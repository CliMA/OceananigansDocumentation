<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library Â· Oceananigans.jl</title><link rel="canonical" href="https://clima.github.io/OceananigansDocumentation/latest/library/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Oceananigans.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../installation_instructions/">Installation instructions</a></li><li><a class="tocitem" href="../using_gpus/">Using GPUs</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../model_setup/architecture/">Architecture</a></li><li><a class="tocitem" href="../model_setup/number_type/">Number type</a></li><li><a class="tocitem" href="../model_setup/grids/">Grid</a></li><li><a class="tocitem" href="../model_setup/clock/">Clock</a></li><li><a class="tocitem" href="../model_setup/coriolis/">Coriolis (rotation)</a></li><li><a class="tocitem" href="../model_setup/tracers/">Tracers</a></li><li><a class="tocitem" href="../model_setup/buoyancy_and_equation_of_state/">Buoyancy and equation of state</a></li><li><a class="tocitem" href="../model_setup/boundary_conditions/">Boundary conditions</a></li><li><a class="tocitem" href="../model_setup/forcing_functions/">Forcing functions</a></li><li><a class="tocitem" href="../model_setup/turbulent_diffusivity_closures_and_les_models/">Turbulent diffusivity closures and LES models</a></li><li><a class="tocitem" href="../model_setup/diagnostics/">Diagnostics</a></li><li><a class="tocitem" href="../model_setup/output_writers/">Output writers</a></li><li><a class="tocitem" href="../model_setup/checkpointing/">Checkpointing</a></li><li><a class="tocitem" href="../model_setup/time_stepping/">Time stepping</a></li><li><a class="tocitem" href="../model_setup/setting_initial_conditions/">Setting initial conditions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Model setup</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../model_setup/overview/">Overview</a></li><li><a class="tocitem" href="../model_setup/architecture/">Architecture</a></li><li><a class="tocitem" href="../model_setup/number_type/">Number type</a></li><li><a class="tocitem" href="../model_setup/grids/">Grid</a></li><li><a class="tocitem" href="../model_setup/clock/">Clock</a></li><li><a class="tocitem" href="../model_setup/coriolis/">Coriolis (rotation)</a></li><li><a class="tocitem" href="../model_setup/tracers/">Tracers</a></li><li><a class="tocitem" href="../model_setup/buoyancy_and_equation_of_state/">Buoyancy and equation of state</a></li><li><a class="tocitem" href="../model_setup/boundary_conditions/">Boundary conditions</a></li><li><a class="tocitem" href="../model_setup/forcing_functions/">Forcing functions</a></li><li><a class="tocitem" href="../model_setup/turbulent_diffusivity_closures_and_les_models/">Turbulent diffusivity closures and LES models</a></li><li><a class="tocitem" href="../model_setup/diagnostics/">Diagnostics</a></li><li><a class="tocitem" href="../model_setup/output_writers/">Output writers</a></li><li><a class="tocitem" href="../model_setup/checkpointing/">Checkpointing</a></li><li><a class="tocitem" href="../model_setup/time_stepping/">Time stepping</a></li><li><a class="tocitem" href="../model_setup/setting_initial_conditions/">Setting initial conditions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Physics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../physics/navier_stokes_and_tracer_conservation/">Navier-Stokes and tracer conservation equations</a></li><li><a class="tocitem" href="../physics/coordinate_system_and_notation/">Coordinate system and notation</a></li><li><a class="tocitem" href="../physics/boussinesq_approximation/">The Boussinesq approximation</a></li><li><a class="tocitem" href="../physics/coriolis_forces/">Coriolis forces</a></li><li><a class="tocitem" href="../physics/buoyancy_and_equations_of_state/">Buoyancy model and equations of state</a></li><li><a class="tocitem" href="../physics/turbulence_closures/">Turbulence closures</a></li><li><a class="tocitem" href="../physics/surface_gravity_waves/">Surface gravity waves and the Craik-Leibovich approximation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Numerical implementation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../numerical_implementation/pressure_decomposition/">Pressure decomposition</a></li><li><a class="tocitem" href="../numerical_implementation/time_stepping/">Time stepping</a></li><li><a class="tocitem" href="../numerical_implementation/finite_volume/">Finite volume method</a></li><li><a class="tocitem" href="../numerical_implementation/spatial_operators/">Spatial operators</a></li><li><a class="tocitem" href="../numerical_implementation/boundary_conditions/">Boundary conditions</a></li><li><a class="tocitem" href="../numerical_implementation/poisson_solvers/">Poisson solvers</a></li><li><a class="tocitem" href="../numerical_implementation/large_eddy_simulation/">Large eddy simulation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Verification experiments</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../verification/taylor_green_vortex/">Taylor-Green vortex</a></li><li><a class="tocitem" href="../verification/stratified_couette_flow/">Stratified Couette flow</a></li><li><a class="tocitem" href="../verification/convergence_tests/">Convergence tests</a></li></ul></li><li><a class="tocitem" href="../gallery/">Gallery</a></li><li><a class="tocitem" href="../benchmarks/">Performance benchmarks</a></li><li><a class="tocitem" href="../contributing/">Contributor&#39;s guide</a></li><li class="is-active"><a class="tocitem" href>Library</a><ul class="internal"><li><a class="tocitem" href="#Architectures"><span>Architectures</span></a></li><li><a class="tocitem" href="#Boundary-conditions"><span>Boundary conditions</span></a></li><li><a class="tocitem" href="#Buoyancy"><span>Buoyancy</span></a></li><li><a class="tocitem" href="#Coriolis"><span>Coriolis</span></a></li><li><a class="tocitem" href="#Diagnostics"><span>Diagnostics</span></a></li><li><a class="tocitem" href="#Fields"><span>Fields</span></a></li><li><a class="tocitem" href="#Forcing"><span>Forcing</span></a></li><li><a class="tocitem" href="#Grids"><span>Grids</span></a></li><li><a class="tocitem" href="#Models"><span>Models</span></a></li><li><a class="tocitem" href="#Output-writers"><span>Output writers</span></a></li><li><a class="tocitem" href="#Time-steppers"><span>Time steppers</span></a></li><li><a class="tocitem" href="#Simulations"><span>Simulations</span></a></li><li><a class="tocitem" href="#Tubrulence-closures"><span>Tubrulence closures</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li><li><a class="tocitem" href="#Abstract-operations"><span>Abstract operations</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">Appendix</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../appendix/staggered_grid/">Staggered grid</a></li><li><a class="tocitem" href="../appendix/fractional_step/">Fractional step method</a></li></ul></li><li><a class="tocitem" href="../function_index/">Function index</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/CliMA/Oceananigans.jl/blob/master/docs/src/library.md" title="Edit on GitHub"><span class="docs-icon fab">ï</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><p>Documenting the public user interface.</p><h2 id="Architectures"><a class="docs-heading-anchor" href="#Architectures">Architectures</a><a id="Architectures-1"></a><a class="docs-heading-anchor-permalink" href="#Architectures" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Architectures.AbstractArchitecture" href="#Oceananigans.Architectures.AbstractArchitecture"><code>Oceananigans.Architectures.AbstractArchitecture</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractArchitecture</code></pre><p>Abstract supertype for architectures supported by Oceananigans.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Architectures.jl#L12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Architectures.CPU" href="#Oceananigans.Architectures.CPU"><code>Oceananigans.Architectures.CPU</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CPU &lt;: AbstractArchitecture</code></pre><p>Run Oceananigans on a single-core of a CPU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Architectures.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Architectures.GPU" href="#Oceananigans.Architectures.GPU"><code>Oceananigans.Architectures.GPU</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GPU &lt;: AbstractArchitecture</code></pre><p>Run Oceananigans on a single NVIDIA CUDA GPU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Architectures.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Architectures.@hascuda-Tuple{Any}" href="#Oceananigans.Architectures.@hascuda-Tuple{Any}"><code>Oceananigans.Architectures.@hascuda</code></a> â <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@hascuda expr</code></pre><p>A macro to compile and execute <code>expr</code> only if CUDA is installed and available. Generally used to wrap expressions that can only be compiled if <code>CuArrays</code> and <code>CUDAnative</code> can be loaded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Architectures.jl#L33-L38">source</a></section></article><h2 id="Boundary-conditions"><a class="docs-heading-anchor" href="#Boundary-conditions">Boundary conditions</a><a id="Boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-conditions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.BCType" href="#Oceananigans.BoundaryConditions.BCType"><code>Oceananigans.BoundaryConditions.BCType</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BCType</code></pre><p>Abstract supertype for boundary condition types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/BoundaryConditions/boundary_condition_types.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.Flux" href="#Oceananigans.BoundaryConditions.Flux"><code>Oceananigans.BoundaryConditions.Flux</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Flux</code></pre><p>A type specifying a boundary condition on the flux of a field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/BoundaryConditions/boundary_condition_types.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.Gradient" href="#Oceananigans.BoundaryConditions.Gradient"><code>Oceananigans.BoundaryConditions.Gradient</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Gradient</code></pre><p>A type specifying a boundary condition on the derivative or gradient of a field. Also called a Neumann boundary condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/BoundaryConditions/boundary_condition_types.jl#L24-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.NormalFlow" href="#Oceananigans.BoundaryConditions.NormalFlow"><code>Oceananigans.BoundaryConditions.NormalFlow</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NormalFlow</code></pre><p>A type specifying the component of a velocity field normal to a boundary.</p><p>Thus <code>NormalFlow</code> can only be applied to <code>u</code> along x, <code>v</code> along y, or <code>w</code> along z. For all other cases â- fields located at (Cell, Cell, Cell), or <code>u</code>, <code>v</code>, and <code>w</code> in (y, z), (x, z), and (x, y), respectively, either <code>Value</code>, <code>Gradient</code>, or <code>Flux</code> conditions must be used.</p><p>Note that <code>NormalFlow</code> differs from a zero <code>Value</code> boundary condition:  <code>Value</code> imposes values at cell centers, while <code>NormalFlow</code> imposes values <em>on</em> a boundary, at cell faces. Only wall-normal components of the velocity field are defined on cell faces with respect to the wall-normal direction, and therefore only wall-normal components of the velocity field are defined on boundaries.  Both tracers and wall-tangential components of velocity fields are defined at cell centers with respect to the wall-normal direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/BoundaryConditions/boundary_condition_types.jl#L40-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.Value" href="#Oceananigans.BoundaryConditions.Value"><code>Oceananigans.BoundaryConditions.Value</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Value</code></pre><p>A type specifying a boundary condition on the value of a field. Also called a Dirchlet boundary condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/BoundaryConditions/boundary_condition_types.jl#L32-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.BoundaryCondition" href="#Oceananigans.BoundaryConditions.BoundaryCondition"><code>Oceananigans.BoundaryConditions.BoundaryCondition</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BoundaryCondition{C&lt;:BCType}(condition)</code></pre><p>Construct a boundary condition of type <code>C</code> with a <code>condition</code> that may be given by a number, an array, or a function with signature:</p><pre><code class="language-none">condition(i, j, grid, clock, state) = # function definition</code></pre><p>that returns a number and where <code>i</code> and <code>j</code> are indices along the boundary.</p><p>Boundary condition types include <code>Periodic</code>, <code>Flux</code>, <code>Value</code>, <code>Gradient</code>, and <code>NormalFlow</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/BoundaryConditions/boundary_condition.jl#L3-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.CoordinateBoundaryConditions" href="#Oceananigans.BoundaryConditions.CoordinateBoundaryConditions"><code>Oceananigans.BoundaryConditions.CoordinateBoundaryConditions</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CoordinateBoundaryConditions(left, right)</code></pre><p>A set of two <code>BoundaryCondition</code>s to be applied along a coordinate x, y, or z.</p><p>The <code>left</code> boundary condition is applied on the negative or lower side of the coordinate while the <code>right</code> boundary condition is applied on the positive or higher side.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/BoundaryConditions/coordinate_boundary_conditions.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.FieldBoundaryConditions" href="#Oceananigans.BoundaryConditions.FieldBoundaryConditions"><code>Oceananigans.BoundaryConditions.FieldBoundaryConditions</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FieldBoundaryConditions</code></pre><p>An alias for <code>NamedTuple{(:x, :y, :z)}</code> that represents a set of three <code>CoordinateBoundaryCondition</code>s applied to a field along x, y, and z.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/BoundaryConditions/field_boundary_conditions.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.FieldBoundaryConditions-Tuple{Any,Any,Any}" href="#Oceananigans.BoundaryConditions.FieldBoundaryConditions-Tuple{Any,Any,Any}"><code>Oceananigans.BoundaryConditions.FieldBoundaryConditions</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">FieldBoundaryConditions(x, y, z)</code></pre><p>Construct a <code>FieldBoundaryConditions</code> using a <code>CoordinateBoundaryCondition</code> for each of the <code>x</code>, <code>y</code>, and <code>z</code> coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/BoundaryConditions/field_boundary_conditions.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.FieldBoundaryConditions-Tuple{Any,Any}" href="#Oceananigans.BoundaryConditions.FieldBoundaryConditions-Tuple{Any,Any}"><code>Oceananigans.BoundaryConditions.FieldBoundaryConditions</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">FieldBoundaryConditions(grid, loc;
      east = DefaultBoundaryCondition(topology(grid)[1], loc[1]),
      west = DefaultBoundaryCondition(topology(grid)[1], loc[1]),
     south = DefaultBoundaryCondition(topology(grid)[2], loc[2]),
     north = DefaultBoundaryCondition(topology(grid)[2], loc[2]),
    bottom = DefaultBoundaryCondition(topology(grid)[3], loc[3]),
       top = DefaultBoundaryCondition(topology(grid)[3], loc[3]))</code></pre><p>Construct <code>FieldBoundaryConditions</code> for a field with location <code>loc</code> (a 3-tuple of <code>Face</code> or <code>Cell</code>) defined on <code>grid</code> (the grid&#39;s topology is what defined the default boundary conditions that are imposed).</p><p>Specific boundary conditions can be applied along the x dimension with the <code>west</code> and <code>east</code> kwargs, along the y-dimension with the <code>south</code> and <code>north</code> kwargs, and along the z-dimension with the <code>bottom</code> and <code>top</code> kwargs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/BoundaryConditions/field_boundary_conditions.jl#L31-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.BoundaryFunction" href="#Oceananigans.BoundaryConditions.BoundaryFunction"><code>Oceananigans.BoundaryConditions.BoundaryFunction</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">    BoundaryFunction{B, X1, X2}(func, parameters=nothing)</code></pre><p>A wrapper for the user-defined boundary condition function <code>func</code>, on the boundary specified by symbol <code>B</code> and at location <code>(X1, X2)</code>, and with <code>parameters</code>.</p><p><strong>Example</strong></p><p>julia&gt; using Oceananigans, Oceananigans.BoundaryConditions, Oceananigans.Fields</p><p>julia&gt; top<em>tracer</em>flux = BoundaryFunction{:z, Cell, Cell}((x, y, t) -&gt; cos(2Ï*x) * cos(t)) (::BoundaryFunction{:z,Cell,Cell,var&quot;#7#8&quot;,Nothing}) (generic function with 1 method)</p><p>julia&gt; top<em>tracer</em>bc = BoundaryCondition(Flux, top<em>tracer</em>flux);</p><p>julia&gt; flux_func(x, y, t, p) = cos(p.k * x) * cos(p.Ï * t); # function with parameters</p><p>julia&gt; parameterized<em>u</em>velocity<em>flux = BoundaryFunction{:z, Face, Cell}(flux</em>func, (k=4Ï, Ï=3.0)) (::BoundaryFunction{:z,Face,Cell,typeof(flux_func),NamedTuple{(:k, :Ï),Tuple{Float64,Float64}}}) (generic function with 1 method)</p><p>julia&gt; top<em>u</em>bc = BoundaryCondition(Flux, parameterized<em>u</em>velocity_flux);</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/BoundaryConditions/boundary_function.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.TracerBoundaryCondition-Tuple{Any,Any,Vararg{Any,N} where N}" href="#Oceananigans.BoundaryConditions.TracerBoundaryCondition-Tuple{Any,Any,Vararg{Any,N} where N}"><code>Oceananigans.BoundaryConditions.TracerBoundaryCondition</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">TracerBoundaryCondition(bctype, B, args...)</code></pre><p>Returns a <code>BoundaryCondition</code> of type <code>bctype</code>, that applies the function <code>func</code> to a tracer on the boundary <code>B</code>, which is one of <code>:x, :y, :z</code>. The boundary function has the signature</p><pre><code class="language-none">`func(Î¾, Î·, t)`</code></pre><p>where <code>t</code> is time, and <code>Î¾</code> and <code>Î·</code> are coordinates along the boundary, eg: <code>(y, z)</code> for <code>B = :x</code>, <code>(x, z)</code> for <code>B = :y</code>, or <code>(x, y)</code> for <code>B = :z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/BoundaryConditions/boundary_function.jl#L81-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.UVelocityBoundaryCondition-Tuple{Any,Any,Vararg{Any,N} where N}" href="#Oceananigans.BoundaryConditions.UVelocityBoundaryCondition-Tuple{Any,Any,Vararg{Any,N} where N}"><code>Oceananigans.BoundaryConditions.UVelocityBoundaryCondition</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">UVelocityBoundaryCondition(bctype, B, args...)</code></pre><p>Returns a <code>BoundaryCondition</code> of type <code>bctype</code>, that applies the function <code>func</code> to <code>u</code>, the <code>x</code>-velocity field, on the boundary <code>B</code>, which is one of <code>:x, :y, :z</code>. The boundary function has the signature</p><pre><code class="language-none">`func(Î¾, Î·, t)`</code></pre><p>where <code>t</code> is time, and <code>Î¾</code> and <code>Î·</code> are coordinates along the boundary, eg: <code>(y, z)</code> for <code>B = :x</code>, <code>(x, z)</code> for <code>B = :y</code>, or <code>(x, y)</code> for <code>B = :z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/BoundaryConditions/boundary_function.jl#L97-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.VVelocityBoundaryCondition-Tuple{Any,Any,Vararg{Any,N} where N}" href="#Oceananigans.BoundaryConditions.VVelocityBoundaryCondition-Tuple{Any,Any,Vararg{Any,N} where N}"><code>Oceananigans.BoundaryConditions.VVelocityBoundaryCondition</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">VVelocityBoundaryCondition(bctype, B, args...)</code></pre><p>Returns a <code>BoundaryCondition</code> of type <code>bctype</code>, that applies the function <code>func</code> to <code>v</code>, the <code>y</code>-velocity field, on the boundary <code>B</code>, which is one of <code>:x, :y, :z</code>. The boundary function has the signature</p><pre><code class="language-none">`func(Î¾, Î·, t)`</code></pre><p>where <code>t</code> is time, and <code>Î¾</code> and <code>Î·</code> are coordinates along the boundary, eg: <code>(y, z)</code> for <code>B = :x</code>, <code>(x, z)</code> for <code>B = :y</code>, or <code>(x, y)</code> for <code>B = :z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/BoundaryConditions/boundary_function.jl#L113-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.WVelocityBoundaryCondition-Tuple{Any,Any,Vararg{Any,N} where N}" href="#Oceananigans.BoundaryConditions.WVelocityBoundaryCondition-Tuple{Any,Any,Vararg{Any,N} where N}"><code>Oceananigans.BoundaryConditions.WVelocityBoundaryCondition</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">VVelocityBoundaryCondition(bctype, B, args...)</code></pre><p>Returns a <code>BoundaryCondition</code> of type <code>bctype</code>, that applies the function <code>func</code> to <code>w</code>, the <code>z</code>-velocity field, on the boundary <code>B</code>, which is one of <code>:x, :y, :z</code>. The boundary function has the signature</p><pre><code class="language-none">`func(Î¾, Î·, t)`</code></pre><p>where <code>t</code> is time, and <code>Î¾</code> and <code>Î·</code> are coordinates along the boundary, eg: <code>(y, z)</code> for <code>B = :x</code>, <code>(x, z)</code> for <code>B = :y</code>, or <code>(x, y)</code> for <code>B = :z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/BoundaryConditions/boundary_function.jl#L129-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.ParameterizedBoundaryConditionFunction" href="#Oceananigans.BoundaryConditions.ParameterizedBoundaryConditionFunction"><code>Oceananigans.BoundaryConditions.ParameterizedBoundaryConditionFunction</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ParameterizedBoundaryConditionFunction(func, parameters)</code></pre><p>A wrapper for boundary condition functions implemented as functions with parameters. The boundary condition <code>func</code> is called with the signature</p><pre><code class="language-none">`func(i, j, grid, clock, state, parameters)`</code></pre><p>where <code>i, j</code> are the indices along the boundary, <code>grid</code> and <code>clock</code> are <code>model.grid</code> and <code>model.clock</code>, and <code>state</code> is a <code>NamedTuple</code> with fields <code>velocities</code>, <code>tracers</code>, and <code>diffusivities</code>, which are each <code>NamedTuple</code>s of <code>OffsetArray</code>s that reference the data associated with their corresponding fields.</p><p><strong>Example</strong></p><p>@inline linear_drag(i, j, grid, clock, state, parameters) =      @inbounds - parameters.Î¼ * state.velocities.u[i, j, 1]</p><p>u<em>boundary</em>condition = ParameterizedBoundaryCondition(linear_drag, (Î¼=Ï,))</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/BoundaryConditions/parameterized_boundary_condition.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.ParameterizedBoundaryCondition-Tuple{Any,Any,Any}" href="#Oceananigans.BoundaryConditions.ParameterizedBoundaryCondition-Tuple{Any,Any,Any}"><code>Oceananigans.BoundaryConditions.ParameterizedBoundaryCondition</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ParameterizedBoundaryCondition(bctype, func, parameters)</code></pre><p>Returns a <code>BoundaryCondition</code> of <code>bctype</code> with a <code>ParameterizedBoundaryConditionFunction</code> with function <code>func</code> and <code>parameters</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/BoundaryConditions/parameterized_boundary_condition.jl#L27-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.fill_halo_regions!-Tuple{AbstractArray,Any,Any,Any,Vararg{Any,N} where N}" href="#Oceananigans.BoundaryConditions.fill_halo_regions!-Tuple{AbstractArray,Any,Any,Any,Vararg{Any,N} where N}"><code>Oceananigans.BoundaryConditions.fill_halo_regions!</code></a> â <span class="docstring-category">Method</span></header><section><div><p>Fill halo regions in x, y, and z for a given field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/BoundaryConditions/fill_halo_regions.jl#L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.fill_halo_regions!-Tuple{Union{Tuple, NamedTuple},Any,Vararg{Any,N} where N}" href="#Oceananigans.BoundaryConditions.fill_halo_regions!-Tuple{Union{Tuple, NamedTuple},Any,Vararg{Any,N} where N}"><code>Oceananigans.BoundaryConditions.fill_halo_regions!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fill_halo_regions!(fields, arch)</code></pre><p>Fill halo regions for each field in the tuple <code>fields</code> according to their boundary conditions, possibly recursing into <code>fields</code> if it is a nested tuple-of-tuples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/BoundaryConditions/fill_halo_regions.jl#L7-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.apply_x_bcs!-Tuple{Any,Any,Any,Vararg{Any,N} where N}" href="#Oceananigans.BoundaryConditions.apply_x_bcs!-Tuple{Any,Any,Any,Vararg{Any,N} where N}"><code>Oceananigans.BoundaryConditions.apply_x_bcs!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">apply_x_bcs!(Gc, arch, grid, args...)</code></pre><p>Apply flux boundary conditions to a field <code>c</code> by adding the associated flux divergence to the source term <code>Gc</code> at the left and right.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/BoundaryConditions/apply_flux_bcs.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.apply_y_bcs!-Tuple{Any,Any,Any,Vararg{Any,N} where N}" href="#Oceananigans.BoundaryConditions.apply_y_bcs!-Tuple{Any,Any,Any,Vararg{Any,N} where N}"><code>Oceananigans.BoundaryConditions.apply_y_bcs!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">apply_y_bcs!(Gc, arch, grid, args...)</code></pre><p>Apply flux boundary conditions to a field <code>c</code> by adding the associated flux divergence to the source term <code>Gc</code> at the left and right.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/BoundaryConditions/apply_flux_bcs.jl#L17-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.apply_z_bcs!-Tuple{Any,Any,Any,Vararg{Any,N} where N}" href="#Oceananigans.BoundaryConditions.apply_z_bcs!-Tuple{Any,Any,Any,Vararg{Any,N} where N}"><code>Oceananigans.BoundaryConditions.apply_z_bcs!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">apply_z_bcs!(Gc, arch, grid, args...)</code></pre><p>Apply flux boundary conditions to a field <code>c</code> by adding the associated flux divergence to the source term <code>Gc</code> at the top and bottom.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/BoundaryConditions/apply_flux_bcs.jl#L26-L31">source</a></section></article><h2 id="Buoyancy"><a class="docs-heading-anchor" href="#Buoyancy">Buoyancy</a><a id="Buoyancy-1"></a><a class="docs-heading-anchor-permalink" href="#Buoyancy" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Buoyancy.SeawaterBuoyancy" href="#Oceananigans.Buoyancy.SeawaterBuoyancy"><code>Oceananigans.Buoyancy.SeawaterBuoyancy</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SeawaterBuoyancy{FT, EOS, T, S} &lt;: AbstractBuoyancy{EOS}</code></pre><p>Buoyancy model for seawater. <code>T</code> and <code>S</code> are either <code>nothing</code> if both temperature and salinity are active, or of type <code>FT</code> if temperature or salinity are constant, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Buoyancy/seawater_buoyancy.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Buoyancy.SeawaterBuoyancy" href="#Oceananigans.Buoyancy.SeawaterBuoyancy"><code>Oceananigans.Buoyancy.SeawaterBuoyancy</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SeawaterBuoyancy([FT=Float64;] gravitational_acceleration = g_Earth,
                              equation_of_state = LinearEquationOfState(FT), 
                              constant_temperature = false, constant_salinity = false)</code></pre><p>Returns parameters for a temperature- and salt-stratified seawater buoyancy model with a <code>gravitational_acceleration</code> constant (typically called &#39;g&#39;), and an <code>equation_of_state</code> that related temperature and salinity (or conservative temperature and absolute salinity) to density anomalies and buoyancy. If either <code>temperature</code> or <code>salinity</code> are specified, buoyancy is calculated</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Buoyancy/seawater_buoyancy.jl#L19-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Buoyancy.âx_b-Tuple{Any,Any,Any,Any,SeawaterBuoyancy,Any}" href="#Oceananigans.Buoyancy.âx_b-Tuple{Any,Any,Any,Any,SeawaterBuoyancy,Any}"><code>Oceananigans.Buoyancy.âx_b</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">âx_b(i, j, k, grid, b::SeawaterBuoyancy, C)</code></pre><p>Returns the x-derivative of buoyancy for temperature and salt-stratified water,</p><div>\[â_x b = g ( Î± â_x Î - Î² â_x sá´¬ ) ,\]</div><p>where <code>g</code> is gravitational acceleration, <code>Î±</code> is the thermal expansion coefficient, <code>Î²</code> is the haline contraction coefficient, <code>Î</code> is conservative temperature, and <code>sá´¬</code> is absolute salinity.</p><p>Note: In Oceananigans, <code>model.tracers.T</code> is conservative temperature and <code>model.tracers.S</code> is absolute salinity.</p><p>Note that <code>âx_Î</code>, <code>âx_sá´¬</code>, <code>Î±</code>, and <code>Î²</code> are all evaluated at cell interfaces in <code>x</code> and cell centers in <code>y</code> and <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Buoyancy/seawater_buoyancy.jl#L54-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Buoyancy.ây_b-Tuple{Any,Any,Any,Any,SeawaterBuoyancy,Any}" href="#Oceananigans.Buoyancy.ây_b-Tuple{Any,Any,Any,Any,SeawaterBuoyancy,Any}"><code>Oceananigans.Buoyancy.ây_b</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ây_b(i, j, k, grid, b::SeawaterBuoyancy, C)</code></pre><p>Returns the y-derivative of buoyancy for temperature and salt-stratified water,</p><div>\[â_y b = g ( Î± â_y Î - Î² â_y sá´¬ ) ,\]</div><p>where <code>g</code> is gravitational acceleration, <code>Î±</code> is the thermal expansion coefficient, <code>Î²</code> is the haline contraction coefficient, <code>Î</code> is conservative temperature, and <code>sá´¬</code> is absolute salinity.</p><p>Note: In Oceananigans, <code>model.tracers.T</code> is conservative temperature and <code>model.tracers.S</code> is absolute salinity.</p><p>Note that <code>ây_Î</code>, <code>ây_sá´¬</code>, <code>Î±</code>, and <code>Î²</code> are all evaluated at cell interfaces in <code>y</code> and cell centers in <code>x</code> and <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Buoyancy/seawater_buoyancy.jl#L80-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Buoyancy.âz_b-Tuple{Any,Any,Any,Any,SeawaterBuoyancy,Any}" href="#Oceananigans.Buoyancy.âz_b-Tuple{Any,Any,Any,Any,SeawaterBuoyancy,Any}"><code>Oceananigans.Buoyancy.âz_b</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">âz_b(i, j, k, grid, b::SeawaterBuoyancy, C)</code></pre><p>Returns the vertical derivative of buoyancy for temperature and salt-stratified water,</p><div>\[â_z b = N^2 = g ( Î± â_z Î - Î² â_z sá´¬ ) ,\]</div><p>where <code>g</code> is gravitational acceleration, <code>Î±</code> is the thermal expansion coefficient, <code>Î²</code> is the haline contraction coefficient, <code>Î</code> is conservative temperature, and <code>sá´¬</code> is absolute salinity.</p><p>Note: In Oceananigans, <code>model.tracers.T</code> is conservative temperature and <code>model.tracers.S</code> is absolute salinity.</p><p>Note that <code>âz_Î</code>, <code>âz_sá´¬</code>, <code>Î±</code>, and <code>Î²</code> are all evaluated at cell interfaces in <code>z</code> and cell centers in <code>x</code> and <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Buoyancy/seawater_buoyancy.jl#L106-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Buoyancy.BuoyancyTracer" href="#Oceananigans.Buoyancy.BuoyancyTracer"><code>Oceananigans.Buoyancy.BuoyancyTracer</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BuoyancyTracer &lt;: AbstractBuoyancy{Nothing}</code></pre><p>Type indicating that the tracer <code>b</code> represents buoyancy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Buoyancy/Buoyancy.jl#L51-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Buoyancy.LinearEquationOfState" href="#Oceananigans.Buoyancy.LinearEquationOfState"><code>Oceananigans.Buoyancy.LinearEquationOfState</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LinearEquationOfState{FT} &lt;: AbstractEquationOfState</code></pre><p>Linear equation of state for seawater.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Buoyancy/linear_equation_of_state.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Buoyancy.LinearEquationOfState" href="#Oceananigans.Buoyancy.LinearEquationOfState"><code>Oceananigans.Buoyancy.LinearEquationOfState</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LinearEquationOfState([FT=Float64;] Î±=1.67e-4, Î²=7.80e-4)</code></pre><p>Returns parameters for a linear equation of state for seawater with thermal expansion coefficient <code>Î±</code> [Kâ»Â¹] and haline contraction coefficient <code>Î²</code> [pptâ»Â¹]. The buoyancy perturbation associated with a linear equation of state is</p><div>\[    b = g (Î± T - Î² S)\]</div><p>Default constants are taken from Table 1.2 (page 33) of Vallis, &quot;Atmospheric and Oceanic Fluid Dynamics: Fundamentals and Large-Scale Circulation&quot; (2ed, 2017).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Buoyancy/linear_equation_of_state.jl#L11-L24">source</a></section></article><h2 id="Coriolis"><a class="docs-heading-anchor" href="#Coriolis">Coriolis</a><a id="Coriolis-1"></a><a class="docs-heading-anchor-permalink" href="#Coriolis" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.FPlane" href="#Oceananigans.Coriolis.FPlane"><code>Oceananigans.Coriolis.FPlane</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FPlane{FT} &lt;: AbstractRotation</code></pre><p>A parameter object for constant rotation around a vertical axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Coriolis/f_plane.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.FPlane" href="#Oceananigans.Coriolis.FPlane"><code>Oceananigans.Coriolis.FPlane</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FPlane([FT=Float64;] f=nothing, rotation_rate=Î©_Earth, latitude=nothing)</code></pre><p>Returns a parameter object for constant rotation at the angular frequency <code>f/2</code>, and therefore with background vorticity <code>f</code>, around a vertical axis. If <code>f</code> is not specified, it is calculated from <code>rotation_rate</code> and <code>latitude</code> according to the relation `f = 2<em>rotation_rate</em>sind(latitude).</p><p>By default, <code>rotation_rate</code> is assumed to be Earth&#39;s.</p><p>Also called <code>FPlane</code>, after the &quot;f-plane&quot; approximation for the local effect of a planet&#39;s rotation in a planar coordinate system tangent to the planet&#39;s surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Coriolis/f_plane.jl#L10-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.NonTraditionalFPlane" href="#Oceananigans.Coriolis.NonTraditionalFPlane"><code>Oceananigans.Coriolis.NonTraditionalFPlane</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NonTraditionalFPlane{FT} &lt;: AbstractRotation</code></pre><p>A Coriolis implementation that facilitates non-traditional Coriolis terms in the zonal and vertical momentum equations along with the traditional Coriolis terms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Coriolis/f_plane.jl#L48-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.NonTraditionalFPlane" href="#Oceananigans.Coriolis.NonTraditionalFPlane"><code>Oceananigans.Coriolis.NonTraditionalFPlane</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NonTraditionalFPlane([FT=Float64;] fz=nothing, fy=nothing,
                                   rotation_rate=Î©_Earth, latitude=nothing)</code></pre><p>Returns a parameter object for constant rotation about an axis in the <code>y-z</code> plane with <code>y</code>- and <code>z</code>-components <code>fy/2</code> and <code>fz/2</code>, and the background vorticity is <code>(0, fy, fz)</code>.</p><p>In oceanography <code>fz</code> and <code>fy</code> represent the components of planetary voriticity which are perpendicular and parallel to the ocean surface in a domain in which <code>x, y, z</code> correspond to the directions east, north, and up.</p><p>If <code>fz</code> and <code>fy</code> are not specified, they are calculated from <code>rotation_rate</code> and <code>latitude</code> according to the relations <code>fz = 2*rotation_rate*sind(latitude)</code> and <code>fy = 2*rotation_rate*cosd(latitude)</code>, respectively. By default, <code>rotation_rate</code> is assumed to be Earth&#39;s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Coriolis/f_plane.jl#L59-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.BetaPlane" href="#Oceananigans.Coriolis.BetaPlane"><code>Oceananigans.Coriolis.BetaPlane</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BetaPlane{T} &lt;: AbstractRotation</code></pre><p>A parameter object for meridionally increasing Coriolis parameter (<code>f = fâ + Î²y</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Coriolis/beta_plane.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.BetaPlane" href="#Oceananigans.Coriolis.BetaPlane"><code>Oceananigans.Coriolis.BetaPlane</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BetaPlane([T=Float64;] fâ=nothing, Î²=nothing,
                       rotation_rate=Î©_Earth, latitude=nothing, radius=R_Earth)</code></pre><p>A parameter object for meridionally increasing Coriolis parameter (<code>f = fâ + Î²y</code>).</p><p>The user may specify both <code>fâ</code> and <code>Î²</code>, or the three parameters <code>rotation_rate</code>, <code>latitude</code>, and <code>radius</code> that specify the rotation rate and radius of a planet, and the central latitude at which the <code>Î²</code>-plane approximation is to be made.</p><p>By default, the <code>rotation_rate</code> and planet <code>radius</code> is assumed to be Earth&#39;s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Coriolis/beta_plane.jl#L11-L22">source</a></section></article><h2 id="Diagnostics"><a class="docs-heading-anchor" href="#Diagnostics">Diagnostics</a><a id="Diagnostics-1"></a><a class="docs-heading-anchor-permalink" href="#Diagnostics" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.HorizontalAverage" href="#Oceananigans.Diagnostics.HorizontalAverage"><code>Oceananigans.Diagnostics.HorizontalAverage</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HorizontalAverage{F, R, P, I, Î©} &lt;: AbstractDiagnostic</code></pre><p>A diagnostic for computing horizontal average of a field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Diagnostics/horizontal_average.jl#L6-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.HorizontalAverage-Tuple{Any}" href="#Oceananigans.Diagnostics.HorizontalAverage-Tuple{Any}"><code>Oceananigans.Diagnostics.HorizontalAverage</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">HorizontalAverage(model, field; frequency=nothing, interval=nothing, return_type=Array)</code></pre><p>Construct a <code>HorizontalAverage</code> of <code>field</code>.</p><p>After the horizontal average is computed it will be stored in the <code>result</code> property.</p><p>The <code>HorizontalAverage</code> can be used as a callable object that computes and returns the horizontal average.</p><p>A <code>frequency</code> or <code>interval</code> (or both) can be passed to indicate how often to run this diagnostic if it is part of <code>model.diagnostics</code>. <code>frequency</code> is a number of iterations while <code>interval</code> is a time interval in units of <code>model.clock.time</code>.</p><p>A <code>return_type</code> can be used to specify the type returned when the <code>HorizontalAverage</code> is used as a callable object. The default <code>return_type=Array</code> is useful when running a GPU model and you want to save the output to disk by passing it to an output writer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Diagnostics/horizontal_average.jl#L21-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.run_diagnostic-Tuple{Any,HorizontalAverage}" href="#Oceananigans.Diagnostics.run_diagnostic-Tuple{Any,HorizontalAverage}"><code>Oceananigans.Diagnostics.run_diagnostic</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">run_diagnostic(model, havg::HorizontalAverage{NTuple{1}})</code></pre><p>Compute the horizontal average of <code>havg.field</code> and store the result in <code>havg.result</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Diagnostics/horizontal_average.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.TimeSeries" href="#Oceananigans.Diagnostics.TimeSeries"><code>Oceananigans.Diagnostics.TimeSeries</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TimeSeries{D, Î©, I, T, TT} &lt;: AbstractDiagnostic</code></pre><p>A diagnostic for collecting and storing time series.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Diagnostics/time_series.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.TimeSeries-Tuple{Any,Any}" href="#Oceananigans.Diagnostics.TimeSeries-Tuple{Any,Any}"><code>Oceananigans.Diagnostics.TimeSeries</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">TimeSeries(diagnostic, model; frequency=nothing, interval=nothing)</code></pre><p>A <code>TimeSeries</code> <code>Diagnostic</code> that records a time series of <code>diagnostic(model)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; model = IncompressibleModel(grid=RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1)));

julia&gt; max_u = TimeSeries(FieldMaximum(abs, model.velocities.u), model; frequency=1)

julia&gt; model.diagnostics[:max_u] = max_u; data(model.velocities.u) .= Ï; time_step!(model, Nt=3, Ît=1e-16)

julia&gt; max_u.data
3-element Array{Float64,1}:
 3.141592653589793
 3.1415926025389127
 3.1415925323439517</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Diagnostics/time_series.jl#L14-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.TimeSeries-Tuple{NamedTuple,Any}" href="#Oceananigans.Diagnostics.TimeSeries-Tuple{NamedTuple,Any}"><code>Oceananigans.Diagnostics.TimeSeries</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">TimeSeries(diagnostics::NamedTuple, model; frequency=nothing, interval=nothing)</code></pre><p>A <code>TimeSeries</code> <code>Diagnostic</code> that records a <code>NamedTuple</code> of time series of <code>diag(model)</code> for each <code>diag</code> in <code>diagnostics</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; model = IncompressibleModel(grid=RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1))); Ît = 1.0;

julia&gt; cfl = TimeSeries((adv=AdvectiveCFL(Ît), diff=DiffusiveCFL(Ît)), model; frequency=1);

julia&gt; model.diagnostics[:cfl] = cfl; time_step!(model, Nt=3, Ît=Ît)

julia&gt; cfl.data
(adv = [0.0, 0.0, 0.0, 0.0], diff = [0.0002688, 0.0002688, 0.0002688, 0.0002688])

julia&gt; cfl.adv
4-element Array{Float64,1}:
 0.0
 0.0
 0.0
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Diagnostics/time_series.jl#L49-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.CFL" href="#Oceananigans.Diagnostics.CFL"><code>Oceananigans.Diagnostics.CFL</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CFL{D, S}</code></pre><p>An object for computing the Courant-Freidrichs-Lewy (CFL) number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Diagnostics/cfl.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.CFL-Tuple{Any}" href="#Oceananigans.Diagnostics.CFL-Tuple{Any}"><code>Oceananigans.Diagnostics.CFL</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CFL(Ît [, timescale=Oceananigans.cell_advection_timescale])</code></pre><p>Returns an object for computing the Courant-Freidrichs-Lewy (CFL) number associated with time step or <code>TimeStepWizard</code> <code>Ît</code> and <code>timescale</code>.</p><p>See also <code>AdvectiveCFL</code> and <code>DiffusiveCFL</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Diagnostics/cfl.jl#L14-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.AdvectiveCFL-Tuple{Any}" href="#Oceananigans.Diagnostics.AdvectiveCFL-Tuple{Any}"><code>Oceananigans.Diagnostics.AdvectiveCFL</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">AdvectiveCFL(Ît)</code></pre><p>Returns an object for computing the Courant-Freidrichs-Lewy (CFL) number associated with time step or <code>TimeStepWizard</code> <code>Ît</code> and the time scale for advection across a cell.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; model = IncompressibleModel(grid=RegularCartesianGrid(size=(16, 16, 16), length=(8, 8, 8)));

julia&gt; cfl = AdvectiveCFL(1.0);

julia&gt; data(model.velocities.u) .= Ï;

julia&gt; cfl(model)
6.283185307179586</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Diagnostics/cfl.jl#L26-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.DiffusiveCFL-Tuple{Any}" href="#Oceananigans.Diagnostics.DiffusiveCFL-Tuple{Any}"><code>Oceananigans.Diagnostics.DiffusiveCFL</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">DiffusiveCFL(Ît)</code></pre><p>Returns an object for computing the diffusive Courant-Freidrichs-Lewy (CFL) number associated with time step or <code>TimeStepWizard</code> <code>Ît</code> and the time scale for diffusion across a cell associated with <code>model.closure</code>.</p><p>The maximum diffusive CFL number among viscosity and all tracer diffusivities is returned.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; model = IncompressibleModel(grid=RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1)));

julia&gt; dcfl = DiffusiveCFL(0.1);

julia&gt; dcfl(model)
2.688e-5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Diagnostics/cfl.jl#L48-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.FieldMaximum" href="#Oceananigans.Diagnostics.FieldMaximum"><code>Oceananigans.Diagnostics.FieldMaximum</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FieldMaximum(mapping, field)</code></pre><p>An object for calculating the maximum of a <code>mapping</code> function applied element-wise to <code>field</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; model = IncompressibleModel(grid=RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1)));

julia&gt; max_abs_u = FieldMaximum(abs, model.velocities.u);

julia&gt; max_wÂ² = FieldMaximum(x-&gt;x^2, model.velocities.w);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Diagnostics/field_maximum.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.NaNChecker" href="#Oceananigans.Diagnostics.NaNChecker"><code>Oceananigans.Diagnostics.NaNChecker</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NaNChecker{F} &lt;: AbstractDiagnostic</code></pre><p>A diagnostic that checks for <code>NaN</code> values and aborts the simulation if any are found.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Diagnostics/nan_checker.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.NaNChecker-Tuple{Any}" href="#Oceananigans.Diagnostics.NaNChecker-Tuple{Any}"><code>Oceananigans.Diagnostics.NaNChecker</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">NaNChecker(model; frequency, fields)</code></pre><p>Construct a <code>NaNChecker</code> for <code>model</code>. <code>fields</code> should be a <code>Dict{Symbol,Field}</code>. A <code>frequency</code> should be passed to indicate how often to check for NaNs (in number of iterations).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Diagnostics/nan_checker.jl#L11-L17">source</a></section></article><h2 id="Fields"><a class="docs-heading-anchor" href="#Fields">Fields</a><a id="Fields-1"></a><a class="docs-heading-anchor-permalink" href="#Fields" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.AbstractField" href="#Oceananigans.Fields.AbstractField"><code>Oceananigans.Fields.AbstractField</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractField{X, Y, Z, A, G}</code></pre><p>Abstract supertype for fields located at <code>(X, Y, Z)</code> with data stored in a container of type <code>A</code>. The field is defined on a grid <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Fields/field.jl#L17-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.Field" href="#Oceananigans.Fields.Field"><code>Oceananigans.Fields.Field</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Field{X, Y, Z, A, G, B} &lt;: AbstractField{X, Y, Z, A, G}</code></pre><p>A field defined at the location (<code>X</code>, <code>Y</code>, <code>Z</code>), each of which can be either <code>Cell</code> or <code>Face</code>, and with data stored in a container of type <code>A</code> (typically an array). The field is defined on a grid <code>G</code> and has field boundary conditions <code>B</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Fields/field.jl#L25-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.Field" href="#Oceananigans.Fields.Field"><code>Oceananigans.Fields.Field</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Field(X, Y, Z, arch, grid, [  bcs = FieldBoundaryConditions(grid, (X, Y, Z)),
                             data = zeros(arch, grid, (X, Y, Z)) ] )</code></pre><p>Construct a <code>Field</code> on <code>grid</code> with <code>data</code> on architecture <code>arch</code> with boundary conditions <code>bcs</code>. Each of <code>(X, Y, Z)</code> is either <code>Cell</code> or <code>Face</code> and determines  the field&#39;s location in <code>(x, y, z)</code>.</p><p><strong>Example</strong></p><p>julia&gt; Ï = Field(Face, Face, Cell, CPU(), RegularCartesianmodel.grid)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Fields/field.jl#L50-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.Field-Tuple{Tuple,Vararg{Any,N} where N}" href="#Oceananigans.Fields.Field-Tuple{Tuple,Vararg{Any,N} where N}"><code>Oceananigans.Fields.Field</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Field(L::Tuple, arch, grid, data, bcs)</code></pre><p>Construct a <code>Field</code> at the location defined by the 3-tuple <code>L</code>, whose elements are <code>Cell</code> or <code>Face</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Fields/field.jl#L79-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.CellField" href="#Oceananigans.Fields.CellField"><code>Oceananigans.Fields.CellField</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">CellField([ FT=eltype(grid) ], arch::AbstractArchitecture, grid, 
          [  bcs = TracerBoundaryConditions(grid),
            data = zeros(FT, arch, grid, (Cell, Cell, Cell) ] )</code></pre><p>Return a <code>Field{Cell, Cell, Cell}</code> on architecture <code>arch</code> and <code>grid</code> containing <code>data</code> with field boundary conditions <code>bcs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Fields/field.jl#L91-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.XFaceField" href="#Oceananigans.Fields.XFaceField"><code>Oceananigans.Fields.XFaceField</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">XFaceField([ FT=eltype(grid) ], arch::AbstractArchitecture, grid,
           [  bcs = UVelocityBoundaryConditions(grid),
             data = zeros(FT, arch, grid, (Face, Cell, Cell) ] )</code></pre><p>Return a <code>Field{Face, Cell, Cell}</code> on architecture <code>arch</code> and <code>grid</code> containing <code>data</code> with field boundary conditions <code>bcs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Fields/field.jl#L106-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.YFaceField" href="#Oceananigans.Fields.YFaceField"><code>Oceananigans.Fields.YFaceField</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">YFaceField([ FT=eltype(grid) ], arch::AbstractArchitecture, grid,
           [  bcs = VVelocityBoundaryConditions(grid),
             data = zeros(FT, arch, grid, (Cell, Face, Cell)) ] )</code></pre><p>Return a <code>Field{Cell, Face, Cell}</code> on architecture <code>arch</code> and <code>grid</code> containing <code>data</code> with field boundary conditions <code>bcs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Fields/field.jl#L121-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.ZFaceField" href="#Oceananigans.Fields.ZFaceField"><code>Oceananigans.Fields.ZFaceField</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ZFaceField([ FT=eltype(grid) ], arch::AbstractArchitecture, grid,
           [  bcs = WVelocityBoundaryConditions(grid),
             data = zeros(FT, arch, grid, (Cell, Cell, Face)) ] )</code></pre><p>Return a <code>Field{Cell, Cell, Face}</code> on architecture <code>arch</code> and <code>grid</code> containing <code>data</code> with field boundary conditions <code>bcs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Fields/field.jl#L136-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.data-Tuple{Any}" href="#Oceananigans.Fields.data-Tuple{Any}"><code>Oceananigans.Fields.data</code></a> â <span class="docstring-category">Method</span></header><section><div><p>Returns <code>f.data</code> for <code>f::Field</code> or <code>f</code> for `f::AbstractArray.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Fields/field.jl#L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.interior-Union{Tuple{Field{X,Y,Z,A,G,B} where B where G where A}, Tuple{Z}, Tuple{Y}, Tuple{X}} where Z where Y where X" href="#Oceananigans.Fields.interior-Union{Tuple{Field{X,Y,Z,A,G,B} where B where G where A}, Tuple{Z}, Tuple{Y}, Tuple{X}} where Z where Y where X"><code>Oceananigans.Fields.interior</code></a> â <span class="docstring-category">Method</span></header><section><div><p>Returns a view of <code>f</code> that excludes halo points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Fields/field.jl#L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.interiorparent-Union{Tuple{Field{X,Y,Z,A,G,B} where B where G where A}, Tuple{Z}, Tuple{Y}, Tuple{X}} where Z where Y where X" href="#Oceananigans.Fields.interiorparent-Union{Tuple{Field{X,Y,Z,A,G,B} where B where G where A}, Tuple{Z}, Tuple{Y}, Tuple{X}} where Z where Y where X"><code>Oceananigans.Fields.interiorparent</code></a> â <span class="docstring-category">Method</span></header><section><div><p>Returns a reference (not a view) to the interior points of <code>field.data.parent.</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Fields/field.jl#L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.location-Union{Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}, Tuple{Z}, Tuple{Y}, Tuple{X}} where Z where Y where X" href="#Oceananigans.Fields.location-Union{Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}, Tuple{Z}, Tuple{Y}, Tuple{X}} where Z where Y where X"><code>Oceananigans.Fields.location</code></a> â <span class="docstring-category">Method</span></header><section><div><p>Returns the location <code>(X, Y, Z)</code> of an <code>AbstractField{X, Y, Z}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Fields/field.jl#L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.set!-Tuple{Any}" href="#Oceananigans.Fields.set!-Tuple{Any}"><code>Oceananigans.Fields.set!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set!(model; kwargs...)</code></pre><p>Set velocity and tracer fields of <code>model</code>. The keyword arguments <code>kwargs...</code> take the form <code>name=data</code>, where <code>name</code> refers to one of the fields of <code>model.velocities</code> or <code>model.tracers</code>, and the <code>data</code> may be an array, a function with arguments <code>(x, y, z)</code>, or any data type for which a <code>set!(Ï::AbstractField, data)</code> function exists.</p><p><strong>Example</strong></p><pre><code class="language-julia">model = IncompressibleModel(grid=RegularCartesianGrid(size=(32, 32, 32), length=(1, 1, 1))

# Set u to a parabolic function of z, v to random numbers damped
# at top and bottom, and T to some silly array of half zeros,
# half random numbers.

uâ(x, y, z) = z/model.grid.Lz * (1 + z/model.grid.Lz)
vâ(x, y, z) = 1e-3 * rand() * uâ(x, y, z)

Tâ = rand(size(model.grid)...)
Tâ[Tâ .&lt; 0.5] .= 0

set!(model, u=uâ, v=vâ, T=Tâ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Fields/set!.jl#L6-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.set!-Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A&lt;:(OffsetArrays.OffsetArray{T,D,#s110} where #s110&lt;:Array where D where T) where Z where Y where X,Array}" href="#Oceananigans.Fields.set!-Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A&lt;:(OffsetArrays.OffsetArray{T,D,#s110} where #s110&lt;:Array where D where T) where Z where Y where X,Array}"><code>Oceananigans.Fields.set!</code></a> â <span class="docstring-category">Method</span></header><section><div><p>Set the CPU field <code>u</code> to the array <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Fields/set!.jl#L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.set!-Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A&lt;:(OffsetArrays.OffsetArray{T,D,#s110} where #s110&lt;:Array where D where T) where Z where Y where X,Function}" href="#Oceananigans.Fields.set!-Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A&lt;:(OffsetArrays.OffsetArray{T,D,#s110} where #s110&lt;:Array where D where T) where Z where Y where X,Function}"><code>Oceananigans.Fields.set!</code></a> â <span class="docstring-category">Method</span></header><section><div><p>Set the CPU field <code>u</code> data to the function <code>f(x, y, z)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Fields/set!.jl#L102">source</a></section></article><h2 id="Forcing"><a class="docs-heading-anchor" href="#Forcing">Forcing</a><a id="Forcing-1"></a><a class="docs-heading-anchor-permalink" href="#Forcing" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcing.SimpleForcing" href="#Oceananigans.Forcing.SimpleForcing"><code>Oceananigans.Forcing.SimpleForcing</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SimpleForcing{X, Y, Z, M, F, P}</code></pre><p>A callable object that implements a &#39;simple&#39; forcing function on a field at the location <code>X, Y, Z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Forcing/simple_forcing.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcing.SimpleForcing-Tuple{Any}" href="#Oceananigans.Forcing.SimpleForcing-Tuple{Any}"><code>Oceananigans.Forcing.SimpleForcing</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SimpleForcing(forcing; parameters=nothing, field_in_signature=false)</code></pre><p>Construct forcing for a field named <code>field_name</code> based on a <code>forcing</code> function, with optional parameters. The keyword arguments determine the expected function  signature of <code>forcing</code>. The keyword <code>field_in_signature=true</code> specifies that the field being forced appears in the user-defined function signature. If <code>parameters</code> is anything other than <code>nothing</code>, it is assumed to be part of the function signature of <code>forcing</code>.</p><p>The four possible signatures of function <code>forcing</code> are thus</p><ul><li><p><code>parameters=nothing, field_in_signature=false</code>:</p><p><code>forcing(x, y, z, t)</code></p></li></ul><p>This is the function signature for default choices of <code>parameters</code> and <code>field_in_signature</code>.</p><ul><li><p><code>field_in_signature=false</code>, specified parameters:</p><p><code>forcing(x, y, z, t, parameters)</code>,</p></li></ul><p>where <code>parameters</code> is the object passed as keyword argument. To compile on the GPU this must be a simple object; typically, a <code>NamedTuple</code> of floats and other constants.</p><ul><li><p><code>parameters=nothing, field_in_signature=true</code>:</p><p><code>forcing(x, y, z, t, field)</code></p></li></ul><p>where <code>field</code> is the value of the field the forcing is applied to at <code>x, y, z</code>.</p><ul><li><p><code>field_in_signature=true</code>, specified parameters:</p><p><code>forcing(x, y, z, t, field, parameters)</code></p></li></ul><p><strong>Examples</strong></p><ul><li>The simplest case: no parameters, additive forcing:</li></ul><pre><code class="language-julia">julia&gt; const a = 2.1

julia&gt; fun_forcing(x, y, z, t) = a * exp(z) * cos(t)

julia&gt; u_forcing = SimpleForcing(fun_forcing)</code></pre><ul><li>Parameterized, additive forcing:</li></ul><pre><code class="language-julia">julia&gt; parameterized_forcing(x, y, z, t, p) = p.Î¼ * exp(z / p.Î») * cos(p.Ï * t)

julia&gt; v_forcing = SimpleForcing(parameterized_forcing, parameters = (Î¼=42, Î»=0.1, Ï=Ï))</code></pre><ul><li>Field-dependent forcing with no parameters:</li></ul><pre><code class="language-julia">julia&gt; growth_in_sunlight(x, y, z, t, P) = exp(z) * P

julia&gt; plankton_forcing = SimpleForcing(growth_in_sunlight, field_in_signature=true)</code></pre><ul><li>Field-dependent forcing with parameters. This example relaxes a tracer to some reference   linear profile.</li></ul><pre><code class="language-julia">julia&gt; tracer_relaxation(x, y, z, t, c, p) = p.Î¼ * exp((z + p.H) / p.Î») * (p.dCdz * z - c) 

julia&gt; c_forcing = SimpleForcing(tracer_relaxation, parameters=(Î¼=1/60, Î»=10, H=1000, dCdz=1), 
                                 field_in_signature=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Forcing/simple_forcing.jl#L23-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcing.ModelForcing-Tuple{}" href="#Oceananigans.Forcing.ModelForcing-Tuple{}"><code>Oceananigans.Forcing.ModelForcing</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ModelForcing(; u=zeroforcing, v=zeroforcing, w=zeroforcing, tracer_forcings...)</code></pre><p>Return a named tuple of forcing functions for each solution field.</p><p><strong>Example</strong></p><p>julia&gt; u_forcing = SimpleForcing((x, y, z, t) -&gt; exp(z) * cos(t))</p><p>julia&gt; model = IncompressibleModel(forcing=ModelForcing(u=u_forcing))</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Forcing/model_forcing.jl#L11-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcing.ParameterizedForcing" href="#Oceananigans.Forcing.ParameterizedForcing"><code>Oceananigans.Forcing.ParameterizedForcing</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ParameterizedForcing(func, parameters)</code></pre><p>Construct a forcing function with parameters. The forcing function, which is applied at grid point <code>i, j, k</code>, is called with the signature</p><pre><code class="language-none">`func(i, j, k, grid, clock, state, parameters)`</code></pre><p><strong>Example</strong></p><p>function cool<em>forcing</em>function(i, j, k, grid, clock, state, parameters) =      return @inbounds - parameters.Î¼ * exp(grid.zC[k] / parameters.Î») * state.velocities.u[i, j, k] end</p><p>parameters = (Î¼=42, Î»=Ï)</p><p>cool<em>forcing = ParameterizedForcing(cool</em>forcing_function, parameters)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Forcing/parameterized_forcing.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcing.GaussianMask" href="#Oceananigans.Forcing.GaussianMask"><code>Oceananigans.Forcing.GaussianMask</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GaussianMask{D}(center, width)</code></pre><p>Callable object that returns a Gaussian masking function centered on <code>center</code>, with <code>width</code>, and varying along direction <code>D</code>.</p><p><strong>Examples</strong></p><ul><li>Create a Gaussian mask centered on <code>z=0</code> with width <code>1</code> meter.</li></ul><pre><code class="language-julia">julia&gt; mask = GaussianMask{:z}(0, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Forcing/relaxation.jl#L50-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcing.LinearTarget" href="#Oceananigans.Forcing.LinearTarget"><code>Oceananigans.Forcing.LinearTarget</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LinearTarget{D}(intercept, gradient)</code></pre><p>Callable object that returns a Linear target function with <code>intercept</code> and <code>gradient</code>, and varying along direction <code>D</code>.</p><p><strong>Examples</strong></p><ul><li>Create a linear target function varying in <code>z</code>, equal to <code>0</code> at  <code>z=0</code> and with gradient 10â»â¶:</li></ul><pre><code class="language-julia">julia&gt; target = LinearTarget{:z}(0, 1e-6)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Forcing/relaxation.jl#L83-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcing.Relaxation-Tuple{}" href="#Oceananigans.Forcing.Relaxation-Tuple{}"><code>Oceananigans.Forcing.Relaxation</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Relaxation(; rate, mask=onefunction, target=zerofunction)</code></pre><p>Returns a <code>SimpleForcing</code> that restores a field to <code>target(x, y, z, t)</code> at the specified <code>rate</code>, in the region <code>mask(x, y, z)</code>.</p><p><strong>Example</strong></p><ul><li>Restore a field to a linear z-gradient everywhere on a timescale of &quot;60&quot; (equal to one minute if the time units of the simulation are seconds).</li></ul><pre><code class="language-julia">julia&gt; restore_stratification = Relaxation(; rate = 1/60, target = (x, y, z, t) -&gt; z)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Forcing/relaxation.jl#L26-L41">source</a></section></article><h2 id="Grids"><a class="docs-heading-anchor" href="#Grids">Grids</a><a id="Grids-1"></a><a class="docs-heading-anchor-permalink" href="#Grids" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.AbstractGrid" href="#Oceananigans.Grids.AbstractGrid"><code>Oceananigans.Grids.AbstractGrid</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractGrid{FT, TX, TY, TZ}</code></pre><p>Abstract supertype for grids with elements of type <code>FT</code> and topology <code>{TX, TY, TZ}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Grids/Grids.jl#L64-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.AbstractTopology" href="#Oceananigans.Grids.AbstractTopology"><code>Oceananigans.Grids.AbstractTopology</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractTopology</code></pre><p>Abstract supertype for grid topologies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Grids/Grids.jl#L34-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.Bounded" href="#Oceananigans.Grids.Bounded"><code>Oceananigans.Grids.Bounded</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Bounded</code></pre><p>Grid topology for bounded dimensions. These could be wall-bounded dimensions or dimensions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Grids/Grids.jl#L48-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.Cell" href="#Oceananigans.Grids.Cell"><code>Oceananigans.Grids.Cell</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Cell</code></pre><p>A type describing the location at the center of a grid cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Grids/Grids.jl#L20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.Face" href="#Oceananigans.Grids.Face"><code>Oceananigans.Grids.Face</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Face</code></pre><p>A type describing the location at the face of a grid cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Grids/Grids.jl#L27-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.Flat" href="#Oceananigans.Grids.Flat"><code>Oceananigans.Grids.Flat</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Flat</code></pre><p>Grid topology for flat dimensions, generally with one grid point, along which the solution is uniform and does not vary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Grids/Grids.jl#L56-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.Periodic" href="#Oceananigans.Grids.Periodic"><code>Oceananigans.Grids.Periodic</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Periodic</code></pre><p>Grid topology for periodic dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Grids/Grids.jl#L41-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.nodes-Tuple{Any,AbstractGrid}" href="#Oceananigans.Grids.nodes-Tuple{Any,AbstractGrid}"><code>Oceananigans.Grids.nodes</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nodes(loc, grid; reshape=false)</code></pre><p>Returns a 3-tuple of views over the interior nodes at the locations in <code>loc</code> in <code>x, y, z</code>.</p><p>If <code>reshape=true</code>, the views are reshaped to 3D arrays with non-singleton dimensions 1, 2, 3 for <code>x, y, z</code>, respectively. These reshaped arrays can then be used in broadcast operations with 3D fields or arrays.</p><p>See <code>xnodes</code>, <code>ynodes</code>, and <code>znodes</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Grids/grid_utils.jl#L144-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.xnodes-Tuple{Type{Cell},Any}" href="#Oceananigans.Grids.xnodes-Tuple{Type{Cell},Any}"><code>Oceananigans.Grids.xnodes</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">xnodes(loc, grid)</code></pre><p>Returns a view over the interior <code>loc=Cell</code> or <code>loc=Face</code> nodes on <code>grid</code> in the x-direction. For <code>Bounded</code> directions, <code>Face</code> nodes include the boundary points.</p><p>See <code>znodes</code> for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Grids/grid_utils.jl#L73-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.ynodes-Tuple{Type{Cell},Any}" href="#Oceananigans.Grids.ynodes-Tuple{Type{Cell},Any}"><code>Oceananigans.Grids.ynodes</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ynodes(loc, grid)</code></pre><p>Returns a view over the interior <code>loc=Cell</code> or <code>loc=Face</code> nodes on <code>grid</code> in the y-direction. For <code>Bounded</code> directions, <code>Face</code> nodes include the boundary points.</p><p>See <code>znodes</code> for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Grids/grid_utils.jl#L84-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.znodes-Tuple{Type{Cell},Any}" href="#Oceananigans.Grids.znodes-Tuple{Type{Cell},Any}"><code>Oceananigans.Grids.znodes</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">znodes(loc, grid)</code></pre><p>Returns a view over the interior <code>loc=Cell</code> or <code>loc=Face</code> nodes on <code>grid</code> in the z-direction. For <code>Bounded</code> directions, <code>Face</code> nodes include the boundary points.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Oceananigans, Oceananigans.Grids

julia&gt; horz_periodic_grid = RegularCartesianGrid(size=(3, 3, 3), extent=(2Ï, 2Ï, 1),
                                                 topology=(Periodic, Periodic, Bounded));

julia&gt; zC = znodes(Cell, horz_periodic_grid)
3-element view(OffsetArray(::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}, 0:4), 1:3) with eltype Float64:
 -0.8333333333333331
 -0.4999999999999999
 -0.16666666666666652</code></pre><pre><code class="language-julia-repl">julia&gt; zF = znodes(Face, horz_periodic_grid)
4-element view(OffsetArray(::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}, 0:5), 1:4) with eltype Float64:
 -1.0
 -0.6666666666666666
 -0.33333333333333337
 -4.44089209850063e-17</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Grids/grid_utils.jl#L95-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.RegularCartesianGrid" href="#Oceananigans.Grids.RegularCartesianGrid"><code>Oceananigans.Grids.RegularCartesianGrid</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RegularCartesianGrid{FT, TX, TY, TZ, R} &lt;: AbstractGrid{FT, TX, TY, TZ}</code></pre><p>A Cartesian grid with with constant grid spacings <code>Îx</code>, <code>Îy</code>, and <code>Îz</code> between cell centers and cell faces, elements of type <code>FT</code>, topology <code>{TX, TY, TZ}</code>, and coordinate ranges of type <code>R</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Grids/regular_cartesian_grid.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.RegularCartesianGrid" href="#Oceananigans.Grids.RegularCartesianGrid"><code>Oceananigans.Grids.RegularCartesianGrid</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RegularCartesianGrid([FT=Float64]; size,
                     extent = nothing, x = nothing, y = nothing, z = nothing,
                     topology = (Periodic, Periodic, Bounded), halo = (1, 1, 1))</code></pre><p>Creates a <code>RegularCartesianGrid</code> with <code>size = (Nx, Ny, Nz)</code> grid points.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>size</code> (required): A 3-tuple <code>(Nx, Ny, Nz)</code> prescribing the number of grid points in <code>x, y, z</code></p></li><li><p><code>extent</code>: A 3-tuple <code>(Lx, Ly, Lz)</code> prescribing the physical extent of the grid.                    The origin is the oceanic default <code>(0, 0, -Lz)</code>.</p></li><li><p><code>x</code>, <code>y</code>, and <code>z</code>: Each of <code>x, y, z</code> are 2-tuples that specify the end points of the domain                    in their respect directions.  </p></li></ul><p><em>Note</em>: <em>Either</em> <code>extent</code>, or all of <code>x</code>, <code>y</code>, and <code>z</code> must be specified.</p><ul><li><p><code>topology</code>: A 3-tuple <code>(Tx, Ty, Tz)</code> specifying the topology of the domain.              <code>Tx</code>, <code>Ty</code>, and <code>Tz</code> specify whether the <code>x</code>-, <code>y</code>-, and <code>z</code> directions are             <code>Periodic</code>, <code>Bounded</code>, or <code>Flat</code>. In a <code>Flat</code> direction, derivatives are              zero. The default is <code>(Periodic, Periodic, Bounded)</code>.</p></li><li><p><code>halo</code>: A 3-tuple of integers that specifies the size of the halo region of cells surrounding         the physical interior in <code>x</code>, <code>y</code>, and <code>z</code>.</p></li></ul><p>The physical extent of the domain can be specified via <code>x</code>, <code>y</code>, and <code>z</code> keyword arguments indicating the left and right endpoints of each dimensions, e.g. <code>x=(-Ï, Ï)</code> or via the <code>extent</code> argument, e.g. <code>extent=(Lx, Ly, Lz)</code> which specifies the extent of each dimension in which case 0 â¤ x â¤ Lx, 0 â¤ y â¤ Ly, and -Lz â¤ z â¤ 0.</p><p>A grid topology may be specified via a tuple assigning one of <code>Periodic</code>, <code>Bounded, and</code>Flat<code>to each dimension. By default, a horizontally periodic grid topology</code>(Periodic, Periodic, Flat)` is assumed.</p><p>Constants are stored using floating point values of type <code>FT</code>. By default this is <code>Float64</code>. Make sure to specify the desired <code>FT</code> if not using <code>Float64</code>.</p><p><strong>Grid properties</strong></p><ul><li><p><code>(Nx, Ny, Nz)::Int</code>: Number of physical points in the (x, y, z)-direction</p></li><li><p><code>(Hx, Hy, Hz)::Int</code>: Number of halo points in the (x, y, z)-direction</p></li><li><p><code>(Lx, Ly, Lz)::FT</code>: Physical extent of the grid in the (x, y, z)-direction</p></li><li><p><code>(Îx, Îy, Îz)::FT</code>: Cell width in the (x, y, z)-direction</p></li><li><p><code>(xC, yC, zC)</code>: (x, y, z) coordinates of cell centers.</p></li><li><p><code>(xF, yF, zF)</code>: (x, y, z) coordinates of cell faces.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; grid = RegularCartesianGrid(size=(32, 32, 32), extent=(1, 2, 3))
RegularCartesianGrid{Float64}
domain: x â [0.0, 1.0], y â [0.0, 2.0], z â [0.0, -3.0]
  resolution (Nx, Ny, Nz) = (32, 32, 32)
   halo size (Hx, Hy, Hz) = (1, 1, 1)
grid spacing (Îx, Îy, Îz) = (0.03125, 0.0625, 0.09375)</code></pre><pre><code class="language-julia">julia&gt; grid = RegularCartesianGrid(Float32; size=(32, 32, 16), x=(0, 8), y=(-10, 10), z=(-Ï, Ï))
RegularCartesianGrid{Float32}
domain: x â [0.0, 8.0], y â [-10.0, 10.0], z â [3.141592653589793, -3.141592653589793]
  resolution (Nx, Ny, Nz) = (32, 32, 16)
   halo size (Hx, Hy, Hz) = (1, 1, 1)
grid spacing (Îx, Îy, Îz) = (0.25f0, 0.625f0, 0.3926991f0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Grids/regular_cartesian_grid.jl#L35-L110">source</a></section></article><h2 id="Models"><a class="docs-heading-anchor" href="#Models">Models</a><a id="Models-1"></a><a class="docs-heading-anchor-permalink" href="#Models" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Models.state-Tuple{Any}" href="#Oceananigans.Models.state-Tuple{Any}"><code>Oceananigans.Models.state</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">state(model)</code></pre><p>Returns a <code>NamedTuple</code> with fields <code>velocities, tracers, diffusivities, tendencies</code>  corresponding to <code>NamedTuple</code>s of <code>OffsetArray</code>s that reference each of the field&#39;s data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Models/Models.jl#L24-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Models.Clock" href="#Oceananigans.Models.Clock"><code>Oceananigans.Models.Clock</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Clock{T&lt;:Number}

Clock{T}(time, iteration)</code></pre><p>Keeps track of the current <code>time</code> and <code>iteration</code> number. The <code>time::T</code> can be either a number of a <code>DateTime</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Models/clock.jl#L5-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Models.NonDimensionalModel-Tuple{}" href="#Oceananigans.Models.NonDimensionalModel-Tuple{}"><code>Oceananigans.Models.NonDimensionalModel</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">NonDimensionalModel(; N, L, Re, Pr=0.7, Ro=Inf, float_type=Float64, kwargs...)</code></pre><p>Construct a &quot;Non-dimensional&quot; <code>Model</code> with resolution <code>N</code>, domain extent <code>L</code>, precision <code>float_type</code>, and the four non-dimensional numbers:</p><pre><code class="language-none">* `Re = U Î» / Î½` (Reynolds number)
* `Pr = U Î» / Îº` (Prandtl number)
* `Ro = U / f Î»` (Rossby number)</code></pre><p>for characteristic velocity scale <code>U</code>, length-scale <code>Î»</code>, viscosity <code>Î½</code>, tracer diffusivity <code>Îº</code>, and Coriolis parameter <code>f</code>. Buoyancy is scaled with <code>Î» UÂ²</code>, so that the Richardson number is <code>Ri=B</code>, where <code>B</code> is a non-dimensional buoyancy scale set by the user via initial conditions or forcing.</p><p>Note that <code>N</code>, <code>L</code>, and <code>Re</code> are required.</p><p>Additional <code>kwargs</code> are passed to the regular <code>IncompressibleModel</code> constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Models/non_dimensional_model.jl#L3-L22">source</a></section></article><h2 id="Output-writers"><a class="docs-heading-anchor" href="#Output-writers">Output writers</a><a id="Output-writers-1"></a><a class="docs-heading-anchor-permalink" href="#Output-writers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.FieldOutput" href="#Oceananigans.OutputWriters.FieldOutput"><code>Oceananigans.OutputWriters.FieldOutput</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FieldOutput([return_type=Array], field)</code></pre><p>Returns a <code>FieldOutput</code> type intended for use with the <code>JLD2OutputWriter</code>. Calling <code>FieldOutput(model)</code> returns <code>return_type(field.data.parent)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/OutputWriters/jld2_output_writer.jl#L150-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.JLD2OutputWriter" href="#Oceananigans.OutputWriters.JLD2OutputWriter"><code>Oceananigans.OutputWriters.JLD2OutputWriter</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">JLD2OutputWriter{F, I, O, IF, IN, KW} &lt;: AbstractOutputWriter</code></pre><p>An output writer for writing to JLD2 files.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/OutputWriters/jld2_output_writer.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.JLD2OutputWriter-Tuple{Any,Any}" href="#Oceananigans.OutputWriters.JLD2OutputWriter-Tuple{Any,Any}"><code>Oceananigans.OutputWriters.JLD2OutputWriter</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JLD2OutputWriter(model, outputs; interval=nothing, frequency=nothing, dir=&quot;.&quot;,
                 prefix=&quot;&quot;, init=noinit, including=[:grid, :coriolis, :buoyancy, :closure],
                 part=1, max_filesize=Inf, force=false, async=false, verbose=false, jld2_kw=Dict{Symbol, Any}())</code></pre><p>Construct a <code>JLD2OutputWriter</code> that writes <code>label, func</code> pairs in <code>outputs</code> (which can be a <code>Dict</code> or <code>NamedTuple</code>) to a JLD2 file, where <code>label</code> is a symbol that labels the output and <code>func</code> is a function of the form <code>func(model)</code> that returns the data to be saved.</p><p><strong>Keyword arguments</strong></p><ul><li><code>frequency::Int</code>   : Save output every <code>n</code> model iterations.</li><li><code>interval::Int</code>    : Save output every <code>t</code> units of model clock time.</li><li><code>dir::String</code>      : Directory to save output to. Default: &quot;.&quot; (current working directory).</li><li><code>prefix::String</code>   : Descriptive filename prefixed to all output files. Default: &quot;&quot;.</li><li><code>init::Function</code>   : A function of the form <code>init(file, model)</code> that runs when a JLD2 output file is initialized.                      Default: <code>noinit(args...) = nothing</code>.</li><li><code>including::Array</code> : List of model properties to save with every file. By default, the grid, equation of state,                      Coriolis parameters, buoyancy parameters, and turbulence closure parameters are saved.</li><li><code>part::Int</code>        : The starting part number used if <code>max_filesize</code> is finite. Default: 1.</li><li><code>max_filesize::Int</code>: The writer will stop writing to the output file once the file size exceeds <code>max_filesize</code>, and                      write to a new one with a consistent naming scheme ending in <code>part1</code>, <code>part2</code>, etc. Defaults to                      <code>Inf</code>.</li><li><code>force::Bool</code>      : Remove existing files if their filenames conflict. Default: <code>false</code>.</li><li><code>async::Bool</code>      : Write output asynchronously. Default: <code>false</code>.</li><li><code>verbose::Bool</code>    : Log what the output writer is doing with statistics on compute/write times and file sizes.                      Default: <code>false</code>.</li><li><code>jld2_kw::Dict</code>    : Dict of kwargs to be passed to <code>jldopen</code> when data is written.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/OutputWriters/jld2_output_writer.jl#L28-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.FieldOutputs-Tuple{Any}" href="#Oceananigans.OutputWriters.FieldOutputs-Tuple{Any}"><code>Oceananigans.OutputWriters.FieldOutputs</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">FieldOutputs(fields)</code></pre><p>Returns a dictionary of <code>FieldOutput</code> objects with key, value pairs corresponding to each name and value in the <code>NamedTuple</code> <code>fields</code>. Intended for use with <code>JLD2OutputWriter</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; output_writer = JLD2OutputWriter(model, FieldOutputs(model.velocities), frequency=1);

julia&gt; keys(output_writer.outputs)
Base.KeySet for a Dict{Symbol,FieldOutput{UnionAll,F} where F} with 3 entries. Keys:
  :w
  :v
  :u</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/OutputWriters/jld2_output_writer.jl#L164-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.NetCDFOutputWriter" href="#Oceananigans.OutputWriters.NetCDFOutputWriter"><code>Oceananigans.OutputWriters.NetCDFOutputWriter</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NetCDFOutputWriter &lt;: AbstractOutputWriter</code></pre><p>An output writer for writing to NetCDF files.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/OutputWriters/netcdf_output_writer.jl#L21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.write_grid_and_attributes-Tuple{Any}" href="#Oceananigans.OutputWriters.write_grid_and_attributes-Tuple{Any}"><code>Oceananigans.OutputWriters.write_grid_and_attributes</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">write_grid_and_attributes(model; filename=&quot;grid.nc&quot;, mode=&quot;c&quot;,
                          compression=0, attributes=Dict(), slice_kw...)</code></pre><p>Writes grid and global <code>attributes</code> to <code>filename</code>. By default writes information to a standalone <code>grid.nc</code> file.</p><p><strong>Keyword arguments</strong></p><ul><li><code>filename</code>  : File name to be saved under.</li><li><code>mode</code>: NetCDF file is opened in either clobber (&quot;c&quot;) or append (&quot;a&quot;) mode. Default: &quot;c&quot;.</li><li><code>compression</code>: Defines the compression level of data from 0-9. Default: 0.</li><li><code>attributes</code>: Global attributes. Default: Dict().</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/OutputWriters/netcdf_output_writer.jl#L203-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.write_output-Tuple{Any,NetCDFOutputWriter}" href="#Oceananigans.OutputWriters.write_output-Tuple{Any,NetCDFOutputWriter}"><code>Oceananigans.OutputWriters.write_output</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">write_output(model, OutputWriter)</code></pre><p>Writes output to the netcdf file at specified intervals. Increments the <code>time</code> dimension every time an output is written to the file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/OutputWriters/netcdf_output_writer.jl#L173-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.Checkpointer" href="#Oceananigans.OutputWriters.Checkpointer"><code>Oceananigans.OutputWriters.Checkpointer</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Checkpointer{I, T, P, A} &lt;: AbstractOutputWriter</code></pre><p>An output writer for checkpointing models to a JLD2 file from which models can be restored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/OutputWriters/checkpointer.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.Checkpointer-Tuple{Any}" href="#Oceananigans.OutputWriters.Checkpointer-Tuple{Any}"><code>Oceananigans.OutputWriters.Checkpointer</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Checkpointer(model; frequency=nothing, interval=nothing, dir=&quot;.&quot;,
             prefix=&quot;checkpoint&quot;, force=false, verbose=false,
             properties = [:architecture, :boundary_conditions, :grid, :clock, :coriolis,
                           :buoyancy, :closure, :velocities, :tracers, :timestepper])</code></pre><p>Construct a <code>Checkpointer</code> that checkpoints the model to a JLD2 file every so often as specified by <code>frequency</code> or <code>interval</code>. The <code>model.clock.iteration</code> is included in the filename to distinguish between multiple checkpoint files.</p><p>Note that extra model <code>properties</code> can be safely specified, but removing crucial properties such as <code>:velocities</code> will make restoring from the checkpoint impossible.</p><p>The checkpoint file is generated by serializing model properties to JLD2. However, functions cannot be serialized to disk (at least not with JLD2). So if a model property contains a reference somewhere in its hierarchy it will not be included in the checkpoint file (and you will have to manually restore them).</p><p><strong>Keyword arguments</strong></p><ul><li><code>frequency::Int</code>   : Save output every <code>n</code> model iterations.</li><li><code>interval::Int</code>    : Save output every <code>t</code> units of model clock time.</li><li><code>dir::String</code>      : Directory to save output to. Default: &quot;.&quot; (current working directory).</li><li><code>prefix::String</code>   : Descriptive filename prefixed to all output files. Default: &quot;checkpoint&quot;.</li><li><code>force::Bool</code>      : Remove existing files if their filenames conflict. Default: <code>false</code>.</li><li><code>verbose::Bool</code>    : Log what the output writer is doing with statistics on compute/write times and file sizes.                      Default: <code>false</code>.</li><li><code>properties::Array</code>: List of model properties to checkpoint.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/OutputWriters/checkpointer.jl#L17-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.restore_from_checkpoint-Tuple{Any}" href="#Oceananigans.OutputWriters.restore_from_checkpoint-Tuple{Any}"><code>Oceananigans.OutputWriters.restore_from_checkpoint</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">restore_from_checkpoint(filepath; kwargs=Dict())</code></pre><p>Restore a model from the checkpoint file stored at <code>filepath</code>. <code>kwargs</code> can be passed to the model constructor, which can be especially useful if you need to manually restore forcing functions or boundary conditions that rely on functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/OutputWriters/checkpointer.jl#L115-L121">source</a></section></article><h2 id="Time-steppers"><a class="docs-heading-anchor" href="#Time-steppers">Time steppers</a><a id="Time-steppers-1"></a><a class="docs-heading-anchor-permalink" href="#Time-steppers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TimeSteppers.AdamsBashforthTimeStepper" href="#Oceananigans.TimeSteppers.AdamsBashforthTimeStepper"><code>Oceananigans.TimeSteppers.AdamsBashforthTimeStepper</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AdamsBashforthTimeStepper(float_type, arch, grid, tracers, Ï=0.125;
                          Gâ¿ = TendencyFields(arch, grid, tracers),
                          Gâ» = TendencyFields(arch, grid, tracers))</code></pre><p>Return an AdamsBashforthTimeStepper object with tendency fields on <code>arch</code> and <code>grid</code> with AB2 parameter <code>Ï</code>. The tendency fields can be specified via optional kwargs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/TimeSteppers/adams_bashforth.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TimeSteppers.time_step!-Tuple{IncompressibleModel{#s105,E,A,G,T,B,R,SW,U,C,Î¦,F,S,K} where K where S where F where Î¦ where C where U where SW where R where B where T where G where A&lt;:Oceananigans.Architectures.AbstractArchitecture where E where #s105&lt;:AdamsBashforthTimeStepper,Any}" href="#Oceananigans.TimeSteppers.time_step!-Tuple{IncompressibleModel{#s105,E,A,G,T,B,R,SW,U,C,Î¦,F,S,K} where K where S where F where Î¦ where C where U where SW where R where B where T where G where A&lt;:Oceananigans.Architectures.AbstractArchitecture where E where #s105&lt;:AdamsBashforthTimeStepper,Any}"><code>Oceananigans.TimeSteppers.time_step!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">time_step!(model::IncompressibleModel{&lt;:AdamsBashforthTimeStepper}, Ît; euler=false)</code></pre><p>Step forward <code>model</code> one time step <code>Ît</code> with a 2nd-order Adams-Bashforth method and pressure-correction substep. Setting <code>euler=true</code> will take a forward Euler time step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/TimeSteppers/adams_bashforth.jl#L34-L39">source</a></section></article><h2 id="Simulations"><a class="docs-heading-anchor" href="#Simulations">Simulations</a><a id="Simulations-1"></a><a class="docs-heading-anchor-permalink" href="#Simulations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Simulations.TimeStepWizard-Tuple{}" href="#Oceananigans.Simulations.TimeStepWizard-Tuple{}"><code>Oceananigans.Simulations.TimeStepWizard</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">TimeStepWizard(cfl=0.1, max_change=2.0, min_change=0.5, max_Ît=Inf)</code></pre><p>A type for calculating adaptive time steps based on capping the CFL number at <code>cfl</code>.</p><p>On calling <code>update_Ît!(wizard, model)</code>, the <code>TimeStepWizard</code> computes a time-step such that <span>$cfl = max(u/Îx, v/Îy, w/Îz) Ît$</span>, where <span>$max(u/Îx, v/Îy, w/Îz)$</span> is the maximum ratio between model velocity and along-velocity grid spacing anywhere on the model grid. The new <code>Ît</code> is constrained to change by a multiplicative factor no more than <code>max_change</code> or no less than <code>min_change</code> from the previous <code>Ît</code>, and to be no greater in absolute magnitude than <code>max_Ît</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Simulations/time_step_wizard.jl#L10-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Simulations.Simulation-Tuple{Any}" href="#Oceananigans.Simulations.Simulation-Tuple{Any}"><code>Oceananigans.Simulations.Simulation</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Simulation(model; Ît,
     stop_criteria = Function[iteration_limit_exceeded, stop_time_exceeded, wall_time_limit_exceeded],
    stop_iteration = Inf,
         stop_time = Inf,
   wall_time_limit = Inf,
       diagnostics = OrderedDict{Symbol, AbstractDiagnostic}(),
    output_writers = OrderedDict{Symbol, AbstractOutputWriter}(),
          progress = nothing,
progress_frequency = 1,
        parameters = nothing)</code></pre><p>Construct an Oceananigans.jl <code>Simulation</code> for a <code>model</code> with time step <code>Ît</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>Ît</code>: Required keyword argument specifying the simulation time step. Can be a <code>Number</code> for constant time steps or a <code>TimeStepWizard</code> for adaptive time-stepping.</li><li><code>stop_criteria</code>: A list of functions or callable objects (each taking a single argument, the <code>simulation</code>). If any of the functions return <code>true</code> when the stop criteria is evaluated the simulation will stop.</li><li><code>stop_iteration</code>: Stop the simulation after this many iterations.</li><li><code>stop_time</code>: Stop the simulation once this much model clock time has passed.</li><li><code>wall_time_limit</code>: Stop the simulation if it&#39;s been running for longer than this many  seconds of wall clock time.</li><li><code>progress</code>: A function with a single argument, the <code>simulation</code>. Will be called every <code>progress_frequency</code> iterations. Useful for logging simulation health.</li><li><code>progress_frequency</code>: How often to update the time step, check stop criteria, and call <code>progress</code> function (in number of iterations).</li><li><code>parameters</code>: Parameters that can be accessed in the <code>progress</code> function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Simulations/simulation.jl#L18-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Simulations.run!-Tuple{Any}" href="#Oceananigans.Simulations.run!-Tuple{Any}"><code>Oceananigans.Simulations.run!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">run!(simulation)</code></pre><p>Run a <code>simulation</code> until one of the stop criteria evaluates to true. The simulation will then stop.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Simulations/run.jl#L51-L56">source</a></section></article><h2 id="Tubrulence-closures"><a class="docs-heading-anchor" href="#Tubrulence-closures">Tubrulence closures</a><a id="Tubrulence-closures-1"></a><a class="docs-heading-anchor-permalink" href="#Tubrulence-closures" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.AbstractIsotropicDiffusivity" href="#Oceananigans.TurbulenceClosures.AbstractIsotropicDiffusivity"><code>Oceananigans.TurbulenceClosures.AbstractIsotropicDiffusivity</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractIsotropicDiffusivity &lt;: AbstractTurbulenceClosure</code></pre><p>Abstract supertype for turbulence closures that are defined by an isotropic viscosity and isotropic diffusivities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/TurbulenceClosures/TurbulenceClosures.jl#L66-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation" href="#Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation"><code>Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AnisotropicMinimumDissipation</code></pre><p>An alias for <code>VerstappenAnisotropicMinimumDissipation</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/TurbulenceClosures/TurbulenceClosures.jl#L183-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.ConstantSmagorinsky" href="#Oceananigans.TurbulenceClosures.ConstantSmagorinsky"><code>Oceananigans.TurbulenceClosures.ConstantSmagorinsky</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConstantSmagorinsky</code></pre><p>An alias for <code>SmagorinskyLilly</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/TurbulenceClosures/TurbulenceClosures.jl#L190-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.ââ±¼_2Î½_Î£ââ±¼-Tuple{Any,Any,Any,Any,Any,AbstractIsotropicDiffusivity,Any,Any}" href="#Oceananigans.TurbulenceClosures.ââ±¼_2Î½_Î£ââ±¼-Tuple{Any,Any,Any,Any,Any,AbstractIsotropicDiffusivity,Any,Any}"><code>Oceananigans.TurbulenceClosures.ââ±¼_2Î½_Î£ââ±¼</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ââ±¼_2Î½_Î£ââ±¼(i, j, k, grid, closure, U, diffusivities)</code></pre><p>Return the <span>$x$</span>-component of the turbulent diffusive flux divergence:</p><p><code>âx(2 Î½ Î£ââ) + ây(2 Î½ Î£ââ) + âz(2 Î½ Î£ââ)</code></p><p>at the location <code>fcc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/TurbulenceClosures/closure_operators.jl#L107-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.ââ±¼_2Î½_Î£ââ±¼-Tuple{Any,Any,Any,Any,Any,AbstractIsotropicDiffusivity,Any,Any}" href="#Oceananigans.TurbulenceClosures.ââ±¼_2Î½_Î£ââ±¼-Tuple{Any,Any,Any,Any,Any,AbstractIsotropicDiffusivity,Any,Any}"><code>Oceananigans.TurbulenceClosures.ââ±¼_2Î½_Î£ââ±¼</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ââ±¼_2Î½_Î£ââ±¼(i, j, k, grid, closure, U, diffusivities)</code></pre><p>Return the <span>$y$</span>-component of the turbulent diffusive flux divergence:</p><p><code>âx(2 Î½ Î£ââ) + ây(2 Î½ Î£ââ) + âz(2 Î½ Î£ââ)</code></p><p>at the location <code>ccf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/TurbulenceClosures/closure_operators.jl#L122-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.ââ±¼_2Î½_Î£ââ±¼-Tuple{Any,Any,Any,Any,Any,AbstractIsotropicDiffusivity,Any,Any}" href="#Oceananigans.TurbulenceClosures.ââ±¼_2Î½_Î£ââ±¼-Tuple{Any,Any,Any,Any,Any,AbstractIsotropicDiffusivity,Any,Any}"><code>Oceananigans.TurbulenceClosures.ââ±¼_2Î½_Î£ââ±¼</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ââ±¼_2Î½_Î£ââ±¼(i, j, k, grid, closure, diffusivities)</code></pre><p>Return the <span>$z$</span>-component of the turbulent diffusive flux divergence:</p><p><code>âx(2 Î½ Î£ââ) + ây(2 Î½ Î£ââ) + âz(2 Î½ Î£ââ)</code></p><p>at the location <code>ccf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/TurbulenceClosures/closure_operators.jl#L137-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.AnisotropicBiharmonicDiffusivity" href="#Oceananigans.TurbulenceClosures.AnisotropicBiharmonicDiffusivity"><code>Oceananigans.TurbulenceClosures.AnisotropicBiharmonicDiffusivity</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AnisotropicBiharmonicDiffusivity{FT, KH, KV}</code></pre><p>Parameters for anisotropic biharmonic diffusivity models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_biharmonic_diffusivity.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.AnisotropicBiharmonicDiffusivity" href="#Oceananigans.TurbulenceClosures.AnisotropicBiharmonicDiffusivity"><code>Oceananigans.TurbulenceClosures.AnisotropicBiharmonicDiffusivity</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AnisotropicBiharmonicDiffusivity(; Î½h, Î½v, Îºh, Îºv)</code></pre><p>Returns parameters for a fourth-order, anisotropic biharmonic diffusivity closure with constant horizontal and vertical biharmonic viscosities <code>Î½h</code>, <code>Î½v</code> and constant horizontal and vertical tracer biharmonic diffusivities <code>Îºh</code>, <code>Îºv</code>. <code>Îºh</code> and <code>Îºv</code> may be <code>NamedTuple</code>s with fields corresponding to each tracer, or a single number to be a applied to all tracers. The tracer flux divergence associated with an anisotropic biharmonic diffusivity is, for example</p><div>\[    âáµ¢ Îºáµ¢â±¼ ââ±¼c = (Îºh ââ´h + Îºv ââ´z) c\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_biharmonic_diffusivity.jl#L16-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.SmagorinskyLilly" href="#Oceananigans.TurbulenceClosures.SmagorinskyLilly"><code>Oceananigans.TurbulenceClosures.SmagorinskyLilly</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SmagorinskyLilly{FT} &lt;: AbstractSmagorinsky{FT}</code></pre><p>Parameters for the Smagorinsky-Lilly turbulence closure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl#L6-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.SmagorinskyLilly" href="#Oceananigans.TurbulenceClosures.SmagorinskyLilly"><code>Oceananigans.TurbulenceClosures.SmagorinskyLilly</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SmagorinskyLilly([FT=Float64;] C=0.23, Pr=1, Î½=1.05e-6, Îº=1.46e-7)</code></pre><p>Return a <code>SmagorinskyLilly</code> type associated with the turbulence closure proposed by Lilly (1962) and Smagorinsky (1958, 1963), which has an eddy viscosity of the form</p><pre><code class="language-none">`Î½â = (C * Îá¶ )Â² * â(2Î£Â²) * â(1 - Cb * NÂ² / Î£Â²) + Î½`,</code></pre><p>and an eddy diffusivity of the form</p><pre><code class="language-none">`Îºâ = (Î½â - Î½) / Pr + Îº`</code></pre><p>where <code>Îá¶ </code> is the filter width, <code>Î£Â² = Î£áµ¢â±¼Î£áµ¢â±¼</code> is the double dot product of the strain tensor <code>Î£áµ¢â±¼</code>, <code>Pr</code> is the turbulent Prandtl number, and <code>NÂ²</code> is the total buoyancy gradient, and <code>Cb</code> is a constant the multiplies the Richardson number modification to the eddy viscosity.</p><p><strong>Keyword arguments</strong></p><pre><code class="language-none">- `C`  : Model constant
- `Cb` : Buoyancy term multipler (`Cb = 0` turns it off, `Cb â  0` turns it on.
         Typically `Cb=1/Pr`.)
- `Pr` : Turbulent Prandtl numbers for each tracer. Either a constant applied to every
         tracer, or a `NamedTuple` with fields for each tracer individually.
- `Î½`  : Constant background viscosity for momentum
- `Îº`  : Constant background diffusivity for tracer. Can either be a single number
         applied to all tracers, or `NamedTuple` of diffusivities corresponding to each
         tracer.</code></pre><p><strong>References</strong></p><p>Smagorinsky, J. &quot;On the numerical integration of the primitive equations of motion for     baroclinic flow in a closed region.&quot; Monthly Weather Review (1958)</p><p>Lilly, D. K. &quot;On the numerical simulation of buoyant convection.&quot; Tellus (1962)</p><p>Smagorinsky, J. &quot;General circulation experiments with the primitive equations: I.     The basic experiment.&quot; Monthly weather review (1963)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl#L25-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.â_Îº_âc-Tuple{Any,Any,Any,Any,Any,Oceananigans.TurbulenceClosures.AbstractSmagorinsky,Any,Any,Any,Vararg{Any,N} where N}" href="#Oceananigans.TurbulenceClosures.â_Îº_âc-Tuple{Any,Any,Any,Any,Any,Oceananigans.TurbulenceClosures.AbstractSmagorinsky,Any,Any,Any,Vararg{Any,N} where N}"><code>Oceananigans.TurbulenceClosures.â_Îº_âc</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">â_Îº_âc(i, j, k, grid, clock, c, closure, diffusivities)</code></pre><p>Return the diffusive flux divergence <code>â â (Îº â c)</code> for the turbulence <code>closure</code>, where <code>c</code> is an array of scalar data located at cell centers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl#L166-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.VerstappenAnisotropicMinimumDissipation" href="#Oceananigans.TurbulenceClosures.VerstappenAnisotropicMinimumDissipation"><code>Oceananigans.TurbulenceClosures.VerstappenAnisotropicMinimumDissipation</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">VerstappenAnisotropicMinimumDissipation{FT} &lt;: AbstractAnisotropicMinimumDissipation{FT}</code></pre><p>Parameters for the anisotropic minimum dissipation large eddy simulation model proposed by Verstappen (2018) and described by Vreugdenhil &amp; Taylor (2018).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/TurbulenceClosures/turbulence_closure_implementations/verstappen_anisotropic_minimum_dissipation.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.VerstappenAnisotropicMinimumDissipation" href="#Oceananigans.TurbulenceClosures.VerstappenAnisotropicMinimumDissipation"><code>Oceananigans.TurbulenceClosures.VerstappenAnisotropicMinimumDissipation</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">VerstappenAnisotropicMinimumDissipation(FT=Float64; C=1/12, CÎ½=nothing, CÎº=nothing,
                                        Cb=0.0, Î½=Î½â, Îº=Îºâ)</code></pre><p>Returns parameters of type <code>FT</code> for the <code>VerstappenAnisotropicMinimumDissipation</code> turbulence closure.</p><p><strong>Keyword arguments</strong></p><pre><code class="language-none">- `C`  : PoincareÌ constant for both eddy viscosity and eddy diffusivities. `C` is overridden
         for eddy viscosity or eddy diffusivity if `CÎ½` or `CÎº` are set, respecitvely.
- `CÎ½` : PoincareÌ constant for momentum eddy viscosity.
- `CÎº` : PoincareÌ constant for tracer eddy diffusivities. If one number or function, the same
         number or function is applied to all tracers. If a `NamedTuple`, it must possess
         a field specifying the PoncareÌ constant for every tracer.
- `Cb` : Buoyancy modification multiplier (`Cb = 0` turns it off, `Cb = 1` turns it on)
- `Î½`  : Constant background viscosity for momentum.
- `Îº`  : Constant background diffusivity for tracer. If a single number, the same background
         diffusivity is applied to all tracers. If a `NamedTuple`, it must possess a field
         specifying a background diffusivity for every tracer.</code></pre><p>By default: <code>C = CÎ½ = CÎº</code> = 1/12, which is appropriate for a finite-volume method employing a second-order advection scheme, <code>Cb</code> = 0, which terms off the buoyancy modification term, the molecular viscosity of seawater at 20 deg C and 35 psu is used for <code>Î½</code>, and the molecular diffusivity of heat in seawater at 20 deg C and 35 psu is used for <code>Îº</code>.</p><p><code>CÎ½</code> or <code>CÎº</code> may be constant numbers, or functions of <code>x, y, z</code>.</p><p><strong>Example</strong></p><p>julia&gt; pretty<em>diffusive</em>closure = AnisotropicMinimumDissipation(C=1/2) VerstappenAnisotropicMinimumDissipation{Float64} turbulence closure with:            PoincareÌ constant for momentum eddy viscosity CÎ½: 0.5     PoincareÌ constant for tracer(s) eddy diffusivit(ies) CÎº: 0.5                         Buoyancy modification multiplier Cb: 0.0                 Background diffusivit(ies) for tracer(s), Îº: 1.46e-7              Background kinematic viscosity for momentum, Î½: 1.05e-6</p><p>julia&gt; const Îz = 0.5; # grid resolution at surface</p><p>julia&gt; surface<em>enhanced</em>tracer<em>C(x, y, z) = 1/12 * (1 + exp((z + Îz/2) / 8Îz)) surface</em>enhanced<em>tracer</em>C (generic function with 1 method)</p><p>julia&gt; fancy<em>closure = AnisotropicMinimumDissipation(CÎº=surface</em>enhanced<em>tracer</em>C) VerstappenAnisotropicMinimumDissipation{Float64} turbulence closure with:            PoincareÌ constant for momentum eddy viscosity CÎ½: 0.08333333333333333     PoincareÌ constant for tracer(s) eddy diffusivit(ies) CÎº: surface<em>enhanced</em>tracer_C                         Buoyancy modification multiplier Cb: 0.0                 Background diffusivit(ies) for tracer(s), Îº: 1.46e-7              Background kinematic viscosity for momentum, Î½: 1.05e-6</p><p>julia&gt; tracer<em>specific</em>closure = AnisotropicMinimumDissipation(CÎº=(câ=1/12, câ=1/6)) VerstappenAnisotropicMinimumDissipation{Float64} turbulence closure with:            PoincareÌ constant for momentum eddy viscosity CÎ½: 0.08333333333333333     PoincareÌ constant for tracer(s) eddy diffusivit(ies) CÎº: (câ = 0.08333333333333333, câ = 0.16666666666666666)                         Buoyancy modification multiplier Cb: 0.0                 Background diffusivit(ies) for tracer(s), Îº: 1.46e-7              Background kinematic viscosity for momentum, Î½: 1.05e-6</p><p><strong>References</strong></p><p>Vreugdenhil C., and Taylor J. (2018), &quot;Large-eddy simulations of stratified plane Couette     flow using the anisotropic minimum-dissipation model&quot;, Physics of Fluids 30, 085104.</p><p>Verstappen, R. (2018), &quot;How much eddy dissipation is needed to counterbalance the nonlinear     production of small, unresolved scales in a large-eddy simulation of turbulence?&quot;,     Computers &amp; Fluids 176, pp. 276-284.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/TurbulenceClosures/turbulence_closure_implementations/verstappen_anisotropic_minimum_dissipation.jl#L29-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.â_Îº_âc-Union{Tuple{tracer_index}, Tuple{Any,Any,Any,Any,Any,Oceananigans.TurbulenceClosures.AbstractAnisotropicMinimumDissipation,Any,Val{tracer_index},Any,Vararg{Any,N} where N}} where tracer_index" href="#Oceananigans.TurbulenceClosures.â_Îº_âc-Union{Tuple{tracer_index}, Tuple{Any,Any,Any,Any,Any,Oceananigans.TurbulenceClosures.AbstractAnisotropicMinimumDissipation,Any,Val{tracer_index},Any,Vararg{Any,N} where N}} where tracer_index"><code>Oceananigans.TurbulenceClosures.â_Îº_âc</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">â_Îº_âc(i, j, k, grid, clock, c, tracer_index, closure, diffusivities)</code></pre><p>Return the diffusive flux divergence <code>â â (Îº â c)</code> for the turbulence <code>closure</code>, where <code>c</code> is an array of scalar data located at cell centers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/TurbulenceClosures/turbulence_closure_implementations/verstappen_anisotropic_minimum_dissipation.jl#L159-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.BlasiusSmagorinsky" href="#Oceananigans.TurbulenceClosures.BlasiusSmagorinsky"><code>Oceananigans.TurbulenceClosures.BlasiusSmagorinsky</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BlasiusSmagorinsky{ML, FT}</code></pre><p>Parameters for the version of the Smagorinsky closure used in the UK Met Office code Blasius, according to Polton and Belcher (2007).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/TurbulenceClosures/turbulence_closure_implementations/blasius_smagorinsky.jl#L6-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.BlasiusSmagorinsky" href="#Oceananigans.TurbulenceClosures.BlasiusSmagorinsky"><code>Oceananigans.TurbulenceClosures.BlasiusSmagorinsky</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BlasiusSmagorinsky(FT=Float64; Pr=1.0, Î½=1.05e-6, Îº=1.46e-7)</code></pre><p>Returns a <code>BlasiusSmagorinsky</code> closure object of type <code>FT</code>.</p><p><strong>Keyword arguments</strong></p><pre><code class="language-none">- `Pr` : Turbulent Prandtl numbers for each tracer. Either a constant applied to every
         tracer, or a `NamedTuple` with fields for each tracer individually.
- `Î½`  : Constant background viscosity for momentum
- `Îº`  : Constant background diffusivity for tracer. Can either be a single number
         applied to all tracers, or `NamedTuple` of diffusivities corresponding to each
         tracer.</code></pre><p><strong>References</strong></p><p>Polton, J. A., and Belcher, S. E. (2007), &quot;Langmuir turbulence and deeply penetrating jets     in an unstratified mixed layer.&quot; Journal of Geophysical Research: Oceans.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/TurbulenceClosures/turbulence_closure_implementations/blasius_smagorinsky.jl#L25-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.RozemaAnisotropicMinimumDissipation" href="#Oceananigans.TurbulenceClosures.RozemaAnisotropicMinimumDissipation"><code>Oceananigans.TurbulenceClosures.RozemaAnisotropicMinimumDissipation</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RozemaAnisotropicMinimumDissipation(FT=Float64; C=0.33, Î½=1.05e-6, Îº=1.46e-7)</code></pre><p>Returns a <code>RozemaAnisotropicMinimumDissipation</code> closure object of type <code>FT</code> with</p><pre><code class="language-none">* `C` : PoincareÌ constant
* `Î½` : &#39;molecular&#39; background viscosity
* `Îº` : &#39;molecular&#39; background diffusivity for each tracer</code></pre><p>See Rozema et al., &quot; (2015)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/TurbulenceClosures/turbulence_closure_implementations/rozema_anisotropic_minimum_dissipation.jl#L12-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.TwoDimensionalLeith" href="#Oceananigans.TurbulenceClosures.TwoDimensionalLeith"><code>Oceananigans.TurbulenceClosures.TwoDimensionalLeith</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TwoDimensionalLeith{FT} &lt;: AbstractLeith{FT}</code></pre><p>Parameters for the 2D Leith turbulence closure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.TwoDimensionalLeith" href="#Oceananigans.TurbulenceClosures.TwoDimensionalLeith"><code>Oceananigans.TurbulenceClosures.TwoDimensionalLeith</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TwoDimensionalLeith([FT=Float64;] C=0.3, C_Redi=1, C_GM=1)</code></pre><p>Return a <code>TwoDimensionalLeith</code> type associated with the turbulence closure proposed by Leith (1965) and Fox-Kemper &amp; Menemenlis (2008) which has an eddy viscosity of the form</p><pre><code class="language-none">`Î½â = (C * Îá¶ )Â³ * â(Î¶Â² + (âh âz w)Â²)`</code></pre><p>and an eddy diffusivity of the form...</p><p>where <code>Îá¶ </code> is the filter width, <code>Î¶Â² = (âx v - ây u)Â²</code> is the squared vertical vorticity, and <code>C</code> is a model constant.</p><p><strong>Keyword arguments</strong></p><pre><code class="language-none">- `C`      : Model constant
- `C_Redi` : Coefficient for down-gradient tracer diffusivity for each tracer.
             Either a constant applied to every tracer, or a `NamedTuple` with fields
             for each tracer individually.
- `C_GM`   : Coefficient for down-gradient tracer diffusivity for each tracer.
             Either a constant applied to every tracer, or a `NamedTuple` with fields
             for each tracer individually.</code></pre><p><strong>References</strong></p><p>Leith, C. E. (1968). &quot;Diffusion Approximation for TwoâDimensional Turbulence&quot;, The Physics of     Fluids 11, 671. doi: 10.1063/1.1691968</p><p>FoxâKemper, B., &amp; D. Menemenlis (2008), &quot;Can large eddy simulation techniques improve mesoscale rich     ocean models?&quot;, in Ocean Modeling in an Eddying Regime, Geophys. Monogr. Ser., vol. 177, pp. 319â337.     doi:10.1029/177GM19</p><p>Pearson, B. et al. (2017) , &quot;Evaluation of scale-aware subgrid mesoscale eddy models in a global eddy     rich model&quot;, Ocean Modelling 115, 42-58. doi: 10.1016/j.ocemod.2017.05.007</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl#L22-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.â_Îº_âc-Tuple{Any,Any,Any,Any,Any,Oceananigans.TurbulenceClosures.AbstractLeith,Any,Any,Any,Any,Any}" href="#Oceananigans.TurbulenceClosures.â_Îº_âc-Tuple{Any,Any,Any,Any,Any,Oceananigans.TurbulenceClosures.AbstractLeith,Any,Any,Any,Any,Any}"><code>Oceananigans.TurbulenceClosures.â_Îº_âc</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">â_Îº_âc(i, j, k, grid, clock, c, closure, diffusivities)</code></pre><p>Return the diffusive flux divergence <code>â â (Îº â c)</code> for the turbulence <code>closure</code>, where <code>c</code> is an array of scalar data located at cell centers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl#L196-L201">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.GiB" href="#Oceananigans.Utils.GiB"><code>Oceananigans.Utils.GiB</code></a> â <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">GiB</code></pre><p>A <code>Float64</code> constant equal to 1024<code>MiB</code>. Useful for increasing the clarity of scripts, e.g. <code>max_filesize = 50GiB</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Utils/units.jl#L61-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.KiB" href="#Oceananigans.Utils.KiB"><code>Oceananigans.Utils.KiB</code></a> â <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">KiB</code></pre><p>A <code>Float64</code> constant equal to 1024.0. Useful for increasing the clarity of scripts, e.g. <code>max_filesize = 250KiB</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Utils/units.jl#L47-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.MiB" href="#Oceananigans.Utils.MiB"><code>Oceananigans.Utils.MiB</code></a> â <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">MiB</code></pre><p>A <code>Float64</code> constant equal to 1024<code>KiB</code>. Useful for increasing the clarity of scripts, e.g. <code>max_filesize = 100MiB</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Utils/units.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.TiB" href="#Oceananigans.Utils.TiB"><code>Oceananigans.Utils.TiB</code></a> â <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">TiB</code></pre><p>A <code>Float64</code> constant equal to 1024<code>GiB</code>. Useful for increasing the clarity of scripts, e.g. <code>max_filesize = 2TiB</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Utils/units.jl#L68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.day" href="#Oceananigans.Utils.day"><code>Oceananigans.Utils.day</code></a> â <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">day</code></pre><p>A <code>Float64</code> constant equal to 24<code>hour</code>. Useful for increasing the clarity of scripts, e.g. <code>Ît = 0.5day</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Utils/units.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.hour" href="#Oceananigans.Utils.hour"><code>Oceananigans.Utils.hour</code></a> â <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">hour</code></pre><p>A <code>Float64</code> constant equal to 60<code>minute</code>. Useful for increasing the clarity of scripts, e.g. <code>Ît = 3hour</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Utils/units.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.kilometer" href="#Oceananigans.Utils.kilometer"><code>Oceananigans.Utils.kilometer</code></a> â <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">kilometer</code></pre><p>A <code>Float64</code> constant equal to 1000<code>meter</code>. Useful for increasing the clarity of scripts, e.g. <code>Lx = 250kilometer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Utils/units.jl#L40-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.meter" href="#Oceananigans.Utils.meter"><code>Oceananigans.Utils.meter</code></a> â <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">meter</code></pre><p>A <code>Float64</code> constant equal to 1.0. Useful for increasing the clarity of scripts, e.g. <code>Lx = 100meter</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Utils/units.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.minute" href="#Oceananigans.Utils.minute"><code>Oceananigans.Utils.minute</code></a> â <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">minute</code></pre><p>A <code>Float64</code> constant equal to 60<code>second</code>. Useful for increasing the clarity of scripts, e.g. <code>Ît = 15minute</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Utils/units.jl#L12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.second" href="#Oceananigans.Utils.second"><code>Oceananigans.Utils.second</code></a> â <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">second</code></pre><p>A <code>Float64</code> constant equal to 1.0. Useful for increasing the clarity of scripts, e.g. <code>Ît = 1second</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Utils/units.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.prettytime-Tuple{Any}" href="#Oceananigans.Utils.prettytime-Tuple{Any}"><code>Oceananigans.Utils.prettytime</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">prettytime(t)</code></pre><p>Convert a floating point value <code>t</code> representing an amount of time in seconds to a more human-friendly formatted string with three decimal places. Depending on the value of <code>t</code> the string will be formatted to show <code>t</code> in nanoseconds (ns), microseconds (Î¼s), milliseconds (ms), seconds (s), minutes (min), hours (hr), or days (day).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Utils/pretty_time.jl#L4-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.pretty_filesize" href="#Oceananigans.Utils.pretty_filesize"><code>Oceananigans.Utils.pretty_filesize</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pretty_filesize(s, suffix=&quot;B&quot;)</code></pre><p>Convert a floating point value <code>s</code> representing a file size to a more human-friendly formatted string with one decimal places with a <code>suffix</code> defaulting to &quot;B&quot;. Depending on the value of <code>s</code> the string will be formatted to show <code>s</code> using an SI prefix from bytes, kiB (1024 bytes), MiB (1024Â² bytes), and so on up to YiB (1024â¸ bytes).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Utils/pretty_filesize.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.cell_advection_timescale-NTuple{4,Any}" href="#Oceananigans.Utils.cell_advection_timescale-NTuple{4,Any}"><code>Oceananigans.Utils.cell_advection_timescale</code></a> â <span class="docstring-category">Method</span></header><section><div><p>Returns the time-scale for advection on a regular grid across a single grid cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Utils/cell_advection_timescale.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.validate_interval-Tuple{Any,Any}" href="#Oceananigans.Utils.validate_interval-Tuple{Any,Any}"><code>Oceananigans.Utils.validate_interval</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">validate_interval(frequency, interval)</code></pre><p>Ensure that frequency and interval are not both <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Utils/output_writer_diagnostic_utils.jl#L31-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.with_tracers-Tuple{Any,NamedTuple,Any}" href="#Oceananigans.Utils.with_tracers-Tuple{Any,NamedTuple,Any}"><code>Oceananigans.Utils.with_tracers</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">with_tracers(tracer_names, initial_tuple, tracer_default)</code></pre><p>Create a tuple corresponding to the solution variables <code>u</code>, <code>v</code>, <code>w</code>, and <code>tracer_names</code>. <code>initial_tuple</code> is a <code>NamedTuple</code> that at least has fields <code>u</code>, <code>v</code>, and <code>w</code>, and may have some fields corresponding to the names in <code>tracer_names</code>. <code>tracer_default</code> is a function that produces a default tuple value for each tracer if not included in <code>initial_tuple</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/Utils/with_tracers.jl#L1-L9">source</a></section></article><h2 id="Abstract-operations"><a class="docs-heading-anchor" href="#Abstract-operations">Abstract operations</a><a id="Abstract-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-operations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.@unary-Tuple" href="#Oceananigans.AbstractOperations.@unary-Tuple"><code>Oceananigans.AbstractOperations.@unary</code></a> â <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@unary op1 op2 op3...</code></pre><p>Turn each unary function in the list <code>(op1, op2, op3...)</code> into a unary operator on <code>Oceananigans.Fields</code> for use in <code>AbstractOperations</code>.</p><p>Note: a unary function is a function with one argument: for example, <code>sin(x)</code> is a unary function.</p><p>Also note: a unary function in <code>Base</code> must be imported to be extended: use <code>import Base: op; @unary op</code>.</p><p><strong>Example</strong></p><p>julia&gt; square<em>it(x) = x^2 square</em>it (generic function with 1 method)</p><p>julia&gt; @unary square<em>it 7-element Array{Any,1}:  :sqrt  :sin  :cos  :exp  :tanh  :-  :square</em>it</p><p>julia&gt; c = Field(Cell, Cell, Cell, CPU(), RegularCartesianGrid((1, 1, 16), (1, 1, 1)));</p><p>julia&gt; square_it(c) UnaryOperation at (Cell, Cell, Cell) âââ grid: RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}} â   âââ size: (1, 1, 16) â   âââ domain: x â [0.0, 1.0], y â [0.0, 1.0], z â [0.0, -1.0] âââ tree:</p><p>square_it at (Cell, Cell, Cell) via identity âââ OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/AbstractOperations/unary_operations.jl#L33-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.@binary-Tuple" href="#Oceananigans.AbstractOperations.@binary-Tuple"><code>Oceananigans.AbstractOperations.@binary</code></a> â <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@binary op1 op2 op3...</code></pre><p>Turn each binary function in the list <code>(op1, op2, op3...)</code> into a binary operator on <code>Oceananigans.Fields</code> for use in <code>AbstractOperations</code>.</p><p>Note: a binary function is a function with two arguments: for example, <code>+(x, y)</code> is a binary function.</p><p>Also note: a binary function in <code>Base</code> must be imported to be extended: use <code>import Base: op; @binary op</code>.</p><p><strong>Example</strong></p><p>```jldoctest julia&gt; plus<em>or</em>times(x, y) = x &lt; 0 ? x + y : x * y plus<em>or</em>times (generic function with 1 method)</p><p>julia&gt; @binary plus<em>or</em>times 6-element Array{Any,1}:  :+  :-  :/  :^  :*  :plus<em>or</em>times</p><p>julia&gt; c, d = (Field(Cell, Cell, Cell, CPU(), RegularCartesianGrid((1, 1, 16), (1, 1, 1))) for i = 1:2);</p><p>julia&gt; plus<em>or</em>times(c, d) BinaryOperation at (Cell, Cell, Cell) âââ grid: RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}} â   âââ size: (1, 1, 16) â   âââ domain: x â [0.0, 1.0], y â [0.0, 1.0], z â [0.0, -1.0] âââ tree:</p><p>plus<em>or</em>times at (Cell, Cell, Cell) via Oceananigans.AbstractOperations.identity âââ OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}} âââ OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/AbstractOperations/binary_operations.jl#L84-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.@multiary-Tuple" href="#Oceananigans.AbstractOperations.@multiary-Tuple"><code>Oceananigans.AbstractOperations.@multiary</code></a> â <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@multiary op1 op2 op3...</code></pre><p>Turn each multiary operator in the list <code>(op1, op2, op3...)</code> into a multiary operator on <code>Oceananigans.Fields</code> for use in <code>AbstractOperations</code>.</p><p>Note that a multiary operator:     * is a function with two or more arguments: for example, <code>+(x, y, z)</code> is a multiary function;     * must be imported to be extended if part of <code>Base</code>: use <code>import Base: op; @multiary op</code>;     * can only be called on <code>Oceananigans.Field</code>s if the &quot;location&quot; is noted explicitly; see example.</p><p><strong>Example</strong></p><p>```jldoctest julia&gt; harmonic<em>plus(a, b, c) = 1/3 * (1/a + 1/b + 1/c) harmonic</em>plus(generic function with 1 method)</p><p>julia&gt; @multiary harmonic<em>plus 3-element Array{Any,1}:  :+  :*  :harmonic</em>plus</p><p>julia&gt; c, d, e = Tuple(Field(Cell, Cell, Cell, CPU(), RegularCartesianGrid((1, 1, 16), (1, 1, 1))) for i = 1:3);</p><p>julia&gt; harmonic_plus(c, d, e) # this calls the original function, which in turn returns a (correct) operation tree BinaryOperation at (Cell, Cell, Cell) âââ grid: RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}} â   âââ size: (1, 1, 16) â   âââ domain: x â [0.0, 1.0], y â [0.0, 1.0], z â [0.0, -1.0] âââ tree:</p><ul><li>at (Cell, Cell, Cell) via Oceananigans.AbstractOperations.identity</li></ul><p>âââ 0.3333333333333333 âââ + at (Cell, Cell, Cell) via Oceananigans.AbstractOperations.identity  Â Â  âââ + at (Cell, Cell, Cell) via Oceananigans.AbstractOperations.identity  Â Â  âÂ Â  âââ / at (Cell, Cell, Cell) via Oceananigans.AbstractOperations.identity  Â Â  âÂ Â  âÂ Â  âââ 1  Â Â  âÂ Â  âÂ Â  âââ OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}  Â Â  âÂ Â  âââ / at (Cell, Cell, Cell) via Oceananigans.AbstractOperations.identity  Â Â   Â Â  âÂ Â  âââ 1  Â Â   Â Â  âÂ Â  âââ OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}  Â Â  âââ / at (Cell, Cell, Cell) via Oceananigans.AbstractOperations.identity  Â Â   Â Â  âââ 1  Â Â   Â Â  âââ OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}</p><p>julia&gt; @at (Cell, Cell, Cell) harmonic_plus(c, d, e) # this returns a <code>MultiaryOperation</code> as expected MultiaryOperation at (Cell, Cell, Cell) âââ grid: RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}} â   âââ size: (1, 1, 16) â   âââ domain: x â [0.0, 1.0], y â [0.0, 1.0], z â [0.0, -1.0] âââ tree:</p><p>harmonic_plus at (Cell, Cell, Cell) âââ OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}} âââ OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}} âââ OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/AbstractOperations/multiary_operations.jl#L49-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.âx-Tuple{Union{Type{Cell}, Type{Face}}}" href="#Oceananigans.AbstractOperations.âx-Tuple{Union{Type{Cell}, Type{Face}}}"><code>Oceananigans.AbstractOperations.âx</code></a> â <span class="docstring-category">Method</span></header><section><div><p>Return the x-derivative function acting at (<code>X</code>, <code>Any</code>, <code>Any</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/AbstractOperations/derivatives.jl#L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.âx-Union{Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}, Tuple{Z}, Tuple{Y}, Tuple{X}} where Z where Y where X" href="#Oceananigans.AbstractOperations.âx-Union{Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}, Tuple{Z}, Tuple{Y}, Tuple{X}} where Z where Y where X"><code>Oceananigans.AbstractOperations.âx</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">âx(a::AbstractField)</code></pre><p>Return an abstract representation of a x-derivative acting on <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/AbstractOperations/derivatives.jl#L77-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.âx-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{Tuple,Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}} where Z where Y where X" href="#Oceananigans.AbstractOperations.âx-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{Tuple,Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}} where Z where Y where X"><code>Oceananigans.AbstractOperations.âx</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">âx(L::Tuple, a::AbstractField)</code></pre><p>Return an abstract representation of an x-derivative acting on <code>a</code> followed by interpolation to <code>L</code>, where <code>L</code> is a 3-tuple of <code>Face</code>s and <code>Cell</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/AbstractOperations/derivatives.jl#L48-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.ây-Tuple{Union{Type{Cell}, Type{Face}}}" href="#Oceananigans.AbstractOperations.ây-Tuple{Union{Type{Cell}, Type{Face}}}"><code>Oceananigans.AbstractOperations.ây</code></a> â <span class="docstring-category">Method</span></header><section><div><p>Return the y-derivative function acting at (<code>Any</code>, <code>Y</code>, <code>Any</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/AbstractOperations/derivatives.jl#L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.ây-Union{Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}, Tuple{Z}, Tuple{Y}, Tuple{X}} where Z where Y where X" href="#Oceananigans.AbstractOperations.ây-Union{Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}, Tuple{Z}, Tuple{Y}, Tuple{X}} where Z where Y where X"><code>Oceananigans.AbstractOperations.ây</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ây(a::AbstractField)</code></pre><p>Return an abstract representation of a y-derivative acting on <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/AbstractOperations/derivatives.jl#L84-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.ây-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{Tuple,Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}} where Z where Y where X" href="#Oceananigans.AbstractOperations.ây-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{Tuple,Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}} where Z where Y where X"><code>Oceananigans.AbstractOperations.ây</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ây(L::Tuple, a::AbstractField)</code></pre><p>Return an abstract representation of a y-derivative acting on <code>a</code> followed by interpolation to <code>L</code>, where <code>L</code> is a 3-tuple of <code>Face</code>s and <code>Cell</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/AbstractOperations/derivatives.jl#L57-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.âz-Tuple{Union{Type{Cell}, Type{Face}}}" href="#Oceananigans.AbstractOperations.âz-Tuple{Union{Type{Cell}, Type{Face}}}"><code>Oceananigans.AbstractOperations.âz</code></a> â <span class="docstring-category">Method</span></header><section><div><p>Return the z-derivative function acting at (<code>Any</code>, <code>Any</code>, <code>Z</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/AbstractOperations/derivatives.jl#L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.âz-Union{Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}, Tuple{Z}, Tuple{Y}, Tuple{X}} where Z where Y where X" href="#Oceananigans.AbstractOperations.âz-Union{Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}, Tuple{Z}, Tuple{Y}, Tuple{X}} where Z where Y where X"><code>Oceananigans.AbstractOperations.âz</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">âz(a::AbstractField)</code></pre><p>Return an abstract representation of a z-derivative acting on <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/AbstractOperations/derivatives.jl#L90-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.âz-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{Tuple,Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}} where Z where Y where X" href="#Oceananigans.AbstractOperations.âz-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{Tuple,Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}} where Z where Y where X"><code>Oceananigans.AbstractOperations.âz</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">âz(L::Tuple, a::AbstractField)</code></pre><p>Return an abstract representation of a z-derivative acting on <code>a</code> followed by interpolation to <code>L</code>, where <code>L</code> is a 3-tuple of <code>Face</code>s and <code>Cell</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/AbstractOperations/derivatives.jl#L66-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.Computation" href="#Oceananigans.AbstractOperations.Computation"><code>Oceananigans.AbstractOperations.Computation</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Computation{T, R, O, G}</code></pre><p>Represents an operation performed over the elements of a field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/AbstractOperations/computations.jl#L6-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.Computation-Tuple" href="#Oceananigans.AbstractOperations.Computation-Tuple"><code>Oceananigans.AbstractOperations.Computation</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(computation::Computation)(args...)</code></pre><p>Performs the <code>compute(computation)</code> and returns the result if <code>isnothing(return_type)</code>, or the result after being converted to <code>return_type</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/AbstractOperations/computations.jl#L60-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.Computation-Tuple{Any,Any}" href="#Oceananigans.AbstractOperations.Computation-Tuple{Any,Any}"><code>Oceananigans.AbstractOperations.Computation</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Computation(operation, result; return_type=Array)</code></pre><p>Returns a <code>Computation</code> representing an <code>operation</code> performed over the elements of <code>operation.grid</code> and stored in <code>result</code>. <code>return_type</code> specifies the output type when the <code>Computation</code> instances is called as a function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/AbstractOperations/computations.jl#L18-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.compute!-Tuple{Computation}" href="#Oceananigans.AbstractOperations.compute!-Tuple{Computation}"><code>Oceananigans.AbstractOperations.compute!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute!(computation::Computation)</code></pre><p>Perform a <code>computation</code>. The result is stored in <code>computation.result</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/AbstractOperations/computations.jl#L34-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.@at-Tuple{Any,Any}" href="#Oceananigans.AbstractOperations.@at-Tuple{Any,Any}"><code>Oceananigans.AbstractOperations.@at</code></a> â <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@at location abstract_operation</code></pre><p>Modify the <code>abstract_operation</code> so that it returns values at <code>location</code>, where <code>location</code> is a 3-tuple of <code>Face</code>s and <code>Cell</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/b8f28c2b7d5f66bf113260b2f0dd4d47f3f62a68/src/AbstractOperations/interpolation_utils.jl#L86-L91">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../contributing/">Â« Contributor&#39;s guide</a><a class="docs-footer-nextpage" href="../appendix/staggered_grid/">Staggered grid Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 22 July 2020 21:05">Wednesday 22 July 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

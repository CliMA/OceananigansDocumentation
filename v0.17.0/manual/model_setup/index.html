<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Model setup · Oceananigans.jl</title><link rel="canonical" href="https://climate-machine.github.io/Oceananigans.jl/latest/manual/model_setup/index.html"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Oceananigans.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../generated/simple_diffusion/">One-dimensional diffusion</a></li><li><a class="tocitem" href="../../generated/two_dimensional_turbulence/">Two-dimensional turbulence</a></li><li><a class="tocitem" href="../../generated/ocean_wind_mixing_and_convection/">Ocean wind mixing and convection</a></li><li><a class="tocitem" href="../../generated/ocean_convection_with_plankton/">Ocean convection with plankton</a></li><li><a class="tocitem" href="../../generated/internal_wave/">Internal wave</a></li></ul></li><li class="is-active"><a class="tocitem" href>Model setup</a><ul class="internal"><li><a class="tocitem" href="#Architecture-1"><span>Architecture</span></a></li><li><a class="tocitem" href="#Number-type-1"><span>Number type</span></a></li><li><a class="tocitem" href="#Grids-1"><span>Grids</span></a></li><li><a class="tocitem" href="#Clock-1"><span>Clock</span></a></li><li><a class="tocitem" href="#Coriolis-1"><span>Coriolis</span></a></li><li><a class="tocitem" href="#Tracers-1"><span>Tracers</span></a></li><li><a class="tocitem" href="#Buoyancy-and-equation-of-state-1"><span>Buoyancy and equation of state</span></a></li><li><a class="tocitem" href="#Boundary-conditions-1"><span>Boundary conditions</span></a></li><li><a class="tocitem" href="#Forcing-functions-1"><span>Forcing functions</span></a></li><li><a class="tocitem" href="#Parameters-1"><span>Parameters</span></a></li><li><a class="tocitem" href="#Turbulent-diffusivity-closures-and-large-eddy-simulation-models-1"><span>Turbulent diffusivity closures and large eddy simulation models</span></a></li><li><a class="tocitem" href="#Diagnostics-1"><span>Diagnostics</span></a></li><li><a class="tocitem" href="#Output-writers-1"><span>Output writers</span></a></li><li><a class="tocitem" href="#Time-stepping-1"><span>Time stepping</span></a></li><li><a class="tocitem" href="#Setting-initial-conditions-1"><span>Setting initial conditions</span></a></li></ul></li><li><a class="tocitem" href="../physics/">Physics</a></li><li><span class="tocitem">Numerical implementation</span><ul><li><a class="tocitem" href="../pressure_decomposition/">Pressure decomposition</a></li><li><a class="tocitem" href="../time_stepping/">Time stepping</a></li><li><a class="tocitem" href="../finite_volume/">Finite volume method</a></li><li><a class="tocitem" href="../spatial_operators/">Spatial operators</a></li><li><a class="tocitem" href="../boundary_conditions/">Boundary conditions</a></li><li><a class="tocitem" href="../poisson_solvers/">Poisson solvers</a></li><li><a class="tocitem" href="../large_eddy_simulation/">Large eddy simulation</a></li></ul></li><li><span class="tocitem">Verification experiments</span><ul><li><a class="tocitem" href="../../verification/taylor_green_vortex/">Taylor-Green vortex</a></li><li><a class="tocitem" href="../../verification/stratified_couette_flow/">Stratified Couette flow</a></li></ul></li><li><a class="tocitem" href="../../gallery/">Gallery</a></li><li><a class="tocitem" href="../../benchmarks/">Performance benchmarks</a></li><li><a class="tocitem" href="../../library/">Library</a></li><li><span class="tocitem">Appendix</span><ul><li><a class="tocitem" href="../staggered_grid/">Staggered grid</a></li><li><a class="tocitem" href="../fractional_step/">Fractional step method</a></li></ul></li><li><a class="tocitem" href="../../subject_index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Model setup</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Model setup</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/climate-machine/Oceananigans.jl/blob/master/docs/src/manual/model_setup.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Model-setup-1"><a class="docs-heading-anchor" href="#Model-setup-1">Model setup</a><a class="docs-heading-anchor-permalink" href="#Model-setup-1" title="Permalink"></a></h1><p>This section describes all the options and features that can be used to set up a model. For more detailed information consult the API documentation.</p><p>Each structure covered in this section can be constructed and passed to the <code>Model</code> constructor. For examples of model construction, see the examples. The verification experiments provide more advanced examples.</p><h2 id="Architecture-1"><a class="docs-heading-anchor" href="#Architecture-1">Architecture</a><a class="docs-heading-anchor-permalink" href="#Architecture-1" title="Permalink"></a></h2><p>Passing <code>architecture = CPU()</code> or <code>architecture = GPU()</code> to the <code>Model</code> constructor will determine whether the model is time stepped on a CPU or GPU.</p><p>Ideally a set up or simulation script does not need to be modified to run on a GPU but we are still smoothing out rough edges. Generally the CPU wants <code>Array</code> objects while the GPU wants <code>CuArray</code> objects.</p><div class="admonition is-success"><header class="admonition-header">Running on GPUs</header><div class="admonition-body"><p>If you are having issues with running Oceananigans on a GPU, please <a href="https://github.com/climate-machine/Oceananigans.jl/issues/new">open an issue</a> and we&#39;ll do our best to help out.</p></div></div><h2 id="Number-type-1"><a class="docs-heading-anchor" href="#Number-type-1">Number type</a><a class="docs-heading-anchor-permalink" href="#Number-type-1" title="Permalink"></a></h2><p>Passing <code>float_type=Float64</code> or <code>float_type=Float32</code> to the <code>Model</code> constructor causes the model to store all numbers with 64-bit or 32-bit floating point precision.</p><div class="admonition is-info"><header class="admonition-header">Avoiding mixed-precision operations</header><div class="admonition-body"><p>When not using <code>Float64</code> be careful to not mix different precisions as it could introduce implicit type conversions which can negatively effect performance. You can pass the number type desires to many constructors to enforce the type you want: e.g. <code>RegularCartesianGrid(Float32; size=(16, 16, 16), length=(1, 1, 1))</code> and <code>ConstantIsotropicDiffusivity(Float16; κ=1//7, ν=2//7)</code>.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Effect of floating point precision on simulation accuracy</header><div class="admonition-body"><p>While we run many tests with both <code>Float32</code> and <code>Float64</code> it is not clear whether <code>Float32</code> is precise enough to provide similar accuracy in all use cases. If accuracy is a concern, stick to <code>Float64</code>.</p><p>We will be actively investigating the possibility of using lower precision floating point numbers such as <code>Float32</code> and <code>Float16</code> for fluid dynamics as well as the use of alternative number types such as Posits and Sonums.</p></div></div><h2 id="Grids-1"><a class="docs-heading-anchor" href="#Grids-1">Grids</a><a class="docs-heading-anchor-permalink" href="#Grids-1" title="Permalink"></a></h2><p>Currently only a regular Cartesian grid with constant grid spacings is supported. The spacing can be different for each dimension.</p><p>When constructing a <code>RegularCartesianGrid</code> the number of grid points (or size of the grid) must be passed a tuple along with the physical length of each dimension.</p><p>A regular Cartesian grid with <span>$N_x \times N_y \times N_z = 64 \times 32 \times 16$</span> grid points and a length of <span>$L_x = 200$</span> meters, <span>$L_y = 100$</span> meters, and <span>$L_z = 100$</span> meters is constructed using</p><pre><code class="language-">grid = RegularCartesianGrid(size=(64, 32, 16), length=(200, 100, 100))</code></pre><div class="admonition is-info"><header class="admonition-header">Default domain</header><div class="admonition-body"><p>By default <span>$x \in [0, L_x]$</span>, <span>$y \in [0, L_y]$</span>, and <span>$z \in [-L_z, 0]$</span> which is common for oceanographic applications.</p></div></div><h3 id="Specifying-the-domain-1"><a class="docs-heading-anchor" href="#Specifying-the-domain-1">Specifying the domain</a><a class="docs-heading-anchor-permalink" href="#Specifying-the-domain-1" title="Permalink"></a></h3><p>To specify a different domain, the <code>x</code>, <code>y</code>, and <code>z</code> keyword arguments can be used instead of <code>length</code>. For example, to use the domain <span>$x \in [-100, 100]$</span> meters, <span>$y \in [-50, 50]$</span> meters, and <span>$z \in [0, 100]$</span> meters</p><pre><code class="language-">grid = RegularCartesianGrid(size=(64, 32, 16), x=(-100, 100), y=(-50, 50), z=(0, 100))</code></pre><h3 id="Two-dimensional-grids-1"><a class="docs-heading-anchor" href="#Two-dimensional-grids-1">Two-dimensional grids</a><a class="docs-heading-anchor-permalink" href="#Two-dimensional-grids-1" title="Permalink"></a></h3><p>Two-dimensional grids can be constructed by setting the number of grid points along the flat dimension to be 1. A two-dimensional grid in the <span>$xz$</span>-plane can be constructed using</p><pre><code class="language-">grid = RegularCartesianGrid(size=(64, 1, 16), length=(200, 1, 100))</code></pre><p>In this case the length of the <span>$y$</span> dimension must be specified but does not matter so we just set it to 1.</p><p>2D grids can be used to simulate <span>$xy$</span>, <span>$xz$</span>, and <span>$yz$</span> planes.</p><h3 id="One-dimensional-grids-1"><a class="docs-heading-anchor" href="#One-dimensional-grids-1">One-dimensional grids</a><a class="docs-heading-anchor-permalink" href="#One-dimensional-grids-1" title="Permalink"></a></h3><p>One-dimensional grids can be constructed in a similar manner, most commonly used to set up vertical column models. For example, to set up a 1D model with <span>$N_z$</span> grid points</p><pre><code class="language-">grid = RegularCartesianGrid(size=(1, 1, 90), length=(1, 1, 1000))</code></pre><div class="admonition is-warning"><header class="admonition-header">One-dimensional horizontal models</header><div class="admonition-body"><p>We only test one-dimensional vertical models and cannot guarantee that one-dimensional horizontal models will work as expected.</p></div></div><h2 id="Clock-1"><a class="docs-heading-anchor" href="#Clock-1">Clock</a><a class="docs-heading-anchor-permalink" href="#Clock-1" title="Permalink"></a></h2><p>The clock holds the current iteration number and time. By default the model starts at iteration number 0 and time 0</p><pre><code class="language-">clock = Clock(0, 0)</code></pre><p>but can be modified if you wish to start the model clock at some other time. If you want iteration 0 to correspond to <span>$t = 3600$</span> seconds, then you can construct</p><pre><code class="language-">clock = Clock(0, 3600)</code></pre><p>and pass it to the model.</p><h2 id="Coriolis-1"><a class="docs-heading-anchor" href="#Coriolis-1">Coriolis</a><a class="docs-heading-anchor-permalink" href="#Coriolis-1" title="Permalink"></a></h2><p>The Coriolis option determines whether the fluid experiences the effect of the Coriolis force, or rotation. Currently three options are available: no rotation, <span>$f$</span>-plane, and <span>$\beta$</span>-plane.</p><div class="admonition is-info"><header class="admonition-header">Coriolis vs. rotation</header><div class="admonition-body"><p>If you are wondering why this option is called &quot;Coriolis&quot; it is because rotational effects could include the Coriolis and centripetal forces, both of which arise in non-inertial reference frames. But here the model only considers the Coriolis force.</p></div></div><p>To use no rotation, pass</p><pre><code class="language-julia">coriolis = nothing</code></pre><h3 id="f-plane-1"><a class="docs-heading-anchor" href="#f-plane-1"><span>$f$</span>-plane</a><a class="docs-heading-anchor-permalink" href="#f-plane-1" title="Permalink"></a></h3><p>To set up an <span>$f$</span>-plane with, for example, rotation rate <span>$f = 10^{-4} \text{s}^{-1}$</span></p><pre><code class="language-">coriolis = FPlane(f=1e-4)</code></pre><p>An <span>$f$</span>-plane can also be specified at some latitude on a spherical planet with a planetary rotation rate. For example, to specify an <span>$f$</span>-plane at a latitude of <span>$\varphi = 45°\text{N}$</span> on Earth which has a rotation rate of <span>$\Omega = 7.292115 \times 10^{-5} \text{s}^{-1}$</span></p><pre><code class="language-">coriolis = FPlane(rotation_rate=7.292115e-5, latitude=45)</code></pre><p>in which case the value of <span>$f$</span> is given by <span>$2\Omega\sin\varphi$</span>.</p><h3 id="\\beta-plane-1"><a class="docs-heading-anchor" href="#\\beta-plane-1"><span>$\beta$</span>-plane</a><a class="docs-heading-anchor-permalink" href="#\\beta-plane-1" title="Permalink"></a></h3><p>To set up a <span>$\beta$</span>-plane the background rotation rate <span>$f_0$</span> and the <span>$\beta$</span> parameter must be specified. For example, a <span>$\beta$</span>-plane with <span>$f_0 = 10^{-4} \text{s}^{-1}$</span> and <span>$\beta = 1.5 \times 10^{-11} \text{s}^{-1}\text{m}^{-1}$</span> can be set up with</p><pre><code class="language-">coriolis = BetaPlane(f₀=1e-4, β=1.5e-11)</code></pre><p>Alternatively, a <span>$\beta$</span>-plane can also be set up at some latitude on a spherical planet with a planetary rotation rate and planetary radius. For example, to specify a <span>$\beta$</span>-plane at a latitude of <span>$\varphi = 10\degree{S}$</span> on Earth which has a rotation rate of <span>$\Omega = 7.292115 \times 10^{-5} \text{s}^{-1}$</span> and a radius of <span>$R = 6,371 \text{km}$</span></p><pre><code class="language-">coriolis = BetaPlane(rotation_rate=7.292115e-5, latitude=-10, radius=6371e3)</code></pre><p>in which case <span>$f_0 = 2\Omega\sin\varphi$</span> and <span>$\beta = 2\Omega\cos\varphi / R$</span>.</p><h2 id="Tracers-1"><a class="docs-heading-anchor" href="#Tracers-1">Tracers</a><a class="docs-heading-anchor-permalink" href="#Tracers-1" title="Permalink"></a></h2><p>The tracers to be advected around can be specified via a list of symbols. By default the model evolves temperature and salinity</p><pre><code class="language-julia">tracers = (:T, :S)</code></pre><pre><code class="language-none">(:T, :S)</code></pre><p>but any number of arbitrary tracers can be appended to this list. For example, to evolve quantities <span>$C_1$</span>, CO₂, and nitrogen as passive tracers you could set them up as</p><pre><code class="language-julia">tracers = (:T, :S, :C₁, :CO₂, :nitrogen)</code></pre><pre><code class="language-none">(:T, :S, :C₁, :CO₂, :nitrogen)</code></pre><div class="admonition is-info"><header class="admonition-header">Active vs. passive tracers</header><div class="admonition-body"><p>An active tracer typically denotes a tracer quantity that affects the fluid dynamics through buoyancy. In the ocean temperature and salinity are active tracers. Passive tracers, on the other hand, typically do not affect the fluid dynamics are are <em>passively</em> advected around by the flow field.</p></div></div><h2 id="Buoyancy-and-equation-of-state-1"><a class="docs-heading-anchor" href="#Buoyancy-and-equation-of-state-1">Buoyancy and equation of state</a><a class="docs-heading-anchor-permalink" href="#Buoyancy-and-equation-of-state-1" title="Permalink"></a></h2><p>The buoyancy option selects how buoyancy is treated. There are currently three options:</p><ol><li>No buoyancy (and no gravity).</li><li>Evolve buoyancy as a tracer.</li><li><em>Seawater buoyancy</em>: evolve temperature <span>$T$</span> and salinity <span>$S$</span> as tracers with a value for the gravitational acceleration <span>$g$</span> and an appropriate equation of state.</li></ol><h3 id="No-buoyancy-1"><a class="docs-heading-anchor" href="#No-buoyancy-1">No buoyancy</a><a class="docs-heading-anchor-permalink" href="#No-buoyancy-1" title="Permalink"></a></h3><p>To turn off buoyancy (and gravity) simply pass</p><pre><code class="language-julia">buoyancy = nothing</code></pre><p>to the <code>Model</code> constructor. In this case, you will probably also want to explicitly specify which tracers to evolve. In particular, you probably will not want to evolve temperature and salinity, which are included by default. To specify no tracers, also pass</p><pre><code class="language-julia">tracers = ()</code></pre><pre><code class="language-none">()</code></pre><p>to the <code>Model</code> constructor.</p><h3 id="Buoyancy-as-a-tracer-1"><a class="docs-heading-anchor" href="#Buoyancy-as-a-tracer-1">Buoyancy as a tracer</a><a class="docs-heading-anchor-permalink" href="#Buoyancy-as-a-tracer-1" title="Permalink"></a></h3><p>To directly evolve buoyancy as a tracer simply pass</p><pre><code class="language-">buoyancy = BuoyancyTracer()</code></pre><p>to the <code>Model</code> constructor. Buoyancy <code>:b</code> must be included as a tracer, for example, by also passing</p><pre><code class="language-julia">tracers = (:b)</code></pre><pre><code class="language-none">:b</code></pre><h3 id="Seawater-buoyancy-1"><a class="docs-heading-anchor" href="#Seawater-buoyancy-1">Seawater buoyancy</a><a class="docs-heading-anchor-permalink" href="#Seawater-buoyancy-1" title="Permalink"></a></h3><p>To evolve temperature <span>$T$</span> and salinity <span>$S$</span> and diagnose the buoyancy, you can pass</p><pre><code class="language-">buoyancy = SeawaterBuoyancy()</code></pre><p>which is also the default. Without any options specified, a value of <span>$g = 9.80665 \; \text{m/s}^2$</span> is used for the gravitational acceleration (corresponding to <a href="https://en.wikipedia.org/wiki/Standard_gravity">standard gravity</a>) along with a linear equation of state with thermal expansion and haline contraction coefficients suitable for water.</p><p>If, for example, you wanted to simulate fluids on another planet such as Europa where <span>$g = 1.3 \; \text{m/s}^2$</span>, then use</p><pre><code class="language-">buoyancy = SeawaterBuoyancy(gravitational_acceleration=1.3)</code></pre><p>When using <code>SeawaterBuoyancy</code> temperature <code>:T</code> and salinity <code>:S</code> tracers must be specified</p><pre><code class="language-julia">tracers = (:T, :S)</code></pre><pre><code class="language-none">(:T, :S)</code></pre><h4 id="Linear-equation-of-state-1"><a class="docs-heading-anchor" href="#Linear-equation-of-state-1">Linear equation of state</a><a class="docs-heading-anchor-permalink" href="#Linear-equation-of-state-1" title="Permalink"></a></h4><p>To use non-default thermal expansion and haline contraction coefficients, say <span>$\alpha = 2 \times 10^{-3} \; \text{K}^{-1}$</span> and <span>$\beta = 5 \times 10{-4} \text{ppt}^{-1}$</span> corresponding to some other fluid, then use</p><pre><code class="language-">buoyancy = SeawaterBuoyancy(equation_of_state = LinearEquationOfState(α=1.67e-4, β=7.80e-4))</code></pre><h4 id="Idealized-nonlinear-equation-of-state-1"><a class="docs-heading-anchor" href="#Idealized-nonlinear-equation-of-state-1">Idealized nonlinear equation of state</a><a class="docs-heading-anchor-permalink" href="#Idealized-nonlinear-equation-of-state-1" title="Permalink"></a></h4><p>Instead of a linear equation of state, five idealized nonlinear equation of state as described by Roquet et al. (2015) may be specified. See <a href="manual/@ref RoquetIdealizedNonlinearEquationOfState"><code>RoquetIdealizedNonlinearEquationOfState</code></a>.</p><h2 id="Boundary-conditions-1"><a class="docs-heading-anchor" href="#Boundary-conditions-1">Boundary conditions</a><a class="docs-heading-anchor-permalink" href="#Boundary-conditions-1" title="Permalink"></a></h2><p>A boundary condition is applied to each field, dimension, and endpoint. There are left and right (or bottom and top) boundary conditions for each of the x, y, and z dimensions so each field is associated with 6 boundary conditions. Each of these boundary conditions may be specified individually. Each boundary condition can be specified via a constant value, an array, or a function.</p><p>See <a href="../boundary_conditions/#numerical_bcs-1">Numerical implementation of boundary conditions</a> for more details.</p><div class="admonition is-warning"><header class="admonition-header">Consistent boundary conditions</header><div class="admonition-body"><p>Be careful to ensure that you don&#39;t set up a model with inconsistent boundary conditions. For example, periodic boundary conditions should remain imposed on all fields and endpoints for periodic dimensions, and velocities normal to a wall (e.g. vertical velocity w with walls at the top and bottom) must have no-penetration boundary conditions.</p></div></div><h3 id="Types-of-boundary-conditions-1"><a class="docs-heading-anchor" href="#Types-of-boundary-conditions-1">Types of boundary conditions</a><a class="docs-heading-anchor-permalink" href="#Types-of-boundary-conditions-1" title="Permalink"></a></h3><ol><li><a href="../../library/#Oceananigans.Periodic"><code>Periodic</code></a></li><li><a href="../../library/#Oceananigans.Flux"><code>Flux</code></a></li><li><a href="../../library/#Oceananigans.Value"><code>Value</code></a> (<a href="../../library/#Oceananigans.Dirchlet"><code>Dirchlet</code></a>)</li><li><a href="../../library/#Oceananigans.Gradient"><code>Gradient</code></a> (<a href="../../library/#Oceananigans.Neumann"><code>Neumann</code></a>)</li><li><a href="manual/@ref NoPenetration"><code>No-penetration</code></a></li></ol><p>Notice that open boundary conditions and radiation boundary conditions can be imposed via flux or value boundary conditions defined by a function or array.</p><h3 id="Default-boundary-conditions-1"><a class="docs-heading-anchor" href="#Default-boundary-conditions-1">Default boundary conditions</a><a class="docs-heading-anchor-permalink" href="#Default-boundary-conditions-1" title="Permalink"></a></h3><p>By default, periodic boundary conditions are applied on all fields along periodic dimensions. All other boundary conditions are no-flux, except for velocities normal to a wall which get no-penetration boundary conditions.</p><h3 id="Boundary-condition-structures-1"><a class="docs-heading-anchor" href="#Boundary-condition-structures-1">Boundary condition structures</a><a class="docs-heading-anchor-permalink" href="#Boundary-condition-structures-1" title="Permalink"></a></h3><p>Oceananigans uses a hierarchical structure to expressing boundary conditions.</p><ol><li>A <a href="../../library/#Oceananigans.BoundaryCondition"><code>BoundaryCondition</code></a> is associated with every field, dimension, and endpoint.</li><li>Boundary conditions specifying the condition at the left and right endpoints (or top and bottom endpoints) are grouped into <a href="../../library/#Oceananigans.CoordinateBoundaryConditions"><code>CoordinateBoundaryConditions</code></a>.</li><li>A set of three <code>CoordinateBoundaryConditions</code> specifying the boundary conditions along the x, y, and z dimensions for a single field are grouped into a <a href="../../library/#Oceananigans.FieldBoundaryConditions"><code>FieldBoundaryConditions</code></a> named tuple.</li><li>A set of <code>FieldBoundaryConditions</code>, one for each field, are grouped together into a named tuple and passed to the <code>Model</code> constructor.</li></ol><p>Boundary conditions are defined at model construction time by passing a named tuple of <code>FieldBoundaryConditions</code> specifying boundary conditions on every field: velocities (<span>$u$</span>, <span>$v$</span>, <span>$w$</span>) and all tracers.</p><p>Typically you only want to impose a few boundary conditions, in which case it&#39;s useful to use convenience constructors such as <a href="../../library/#Oceananigans.HorizontallyPeriodicBCs-Tuple{}"><code>HorizontallyPeriodicBCs</code></a> when constructing horizontally periodic boundary conditions for a field and <a href="../../library/#Oceananigans.HorizontallyPeriodicSolutionBCs-Tuple{}"><code>HorizontallyPeriodicSolutionBCs</code></a> when constructing horizontally periodic boundary conditions for a model. Also see <a href="../../library/#Oceananigans.ChannelBCs-Tuple{}"><code>ChannelBCs</code></a> and <a href="../../library/#Oceananigans.ChannelSolutionBCs-Tuple{}"><code>ChannelSolutionBCs</code></a>.</p><p>See the sections below for more details. The examples and verification experiments also provide examples for setting up many difference kinds of boundary conditions.</p><h3 id="Creating-individual-boundary-conditions-1"><a class="docs-heading-anchor" href="#Creating-individual-boundary-conditions-1">Creating individual boundary conditions</a><a class="docs-heading-anchor-permalink" href="#Creating-individual-boundary-conditions-1" title="Permalink"></a></h3><p>Some examples of creating individual boundary conditions:</p><ol><li>A constant Value (Dirchlet) boundary condition, perhaps representing a constant temperature at some boundary.</li></ol><pre><code class="language-">constant_T_bc = BoundaryCondition(Value, 20)</code></pre><ol><li>A constant flux boundary condition, perhaps representing a constant wind stress at some boundary such as the ocean surface.</li></ol><pre><code class="language-">ρ₀ = 1027  # Reference density [kg/m³]
τₓ = 0.08  # Wind stress [N/m²]
wind_stress_bc = BoundaryCondition(Flux, τₓ/ρ₀)</code></pre><ol><li>A spatially varying (white noise) cooling flux to be imposed at some boundary. Note that the boundary condition is given by the array <code>Q</code> here. When running on the GPU, <code>Q</code> must be converted to a <code>CuArray</code>.</li></ol><pre><code class="language-">Nx, Ny = 16, 16  # Number of grid points.

ρ₀ = 1027  # Reference density [kg/m³]
cₚ = 4000  # Heat capacity of water at constant pressure [J/kg/K]

Q  = randn(Nx, Ny) ./ (ρ₀ * cₚ)

white_noise_T_bc = BoundaryCondition(Flux, Q)</code></pre><h3 id="Specifying-boundary-conditions-with-functions-1"><a class="docs-heading-anchor" href="#Specifying-boundary-conditions-with-functions-1">Specifying boundary conditions with functions</a><a class="docs-heading-anchor-permalink" href="#Specifying-boundary-conditions-with-functions-1" title="Permalink"></a></h3><p>You can also specify the boundary condition via a function. For z boundary conditions the function will be called with the signature</p><pre><code class="language-none">f(i, j, grid, t, U, C, params)</code></pre><p>where <code>i, j</code> is the grid index, <code>grid</code> is <code>model.grid</code>, <code>t</code> is the <code>model.clock.time</code>, <code>U</code> is the named tuple <code>model.velocities</code>, <code>C</code> is the named tuple <code>C.tracers</code>, and <code>params</code> is the user-defined <code>model.parameters</code>. The signature is similar for x and y boundary conditions expect that <code>i, j</code> is replaced with <code>j, k</code> and <code>i, k</code> respectively.</p><p>We can add a fourth example now:</p><ol><li>A spatially varying and time-dependent heating representing perhaps a localized source of heating modulated by a diurnal cycle.</li></ol><pre><code class="language-">@inline Q(i, j, grid, t, U, C, params) = @inbounds exp(-(grid.xC[i]^2 + grid.yC[j]^2)) * sin(2π*t)
localized_heating_bc = BoundaryCondition(Flux, Q)</code></pre><div class="admonition is-info"><header class="admonition-header">Performance of functions in boundary conditions</header><div class="admonition-body"><p>For performance reasons, you should define all functions used in boundary conditions as inline functions via the <code>@inline</code> macro. If any arrays are accessed within the function, disabling bounds-checking with <code>@inbounds</code> can also speed things up.</p></div></div><h3 id="Specifying-boundary-conditions-on-a-field-1"><a class="docs-heading-anchor" href="#Specifying-boundary-conditions-on-a-field-1">Specifying boundary conditions on a field</a><a class="docs-heading-anchor-permalink" href="#Specifying-boundary-conditions-on-a-field-1" title="Permalink"></a></h3><p>To, for example, create a set of horizontally periodic field boundary conditions</p><pre><code class="language-">T_bcs = HorizontallyPeriodicBCs(   top = BoundaryCondition(Value, 20),
                                bottom = BoundaryCondition(Gradient, 0.01))</code></pre><p>which will create a <a href="../../library/#Oceananigans.FieldBoundaryConditions"><code>FieldBoundaryConditions</code></a> object for temperature T appropriate for horizontally periodic model configurations where the x and y boundary conditions are all periodic.</p><h3 id="Specifying-model-boundary-conditions-1"><a class="docs-heading-anchor" href="#Specifying-model-boundary-conditions-1">Specifying model boundary conditions</a><a class="docs-heading-anchor-permalink" href="#Specifying-model-boundary-conditions-1" title="Permalink"></a></h3><p>A named tuple of <a href="../../library/#Oceananigans.FieldBoundaryConditions"><code>FieldBoundaryConditions</code></a> objects must be passed to the Model constructor specifying boundary conditions on all fields. To, for example, impose non-default boundary conditions on the u-velocity and temperature</p><pre><code class="language-">u_bcs = HorizontallyPeriodicBCs(   top = BoundaryCondition(Value, 0.1),
                                bottom = BoundaryCondition(Value, -0.1))
T_bcs = HorizontallyPeriodicBCs(   top = BoundaryCondition(Value, 20),
                                bottom = BoundaryCondition(Gradient, 0.01))

model_bcs = HorizontallyPeriodicSolutionBCs(u=u_bc, T=T_bcs)

model = Model(grid=RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1)),
              boundary_conditions=model_bcs)</code></pre><h2 id="Forcing-functions-1"><a class="docs-heading-anchor" href="#Forcing-functions-1">Forcing functions</a><a class="docs-heading-anchor-permalink" href="#Forcing-functions-1" title="Permalink"></a></h2><p>Can be used to implement anything you wish, as long as it can be expressed as extra terms in the momentum equation or tracer evolution equations.</p><p>Forcing functions will be called with the signature</p><pre><code class="language-none">f(i, j, k, grid, t, U, C, params)</code></pre><p>where <code>i, j, k</code> is the grid index, <code>grid</code> is <code>model.grid</code>, <code>t</code> is the <code>model.clock.time</code>, <code>U</code> is the named tuple <code>model.velocities</code>, <code>C</code> is the named tuple <code>C.tracers</code>, and <code>params</code> is the user-defined <code>model.parameters</code>.</p><p>Once you have defined all the forcing functions needed by the model, <code>ModelForcing</code> can be used to create a named tuple of forcing functions that can be passed to the <code>Model</code> constructor.</p><p>Some examples:</p><ol><li>Implementing a sponge layer at the bottom of the domain that damps the velocity (to filter out waves) with an</li></ol><p>e-folding length scale of 1% of the domain height.</p><pre><code class="language-">N, L = 16, 100
grid = RegularCartesianGrid(size=(N, N, N), length=(L, L, L))

const τ⁻¹ = 1 / 60  # Damping/relaxation time scale [s⁻¹].
const Δμ = 0.01L    # Sponge layer width [m] set to 1% of the domain height.
@inline μ(z, Lz) = τ⁻¹ * exp(-(z+Lz) / Δμ)

@inline Fu(grid, U, Φ, i, j, k) = @inbounds -μ(grid.zC[k], grid.Lz) * U.u[i, j, k]
@inline Fv(grid, U, Φ, i, j, k) = @inbounds -μ(grid.zC[k], grid.Lz) * U.v[i, j, k]
@inline Fw(grid, U, Φ, i, j, k) = @inbounds -μ(grid.zF[k], grid.Lz) * U.w[i, j, k]

forcing = ModelForcing(Fu=Fu, Fv=Fv, Fw=Fw)
model = Model(grid=grid, forcing=forcing)</code></pre><ol><li>Implementing a point source of fresh meltwater from ice shelf melting via a relaxation term</li></ol><pre><code class="language-">Nx = Ny = Nz = 16
Lx = Ly = Lz = 1000
grid = RegularCartesianGrid(size=(Nx, Ny, Nz), length=(Lx, Ly, Lz))

λ = 1/(1minute)  # Relaxation timescale [s⁻¹].

# Temperature and salinity of the meltwater outflow.
T_source = -1
S_source = 33.95

# Index of the point source at the middle of the southern wall.
source_index = (Int(Nx/2), 1, Int(Nz/2))

# Point source
@inline T_point_source(i, j, k, grid, time, U, C, p) =
    @inbounds ifelse((i, j, k) == p.source_index, -p.λ * (C.T[i, j, k] - p.T_source), 0)

@inline S_point_source(i, j, k, grid, time, U, C, p) =
    @inbounds ifelse((i, j, k) == p.source_index, -p.λ * (C.S[i, j, k] - p.S_source), 0)

params = (source_index=source_index, T_source=T_source, S_source=S_source, λ=λ)

forcing = ModelForcing(T=T_point_source, S=S_point_source)</code></pre><ol><li>You can also define a forcing as a function of <code>(x, y, z, t)</code> or <code>(x, y, z, t, params)</code> using the <code>SimpleForcing</code></li></ol><p>constructor.</p><pre><code class="language-">const a = 2.1
fun_forcing(x, y, z, t) = a * exp(z) * cos(t)
u_forcing = SimpleForcing(fun_forcing)

parameterized_forcing(x, y, z, t, p) = p.μ * exp(z/p.λ) * cos(p.ω*t)
v_forcing = SimpleForcing(parameterized_forcing, parameters=(μ=42, λ=0.1, ω=π))

forcing = ModelForcing(u=u_forcing, v=v_forcing)

model = Model(grid=RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1)),
              forcing=forcing)</code></pre><h2 id="Parameters-1"><a class="docs-heading-anchor" href="#Parameters-1">Parameters</a><a class="docs-heading-anchor-permalink" href="#Parameters-1" title="Permalink"></a></h2><p>A user-defined object (could be anything) can be passed via the <code>parameters</code> keyword to be accessed by forcing functions and boundary condition functions.</p><h2 id="Turbulent-diffusivity-closures-and-large-eddy-simulation-models-1"><a class="docs-heading-anchor" href="#Turbulent-diffusivity-closures-and-large-eddy-simulation-models-1">Turbulent diffusivity closures and large eddy simulation models</a><a class="docs-heading-anchor-permalink" href="#Turbulent-diffusivity-closures-and-large-eddy-simulation-models-1" title="Permalink"></a></h2><p>A turbulent diffusivty closure representing the effects of viscous dissipation and diffusion can be passed via the <code>closure</code> keyword.</p><p>See <a href="manual/@ref numerical_closures">turbulence closures</a> and <a href="manual/@ref numerical_les">large eddy simulation</a> for more details on turbulent diffusivity closures.</p><h3 id="Constant-isotropic-diffusivity-1"><a class="docs-heading-anchor" href="#Constant-isotropic-diffusivity-1">Constant isotropic diffusivity</a><a class="docs-heading-anchor-permalink" href="#Constant-isotropic-diffusivity-1" title="Permalink"></a></h3><p>To use constant isotropic values for the viscosity ν and diffusivity κ you can use <code>ConstantIsotropicDiffusivity</code></p><pre><code class="language-">closure = ConstantIsotropicDiffusivity(ν=1e-2, κ=1e-2)</code></pre><h3 id="Constant-anisotropic-diffusivity-1"><a class="docs-heading-anchor" href="#Constant-anisotropic-diffusivity-1">Constant anisotropic diffusivity</a><a class="docs-heading-anchor-permalink" href="#Constant-anisotropic-diffusivity-1" title="Permalink"></a></h3><p>To specify constant values for the horizontal and vertical viscosities, <span>$\nu_h$</span> and <span>$\nu_v$</span>, and horizontal and vertical diffusivities, <span>$\kappa_h$</span> and <span>$\kappa_v$</span>, you can use <code>ConstantAnisotropicDiffusivity</code></p><pre><code class="language-">closure = ConstantAnisotropicDiffusivity(νh=1e-3, νv=5e-2, κh=2e-3, κv=1e-1)</code></pre><h3 id="Smagorinsky-Lilly-1"><a class="docs-heading-anchor" href="#Smagorinsky-Lilly-1">Smagorinsky-Lilly</a><a class="docs-heading-anchor-permalink" href="#Smagorinsky-Lilly-1" title="Permalink"></a></h3><p>To use the Smagorinsky-Lilly LES closure, no parameters are required</p><pre><code class="language-">closure = SmagorinskyLilly()</code></pre><p>although they may be specified. By default, the background viscosity and diffusivity are assumed to be the molecular values for seawater. For more details see <a href="manual/@ref"><code>SmagorinskyLilly</code></a>.</p><h3 id="Anisotropic-minimum-dissipation-1"><a class="docs-heading-anchor" href="#Anisotropic-minimum-dissipation-1">Anisotropic minimum dissipation</a><a class="docs-heading-anchor-permalink" href="#Anisotropic-minimum-dissipation-1" title="Permalink"></a></h3><p>To use the constant anisotropic minimum dissipation (AMD) LES closure, no parameters are required</p><pre><code class="language-">closure = AnisotropicMinimumDissipation()</code></pre><p>although they may be specified. By default, the background viscosity and diffusivity are assumed to be the molecular values for seawater. For more details see <a href="manual/@ref"><code>AnisotropicMinimumDissipation</code></a>.</p><h2 id="Diagnostics-1"><a class="docs-heading-anchor" href="#Diagnostics-1">Diagnostics</a><a class="docs-heading-anchor-permalink" href="#Diagnostics-1" title="Permalink"></a></h2><p>Diagnostics are a set of general utilities that can be called on-demand during time-stepping to compute quantities of interest you may want to save to disk, such as the horizontal average of the temperature, the maximum velocity, or to produce a time series of salinity. They also include utilities for diagnosing model health, such as the CFL number or to check for NaNs.</p><p>Diagnostics are stored as a list of diagnostics in <code>model.diagnostics</code>. Diagnostics can be specified at model creation time or be specified at any later time and appended (or assigned with a key value pair) to <code>model.diagnostics</code>.</p><p>Most diagnostics can be run at specified frequencies (e.g. every 25 time steps) or specified intervals (e.g. every 15 minutes of simulation time). If you&#39;d like to run a diagnostic on demand then do not specify a frequency or interval (and do not add it to <code>model.diagnostics</code>).</p><p>We describe the <code>HorizontalAverage</code> diagnostic in detail below but see the API documentation for other diagnostics such as <a href="manual/@ref"><code>Timeseries</code></a>, <a href="manual/@ref"><code>FieldMaximum</code></a>, <a href="manual/@ref"><code>CFL</code></a>, and <a href="manual/@ref"><code>NaNChecker</code></a>.</p><h3 id="Horizontal-averages-1"><a class="docs-heading-anchor" href="#Horizontal-averages-1">Horizontal averages</a><a class="docs-heading-anchor-permalink" href="#Horizontal-averages-1" title="Permalink"></a></h3><p>You can create a <code>HorizontalAverage</code> diagnostic by passing a field to the constructor, e.g.</p><pre><code class="language-">model = Model(grid=RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1)))
T_avg = HorizontalAverage(model.tracers.T)
push!(model.diagnostics, T_avg)</code></pre><p>which can then be called on-demand via <code>T_avg(model)</code> to return the horizontally averaged temperature. When running on the GPU you may want it to return an <code>Array</code> instead of a <code>CuArray</code> in case you want to save the horizontal average to disk in which case you&#39;d want to construct it like</p><pre><code class="language-">model = Model(grid=RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1)))
T_avg = HorizontalAverage(model.tracers.T; return_type=Array)
push!(model.diagnostics, T_avg)</code></pre><p>You can also use pass an abstract operator to take the horizontal average of any diagnosed quantity. For example, to compute the horizontal average of the vertical component of vorticity:</p><pre><code class="language-">model = Model(grid=RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1)))
u, v, w = model.velocities
ζ = ∂x(v) - ∂y(u)
ζ_avg = HorizontalAverage(ζ)
model.diagnostics[:vorticity_profile] = ζ_avg</code></pre><p>See <a href="manual/@ref"><code>HorizontalAverage</code></a> for more details and options.</p><h2 id="Output-writers-1"><a class="docs-heading-anchor" href="#Output-writers-1">Output writers</a><a class="docs-heading-anchor-permalink" href="#Output-writers-1" title="Permalink"></a></h2><p>Saving model data to disk can be done in a flexible manner using output writers. The two main output writers currently implemented are a NetCDF output writer (relying on <a href="https://github.com/Alexander-Barth/NCDatasets.jl">NCDatasets.jl</a>) and a JLD2 output writer (relying on <a href="https://github.com/JuliaIO/JLD2.jl">JLD2.jl</a>).</p><p>Output writers are stored as a list of output writers in <code>model.output_writers</code>. Output writers can be specified at model creation time or be specified at any later time and appended (or assigned with a key value pair) to <code>model.output_writers</code>.</p><h3 id="NetCDF-output-writer-1"><a class="docs-heading-anchor" href="#NetCDF-output-writer-1">NetCDF output writer</a><a class="docs-heading-anchor-permalink" href="#NetCDF-output-writer-1" title="Permalink"></a></h3><p>Model data can be saved to NetCDF files along with associated metadata. The NetCDF output writer is generally used by passing it a dictionary of (label, field) pairs and any indices for slicing if you don&#39;t want to save the full 3D field.</p><p>The following example shows how to construct NetCDF output writers for two different kinds of outputs (3D fields and slices) along with output attributes</p><pre><code class="language-">Nx = Ny = Nz = 16
model = Model(grid=RegularCartesianGrid(size=(Nx, Ny, Nz), length=(1, 1, 1)))

fields = Dict(
    &quot;u&quot; =&gt; model.velocities.u,
    &quot;T&quot; =&gt; model.tracers.T
)

output_attributes = Dict(
    &quot;u&quot; =&gt; Dict(&quot;longname&quot; =&gt; &quot;Velocity in the x-direction&quot;, &quot;units&quot; =&gt; &quot;m/s&quot;),
    &quot;T&quot; =&gt; Dict(&quot;longname&quot; =&gt; &quot;Temperature&quot;, &quot;units&quot; =&gt; &quot;C&quot;)
)

model.output_writers[:field_writer] = NetCDFOutputWriter(model, fields; filename=&quot;output_fields.nc&quot;,
                                                         interval=6hour, output_attributes=output_attributes)

model.output_writers[:surface_slice_writer] = NetCDFOutputWriter(model, fields; filename=&quot;output_surface_xy_slice.nc&quot;,
                                                                 interval=5minute, output_attributes=output_attributes,
                                                                 zC=Nz, zF=Nz)</code></pre><p>See <a href="manual/@ref"><code>NetCDFOutputWriter</code></a> for more details and options.</p><h3 id="JLD2-output-writer-1"><a class="docs-heading-anchor" href="#JLD2-output-writer-1">JLD2 output writer</a><a class="docs-heading-anchor-permalink" href="#JLD2-output-writer-1" title="Permalink"></a></h3><p>JLD2 is a an HDF5 compatible file format written in pure Julia and is generally pretty fast. JLD2 files can be opened in Python with the <a href="https://www.h5py.org/">h5py</a> package.</p><p>The JLD2 output writer is generally used by passing it a dictionary or named tuple of (label, function) pairs where the functions have a single input <code>model</code>. Whenever output needs to be written, the functions will be called and the output of the function will be saved to the JLD2 file. For example, to write out 3D fields for w and T and a horizontal average of T every 1 hour of simulation time to a file called <code>some_data.jld2</code></p><pre><code class="language-">model = Model(grid=RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1)))

function init_save_some_metadata(file, model)
    file[&quot;author&quot;] = &quot;Chim Riggles&quot;
    file[&quot;parameters/coriolis_parameter&quot;] = 1e-4
    file[&quot;parameters/density&quot;] = 1027
end

T_avg =  HorizontalAverage(model.tracers.T)

outputs = Dict(
    :w =&gt; model -&gt; model.velocities.u,
    :T =&gt; model -&gt; model.tracers.T,
    :T_avg =&gt; model -&gt; T_avg(model)
)

jld2_writer = JLD2OutputWriter(model, outputs; init=init_save_some_metadata, interval=1hour, prefix=&quot;some_data&quot;)

push!(model.output_writers, jld2_writer)</code></pre><p>See <a href="manual/@ref"><code>JLD2OutputWriter</code></a> for more details and options.</p><h3 id="Checkpointer-1"><a class="docs-heading-anchor" href="#Checkpointer-1">Checkpointer</a><a class="docs-heading-anchor-permalink" href="#Checkpointer-1" title="Permalink"></a></h3><p>A checkpointer can be used to serialize the entire model state to a file from which the model can be restored at any time. This is useful if you&#39;d like to periodically checkpoint when running long simulations in case of crashes or cluster time limits, but also if you&#39;d like to restore from a checkpoint and try out multiple scenarios.</p><p>For example, to periodically checkpoint the model state to disk every 1,000,000 seconds of simulation time to files of the form <code>model_checkpoint_xxx.jld2</code> where <code>xxx</code> is the iteration number (automatically filled in)</p><pre><code class="language-">model = Model(grid=RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1)))
model.output_writers[:checkpointer] = Checkpointer(model; interval=1e6, prefix=&quot;model_checkpoint&quot;)</code></pre><p>The default options should provide checkpoint files that are easy to restore from in most cases. For more advanced options and features, see <a href="manual/@ref"><code>Checkpointer</code></a>.</p><h4 id="Restoring-from-a-checkpoint-file-1"><a class="docs-heading-anchor" href="#Restoring-from-a-checkpoint-file-1">Restoring from a checkpoint file</a><a class="docs-heading-anchor-permalink" href="#Restoring-from-a-checkpoint-file-1" title="Permalink"></a></h4><p>To restore the model from a checkpoint file, for example <code>model_checkpoint_12345.jld2</code>, simply call</p><pre><code class="language-none">model = restore_from_checkpoint(&quot;model_checkpoint_12345.jld2&quot;)</code></pre><p>which will create a new model object that is identical to the one that was serialized to disk. You can continue time stepping after restoring from a checkpoint.</p><p>You can pass additional parameters to the <code>Model</code> constructor. See <a href="manual/@ref"><code>restore_from_checkpoint</code></a> for more information.</p><h4 id="Restoring-with-functions-1"><a class="docs-heading-anchor" href="#Restoring-with-functions-1">Restoring with functions</a><a class="docs-heading-anchor-permalink" href="#Restoring-with-functions-1" title="Permalink"></a></h4><p>JLD2 cannot serialize functions to disk. so if you used forcing functions, boundary conditions containing functions, or the model included references to functions then they will not be serialized to the checkpoint file. When restoring from a checkpoint file, any model property that contained functions must be manually restored via keyword arguments to <a href="manual/@ref"><code>restore_from_checkpoint</code></a>.</p><h2 id="Time-stepping-1"><a class="docs-heading-anchor" href="#Time-stepping-1">Time stepping</a><a class="docs-heading-anchor-permalink" href="#Time-stepping-1" title="Permalink"></a></h2><p>Once you&#39;re ready to time step the model simply call</p><pre><code class="language-none">time_step!(model; Δt=10)</code></pre><p>to take a single time step with step size 10. To take multiple time steps also pass an <code>Nt</code> keyword argument like</p><pre><code class="language-none">time_step!(model; Δt=10, Nt=50)</code></pre><p>By default, <code>time_step!</code> uses a first-order forward Euler time step to take the first time step then uses a second-order Adams-Bashforth method for the remaining time steps (which required knowledge of the previous time step). If you are resuming time-stepping then you should not use a forward Euler initialization time step. This can be done via</p><pre><code class="language-none">time_step!(model; Δt=10)
time_step!(model; Δt=10, Nt=50, init_with_euler=false)</code></pre><h3 id="Adaptive-time-stepping-1"><a class="docs-heading-anchor" href="#Adaptive-time-stepping-1">Adaptive time stepping</a><a class="docs-heading-anchor-permalink" href="#Adaptive-time-stepping-1" title="Permalink"></a></h3><p>Adaptive time stepping can be acomplished using the <a href="manual/@ref"><code>TimeStepWizard</code></a>. It can be used to compute time steps based on capping the CFL number at some value. You must remember to update the time step every so often. For example, to cap the CFL number at 0.3 and update the time step every 50 time steps:</p><pre><code class="language-none">wizard = TimeStepWizard(cfl=0.3, Δt=1.0, max_change=1.2, max_Δt=30.0)

while model.clock.time &lt; end_time
    time_step!(model; Δt=wizard.Δt, Nt=50)
    update_Δt!(wizard, model)
end</code></pre><p>See <a href="manual/@ref"><code>TimeStepWizard</code></a> for documentation of other features and options.</p><div class="admonition"><header class="admonition-header">Maximum CFL with second-order Adams-Bashforth time stepping</header><div class="admonition-body"><p>For stable time-stepping it is recommended to cap the CFL at 0.3 or smaller, although capping it at 0.5 works well for certain simulations. For some simulations, it may be neccessary to cap the CFL number at 0.1 or lower.</p></div></div><div class="admonition"><header class="admonition-header">Adaptive time stepping with second-order Adams-Bashforth time stepping</header><div class="admonition-body"><p>You should use an initializer forward Euler time step whenever changing the time step (i.e. <code>init_with_euler=true</code> which is the default value).</p></div></div><h2 id="Setting-initial-conditions-1"><a class="docs-heading-anchor" href="#Setting-initial-conditions-1">Setting initial conditions</a><a class="docs-heading-anchor-permalink" href="#Setting-initial-conditions-1" title="Permalink"></a></h2><p>Initial conditions are imposed after model construction. This can be easily done using the the <code>set!</code> function, which allows the setting of initial conditions using constant values, arrays, or functions.</p><pre><code class="language-">set!(model.velocities.u, 0.1)</code></pre><pre><code class="language-">∂T∂z = 0.01
ϵ(σ) = σ * randn()
T₀(x, y, z) = ∂T∂z * z + ϵ(1e-8)
set!(model.tracers.T, T₀)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../generated/internal_wave/">« Internal wave</a><a class="docs-footer-nextpage" href="../physics/">Physics »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 13 December 2019 00:49">Friday 13 December 2019</span>. Using Julia version 1.2.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Simulation tips · Oceananigans.jl</title><meta name="title" content="Simulation tips · Oceananigans.jl"/><meta property="og:title" content="Simulation tips · Oceananigans.jl"/><meta property="twitter:title" content="Simulation tips · Oceananigans.jl"/><meta name="description" content="Documentation for Oceananigans.jl."/><meta property="og:description" content="Documentation for Oceananigans.jl."/><meta property="twitter:description" content="Documentation for Oceananigans.jl."/><meta property="og:url" content="https://clima.github.io/OceananigansDocumentation/stable/simulation_tips/"/><meta property="twitter:url" content="https://clima.github.io/OceananigansDocumentation/stable/simulation_tips/"/><link rel="canonical" href="https://clima.github.io/OceananigansDocumentation/stable/simulation_tips/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Oceananigans.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../quick_start/">Quick start</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../generated/one_dimensional_diffusion/">One-dimensional diffusion</a></li><li><a class="tocitem" href="../generated/two_dimensional_turbulence/">Two-dimensional turbulence</a></li><li><a class="tocitem" href="../generated/internal_wave/">Internal wave</a></li><li><a class="tocitem" href="../generated/convecting_plankton/">Convecting plankton</a></li><li><a class="tocitem" href="../generated/ocean_wind_mixing_and_convection/">Ocean wind mixing and convection</a></li><li><a class="tocitem" href="../generated/langmuir_turbulence/">Langmuir turbulence</a></li><li><a class="tocitem" href="../generated/baroclinic_adjustment/">Baroclinic adjustment</a></li><li><a class="tocitem" href="../generated/kelvin_helmholtz_instability/">Kelvin-Helmholtz instability</a></li><li><a class="tocitem" href="../generated/shallow_water_Bickley_jet/">Shallow water Bickley jet</a></li><li><a class="tocitem" href="../generated/horizontal_convection/">Horizontal convection</a></li><li><a class="tocitem" href="../generated/tilted_bottom_boundary_layer/">Tilted bottom boundary layer</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Physics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../physics/notation/">Coordinate system and notation</a></li><li><a class="tocitem" href="../physics/boussinesq/">Boussinesq approximation</a></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label"><code>NonhydrostaticModel</code></span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../physics/nonhydrostatic_model/">Nonhydrostatic model</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label"><code>HydrostaticFreeSurfaceModel</code></span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../physics/hydrostatic_free_surface_model/">Hydrostatic model with a free surface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label"><code>ShallowWaterModel</code></span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../physics/shallow_water_model/">Shallow water model</a></li></ul></li><li><a class="tocitem" href="../physics/boundary_conditions/">Boundary conditions</a></li><li><a class="tocitem" href="../physics/buoyancy_and_equations_of_state/">Buoyancy models and equations of state</a></li><li><a class="tocitem" href="../physics/coriolis_forces/">Coriolis forces</a></li><li><a class="tocitem" href="../physics/turbulence_closures/">Turbulence closures</a></li><li><a class="tocitem" href="../physics/surface_gravity_waves/">Surface gravity waves and the Craik-Leibovich approximation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Numerical implementation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../numerical_implementation/finite_volume/">Finite volume method</a></li><li><a class="tocitem" href="../numerical_implementation/spatial_operators/">Spatial operators</a></li><li><a class="tocitem" href="../numerical_implementation/pressure_decomposition/">Pressure decomposition</a></li><li><a class="tocitem" href="../numerical_implementation/time_stepping/">Time stepping</a></li><li><a class="tocitem" href="../numerical_implementation/boundary_conditions/">Boundary conditions</a></li><li><a class="tocitem" href="../numerical_implementation/elliptic_solvers/">Elliptic solvers</a></li><li><a class="tocitem" href="../numerical_implementation/large_eddy_simulation/">Large eddy simulation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Model setup</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../model_setup/overview/">Overview</a></li><li><a class="tocitem" href="../model_setup/architecture/">Architecture</a></li><li><a class="tocitem" href="../model_setup/number_type/">Number type</a></li><li><a class="tocitem" href="../model_setup/grids/">Grid</a></li><li><a class="tocitem" href="../model_setup/clock/">Clock</a></li><li><a class="tocitem" href="../model_setup/coriolis/">Coriolis (rotation)</a></li><li><a class="tocitem" href="../model_setup/tracers/">Tracers</a></li><li><a class="tocitem" href="../model_setup/buoyancy_and_equation_of_state/">Buoyancy models and equation of state</a></li><li><a class="tocitem" href="../model_setup/boundary_conditions/">Boundary conditions</a></li><li><a class="tocitem" href="../model_setup/forcing_functions/">Forcing functions</a></li><li><a class="tocitem" href="../model_setup/background_fields/">Background fields</a></li><li><a class="tocitem" href="../model_setup/turbulent_diffusivity_closures_and_les_models/">Turbulent diffusivity closures and LES models</a></li><li><a class="tocitem" href="../model_setup/lagrangian_particles/">Lagrangian particles</a></li><li><a class="tocitem" href="../model_setup/diagnostics/">Diagnostics</a></li><li><a class="tocitem" href="../model_setup/callbacks/">Callbacks</a></li><li><a class="tocitem" href="../model_setup/output_writers/">Output writers</a></li><li><a class="tocitem" href="../model_setup/checkpointing/">Checkpointing</a></li><li><a class="tocitem" href="../model_setup/setting_initial_conditions/">Setting initial conditions</a></li></ul></li><li class="is-active"><a class="tocitem" href>Simulation tips</a><ul class="internal"><li><a class="tocitem" href="#General-(CPU/GPU)-simulation-tips"><span>General (CPU/GPU) simulation tips</span></a></li><li><a class="tocitem" href="#GPU-simulation-tips"><span>GPU simulation tips</span></a></li></ul></li><li><a class="tocitem" href="../contributing/">Contributor&#39;s guide</a></li><li><a class="tocitem" href="../gallery/">Gallery</a></li><li><a class="tocitem" href="../references/">References</a></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">Appendix</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../appendix/staggered_grid/">Staggered grid</a></li><li><a class="tocitem" href="../appendix/fractional_step/">Fractional step method</a></li><li><a class="tocitem" href="../appendix/convergence_tests/">Convergence tests</a></li><li><a class="tocitem" href="../appendix/benchmarks/">Performance benchmarks</a></li><li><a class="tocitem" href="../appendix/library/">Library</a></li><li><a class="tocitem" href="../appendix/function_index/">Function index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Simulation tips</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Simulation tips</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/CliMA/Oceananigans.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/CliMA/Oceananigans.jl/blob/main/docs/src/simulation_tips.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="simulation_tips"><a class="docs-heading-anchor" href="#simulation_tips">Simulation tips</a><a id="simulation_tips-1"></a><a class="docs-heading-anchor-permalink" href="#simulation_tips" title="Permalink"></a></h1><p>Oceananigans attempts to optimize computations as much as possible &quot;behind the scenes&quot;. Yet Oceananigans&#39; flexibility places some responsibility on users to ensure high performance simulations, especially for complex setups with user-defined forcing functions, boundary condition functions, and diagnostics. Furthermore, in case of more complex GPU runs, some details could sometimes prevent your simulation from running altogether. While Julia knowledge is obviously desirable here, a user that is unfamiliar with Julia can get away with efficient simulations by learning a few rules of thumb. It is nonetheless recommended that users go through Julia&#39;s <a href="https://docs.julialang.org/en/v1/manual/performance-tips/">performance tips</a>, which contains more in-depth explanations of some of the aspects discussed here.</p><h2 id="General-(CPU/GPU)-simulation-tips"><a class="docs-heading-anchor" href="#General-(CPU/GPU)-simulation-tips">General (CPU/GPU) simulation tips</a><a id="General-(CPU/GPU)-simulation-tips-1"></a><a class="docs-heading-anchor-permalink" href="#General-(CPU/GPU)-simulation-tips" title="Permalink"></a></h2><h3 id="Avoid-global-variables-whenever-possible"><a class="docs-heading-anchor" href="#Avoid-global-variables-whenever-possible">Avoid global variables whenever possible</a><a id="Avoid-global-variables-whenever-possible-1"></a><a class="docs-heading-anchor-permalink" href="#Avoid-global-variables-whenever-possible" title="Permalink"></a></h3><p>In general using a <a href="https://docs.julialang.org/en/v1/manual/variables-and-scoping/#Global-Scope">global variable</a> (which can be loosely defined as a variable defined in the main script) inside functions slows down the code. One way to circumvent this is to always <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables">use local variables or pass them as arguments to functions</a>. This helps the compiler optimize the code.</p><p>Another way around this is to <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables">define global variables as constants whenever possible</a>. One thing to keep in mind when doing this is that when a <code>const</code> is defined, its value can&#39;t be changed until you restart the Julia session. So this latter approach is good for production-ready code, but may be undesirable in the early stages of development while you still have to change the parameters of the simulation for exploration.</p><p>It is especially important to avoid global variables in functions that are meant to be executed in GPU kernels (such as functions defining boundary conditions and forcings). Otherwise the Julia GPU compiler can fail with obscure errors. This is explained in more detail in the GPU simulation tips section below.</p><h3 id="Consider-inlining-small-functions"><a class="docs-heading-anchor" href="#Consider-inlining-small-functions">Consider inlining small functions</a><a id="Consider-inlining-small-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Consider-inlining-small-functions" title="Permalink"></a></h3><p>Inlining is when the compiler <a href="https://en.wikipedia.org/wiki/Inline_expansion">replaces a function call with the body of the function that is being called before compiling</a>. The advantage of inlining (which in julia can be done with the <a href="https://docs.julialang.org/en/v1/devdocs/meta/"><code>@inline</code> macro</a>) is that gets rid of the time spent calling the function. The Julia compiler automatically makes some calls as to what functions it should or shouldn&#39;t inline, but you can force a function to be inlined by including the macro <code>@inline</code> before its definition. This is more suited for small functions that are called often. Here&#39;s an example of an implementation of the Heaviside function that forces it to be inlined:</p><pre><code class="language-julia hljs">@inline heaviside(x) = ifelse(x &lt; 0, zero(x), one(x))</code></pre><p>In practice it&#39;s hard to say whether inlining a function will bring runtime benefits <em>with certainty</em>, since Julia and KernelAbstractions.jl (needed for GPU runs) already inline some functions automatically. However, it is generally a good idea to at least investigate this aspect in your code as the benefits can potentially be significant.</p><h2 id="GPU-simulation-tips"><a class="docs-heading-anchor" href="#GPU-simulation-tips">GPU simulation tips</a><a id="GPU-simulation-tips-1"></a><a class="docs-heading-anchor-permalink" href="#GPU-simulation-tips" title="Permalink"></a></h2><p>Running on GPUs can be very different from running on CPUs. Oceananigans makes most of the necessary changes in the background, so that for very simple simulations changing between CPUs and GPUs is just a matter of changing the <code>architecture</code> argument in the model from <code>CPU()</code> to <code>GPU()</code>. However, for more complex simulations some care needs to be taken on the part of the user. While knowledge of GPU computing (and Julia) is again desirable, an inexperienced user can also achieve high efficiency in GPU simulations by following a few simple principles.</p><h3 id="Global-variables-that-need-to-be-used-in-GPU-computations-need-to-be-defined-as-constants-or-passed-as-parameters"><a class="docs-heading-anchor" href="#Global-variables-that-need-to-be-used-in-GPU-computations-need-to-be-defined-as-constants-or-passed-as-parameters">Global variables that need to be used in GPU computations need to be defined as constants or passed as parameters</a><a id="Global-variables-that-need-to-be-used-in-GPU-computations-need-to-be-defined-as-constants-or-passed-as-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Global-variables-that-need-to-be-used-in-GPU-computations-need-to-be-defined-as-constants-or-passed-as-parameters" title="Permalink"></a></h3><p>Any global variable that needs to be accessed by the GPU needs to be a constant or the simulation will crash. This includes any variables that are referenced as global variables in functions used for forcing of boundary conditions. For example,</p><pre><code class="language-julia hljs">T₀ = 20 # ᵒC
surface_temperature(x, y, t) = T₀ * sin(2π / 86400 * t)
T_bcs = FieldBoundaryConditions(bottom = GradientBoundaryCondition(surface_temperature))</code></pre><p>will throw an error if run on the GPU (and will run more slowly than it should on the CPU). Replacing the first line above with</p><pre><code class="language-julia hljs">const T₀ = 20 # ᵒC</code></pre><p>fixes the issue by indicating to the compiler that <code>T₀</code> will not change.</p><p>Note that the <em>literal</em> <code>2π / 86400</code> is not an issue – it&#39;s only the <em>variable</em> <code>T₀</code> that must be declared <code>const</code>.</p><p>Alternatively, we can pass the variable as a parameter to <code>GradientBoundaryCondition</code>. To do that we need to pass a named tuple as <code>parameter</code> keyword argument:</p><pre><code class="language-julia hljs">T₀ = 20 # ᵒC
surface_temperature(x, y, t, p) = p.T₀ * sin(2π / 86400 * t)
T_bcs = FieldBoundaryConditions(bottom = GradientBoundaryCondition(surface_temperature, parameters=(; T₀)))</code></pre><h3 id="Complex-diagnostics-using-computed-Fields-may-not-work-on-GPUs"><a class="docs-heading-anchor" href="#Complex-diagnostics-using-computed-Fields-may-not-work-on-GPUs">Complex diagnostics using computed <code>Field</code>s may not work on GPUs</a><a id="Complex-diagnostics-using-computed-Fields-may-not-work-on-GPUs-1"></a><a class="docs-heading-anchor-permalink" href="#Complex-diagnostics-using-computed-Fields-may-not-work-on-GPUs" title="Permalink"></a></h3><p><code>Field</code>s are the most convenient way to calculate diagnostics for your simulation. They will always work on CPUs, but when their complexity is high (in terms of number of abstract operations) the compiler can&#39;t translate them into GPU code and they fail for GPU runs. (This limitation is summarized  in <a href="https://github.com/CliMA/Oceananigans.jl/issues/1886">this Github issue</a> and contributions are welcome.) For example, in the example below, calculating <code>u²</code> works in both CPUs and GPUs, but calculating  <code>ε</code> will not compile on GPUs when we call the command <code>compute!</code>:</p><pre><code class="language-julia hljs">using Oceananigans
grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1))
model = NonhydrostaticModel(grid=grid, closure=ScalarDiffusivity(ν=1e-6))
u, v, w = model.velocities
ν = model.closure.ν
u² = Field(u^2)
ε = Field(ν*(∂x(u)^2 + ∂x(v)^2 + ∂x(w)^2 + ∂y(u)^2 + ∂y(v)^2 + ∂y(w)^2 + ∂z(u)^2 + ∂z(v)^2 + ∂z(w)^2))
compute!(u²)
compute!(ε)</code></pre><p>There are a few ways to work around this issue. One is to compute <code>ε</code> in steps by nesting computed <code>Field</code>s,</p><pre><code class="language-julia hljs">ddx² = Field(∂x(u)^2 + ∂x(v)^2 + ∂x(w)^2)
ddy² = Field(∂y(u)^2 + ∂y(v)^2 + ∂y(w)^2)
ddz² = Field(∂z(u)^2 + ∂z(v)^2 + ∂z(w)^2)
ε = Field(ν * (ddx² + ddy² + ddz²))
compute!(ε)</code></pre><p>This method increases the computational cost since it requires computing and storing 3 intermediate terms. <code>ε</code> may also be calculated via <code>KernelFunctionOperations</code>s, which requires explicitly building a &quot;kernel function&quot; from low-level Oceananigans operators.</p><pre><code class="language-julia hljs">using Oceananigans.Operators
using Oceananigans.AbstractOperations: KernelFunctionOperation

@inline fψ_plus_gφ²(i, j, k, grid, f, ψ, g, φ) = (f(i, j, k, grid, ψ) + g(i, j, k, grid, φ))^2

function isotropic_viscous_dissipation_rate_ccc(i, j, k, grid, u, v, w, ν)
    Σˣˣ² = ∂xᶜᶜᶜ(i, j, k, grid, u)^2
    Σʸʸ² = ∂yᶜᶜᶜ(i, j, k, grid, v)^2
    Σᶻᶻ² = ∂zᶜᶜᶜ(i, j, k, grid, w)^2

    Σˣʸ² = ℑxyᶜᶜᵃ(i, j, k, grid, fψ_plus_gφ², ∂yᶠᶠᶜ, u, ∂xᶠᶠᶜ, v) / 4
    Σˣᶻ² = ℑxzᶜᵃᶜ(i, j, k, grid, fψ_plus_gφ², ∂zᶠᶜᶠ, u, ∂xᶠᶜᶠ, w) / 4
    Σʸᶻ² = ℑyzᵃᶜᶜ(i, j, k, grid, fψ_plus_gφ², ∂zᶜᶠᶠ, v, ∂yᶜᶠᶠ, w) / 4

    return 2ν * (Σˣˣ² + Σʸʸ² + Σᶻᶻ² + 2 * (Σˣʸ² + Σˣᶻ² + Σʸᶻ²))
end

ε_op = KernelFunctionOperation{Center, Center, Center}(isotropic_viscous_dissipation_rate_ccc,
                                                       grid, u, v, w, ν)

ε = Field(ε_op)

compute!(ε)</code></pre><p>Writing kernel functions like <code>isotropic_viscous_dissipation_rate_ccc</code> requires understanding the C-grid, but incurs only one iteration over the domain.</p><p><code>KernelFunctionOperation</code>s for some diagnostics common to large eddy simulation are defined in <a href="https://github.com/tomchor/Oceanostics.jl/blob/3b8f67338656557877ef8ef5ebe3af9e7b2974e2/src/TurbulentKineticEnergyTerms.jl#L35-L57">Oceanostics.jl</a>,</p><pre><code class="language-julia hljs">using Oceanostics: IsotropicPseudoViscousDissipationRate
ε = IsotropicViscousDissipationRate(model, u, v, w, ν)
compute!(ε)</code></pre><p><a href="https://github.com/CliMA/Oceananigans.jl/issues/new">Start an issue on Github</a> if more help is needed.</p><h3 id="Try-to-decrease-the-memory-use-of-your-runs"><a class="docs-heading-anchor" href="#Try-to-decrease-the-memory-use-of-your-runs">Try to decrease the memory-use of your runs</a><a id="Try-to-decrease-the-memory-use-of-your-runs-1"></a><a class="docs-heading-anchor-permalink" href="#Try-to-decrease-the-memory-use-of-your-runs" title="Permalink"></a></h3><p>GPU runs are sometimes memory-limited. A state-of-the-art Tesla V100 GPU has 32GB of memory –- enough memory for simulations with about 100 million points, or grids a bit smaller than 512 × 512 × 512. (The maximum grid size depends on some user-specified factors, like the number of passive tracers or computed diagnostics.) For large simulations on the GPU, careful management of memory allocation may be required:</p><ul><li><p>Use the <a href="https://developer.nvidia.com/nvidia-system-management-interface"><code>nvidia-smi</code></a> command line utility to monitor the memory usage of the GPU. It should tell you how much memory there is on your GPU and how much of it you&#39;re using and you can run it from Julia via</p><pre><code class="language-julia hljs">julia&gt; ;
shell&gt; run(`nvidia-smi`)</code></pre></li><li><p>Try to use higher-order advection schemes. In general when you use a higher-order scheme you need fewer grid points to achieve the same accuracy that you would with a lower-order one. Refer to the <a href="https://clima.github.io/OceananigansDocumentation/stable/appendix/library/#Advection">documentation</a> for available advection schemes.</p></li><li><p>Manually define scratch space to be reused in diagnostics. By default, every time a user-defined diagnostic is calculated the compiler reserves a new chunk of memory for that calculation, usually called scratch space. In general, the more diagnostics, the more scratch space needed and the bigger the memory requirements. However, if you explicitly create a scratch space and pass that same scratch space for as many diagnostics as you can, you minimize the memory requirements of your calculations by reusing the same chunk of memory. Have a look at an <a href="https://github.com/CliMA/LESbrary.jl/blob/cf31b0ec20219d5ad698af334811d448c27213b0/examples/three_layer_ constant_fluxes.jl#L380-L383">example for how to create scratch space</a> and how it can be <a href="https://github.com/CliMA/LESbrary.jl/blob/cf31b0ec20219d5ad698af334811d448c27213b0/src/TurbulenceStatistics/first_through_third_order.jl#L109-L112">used in calculations</a>.</p></li></ul><h3 id="Arrays-in-GPUs-are-usually-different-from-arrays-in-CPUs"><a class="docs-heading-anchor" href="#Arrays-in-GPUs-are-usually-different-from-arrays-in-CPUs">Arrays in GPUs are usually different from arrays in CPUs</a><a id="Arrays-in-GPUs-are-usually-different-from-arrays-in-CPUs-1"></a><a class="docs-heading-anchor-permalink" href="#Arrays-in-GPUs-are-usually-different-from-arrays-in-CPUs" title="Permalink"></a></h3><p>Oceananigans.jl uses <a href="https://cuda.juliagpu.org/stable/usage/array/"><code>CUDA.CuArray</code></a> to store  data for GPU computations. One limitation of <code>CuArray</code>s compared to the <code>Array</code>s used for  CPU computations is that <code>CuArray</code> elements in general cannot be accessed outside kernels launched through CUDA.jl or KernelAbstractions.jl. (You can learn more about GPU kernels  <a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#kernels">here</a> and  <a href="https://cuda.juliagpu.org/stable/usage/overview/#Kernel-programming-with-@cuda">here</a>.) Doing so requires individual elements to be copied from or to the GPU for processing, which is very slow and can result in huge slowdowns. To avoid such unintentional slowdowns, Oceananigans.jl disables CUDA scalar indexing by default. See the <a href="https://juliagpu.github.io/CUDA.jl/dev/usage/workflow/#UsageWorkflowScalar">scalar indexing</a> section of the CUDA.jl documentation for more information on scalar indexing.</p><p>For example, if can be difficult to just view a <code>CuArray</code> since Julia needs to access  its elements to do that. Consider the example below:</p><pre><code class="language-julia hljs">julia&gt; using Oceananigans, Adapt

julia&gt; grid = RectilinearGrid(GPU(); size=(1, 1, 1), extent=(1, 1, 1), halo=(1, 1, 1))
1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 1×1×1 halo
├── Periodic x ∈ [0.0, 1.0)  regularly spaced with Δx=1.0
├── Periodic y ∈ [0.0, 1.0)  regularly spaced with Δy=1.0
└── Bounded  z ∈ [-1.0, 0.0] regularly spaced with Δz=1.0

julia&gt; model = NonhydrostaticModel(; grid)
NonhydrostaticModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0)
├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 1×1×1 halo
├── timestepper: QuasiAdamsBashforth2TimeStepper
├── tracers: ()
├── closure: Nothing
├── buoyancy: Nothing
└── coriolis: Nothing

julia&gt; typeof(model.velocities.u.data)
OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}

julia&gt; adapt(Array, model.velocities.u.data)
3×3×3 OffsetArray(::Array{Float64, 3}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2×0:2×0:2:
[:, :, 0] =
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0

[:, :, 1] =
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0

[:, :, 2] =
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0</code></pre><p>Notice that to view the <code>CuArray</code> that stores values for <code>u</code> we first need to transform it into a regular <code>Array</code> using <code>Adapt.adapt</code>. If we naively try to view the <code>CuArray</code> without that step we get an error:</p><pre><code class="language-julia hljs">julia&gt; model.velocities.u.data
3×3×3 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2×0:2×0:2:
[:, :, 0] =
Error showing value of type OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}:
ERROR: Scalar indexing is disallowed.</code></pre><p>Here <code>CUDA.jl</code> throws an error because scalar <code>getindex</code> is not <code>allowed</code>. There are ways to overcome this limitation and allow scalar indexing (more about that  in the <a href="https://cuda.juliagpu.org/stable/usage/workflow/#UsageWorkflowScalar">CUDA.jl documentation</a>), but this option can be very slow on GPUs, so it is advised to only use this last method when using the REPL or  prototyping –- never in production-ready scripts.</p><p>You might also need to keep these differences in mind when using arrays to define initial conditions, boundary conditions or forcing functions on a GPU. To learn more about working with <code>CuArray</code>s, see the <a href="https://juliagpu.github.io/CUDA.jl/dev/usage/array/">array programming</a> section of the CUDA.jl documentation.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../model_setup/setting_initial_conditions/">« Setting initial conditions</a><a class="docs-footer-nextpage" href="../contributing/">Contributor&#39;s guide »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Thursday 29 February 2024 07:30">Thursday 29 February 2024</span>. Using Julia version 1.10.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

var documenterSearchIndex = {"docs":
[{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"EditURL = \"<unknown>/examples/kelvin_helmholtz_instability.jl\"","category":"page"},{"location":"generated/kelvin_helmholtz_instability/#Stratified-Kelvin-Helmholtz-instability","page":"Kelvin-Helmholtz instability","title":"Stratified Kelvin-Helmholtz instability","text":"","category":"section"},{"location":"generated/kelvin_helmholtz_instability/#Install-dependencies","page":"Kelvin-Helmholtz instability","title":"Install dependencies","text":"","category":"section"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"using Pkg\npkg\"add Oceananigans, JLD2, Plots\"","category":"page"},{"location":"generated/kelvin_helmholtz_instability/#The-physical-domain","page":"Kelvin-Helmholtz instability","title":"The physical domain","text":"","category":"section"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"We simulate Kelvin-Helmholtz instability in two-dimensions in x z and therefore assign Flat to the y direction,","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"using Oceananigans\n\ngrid = RegularRectilinearGrid(size=(64, 64), x=(-5, 5), z=(-5, 5),\n                              topology=(Periodic, Flat, Bounded))","category":"page"},{"location":"generated/kelvin_helmholtz_instability/#The-basic-state","page":"Kelvin-Helmholtz instability","title":"The basic state","text":"","category":"section"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"We're simulating the instability of a sheared and stably-stratified basic state U(z) and B(z). Two parameters define our basic state: the Richardson number defined as,","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Ri = frac_z B(_z U)^2","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"and the width of the stratification layer, h.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"shear_flow(x, y, z, t) = tanh(z)\n\nstratification(x, y, z, t, p) = p.h * p.Ri * tanh(z / p.h)\n\nU = BackgroundField(shear_flow)\n\nB = BackgroundField(stratification, parameters=(Ri=0.1, h=1/4))","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Our basic state thus has a thin layer of stratification in the center of the channel, embedded within a thicker shear layer surrounded by unstratified fluid.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"using Plots\n\nzF = znodes(Face, grid)\nzC = znodes(Center, grid)\n\nRi, h = B.parameters\n\nkwargs = (ylabel=\"z\", linewidth=3, label=nothing)\n\n U_plot = plot(shear_flow.(0, 0, zC, 0), zC; xlabel=\"U(z)\", kwargs...)\n\n B_plot = plot([stratification(0, 0, z, 0, (Ri=Ri, h=h)) for z in zC], zC; xlabel=\"B(z)\", color=:red, kwargs...)\n\nRi_plot = plot(@. Ri * sech(zF / h)^2 / sech(zF)^2, zF; xlabel=\"Ri(z)\", color=:black, kwargs...) # Ri(z)= ∂_z B / (∂_z U)²; derivatives computed by hand\n\nplot(U_plot, B_plot, Ri_plot, layout=(1, 3), size=(800, 400))","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"In unstable flows it is often useful to determine the dominant spatial structure of the instability and the growth rate at which the instability grows. If the simulation idealizes a physical flow, this can be used to make predictions as to what should develop and how quickly.  Since these instabilities are often attributed to a linear instability, we can determine information about the structure and the growth rate of the instability by analyzing the linear operator that governs small perturbations about a base state, or by solving for the linear dynamics.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Here, we discuss first briefly linear instabilities and how one can obtain growth rates and structures of most unstable modes via eigenanalysis. Then we present an alternative method for approximating the eigenanalysis results when one does not have access to the linear dynamics or the linear operator about the base state.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/#Linear-Instabilities","page":"Kelvin-Helmholtz instability","title":"Linear Instabilities","text":"","category":"section"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"The base state U(z), B(z) is a solution of the inviscid equations of motion. Whether the base state is stable or not is determined by whether small perturbations about this base state grow or decay. To formalize this, we study the linearized dynamics satisfied by perturbations about the base state:","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"partial_t Phi = L Phi  ","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"where Phi = (u v w b) is a vector of the perturbation velocities u v w and perturbation buoyancy b and L a linear operator that depends on the base state, L = L(U(z) B(z)) (the background_fields). Eigenanalysis of the linear operator L determines the stability of the base state, such as the Kelvin-Helmholtz instability. That is, by using the ansantz","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Phi(x y z t) = phi(x y z)  exp(lambda t)  ","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"then lambda and phi are respectively eigenvalues and eigenmodes of L, i.e., they obey","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"L  phi_j = lambda_j  phi_j quad j=12dots  ","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"From hereafter we'll use the convention that the eigenvalues are ordered according to their real part, real(lambda_1) ge real(lambda_2) ge dotsb.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Remarks:","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"As we touched upon briefly above, Oceananigans.jl, does not include a linearized version of the equations. Furthermore, Oceananigans.jl does not give us access to the linear operator L so that we can perform eigenanalysis. Below we discuss an alternative way of approximating the eigenanalysis results. The method boils down to solving the nonlinear equations while continually renormalize the magnitude of the perturbations to ensure that nonlinear terms (terms that are quadratic or higher in perturbations) remain negligibly small, i.e.,much smaller than the background flow.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/#The-power-method-algorithm","page":"Kelvin-Helmholtz instability","title":"The power method algorithm","text":"","category":"section"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Successive application of L to a random initial state will eventually render it parallel with eigenmode phi_1:","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"lim_n to infty L^n Phi propto phi_1  ","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Of course, if phi_1 is an unstable mode (i.e., sigma_1 = real(lambda_1)  0), then successive application of L will lead to exponential amplification. (Similarly, if sigma_1  0, successive application of L will lead to exponential decay of Phi down to machine precision.) Therefore, after each application of the linear operator L, we rescale the output L Phi back to a pre-selected amplitude.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"So, we initialize a simulation with random initial conditions with amplitude much less than those of the base state (which are O(1)). Instead of \"applying\" L on our initial state, we evolve the (approximately) linear dynamics for interval Delta tau. We measure how much the energy has grown during that interval, rescale the perturbations back to original energy amplitude and repeat. After some iterations the state will converge to the most unstable eigenmode.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"In summary, each iteration of the power method includes:","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"compute the perturbation energy, E_0,\nevolve the system for a time-interval Delta tau,\ncompute the perturbation energy, E_1,\ndetermine the exponential growth of the most unstable mode during the interval Delta tau as  log(E_1  E_0)  (2 Delta tau),\nrepeat the above until growth rate converges.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"By fiddling a bit with Delta t we can get convergence after only a few iterations.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Let's apply all these to our example.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/#The-model","page":"Kelvin-Helmholtz instability","title":"The model","text":"","category":"section"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"model = IncompressibleModel(timestepper = :RungeKutta3,\n                              advection = UpwindBiasedFifthOrder(),\n                                   grid = grid,\n                               coriolis = nothing,\n                      background_fields = (u=U, b=B),\n                                closure = IsotropicDiffusivity(ν=2e-4, κ=2e-4),\n                               buoyancy = BuoyancyTracer(),\n                                tracers = :b)","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"We have included a \"pinch\" of viscosity and diffusivity in anticipation of what will follow furtherdown: viscosity and diffusivity will ensure numerical stability when we evolve the unstable mode to the point it becomes nonlinear.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"For this example, we take Delta tau = 15.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"simulation = Simulation(model, Δt=0.1, stop_iteration=150)","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Now some helper functions that will be used during for the power method algorithm.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"First a function that evolves the state for Delta tau and measure the energy growth over that period.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"\"\"\"\n    grow_instability!(simulation, e)\n\nGrow an instability by running `simulation`.\n\nEstimates the growth rate ``σ`` of the instability\nusing the fractional change in volume-mean kinetic energy,\nover the course of the `simulation`\n\n``\nenergy(t₀ + Δτ) / energy(t₀) ≈ exp(2 σ Δτ)\n``\n\nwhere ``t₀`` is the starting time of the simulation and ``t₀ + Δτ``\nthe ending time of the simulation. We thus find that the growth rate\nis measured by\n\n``\nσ = log(energy(t₀ + Δτ) / energy(t₀)) / (2 * Δτ) .\n``\n\"\"\"\nfunction grow_instability!(simulation, energy)\n    # Initialize\n    simulation.model.clock.iteration = 0\n    t₀ = simulation.model.clock.time = 0\n    compute!(energy)\n    energy₀ = energy[1, 1, 1]\n\n    # Grow\n    run!(simulation)\n\n    # Analyze\n    compute!(energy)\n    energy₁ = energy[1, 1, 1]\n    Δτ = simulation.model.clock.time - t₀\n\n    # ½(u² + v²) ~ exp(2 σ Δτ)\n    σ = growth_rate = log(energy₁ / energy₀) / 2Δτ\n\n    return growth_rate\nend\nnothing # hide","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Finally, we write a function that rescales the state. The rescaling is done via computing the kinetic energy and then rescaling all flow fields so that the kinetic energy assumes a targetted value.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"(Measuring the perturbation growth via the kinetic energy works fine unless an unstable mode only has buoyancy structure. In that case, the total perturbation energy is more adequate.)","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"\"\"\"\n    rescale!(model, energy; target_kinetic_energy=1e-3)\n\nRescales all model fields so that `energy = target_kinetic_energy`.\n\"\"\"\nfunction rescale!(model, energy; target_kinetic_energy=1e-6)\n    compute!(energy)\n\n    rescale_factor = √(target_kinetic_energy / energy[1, 1, 1])\n\n    model.velocities.u.data.parent .*= rescale_factor\n    model.velocities.v.data.parent .*= rescale_factor\n    model.velocities.w.data.parent .*= rescale_factor\n    model.tracers.b.data.parent .*= rescale_factor\n\n    return nothing\nend\n\nusing Printf","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Some more helper function for the power method,","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"\"\"\"\n    convergence(σ)\n\nCheck if the growth rate has converged. If the array `σ` has at least 2 elements then returns the\nrelative difference between ``σ[end]`` and ``σ[end-1]``.\n\"\"\"\nconvergence(σ) = length(σ) > 1 ? abs((σ[end] - σ[end-1]) / σ[end]) : 9.1e18 # pretty big (not Inf tho)\nnothing # hide","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"and the main function that performs the power method iteration.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"\"\"\"\n    estimate_growth_rate(simulation, energy, ω; convergence_criterion=1e-3)\n\nEstimates the growth rate iteratively until the relative change\nin the estimated growth rate ``σ`` falls below `convergence_criterion`.\n\nReturns ``σ``.\n\"\"\"\nfunction estimate_growth_rate(simulation, energy, ω, b; convergence_criterion=1e-3)\n    σ = []\n\n    power_method_data = []\n\n    compute!(ω)\n\n    push!(power_method_data, (ω=collect(interior(ω)[:, 1, :]), b=collect(interior(b)[:, 1, :]), σ=deepcopy(σ)))\n\n    while convergence(σ) > convergence_criterion\n        compute!(energy)\n\n        @info @sprintf(\"About to start power method iteration %d; kinetic energy: %.2e\", length(σ)+1, energy[1, 1, 1])\n\n        push!(σ, grow_instability!(simulation, energy))\n\n        compute!(energy)\n\n        @info @sprintf(\"Power method iteration %d, kinetic energy: %.2e, σⁿ: %.2e, relative Δσ: %.2e\",\n                       length(σ), energy[1, 1, 1], σ[end], convergence(σ))\n\n        compute!(ω)\n\n        rescale!(simulation.model, energy)\n\n        push!(power_method_data, (ω=collect(interior(ω)[:, 1, :]), b=collect(interior(b)[:, 1, :]), σ=deepcopy(σ)))\n    end\n\n    return σ, power_method_data\nend\nnothing # hide","category":"page"},{"location":"generated/kelvin_helmholtz_instability/#Eigenplotting","page":"Kelvin-Helmholtz instability","title":"Eigenplotting","text":"","category":"section"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"A good algorithm wouldn't be complete without a good visualization,","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"u, v, w = model.velocities\nb = model.tracers.b\n\nperturbation_vorticity = ComputedField(∂z(u) - ∂x(w))\n\nxF, yF, zF = nodes(perturbation_vorticity)\n\nxC, yC, zC = nodes(b)\n\neigentitle(σ, t) = length(σ) > 0 ? @sprintf(\"Iteration #%i; growth rate %.2e\", length(σ), σ[end]) : @sprintf(\"Initial perturbation fields\")\n\nfunction eigenplot(ω, b, σ, t; ω_lim=maximum(abs, ω)+1e-16, b_lim=maximum(abs, b)+1e-16)\n\n    kwargs = (xlabel=\"x\", ylabel=\"z\", linewidth=0, label=nothing, color = :balance, aspectratio = 1,)\n\n    ω_title(t) = t == nothing ? @sprintf(\"vorticity\") : @sprintf(\"vorticity at t = %.2f\", t)\n\n    plot_ω = contourf(xF, zF, clamp.(ω, -ω_lim, ω_lim)';\n                      levels = range(-ω_lim, stop=ω_lim, length=20),\n                       xlims = (xF[1], xF[grid.Nx]),\n                       ylims = (zF[1], zF[grid.Nz]),\n                       clims = (-ω_lim, ω_lim),\n                       title = ω_title(t), kwargs...)\n\n    b_title(t) = t == nothing ? @sprintf(\"buoyancy\") : @sprintf(\"buoyancy at t = %.2f\", t)\n\n    plot_b = contourf(xC, zC, clamp.(b, -b_lim, b_lim)';\n                    levels = range(-b_lim, stop=b_lim, length=20),\n                     xlims = (xC[1], xC[grid.Nx]),\n                     ylims = (zC[1], zC[grid.Nz]),\n                     clims = (-b_lim, b_lim),\n                     title = b_title(t), kwargs...)\n\n    return plot(plot_ω, plot_b, layout=(1, 2), size=(800, 380))\nend\n\nfunction power_method_plot(ω, b, σ, t)\n    plot_growthrates = scatter(σ,\n                             xlabel = \"Power iteration\",\n                             ylabel = \"Growth rate\",\n                              title = eigentitle(σ, nothing),\n                              label = nothing)\n\n    plot_eigenmode = eigenplot(ω, b, σ, nothing)\n\n    return plot(plot_growthrates, plot_eigenmode, layout=@layout([A{0.25h}; B]), size=(800, 600))\nend\nnothing # hide","category":"page"},{"location":"generated/kelvin_helmholtz_instability/#Rev-your-engines...","page":"Kelvin-Helmholtz instability","title":"Rev your engines...","text":"","category":"section"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"We initialize the power iteration with random noise and rescale to have a target_kinetic_energy","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"using Random, Statistics\n\nmean_perturbation_kinetic_energy = AveragedField(1/2 * (u^2 + w^2), dims=(1, 2, 3))\n\nnoise(x, y, z) = randn()\n\nset!(model, u=noise, w=noise, b=noise)\n\nrescale!(simulation.model, mean_perturbation_kinetic_energy, target_kinetic_energy=1e-6)\n\ngrowth_rates, power_method_data = estimate_growth_rate(simulation, mean_perturbation_kinetic_energy, perturbation_vorticity, b)\n\n@info \"Power iterations converged! Estimated growth rate: $(growth_rates[end])\"","category":"page"},{"location":"generated/kelvin_helmholtz_instability/#Powerful-convergence","page":"Kelvin-Helmholtz instability","title":"Powerful convergence","text":"","category":"section"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"We animate the power method steps. A scatter plot illustrates how the growth rate converges as the power method iterates,","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"anim_powermethod = @animate for i in 1:length(power_method_data)\n    power_method_plot(power_method_data[i].ω, power_method_data[i].b, power_method_data[i].σ, nothing)\nend\n\nmp4(anim_powermethod, \"powermethod.mp4\", fps = 1) # hide","category":"page"},{"location":"generated/kelvin_helmholtz_instability/#Now-for-the-fun-part","page":"Kelvin-Helmholtz instability","title":"Now for the fun part","text":"","category":"section"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Now we simulate the nonlinear evolution of the eigenmode we've isolated for a few e-folding times 1sigma,","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"# Reset the clock\nmodel.clock.iteration = 0\nmodel.clock.time = 0\n\nestimated_growth_rate = growth_rates[end]\n\nsimulation.stop_time = 5 / estimated_growth_rate\nsimulation.stop_iteration = 9.1e18 # pretty big (not Inf tho)\n\n# Rescale the eigenmode\ninitial_eigenmode_energy = 5e-5\nrescale!(simulation.model, mean_perturbation_kinetic_energy, target_kinetic_energy=initial_eigenmode_energy)","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Let's save and plot the perturbation vorticity and buoyancy and also the total vorticity and buoyancy (perturbation + basic state). It'll be also neat to plot the kinetic energy time-series and confirm it grows with the estimated growth rate.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"total_vorticity = ComputedField(∂z(u) + ∂z(model.background_fields.velocities.u) - ∂x(w))\n\ntotal_b = ComputedField(b + model.background_fields.tracers.b)\n\nsimulation.output_writers[:vorticity] =\n    JLD2OutputWriter(model, (ω=perturbation_vorticity, Ω=total_vorticity, b=b, B=total_b, KE=mean_perturbation_kinetic_energy),\n                     schedule = TimeInterval(0.10 / estimated_growth_rate),\n                     prefix = \"kelvin_helmholtz_instability\",\n                     force = true)","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"And now we...","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"@info \"*** Running a simulation of Kelvin-Helmholtz instability...\"\nrun!(simulation)","category":"page"},{"location":"generated/kelvin_helmholtz_instability/#Pretty-things","page":"Kelvin-Helmholtz instability","title":"Pretty things","text":"","category":"section"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Load it; plot it. First the nonlinear equilibration of the perturbation fields together with the evolution of the kinetic energy.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"using JLD2\n\nfile = jldopen(simulation.output_writers[:vorticity].filepath)\n\niterations = parse.(Int, keys(file[\"timeseries/t\"]))\n\n@info \"Making a neat movie of stratified shear flow...\"\n\nfunction plot_energy_timeseries(time, KE, estimated_growth_rate, initial_eigenmode_energy, stop_time)\n    energy_plot = plot([0, stop_time], initial_eigenmode_energy * exp.(2 * estimated_growth_rate * [0, stop_time]),\n             label = \"~ exp(2 σ t)\",\n            legend = :topleft,\n                lw = 2,\n             color = :black,\n             yaxis = :log,\n             xlims = (0, simulation.stop_time),\n             ylims = (initial_eigenmode_energy, 1e-1),\n            xlabel = \"time\",\n            ylabel = \"kinetic energy\",\n            )\n\n    energy_plot = plot!(time, KE,\n              label = \"perturbation kinetic energy\",\n              lw = 6,\n              alpha = 0.5)\n\n    return energy_plot\nend\n\ntime = []\nKE = []\n\nanim_perturbations = @animate for (i, iteration) in enumerate(iterations)\n\n    @info \"Plotting frame $i from iteration $iteration...\"\n\n    t = file[\"timeseries/t/$iteration\"]\n    ω_snapshot = file[\"timeseries/ω/$iteration\"][:, 1, :]\n    b_snapshot = file[\"timeseries/b/$iteration\"][:, 1, :]\n    ke = file[\"timeseries/KE/$iteration\"][]\n\n    push!(time, t)\n    push!(KE, ke)\n\n    energy_plot = plot_energy_timeseries(time, KE, estimated_growth_rate, initial_eigenmode_energy, simulation.stop_time)\n\n    eigenmode_plot = eigenplot(ω_snapshot, b_snapshot, nothing, t; ω_lim=1, b_lim=0.05)\n\n    plot(eigenmode_plot, energy_plot, layout=@layout([A{0.6h}; B]), size=(800, 600))\n\nend\n\nmp4(anim_perturbations, \"kelvin_helmholtz_instability_perturbations.mp4\", fps = 8) # hide","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"And then the same for total vorticity & buoyancy of the fluid.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"time = []\nKE = []\n\nanim_total = @animate for (i, iteration) in enumerate(iterations)\n\n    @info \"Plotting frame $i from iteration $iteration...\"\n\n    t = file[\"timeseries/t/$iteration\"]\n    ω_snapshot = file[\"timeseries/Ω/$iteration\"][:, 1, :]\n    b_snapshot = file[\"timeseries/B/$iteration\"][:, 1, :]\n    ke = file[\"timeseries/KE/$iteration\"][]\n\n    push!(time, t)\n    push!(KE, ke)\n\n    energy_plot = plot_energy_timeseries(time, KE, estimated_growth_rate, initial_eigenmode_energy, simulation.stop_time)\n\n    eigenmode_plot = eigenplot(ω_snapshot, b_snapshot, nothing, t; ω_lim=1, b_lim=0.05)\n\n    plot(eigenmode_plot, energy_plot, layout=@layout([A{0.6h}; B]), size=(800, 600))\nend\n\nmp4(anim_total, \"kelvin_helmholtz_instability_total.mp4\", fps = 8) # hide","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"This page was generated using Literate.jl.","category":"page"},{"location":"numerical_implementation/time_stepping/#Time-stepping-and-the-fractional-step-method","page":"Time stepping","title":"Time-stepping and the fractional step method","text":"","category":"section"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"The time-integral of the momentum equation with the pressure decomposition from time step n at t = t_n  to time step n+1 at t_n+1 is","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"    beginequation\n    labeleqmomentum-time-integral\n    boldsymbolu^n+1 - boldsymbolu^n = \n        int_t_n^t_n+1 Big  - boldsymbolnabla phi_rmnon \n                                    - boldsymbolnabla_h phi_rmhyd \n                                    - left ( boldsymbolu boldsymbolcdot boldsymbolnabla right ) boldsymbolu \n                                    - boldsymbolf times boldsymbolu \n                                    + boldsymbolnabla boldsymbolcdot boldsymboltau \n                                    + boldsymbolF_boldsymbolu Big   mathrmd t  \n    endequation","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"where the superscript n and n+1 imply evaluation at t_n and t_n+1,  such that boldsymbolu^n equiv boldsymbolu(t=t_n). The crux of the fractional step method is to treat the pressure term  boldsymbolnabla phi_rmnon implicitly using the approximation","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"int_t_n^t_n+1 boldsymbolnabla phi_rmnon  mathrmd t approx \n    Delta t boldsymbolnabla phi_rmnon^n+1  ","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"while treating the rest of the terms on the right hand side of \\eqref{eq:momentum-time-integral} explicitly. The implicit treatment of pressure ensures that the velocity field obtained at time step n+1 is divergence-free.","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"To effect such a fractional step method, we define an intermediate velocity field boldsymbolu^star such that","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"    beginequation\n    labeleqintermediate-velocity-field\n    boldsymbolu^star - boldsymbolu^n = int_t_n^t_n+1 boldsymbolG_boldsymbolu  mathrmd t  \n    endequation","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"where","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"boldsymbolG_boldsymbolu equiv - boldsymbolnabla_h phi_rmhyd \n                       - left ( boldsymbolu boldsymbolcdot boldsymbolnabla right ) boldsymbolu \n                       - boldsymbolf times boldsymbolu \n                       + boldsymbolnabla boldsymbolcdot boldsymboltau \n                       + boldsymbolF_boldsymbolu","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"collects all terms on the right side of the time-integral of the momentum equation except the contribution  of non-hydrostatic pressure boldsymbolnabla phi_n. The integral on the right of the equation for boldsymbolu^star may be approximated by a variety of  explicit methods: for example, a forward Euler method uses","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"    beginequation\n    int_t_n^t_n+1 G  mathrmd t approx Delta t G^n  \n    labeleqforward-euler\n    endequation","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"for any time-dependent function G(t), while a second-order Adams-Bashforth method uses the approximation","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"    beginequation\n    labeleqadams-bashforth\n    int_t_n^t_n+1 G  mathrmd t approx \n        Delta t left  left ( tfrac32 + chi right ) G^n \n        - left ( tfrac12 + chi right ) G^n-1 right   \n    endequation","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"where chi is a parameter. Ascher et al. (1995) claim that chi = tfrac18 is optimal;  chi=-tfrac12 yields the forward Euler scheme.","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"Combining the equations for boldsymbolu^star and the time integral of the momentum equation yields","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"    beginequation\n    labeleqfractional-step\n    boldsymbolu^n+1 - boldsymbolu^star = - Delta t boldsymbolnabla phi_rmnon^n+1  \n    endequation","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"Taking the divergence of fractional step equation and requiring that  boldsymbolnabla boldsymbolcdot boldsymbolu^n+1 = 0 yields a Poisson equation for the potential  phi_rmnon at time-step n+1:","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"    nabla^2 phi_rmnon^n+1 = fracboldsymbolnabla boldsymbolcdot boldsymbolu^starDelta t  ","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"With boldsymbolu^star and phi_rmnon, boldsymbolu^n+1 is then computed via the fractional step equation.","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"Tracers are stepped forward explicitly via","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"    beginequation\n    labeleqtracer-timestep\n    c^n+1 - c^n = int_t_n^t_n+1 G_c  mathrmd t  \n    endequation","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"where ","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"    G_c equiv - boldsymbolnabla boldsymbolcdot left ( boldsymbolu c right ) - boldsymbolnabla boldsymbolcdot boldsymbolq_c + F_c  ","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"and the same forward Euler or Adams-Bashforth scheme as for the explicit evaluation of the time-integral of boldsymbolG_u is used to evaluate the integral of G_c.","category":"page"},{"location":"numerical_implementation/turbulence_closures/#numerical_closures","page":"Turbulence closures","title":"Turbulence closures","text":"","category":"section"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"To truly simulate and resolve turbulence at high Reynolds number (so basically all interesting flows) would require you resolve all motions down to the A. Kolmogorov  (1941) length scale eta = (nu^3  varepsilon)^14 where nu is the kinematic viscosity and varepsilon the average rate of dissipation of turbulence kinetic energy per unit mass.","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"As pointed out way back by S. Corrsin  (1961), to run a simulation on a horizontal domain about 10 times the size of an \"average eddy\" with 100 vertical levels and where the grid spacing is given by eta would require the computer to store on the order of 10^14 variables.[1] This is still impractical today, although may be within reach in less than a decade. He ends by suggesting the use of an analog rather digital computer–-a tank of water.","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"[1]: And even then, eta gives the maximum allowable grid spacing. There is significant flow structure smaller than eta.","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"To have any hope of simulating high Reynolds number flows we need some way of resolving the sub-grid scale motions.[2]","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"[2]: In reality there is no need to resolve all motions down to the Kolmogorov length scale to achieve acceptable accuracy. Perhaps good results can be achieved if 80\\% of the kinetic energy is resolved (§13) S. B. Pope  (2000).","category":"page"},{"location":"numerical_implementation/turbulence_closures/#Reynolds-averaged-Navier–Stokes-equations","page":"Turbulence closures","title":"Reynolds-averaged Navier–Stokes equations","text":"","category":"section"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"Following Osborne Reynolds  (1895) we can decompose flow variables such as velocity boldsymbolu into the mean component overlineboldsymbolu and the fluctuating component boldsymbolu^prime so that boldsymbolu = overlineboldsymbolu + boldsymbolu^prime [see §4 of S. B. Pope  (2000) for a modern discussion].","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"Expressing the Navier-Stokes equations in tensor notation","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"beginalign\n    partial_i u_i = 0   \n    partial_t u_i + u_j partial_j u_i = f_i - alphapartial_i p + nu partial_j partial_j u_i  \nendalign","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"where alpha = rho^-1 is the specific volume and f_i represents external forces. We can plug in the Reynolds decomposition for boldsymbolu and after some manipulation arrive at the following form for the Reynolds-averaged Navier-Stokes equations","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"beginalign\n    partial_i overlineu_i = 0   \n    partial_t overlineu_i + overlineu_j partial_j overlineu_i = overlinef_i -\n    partial_j left(-alphaoverlinepdelta_ij + 2nu overlineS_ij - overlineu_i^prime u_j^primeright)  \nendalign","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"where","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"overlineS_ij = frac12 ( partial_j overlineu_i + partial_i overlineu_j )  ","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"is the mean rate of strain tensor.","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"Thanks to the non-linearity of the Navier-Stokes equations, even when averaged we are left with pesky fluctuation terms which form the components of the Reynolds stress tensor","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"tau_ij = rho overlineu_i^prime u_j^prime  ","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"Attempting to close the equations leads to the closure problem: the time evolution of the Reynolds stresses depends on  triple covariances overlineu_i^prime u_j^prime u_k^prime and covariances with pressure, which depend on quadruple covariances and so on P. Y. Chou  (1945).","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"This is kind of hopeless so we will have to find some way to model the Reynolds stresses.","category":"page"},{"location":"numerical_implementation/turbulence_closures/#Gradient-diffusion-hypothesis-and-eddy-viscosity-models","page":"Turbulence closures","title":"Gradient-diffusion hypothesis and eddy viscosity models","text":"","category":"section"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"The gradient-diffusion hypothesis, due to J. Boussinesq  (1877), assumes that the transport of scalar fluxes such as overlineboldsymbolu^prime c^prime and overlineu_i^prime u_j^prime occurs down the mean scalar gradient grad c as if they are being diffused (§4.4) S. B. Pope  (2000). This is in analogy with how momentum transfer by molecular motion in a gas can be described by a molecular viscosity.","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"Taking this assumption we can express the Reynolds stresses and turbulent tracer fluxes in terms of the mean variables and close the equations","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"overlineboldsymbolu^prime c^prime = -kappa_e boldsymbolnabla overlinec\nquad textand quad\noverlineu_i^prime u_j^prime = -2nu_e overlineS_ij  ","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"where nu_e = nu_e(boldsymbolx t) is the turbulent or eddy viscosity and kappa_e = kappa_e(boldsymbolx t) is the eddy diffusivity.","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"The effective diffusivity ends up being the sum of the molecular and eddy diffusivities. So just by using an elevated value for the viscosity and diffusivity, you are already using an eddy viscosity model.","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"The eddy viscosity model is simple and for that reason is very popular. It can work well even with a constant eddy diffusivity. However, it does assume that the flux is aligned down gradient, which is not true even in simple turbulent flows as the physics of turbulence is quite different from that of colliding molecules leading to the viscous stress law (§4.4,10.1) S. B. Pope  (2000). So we might want something a little bit more sophisticated.","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"EditURL = \"<unknown>/examples/two_dimensional_turbulence.jl\"","category":"page"},{"location":"generated/two_dimensional_turbulence/#Two-dimensional-turbulence-example","page":"Two-dimensional turbulence","title":"Two dimensional turbulence example","text":"","category":"section"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"In this example, we initialize a random velocity field and observe its turbulent decay in a two-dimensional domain. This example demonstrates:","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"How to run a model with no tracers and no buoyancy model.\nHow to use AbstractOperations.\nHow to use ComputedFields to generate output.","category":"page"},{"location":"generated/two_dimensional_turbulence/#Install-dependencies","page":"Two-dimensional turbulence","title":"Install dependencies","text":"","category":"section"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"using Pkg\npkg\"add Oceananigans, JLD2, Plots\"","category":"page"},{"location":"generated/two_dimensional_turbulence/#Model-setup","page":"Two-dimensional turbulence","title":"Model setup","text":"","category":"section"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"We instantiate the model with an isotropic diffusivity. We use a grid with 128² points, a fifth-order advection scheme, third-order Runge-Kutta time-stepping, and a small isotropic viscosity.  Note that we assign Flat to the z direction.","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"using Oceananigans\n\ngrid = RegularRectilinearGrid(size=(128, 128), extent=(2π, 2π),\n                              topology=(Periodic, Periodic, Flat))\n\nmodel = IncompressibleModel(timestepper = :RungeKutta3,\n                              advection = UpwindBiasedFifthOrder(),\n                                   grid = grid,\n                               buoyancy = nothing,\n                                tracers = nothing,\n                                closure = IsotropicDiffusivity(ν=1e-5)\n                           )","category":"page"},{"location":"generated/two_dimensional_turbulence/#Random-initial-conditions","page":"Two-dimensional turbulence","title":"Random initial conditions","text":"","category":"section"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Our initial condition randomizes model.velocities.u and model.velocities.v. We ensure that both have zero mean for aesthetic reasons.","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"using Statistics\n\nu₀ = rand(size(model.grid)...)\nu₀ .-= mean(u₀)\n\nset!(model, u=u₀, v=u₀)","category":"page"},{"location":"generated/two_dimensional_turbulence/#Computing-vorticity-and-speed","page":"Two-dimensional turbulence","title":"Computing vorticity and speed","text":"","category":"section"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"To make our equations prettier, we unpack u, v, and w from the NamedTuple model.velocities:","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"u, v, w = model.velocities","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Next we create two objects called ComputedFields that calculate (i) vorticity that measures the rate at which the fluid rotates and is defined as","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"ω = _x v - _y u  ","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"ω = ∂x(v) - ∂y(u)\n\nω_field = ComputedField(ω)","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"We also calculate (ii) the speed of the flow,","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"s = sqrtu^2 + v^2  ","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"s = sqrt(u^2 + v^2)\n\ns_field = ComputedField(s)","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"We'll pass these ComputedFields to an output writer below to calculate them during the simulation. Now we construct a simulation that prints out the iteration and model time as it runs.","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"progress(sim) = @info \"Iteration: $(sim.model.clock.iteration), time: $(round(Int, sim.model.clock.time))\"\n\nsimulation = Simulation(model, Δt=0.2, stop_time=50, iteration_interval=100, progress=progress)","category":"page"},{"location":"generated/two_dimensional_turbulence/#Output","page":"Two-dimensional turbulence","title":"Output","text":"","category":"section"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"We set up an output writer for the simulation that saves the vorticity every 20 iterations.","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"simulation.output_writers[:fields] = JLD2OutputWriter(model, (ω=ω_field, s=s_field),\n                                                      schedule = TimeInterval(2),\n                                                      prefix = \"two_dimensional_turbulence\",\n                                                      force = true)","category":"page"},{"location":"generated/two_dimensional_turbulence/#Running-the-simulation","page":"Two-dimensional turbulence","title":"Running the simulation","text":"","category":"section"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Pretty much just","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"run!(simulation)","category":"page"},{"location":"generated/two_dimensional_turbulence/#Visualizing-the-results","page":"Two-dimensional turbulence","title":"Visualizing the results","text":"","category":"section"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"We load the output and make a movie.","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"using JLD2\n\nfile = jldopen(simulation.output_writers[:fields].filepath)\n\niterations = parse.(Int, keys(file[\"timeseries/t\"]))","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Construct the x y grid for plotting purposes,","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"xω, yω, zω = nodes(ω_field)\nxs, ys, zs = nodes(s_field)\nnothing # hide","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"and animate the vorticity and fluid speed.","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"using Plots\n\n@info \"Making a neat movie of vorticity and speed...\"\n\nanim = @animate for (i, iteration) in enumerate(iterations)\n\n    @info \"Plotting frame $i from iteration $iteration...\"\n\n    t = file[\"timeseries/t/$iteration\"]\n    ω_snapshot = file[\"timeseries/ω/$iteration\"][:, :, 1]\n    s_snapshot = file[\"timeseries/s/$iteration\"][:, :, 1]\n\n    ω_lim = 2.0\n    ω_levels = range(-ω_lim, stop=ω_lim, length=20)\n\n    s_lim = 0.2\n    s_levels = range(0, stop=s_lim, length=20)\n\n    kwargs = (xlabel=\"x\", ylabel=\"y\", aspectratio=1, linewidth=0, colorbar=true,\n              xlims=(0, model.grid.Lx), ylims=(0, model.grid.Ly))\n\n    ω_plot = contourf(xω, yω, clamp.(ω_snapshot', -ω_lim, ω_lim);\n                       color = :balance,\n                      levels = ω_levels,\n                       clims = (-ω_lim, ω_lim),\n                      kwargs...)\n\n    s_plot = contourf(xs, ys, clamp.(s_snapshot', 0, s_lim);\n                       color = :thermal,\n                      levels = s_levels,\n                       clims = (0., s_lim),\n                      kwargs...)\n\n    plot(ω_plot, s_plot, title=[\"Vorticity\" \"Speed\"], layout=(1, 2), size=(1200, 500))\nend\n\nmp4(anim, \"two_dimensional_turbulence.mp4\", fps = 8) # hide","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"This page was generated using Literate.jl.","category":"page"},{"location":"model_setup/output_writers/#Output-writers","page":"Output writers","title":"Output writers","text":"","category":"section"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"AbstractOutputWriters save data to disk. Oceananigans provides three ways to write output:","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"NetCDFOutputWriter for output of arrays and scalars that uses NCDatasets.jl\nJLD2OutputWriter for arbitrary julia data structures that uses JLD2.jl\nCheckpointer that automatically saves as much model data as possible, using JLD2.jl","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"The Checkpointer is discussed on a separate documentation page.","category":"page"},{"location":"model_setup/output_writers/#Basic-usage","page":"Output writers","title":"Basic usage","text":"","category":"section"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"NetCDFOutputWriter and JLD2OutputWriter require four inputs:","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"The model from which output data is sourced (required to initialize the OutputWriter).\nA key-value pairing of output \"names\" and \"output\" objects. JLD2OutputWriter accepts NamedTuples and Dicts; NetCDFOutputWriter accepts Dicts with string-valued keys. Output objects are either AbstractFields or functions that return data when called via func(model).\nA schedule on which output is written. TimeInterval, IterationInterval, WallTimeInterval schedule periodic output according to the simulation time, simulation interval, or \"wall time\" (the physical time according to a clock on your wall). A fourth schedule called AveragedTimeInterval specifies periodic output that is time-averaged over a window prior to being written.\nThe filename and directory. Currently NetCDFOutputWriter accepts one filepath argument, while JLD2OutputWriter accepts a filename prefix and directory.","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"Other important keyword arguments are","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"field_slicer::FieldSlicer for outputting subregions, two- and one-dimensional slices of fields. By default a FieldSlicer is used to remove halo regions from fields so that only the physical portion of model data is saved to disk.\narray_type for specifying the type of the array that holds outputted field data. The default is Array{Float32}, or arrays of single-precision floating point numbers.","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"Once an OutputWriter is created, it can be used to write output by adding it the ordered dictionary simulation.output_writers. prior to calling run!(simulation).","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"More specific detail about the NetCDFOutputWriter and JLD2OutputWriter is given below.","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"tip: Time step alignment and output writing\nOceananigans simulations will shorten the time step as needed to align model output with each output writer's schedule.","category":"page"},{"location":"model_setup/output_writers/#NetCDF-output-writer","page":"Output writers","title":"NetCDF output writer","text":"","category":"section"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"Model data can be saved to NetCDF files along with associated metadata. The NetCDF output writer is generally used by passing it a dictionary of (label, field) pairs and any indices for slicing if you don't want to save the full 3D field.","category":"page"},{"location":"model_setup/output_writers/#Examples","page":"Output writers","title":"Examples","text":"","category":"section"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"Saving the u velocity field and temperature fields, the full 3D fields and surface 2D slices to separate NetCDF files:","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"using Oceananigans, Oceananigans.OutputWriters\n\ngrid = RegularRectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1));\n\nmodel = IncompressibleModel(grid=grid);\n\nsimulation = Simulation(model, Δt=12, stop_time=3600);\n\nfields = Dict(\"u\" => model.velocities.u, \"T\" => model.tracers.T);\n\nsimulation.output_writers[:field_writer] =\n    NetCDFOutputWriter(model, fields, filepath=\"more_fields.nc\", schedule=TimeInterval(60))\n\n# output\nNetCDFOutputWriter scheduled on TimeInterval(1 minute):\n├── filepath: more_fields.nc\n├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0)\n├── 2 outputs: [\"T\", \"u\"]\n├── field slicer: FieldSlicer(:, :, :, with_halos=false)\n└── array type: Array{Float32}","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"simulation.output_writers[:surface_slice_writer] =\n    NetCDFOutputWriter(model, fields, filepath=\"another_surface_xy_slice.nc\",\n                       schedule=TimeInterval(60), field_slicer=FieldSlicer(k=grid.Nz))\n\n# output\nNetCDFOutputWriter scheduled on TimeInterval(1 minute):\n├── filepath: another_surface_xy_slice.nc\n├── dimensions: zC(1), zF(1), xC(16), yF(16), xF(16), yC(16), time(0)\n├── 2 outputs: [\"T\", \"u\"]\n├── field slicer: FieldSlicer(:, :, 16, with_halos=false)\n└── array type: Array{Float32}","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"simulation.output_writers[:averaged_profile_writer] =\n    NetCDFOutputWriter(model, fields,\n                       filepath = \"another_averaged_z_profile.nc\",\n                       schedule = AveragedTimeInterval(60, window=20),\n                       field_slicer = FieldSlicer(i=1, j=1))\n\n# output\nNetCDFOutputWriter scheduled on TimeInterval(1 minute):\n├── filepath: another_averaged_z_profile.nc\n├── dimensions: zC(16), zF(17), xC(1), yF(1), xF(1), yC(1), time(0)\n├── 2 outputs: [\"T\", \"u\"] averaged on AveragedTimeInterval(window=20 seconds, stride=1, interval=1 minute)\n├── field slicer: FieldSlicer(1, 1, :, with_halos=false)\n└── array type: Array{Float32}","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"NetCDFOutputWriter also accepts output functions that write scalars and arrays to disk, provided that their dimensions are provided:","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"using Oceananigans, Oceananigans.OutputWriters\n\ngrid = RegularRectilinearGrid(size=(16, 16, 16), extent=(1, 2, 3));\n\nmodel = IncompressibleModel(grid=grid);\n\nsimulation = Simulation(model, Δt=1.25, stop_iteration=3);\n\nf(model) = model.clock.time^2; # scalar output\ng(model) = model.clock.time .* exp.(znodes(Center, grid)); # vector/profile output\nh(model) = model.clock.time .* (   sin.(xnodes(Center, grid, reshape=true)[:, :, 1])\n                            .*     cos.(ynodes(Face, grid, reshape=true)[:, :, 1])); # xy slice output\n\noutputs = Dict(\"scalar\" => f, \"profile\" => g, \"slice\" => h);\n\ndims = Dict(\"scalar\" => (), \"profile\" => (\"zC\",), \"slice\" => (\"xC\", \"yC\"));\n\noutput_attributes = Dict(\n    \"scalar\"  => Dict(\"longname\" => \"Some scalar\", \"units\" => \"bananas\"),\n    \"profile\" => Dict(\"longname\" => \"Some vertical profile\", \"units\" => \"watermelons\"),\n    \"slice\"   => Dict(\"longname\" => \"Some slice\", \"units\" => \"mushrooms\")\n);\n\nglobal_attributes = Dict(\"location\" => \"Bay of Fundy\", \"onions\" => 7);\n\nsimulation.output_writers[:things] =\n    NetCDFOutputWriter(model, outputs,\n                       schedule=IterationInterval(1), filepath=\"some_things.nc\", dimensions=dims, verbose=true,\n                       global_attributes=global_attributes, output_attributes=output_attributes)\n\n# output\nNetCDFOutputWriter scheduled on IterationInterval(1):\n├── filepath: some_things.nc\n├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0)\n├── 3 outputs: [\"profile\", \"slice\", \"scalar\"]\n├── field slicer: FieldSlicer(:, :, :, with_halos=false)\n└── array type: Array{Float32}","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"See NetCDFOutputWriter for more information.","category":"page"},{"location":"model_setup/output_writers/#JLD2-output-writer","page":"Output writers","title":"JLD2 output writer","text":"","category":"section"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"JLD2 is a fast HDF5 compatible file format written in pure Julia. JLD2 files can be opened in Julia with the JLD2.jl package and in Python with the h5py package.","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"The JLD2OutputWriter receives either a Dictionary or NamedTuple containing name, output pairs. The name can be a symbol or string. The output must either be an AbstractField or a function called with func(model) that returns arbitrary output. Whenever output needs to be written, the functions will be called and the output of the function will be saved to the JLD2 file.","category":"page"},{"location":"model_setup/output_writers/#Examples-2","page":"Output writers","title":"Examples","text":"","category":"section"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"Write out 3D fields for w and T and a horizontal average:","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"using Oceananigans, Oceananigans.OutputWriters, Oceananigans.Fields\nusing Oceananigans.Utils: hour, minute\n\nmodel = IncompressibleModel(grid=RegularRectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)))\n\nsimulation = Simulation(model, Δt=12, stop_time=1hour)\n\nfunction init_save_some_metadata!(file, model)\n    file[\"author\"] = \"Chim Riggles\"\n    file[\"parameters/coriolis_parameter\"] = 1e-4\n    file[\"parameters/density\"] = 1027\n    return nothing\nend\n\nT_avg =  AveragedField(model.tracers.T, dims=(1, 2))\n\n# Note that model.velocities is NamedTuple\nsimulation.output_writers[:velocities] = JLD2OutputWriter(model, model.velocities,\n                                                          prefix = \"some_more_data\",\n                                                          schedule = TimeInterval(20minute),\n                                                          init = init_save_some_metadata!)\n\n# output\nJLD2OutputWriter scheduled on TimeInterval(20 minutes):\n├── filepath: ./some_more_data.jld2\n├── 3 outputs: (:u, :v, :w)\n├── field slicer: FieldSlicer(:, :, :, with_halos=false)\n├── array type: Array{Float32}\n├── including: [:grid, :coriolis, :buoyancy, :closure]\n└── max filesize: Inf YiB","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"and a time- and horizontal-average of temperature T every 1 hour of simulation time to a file called some_averaged_data.jld2","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"simulation.output_writers[:avg_T] = JLD2OutputWriter(model, (T=T_avg,),\n                                                     prefix = \"some_more_averaged_data\",\n                                                     schedule = AveragedTimeInterval(20minute, window=5minute))\n# output\nJLD2OutputWriter scheduled on TimeInterval(20 minutes):\n├── filepath: ./some_more_averaged_data.jld2\n├── 1 outputs: (:T,) averaged on AveragedTimeInterval(window=5 minutes, stride=1, interval=20 minutes)\n├── field slicer: FieldSlicer(:, :, :, with_halos=false)\n├── array type: Array{Float32}\n├── including: [:grid, :coriolis, :buoyancy, :closure]\n└── max filesize: Inf YiB","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"See JLD2OutputWriter for more information.","category":"page"},{"location":"model_setup/output_writers/#Time-averaged-output","page":"Output writers","title":"Time-averaged output","text":"","category":"section"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"Time-averaged output is specified by setting the schedule keyword argument for either NetCDFOutputWriter or JLD2OutputWriter to AveragedTimeInterval.","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"With AveragedTimeInterval, the time-average of a is taken as a left Riemann sum corresponding to","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"langle a rangle = frac1T int_t_i-T^t_i a  mathrmd t  ","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"where langle a rangle is the time-average of a, T is the time-window for averaging specified by the window keyword argument to AveragedTimeInterval, and the t_i are discrete times separated by the time interval. The t_i specify both the end of the averaging window and the time at which output is written.","category":"page"},{"location":"model_setup/output_writers/#Example","page":"Output writers","title":"Example","text":"","category":"section"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"Building an AveragedTimeInterval that averages over a 1 year window, every 4 years,","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"using Oceananigans.OutputWriters: AveragedTimeInterval\nusing Oceananigans.Utils: year, years\n\nschedule = AveragedTimeInterval(4years, window=1year)\n\n# output\nAveragedTimeInterval(window=1 year, stride=1, interval=4 years)","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"An AveragedTimeInterval schedule directs an output writer to time-average its outputs before writing them to disk:","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"using Oceananigans\nusing Oceananigans.OutputWriters: JLD2OutputWriter\nusing Oceananigans.Utils: minutes\n\nmodel = IncompressibleModel(grid=RegularRectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)))\n\nsimulation = Simulation(model, Δt=10minutes, stop_time=30years)\n\nsimulation.output_writers[:velocities] = JLD2OutputWriter(model, model.velocities,\n                                                          prefix = \"even_more_averaged_velocity_data\",\n                                                          schedule = AveragedTimeInterval(4years, window=1year, stride=2))\n\n# output\nJLD2OutputWriter scheduled on TimeInterval(4 years):\n├── filepath: ./even_more_averaged_velocity_data.jld2\n├── 3 outputs: (:u, :v, :w) averaged on AveragedTimeInterval(window=1 year, stride=2, interval=4 years)\n├── field slicer: FieldSlicer(:, :, :, with_halos=false)\n├── array type: Array{Float32}\n├── including: [:grid, :coriolis, :buoyancy, :closure]\n└── max filesize: Inf YiB","category":"page"},{"location":"model_setup/clock/#Clock","page":"Clock","title":"Clock","text":"","category":"section"},{"location":"model_setup/clock/","page":"Clock","title":"Clock","text":"The clock holds the current simulation time, iteration number, and time step stage. The time step stage is relevant only for the multi-stage time-stepper RungeKutta3TimeStepper.","category":"page"},{"location":"model_setup/clock/","page":"Clock","title":"Clock","text":"By default, Clocks are initialized at iteration 0, and stage 1,","category":"page"},{"location":"model_setup/clock/","page":"Clock","title":"Clock","text":"DocTestSetup = quote\n    using Oceananigans\nend","category":"page"},{"location":"model_setup/clock/","page":"Clock","title":"Clock","text":"julia> clock = Clock(time=0.0)\nClock{Float64}: time = 0 seconds, iteration = 0, stage = 1","category":"page"},{"location":"model_setup/clock/","page":"Clock","title":"Clock","text":"but can be modified to start the model clock at some other time. For example, passing","category":"page"},{"location":"model_setup/clock/","page":"Clock","title":"Clock","text":"julia> clock = Clock(time=3600.0)\nClock{Float64}: time = 1 hour, iteration = 0, stage = 1","category":"page"},{"location":"model_setup/clock/","page":"Clock","title":"Clock","text":"to the constructor for IncompressibleModel causes the simulation time to start at t = 3600 seconds.","category":"page"},{"location":"model_setup/clock/","page":"Clock","title":"Clock","text":"The type of the keyword argument time should be a float or date type. To use the date type TimeDate from the TimesDates.jl package, for example, pass","category":"page"},{"location":"model_setup/clock/","page":"Clock","title":"Clock","text":"julia> using TimesDates\n\njulia> clock = Clock(time=TimeDate(2020))\nClock{TimesDates.TimeDate}: time = 2020-01-01T00:00:00, iteration = 0, stage = 1","category":"page"},{"location":"model_setup/clock/","page":"Clock","title":"Clock","text":"to IncompressibleModel. TimeDate supports nanosecond resolution and is thus recommended over Base.Dates.DateTime, which is also supported but has only millisecond resolution.","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#Turbulent-diffusivity-closures-and-large-eddy-simulation-models","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and large eddy simulation models","text":"","category":"section"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"A turbulent diffusivity closure representing the effects of viscous dissipation and diffusion can be passed via the closure keyword.","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"See turbulence closures and large eddy simulation for more details on turbulent diffusivity closures.","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#Constant-isotropic-diffusivity","page":"Turbulent diffusivity closures and LES models","title":"Constant isotropic diffusivity","text":"","category":"section"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"To use constant isotropic values for the viscosity ν and diffusivity κ you can use IsotropicDiffusivity","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"julia> using Oceananigans.TurbulenceClosures\n\njulia> closure = IsotropicDiffusivity(ν=1e-2, κ=1e-2)\nIsotropicDiffusivity: ν=0.01, κ=0.01","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#Constant-anisotropic-diffusivity","page":"Turbulent diffusivity closures and LES models","title":"Constant anisotropic diffusivity","text":"","category":"section"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"To specify constant values for the horizontal and vertical viscosities, nu_h and nu_v, and horizontal and vertical diffusivities, kappa_h and kappa_v, you can use AnisotropicDiffusivity","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"julia> using Oceananigans.TurbulenceClosures\n\njulia> closure = AnisotropicDiffusivity(νh=1e-3, νz=5e-2, κh=2e-3, κz=1e-1)\nAnisotropicDiffusivity: (νx=0.001, νy=0.001, νz=0.05), (κx=0.002, κy=0.002, κz=0.1)","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#Smagorinsky-Lilly","page":"Turbulent diffusivity closures and LES models","title":"Smagorinsky-Lilly","text":"","category":"section"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"To use the Smagorinsky-Lilly LES closure, no parameters are required","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"julia> using Oceananigans.TurbulenceClosures\n\njulia> closure = SmagorinskyLilly()\nSmagorinskyLilly: C=0.23, Cb=1.0, Pr=1.0, ν=0.0, κ=0.0","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"although they may be specified. By default, the background viscosity and diffusivity are assumed to be the molecular values for seawater. For more details see SmagorinskyLilly.","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#Anisotropic-minimum-dissipation","page":"Turbulent diffusivity closures and LES models","title":"Anisotropic minimum dissipation","text":"","category":"section"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"To use the constant anisotropic minimum dissipation (AMD) LES closure,","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"julia> using Oceananigans.TurbulenceClosures\n\njulia> closure = AnisotropicMinimumDissipation()\nAnisotropicMinimumDissipation{Float64} turbulence closure with:\n           Poincaré constant for momentum eddy viscosity Cν: 0.08333333333333333\n    Poincaré constant for tracer(s) eddy diffusivit(ies) Cκ: 0.08333333333333333\n                        Buoyancy modification multiplier Cb: nothing\n                Background diffusivit(ies) for tracer(s), κ: 0.0\n             Background kinematic viscosity for momentum, ν: 0.0","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"no parameters are required although they may be specified. By default, the background viscosity and diffusivity are assumed to be the molecular values for seawater. For more details see AnisotropicMinimumDissipation.","category":"page"},{"location":"model_setup/grids/#Grids","page":"Grid","title":"Grids","text":"","category":"section"},{"location":"model_setup/grids/","page":"Grid","title":"Grid","text":"We currently support only RegularRectilinearGrids with constant grid spacings. The spacing can be different for each dimension.","category":"page"},{"location":"model_setup/grids/","page":"Grid","title":"Grid","text":"A RegularRectilinearGrid is constructed by specifying the size of the grid (a Tuple specifying the number of grid points in each direction) and either the extent (a Tuple specifying the physical extent of the grid in each direction), or 2-Tuples x, y, and z (for a 3D grid) that defines the the end points in each direction.","category":"page"},{"location":"model_setup/grids/","page":"Grid","title":"Grid","text":"A regular rectilinear grid with N_x times N_y times N_z = 32 times 64 times 256 grid points and an extent of L_x = 128 meters, L_y = 256 meters, and L_z = 512 meters is constructed using","category":"page"},{"location":"model_setup/grids/","page":"Grid","title":"Grid","text":"DocTestSetup = quote\n    using Oceananigans\nend","category":"page"},{"location":"model_setup/grids/","page":"Grid","title":"Grid","text":"julia> grid = RegularRectilinearGrid(size=(32, 64, 256), extent=(128, 256, 512))\nRegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}\n                   domain: x ∈ [0.0, 128.0], y ∈ [0.0, 256.0], z ∈ [-512.0, 0.0]\n                 topology: (Periodic, Periodic, Bounded)\n  resolution (Nx, Ny, Nz): (32, 64, 256)\n   halo size (Hx, Hy, Hz): (1, 1, 1)\ngrid spacing (Δx, Δy, Δz): (4.0, 4.0, 2.0)","category":"page"},{"location":"model_setup/grids/","page":"Grid","title":"Grid","text":"info: Default domain\nWhen using the extent keyword, the domain is x in 0 L_x, y in 0 L_y, and z in -L_z 0 – a sensible choice for oceanographic applications.","category":"page"},{"location":"model_setup/grids/#Specifying-the-grid's-topology","page":"Grid","title":"Specifying the grid's topology","text":"","category":"section"},{"location":"model_setup/grids/","page":"Grid","title":"Grid","text":"Another crucial keyword is a 3-Tuple that specifies the grid's topology. In each direction the grid may be Periodic or Bounded. By default, the RegularRectilinearGrid constructor assumes the grid topology is horizontally-periodic and bounded in the vertical, such that topology = (Periodic, Periodic, Bounded).","category":"page"},{"location":"model_setup/grids/","page":"Grid","title":"Grid","text":"A \"channel\" model that is periodic in the x-direction and wall-bounded in the y- and z-dimensions is build with,","category":"page"},{"location":"model_setup/grids/","page":"Grid","title":"Grid","text":"julia> grid = RegularRectilinearGrid(topology=(Periodic, Bounded, Bounded), size=(64, 64, 32), extent=(1e4, 1e4, 1e3))\nRegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}\n                   domain: x ∈ [0.0, 10000.0], y ∈ [0.0, 10000.0], z ∈ [-1000.0, 0.0]\n                 topology: (Periodic, Bounded, Bounded)\n  resolution (Nx, Ny, Nz): (64, 64, 32)\n   halo size (Hx, Hy, Hz): (1, 1, 1)\ngrid spacing (Δx, Δy, Δz): (156.25, 156.25, 31.25)","category":"page"},{"location":"model_setup/grids/#Specifying-domain-end-points","page":"Grid","title":"Specifying domain end points","text":"","category":"section"},{"location":"model_setup/grids/","page":"Grid","title":"Grid","text":"To specify a domain with a different origin than the default, the x, y, and z keyword arguments must be used. For example, a grid with x in -100 100 meters, y in 0 125 meters, and z in -π π meters is constructed via","category":"page"},{"location":"model_setup/grids/","page":"Grid","title":"Grid","text":"julia> grid = RegularRectilinearGrid(size=(32, 16, 256), x=(-100, 100), y=(0, 12.5), z=(-π, π))\nRegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}\n                   domain: x ∈ [-100.0, 100.0], y ∈ [0.0, 12.5], z ∈ [-3.141592653589793, 3.141592653589793]\n                 topology: (Periodic, Periodic, Bounded)\n  resolution (Nx, Ny, Nz): (32, 16, 256)\n   halo size (Hx, Hy, Hz): (1, 1, 1)\ngrid spacing (Δx, Δy, Δz): (6.25, 0.78125, 0.02454369260617026)","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"EditURL = \"<unknown>/examples/langmuir_turbulence.jl\"","category":"page"},{"location":"generated/langmuir_turbulence/#Langmuir-turbulence-example","page":"Langmuir turbulence","title":"Langmuir turbulence example","text":"","category":"section"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"This example implements the Langmuir turbulence simulation reported in section 4 of","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"McWilliams, J. C. et al., \"Langmuir Turbulence in the ocean,\" Journal of Fluid Mechanics (1997).","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"This example demonstrates","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"How to run large eddy simulations with surface wave effects via the Craik-Leibovich approximation.\nHow to specify time- and horizontally-averaged output.","category":"page"},{"location":"generated/langmuir_turbulence/#Install-dependencies","page":"Langmuir turbulence","title":"Install dependencies","text":"","category":"section"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"using Pkg\npkg\"add Oceananigans, JLD2, Plots\"","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"using Oceananigans\nusing Oceananigans.Units: minute, minutes, hours","category":"page"},{"location":"generated/langmuir_turbulence/#Model-set-up","page":"Langmuir turbulence","title":"Model set-up","text":"","category":"section"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"To build the model, we specify the grid, Stokes drift, boundary conditions, and Coriolis parameter.","category":"page"},{"location":"generated/langmuir_turbulence/#Domain-and-numerical-grid-specification","page":"Langmuir turbulence","title":"Domain and numerical grid specification","text":"","category":"section"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"We create a grid with modest resolution. The grid extent is similar, but not exactly the same as that in McWilliams et al. (1997).","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"grid = RegularRectilinearGrid(size=(32, 32, 48), extent=(128, 128, 96))","category":"page"},{"location":"generated/langmuir_turbulence/#The-Stokes-Drift-profile","page":"Langmuir turbulence","title":"The Stokes Drift profile","text":"","category":"section"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"The surface wave Stokes drift profile prescribed in McWilliams et al. (1997) corresponds to a 'monochromatic' (that is, single-frequency) wave field.","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"A monochromatic wave field is characterized by its wavelength and amplitude (half the distance from wave crest to wave trough), which determine the wave frequency and the vertical scale of the Stokes drift profile.","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"using Oceananigans.BuoyancyModels: g_Earth\n\n amplitude = 0.8 # m\nwavelength = 60 # m\nwavenumber = 2π / wavelength # m⁻¹\n frequency = sqrt(g_Earth * wavenumber) # s⁻¹\n\n# The vertical scale over which the Stokes drift of a monochromatic surface wave\n# decays away from the surface is `1/2wavenumber`, or\nconst vertical_scale = wavelength / 4π\n\n# Stokes drift velocity at the surface\nconst Uˢ = amplitude^2 * wavenumber * frequency # m s⁻¹","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"The const declarations ensure that Stokes drift functions compile on the GPU. To run this example on the GPU, write architecture = GPU() in the constructor for IncompressibleModel below.","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"The Stokes drift profile is","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"uˢ(z) = Uˢ * exp(z / vertical_scale)","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"which we'll need for the initial condition.","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"info: The Craik-Leibovich equations in Oceananigans\nOceananigans implements the Craik-Leibovich approximation for surface wave effects using the Lagrangian-mean velocity field as its prognostic momentum variable. In other words, model.velocities.u is the Lagrangian-mean x-velocity beneath surface waves. This differs from models that use the Eulerian-mean velocity field as a prognostic variable, but has the advantage that u accounts for the total advection of tracers and momentum, and that u = v = w = 0 is a steady solution even when Coriolis forces are present. See the physics documentation for more information.","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"The vertical derivative of the Stokes drift is","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"∂z_uˢ(z, t) = 1 / vertical_scale * Uˢ * exp(z / vertical_scale)","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"Finally, we note that the time-derivative of the Stokes drift must be provided if the Stokes drift changes in time. In this example, the Stokes drift is constant and thus the time-derivative of the Stokes drift is 0.","category":"page"},{"location":"generated/langmuir_turbulence/#Boundary-conditions","page":"Langmuir turbulence","title":"Boundary conditions","text":"","category":"section"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"At the surface at z=0, McWilliams et al. (1997) impose a wind stress on u,","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"Qᵘ = -3.72e-5 # m² s⁻², surface kinematic momentum flux\n\nu_boundary_conditions = UVelocityBoundaryConditions(grid, top = FluxBoundaryCondition(Qᵘ))","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"McWilliams et al. (1997) impose a linear buoyancy gradient N² at the bottom along with a weak, destabilizing flux of buoyancy at the surface to faciliate spin-up from rest.","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"Qᵇ = 2.307e-9 # m³ s⁻², surface buoyancy flux\nN² = 1.936e-5 # s⁻², initial and bottom buoyancy gradient\n\nb_boundary_conditions = TracerBoundaryConditions(grid, top = FluxBoundaryCondition(Qᵇ),\n                                                       bottom = GradientBoundaryCondition(N²))","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"info: The flux convention in Oceananigans\nNote that Oceananigans uses \"positive upward\" conventions for all fluxes. In consequence, a negative flux at the surface drives positive velocities, and a positive flux of buoyancy drives cooling.","category":"page"},{"location":"generated/langmuir_turbulence/#Coriolis-parameter","page":"Langmuir turbulence","title":"Coriolis parameter","text":"","category":"section"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"McWilliams et al. (1997) use","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"coriolis = FPlane(f=1e-4) # s⁻¹","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"which is typical for mid-latitudes on Earth.","category":"page"},{"location":"generated/langmuir_turbulence/#Model-instantiation","page":"Langmuir turbulence","title":"Model instantiation","text":"","category":"section"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"We are ready to build the model. We use a fifth-order Weighted Essentially Non-Oscillatory (WENO) advection scheme and the AnisotropicMinimumDissipation model for large eddy simulation. Because our Stokes drift does not vary in x y, we use UniformStokesDrift, which expects Stokes drift functions of z t only.","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"model = IncompressibleModel(\n           architecture = CPU(),\n              advection = WENO5(),\n            timestepper = :RungeKutta3,\n                   grid = grid,\n                tracers = :b,\n               buoyancy = BuoyancyTracer(),\n               coriolis = coriolis,\n                closure = AnisotropicMinimumDissipation(),\n           stokes_drift = UniformStokesDrift(∂z_uˢ=∂z_uˢ),\n    boundary_conditions = (u=u_boundary_conditions, b=b_boundary_conditions),\n)","category":"page"},{"location":"generated/langmuir_turbulence/#Initial-conditions","page":"Langmuir turbulence","title":"Initial conditions","text":"","category":"section"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"We make use of random noise concentrated in the upper 4 meters for buoyancy and velocity initial conditions,","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"Ξ(z) = randn() * exp(z / 4)\nnothing # hide","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"Our initial condition for buoyancy consists of a surface mixed layer 33 m deep, a deep linear stratification, plus noise,","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"initial_mixed_layer_depth = 33 # m\nstratification(z) = z < - initial_mixed_layer_depth ? N² * z : N² * (-initial_mixed_layer_depth)\n\nbᵢ(x, y, z) = stratification(z) + 1e-1 * Ξ(z) * N² * model.grid.Lz","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"The velocity initial condition in McWilliams et al. (1997) is zero Eulerian-mean velocity. This means that we must add the Stokes drift profile to the Lagrangian-mean u velocity field modeled by Oceananigans.jl. We also add noise scaled by the friction velocity to u and w.","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"uᵢ(x, y, z) = uˢ(z) + sqrt(abs(Qᵘ)) * 1e-1 * Ξ(z)\n\nwᵢ(x, y, z) = sqrt(abs(Qᵘ)) * 1e-1 * Ξ(z)\n\nset!(model, u=uᵢ, w=wᵢ, b=bᵢ)","category":"page"},{"location":"generated/langmuir_turbulence/#Setting-up-the-simulation","page":"Langmuir turbulence","title":"Setting up the simulation","text":"","category":"section"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"We use the TimeStepWizard for adaptive time-stepping with a Courant-Freidrichs-Lewy (CFL) number of 1.0,","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"wizard = TimeStepWizard(cfl=1.0, Δt=45.0, max_change=1.1, max_Δt=1minute)","category":"page"},{"location":"generated/langmuir_turbulence/#Nice-progress-messaging","page":"Langmuir turbulence","title":"Nice progress messaging","text":"","category":"section"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"We define a function that prints a helpful message with maximum absolute value of u v w and the current wall clock time.","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"using Printf\n\nwall_clock = time_ns()\n\nfunction print_progress(simulation)\n    model = simulation.model\n    u, v, w = model.velocities\n\n    # Print a progress message\n    msg = @sprintf(\"i: %04d, t: %s, Δt: %s, umax = (%.1e, %.1e, %.1e) ms⁻¹, wall time: %s\\n\",\n                   model.clock.iteration,\n                   prettytime(model.clock.time),\n                   prettytime(wizard.Δt),\n                   maximum(abs, u), maximum(abs, v), maximum(abs, w),\n                   prettytime(1e-9 * (time_ns() - wall_clock))\n                  )\n\n    @info msg\n\n    return nothing\nend","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"Now we create the simulation,","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"simulation = Simulation(model, iteration_interval = 10,\n                                               Δt = wizard,\n                                        stop_time = 4hours,\n                                         progress = print_progress)","category":"page"},{"location":"generated/langmuir_turbulence/#Output","page":"Langmuir turbulence","title":"Output","text":"","category":"section"},{"location":"generated/langmuir_turbulence/#A-field-writer","page":"Langmuir turbulence","title":"A field writer","text":"","category":"section"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"We set up an output writer for the simulation that saves all velocity fields, tracer fields, and the subgrid turbulent diffusivity.","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"output_interval = 5minutes\n\nfields_to_output = merge(model.velocities, model.tracers, (νₑ=model.diffusivities.νₑ,))\n\nsimulation.output_writers[:fields] =\n    JLD2OutputWriter(model, fields_to_output,\n                     schedule = TimeInterval(output_interval),\n                     prefix = \"langmuir_turbulence_fields\",\n                     force = true)","category":"page"},{"location":"generated/langmuir_turbulence/#An-\"averages\"-writer","page":"Langmuir turbulence","title":"An \"averages\" writer","text":"","category":"section"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"We also set up output of time- and horizontally-averaged velocity field and momentum fluxes,","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"u, v, w = model.velocities\n\nU = AveragedField(u, dims=(1, 2))\nV = AveragedField(v, dims=(1, 2))\nB = AveragedField(model.tracers.b, dims=(1, 2))\n\nwu = AveragedField(w * u, dims=(1, 2))\nwv = AveragedField(w * v, dims=(1, 2))\n\nsimulation.output_writers[:averages] =\n    JLD2OutputWriter(model, (u=U, v=V, b=B, wu=wu, wv=wv),\n                     schedule = AveragedTimeInterval(output_interval, window=2minutes),\n                     prefix = \"langmuir_turbulence_averages\",\n                     force = true)","category":"page"},{"location":"generated/langmuir_turbulence/#Running-the-simulation","page":"Langmuir turbulence","title":"Running the simulation","text":"","category":"section"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"This part is easy,","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"run!(simulation)","category":"page"},{"location":"generated/langmuir_turbulence/#Making-a-neat-movie","page":"Langmuir turbulence","title":"Making a neat movie","text":"","category":"section"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"We look at the results by plotting vertical slices of u and w, and a horizontal slice of w to look for Langmuir cells.","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"k = searchsortedfirst(grid.zF[:], -8)\nnothing # hide","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"Making the coordinate arrays takes a few lines of code,","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"xw, yw, zw = nodes(model.velocities.w)\nxu, yu, zu = nodes(model.velocities.u)\nnothing # hide","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"Next, we open the JLD2 file, and extract the iterations we ended up saving at,","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"using JLD2, Plots\n\nfields_file = jldopen(simulation.output_writers[:fields].filepath)\naverages_file = jldopen(simulation.output_writers[:averages].filepath)\n\niterations = parse.(Int, keys(fields_file[\"timeseries/t\"]))","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"This utility is handy for calculating nice contour intervals:","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"function nice_divergent_levels(c, clim; nlevels=20)\n    levels = range(-clim, stop=clim, length=nlevels)\n    cmax = maximum(abs, c)\n    clim < cmax && (levels = vcat([-cmax], levels, [cmax]))\n    return (-clim, clim), levels\nend\nnothing # hide","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"Finally, we're ready to animate.","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"@info \"Making an animation from the saved data...\"\n\nanim = @animate for (i, iter) in enumerate(iterations)\n\n    @info \"Drawing frame $i from iteration $iter \\n\"\n\n    # Load 3D fields from fields_file\n    t = fields_file[\"timeseries/t/$iter\"]\n    w_snapshot = fields_file[\"timeseries/w/$iter\"]\n    u_snapshot = fields_file[\"timeseries/u/$iter\"]\n\n    B_snapshot = averages_file[\"timeseries/b/$iter\"][1, 1, :]\n    U_snapshot = averages_file[\"timeseries/u/$iter\"][1, 1, :]\n    V_snapshot = averages_file[\"timeseries/v/$iter\"][1, 1, :]\n    wu_snapshot = averages_file[\"timeseries/wu/$iter\"][1, 1, :]\n    wv_snapshot = averages_file[\"timeseries/wv/$iter\"][1, 1, :]\n\n    # Extract slices\n    wxy = w_snapshot[:, :, k]\n    wxz = w_snapshot[:, 1, :]\n    uxz = u_snapshot[:, 1, :]\n\n    wlims, wlevels = nice_divergent_levels(w, 0.03)\n    ulims, ulevels = nice_divergent_levels(w, 0.05)\n\n    B_plot = plot(B_snapshot, zu,\n                  label = nothing,\n                  legend = :bottom,\n                  xlabel = \"Buoyancy (m s⁻²)\",\n                  ylabel = \"z (m)\")\n\n    U_plot = plot([U_snapshot V_snapshot], zu,\n                  label = [\"\\$ \\\\bar u \\$\" \"\\$ \\\\bar v \\$\"],\n                  legend = :bottom,\n                  xlabel = \"Velocities (m s⁻¹)\",\n                  ylabel = \"z (m)\")\n\n    wu_label = \"\\$ \\\\overline{wu} \\$\"\n    wv_label = \"\\$ \\\\overline{wv} \\$\"\n\n    fluxes_plot = plot([wu_snapshot, wv_snapshot], zw,\n                       label = [wu_label wv_label],\n                       legend = :bottom,\n                       xlabel = \"Momentum fluxes (m² s⁻²)\",\n                       ylabel = \"z (m)\")\n\n    wxy_plot = contourf(xw, yw, wxy';\n                        color = :balance,\n                        linewidth = 0,\n                        aspectratio = :equal,\n                        clims = wlims,\n                        levels = wlevels,\n                        xlims = (0, grid.Lx),\n                        ylims = (0, grid.Ly),\n                        xlabel = \"x (m)\",\n                        ylabel = \"y (m)\")\n\n    wxz_plot = contourf(xw, zw, wxz';\n                              color = :balance,\n                          linewidth = 0,\n                        aspectratio = :equal,\n                              clims = wlims,\n                             levels = wlevels,\n                              xlims = (0, grid.Lx),\n                              ylims = (-grid.Lz, 0),\n                             xlabel = \"x (m)\",\n                             ylabel = \"z (m)\")\n\n    uxz_plot = contourf(xu, zu, uxz';\n                              color = :balance,\n                          linewidth = 0,\n                        aspectratio = :equal,\n                              clims = ulims,\n                             levels = ulevels,\n                              xlims = (0, grid.Lx),\n                              ylims = (-grid.Lz, 0),\n                             xlabel = \"x (m)\",\n                             ylabel = \"z (m)\")\n\n    wxy_title = @sprintf(\"w(x, y, t) (m s⁻¹) at z=-8 m and t = %s \", prettytime(t))\n    wxz_title = @sprintf(\"w(x, z, t) (m s⁻¹) at y=0 m and t = %s\", prettytime(t))\n    uxz_title = @sprintf(\"u(x, z, t) (m s⁻¹) at y=0 m and t = %s\", prettytime(t))\n\n    plot(wxy_plot, B_plot, wxz_plot, U_plot, uxz_plot, fluxes_plot,\n         layout = Plots.grid(3, 2, widths=(0.7, 0.3)), size = (900.5, 1000.5),\n         title = [wxy_title \"\" wxz_title \"\" uxz_title \"\"])\n\n    if iter == iterations[end]\n        close(fields_file)\n        close(averages_file)\n    end\nend\n\nmp4(anim, \"langmuir_turbulence.mp4\", fps = 8) # hide","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"EditURL = \"<unknown>/examples/ocean_wind_mixing_and_convection.jl\"","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#gpu_example","page":"Ocean wind mixing and convection","title":"Wind- and convection-driven mixing in an ocean surface boundary layer","text":"","category":"section"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"This example simulates mixing by three-dimensional turbulence in an ocean surface boundary layer driven by atmospheric winds and convection. It demonstrates:","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"How to use the SeawaterBuoyancy model for buoyancy with a linear equation of state.\nHow to use a turbulence closure for large eddy simulation.\nHow to use a function to impose a boundary condition.","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#Install-dependencies","page":"Ocean wind mixing and convection","title":"Install dependencies","text":"","category":"section"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"using Pkg\npkg\"add Oceananigans, JLD2, Plots\"","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We start by importing all of the packages and functions that we'll need for this example.","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"using Random\nusing Printf\nusing Plots\nusing JLD2\n\nusing Oceananigans\nusing Oceananigans.Units: minute, minutes, hour","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#The-grid","page":"Ocean wind mixing and convection","title":"The grid","text":"","category":"section"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We use 32³ grid points with 2 m grid spacing in the horizontal and 1 m spacing in the vertical,","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"grid = RegularRectilinearGrid(size=(32, 32, 32), extent=(64, 64, 32))","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#Buoyancy-that-depends-on-temperature-and-salinity","page":"Ocean wind mixing and convection","title":"Buoyancy that depends on temperature and salinity","text":"","category":"section"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We use the SeawaterBuoyancy model with a linear equation of state,","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"buoyancy = SeawaterBuoyancy(equation_of_state=LinearEquationOfState(α=2e-4, β=8e-4))","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"where α and β are the thermal expansion and haline contraction coefficients for temperature and salinity.","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#Boundary-conditions","page":"Ocean wind mixing and convection","title":"Boundary conditions","text":"","category":"section"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We calculate the surface temperature flux associated with surface heating of 200 W m⁻², reference density ρ, and heat capacity cᴾ,","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Qʰ = 200  # W m⁻², surface _heat_ flux\nρₒ = 1026 # kg m⁻³, average density at the surface of the world ocean\ncᴾ = 3991 # J K⁻¹ s⁻¹, typical heat capacity for seawater\n\nQᵀ = Qʰ / (ρₒ * cᴾ) # K m⁻¹ s⁻¹, surface _temperature_ flux","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Finally, we impose a temperature gradient dTdz both initially and at the bottom of the domain, culminating in the boundary conditions on temperature,","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"dTdz = 0.01 # K m⁻¹\n\nT_bcs = TracerBoundaryConditions(grid,\n                                 top = FluxBoundaryCondition(Qᵀ),\n                                 bottom = GradientBoundaryCondition(dTdz))","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Note that a positive temperature flux at the surface of the ocean implies cooling. This is because a positive temperature flux implies that temperature is fluxed upwards, out of the ocean.","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"For the velocity field, we imagine a wind blowing over the ocean surface with an average velocity at 10 meters u₁₀, and use a drag coefficient cᴰ to estimate the kinematic stress (that is, stress divided by density) exerted by the wind on the ocean:","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"u₁₀ = 10     # m s⁻¹, average wind velocity 10 meters above the ocean\ncᴰ = 2.5e-3  # dimensionless drag coefficient\nρₐ = 1.225   # kg m⁻³, average density of air at sea-level\n\nQᵘ = - ρₐ / ρₒ * cᴰ * u₁₀ * abs(u₁₀) # m² s⁻²","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"The boundary conditions on u are thus","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"u_bcs = UVelocityBoundaryConditions(grid, top = FluxBoundaryCondition(Qᵘ))","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"For salinity, S, we impose an evaporative flux of the form","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"@inline Qˢ(x, y, t, S, evaporation_rate) = - evaporation_rate * S\nnothing # hide","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"where S is salinity. We use an evporation rate of 1 millimeter per hour,","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"evaporation_rate = 1e-3 / hour","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We build the Flux evaporation BoundaryCondition with the function Qˢ, indicating that Qˢ depends on salinity S and passing the parameter evaporation_rate,","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"evaporation_bc = FluxBoundaryCondition(Qˢ, field_dependencies=:S, parameters=evaporation_rate)","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"The full salinity boundary conditions are","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"S_bcs = TracerBoundaryConditions(grid, top=evaporation_bc)","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#Model-instantiation","page":"Ocean wind mixing and convection","title":"Model instantiation","text":"","category":"section"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We fill in the final details of the model here: upwind-biased 5th-order advection for momentum and tracers, 3rd-order Runge-Kutta time-stepping, Coriolis forces, and the AnisotropicMinimumDissipation closure for large eddy simulation to model the effect of turbulent motions at scales smaller than the grid scale that we cannot explicitly resolve.","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"model = IncompressibleModel(architecture = CPU(),\n                            advection = UpwindBiasedFifthOrder(),\n                            timestepper = :RungeKutta3,\n                            grid = grid,\n                            coriolis = FPlane(f=1e-4),\n                            buoyancy = buoyancy,\n                            closure = AnisotropicMinimumDissipation(),\n                            boundary_conditions = (u=u_bcs, T=T_bcs, S=S_bcs))","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Notes:","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"To use the Smagorinsky-Lilly turbulence closure (with a constant model coefficient) rather than AnisotropicMinimumDissipation, use closure = ConstantSmagorinsky() in the model constructor.\nTo change the architecture to GPU, replace architecture = CPU() with architecture = GPU()`","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#Initial-conditions","page":"Ocean wind mixing and convection","title":"Initial conditions","text":"","category":"section"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Our initial condition for temperature consists of a linear stratification superposed with random noise damped at the walls, while our initial condition for velocity consists only of random noise.","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"# Random noise damped at top and bottom\nΞ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz) # noise\n\n# Temperature initial condition: a stable density gradient with random noise superposed.\nTᵢ(x, y, z) = 20 + dTdz * z + dTdz * model.grid.Lz * 1e-6 * Ξ(z)\n\n# Velocity initial condition: random noise scaled by the friction velocity.\nuᵢ(x, y, z) = sqrt(abs(Qᵘ)) * 1e-3 * Ξ(z)\n\n# `set!` the `model` fields using functions or constants:\nset!(model, u=uᵢ, w=uᵢ, T=Tᵢ, S=35)","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#Setting-up-a-simulation","page":"Ocean wind mixing and convection","title":"Setting up a simulation","text":"","category":"section"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We first build a TimeStepWizard to ensure stable time-stepping with a Courant-Freidrichs-Lewy (CFL) number of 1.0.","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"wizard = TimeStepWizard(cfl=1.0, Δt=10.0, max_change=1.1, max_Δt=1minute)","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Nice progress messaging is helpful:","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"start_time = time_ns() # so we can print the total elapsed wall time\n\n# Print a progress message\nprogress_message(sim) =\n    @printf(\"i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\\n\",\n            sim.model.clock.iteration, prettytime(model.clock.time),\n            prettytime(wizard.Δt), maximum(abs, sim.model.velocities.w),\n            prettytime((time_ns() - start_time) * 1e-9))","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We then set up the simulation:","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"simulation = Simulation(model, Δt=wizard, stop_time=40minutes, iteration_interval=10,\n                        progress=progress_message)","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#Output","page":"Ocean wind mixing and convection","title":"Output","text":"","category":"section"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We use the JLD2OutputWriter to save x z slices of the velocity fields, tracer fields, and eddy diffusivities. The prefix keyword argument to JLD2OutputWriter indicates that output will be saved in ocean_wind_mixing_and_convection.jld2.","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"# Create a NamedTuple with eddy viscosity\neddy_viscosity = (νₑ = model.diffusivities.νₑ,)\n\nsimulation.output_writers[:slices] =\n    JLD2OutputWriter(model, merge(model.velocities, model.tracers, eddy_viscosity),\n                           prefix = \"ocean_wind_mixing_and_convection\",\n                     field_slicer = FieldSlicer(j=Int(grid.Ny/2)),\n                         schedule = TimeInterval(1minute),\n                            force = true)","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We're ready:","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"run!(simulation)","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#Turbulence-visualization","page":"Ocean wind mixing and convection","title":"Turbulence visualization","text":"","category":"section"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We animate the data saved in ocean_wind_mixing_and_convection.jld2. We prepare for animating the flow by creating coordinate arrays, opening the file, building a vector of the iterations that we saved data at, and defining functions for computing colorbar limits:","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"# Coordinate arrays\nxw, yw, zw = nodes(model.velocities.w)\nxT, yT, zT = nodes(model.tracers.T)\n\n# Open the file with our data\nfile = jldopen(simulation.output_writers[:slices].filepath)\n\n# Extract a vector of iterations\niterations = parse.(Int, keys(file[\"timeseries/t\"]))\n\n\"\"\" Returns colorbar levels equispaced between `(-clim, clim)` and encompassing the extrema of `c`. \"\"\"\nfunction divergent_levels(c, clim, nlevels=21)\n    cmax = maximum(abs, c)\n    levels = clim > cmax ? range(-clim, stop=clim, length=nlevels) : range(-cmax, stop=cmax, length=nlevels)\n    return (levels[1], levels[end]), levels\nend\n\n\"\"\" Returns colorbar levels equispaced between `clims` and encompassing the extrema of `c`.\"\"\"\nfunction sequential_levels(c, clims, nlevels=20)\n    levels = range(clims[1], stop=clims[2], length=nlevels)\n    cmin, cmax = minimum(c), maximum(c)\n    cmin < clims[1] && (levels = vcat([cmin], levels))\n    cmax > clims[2] && (levels = vcat(levels, [cmax]))\n    return clims, levels\nend","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We start the animation at t = 10minutes since things are pretty boring till then:","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"times = [file[\"timeseries/t/$iter\"] for iter in iterations]\nintro = searchsortedfirst(times, 10minutes)\n\nanim = @animate for (i, iter) in enumerate(iterations[intro:end])\n\n    @info \"Drawing frame $i from iteration $iter...\"\n\n    t = file[\"timeseries/t/$iter\"]\n    w = file[\"timeseries/w/$iter\"][:, 1, :]\n    T = file[\"timeseries/T/$iter\"][:, 1, :]\n    S = file[\"timeseries/S/$iter\"][:, 1, :]\n    νₑ = file[\"timeseries/νₑ/$iter\"][:, 1, :]\n\n    wlims, wlevels = divergent_levels(w, 2e-2)\n    Tlims, Tlevels = sequential_levels(T, (19.7, 19.99))\n    Slims, Slevels = sequential_levels(S, (35, 35.005))\n    νlims, νlevels = sequential_levels(νₑ, (1e-6, 5e-3))\n\n    kwargs = (linewidth=0, xlabel=\"x (m)\", ylabel=\"z (m)\", aspectratio=1,\n              xlims=(0, grid.Lx), ylims=(-grid.Lz, 0))\n\n    w_plot = contourf(xw, zw, w'; color=:balance, clims=wlims, levels=wlevels, kwargs...)\n    T_plot = contourf(xT, zT, T'; color=:thermal, clims=Tlims, levels=Tlevels, kwargs...)\n    S_plot = contourf(xT, zT, S'; color=:haline,  clims=Slims, levels=Slevels, kwargs...)\n\n    # We use a heatmap for the eddy viscosity to observe how it varies on the grid scale.\n    ν_plot = heatmap(xT, zT, νₑ'; color=:thermal, clims=νlims, levels=νlevels, kwargs...)\n\n    w_title = @sprintf(\"vertical velocity (m s⁻¹), t = %s\", prettytime(t))\n    T_title = \"temperature (ᵒC)\"\n    S_title = \"salinity (g kg⁻¹)\"\n    ν_title = \"eddy viscosity (m² s⁻¹)\"\n\n    # Arrange the plots side-by-side.\n    plot(w_plot, T_plot, S_plot, ν_plot, layout=(2, 2), size=(1200, 600),\n         title=[w_title T_title S_title ν_title])\n\n    iter == iterations[end] && close(file)\nend\n\nmp4(anim, \"ocean_wind_mixing_and_convection.mp4\", fps = 8) # hide","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"This page was generated using Literate.jl.","category":"page"},{"location":"model_setup/checkpointing/#Checkpointing","page":"Checkpointing","title":"Checkpointing","text":"","category":"section"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"A checkpointer can be used to serialize the entire model state to a file from which the model can be restored at any time. This is useful if you'd like to periodically checkpoint when running long simulations in case of crashes or cluster time limits, but also if you'd like to restore from a checkpoint and try out multiple scenarios.","category":"page"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"For example, to periodically checkpoint the model state to disk every 1,000,000 seconds of simulation time to files of the form model_checkpoint_iteration12500.jld2 where 12500 is the iteration number (automatically filled in)","category":"page"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"DocTestSetup = quote\n    using Oceananigans\nend","category":"page"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"julia> using Oceananigans, Oceananigans.Units\n\njulia> model = IncompressibleModel(grid=RegularRectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1)));\n\njulia> checkpointer = Checkpointer(model, schedule=TimeInterval(5years), prefix=\"model_checkpoint\")\nCheckpointer{TimeInterval,Array{Symbol,1}}(TimeInterval(1.5768e8, 0.0), \".\", \"model_checkpoint\", [:architecture, :grid, :clock, :coriolis, :buoyancy, :closure, :velocities, :tracers, :timestepper, :particles], false, false, false)","category":"page"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"The default options should provide checkpoint files that are easy to restore from in most cases. For more advanced options and features, see Checkpointer.","category":"page"},{"location":"model_setup/checkpointing/#Restoring-from-a-checkpoint-file","page":"Checkpointing","title":"Restoring from a checkpoint file","text":"","category":"section"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"To restore the model from a checkpoint file, for example model_checkpoint_12345.jld2, simply call","category":"page"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"model = restore_from_checkpoint(\"model_checkpoint_12345.jld2\")","category":"page"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"which will create a new model object that is identical to the one that was serialized to disk. You can continue time stepping after restoring from a checkpoint.","category":"page"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"You can pass additional parameters to the Model constructor. See restore_from_checkpoint for more information.","category":"page"},{"location":"model_setup/checkpointing/#Restoring-with-functions","page":"Checkpointing","title":"Restoring with functions","text":"","category":"section"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"JLD2 cannot serialize functions to disk. so if you used forcing functions, boundary conditions containing functions, or the model included references to functions then they will not be serialized to the checkpoint file. When restoring from a checkpoint file, any model property that contained functions must be manually restored via keyword arguments to restore_from_checkpoint.","category":"page"},{"location":"publications/#Papers-and-preprints-using-Oceananigans.jl","page":"Publications","title":"Papers and preprints using Oceananigans.jl","text":"","category":"section"},{"location":"publications/","page":"Publications","title":"Publications","text":"If you have work using Oceananigans.jl that you would like to have listed here, please open a pull request to add it or let us know!","category":"page"},{"location":"publications/","page":"Publications","title":"Publications","text":"Wagner, G. L., Chini, G. P., Ramadhan, A., Gallet, B., & Ferrari, R. (2021). Near-inertial waves and turbulence driven by the growth of swell, Journal of Physical Oceanography, 51(5), 1337-1351. DOI: 10.1175/JPO-D-20-0178.1\nBuffett, B. A. (2021). Conditions for turbulent Ekman layers in precessionally driven flow, Geophysical Journal International, 226, 1, pp. 56–65. DOI: 10.1093/gji/ggab088\nBhamidipati, N., Souza, A.N. & Flierl, G.R., (2020). Turbulent mixing of a passive scalar in the ocean mixed layer. Ocean Modelling, 149, 101615. DOI: 10.1016/j.ocemod.2020.101615\nSouza, A. N., Wagner, G. L., Ramadhan, A., Allen, B., Churavy, V., Schloss, J., Campin, J. M., Hill, C., Edelman, A., Marshall, J., Flierl, G., & Ferrari, R. (2020). Uncertainty quantification of ocean parameterizations: Application to the K‐Profile‐Parameterization for penetrative convection. Journal of Advances in Modeling Earth Systems, 12, e2020MS002108. DOI: 10.1029/2020MS002108","category":"page"},{"location":"model_setup/forcing_functions/#Forcing-functions","page":"Forcing functions","title":"Forcing functions","text":"","category":"section"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"\"Forcings\" are user-defined terms appended to right-hand side of the momentum or tracer evolution equations. In Oceananigans, momentum and tracer forcings are defined via julia functions. Oceananigans includes an interface for implementing forcing functions that depend on spatial coordinates, time, model velocity and tracer fields, and external parameters.","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"DocTestSetup = quote\n    using Oceananigans\nend","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"Forcings are added to Oceananigans models by passing a NamedTuple of functions or forcing objects to the forcing keyword argument in IncompressibleModel's constructor. By default, momentum and tracer forcing functions are assumed to be functions of x, y, z, t. A basic example is","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"u_forcing(x, y, z, t) = exp(z) * cos(x) * sin(t)\n\ngrid = RegularRectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))\nmodel = IncompressibleModel(grid=grid, forcing=(u=u_forcing,))\n\nmodel.forcing.u\n\n# output\nContinuousForcing{Nothing} at (Face, Center, Center)\n├── func: u_forcing\n├── parameters: nothing\n└── field dependencies: ()","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"More general forcing functions are built via the Forcing constructor described below. Oceananigans also provides a convenience type called Relaxation that specifies \"relaxation\", or damping terms that restore a field to a target distribution outside of a masked region of space. Relaxation can be used to implement sponge layers near the boundaries of a domain.","category":"page"},{"location":"model_setup/forcing_functions/#The-Forcing-constructor","page":"Forcing functions","title":"The Forcing constructor","text":"","category":"section"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"The Forcing constructor provides an interface for specifying forcing functions that","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"Depend on external parameters; and\nDepend on model fields at the x, y, z location that forcing is applied; and/or\nRequire access to discrete model data.","category":"page"},{"location":"model_setup/forcing_functions/#Forcing-functions-with-external-parameters","page":"Forcing functions","title":"Forcing functions with external parameters","text":"","category":"section"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"Most forcings involve external, changeable parameters. Here are two examples of forcing_functions that depend on  (i) a single scalar parameter s, and (ii) a NamedTuple of parameters, p:","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"# Forcing that depends on a scalar parameter `s`\nu_forcing_func(x, y, z, t, s) = s * z\n\nu_forcing = Forcing(u_forcing_func, parameters=0.1)\n\n# Forcing that depends on a `NamedTuple` of parameters `p`\nT_forcing_func(x, y, z, t, p) = - p.μ * exp(z / p.λ) * cos(p.k * x) * sin(p.ω * t)\n\nT_forcing = Forcing(T_forcing_func, parameters=(μ=1, λ=0.5, k=2π, ω=4π))\n\ngrid = RegularRectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))\nmodel = IncompressibleModel(grid=grid, forcing=(u=u_forcing, T=T_forcing))\n\nmodel.forcing.T\n\n# output\nContinuousForcing{NamedTuple{(:μ, :λ, :k, :ω),Tuple{Int64,Float64,Float64,Float64}}} at (Center, Center, Center)\n├── func: T_forcing_func\n├── parameters: (μ = 1, λ = 0.5, k = 6.283185307179586, ω = 12.566370614359172)\n└── field dependencies: ()","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"model.forcing.u\n\n# output\nContinuousForcing{Float64} at (Face, Center, Center)\n├── func: u_forcing_func\n├── parameters: 0.1\n└── field dependencies: ()","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"In this example, the objects passed to the parameters keyword in the construction of u_forcing and T_forcing –- a floating point number for u_forcing, and a NamedTuple of parameters for T_forcing –- are passed on to u_forcing_func and T_forcing_func when they are called during time-stepping. The object passed to parameters is in principle arbitrary. However, if using the GPU, then typeof(parameters) may be restricted by the requirements of GPU-compiliability.","category":"page"},{"location":"model_setup/forcing_functions/#Forcing-functions-that-depend-on-model-fields","page":"Forcing functions","title":"Forcing functions that depend on model fields","text":"","category":"section"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"Forcing functions may depend on model fields evaluated at the x, y, z where forcing is applied. Here's a somewhat non-sensical example:","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"# Forcing that depends on the velocity fields `u`, `v`, and `w`\nw_forcing_func(x, y, z, t, u, v, w) = - (u^2 + v^2 + w^2) / 2\n\nw_forcing = Forcing(w_forcing_func, field_dependencies=(:u, :v, :w))\n\n# Forcing that depends on salinity `S` and a scalar parameter\nS_forcing_func(x, y, z, t, S, μ) = - μ * S\n\nS_forcing = Forcing(S_forcing_func, parameters=0.01, field_dependencies=:S)\n\ngrid = RegularRectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))\nmodel = IncompressibleModel(grid=grid, forcing=(w=w_forcing, S=S_forcing))\n\nmodel.forcing.w\n\n# output\nContinuousForcing{Nothing} at (Center, Center, Face)\n├── func: w_forcing_func\n├── parameters: nothing\n└── field dependencies: (:u, :v, :w)","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"model.forcing.S\n\n# output\nContinuousForcing{Float64} at (Center, Center, Center)\n├── func: S_forcing_func\n├── parameters: 0.01\n└── field dependencies: (:S,)","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"The field_dependencies arguments follow x, y, z, t in the forcing function in the order they are specified in Forcing. If both field_dependencies and parameters are specified, then the field_dependencies arguments follow x, y, z, t, and parameters follow field_dependencies.","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"Model fields that arise in the arguments of continuous Forcing functions are automatically interpolated to the staggered grid location at which the forcing is applied.","category":"page"},{"location":"model_setup/forcing_functions/#\"Discrete-form\"-forcing-functions","page":"Forcing functions","title":"\"Discrete form\" forcing functions","text":"","category":"section"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"\"Discrete form\" forcing functions are either called with the signature","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"func(i, j, k, grid, clock, model_fields)","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"or the parameterized form","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"func(i, j, k, grid, clock, model_fields, parameters)","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"Discrete form forcing functions can access the entirety of model field data through the argument model_fields. The object model_fields is a NamedTuple whose properties include the velocity fields model_fields.u, model_fields.v, model_fields.w and all fields in model.tracers.","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"Using discrete forcing functions may require understanding the staggered arrangement of velocity fields and tracers in Oceananigans. Here's a slightly non-sensical example in which the vertical derivative of a buoyancy tracer is used as a time-scale for damping the u-velocity field:","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"# A damping term that depends on a \"local average\":\nlocal_average(i, j, k, grid, c) = @inbounds (c[i, j, k] + c[i-1, j, k] + c[i+1, j, k] +\n                                                          c[i, j-1, k] + c[i, j+1, k] +\n                                                          c[i, j, k-1] + c[i, j, k+1]) / 7\n\nb_forcing_func(i, j, k, grid, clock, model_fields) = - local_average(i, j, k, grid, model_fields.b)\n\nb_forcing = Forcing(b_forcing_func, discrete_form=true)\n\n# A term that damps the local velocity field in the presence of stratification\nusing Oceananigans.Operators: ∂zᵃᵃᶠ, ℑxzᶠᵃᶜ\n\nfunction u_forcing_func(i, j, k, grid, clock, model_fields, ε)\n    # The vertical derivative of buoyancy, interpolated to the u-velocity location:\n    N² = ℑxzᶠᵃᶜ(i, j, k, grid, ∂zᵃᵃᶠ, model_fields.b)\n\n    # Set to zero in unstable stratification where N² < 0:\n    N² = max(N², zero(typeof(N²)))\n\n    return @inbounds - ε * sqrt(N²) * model_fields.u[i, j, k]\nend\n\nu_forcing = Forcing(u_forcing_func, discrete_form=true, parameters=1e-3)\n\ngrid = RegularRectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))\nmodel = IncompressibleModel(grid=grid, tracers=:b, buoyancy=BuoyancyTracer(), forcing=(u=u_forcing, b=b_forcing))\n\nmodel.forcing.b\n\n# output\nDiscreteForcing{Nothing}\n├── func: b_forcing_func\n└── parameters: nothing","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"model.forcing.u\n\n# output\nDiscreteForcing{Float64}\n├── func: u_forcing_func\n└── parameters: 0.001","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"The annotation @inbounds is crucial for performance when accessing array indices of the fields in model_fields.","category":"page"},{"location":"model_setup/forcing_functions/#Relaxation","page":"Forcing functions","title":"Relaxation","text":"","category":"section"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"Relaxation defines a special forcing function that restores a field at a specified rate to a target distribution, within a region uncovered by a masking function. Relaxation is useful for implementing sponge layers, as shown in the second example.","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"The following code constructs a model in which all components of the velocity field are damped to zero everywhere on a time-scale of 1000 seconds, or ~17 minutes:","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"damping = Relaxation(rate = 1/1000)\n\ngrid = RegularRectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)) \nmodel = IncompressibleModel(grid=grid, forcing=(u=damping, v=damping, w=damping))\n\nmodel.forcing.w\n\n# output\nContinuousForcing{Nothing} at (Center, Center, Face)\n├── func: Relaxation(rate=0.001, mask=1, target=0)\n├── parameters: nothing\n└── field dependencies: (:w,)","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"The constructor for Relaxation accepts the keyword arguments mask, and target, which specify a mask(x, y, z) function that multiplies the forcing, and a target(x, y, z) distribution for the quantity in question. By default, mask uncovered the whole domain and target restores the field in question to 0","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"We illustrate usage of mask and target by implementing a sponge layer that relaxes velocity fields to zero and restores temperature to a linear gradient in the bottom 1/10th of the domain:","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"grid = RegularRectilinearGrid(size=(1, 1, 1), x=(0, 1), y=(0, 1), z=(-1, 0))\n\n        damping_rate = 1/100 # relax fields on a 100 second time-scale\ntemperature_gradient = 0.001 # ⁰C m⁻¹\n surface_temperature = 20    # ⁰C (at z=0)\n\ntarget_temperature = LinearTarget{:z}(intercept=surface_temperature, gradient=temperature_gradient)\n       bottom_mask = GaussianMask{:z}(center=-grid.Lz, width=grid.Lz/10)\n\nuvw_sponge = Relaxation(rate=damping_rate, mask=bottom_mask)\n  T_sponge = Relaxation(rate=damping_rate, mask=bottom_mask, target=target_temperature)\n\nmodel = IncompressibleModel(grid=grid, forcing=(u=uvw_sponge, v=uvw_sponge, w=uvw_sponge, T=T_sponge))\n\nmodel.forcing.u\n\n# output\nContinuousForcing{Nothing} at (Face, Center, Center)\n├── func: Relaxation(rate=0.01, mask=exp(-(z + 1.0)^2 / (2 * 0.1^2)), target=0)\n├── parameters: nothing\n└── field dependencies: (:u,)","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"model.forcing.T\n\n# output\nContinuousForcing{Nothing} at (Center, Center, Center)\n├── func: Relaxation(rate=0.01, mask=exp(-(z + 1.0)^2 / (2 * 0.1^2)), target=20.0 + 0.001 * z)\n├── parameters: nothing\n└── field dependencies: (:T,)","category":"page"},{"location":"numerical_implementation/finite_volume/#Finite-volume-method-on-a-staggered-grid","page":"Finite volume method","title":"Finite volume method on a staggered grid","text":"","category":"section"},{"location":"numerical_implementation/finite_volume/","page":"Finite volume method","title":"Finite volume method","text":"The Oceananigans.jl staggered grid is defined by a rectilinear array of cuboids of horizontal dimensions  Delta x_i j k Delta y_i j k and vertical dimension  Delta z_i j k, where (i j k) index the location of each cell in the staggered grid. Note that the indices (i j k) increase with increasing coordinate (x y z).","category":"page"},{"location":"numerical_implementation/finite_volume/","page":"Finite volume method","title":"Finite volume method","text":"(Image: Schematic of staggered grid) A schematic of Oceananigans.jl finite volumes for a two-dimensional staggered grid in (x z). Tracers c and pressure p are defined at the center of the control volume. The u control volumes are  centered on the left and right edges of the pressure control volume while the w control volumes are centered  on the top and bottom edges of the pressure control volumes. The indexing convention places the i^rmth  u-node on cell x-faces to the left of the i tracer point at cell centers.","category":"page"},{"location":"numerical_implementation/finite_volume/","page":"Finite volume method","title":"Finite volume method","text":"Dropping explicit indexing, the areas of cell faces are given by","category":"page"},{"location":"numerical_implementation/finite_volume/","page":"Finite volume method","title":"Finite volume method","text":"    A_x = Delta y Delta z quad A_y = Delta x Delta z quad A_z = Delta x Delta y  ","category":"page"},{"location":"numerical_implementation/finite_volume/","page":"Finite volume method","title":"Finite volume method","text":"so that each cell encloses a volume V = Delta x Delta y Delta z.","category":"page"},{"location":"numerical_implementation/finite_volume/","page":"Finite volume method","title":"Finite volume method","text":"A finite volume method discretizes a continuous quantity c by considering its average over a finite volume:","category":"page"},{"location":"numerical_implementation/finite_volume/","page":"Finite volume method","title":"Finite volume method","text":"    c_i j k equiv frac1V_i j k int c(boldsymbolx)  mathrmd V_i j k  ","category":"page"},{"location":"numerical_implementation/finite_volume/","page":"Finite volume method","title":"Finite volume method","text":"The finite volumes that discretize each of u, v, and w are located on a grid which is \"staggered\"  with respect to the grid that defines tracer finite volumes.  The nodes, or central points of the velocity finite volumes are co-located with the faces of the tracer  finite volume. In particular, the u-nodes are located in the center of the \"x-face\" (east of the tracer point),  v-nodes are located on y-faces south of the tracer point, and w-nodes are located on  z-faces downwards from the tracer point.","category":"page"},{"location":"installation_instructions/#Installation-instructions","page":"Installation instructions","title":"Installation instructions","text":"","category":"section"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"You can install the latest version of Oceananigans using the built-in package manager (accessed by pressing ] in the Julia command prompt) to add the package and instantiate/build all dependencies","category":"page"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"julia>]\n(v1.5) pkg> add Oceananigans\n(v1.5) pkg> instantiate","category":"page"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"We recommend installing Oceananigans with the built-in Julia package manager, because this installs a stable, tagged release. Oceananigans.jl can be updated to the latest tagged release from the package manager by typing","category":"page"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"(v1.5) pkg> update Oceananigans","category":"page"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"At this time, updating should be done with care, as Oceananigans is under rapid development and breaking changes to the user API occur often. But if anything does happen, please open an issue!","category":"page"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"But if anything does happen or your code stops working, please open an issue and ask! We're more than happy to help with getting your simulations up and running.","category":"page"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"warn: Use Julia 1.5 or newer\nOceananigans requires at least Julia v1.5 to run. Installing Oceananigans with an older version of Julia will install an older version of Oceananigans (the latest version compatible with your version of Julia).","category":"page"},{"location":"validation/stratified_couette_flow/#Stratified-Couette-flow","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"","category":"section"},{"location":"validation/stratified_couette_flow/","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"In regular plane Couette flow, a viscous fluid is situated between two infinite, parallel plates and usually the top plate moves at some constant velocity generating a linear velocity profile in steady state (§4.2-4.3) G. K. Batchelor  (2000).","category":"page"},{"location":"validation/stratified_couette_flow/","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"In stratified Couette flow, the plates are additionally held at fixed temperatures to provide a stable stratification. It is a canonical geometry in which to investigate the dynamics of stratified shear flows as it exhibits a transition to turbulence, intermittent turbulence, coherent structures, and diapycnal mixing among other rich behavior Qi Zhou , John R. Taylor , C. P. Caulfield  (2017).","category":"page"},{"location":"validation/stratified_couette_flow/","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"In this test we follow Catherine A. Vreugdenhil , John R. Taylor  (2018) who use stratified Couette flow as a test of their large-eddy simulation model. We will compare our results to theirs and the direct numerical simulation results of Enrico Deusebio , C. P. Caulfield , J. R. Taylor  (2015) and Qi Zhou , John R. Taylor , C. P. Caulfield  (2017).","category":"page"},{"location":"validation/stratified_couette_flow/#Simulation-setup","page":"Stratified Couette flow","title":"Simulation setup","text":"","category":"section"},{"location":"validation/stratified_couette_flow/","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"In our setup replicating that of Catherine A. Vreugdenhil , John R. Taylor  (2018), a domain of size (L_x L_y L_z)h = (4pi 2pi 2) is bounded in the vertical z-direction by two infinite, parallel plates or walls at z = pm h with horizontal velocity u = pm U_w and constant temperature theta = pm Theta_w where theta denotes temperature in this section. The resulting flow is governed by the Reynolds, Richardson, and Prandtl numbers","category":"page"},{"location":"validation/stratified_couette_flow/","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"textRe = fracU_w hnu quad\ntextRi = fracalpha g Theta_w hU_w^2 quad\ntextPr = fracnukappa  ","category":"page"},{"location":"validation/stratified_couette_flow/","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"where nu is the kinematic viscosity, kappa is the thermal diffusivity, alpha is the thermal expansion coefficient, and g is the gravitational acceleration.","category":"page"},{"location":"validation/stratified_couette_flow/","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"Defining horizontal averages for velocity U = langle u rangle and Theta = langle theta rangle we can define the friction velocity u_tau and friction temperature theta_tau at the wall by","category":"page"},{"location":"validation/stratified_couette_flow/","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"u_tau^2 = fractau_wrho_0\n         = nu leftvert fracpartial Upartial z rightvert_z = pm h quad\ntheta_tau = fracq_wu_tau\n            = frackappau_tau leftvert fracpartialThetapartial z rightvert_z = pm h  ","category":"page"},{"location":"validation/stratified_couette_flow/","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"where tau_w is the wall stress and q_w = u_tau theta_tau is the wall heat flux.","category":"page"},{"location":"validation/stratified_couette_flow/","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"From here the friction Reynolds number and the Nusselt number can be defined","category":"page"},{"location":"validation/stratified_couette_flow/","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"textRe_tau = fracu_tau hnu quad textNu = fracq_w hkappa Theta_w  ","category":"page"},{"location":"validation/stratified_couette_flow/","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"which can be computed and compared.","category":"page"},{"location":"validation/stratified_couette_flow/#Velocity-and-temperature","page":"Stratified Couette flow","title":"Velocity and temperature","text":"","category":"section"},{"location":"validation/stratified_couette_flow/","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"(Image: Velocity and temperature profiles) (Image: Velocity and temperature horizontal slices)","category":"page"},{"location":"validation/stratified_couette_flow/#\\mathrm{Re}_\\tau-and-\\mathrm{Nu}-values","page":"Stratified Couette flow","title":"mathrmRe_tau and mathrmNu values","text":"","category":"section"},{"location":"validation/stratified_couette_flow/","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"(Image: Re and Nu comparison plots) (Image: Re and Nu time series plots)","category":"page"},{"location":"validation/stratified_couette_flow/#LES-viscosity-and-diffusivity","page":"Stratified Couette flow","title":"LES viscosity and diffusivity","text":"","category":"section"},{"location":"validation/stratified_couette_flow/","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"(Image: LES profiles)","category":"page"},{"location":"numerical_implementation/poisson_solvers/#Poisson-solvers","page":"Poisson solvers","title":"Poisson solvers","text":"","category":"section"},{"location":"numerical_implementation/poisson_solvers/#The-elliptic-problem-for-the-pressure","page":"Poisson solvers","title":"The elliptic problem for the pressure","text":"","category":"section"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"The 3d non-hydrostatic pressure field is obtained by taking the divergence of the horizontal  component of the momentum equation and invoking the vertical component to yield an elliptic  Poisson equation for the non-hydrostatic kinematic pressure","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"   beginequation\n   labeleqpoisson-pressure\n   nabla^2phi_NH = fracnabla cdot boldsymbolu^nDelta t + boldsymbolnabla boldsymbolcdot boldsymbolG_boldsymbolu equiv mathscrF  \n   endequation","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"along with homogenous Neumann boundary conditions boldsymbolu cdot boldsymbolhatn = 0 (Neumann on phi for wall-bounded directions and periodic otherwise) and where mathscrF denotes the source term for the Poisson equation.","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"For hydrostatic problems the Poisson equation above only needs to be solved for the vertically integrated flow and the pressure field is a two dimensional term phi_S. In this case a fully three-dimensional solve  is not needed.","category":"page"},{"location":"numerical_implementation/poisson_solvers/#Direct-method","page":"Poisson solvers","title":"Direct method","text":"","category":"section"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"Discretizing elliptic problems that can be solved via a classical separation-of-variables approach, such as Poisson's equation, results in a linear system of equations M boldsymbolx = boldsymboly where M is a real symmetric matrix of block tridiagonal form. This allows for the matrix to be decomposed and solved efficiently, provided that the eigenvalues and eigenvectors of the blocks are known (§2) B. Buzbee , G. Golub , C. Nielson  (1970). In the case of Poisson's equation on a rectangle, R. W. Hockney  (1965) has taken advantage of the fact that the fast Fourier transform can be used to perform the matrix multiplication steps resulting in an even more efficient method. Ulrich Schumann , Roland A Sweet  (1988) describe the implementation of such an algorithm for Poisson's equation on a staggered grid with Dirichlet, Neumann, and periodic boundary conditions.","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"The method can be explained easily by taking the Fourier transform of both sides of \\eqref{eq:poisson-pressure} to yield","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"    beginequation\n    labeleqpoisson-spectral\n    -(k_x^2 + k_y^2 + k_z^2) widehatphi_NH = widehatmathscrF\n    quad implies quad\n    widehatphi_NH = - fracwidehatmathscrFk_x^2 + k_y^2 + k_z^2  \n    endequation","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"where widehatcdot denotes the Fourier component. Here k_x, k_y, and k_z are the wavenumbers. However, when solving the equation on a staggered grid we require a solution for phi_NH that is second-order accurate such that when when its Laplacian is computed, nabla^2phi_NH matches mathscrF to machine precision. This is crucial to ensure that the projection step in §\\ref{sec:fractional-step} works. To do this, the wavenumbers are replaced by eigenvalues lambda_x, lambda_y, and lambda_z satisfying the discrete form of Poisson's equation with appropriate boundary conditions. Thus, Poisson's equation's is diagonalized in Fourier space and the Fourier coefficients of the solution are easily solved for","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"widehatphi_NH(i j k) = - fracwidehatmathscrF(i j k)lambda^x_i + lambda^y_j + lambda^z_k  ","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"The eigenvalues are given by Ulrich Schumann , Roland A Sweet  (1988) and can also be tediously derived by plugging in the definition of the discrete Fourier transform into \\eqref{eq:poisson-spectral}:","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"beginalign\n    lambda^x_i = 4fracN_x^2L_x^2 sin^2 left  frac(i-1)piN_x  right  quad i=01 dotsN_x-1   \n    lambda^x_j = 4fracN_y^2L_y^2 sin^2 left  frac(j-1)piN_y  right  quad j=01 dotsN_y-1   \n    lambda^x_k = 4fracN_z^2L_z^2 sin^2 left  frac(k-1)pi2N_z right  quad k=01 dotsN_z-1  \nendalign","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"where lambda_x and lambda_y correspond to periodic boundary conditions in the horizontal and lambda_z to Neumann boundary conditions in the vertical.","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"There is also an ambiguity in the solution to Poisson's equation as it's only defined up to a constant. To resolve this we choose the solution with zero mean by setting the zeroth Fourier coefficient phi_000 (corresponding to k_x = k_y = k_z = 0) to zero. This also has the added benefit of discarding the zero eigenvalue so we don't divide by it.","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"The Fast Fourier transforms are computed using FFTW.jl [M. Frigo , S.G. Johnson  (1998) and M. Frigo , S.G. Johnson  (2005)] on the CPU and using the cuFFT library on the GPU. Along wall-bouded dimensions, the cosine transform is used. In particular, as the transforms are performed on a staggered grid, DCT-II (REDFT10) is used to perform the forward cosine transform and DCT-III (REDFT01) is used to perform the inverse cosine transform.","category":"page"},{"location":"numerical_implementation/poisson_solvers/#Direct-method-with-a-vertically-stretched-grid","page":"Poisson solvers","title":"Direct method with a vertically stretched grid","text":"","category":"section"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"Using Fourier transforms for all three dimensions results in a method requiring mathcalO(N log_2 N) operations where N is the total number of grid points. This algorithm can be made even more efficient by solving a tridiagonal system along one of the dimensions and utilizing cyclic reduction. This results in the Fourier analysis cyclic reduction or textFACR(ell) algorithm (with ell cyclic reduction steps) which requires only mathcalO(N log_2log_2 N) operations provided the optimal number of cyclic reduction steps is taken, which is ell = log_2 log_2 n where n is the number of grid points in the cyclic reduction dimension. The FACR algorithm was first developed by R. W. Hockney  (1969) and is well reviewed by Paul N. Swarztrauber  (1977) then further benchmarked and extended by Clive Temperton  (1979) and Clive Temperton  (1980).","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"Furthermore, the FACR algorithm removes the restriction that the grid is uniform in one of the dimensions so it can be utilized to implement a fast Poisson solver for vertically stretched grids if the cyclic reduction is applied in the along the vertical dimension.","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"Expanding phi_NH and mathscrF into Fourier modes along the x and y directions","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"phi_ijk = sum_m=1^N_x sum_n=1^N_y tildephi_mnk  e^-mathrmi 2pi i m  N_x   e^-mathrmi 2pi j n  N_y  ","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"and recalling that Fourier transforms do partial_x rightarrow mathrmi k_x and partial_y rightarrow mathrmi k_y we can write \\eqref{eq:poisson-pressure} as","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"sum_m=1^N_x sum_n=1^N_y\nleftlbrace\n    partial_z^2 tildephi_mnk - (k_x^2 + k_y^2) tildephi_mnk - tildemathscrF_mnk\nrightrbrace e^-mathrmi 2 pi i m  N_x  e^-mathrmi 2 pi j n  N_y = 0  ","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"Discretizing the partial_z^2 derivative and equating the term inside the brackets to zero we arrive at N_xtimes N_y symmetric tridiagonal systems of N_z linear equations for the Fourier modes:","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"fractildephi_mnk-1Delta z^C_k\n- leftlbrace frac1Delta z^C_k + frac1Delta z^C_k+1 + Delta z^F_k (k_x^2 + k_y^2) rightrbrace\n  tildephi_mnk\n+ fractildephi_mnk+1Delta z^C_k+1\n= Delta z^F_k tildemathscrF_mnk  ","category":"page"},{"location":"numerical_implementation/poisson_solvers/#Cosine-transforms-on-the-GPU","page":"Poisson solvers","title":"Cosine transforms on the GPU","text":"","category":"section"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"Unfortunately cuFFT does not provide cosine transforms and so we must write our own fast cosine transforms for the GPU. We implemented the fast 1D and 2D cosine transforms described by J. Makhoul  (1980) which compute it by applying the regular Fourier transform to a permuted version of the array.","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"In this section we will be using the DCT-II as the definition of the forward cosine transform for a real signal of length N","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"    beginequation\n    labeleqFCT\n    textDCT(X) quad Y_k = 2 sum_j=0^N-1 cos left fracpi(j + frac12)kN right X_j  \n    endequation","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"and the DCT-III as the definition of the inverse cosine transform","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"    beginequation\n    labeleqIFCT\n    textIDCT(X) quad Y_k = X_0 + 2 sum_j=1^N-1 cos left fracpi j (k + frac12)N right X_j  \n    endequation  ","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"and will use omega_M = e^-2 pi mathrmi  M to denote the M^textth root of unity, sometimes called the twiddle factors in the context of FFT algorithms.","category":"page"},{"location":"numerical_implementation/poisson_solvers/#D-fast-cosine-transform","page":"Poisson solvers","title":"1D fast cosine transform","text":"","category":"section"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"To calculate \\eqref{eq:FCT} using the fast Fourier transform, we first permute the input signal along the appropriate dimension by ordering the odd elements first followed by the even elements to produce a permuted signal","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"    X^prime_n =\n    begincases\n        displaystyle X_2N quad 0 le n le left fracN-12 right   \n        displaystyle X_2N - 2n - 1 quad left fracN+12 right le n le N-1  \n    endcases","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"where a indicates the integer part of a. This should produce, for example,","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"    beginequation\n    labeleqpermutation\n    (a b c d e f g h) quad rightarrow quad (a c e g h f d b)  \n    endequation","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"after which \\eqref{eq:FCT} is computed using","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"  Y = textDCT(X) = 2 textRe leftlbrace omega_4N^k textFFT lbrace X^prime rbrace rightrbrace  ","category":"page"},{"location":"numerical_implementation/poisson_solvers/#D-fast-inverse-cosine-transform","page":"Poisson solvers","title":"1D fast inverse cosine transform","text":"","category":"section"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"The inverse \\eqref{eq:IFCT} can be computed using","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"  Y = textIDCT(X) = textRe leftlbrace omega_4N^-k textIFFT lbrace X rbrace rightrbrace  ","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"after which the inverse permutation of \\eqref{eq:permutation} must be applied.","category":"page"},{"location":"numerical_implementation/poisson_solvers/#D-fast-cosine-transform-2","page":"Poisson solvers","title":"2D fast cosine transform","text":"","category":"section"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"Unfortunately, the 1D algorithm cannot be applied dimension-wise so the 2D algorithm is  more complicated. Thankfully though, the permutation \\eqref{eq:permutation} can be applied dimension-wise. The forward cosine transform for a real signal of length N_1 times N_2 is then given by","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"Y_k_1 k_2 = textDCT(X_n_1 n_2) =\n2 textRe leftlbrace\n    omega_4N_1^k left( omega_4N_2^k tildeX + omega_4N_2^-k tildeX^- right)\nrightrbrace  ","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"where tildeX = textFFT(X^prime) and tildeX^- indicates that tildeX is indexed in reverse.","category":"page"},{"location":"numerical_implementation/poisson_solvers/#D-fast-inverse-cosine-transform-2","page":"Poisson solvers","title":"2D fast inverse cosine transform","text":"","category":"section"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"The inverse can be computed using","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"Y_k_1 k_2 = textIDCT(X_n_1 n_2) =\nfrac14 textRe leftlbrace\n    omega_4N_1^-k omega_4N_2^-k\n    left( tildeX - M_1 M_2 tildeX^-- right)\n    - mathrmi left( M_1 tildeX^-+ + M_2 tildeX^+- right)\nrightrbrace  ","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"where tildeX = textIFFT(X) here, tildeX^-+ is indexed in reverse along the first dimension, tildeX^-+ along the second dimension, and tildeX^-- along both. M_1 and M_2 are masks of lengths N_1 and N_2 respectively, both containing ones except at the first element where M_0 = 0. Afterwards, the inverse permutation of \\eqref{eq:permutation} must be applied.","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"Due to the extra steps involved in calculating the cosine transform in 2D, running with two wall-bounded dimensions typically slows the model down by a factor of 2. Switching to the FACR algorithm may help here as a 2D cosine transform won't be necessary anymore.","category":"page"},{"location":"numerical_implementation/poisson_solvers/#Iterative-Solvers","page":"Poisson solvers","title":"Iterative Solvers","text":"","category":"section"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"For problems with irregular grids the eigenvectors of the discrete Poisson operator are no longer simple Fourier series sines and cosines. This means discrete Fast Fourier Transforms can't be used to generate the projection  of the equation right hand side onto eigenvectors. So an eigenvector based approach to solving the Poisson equation is not computationally efficient.","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"An pre-conditioned conjugate gradient iterative solver is used instead for problems with grids that are non uniform in multiple directions. This includes curvilinear grids on the sphere and also telescoping cartesian grids that stretch along more than one dimension. There are two forms  of the pressure operator in this approach. One is rigid lid form and one is an implicit  free-surface form.","category":"page"},{"location":"numerical_implementation/poisson_solvers/#Rigid-lid-pressure-operator","page":"Poisson solvers","title":"Rigid lid pressure operator","text":"","category":"section"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"The rigid lid operator is based on the same continuous form as is used in the Direct Method solver.","category":"page"},{"location":"numerical_implementation/poisson_solvers/#Implicit-free-surface-pressure-operator","page":"Poisson solvers","title":"Implicit free surface pressure operator","text":"","category":"section"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"The implicit free surface solver solves for the free-surface, eta, in the vertically integrated continuity equation","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"    beginequation\n    labeleqvertically-integrated-continuity\n    partial_t eta + partial_x H hatu + partial_y H hatv = M  \n    endequation","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"where M is some surface volume flux (e.g terms such as precipitation, evaporation and runoff),  currently M=0 is assumed. To form a linear system that can be solved implicitly we recast the continuity equation into a discrete integral form","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"    beginequation\n    labeleqsemi-discrete-integral-continuity\n    A_z partial_t eta + delta_x^caasum_k A_x u +delta_y^caasum_k A_y v = A_z M  \n    endequation","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"and apply the discrete form to the hydrostatic form of the velocity fractional step equation","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"    beginequation\n    labeleqhydrostatic-fractional-step\n    boldsymbolu^n+1 = boldsymbolu^star - gDelta t boldsymbolnabla eta^n+1  \n    endequation","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"as follows.","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"Assuming M=0 (for now), for the n+1 timestep velocity we want the following to hold","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"    A_zfraceta^n+1-eta^nDelta t=-delta_x^caasum_k A_x u^n+1 - delta_y^caasum_k A_y v^n+1  ","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"substituting for u^n+1 and v^n+1 from the discrete form of the  right-hand-side of \\eqref{eq:hydrostatic-fractional-step} then gives an implicit equation for eta^n+1.","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"beginalign\n   delta_x^caasum_k A_x partial_x^faaeta^n+1  + delta_y^acasum_k A_y partial_y^afaeta^n+1 - frac1gDelta t^2A_z eta^n+1 = \n    = frac1g Delta tleft( delta_x^caasum_k A_x u^star + delta_y^acasum_k A_y v^star right) - frac1gDelta t^2A_z eta^n  \nendalign","category":"page"},{"location":"numerical_implementation/poisson_solvers/","page":"Poisson solvers","title":"Poisson solvers","text":"Formulated in this way, the linear operator will be symmetric and so can be solved using a preconditioned conjugate  gradient algorithmn.","category":"page"},{"location":"using_gpus/#Using-GPUs","page":"Using GPUs","title":"Using GPUs","text":"","category":"section"},{"location":"using_gpus/","page":"Using GPUs","title":"Using GPUs","text":"A big feature of Oceananigans is being able to run on graphical processing units (GPUs) for increased performance. Depending on your CPU and GPU combination, speedups of >150x are possible, for example on Google Cloud where running on GPUs is more cost-effective. See the performance benchmarks for more details.","category":"page"},{"location":"using_gpus/","page":"Using GPUs","title":"Using GPUs","text":"See Architecture for instructions on setting up a model on a GPU.","category":"page"},{"location":"using_gpus/","page":"Using GPUs","title":"Using GPUs","text":"Oceananigans does not yet support distributed parallelism (multi-CPU or multi-GPU).","category":"page"},{"location":"using_gpus/","page":"Using GPUs","title":"Using GPUs","text":"tip: Running on GPUs\nIf you are having issues with running Oceananigans on a GPU or setting things up, please open an issue and we'll do our best to help out!","category":"page"},{"location":"using_gpus/#When-to-use-a-GPU","page":"Using GPUs","title":"When to use a GPU","text":"","category":"section"},{"location":"using_gpus/","page":"Using GPUs","title":"Using GPUs","text":"GPUs are very useful for running large simulations. If your simulation uses over 1,000,000 grid points, you will probably benefit significantly from running your simulation on a GPU.","category":"page"},{"location":"using_gpus/","page":"Using GPUs","title":"Using GPUs","text":"GPU simulations tend to be memory-limited. That is, you'll probably fill the GPU's memory long before the model becomes unbearably slow. High-end GPUs such as the Nvidia Tesla V100 only come with up to 32 GB of memory. On a GPU with 16 GB of memory, you can run a simulation (with 2 tracers) with up to ~50 million grid points.","category":"page"},{"location":"using_gpus/#Getting-access-to-GPUs","page":"Using GPUs","title":"Getting access to GPUs","text":"","category":"section"},{"location":"using_gpus/","page":"Using GPUs","title":"Using GPUs","text":"If you don't have a GPU there are a few resources you can try to acquire a GPU from.","category":"page"},{"location":"using_gpus/","page":"Using GPUs","title":"Using GPUs","text":"In general, to get good performance you'll want a GPU with good 64-bit floating point performance although Oceananigans can be used with 32-bit floats. Most recent gaming GPUs should work but might have poor 64-bit float performance.","category":"page"},{"location":"using_gpus/","page":"Using GPUs","title":"Using GPUs","text":"If you have access to any supercomputer clusters, check to see if they have any GPUs. See also this Stack Overflow post: Where can I get access to GPU cluster for educational purpose?","category":"page"},{"location":"using_gpus/","page":"Using GPUs","title":"Using GPUs","text":"Cloud computing providers such as Google Cloud and Amazon EC2 allow you to rent GPUs per hour. Sometimes they offer free trials or credits that can be used towards GPUs although they seem to be getting less common.","category":"page"},{"location":"using_gpus/","page":"Using GPUs","title":"Using GPUs","text":"See the Julia on Google Colab: Free GPU-Accelerated Shareable Notebooks post on the Julia Discourse.","category":"page"},{"location":"using_gpus/","page":"Using GPUs","title":"Using GPUs","text":"Code Ocean also has GPU support and allows you to spin up capsules with pretty decent Tesla K80 GPUs for free (for now) if you want to play around with them. They may not be powerful enough for huge simulations though. You'll want to use their \"Ubuntu Linux with GPU support (18.04.3)\" with the ability to compile CUDA code. Then you'll have to install Julia manually.","category":"page"},{"location":"using_gpus/#I-have-a-GPU.-Now-what?","page":"Using GPUs","title":"I have a GPU. Now what?","text":"","category":"section"},{"location":"using_gpus/","page":"Using GPUs","title":"Using GPUs","text":"Make sure you have an Nvidia GPU that is CUDA compatible: https://developer.nvidia.com/cuda-gpus. Most recent GPUs should be but older GPUs and many laptop GPUs may not be.","category":"page"},{"location":"using_gpus/","page":"Using GPUs","title":"Using GPUs","text":"Then download and install the CUDA Toolkit: https://developer.nvidia.com/cuda-downloads","category":"page"},{"location":"using_gpus/","page":"Using GPUs","title":"Using GPUs","text":"Once the CUDA Toolkit is installed, you might have to build Oceananigans again","category":"page"},{"location":"using_gpus/","page":"Using GPUs","title":"Using GPUs","text":"julia>]\n(v1.5) pkg> build Oceananigans","category":"page"},{"location":"using_gpus/","page":"Using GPUs","title":"Using GPUs","text":"The ocean wind mixing and convection example is a good one to test out on the GPU.","category":"page"},{"location":"simulation_tips/#Simulation-tips","page":"Simulation tips","title":"Simulation tips","text":"","category":"section"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"In Oceananigans we try to do most of the optimizing behind the scenes, that way the average user doesn't have to worry about details when setting up a simulation. However, there's just so much optimization that can be done in the source code. Because of Oceananigans script-based interface, the user has to be aware of some things when writing the simulation script in order to take full advantage of Julia's speed. Furthermore, in case of more complex GPU runs, some details could sometimes prevent your simulation from running altogether. While Julia knowledge is obviously desirable here, a user that is unfamiliar with Julia can get away with efficient simulations by learning a few rules of thumb. It is nonetheless recommended that users go through Julia's performance tips, which contains more in-depth explanations of some of the aspects discussed here.","category":"page"},{"location":"simulation_tips/#General-(CPU/GPU)-simulation-tips","page":"Simulation tips","title":"General (CPU/GPU) simulation tips","text":"","category":"section"},{"location":"simulation_tips/#Avoid-global-variables-whenever-possible","page":"Simulation tips","title":"Avoid global variables whenever possible","text":"","category":"section"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"In general using a global variable (which can be loosely defined as a variable defined in the main script) inside functions slows down the code. One way to circumvent this is to always use local variables or pass them as arguments to functions. This helps the compiler optimize the code.","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Another way around this is to define global variables as constants whenever possible. One thing to keep in mind when doing this is that when a const is defined, its value can't be changed until you restart the Julia session. So this latter approach is good for production-ready code, but may be undesirable in the early stages of development while you still have to change the parameters of the simulation for exploration.","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"It is especially important to avoid global variables in functions that are meant to be executed in GPU kernels (such as functions defining boundary conditions and forcings). Otherwise the Julia GPU compiler can fail with obscure errors. This is explained in more detail in the GPU simulation tips section below.","category":"page"},{"location":"simulation_tips/#Consider-inlining-small-functions","page":"Simulation tips","title":"Consider inlining small functions","text":"","category":"section"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Inlining is when the compiler replaces a function call with the body of the function that is being called before compiling. The advantage of inlining (which in julia can be done with the @inline macro) is that gets rid of the time spent calling the function. The Julia compiler automatically makes some calls as to what functions it should or shouldn't inline, but you can force a function to be inlined by including the macro @inline before its definition. This is more suited for small functions that are called often. Here's an example of an implementation of the Heaviside function that forces it to be inlined:","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"@inline heaviside(X) = ifelse(X < 0, zero(X), one(X))","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"In practice it's hard to say whether inlining a function will bring runtime benefits with certainty, since Julia and KernelAbstractions.jl (needed for GPU runs) already inline some functions automatically. However, it is generally a good idea to at least investigate this aspect in your code as the benefits can potentially be significant.","category":"page"},{"location":"simulation_tips/#GPU-simulation-tips","page":"Simulation tips","title":"GPU simulation tips","text":"","category":"section"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Running on GPUs can be very different from running on CPUs. Oceananigans makes most of the necessary changes in the background, so that for very simple simulations changing between CPUs and GPUs is just a matter of changing the architecture argument in the model from CPU() to GPU(). However, for more complex simulations some care needs to be taken on the part of the user. While knowledge of GPU computing (and Julia) is again desirable, an inexperienced user can also achieve high efficiency in GPU simulations by following a few simple principles.","category":"page"},{"location":"simulation_tips/#Variables-that-need-to-be-used-in-GPU-computations-need-to-be-defined-as-constants","page":"Simulation tips","title":"Variables that need to be used in GPU computations need to be defined as constants","text":"","category":"section"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Any global variable that needs to be accessed by the GPU needs to be a constant or the simulation will crash. This includes any variables used in forcing functions and boundary conditions. For example, if you define a boundary condition like the example below and run your simulation on a GPU you'll get an error.","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"dTdz = 0.01 # K m⁻¹\nT_bcs = TracerBoundaryConditions(grid,\n                                 bottom = GradientBoundaryCondition(dTdz))","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"However, if you define dTdz as a constant by replacing the first line with const dTdz = 0.01, then (provided everything else is done properly) your run will be successful.","category":"page"},{"location":"simulation_tips/#Complex-diagnostics-using-ComputedFields-may-not-work-on-GPUs","page":"Simulation tips","title":"Complex diagnostics using ComputedFields may not work on GPUs","text":"","category":"section"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"ComputedFields are the most convenient way to calculate diagnostics for your simulation. They will always work on CPUs, but when their complexity is high (in terms of number of abstract operations) the compiler can't translate them into GPU code and they fail for GPU runs. (This limitation is discussed  in this Github issue and contributors are welcome.) For example, in the example below, calculating u² works in both CPUs and GPUs, but calculating  ε will not compile on GPUs when we call the command compute!:","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"u, v, w = model.velocities\nν = model.closure.ν\nu² = ComputedField(u^2)\nε = ComputedField(ν*(∂x(u)^2 + ∂x(v)^2 + ∂x(w)^2 + ∂y(u)^2 + ∂y(v)^2 + ∂y(w)^2 + ∂z(u)^2 + ∂z(v)^2 + ∂z(w)^2))\ncompute!(u²)\ncompute!(ε)","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"There are two approaches to  bypass this issue. The first is to nest ComputedFields. For example, we can make KE be successfully computed on GPUs by defining it as","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"ddx² = ComputedField(∂x(u)^2 + ∂x(v)^2 + ∂x(w)^2)\nddy² = ComputedField(∂y(u)^2 + ∂y(v)^2 + ∂y(w)^2)\nddz² = ComputedField(∂z(u)^2 + ∂z(v)^2 + ∂z(w)^2)\nε = ComputedField(ν*(ddx² + ddy² + ddz²))\ncompute!(ε)","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"This is a simple workaround that is especially suited for the development stage of a simulation. However, when running this, the code will iterate over the whole domain 4 times to calculate ε (one for each computed field defined), which is not very efficient.","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"A different way to calculate ε is by using KernelComputedFields, where the user manually specifies the computing kernel to the compiler. The advantage of this method is that it's more efficient (the code will only iterate once over the domain in order to calculate ε), but the disadvantage is that this requires that the has some knowledge of Oceananigans operations and how they should be performed on a C-grid. For example calculating ε with this approach would look like this:","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"using Oceananigans.Operators\nusing KernelAbstractions: @index, @kernel\nusing Oceananigans.Grids: Center, Face\nusing Oceananigans.Fields: KernelComputedField\n\n@inline fψ_plus_gφ²(i, j, k, grid, f, ψ, g, φ) = @inbounds (f(i, j, k, grid, ψ) + g(i, j, k, grid, φ))^2\n@kernel function isotropic_viscous_dissipation_rate_ccc!(ϵ, grid, u, v, w, ν)\n    i, j, k = @index(Global, NTuple)\n\n    Σˣˣ² = ∂xᶜᵃᵃ(i, j, k, grid, u)^2\n    Σʸʸ² = ∂yᵃᶜᵃ(i, j, k, grid, v)^2\n    Σᶻᶻ² = ∂zᵃᵃᶜ(i, j, k, grid, w)^2\n\n    Σˣʸ² = ℑxyᶜᶜᵃ(i, j, k, grid, fψ_plus_gφ², ∂yᵃᶠᵃ, u, ∂xᶠᵃᵃ, v) / 4\n    Σˣᶻ² = ℑxzᶜᵃᶜ(i, j, k, grid, fψ_plus_gφ², ∂zᵃᵃᶠ, u, ∂xᶠᵃᵃ, w) / 4\n    Σʸᶻ² = ℑyzᵃᶜᶜ(i, j, k, grid, fψ_plus_gφ², ∂zᵃᵃᶠ, v, ∂yᵃᶠᵃ, w) / 4\n\n    @inbounds ϵ[i, j, k] = ν[i, j, k] * 2 * (Σˣˣ² + Σʸʸ² + Σᶻᶻ² + 2 * (Σˣʸ² + Σˣᶻ² + Σʸᶻ²))\nend\nε = KernelComputedField(Center, Center, Center, isotropic_viscous_dissipation_rate_ccc!, model;\n                         computed_dependencies=(u, v, w, ν))","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"It may be useful to know that there are some kernels already defined for commonly-used diagnostics in packages that are companions to Oceananigans. For example Oceanostics.jl and LESbrary.jl. Users should first look there before writing any kernel by hand and are always welcome to start an issue on Github if they need help to write a different kernel.","category":"page"},{"location":"simulation_tips/#Try-to-decrease-the-memory-use-of-your-runs","page":"Simulation tips","title":"Try to decrease the memory-use of your runs","text":"","category":"section"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"GPU runs are generally memory-limited. As an example, a state-of-the-art Tesla V100 GPU has 32GB of memory, which is enough to fit, on average, a simulation with about 100 million points –- a bit smaller than a 512-cubed simulation. (The precise number depends on many other things, such as the number of tracers simulated, as well as the diagnostics that are calculated.) This means that it is especially important to be mindful of the size of your runs when running Oceananigans on GPUs and it is generally good practice to decrease the memory required for your runs. Below are some useful tips to achieve this","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Use the nvidia-smi command line utility to monitor the memory usage of the GPU. It should tell you how much memory there is on your GPU and how much of it you're using.\nTry to use higher-order advection schemes. In general when you use a higher-order scheme you need fewer grid points to achieve the same accuracy that you would with a lower-order one. Oceananigans provides two high-order advection schemes: 5th-order WENO method (WENO5) and 3rd-order upwind.\nManually define scratch space to be reused in diagnostics. By default, every time a user-defined diagnostic is calculated the compiler reserves a new chunk of memory for that calculation, usually called scratch space. In general, the more diagnostics, the more scratch space needed and the bigger the memory requirements. However, if you explicitly create a scratch space and pass that same scratch space for as many diagnostics as you can, you minimize the memory requirements of your calculations by reusing the same memory chunk. As an example, you can see scratch space being created here and then being used in calculations here.","category":"page"},{"location":"simulation_tips/#Arrays-in-GPUs-are-usually-different-from-arrays-in-CPUs","page":"Simulation tips","title":"Arrays in GPUs are usually different from arrays in CPUs","text":"","category":"section"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"On the CPU Oceananigans.jl uses regular Arrays, but on the GPU it has to use CuArrays from the CUDA.jl package. While deep down both are arrays, their implementations are different and both can behave very differently. Something to keep in mind when working with CuArrays is that you do not want to access elements of a CuArray outside of a kernel. Doing so invokes scalar operations in which individual elements are copied from or to the GPU for processing. This is very slow and can result in huge slowdowns. For this reason, Oceananigans.jl disables CUDA scalar operations by default. See the scalar indexing section of the CUDA.jl documentation for more information on scalar indexing.","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"For example if can be difficult to just view a CuArray since Julia needs to access  its elements to do that. Consider the example below:","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"julia> using Oceananigans; using Adapt\n\njulia> grid = RegularRectilinearGrid(size=(1,1,1), extent=(1,1,1))\nRegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}\n                   domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]\n                 topology: (Periodic, Periodic, Bounded)\n  resolution (Nx, Ny, Nz): (1, 1, 1)\n   halo size (Hx, Hy, Hz): (1, 1, 1)\ngrid spacing (Δx, Δy, Δz): (1.0, 1.0, 1.0)\n\njulia> model = IncompressibleModel(grid=grid, architecture=GPU())\nIncompressibleModel{GPU, Float64}(time = 0 seconds, iteration = 0) \n├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1)\n├── tracers: (:T, :S)\n├── closure: IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}}\n├── buoyancy: SeawaterBuoyancy{Float64,LinearEquationOfState{Float64},Nothing,Nothing}\n└── coriolis: Nothing\n\njulia> typeof(model.velocities.u.data)\nOffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}\n\njulia> adapt(Array, model.velocities.u.data)\n3×3×3 OffsetArray(::Array{Float64,3}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2×0:2×0:2:\n[:, :, 0] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n[:, :, 1] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n[:, :, 2] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Notice that in order to view the CuArray that stores values for u we needed to transform it into a regular Array first using Adapt.adapt. If we naively try to view the CuArray without that step we get an error:","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"julia> model.velocities.u.data\n3×3×3 OffsetArray(::CUDA.CuArray{Float64,3}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2×0:2×0:2:\n[:, :, 0] =\nError showing value of type OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}:\nERROR: scalar getindex is disallowed","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Here CUDA.jl throws an error because scalar getindex is not allowed. Another way around  this limitation is to allow scalar operations on CuArrays. We can temporarily do that with the CUDA.@allowscalar macro or by calling CUDA.allowscalar(true).","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"julia> using CUDA; CUDA.allowscalar(true)\n\njulia> model.velocities.u.data\n3×3×3 OffsetArray(::CuArray{Float64,3}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2×0:2×0:2:\n[:, :, 0] =\n┌ Warning: Performing scalar operations on GPU arrays: This is very slow, consider disallowing these operations with `allowscalar(false)`\n└ @ GPUArrays ~/.julia/packages/GPUArrays/WV76E/src/host/indexing.jl:43\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n[:, :, 1] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n[:, :, 2] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Notice the warning we get when we do this. Scalar operations on GPUs can be very slow, so it is advised to only use this last method when using the REPL or prototyping –- never in production-ready scripts.","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"You might also need to keep these differences in mind when using arrays to define initial conditions, boundary conditions or forcing functions on a GPU. To learn more about working with CuArrays, see the array programming section of the CUDA.jl documentation.","category":"page"},{"location":"physics/surface_gravity_waves/#Surface-gravity-waves-and-the-Craik-Leibovich-approximation","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"","category":"section"},{"location":"physics/surface_gravity_waves/","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"In Oceananiagns.jl, users model the effects of surface waves by specifying spatial and temporal gradients of the Stokes drift velocity field. At the moment, only uniform unidirectional Stokes drift fields are supported, in which case","category":"page"},{"location":"physics/surface_gravity_waves/","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"    boldsymbolu^S = u^S(z t) hatboldsymbolx + v^S(z t) hatboldsymboly  ","category":"page"},{"location":"physics/surface_gravity_waves/","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"Surface waves are modeled in Oceananigans.jl by the Craik-Leibovich approximation, which governs interior motions under a surface gravity wave field that have been time- or phase-averaged over the rapid oscillations of the surface waves. The oscillatory vertical and horizontal motions associated with surface waves themselves, therefore, are not present in the resolved velocity field boldsymbolu, and only the  steady, averaged effect of surface waves that manifests over several or more wave oscillations  are modeled.","category":"page"},{"location":"physics/surface_gravity_waves/","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"In Oceananigans.jl with surface waves, the resolved velocity field boldsymbolu is the  Lagrangian-mean velocity field. The Lagrangian-mean velocity field at a particular location  (x y z) is average velocity of a fluid particle whose average position is (x y z)  at time t. The average position of a fluid particle boldsymbolxi(t) = (xi eta zeta)  is thus governed by","category":"page"},{"location":"physics/surface_gravity_waves/","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"    partial_t boldsymbolxi + boldsymbolu(boldsymbolxi t) boldsymbolcdot boldsymbolnabla boldsymbolxi = boldsymbolu(boldsymbolxi t)  ","category":"page"},{"location":"physics/surface_gravity_waves/","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"which is the same relationship that holds when surface waves are not present and boldsymbolu  ceases to be an averaged velocity field. The simplicity of the governing equations for Lagrangian-mean  momentum is the main reason we use a Lagrangian-mean formulation in Oceananigans.jl, rather  than an Eulerian-mean formulation: for example, the tracer conservation equation is unchanged  by the inclusion of surface wave effects. Moreover, because the effect of surface waves manifests  either as a bulk forcing of Lagrangian-mean momentum or as a modification to the effective background  rotation rate of the interior fluid similar to any bulk forcing or Coriolis force, we do not  explicitly include the effects of surface waves in turbulence closures that model the effects  of subgrid turbulence. More specifically, the effect of steady surface waves does not effect  the conservation of Lagrangian-mean turbulent kinetic energy.","category":"page"},{"location":"physics/surface_gravity_waves/","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"The Lagrangian-mean velocity field boldsymbolu contrasts with the Eulerian-mean velocity  field boldsymbolu^E, which is the fluid velocity averaged at the fixed Eulerian position  (x y z). The surface wave Stokes drift field supplied by the user is, in fact, defined by the difference between the Eulerian- and Lagrangian-mean velocity:","category":"page"},{"location":"physics/surface_gravity_waves/","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"    boldsymbolu^S equiv boldsymbolu - boldsymbolu^E  ","category":"page"},{"location":"physics/surface_gravity_waves/","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"The Stokes drift velocity field is typically prescribed for idealized scenarios, or determined from a wave model for the evolution of surface waves under time-dependent atmospheric winds in more realistic cases.","category":"page"},{"location":"#Oceananigans.jl","page":"Home","title":"Oceananigans.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"🌊 Fast and friendly fluid dynamics on CPUs and GPUs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Oceananigans.jl is a fast and friendly fluid flow solver written in Julia that can be run in 1-3 dimensions on CPUs and GPUs. It can simulate the incompressible Boussinesq equations, the shallow water equations, or the hydrostatic Boussinesq equations with a free surface. Oceananigans.jl comes with user-friendly features for simulating rotating stratified fluids including user-defined boundary conditions and forcing functions, arbitrary tracers, large eddy simulation turbulence closures, high-order advection schemes, immersed boundaries, Lagrangian particle tracking, and more!","category":"page"},{"location":"","page":"Home","title":"Home","text":"We strive for a user interface that makes Oceananigans.jl`as friendly and intuitive to use as possible, allowing users to focus on the science. Internally, we have attempted to write the underlying algorithm so that the code runs as fast as possible for the configuration chosen by the user –- from simple two-dimensional setups to complex three-dimensional simulations –- and so that as much code as possible is shared between the different architectures, models, and grids.","category":"page"},{"location":"#Getting-help","page":"Home","title":"Getting help","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you are interested in using Oceananigans.jl or are trying to figure out how to use it, please feel free to ask us questions and get in touch! If you're trying to set up a model then check out the examples and model setup documentation. Please feel free to start a discussion if you have any questions, comments, suggestions, etc! There is also an #oceananigans channel on the Julia Slack.","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use Oceananigans.jl as part of your research, teaching, or other activities, we would be grateful if you could cite our work and mention Oceananigans.jl by name.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{OceananigansJOSS,\n  doi = {10.21105/joss.02018},\n  url = {https://doi.org/10.21105/joss.02018},\n  year = {2020},\n  publisher = {The Open Journal},\n  volume = {5},\n  number = {53},\n  pages = {2018},\n  author = {Ali Ramadhan and Gregory LeClaire Wagner and Chris Hill and Jean-Michel Campin and Valentin Churavy and Tim Besard and Andre Souza and Alan Edelman and Raffaele Ferrari and John Marshall},\n  title = {Oceananigans.jl: Fast and friendly geophysical fluid dynamics on GPUs},\n  journal = {Journal of Open Source Software}\n}","category":"page"},{"location":"generated/geostrophic_adjustment/","page":"Geostrophic adjustment","title":"Geostrophic adjustment","text":"EditURL = \"<unknown>/examples/geostrophic_adjustment.jl\"","category":"page"},{"location":"generated/geostrophic_adjustment/#Geostrophic-adjustment-using-Oceananigans.HydrostaticFreeSurfaceModel","page":"Geostrophic adjustment","title":"Geostrophic adjustment using Oceananigans.HydrostaticFreeSurfaceModel","text":"","category":"section"},{"location":"generated/geostrophic_adjustment/","page":"Geostrophic adjustment","title":"Geostrophic adjustment","text":"This example demonstrates how to simulate the one-dimensional geostrophic adjustment of a free surface using Oceananigans.HydrostaticFreeSurfaceModel. Here, we solve the hydrostatic Boussinesq equations beneath a free surface with a small-amplitude about rest z = 0, with boundary conditions expanded around z = 0, and free surface dynamics linearized under the assumption η  H ll 1, where η is the free surface displacement, and H is the total depth of the fluid.","category":"page"},{"location":"generated/geostrophic_adjustment/#Install-dependencies","page":"Geostrophic adjustment","title":"Install dependencies","text":"","category":"section"},{"location":"generated/geostrophic_adjustment/","page":"Geostrophic adjustment","title":"Geostrophic adjustment","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"generated/geostrophic_adjustment/","page":"Geostrophic adjustment","title":"Geostrophic adjustment","text":"using Pkg\npkg\"add Oceananigans, JLD2, Plots\"","category":"page"},{"location":"generated/geostrophic_adjustment/#A-one-dimensional-domain","page":"Geostrophic adjustment","title":"A one-dimensional domain","text":"","category":"section"},{"location":"generated/geostrophic_adjustment/","page":"Geostrophic adjustment","title":"Geostrophic adjustment","text":"We use a one-dimensional domain of geophysical proportions,","category":"page"},{"location":"generated/geostrophic_adjustment/","page":"Geostrophic adjustment","title":"Geostrophic adjustment","text":"using Oceananigans\nusing Oceananigans.Units\nusing Oceananigans.Models.HydrostaticFreeSurfaceModels: ImplicitFreeSurface\n\ngrid = RegularRectilinearGrid(size = (128, 1, 1),\n                              x = (0, 1000kilometers), y = (0, 1), z = (-400meters, 0),\n                              topology = (Bounded, Periodic, Bounded))","category":"page"},{"location":"generated/geostrophic_adjustment/","page":"Geostrophic adjustment","title":"Geostrophic adjustment","text":"and Coriolis parameter appropriate for the mid-latitudes on Earth,","category":"page"},{"location":"generated/geostrophic_adjustment/","page":"Geostrophic adjustment","title":"Geostrophic adjustment","text":"coriolis = FPlane(f=1e-4)","category":"page"},{"location":"generated/geostrophic_adjustment/#Building-a-HydrostaticFreeSurfaceModel","page":"Geostrophic adjustment","title":"Building a HydrostaticFreeSurfaceModel","text":"","category":"section"},{"location":"generated/geostrophic_adjustment/","page":"Geostrophic adjustment","title":"Geostrophic adjustment","text":"We use grid and coriolis to build a simple HydrostaticFreeSurfaceModel,","category":"page"},{"location":"generated/geostrophic_adjustment/","page":"Geostrophic adjustment","title":"Geostrophic adjustment","text":"model = HydrostaticFreeSurfaceModel(grid = grid,\n                                    coriolis = coriolis,\n                                    free_surface=ImplicitFreeSurface())","category":"page"},{"location":"generated/geostrophic_adjustment/#A-geostrophic-adjustment-initial-value-problem","page":"Geostrophic adjustment","title":"A geostrophic adjustment initial value problem","text":"","category":"section"},{"location":"generated/geostrophic_adjustment/","page":"Geostrophic adjustment","title":"Geostrophic adjustment","text":"We pose a geostrophic adjustment problem that consists of a partially-geostrophic Gaussian height field complemented by a geostrophic y-velocity,","category":"page"},{"location":"generated/geostrophic_adjustment/","page":"Geostrophic adjustment","title":"Geostrophic adjustment","text":"Gaussian(x, L) = exp(-x^2 / 2L^2)\n\nU = 0.1 # geostrophic velocity\nL = grid.Lx / 40 # Gaussian width\nx₀ = grid.Lx / 4 # Gaussian center\n\nvᵍ(x, y, z) = - U * (x - x₀) / L * Gaussian(x - x₀, L)\n\ng = model.free_surface.gravitational_acceleration\n\nη₀ = coriolis.f * U * L / g # geostrohpic free surface amplitude\n\nηᵍ(x) = η₀ * Gaussian(x - x₀, L)","category":"page"},{"location":"generated/geostrophic_adjustment/","page":"Geostrophic adjustment","title":"Geostrophic adjustment","text":"We use an initial height field that's twice the geostrophic solution, thus superimposing a geostrophic and ageostrophic component in the free surface displacement field:","category":"page"},{"location":"generated/geostrophic_adjustment/","page":"Geostrophic adjustment","title":"Geostrophic adjustment","text":"ηⁱ(x, y) = 2 * ηᵍ(x)","category":"page"},{"location":"generated/geostrophic_adjustment/","page":"Geostrophic adjustment","title":"Geostrophic adjustment","text":"We set the initial condition to vᵍ and ηⁱ,","category":"page"},{"location":"generated/geostrophic_adjustment/","page":"Geostrophic adjustment","title":"Geostrophic adjustment","text":"set!(model, v=vᵍ, η=ηⁱ)","category":"page"},{"location":"generated/geostrophic_adjustment/#Running-a-Simulation","page":"Geostrophic adjustment","title":"Running a Simulation","text":"","category":"section"},{"location":"generated/geostrophic_adjustment/","page":"Geostrophic adjustment","title":"Geostrophic adjustment","text":"We pick a time-step that resolves the surface dynamics,","category":"page"},{"location":"generated/geostrophic_adjustment/","page":"Geostrophic adjustment","title":"Geostrophic adjustment","text":"gravity_wave_speed = sqrt(g * grid.Lz) # hydrostatic (shallow water) gravity wave speed\n\nwave_propagation_time_scale = model.grid.Δx / gravity_wave_speed\n\nsimulation = Simulation(model, Δt = 0.1 * wave_propagation_time_scale, stop_iteration = 1000)","category":"page"},{"location":"generated/geostrophic_adjustment/#Output","page":"Geostrophic adjustment","title":"Output","text":"","category":"section"},{"location":"generated/geostrophic_adjustment/","page":"Geostrophic adjustment","title":"Geostrophic adjustment","text":"We output the velocity field and free surface displacement,","category":"page"},{"location":"generated/geostrophic_adjustment/","page":"Geostrophic adjustment","title":"Geostrophic adjustment","text":"output_fields = merge(model.velocities, (η=model.free_surface.η,))\n\nsimulation.output_writers[:fields] = JLD2OutputWriter(model, output_fields,\n                                                      schedule = IterationInterval(10),\n                                                      prefix = \"geostrophic_adjustment\",\n                                                      force = true)\n\nrun!(simulation)","category":"page"},{"location":"generated/geostrophic_adjustment/#Visualizing-the-results","page":"Geostrophic adjustment","title":"Visualizing the results","text":"","category":"section"},{"location":"generated/geostrophic_adjustment/","page":"Geostrophic adjustment","title":"Geostrophic adjustment","text":"using JLD2, Plots, Printf\n\nxη = xw = xv = xnodes(model.free_surface.η)\nxu = xnodes(model.velocities.u)\n\nfile = jldopen(simulation.output_writers[:fields].filepath)\n\niterations = parse.(Int, keys(file[\"timeseries/t\"]))\n\nanim = @animate for (i, iter) in enumerate(iterations)\n\n    u = file[\"timeseries/u/$iter\"][:, 1, 1]\n    v = file[\"timeseries/v/$iter\"][:, 1, 1]\n    η = file[\"timeseries/η/$iter\"][:, 1, 1]\n    t = file[\"timeseries/t/$iter\"]\n\n    titlestr = @sprintf(\"Geostrophic adjustment at t = %.1f hours\", t / hours)\n\n    v_plot = plot(xv / kilometers, v, linewidth = 2, title = titlestr,\n                  label = \"\", xlabel = \"x (km)\", ylabel = \"v (m s⁻¹)\", ylims = (-U, U))\n\n    u_plot = plot(xu / kilometers, u, linewidth = 2,\n                  label = \"\", xlabel = \"x (km)\", ylabel = \"u (m s⁻¹)\", ylims = (-2e-3, 2e-3))\n\n    η_plot = plot(xη / kilometers, η, linewidth = 2,\n                  label = \"\", xlabel = \"x (km)\", ylabel = \"η (m)\", ylims = (-η₀/10, 2η₀))\n\n    plot(v_plot, u_plot, η_plot, layout = (3, 1), size = (800, 600))\nend\n\nclose(file)\n\nmp4(anim, \"geostrophic_adjustment.mp4\", fps = 15) # hide","category":"page"},{"location":"generated/geostrophic_adjustment/","page":"Geostrophic adjustment","title":"Geostrophic adjustment","text":"","category":"page"},{"location":"generated/geostrophic_adjustment/","page":"Geostrophic adjustment","title":"Geostrophic adjustment","text":"This page was generated using Literate.jl.","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"numerical_implementation/spatial_operators/#Spatial-operators","page":"Spatial operators","title":"Spatial operators","text":"","category":"section"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"To calculate the various terms and perform the time-stepping, discrete difference and interpolation  operators must be designed from which all the terms, such as momentum advection and Laplacian  diffusion, may be constructed. Much of the material in this section is derived from John Marshall , Alistair Adcroft , Chris Hill , Lev Perelman , Curt Heisey  (1997).","category":"page"},{"location":"numerical_implementation/spatial_operators/#Differences","page":"Spatial operators","title":"Differences","text":"","category":"section"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"Difference operators act as the discrete form of the derivative operator. Care must be taken  when calculating differences on a staggered grid. For example, the the difference of a cell-centered  variable such as temperature T lies on the faces  in the direction of the difference, and  vice versa. In principle, there are three difference operators, one for each  direction","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"  delta_x f = f_E - f_W  quad\n  delta_y f = f_N - f_S  quad\n  delta_z f = f_T - f_B ","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"where the E and W subscripts indicate that the value is evaluated the eastern or western  wall of the cell, N and S indicate the northern and southern walls, and T and B  indicate the top and bottom walls.","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"Additionally, two delta operators must be defined for each direction to account for the  staggered nature of the grid. One for taking the difference of a cell-centered variable and  projecting it onto the cell faces","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"beginalign\n    delta_x^faa f_i j k = f_i j k - f_i-1 j k   \n    delta_y^afa f_i j k = f_i j k - f_i j-1 k   \n    delta_z^aaf f_i j k = f_i j k - f_i j k-1   \nendalign","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"and another for taking the difference of a face-centered variable and projecting it onto the cell centers","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"beginalign\n    delta_x^caa f_i j k = f_i+1 j k - f_i j k   \n    delta_y^aca f_i j k = f_i j+1 k - f_i j k   \n    delta_z^aac f_i j k = f_i j k+1 - f_i j k  \nendalign","category":"page"},{"location":"numerical_implementation/spatial_operators/#Interpolation","page":"Spatial operators","title":"Interpolation","text":"","category":"section"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"In order to add or multiply variables that are defined at different points they are interpolated.  In our case, linear interpolation or averaging is employed. Once again, there are two averaging  operators, one for each direction, \\begin{equation}   \\overline{f}^x = \\frac{fE + fW}{2} \\, , \\quad   \\overline{f}^y = \\frac{fN + fS}{2} \\, , \\quad   \\overline{f}^z = \\frac{fT + fB}{2} \\, . \\end{equation}","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"Additionally, three averaging operators must be defined for each direction. One for taking the  average of a cell-centered  variable and projecting it onto the cell faces","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"beginalign\n    overlinef_i j k^faa = fracf_i j k + f_i-1 j k2   \n    overlinef_i j k^afa = fracf_i j k + f_i j-1 k2   \n    overlinef_i j k^aaf = fracf_i j k + f_i j k-12  \nendalign","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"and another for taking the average of a face-centered variable and projecting it onto the cell centers","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"beginalign\n    overlinef_i j k^caa = fracf_i+1 j k + f_i j k2   \n    overlinef_i j k^aca = fracf_i j+1 k + f_i j k2   \n    overlinef_i j k^aac = fracf_i j k+1 + f_i j k2  \nendalign","category":"page"},{"location":"numerical_implementation/spatial_operators/#Divergence-and-flux-divergence","page":"Spatial operators","title":"Divergence and flux divergence","text":"","category":"section"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"The divergence of the flux of a cell-centered quantity over the cell can be calculated as","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"boldsymbolnabla boldsymbolcdot boldsymbolf\n= frac1V left delta_x^faa (A_x f_x)\n                   + delta_y^afa (A_y f_y)\n                   + delta_z^aaf (A_z f_z) right  ","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"where boldsymbolf = (f_x f_y f_z) is the flux with components defined normal to the  faces, and V is the volume of the cell. The presence of a solid boundary is indicated by  setting the appropriate flux normal to the boundary to zero.","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"A similar divergence operator can be defined for a face-centered quantity. The divergence of  the flux of T over a cell,  boldsymbolnabla boldsymbolcdot (boldsymbolu T),  required in the evaluation of G_T, for example, is then","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"renewcommanddiv1 boldsymbolnabla boldsymbolcdot left ( 1 right )\ndivboldsymbolu T\n= frac1V left delta_x^caa (A_x u overlineT^faa)\n                   + delta_y^aca (A_y v overlineT^afa)\n                   + delta_z^aac (A_z w overlineT^aaf) right  ","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"where T is interpolated onto the cell faces where it can be multiplied by the velocities,  which are then differenced and  projected onto the cell centers where they added together and  then added to G_T which also lives at the cell centers.","category":"page"},{"location":"numerical_implementation/spatial_operators/#Momentum-advection","page":"Spatial operators","title":"Momentum advection","text":"","category":"section"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"The advection terms that make up the mathbfG terms in equations \\eqref{eq:horizontalMomentum} and \\eqref{eq:verticalMomentum} can be rewritten using the incompressibility (boldsymbolnabla boldsymbolcdot boldsymbolu = 0)  as, e.g,","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"renewcommanddiv1 boldsymbolnabla boldsymbolcdot left ( 1 right )\nbeginalign\nboldsymbolu boldsymbolcdot boldsymbolnabla u  = divu boldsymbolu - u ( boldsymbolnabla boldsymbolcdot boldsymbolu ) nonumber \n     = divu boldsymbolu  \nendalign","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"which can then be discretized similarly to the flux divergence operator, however, they must  be discretized differently for each direction.","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"For example, the x-momentum advection operator is discretized as","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"boldsymbolu boldsymbolcdot boldsymbolnabla u\n= frac1overlineV^x left\n    delta_x^faa left( overlineA_x u^caa overlineu^caa right)\n  + delta_y^afa left( overlineA_y v^aca overlineu^aca right)\n  + delta_z^aaf left( overlineA_z w^aac overlineu^aac right)\nright  ","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"where overlineV^x is the average of the volumes of the cells on either side of the face  in question. Calculating partial(uu)partial x can be performed by interpolating A_x u  and u onto the cell centers then multiplying them and differencing them back onto the faces.  However, in the case of the the two other terms, partial(vu)partial y and partial(wu)partial z,  the two variables must be interpolated onto the cell edges to be multiplied then differenced  back onto the cell faces.","category":"page"},{"location":"numerical_implementation/spatial_operators/#Discretization-of-isotropic-diffusion-operators","page":"Spatial operators","title":"Discretization of isotropic diffusion operators","text":"","category":"section"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"An isotropic viscosity operator acting on vertical momentum is discretized via","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"    boldsymbolnabla boldsymbolcdot left ( nu_e boldsymbolnabla w right )\n    = frac1V left\n          delta_x^faa ( nu_e overlineA_x^caa partial_x^caa w )\n        + delta_y^afa ( nu_e overlineA_y^aca partial_y^aca w )\n        + delta_z^aaf ( nu_e overlineA_z^aac partial_z^aac w )\n    right   ","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"where nu is the kinematic viscosity.","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"An isotropic diffusion operator acting on a tracer c, on the other hand, is discretized via","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"   boldsymbolnabla boldsymbolcdot left ( kappa_e boldsymbolnabla c right )\n    = frac1V left phantomoverlineA_x^caa\n        delta_x^caa ( kappa_e A_x partial_x^faa c )\n      + delta_y^aca ( kappa_e A_y partial_y^afa c )\n      + delta_z^aac ( kappa_e A_z partial_z^aaf c )\n    right  ","category":"page"},{"location":"numerical_implementation/spatial_operators/#Vertical-integrals","page":"Spatial operators","title":"Vertical integrals","text":"","category":"section"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"Vertical integrals are converted into sums along each column. For example, the hydrostatic pressure  anomaly is","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"    p_HY^prime = int_-L_z^0 b^prime  mathrmd z  ","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"where b^prime is the buoyancy perturbation. Converting it into a sum that we compute from  the top downwards we get","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"    beginequation\n    p_HY^prime(k) =\n        begincases\n            - overlineb_N_z^prime^aaf Delta z^F_N_z                quad k = N_z   \n            p_HY^prime(k+1) - overlineb_k+1^prime^aaf Delta z^F_k  quad 1 le k le N_z - 1  \n        endcases\n    endequation","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"where we converted the sum into a recursive definition for p_HY^prime(k) in terms of  p_HY^prime(k+1) so that the integral may be computed with mathcalO(N_z) operations  by a single thread.","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"The vertical velocity w may be computed from u and v via the continuity equation","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"    w = - int_-L_z^0 (partial_x u + partial_y v)  mathrmd z  ","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"to satisfy the incompressibility condition nablacdotboldsymbolu = 0 to numerical precision.  This also involves computing a vertical integral, in this case evaluated from the bottom up","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"    beginequation\n    w_k =\n        begincases\n            0  quad k = 1   \n            w_k-1 - left( partial_x^caa u + partial_y^aca v right) Delta z^C_k  quad 2 le k le N_z  \n        endcases\n    endequation","category":"page"},{"location":"contributing/#Contributors-Guide","page":"Contributor's guide","title":"Contributors Guide","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Thank you for considering contributing to Oceananigans! This short guide will give you ideas on how you can contribute and help you make a contribution.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Please feel free to ask us questions and chat with us at any time if you're unsure about anything.","category":"page"},{"location":"contributing/#What-can-I-do?","page":"Contributor's guide","title":"What can I do?","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Tackle an existing issue. We keep a list of good first issues that are self-contained and suitable for a newcomer to try and work on.\nTry to run Oceananigans and play around with it to simulate your favorite fluids and ocean physics. If you run into any problems or find it difficult to use or understand, please open an issue!\nWrite up an example or tutorial on how to do something useful with Oceananigans, like how to set up a new physical configuration.\nImprove documentation or comments if you found something hard to use.\nImplement a new feature if you need it to use Oceananigans.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"If you're interested in working on something, let us know by commenting on existing issues or by opening a new issue. This is to make sure no one else is working on the same issue and so we can help and guide you in case there is anything you need to know beforehand.","category":"page"},{"location":"contributing/#Ground-Rules","page":"Contributor's guide","title":"Ground Rules","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Each pull request should consist of a logical collection of changes. You can include multiple bug fixes in a single pull request, but they should be related. For unrelated changes, please submit multiple pull requests.\nDo not commit changes to files that are irrelevant to your feature or bugfix (eg: .gitignore).\nBe willing to accept criticism and work on improving your code; we don't want to break other users' code, so care must be taken not to introduce bugs. We discuss pull requests and keep working on them until we believe we've done a good job.\nBe aware that the pull request review process is not immediate, and is generally proportional to the size of the pull request.","category":"page"},{"location":"contributing/#Reporting-a-bug","page":"Contributor's guide","title":"Reporting a bug","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"The easiest way to get involved is to report issues you encounter when using Oceananigans or by requesting something you think is missing.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Head over to the issues page.\nSearch to see if your issue already exists or has even been solved previously.\nIf you indeed have a new issue or request, click the \"New Issue\" button.\nPlease be as specific as possible. Include the version of the code you were using, as well as what operating system you are running. The output of Julia's versioninfo() and ] status is helpful to include. If possible, include complete, minimal example code that reproduces the problem.","category":"page"},{"location":"contributing/#Setting-up-your-development-environment","page":"Contributor's guide","title":"Setting up your development environment","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Install Julia on your system.\nInstall git on your system if it is not already there (install XCode command line tools on a Mac or git bash on Windows).\nLogin to your GitHub account and make a fork of the Oceananigans repository by clicking the \"Fork\" button.\nClone your fork of the Oceananigans repository (in terminal on Mac/Linux or git shell/ GUI on Windows) in the location you'd like to keep it.\ngit clone https://github.com/your-user-name/Oceananigans.jl.git\nNavigate to that folder in the terminal or in Anaconda Prompt if you're on Windows.\nConnect your repository to the upstream (main project).\ngit remote add oceananigans https://github.com/CLiMA/Oceananigans.jl.git\nCreate the development environment by opening Julia via julia --project then typing in ] instantiate. This will install all the dependencies in the Project.toml file.\nYou can test to make sure Oceananigans works by typing in ] test which will run all the tests (this can take a while).","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Your development environment is now ready!","category":"page"},{"location":"contributing/#Pull-Requests","page":"Contributor's guide","title":"Pull Requests","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Changes and contributions should be made via GitHub pull requests against the master branch.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"When you're done making changes, commit the changes you made. Chris Beams has written a guide on how to write good commit messages.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"When you think your changes are ready to be merged into the main repository, push to your fork and submit a pull request.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Working on your first Pull Request? You can learn how from this free video series How to Contribute to an Open Source Project on GitHub, Aaron Meurer's tutorial on the git workflow, or the guide “How to Contribute to Open Source\".","category":"page"},{"location":"contributing/#Documentation","page":"Contributor's guide","title":"Documentation","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Now that you've made your awesome contribution, it's time to tell the world how to use it. Writing documentation strings is really important to make sure others use your functionality properly. Didn't write new functions? That's fine, but be sure that the documentation for the code you touched is still in great shape. It is not uncommon to find some strange wording or clarification that you can take care of while you are here.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"You can preview how the Documentation will look like after merging by building the documentation  locally. From the main directory of your local repository call","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"julia --project=docs/ -e 'using Pkg; Pkg.instantiate(); Pkg.develop(PackageSpec(path=pwd()))'\njulia --project=docs/ docs/make.jl","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"and then open docs/build/index.html in your favorite browser.","category":"page"},{"location":"contributing/#Credits","page":"Contributor's guide","title":"Credits","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"This contributor's guide is heavily based on the excellent MetPy contributor's guide.","category":"page"},{"location":"function_index/#Index","page":"Function index","title":"Index","text":"","category":"section"},{"location":"function_index/","page":"Function index","title":"Function index","text":"","category":"page"},{"location":"physics/turbulence_closures/#Turbulence-closures","page":"Turbulence closures","title":"Turbulence closures","text":"","category":"section"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"The turbulence closure selected by the user determines the form of stress divergence boldsymbolnabla boldsymbolcdot boldsymboltau and diffusive flux divergence boldsymbolnabla boldsymbolcdot boldsymbolq_c in the momentum and tracer conservation equations.","category":"page"},{"location":"physics/turbulence_closures/#Constant-isotropic-diffusivity","page":"Turbulence closures","title":"Constant isotropic diffusivity","text":"","category":"section"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"In a constant isotropic diffusivity model, the kinematic stress tensor is defined","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"tau_ij = - nu Sigma_ij  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"where nu is a constant viscosity and Sigma_ij equiv tfrac12 left ( u_i j + u_j i right ) is the strain-rate tensor. The divergence of boldsymboltau is then","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"boldsymbolnabla boldsymbolcdot boldsymboltau = -nu nabla^2 boldsymbolu  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"Similarly, the diffusive tracer flux is boldsymbolq_c = - kappa boldsymbolnabla c for tracer diffusivity kappa, and the diffusive tracer flux divergence is","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"boldsymbolnabla boldsymbolcdot boldsymbolq_c = - kappa nabla^2 c  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"Each tracer may have a unique diffusivity kappa.","category":"page"},{"location":"physics/turbulence_closures/#Constant-anisotropic-diffusivity","page":"Turbulence closures","title":"Constant anisotropic diffusivity","text":"","category":"section"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"In Oceananigans.jl, a constant anisotropic diffusivity implies a constant tensor diffusivity nu_j k and stress boldsymboltau_ij = nu_j k u_i k with non-zero components nu_11 = nu_22 = nu_h and nu_33 = nu_v. With this form the kinematic stress divergence becomes","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"boldsymbolnabla boldsymbolcdot boldsymboltau = - left  nu_h left ( partial_x^2 + partial_y^2 right )\n                                    + nu_v partial_z^2 right  boldsymbolu  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"and diffusive flux divergence","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"boldsymbolnabla boldsymbolcdot boldsymbolq_c = - left  kappa_h left ( partial_x^2 + partial_y^2 right )\n                                    + kappa_v partial_z^2 right  c  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"in terms of the horizontal viscosities and diffusivities nu_h and kappa_h and the vertical viscosity and diffusivities nu_v and kappa_v. Each tracer may have a unique diffusivity components kappa_h and kappa_v.","category":"page"},{"location":"physics/turbulence_closures/#Constant-anisotropic-biharmonic-diffusivity","page":"Turbulence closures","title":"Constant anisotropic biharmonic diffusivity","text":"","category":"section"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"In Oceananigans.jl, a constant anisotropic biharmonic diffusivity implies a constant tensor diffusivity nu_j k and stress boldsymboltau_ij = nu_j k partial_k^3 u_i with non-zero components nu_11 = nu_22 = nu_h and nu_33 = nu_v. With this form the kinematic stress divergence becomes","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"boldsymbolnabla boldsymbolcdot boldsymboltau = - left  nu_h left ( partial_x^2 + partial_y^2 right )^2\n                                    + nu_v partial_z^4 right  boldsymbolu  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"and diffusive flux divergence","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"boldsymbolnabla boldsymbolcdot boldsymbolq_c = - left  kappa_h left ( partial_x^2 + partial_y^2 right )^2\n                                    + kappa_v partial_z^4 right  c  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"in terms of the horizontal biharmonic viscosities and diffusivities nu_h and kappa_h and the vertical biharmonic viscosity and diffusivities nu_v and kappa_v. Each tracer may have a unique diffusivity components kappa_h and kappa_v.","category":"page"},{"location":"physics/turbulence_closures/#Smagorinsky-Lilly-turbulence-closure","page":"Turbulence closures","title":"Smagorinsky-Lilly turbulence closure","text":"","category":"section"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"In the turbulence closure proposed by Lilly (1962) and J. Smagorinsky  (1963), the subgrid stress associated with unresolved turbulent motions is modeled diffusively via","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"tau_ij = nu_e Sigma_ij  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"where Sigma_ij = tfrac12 left ( u_i j + u_j i right ) is the resolved strain rate. The eddy viscosity is given by","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"    beginalign\n    nu_e = left ( C Delta_f right )^2 sqrt Sigma^2   Upsilon(Ri) + nu  \n    labeleqsmagorinsky-viscosity\n    endalign","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"where Delta_f is the \"filter width\" associated with the finite volume grid spacing, C is a user-specified model constant, Sigma^2 equiv Sigma_ij Sigma_ij, and nu is a constant isotropic background viscosity. The factor Upsilon(Ri) reduces nu_e in regions of strong stratification where the resolved gradient Richardson number Ri equiv N^2  Sigma^2 is large via","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"    Upsilon(Ri) = sqrt1 - min left ( 1 C_b N^2  Sigma^2 right )  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"where N^2 = max left (0 partial_z b right ) is the squared buoyancy frequency for stable stratification with partial_z b  0 and C_b is a user-specified constant. Roughly speaking, the filter width for the Smagorinsky-Lilly closure is taken as","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"Delta_f(boldsymbolx) = left ( Delta x Delta y Delta z right)^13  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"where Delta x, Delta y, and Delta z are the grid spacing in the boldsymbolhat x, boldsymbolhat y, and boldsymbolhat z directions at location boldsymbolx = (x y z).","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"The effect of subgrid turbulence on tracer mixing is also modeled diffusively via","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"boldsymbolq_c = kappa_e boldsymbolnabla c  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"where the eddy diffusivity kappa_e is","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"kappa_e = fracnu_e - nuPr + kappa  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"where Pr is a turbulent Prandtl number and kappa is a constant isotropic background diffusivity. Both Pr and kappa may be set independently for each tracer.","category":"page"},{"location":"physics/turbulence_closures/#Anisotropic-minimum-dissipation-(AMD)-turbulence-closure","page":"Turbulence closures","title":"Anisotropic minimum dissipation (AMD) turbulence closure","text":"","category":"section"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"Oceananigans.jl uses the anisotropic minimum dissipation (AMD) model proposed by Verstappen18 and described and tested by Vreugdenhil18. The AMD model uses an eddy diffusivity hypothesis similar the Smagorinsky-Lilly model. In the AMD model, the eddy viscosity and diffusivity for each tracer are defined in terms of eddy viscosity and diffusivity predictors nu_e^dagger and kappa_e^dagger, such that","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"    nu_e = max left ( 0 nu_e^dagger right ) + nu\n    quad textand quad\n    kappa_e = max left ( 0 kappa_e^dagger right ) + kappa  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"to ensure that nu_e ge 0 and kappa_e ge 0, where nu and kappa are the constant isotropic background viscosity and diffusivities for each tracer. The eddy viscosity  predictor is","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"    beginequation\n    nu_e^dagger = -(C Delta_f)^2\n    frac\n        (hatpartial_k hatu_i) (hatpartial_k hatu_j) hatSigma_ij\n        + C_b hatdelta_i3 (hatpartial_k hatu_i) (hatpartial_k b)\n        (hatpartial_l hatu_m) (hatpartial_l hatu_m)  \n    labeleqnu-dagger\n    endequation","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"while the eddy diffusivity predictor for tracer c is","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"    beginequation\n    labeleqkappa-dagger\n    kappa_e^dagger = -(C Delta_f)^2\n    frac\n        (hatpartial_k hatu_i) (hatpartial_k c) (hatpartial_i c)\n        (hatpartial_l c) (hatpartial_l c)  \n    endequation","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"In the definitions of the eddy viscosity and eddy diffusivity predictor, C and C_b are user-specified model constants, Delta_f is a \"filter width\" associated with the finite volume grid spacing, and the hat decorators on partial derivatives, velocities, and the Kronecker delta hat delta_i3 are defined such that","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"    hat partial_i equiv Delta_i partial_i qquad\n    hatu_i(x t) equiv fracu_i(x t)Delta_i quad textand quad\n    hatdelta_i3 equiv fracdelta_i3Delta_3  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"A velocity gradient, for example, is therefore hatpartial_i hatu_j(x t) = fracDelta_iDelta_j partial_i u_j(x t), while the normalized strain tensor is","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"    hatSigma_ij =\n        frac12 left hatpartial_i hatu_j(x t) + hatpartial_j hatu_i(x t) right  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"The filter width Delta_f in that appears in the viscosity and diffusivity predictors is taken as the square root of the harmonic mean of the squares of the filter widths in each direction:","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"    frac1Delta_f^2 = frac13 left(   frac1Delta x^2\n                                              + frac1Delta y^2\n                                              + frac1Delta z^2 right)  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"The constant C_b permits the \"buoyancy modification\" term it multiplies to be omitted from a calculation. By default we use the model constants C=112 and C_b=0.","category":"page"},{"location":"benchmarks/#performance_benchmarks","page":"Performance benchmarks","title":"Performance benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"The performance benchmarking scripts in the benchmarks directory of the git repository can be run to benchmark Oceananigans.jl on your machine. They use TimerOutputs.jl to nicely format the benchmark results.","category":"page"},{"location":"benchmarks/#Static-ocean","page":"Performance benchmarks","title":"Static ocean","text":"","category":"section"},{"location":"benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"This is a benchmark of a simple \"static ocean\" configuration. The time stepping and Poisson solver still takes the same amount of time whether the ocean is static or active, so it is quite indicative of actual performance. It tests the performance of a bare-bones horizontally-periodic model with topology = (Periodic, Periodic, Bounded).","category":"page"},{"location":"benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Oceananigans v0.34.0 (DEVELOPMENT BRANCH)\r\nJulia Version 1.4.2\r\nCommit 44fa15b150* (2020-05-23 18:35 UTC)\r\nPlatform Info:\r\n  OS: Linux (x86_64-pc-linux-gnu)\r\n  CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz\r\n  WORD_SIZE: 64\r\n  LIBM: libopenlibm\r\n  LLVM: libLLVM-8.0.1 (ORCJIT, skylake)\r\n  GPU: TITAN V\r\n\r\n ──────────────────────────────────────────────────────────────────────────────────────\r\n        Static ocean benchmarks                Time                   Allocations      \r\n                                       ──────────────────────   ───────────────────────\r\n           Tot / % measured:                 291s / 29.6%           27.7GiB / 0.50%    \r\n\r\n Section                       ncalls     time   %tot     avg     alloc   %tot      avg\r\n ──────────────────────────────────────────────────────────────────────────────────────\r\n  16× 16× 16  [CPU, Float32]       10   15.6ms  0.02%  1.56ms   2.61MiB  1.84%   267KiB\r\n  16× 16× 16  [CPU, Float64]       10   16.9ms  0.02%  1.69ms   2.61MiB  1.84%   267KiB\r\n  16× 16× 16  [GPU, Float32]       10   53.4ms  0.06%  5.34ms   11.5MiB  8.14%  1.15MiB\r\n  16× 16× 16  [GPU, Float64]       10   69.7ms  0.08%  6.97ms   11.5MiB  8.14%  1.15MiB\r\n  32× 32× 32  [CPU, Float32]       10   54.6ms  0.06%  5.46ms   2.61MiB  1.84%   267KiB\r\n  32× 32× 32  [CPU, Float64]       10   57.1ms  0.07%  5.71ms   2.61MiB  1.84%   267KiB\r\n  32× 32× 32  [GPU, Float32]       10   57.5ms  0.07%  5.75ms   11.6MiB  8.15%  1.16MiB\r\n  32× 32× 32  [GPU, Float64]       10   75.0ms  0.09%  7.50ms   11.6MiB  8.16%  1.16MiB\r\n  64× 64× 64  [CPU, Float32]       10    424ms  0.49%  42.4ms   2.61MiB  1.84%   267KiB\r\n  64× 64× 64  [CPU, Float64]       10    425ms  0.49%  42.5ms   2.61MiB  1.84%   267KiB\r\n  64× 64× 64  [GPU, Float32]       10   61.7ms  0.07%  6.17ms   11.6MiB  8.16%  1.16MiB\r\n  64× 64× 64  [GPU, Float64]       10   82.4ms  0.10%  8.24ms   11.6MiB  8.17%  1.16MiB\r\n 128×128×128  [CPU, Float32]       10    3.67s  4.26%   367ms   2.61MiB  1.84%   267KiB\r\n 128×128×128  [CPU, Float64]       10    3.64s  4.23%   364ms   2.61MiB  1.84%   267KiB\r\n 128×128×128  [GPU, Float32]       10   74.8ms  0.09%  7.48ms   11.6MiB  8.16%  1.16MiB\r\n 128×128×128  [GPU, Float64]       10   94.0ms  0.11%  9.40ms   11.6MiB  8.17%  1.16MiB\r\n 256×256×256  [CPU, Float32]       10    38.5s  44.8%   3.85s   2.61MiB  1.84%   267KiB\r\n 256×256×256  [CPU, Float64]       10    37.9s  44.1%   3.79s   2.61MiB  1.84%   267KiB\r\n 256×256×256  [GPU, Float32]       10    350ms  0.41%  35.0ms   11.6MiB  8.18%  1.16MiB\r\n 256×256×256  [GPU, Float64]       10    352ms  0.41%  35.2ms   11.6MiB  8.17%  1.16MiB\r\n ──────────────────────────────────────────────────────────────────────────────────────\r\n\r\nCPU Float64 -> Float32 speedup:\r\n 16× 16× 16 : 1.084\r\n 32× 32× 32 : 1.046\r\n 64× 64× 64 : 1.000\r\n128×128×128 : 0.993\r\n256×256×256 : 0.986\r\n\r\nGPU Float64 -> Float32 speedup:\r\n 16× 16× 16 : 1.304\r\n 32× 32× 32 : 1.303\r\n 64× 64× 64 : 1.335\r\n128×128×128 : 1.257\r\n256×256×256 : 1.004\r\n\r\nCPU -> GPU speedup:\r\n 16× 16× 16  [Float32]: 0.291\r\n 16× 16× 16  [Float64]: 0.242\r\n 32× 32× 32  [Float32]: 0.949\r\n 32× 32× 32  [Float64]: 0.762\r\n 64× 64× 64  [Float32]: 6.876\r\n 64× 64× 64  [Float64]: 5.152\r\n128×128×128  [Float32]: 49.036\r\n128×128×128  [Float64]: 38.730\r\n256×256×256  [Float32]: 109.868\r\n256×256×256  [Float64]: 107.863","category":"page"},{"location":"benchmarks/#Channel","page":"Performance benchmarks","title":"Channel","text":"","category":"section"},{"location":"benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"This benchmark tests the channel model (topology = (Periodic, Bounded, Bounded)) configuration which can be slower due to the use of a more complicated algorithm (involving 2D cosine transforms) for the pressure solver in the current version of Oceananigans.","category":"page"},{"location":"benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Oceananigans v0.34.0 (DEVELOPMENT BRANCH)\r\nJulia Version 1.4.2\r\nCommit 44fa15b150* (2020-05-23 18:35 UTC)\r\nPlatform Info:\r\n  OS: Linux (x86_64-pc-linux-gnu)\r\n  CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz\r\n  WORD_SIZE: 64\r\n  LIBM: libopenlibm\r\n  LLVM: libLLVM-8.0.1 (ORCJIT, skylake)\r\n  GPU: TITAN V\r\n\r\n ──────────────────────────────────────────────────────────────────────────────────────\r\n           Channel benchmarks                  Time                   Allocations      \r\n                                       ──────────────────────   ───────────────────────\r\n           Tot / % measured:                 453s / 19.5%           26.3GiB / 0.48%    \r\n\r\n Section                       ncalls     time   %tot     avg     alloc   %tot      avg\r\n ──────────────────────────────────────────────────────────────────────────────────────\r\n  32× 32× 32  [CPU, Float32]       10   58.5ms  0.07%  5.85ms   2.84MiB  2.22%   291KiB\r\n  32× 32× 32  [CPU, Float64]       10   60.8ms  0.07%  6.08ms   2.85MiB  2.22%   291KiB\r\n  32× 32× 32  [GPU, Float32]       10   68.7ms  0.08%  6.87ms   12.6MiB  9.85%  1.26MiB\r\n  32× 32× 32  [GPU, Float64]       10   88.2ms  0.10%  8.82ms   12.6MiB  9.85%  1.26MiB\r\n  64× 64× 64  [CPU, Float32]       10    459ms  0.52%  45.9ms   2.84MiB  2.22%   291KiB\r\n  64× 64× 64  [CPU, Float64]       10    442ms  0.50%  44.2ms   2.85MiB  2.22%   291KiB\r\n  64× 64× 64  [GPU, Float32]       10   91.0ms  0.10%  9.10ms   12.8MiB  10.0%  1.28MiB\r\n  64× 64× 64  [GPU, Float64]       10    108ms  0.12%  10.8ms   12.8MiB  10.0%  1.28MiB\r\n 128×128×128  [CPU, Float32]       10    3.87s  4.38%   387ms   2.84MiB  2.22%   291KiB\r\n 128×128×128  [CPU, Float64]       10    3.92s  4.44%   392ms   2.85MiB  2.22%   291KiB\r\n 128×128×128  [GPU, Float32]       10    145ms  0.16%  14.5ms   13.2MiB  10.3%  1.32MiB\r\n 128×128×128  [GPU, Float64]       10    163ms  0.18%  16.3ms   13.2MiB  10.3%  1.32MiB\r\n 256×256×256  [CPU, Float32]       10    38.6s  43.6%   3.86s   2.85MiB  2.22%   292KiB\r\n 256×256×256  [CPU, Float64]       10    38.7s  43.8%   3.87s   2.85MiB  2.22%   292KiB\r\n 256×256×256  [GPU, Float32]       10    805ms  0.91%  80.5ms   14.0MiB  10.9%  1.40MiB\r\n 256×256×256  [GPU, Float64]       10    805ms  0.91%  80.5ms   14.0MiB  10.9%  1.40MiB\r\n ──────────────────────────────────────────────────────────────────────────────────────\r\n\r\nCPU Float64 -> Float32 speedup:\r\n 32× 32× 32 : 1.040\r\n 64× 64× 64 : 0.963\r\n128×128×128 : 1.015\r\n256×256×256 : 1.004\r\n\r\nGPU Float64 -> Float32 speedup:\r\n 32× 32× 32 : 1.283\r\n 64× 64× 64 : 1.188\r\n128×128×128 : 1.120\r\n256×256×256 : 0.999\r\n\r\nCPU -> GPU speedup:\r\n 32× 32× 32  [Float32]: 0.851\r\n 32× 32× 32  [Float64]: 0.689\r\n 64× 64× 64  [Float32]: 5.044\r\n 64× 64× 64  [Float64]: 4.088\r\n128×128×128  [Float32]: 26.602\r\n128×128×128  [Float64]: 24.097\r\n256×256×256  [Float32]: 47.891\r\n256×256×256  [Float64]: 48.116","category":"page"},{"location":"benchmarks/#Tracers","page":"Performance benchmarks","title":"Tracers","text":"","category":"section"},{"location":"benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"This benchmark tests the performance impacts of running with various amounts of active and passive tracers.","category":"page"},{"location":"benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Oceananigans v0.34.0 (DEVELOPMENT BRANCH)\r\nJulia Version 1.4.2\r\nCommit 44fa15b150* (2020-05-23 18:35 UTC)\r\nPlatform Info:\r\n  OS: Linux (x86_64-pc-linux-gnu)\r\n  CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz\r\n  WORD_SIZE: 64\r\n  LIBM: libopenlibm\r\n  LLVM: libLLVM-8.0.1 (ORCJIT, skylake)\r\n  GPU: TITAN V\r\n\r\n ───────────────────────────────────────────────────────────────────────────────────────────────────────────\r\n                      Tracer benchmarks                             Time                   Allocations      \r\n                                                            ──────────────────────   ───────────────────────\r\n                      Tot / % measured:                           168s / 1.29%           18.6GiB / 0.77%    \r\n\r\n Section                                            ncalls     time   %tot     avg     alloc   %tot      avg\r\n ───────────────────────────────────────────────────────────────────────────────────────────────────────────\r\n  32× 32× 32 0 active +  0 passive [CPU, Float64]       10   42.4ms  1.96%  4.24ms   1.89MiB  1.29%   194KiB\r\n  32× 32× 32 0 active +  1 passive [CPU, Float64]       10   48.3ms  2.23%  4.83ms   2.17MiB  1.49%   223KiB\r\n  32× 32× 32 0 active +  2 passive [CPU, Float64]       10   53.5ms  2.46%  5.35ms   2.61MiB  1.78%   267KiB\r\n  32× 32× 32 1 active +  0 passive [CPU, Float64]       10   48.9ms  2.25%  4.89ms   2.17MiB  1.49%   223KiB\r\n  32× 32× 32 2 active +  0 passive [CPU, Float64]       10   56.0ms  2.58%  5.60ms   2.61MiB  1.78%   267KiB\r\n  32× 32× 32 2 active +  3 passive [CPU, Float64]       10   77.0ms  3.55%  7.70ms   3.73MiB  2.55%   382KiB\r\n  32× 32× 32 2 active +  5 passive [CPU, Float64]       10   90.4ms  4.16%  9.04ms   4.46MiB  3.05%   457KiB\r\n  32× 32× 32 2 active + 10 passive [CPU, Float64]       10    127ms  5.86%  12.7ms   6.36MiB  4.35%   651KiB\r\n 256×256×128 0 active +  0 passive [GPU, Float64]       10    146ms  6.75%  14.6ms   8.48MiB  5.80%   868KiB\r\n 256×256×128 0 active +  1 passive [GPU, Float64]       10    162ms  7.45%  16.2ms   9.92MiB  6.78%  0.99MiB\r\n 256×256×128 0 active +  2 passive [GPU, Float64]       10    174ms  8.03%  17.4ms   11.6MiB  7.92%  1.16MiB\r\n 256×256×128 1 active +  0 passive [GPU, Float64]       10    160ms  7.39%  16.0ms   9.90MiB  6.77%  0.99MiB\r\n 256×256×128 2 active +  0 passive [GPU, Float64]       10    177ms  8.18%  17.7ms   11.6MiB  7.93%  1.16MiB\r\n 256×256×128 2 active +  3 passive [GPU, Float64]       10    222ms  10.2%  22.2ms   17.0MiB  11.6%  1.70MiB\r\n 256×256×128 2 active +  5 passive [GPU, Float64]       10    255ms  11.8%  25.5ms   20.6MiB  14.1%  2.06MiB\r\n 256×256×128 2 active + 10 passive [GPU, Float64]       10    328ms  15.1%  32.8ms   31.3MiB  21.4%  3.13MiB\r\n ───────────────────────────────────────────────────────────────────────────────────────────────────────────","category":"page"},{"location":"benchmarks/#Turbulence-closures","page":"Performance benchmarks","title":"Turbulence closures","text":"","category":"section"},{"location":"benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"This benchmark tests the performance impacts of various turbulent diffusivity closures and large eddy simulation (LES) models.","category":"page"},{"location":"benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Oceananigans v0.34.0 (DEVELOPMENT BRANCH)\r\nJulia Version 1.4.2\r\nCommit 44fa15b150* (2020-05-23 18:35 UTC)\r\nPlatform Info:\r\n  OS: Linux (x86_64-pc-linux-gnu)\r\n  CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz\r\n  WORD_SIZE: 64\r\n  LIBM: libopenlibm\r\n  LLVM: libLLVM-8.0.1 (ORCJIT, skylake)\r\n  GPU: TITAN V\r\n\r\n ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\r\n                         Turbulence closure benchmarks                                Time                   Allocations      \r\n                                                                              ──────────────────────   ───────────────────────\r\n                               Tot / % measured:                                    257s / 34.3%           25.0GiB / 0.47%    \r\n\r\n Section                                                              ncalls     time   %tot     avg     alloc   %tot      avg\r\n ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\r\n  32× 32× 32 AnisotropicDiffusivity [CPU, Float64]                        10   52.0ms  0.06%  5.20ms   2.62MiB  2.16%   268KiB\r\n  32× 32× 32 AnisotropicDiffusivity [GPU, Float64]                        10   52.3ms  0.06%  5.23ms   11.6MiB  9.60%  1.16MiB\r\n  32× 32× 32 IsotropicDiffusivity [CPU, Float64]                          10   52.7ms  0.06%  5.27ms   2.61MiB  2.15%   267KiB\r\n  32× 32× 32 IsotropicDiffusivity [GPU, Float64]                          10   49.7ms  0.06%  4.97ms   11.6MiB  9.55%  1.16MiB\r\n  32× 32× 32 SmagorinskyLilly [CPU, Float64]                              10   88.3ms  0.10%  8.83ms   2.73MiB  2.25%   280KiB\r\n  32× 32× 32 SmagorinskyLilly [GPU, Float64]                              10   57.1ms  0.06%  5.71ms   12.5MiB  10.3%  1.25MiB\r\n  32× 32× 32 VerstappenAnisotropicMinimumDissipation [CPU, Float64]       10   85.8ms  0.10%  8.58ms   2.93MiB  2.42%   300KiB\r\n  32× 32× 32 VerstappenAnisotropicMinimumDissipation [GPU, Float64]       10   67.6ms  0.08%  6.76ms   14.0MiB  11.5%  1.40MiB\r\n 256×256×128 AnisotropicDiffusivity [CPU, Float64]                        10    16.7s  19.0%   1.67s   2.62MiB  2.16%   268KiB\r\n 256×256×128 AnisotropicDiffusivity [GPU, Float64]                        10    180ms  0.21%  18.0ms   11.7MiB  9.62%  1.17MiB\r\n 256×256×128 IsotropicDiffusivity [CPU, Float64]                          10    16.5s  18.7%   1.65s   2.61MiB  2.15%   267KiB\r\n 256×256×128 IsotropicDiffusivity [GPU, Float64]                          10    179ms  0.20%  17.9ms   11.6MiB  9.59%  1.16MiB\r\n 256×256×128 SmagorinskyLilly [CPU, Float64]                              10    27.4s  31.1%   2.74s   2.73MiB  2.26%   280KiB\r\n 256×256×128 SmagorinskyLilly [GPU, Float64]                              10    268ms  0.30%  26.8ms   12.5MiB  10.3%  1.25MiB\r\n 256×256×128 VerstappenAnisotropicMinimumDissipation [CPU, Float64]       10    26.0s  29.5%   2.60s   2.93MiB  2.42%   300KiB\r\n 256×256×128 VerstappenAnisotropicMinimumDissipation [GPU, Float64]       10    289ms  0.33%  28.9ms   14.0MiB  11.6%  1.40MiB\r\n ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────","category":"page"},{"location":"benchmarks/#Shallow-Water-Model","page":"Performance benchmarks","title":"Shallow Water Model","text":"","category":"section"},{"location":"benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"This benchmark tests the performance of the shallow water model run in a doubly periodic domain (topology = (Periodic, Periodic, Flat)) on CPUs versus GPUs.  We find that we get a speed up of over 100 with 1024^2 and this almost doubles by 4096^2.","category":"page"},{"location":"benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Oceananigans v0.53.2\r\nJulia Version 1.5.2\r\nCommit 539f3ce943* (2020-09-23 23:17 UTC)\r\nPlatform Info:\r\n  OS: Linux (x86_64-pc-linux-gnu)\r\n  CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz\r\n  WORD_SIZE: 64\r\n  LIBM: libopenlibm\r\n  LLVM: libLLVM-9.0.1 (ORCJIT, cascadelake)\r\nEnvironment:\r\n  EBVERSIONJULIA = 1.5.2\r\n  GPU: Tesla V100-SXM2-32GB\r\n\r\n                                              Shallow water model benchmarks\r\n┌───────────────┬─────────────┬───────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┬─────────┐\r\n│ Architectures │ Float_types │    Ns │        min │     median │       mean │        max │     memory │ allocs │ samples │\r\n├───────────────┼─────────────┼───────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┼─────────┤\r\n│           CPU │     Float64 │    32 │   1.968 ms │   2.201 ms │   2.180 ms │   2.418 ms │ 304.19 KiB │   1879 │      10 │\r\n│           CPU │     Float64 │    64 │   3.323 ms │   3.403 ms │   3.438 ms │   3.662 ms │ 304.28 KiB │   1885 │      10 │\r\n│           CPU │     Float64 │   128 │   8.024 ms │   8.106 ms │   8.128 ms │   8.443 ms │ 304.28 KiB │   1885 │      10 │\r\n│           CPU │     Float64 │   256 │  24.693 ms │  24.877 ms │  24.975 ms │  25.452 ms │ 304.28 KiB │   1885 │      10 │\r\n│           CPU │     Float64 │   512 │  96.451 ms │  97.999 ms │  97.824 ms │  99.195 ms │ 305.09 KiB │   1937 │      10 │\r\n│           CPU │     Float64 │  1024 │ 402.754 ms │ 404.855 ms │ 404.871 ms │ 407.238 ms │ 305.09 KiB │   1937 │      10 │\r\n│           CPU │     Float64 │  2048 │    1.621 s │    1.625 s │    1.624 s │    1.626 s │ 305.09 KiB │   1937 │       4 │\r\n│           CPU │     Float64 │  4096 │    6.519 s │    6.519 s │    6.519 s │    6.519 s │ 305.09 KiB │   1937 │       1 │\r\n│           CPU │     Float64 │  8192 │   26.404 s │   26.404 s │   26.404 s │   26.404 s │ 305.09 KiB │   1937 │       1 │\r\n│           CPU │     Float64 │ 16384 │  105.359 s │  105.359 s │  105.359 s │  105.359 s │ 305.09 KiB │   1937 │       1 │\r\n│           GPU │     Float64 │    32 │   2.937 ms │   3.157 ms │   3.186 ms │   3.556 ms │ 637.95 KiB │   5599 │      10 │\r\n│           GPU │     Float64 │    64 │   3.083 ms │   3.306 ms │   3.298 ms │   3.648 ms │ 657.08 KiB │   5599 │      10 │\r\n│           GPU │     Float64 │   128 │   3.100 ms │   3.340 ms │   3.319 ms │   3.591 ms │ 691.95 KiB │   5599 │      10 │\r\n│           GPU │     Float64 │   256 │   3.170 ms │   3.398 ms │   3.463 ms │   4.453 ms │ 767.33 KiB │   5599 │      10 │\r\n│           GPU │     Float64 │   512 │   3.244 ms │   3.476 ms │   3.523 ms │   4.268 ms │ 912.14 KiB │   5651 │      10 │\r\n│           GPU │     Float64 │  1024 │   3.417 ms │   3.604 ms │   3.666 ms │   4.532 ms │   1.17 MiB │   5685 │      10 │\r\n│           GPU │     Float64 │  2048 │   9.201 ms │   9.246 ms │   9.243 ms │   9.317 ms │   1.73 MiB │   5775 │      10 │\r\n│           GPU │     Float64 │  4096 │  35.143 ms │  35.438 ms │  35.395 ms │  35.573 ms │   2.86 MiB │   5739 │      10 │\r\n│           GPU │     Float64 │  8192 │ 139.050 ms │ 139.118 ms │ 139.136 ms │ 139.285 ms │   5.11 MiB │   5739 │      10 │\r\n│           GPU │     Float64 │ 16384 │ 563.804 ms │ 563.922 ms │ 563.931 ms │ 564.081 ms │   9.61 MiB │   5761 │       9 │\r\n└───────────────┴─────────────┴───────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┴─────────┘\r\n\r\n        Shallow water model CPU -> GPU speedup\r\n┌─────────────┬───────┬──────────┬─────────┬─────────┐\r\n│ Float_types │    Ns │  speedup │  memory │  allocs │\r\n├─────────────┼───────┼──────────┼─────────┼─────────┤\r\n│     Float64 │    32 │ 0.697116 │ 2.09724 │ 2.97978 │\r\n│     Float64 │    64 │  1.02927 │ 2.15944 │ 2.97029 │\r\n│     Float64 │   128 │  2.42711 │ 2.27406 │ 2.97029 │\r\n│     Float64 │   256 │  7.32025 │ 2.52177 │ 2.97029 │\r\n│     Float64 │   512 │  28.1914 │ 2.98971 │  2.9174 │\r\n│     Float64 │  1024 │  112.326 │ 3.93542 │ 2.93495 │\r\n│     Float64 │  2048 │  175.735 │ 5.81322 │ 2.98141 │\r\n│     Float64 │  4096 │  183.947 │ 9.58727 │ 2.96283 │\r\n│     Float64 │  8192 │  189.795 │  17.139 │ 2.96283 │\r\n│     Float64 │ 16384 │  186.833 │ 32.2437 │ 2.97419 │\r\n└─────────────┴───────┴──────────┴─────────┴─────────┘\r\n","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"EditURL = \"<unknown>/examples/shallow_water_Bickley_jet.jl\"","category":"page"},{"location":"generated/shallow_water_Bickley_jet/#An-unstable-Bickley-jet-in-Shallow-Water-model","page":"Shallow water Bickley jet","title":"An unstable Bickley jet in Shallow Water model","text":"","category":"section"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"This example shows how to use Oceananigans.ShallowWaterModel to simulate the evolution of an unstable, geostrophically balanced, Bickley jet. The model solves the governing equations for the shallow water model in conservative form.  The geometry is that of a periodic channel in the x-direction with a flat bottom and a free-surface. The initial conditions are that of a Bickley jet with small-amplitude perturbations. The interested reader can see \"The nonlinear evolution of barotropically unstable jets,\" J. Phys. Oceanogr. (2003) for more details on this specific problem.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Unlike the other models, the fields that are simulated are the mass transports, uh and vh in the x and y directions, respectively, and the height h.  Note that the velocities u and v are not state variables but can be easily computed when needed, e.g., via u = uh / h.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/#Install-dependencies","page":"Shallow water Bickley jet","title":"Install dependencies","text":"","category":"section"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"First we make sure that we have all of the packages that are required to run the simulation.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"using Pkg\npkg\"add Oceananigans, NCDatasets, Plots, Printf, Polynomials\"","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"using Oceananigans\nusing Oceananigans.Models: ShallowWaterModel","category":"page"},{"location":"generated/shallow_water_Bickley_jet/#Two-dimensional-domain","page":"Shallow water Bickley jet","title":"Two-dimensional domain","text":"","category":"section"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"The shallow water model is a two-dimensional model and thus the number of vertical points Nz must be set to one.  Note that L_z is the mean depth of the fluid.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Lx, Ly, Lz = 2π, 20, 1\nNx, Ny = 128, 128\n\ngrid = RegularRectilinearGrid(size = (Nx, Ny),\n                              x = (0, Lx), y = (-Ly/2, Ly/2),\n                              topology = (Periodic, Bounded, Flat))","category":"page"},{"location":"generated/shallow_water_Bickley_jet/#Physical-parameters","page":"Shallow water Bickley jet","title":"Physical parameters","text":"","category":"section"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"This is a toy problem and we choose the parameters so the jet idealizes a relatively narrow mesoscale jet. The physical parameters are","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"f: Coriolis parameter\ng: Acceleration due to gravity\nU: Maximum jet speed\nDelta eta: Maximum free-surface deformation as dictated by geostrophy","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":" const f = 1\n const g = 9.8\n const U = 1.0\nconst Δη = f * U / g\nnothing # hide","category":"page"},{"location":"generated/shallow_water_Bickley_jet/#Building-a-ShallowWaterModel","page":"Shallow water Bickley jet","title":"Building a ShallowWaterModel","text":"","category":"section"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"We use grid, coriolis and gravitational_acceleration to build the model. Furthermore, we specify RungeKutta3 for time-stepping and WENO5 for advection.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"model = ShallowWaterModel(\n    timestepper=:RungeKutta3,\n    advection=WENO5(),\n    grid=grid,\n    gravitational_acceleration=g,\n    coriolis=FPlane(f=f),\n    )","category":"page"},{"location":"generated/shallow_water_Bickley_jet/#Background-state-and-perturbation","page":"Shallow water Bickley jet","title":"Background state and perturbation","text":"","category":"section"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"The background velocity u and free-surface η are chosen to represent a geostrophically balanced Bickely jet with maximum speed of U and maximum free-surface deformation of Δη, i.e.,","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"beginalign\nη(y)  = - Δη tanh(y)  \nu(y)  = U mathrmsech^2(y) \nendalign","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"The total height of the fluid is h = L_z + eta. Linear stability theory predicts that for the parameters we consider here, the growth rate for the most unstable mode that fits our domain is approximately 0139.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"We also specify ω̄ as the vorticity of the background state, ω = - _y u = 2 U mathrmsech^2(y) tanh(y).","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"h̄(x, y, z) = Lz - Δη * tanh(y)\nū(x, y, z) = U * sech(y)^2\nω̄(x, y, z) = 2 * U * sech(y)^2 * tanh(y)\nnothing # hide","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"The initial conditions include a small-amplitude perturbation that decays away from the center of the jet.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":" small_amplitude = 1e-4\n\n uⁱ(x, y, z) = ū(x, y, z) + small_amplitude * exp(-y^2) * randn()\n hⁱ(x, y, z) = h̄(x, y, z)\nuhⁱ(x, y, z) = uⁱ(x, y, z) * hⁱ(x, y, z)\nnothing # hide","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"We set the initial conditions for the zonal mass transport uhⁱ and the fluid height hⁱ.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"set!(model, uh = uhⁱ, h = hⁱ)","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"We compute the total vorticity and the perturbation vorticity.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"uh, vh, h = model.solution\n\n        u = ComputedField(uh / h)\n        v = ComputedField(vh / h)\n        ω = ComputedField(∂x(v) - ∂y(u))\n   ω_pert = ComputedField(ω - ω̄)\nnothing #hide","category":"page"},{"location":"generated/shallow_water_Bickley_jet/#Running-a-Simulation","page":"Shallow water Bickley jet","title":"Running a Simulation","text":"","category":"section"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"We pick the time-step so that we make sure we resolve the surface gravity waves, which propagate with speed of the order sqrtg L_z. That is, with Δt = 1e-2 we ensure that sqrtg L_z Δt  Δx  sqrtg L_z Δt  Δy  07.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"simulation = Simulation(model, Δt = 1e-2, stop_time = 150)","category":"page"},{"location":"generated/shallow_water_Bickley_jet/#Prepare-output-files","page":"Shallow water Bickley jet","title":"Prepare output files","text":"","category":"section"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Define a function to compute the norm of the perturbation on the cross channel velocity. We obtain the norm function from LinearAlgebra.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"using LinearAlgebra: norm\n\nfunction perturbation_norm(model)\n    compute!(v)\n    return norm(interior(v))\nend\nnothing # hide","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Choose the two fields to be output to be the total and perturbation vorticity.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"outputs = (ω_total = ω, ω_pert = ω_pert)","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Build the output_writer for the two-dimensional fields to be output. Output every t = 1.0.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"simulation.output_writers[:fields] =\n    NetCDFOutputWriter(\n        model,\n        (ω = ω, ω_pert = ω_pert),\n          filepath = joinpath(@__DIR__, \"shallow_water_Bickley_jet.nc\"),\n          schedule = TimeInterval(1.0),\n              mode = \"c\")","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Build the output_writer for the growth rate, which is a scalar field. Output every time step.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"simulation.output_writers[:growth] =\n    NetCDFOutputWriter(\n        model,\n        (perturbation_norm = perturbation_norm,),\n          filepath = joinpath(@__DIR__, \"perturbation_norm_shallow_water.nc\"),\n          schedule = IterationInterval(1),\n        dimensions = (perturbation_norm=(),),\n              mode = \"c\")","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"And finally run the simulation.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"run!(simulation)","category":"page"},{"location":"generated/shallow_water_Bickley_jet/#Visualize-the-results","page":"Shallow water Bickley jet","title":"Visualize the results","text":"","category":"section"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Load required packages to read output and plot.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"using NCDatasets, Plots, Printf\nnothing # hide","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Define the coordinates for plotting.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"x, y = xnodes(ω), ynodes(ω)\nnothing # hide","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Define keyword arguments for plotting the contours.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"kwargs = (\n         xlabel = \"x\",\n         ylabel = \"y\",\n         aspect = 1,\n           fill = true,\n         levels = 20,\n      linewidth = 0,\n          color = :balance,\n       colorbar = true,\n           ylim = (-Ly/2, Ly/2),\n           xlim = (0, Lx)\n)\nnothing # hide","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Read in the output_writer for the two-dimensional fields and then create an animation showing both the total and perturbation vorticities.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"ds = NCDataset(simulation.output_writers[:fields].filepath, \"r\")\n\niterations = keys(ds[\"time\"])\n\nanim = @animate for (iter, t) in enumerate(ds[\"time\"])\n     ω = ds[\"ω\"][:, :, 1, iter]\n    ωp = ds[\"ω_pert\"][:, :, 1, iter]\n\n    ωp_max = maximum(abs, ωp)\n\n     plot_ω = contour(x, y, ω',\n                       clim = (-1, 1),\n                      title = @sprintf(\"Total vorticity, ω, at t = %.1f\", t); kwargs...)\n\n    plot_ωp = contour(x, y, ωp',\n                       clim = (-ωp_max, ωp_max),\n                      title = @sprintf(\"Perturbation vorticity, ω - ω̄, at t = %.1f\", t); kwargs...)\n\n    plot(plot_ω, plot_ωp, layout = (1, 2), size = (800, 440))\nend\n\nclose(ds)\n\nmp4(anim, \"Bickley_Jet_ShallowWater.mp4\", fps=15)","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Read in the output_writer for the scalar field (the norm of v-velocity).","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"ds2 = NCDataset(simulation.output_writers[:growth].filepath, \"r\")\n\niterations = keys(ds2[\"time\"])\n\n     t = ds2[\"time\"][:]\nnorm_v = ds2[\"perturbation_norm\"][:]\n\nclose(ds2)\nnothing # hide","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"We import the fit function from Polynomials.jl to compute the best-fit slope of the perturbation norm on a logarithmic plot. This slope corresponds to the growth rate.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"using Polynomials: fit\n\nI = 6000:7000\n\ndegree = 1\nlinear_fit_polynomial = fit(t[I], log.(norm_v[I]), degree, var = :t)","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"We can get the coefficient of the n-th power from the fitted polynomial by using n as an index, e.g.,","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"constant, slope = linear_fit_polynomial[0], linear_fit_polynomial[1]","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"We then use the computed linear fit coefficients to construct the best fit and plot it together with the time-series for the perturbation norm for comparison.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"best_fit = @. exp(constant + slope * t)\n\nplot(t, norm_v,\n        yaxis = :log,\n        ylims = (1e-3, 30),\n           lw = 4,\n        label = \"norm(v)\",\n       xlabel = \"time\",\n       ylabel = \"norm(v)\",\n        title = \"growth of perturbation norm\",\n       legend = :bottomright)\n\nplot!(t[I], 2 * best_fit[I], # factor 2 offsets fit from curve for better visualization\n           lw = 4,\n        label = \"best fit\")","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"The slope of the best-fit curve on a logarithmic scale approximates the rate at which instability grows in the simulation. Let's see how this compares with the theoretical growth rate.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"println(\"Numerical growth rate is approximated to be \", round(slope, digits=3), \",\\n\",\n        \"which is very close to the theoretical value of 0.139.\")","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"EditURL = \"<unknown>/examples/internal_wave.jl\"","category":"page"},{"location":"generated/internal_wave/#Internal-wave-example","page":"Internal wave","title":"Internal wave example","text":"","category":"section"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"In this example, we initialize an internal wave packet in two-dimensions and watch it propagate. This example illustrates how to set up a two-dimensional model, set initial conditions, and how to use BackgroundFields.","category":"page"},{"location":"generated/internal_wave/#Install-dependencies","page":"Internal wave","title":"Install dependencies","text":"","category":"section"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"using Pkg\npkg\"add Oceananigans, JLD2, Plots\"","category":"page"},{"location":"generated/internal_wave/#The-physical-domain","page":"Internal wave","title":"The physical domain","text":"","category":"section"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"First, we pick a resolution and domain size. We use a two-dimensional domain that's periodic in (x z) and is Flat in y:","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"using Oceananigans\n\ngrid = RegularRectilinearGrid(size=(128, 128), x=(-π, π), z=(-π, π),\n                              topology=(Periodic, Flat, Periodic))","category":"page"},{"location":"generated/internal_wave/#Internal-wave-parameters","page":"Internal wave","title":"Internal wave parameters","text":"","category":"section"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"Inertia-gravity waves propagate in fluids that are both (i) rotating, and (ii) density-stratified. We use Oceananigans' Coriolis abstraction to implement a background rotation rate:","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"coriolis = FPlane(f=0.2)","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"On an FPlane, the domain is idealized as rotating at a constant rate with rotation period 2π/f. coriolis is passed to IncompressibleModel below. Our units are arbitrary.","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"We use Oceananigans' background_fields abstraction to define a background buoyancy field B(z) = N^2 * z, where z is the vertical coordinate and N is the \"buoyancy frequency\". This means that the modeled buoyancy field perturbs the basic state B(z).","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"# Background fields are functions of `x, y, z, t`, and optional parameters.\n# Here we have one parameter, the buoyancy frequency\nB_func(x, y, z, t, N) = N^2 * z\n\nN = 1 ## buoyancy frequency\n\nB = BackgroundField(B_func, parameters=N)","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"We are now ready to instantiate our model. We pass grid, coriolis, and B to the IncompressibleModel constructor. We add a small amount of IsotropicDiffusivity to keep the model stable during time-stepping, and specify that we're using a single tracer called b that we identify as buoyancy by setting buoyancy=BuoyancyTracer().","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"model = IncompressibleModel(\n                 grid = grid,\n            advection = CenteredFourthOrder(),\n          timestepper = :RungeKutta3,\n              closure = IsotropicDiffusivity(ν=1e-6, κ=1e-6),\n             coriolis = coriolis,\n              tracers = :b,\n    background_fields = (b=B,), # `background_fields` is a `NamedTuple`\n             buoyancy = BuoyancyTracer()\n)","category":"page"},{"location":"generated/internal_wave/#A-Gaussian-wavepacket","page":"Internal wave","title":"A Gaussian wavepacket","text":"","category":"section"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"Next, we set up an initial condition that excites an internal wave that propates through our rotating, stratified fluid. This internal wave has the pressure field","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"p(x y z t) = a(x z)  cos(kx + mz - ω t)  ","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"where m is the vertical wavenumber, k is the horizontal wavenumber, ω is the wave frequncy, and a(x z) is a Gaussian envelope. The internal wave dispersion relation links the wave numbers k and m, the Coriolis parameter f, and the buoyancy frequency N:","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"# Non-dimensional internal wave parameters\nm = 16      # vertical wavenumber\nk = 8       # horizontal wavenumber\nf = coriolis.f\n\n# Dispersion relation for inertia-gravity waves\nω² = (N^2 * k^2 + f^2 * m^2) / (k^2 + m^2)\n\nω = sqrt(ω²)\nnothing # hide","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"We define a Gaussian envelope for the wave packet so that we can observe wave propagation.","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"# Some Gaussian parameters\nA = 1e-9\nδ = grid.Lx / 15\n\n# A Gaussian envelope centered at ``(x, z) = (0, 0)``.\na(x, z) = A * exp( -( x^2 + z^2 ) / 2δ^2 )\nnothing # hide","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"An inertia-gravity wave is a linear solution to the Boussinesq equations. In order that our initial condition excites an inertia-gravity wave, we initialize the velocity and buoyancy perturbation fields to be consistent with the pressure field p = a  cos(kx + mx - ωt) at t=0. These relations are sometimes called the \"polarization relations\". At t=0, the polarization relations yield","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"u₀(x, y, z) = a(x, z) * k * ω   / (ω^2 - f^2) * cos(k*x + m*z)\nv₀(x, y, z) = a(x, z) * k * f   / (ω^2 - f^2) * sin(k*x + m*z)\nw₀(x, y, z) = a(x, z) * m * ω   / (ω^2 - N^2) * cos(k*x + m*z)\nb₀(x, y, z) = a(x, z) * m * N^2 / (ω^2 - N^2) * sin(k*x + m*z)\n\nset!(model, u=u₀, v=v₀, w=w₀, b=b₀)","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"Recall that the buoyancy b is a perturbation, so that the total buoyancy field is N^2 z + b.","category":"page"},{"location":"generated/internal_wave/#A-wave-packet-on-the-loose","page":"Internal wave","title":"A wave packet on the loose","text":"","category":"section"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"We're ready to release the packet. We build a simulation with a constant time-step,","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"simulation = Simulation(model, Δt = 0.1 * 2π/ω, stop_iteration = 15)","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"and add an output writer that saves the vertical velocity field every two iterations:","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"simulation.output_writers[:velocities] = JLD2OutputWriter(model, model.velocities,\n                                                          schedule = IterationInterval(1),\n                                                            prefix = \"internal_wave\",\n                                                             force = true)","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"With initial conditions set and an output writer at the ready, we run the simulation","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"run!(simulation)","category":"page"},{"location":"generated/internal_wave/#Animating-a-propagating-packet","page":"Internal wave","title":"Animating a propagating packet","text":"","category":"section"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"To visualize the solution, we load snapshots of the data and use it to make contour plots of vertical velocity.","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"using JLD2, Printf, Plots","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"We use coordinate arrays appropriate for the vertical velocity field,","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"x, y, z = nodes(model.velocities.w)\nnothing # hide","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"open the jld2 file with the data,","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"file = jldopen(simulation.output_writers[:velocities].filepath)\n\n# Extracts a vector of `iterations` at which data was saved.\niterations = parse.(Int, keys(file[\"timeseries/t\"]))","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"and makes an animation with Plots.jl:","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"anim = @animate for (i, iter) in enumerate(iterations)\n\n    @info \"Drawing frame $i from iteration $iter...\"\n\n    w = file[\"timeseries/w/$iter\"][:, 1, :]\n    t = file[\"timeseries/t/$iter\"]\n\n    contourf(x, z, w', title = @sprintf(\"ωt = %.2f\", ω * t),\n                      levels = range(-1e-8, stop=1e-8, length=10),\n                       clims = (-1e-8, 1e-8),\n                      xlabel = \"x\",\n                      ylabel = \"z\",\n                       xlims = (-π, π),\n                       ylims = (-π, π),\n                   linewidth = 0,\n                       color = :balance,\n                      legend = false,\n                 aspectratio = :equal)\nend\n\nmp4(anim, \"internal_wave.mp4\", fps = 8) # hide","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"This page was generated using Literate.jl.","category":"page"},{"location":"physics/navier_stokes_and_tracer_conservation/#Coordinate-system-and-notation","page":"Navier-Stokes and tracer conservation equations","title":"Coordinate system and notation","text":"","category":"section"},{"location":"physics/navier_stokes_and_tracer_conservation/","page":"Navier-Stokes and tracer conservation equations","title":"Navier-Stokes and tracer conservation equations","text":"Oceananigans.jl is formulated in a Cartesian coordinate system boldsymbolx = (x y z) with unit vectors boldsymbolhat x, boldsymbolhat y, and boldsymbolhat z, where boldsymbolhat x points east, boldsymbolhat y points north, and boldsymbolhat z points 'upward', opposite the direction of gravitational acceleration. We denote time with t, partial derivatives with respect to time t or a coordinate x with partial_t or partial_x, and denote the gradient operator boldsymbolnabla equiv partial_x boldsymbolhat x + partial_y boldsymbolhat y + partial_z boldsymbolhat z. We use u, v, and w to denote the east, north, and vertical velocity components, such that boldsymbolu = u boldsymbolhat x + v boldsymbolhat y + w boldsymbolhat z.","category":"page"},{"location":"physics/navier_stokes_and_tracer_conservation/#The-Boussinesq-Navier-Stokes-equations-and-tracer-conservation-equations","page":"Navier-Stokes and tracer conservation equations","title":"The Boussinesq Navier-Stokes equations and tracer conservation equations","text":"","category":"section"},{"location":"physics/navier_stokes_and_tracer_conservation/","page":"Navier-Stokes and tracer conservation equations","title":"Navier-Stokes and tracer conservation equations","text":"Oceananigans.jl solves the incompressible Navier-Stokes equations under the Boussinesq approximation[1] and an arbitrary number of tracer conservation equations. Physics associated with individual terms in the momentum and tracer conservation equations –- the background rotation rate of the equation's reference frame, gravitational effects associated with buoyant tracers under the Boussinesq approximation, generalized stresses and tracer fluxes associated with viscous and diffusive physics, and arbitrary \"forcing functions\" –- are determined by the whims of the user.","category":"page"},{"location":"physics/navier_stokes_and_tracer_conservation/","page":"Navier-Stokes and tracer conservation equations","title":"Navier-Stokes and tracer conservation equations","text":"[1]: Named after Boussinesq (1903) although used earlier by Oberbeck (1879), the Boussinesq   approximation neglects density differences in the momentum equation except when associated   with the gravitational term. It is an accurate approximation for many flows, and especially   so for oceanic flows where density differences are very small. See Vallis (2017, section 2.4)   for an oceanographic introduction to the Boussinesq equations and Vallis (2017, Section 2.A)   for an asymptotic derivation. See Kundu (2015, Section 4.9) for an engineering   introduction.","category":"page"},{"location":"physics/navier_stokes_and_tracer_conservation/","page":"Navier-Stokes and tracer conservation equations","title":"Navier-Stokes and tracer conservation equations","text":"The fluid density rho in Oceananigans.jl is, in general, decomposed into three components:","category":"page"},{"location":"physics/navier_stokes_and_tracer_conservation/","page":"Navier-Stokes and tracer conservation equations","title":"Navier-Stokes and tracer conservation equations","text":"    rho(boldsymbolx t) = rho_0 + rho_*(z) + rho(boldsymbolx t)  ","category":"page"},{"location":"physics/navier_stokes_and_tracer_conservation/","page":"Navier-Stokes and tracer conservation equations","title":"Navier-Stokes and tracer conservation equations","text":"where rho_0 is a constant 'reference' density, rho_*(z) is a background density profile which, when non-zero, is typically associated with the hydrostatic compression of seawater in the deep ocean, and rho(boldsymbolx t) is the dynamic component of density corresponding to inhomogeneous distributions of a buoyant tracer such as temperature or salinity. The fluid buoyancy, associated with the buoyant acceleration of fluid, is defined in terms of rho as","category":"page"},{"location":"physics/navier_stokes_and_tracer_conservation/","page":"Navier-Stokes and tracer conservation equations","title":"Navier-Stokes and tracer conservation equations","text":"    b = - fracg rhorho_0  ","category":"page"},{"location":"physics/navier_stokes_and_tracer_conservation/","page":"Navier-Stokes and tracer conservation equations","title":"Navier-Stokes and tracer conservation equations","text":"where g is gravitational acceleration.","category":"page"},{"location":"physics/navier_stokes_and_tracer_conservation/","page":"Navier-Stokes and tracer conservation equations","title":"Navier-Stokes and tracer conservation equations","text":"The Boussinesq approximation is valid when rho_* + rho ll rho_0, which implies the fluid is approximately incompressible, and thus does not support acoustic waves. In this case, the mass conservation equation reduces to the continuity equation","category":"page"},{"location":"physics/navier_stokes_and_tracer_conservation/","page":"Navier-Stokes and tracer conservation equations","title":"Navier-Stokes and tracer conservation equations","text":"    beginequation\n    boldsymbolnabla boldsymbolcdot boldsymbolu = partial_x u + partial_y v + partial_z w = 0  \n    labeleqcontinuity\n    endequation","category":"page"},{"location":"physics/navier_stokes_and_tracer_conservation/#The-momentum-conservation-equation","page":"Navier-Stokes and tracer conservation equations","title":"The momentum conservation equation","text":"","category":"section"},{"location":"physics/navier_stokes_and_tracer_conservation/","page":"Navier-Stokes and tracer conservation equations","title":"Navier-Stokes and tracer conservation equations","text":"The equations governing the conservation of momentum in a rotating fluid, including buoyancy via the Boussinesq approximation and including the averaged effects of surface gravity waves at the top of the domain via the Craik-Leibovich approximation are","category":"page"},{"location":"physics/navier_stokes_and_tracer_conservation/","page":"Navier-Stokes and tracer conservation equations","title":"Navier-Stokes and tracer conservation equations","text":"    beginalign\n    partial_t boldsymbolu  = - left ( boldsymbolu boldsymbolcdot boldsymbolnabla right ) boldsymbolu\n                        - left ( boldsymbolU boldsymbolcdot boldsymbolnabla right ) boldsymbolu\n                        - left ( boldsymbolu boldsymbolcdot boldsymbolnabla right ) boldsymbolU nonumber \n                         qquad\n                        - left ( boldsymbolf - boldsymbolnabla times boldsymbolu^S right ) times boldsymbolu \n                        - boldsymbolnabla phi\n                        + b boldsymbolhat z\n                        - boldsymbolnabla boldsymbolcdot boldsymboltau\n                        + partial_t boldsymbolu^S\n                        + boldsymbolF_u  \n    labeleqmomentum\n    endalign","category":"page"},{"location":"physics/navier_stokes_and_tracer_conservation/","page":"Navier-Stokes and tracer conservation equations","title":"Navier-Stokes and tracer conservation equations","text":"where b the is buoyancy, boldsymboltau is the kinematic stress tensor, boldsymbolF_u denotes an internal forcing of the velocity field boldsymbolu, phi is the potential associated with kinematic and constant hydrostatic contributions to pressure, boldsymbolu^S  is the 'Stokes drift' velocity field associated with surface gravity waves, and boldsymbolf  is the Coriolis parameter, or the background vorticity associated with the specified rate of  rotation of the frame of reference.","category":"page"},{"location":"physics/navier_stokes_and_tracer_conservation/","page":"Navier-Stokes and tracer conservation equations","title":"Navier-Stokes and tracer conservation equations","text":"The terms that appear on the right-hand side of the momentum conservation equation are (in order):","category":"page"},{"location":"physics/navier_stokes_and_tracer_conservation/","page":"Navier-Stokes and tracer conservation equations","title":"Navier-Stokes and tracer conservation equations","text":"momentum advection, left ( boldsymbolu boldsymbolcdot boldsymbolnabla right )  boldsymbolu,\nadvection of resolved momentum by the background velocity field boldsymbolU,  left ( boldsymbolU boldsymbolcdot boldsymbolnabla right ) boldsymbolu,\nadvection of background momentum by resolved velocity, left ( boldsymbolu boldsymbolcdot  boldsymbolnabla right ) boldsymbolU,\ncoriolis, boldsymbolf times boldsymbolu,\nthe effective background rotation rate due to surface waves, left ( boldsymbolnabla times  boldsymbolu^S right ) times boldsymbolu,\npressure gradient, boldsymbolnabla phi,\nbuoyant acceleration, b boldsymbolhat z,\nmolecular or turbulence viscous stress, boldsymbolnabla boldsymbolcdot boldsymboltau,\na source of momentum due to forcing or damping of surface waves, partial_t boldsymbolu^S, and\nan arbitrary internal source of momentum, boldsymbolF_u.","category":"page"},{"location":"physics/navier_stokes_and_tracer_conservation/#The-tracer-conservation-equation","page":"Navier-Stokes and tracer conservation equations","title":"The tracer conservation equation","text":"","category":"section"},{"location":"physics/navier_stokes_and_tracer_conservation/","page":"Navier-Stokes and tracer conservation equations","title":"Navier-Stokes and tracer conservation equations","text":"The conservation law for tracers in Oceananigans.jl is","category":"page"},{"location":"physics/navier_stokes_and_tracer_conservation/","page":"Navier-Stokes and tracer conservation equations","title":"Navier-Stokes and tracer conservation equations","text":"    beginalign\n    partial_t c = - boldsymbolu boldsymbolcdot boldsymbolnabla c\n                   - boldsymbolU boldsymbolcdot boldsymbolnabla c\n                   - boldsymbolu boldsymbolcdot boldsymbolnabla C\n                   - boldsymbolnabla boldsymbolcdot boldsymbolq_c\n                   + F_c  \n    labeleqtracer\n    endalign","category":"page"},{"location":"physics/navier_stokes_and_tracer_conservation/","page":"Navier-Stokes and tracer conservation equations","title":"Navier-Stokes and tracer conservation equations","text":"where boldsymbolq_c is the diffusive flux of c and F_c is an arbitrary source term. Oceananigans.jl permits arbitrary tracers and thus an arbitrary number of tracer equations to  be solved simultaneously with the momentum equations.","category":"page"},{"location":"physics/navier_stokes_and_tracer_conservation/","page":"Navier-Stokes and tracer conservation equations","title":"Navier-Stokes and tracer conservation equations","text":"From left to right, the terms that appear on the right-hand side of the tracer conservation equation are","category":"page"},{"location":"physics/navier_stokes_and_tracer_conservation/","page":"Navier-Stokes and tracer conservation equations","title":"Navier-Stokes and tracer conservation equations","text":"tracer advection, boldsymbolu boldsymbolcdot boldsymbolnabla c,\ntracer advection by the background velocity field, U, boldsymbolU boldsymbolcdot boldsymbolnabla c,\nadvection of the background tracer field, C, by the resolved velocity field, boldsymbolu boldsymbolcdot boldsymbolnabla C,\nmolecular or turbulent diffusion, boldsymbolnabla boldsymbolcdot boldsymbolq_c, and\nan arbitrary internal source of tracer, F_c.","category":"page"},{"location":"physics/navier_stokes_and_tracer_conservation/","page":"Navier-Stokes and tracer conservation equations","title":"Navier-Stokes and tracer conservation equations","text":"The following subsections provide more details on the possible forms that each individual term  in the momentum and tracer equations can take in Oceananigans.jl.","category":"page"},{"location":"library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Documenting the public user interface.","category":"page"},{"location":"library/#Advection","page":"Library","title":"Advection","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Advection]\nPrivate = false\nPages   = [\n    \"Advection.jl\",\n    \"tracer_advection_operators.jl\",\n    \"momentum_advection_operators.jl\",\n    \"centered_second_order.jl\",\n    \"centered_fourth_order.jl\"\n]","category":"page"},{"location":"library/#Oceananigans.Advection.div_Uc-NTuple{7,Any}","page":"Library","title":"Oceananigans.Advection.div_Uc","text":"div_uc(i, j, k, grid, advection, U, c)\n\nCalculates the divergence of the flux of a tracer quantity c being advected by a velocity field U = (u, v, w), ∇·(Uc),\n\n1/V * [δxᶜᵃᵃ(Ax * u * ℑxᶠᵃᵃ(c)) + δyᵃᶜᵃ(Ay * v * ℑyᵃᶠᵃ(c)) + δzᵃᵃᶜ(Az * w * ℑzᵃᵃᶠ(c))]\n\nwhich will end up at the location ccc.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Advection.div_Uu-NTuple{7,Any}","page":"Library","title":"Oceananigans.Advection.div_Uu","text":"div_Uu(i, j, k, grid, advection, U, u)\n\nCalculate the advection of momentum in the x-direction using the conservative form, ∇·(Uu)\n\n1/Vᵘ * [δxᶠᵃᵃ(ℑxᶜᵃᵃ(Ax * u) * ℑxᶜᵃᵃ(u)) + δy_fca(ℑxᶠᵃᵃ(Ay * v) * ℑyᵃᶠᵃ(u)) + δz_fac(ℑxᶠᵃᵃ(Az * w) * ℑzᵃᵃᶠ(u))]\n\nwhich will end up at the location fcc.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Advection.div_Uv-NTuple{7,Any}","page":"Library","title":"Oceananigans.Advection.div_Uv","text":"div_Uv(i, j, k, grid, advection, U, v)\n\nCalculate the advection of momentum in the y-direction using the conservative form, ∇·(Uv)\n\n1/Vʸ * [δx_cfa(ℑyᵃᶠᵃ(Ax * u) * ℑxᶠᵃᵃ(v)) + δyᵃᶠᵃ(ℑyᵃᶜᵃ(Ay * v) * ℑyᵃᶜᵃ(v)) + δz_afc(ℑxᶠᵃᵃ(Az * w) * ℑzᵃᵃᶠ(w))]\n\nwhich will end up at the location cfc.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Advection.div_Uw-NTuple{7,Any}","page":"Library","title":"Oceananigans.Advection.div_Uw","text":"div_Uw(i, j, k, grid, advection, U, w)\n\nCalculate the advection of momentum in the z-direction using the conservative form, ∇·(Uw)\n\n1/Vʷ * [δx_caf(ℑzᵃᵃᶠ(Ax * u) * ℑxᶠᵃᵃ(w)) + δy_acf(ℑzᵃᵃᶠ(Ay * v) * ℑyᵃᶠᵃ(w)) + δzᵃᵃᶠ(ℑzᵃᵃᶜ(Az * w) * ℑzᵃᵃᶜ(w))]\n\nwhich will end up at the location ccf.\n\n\n\n\n\n","category":"method"},{"location":"library/#Architectures","page":"Library","title":"Architectures","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Architectures]\nPrivate = false\nPages   = [\"Architectures.jl\"]","category":"page"},{"location":"library/#Oceananigans.Architectures.AbstractArchitecture","page":"Library","title":"Oceananigans.Architectures.AbstractArchitecture","text":"AbstractArchitecture\n\nAbstract supertype for architectures supported by Oceananigans.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Architectures.AbstractCPUArchitecture","page":"Library","title":"Oceananigans.Architectures.AbstractCPUArchitecture","text":"AbstractCPUArchitecture\n\nAbstract supertype for CPU architectures supported by Oceananigans.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Architectures.AbstractGPUArchitecture","page":"Library","title":"Oceananigans.Architectures.AbstractGPUArchitecture","text":"AbstractGPUArchitecture\n\nAbstract supertype for GPU architectures supported by Oceananigans.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Architectures.CPU","page":"Library","title":"Oceananigans.Architectures.CPU","text":"CPU <: AbstractArchitecture\n\nRun Oceananigans on one CPU node. Uses multiple threads if the environment variable JULIA_NUM_THREADS is set.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Architectures.GPU","page":"Library","title":"Oceananigans.Architectures.GPU","text":"GPU <: AbstractArchitecture\n\nRun Oceananigans on a single NVIDIA CUDA GPU.\n\n\n\n\n\n","category":"type"},{"location":"library/#Boundary-conditions","page":"Library","title":"Boundary conditions","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.BoundaryConditions]\nPrivate = false\nPages   = [\n    \"BoundaryConditions/BoundaryConditions.jl\",\n    \"BoundaryConditions/boundary_condition_types.jl\",\n    \"BoundaryConditions/boundary_condition.jl\",\n    \"BoundaryConditions/coordinate_boundary_conditions.jl\",\n    \"BoundaryConditions/field_boundary_conditions.jl\",\n    \"BoundaryConditions/boundary_function.jl\",\n    \"BoundaryConditions/parameterized_boundary_condition.jl\",\n    \"BoundaryConditions/show_boundary_conditions.jl\",\n    \"BoundaryConditions/fill_halo_regions.jl\",\n    \"BoundaryConditions/apply_flux_bcs.jl\",\n    \"BoundaryConditions/apply_value_gradient_bcs.jl\",\n    \"BoundaryConditions/apply_normal_flow_bcs.jl\"\n]","category":"page"},{"location":"library/#Oceananigans.BoundaryConditions.BCType","page":"Library","title":"Oceananigans.BoundaryConditions.BCType","text":"BCType\n\nAbstract supertype for boundary condition types.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.BoundaryConditions.Flux","page":"Library","title":"Oceananigans.BoundaryConditions.Flux","text":"Flux\n\nA type specifying a boundary condition on the flux of a field.\n\nThe sign convention is such that a positive flux represents the flux of a quantity in the positive direction. For example, a positive vertical flux implies a quantity is fluxed upwards, in the +z direction.\n\nDue to this convention, a positive flux applied to the top boundary specifies that a quantity is fluxed upwards across the top boundary and thus out of the domain. As a result, a positive flux applied to a top boundary leads to a reduction of that quantity in the interior of the domain; for example, a positive, upwards flux of heat at the top of the domain acts to cool the interior of the domain. Conversely, a positive flux applied to the bottom boundary leads to an increase of the quantity in the interior of the domain. The same logic holds for east, west, north, and south boundaries.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.BoundaryConditions.Gradient","page":"Library","title":"Oceananigans.BoundaryConditions.Gradient","text":"Gradient\n\nA type specifying a boundary condition on the derivative or gradient of a field. Also called a Neumann boundary condition.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.BoundaryConditions.NormalFlow","page":"Library","title":"Oceananigans.BoundaryConditions.NormalFlow","text":"NormalFlow\n\nA type specifying the component of a velocity field normal to a boundary.\n\nThus NormalFlow can only be applied to u along x, v along y, or w along z. For all other cases –- fields located at (Center, Center, Center), or u, v, and w in (y, z), (x, z), and (x, y), respectively, either Value, Gradient, or Flux conditions must be used.\n\nNote that NormalFlow differs from a zero Value boundary condition:  Value imposes values at cell centers, while NormalFlow imposes values on a boundary, at cell faces. Only wall-normal components of the velocity field are defined on cell faces with respect to the wall-normal direction, and therefore only wall-normal components of the velocity field are defined on boundaries.  Both tracers and wall-tangential components of velocity fields are defined at cell centers with respect to the wall-normal direction.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.BoundaryConditions.Value","page":"Library","title":"Oceananigans.BoundaryConditions.Value","text":"Value\n\nA type specifying a boundary condition on the value of a field. Also called a Dirchlet boundary condition.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.BoundaryConditions.BoundaryCondition","page":"Library","title":"Oceananigans.BoundaryConditions.BoundaryCondition","text":"struct BoundaryCondition{C<:BCType, T}\n\nContainer for boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.BoundaryConditions.BoundaryCondition-Tuple{Any,Any}","page":"Library","title":"Oceananigans.BoundaryConditions.BoundaryCondition","text":"BoundaryCondition(BC, condition)\n\nConstruct a boundary condition of type BC with a number or array as a condition.\n\nBoundary condition types include Periodic, Flux, Value, Gradient, and NormalFlow.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.BoundaryConditions.BoundaryCondition-Tuple{Any,Function}","page":"Library","title":"Oceananigans.BoundaryConditions.BoundaryCondition","text":"BoundaryCondition(BC, condition::Function; parameters=nothing, discrete_form=false)\n\nConstruct a boundary condition of type BC with a function boundary condition.\n\nBy default, the function boudnary condition is assumed to have the 'continuous form' condition(ξ, η, t), where t is time and ξ and η vary along the boundary. In particular:\n\nOn x-boundaries, condition(y, z, t).\nOn y-boundaries, condition(x, z, t).\nOn z-boundaries, condition(x, y, t).\n\nIf parameters is not nothing, then function boundary conditions have the form func(ξ, η, t, parameters), where ξ and η are spatial coordinates varying along the boundary as explained above.\n\nIf discrete_form=true, the function condition is assumed to have the \"discrete form\",\n\n`condition(i, j, grid, clock, model_fields)`,\n\nwhere i, and j are indices that vary along the boundary. If discrete_form=true and parameters is not nothing, the function condition is called with\n\n`condition(i, j, grid, clock, model_fields, parameters)`.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.BoundaryConditions.CoordinateBoundaryConditions","page":"Library","title":"Oceananigans.BoundaryConditions.CoordinateBoundaryConditions","text":"CoordinateBoundaryConditions(left, right)\n\nA set of two BoundaryConditions to be applied along a coordinate x, y, or z.\n\nThe left boundary condition is applied on the negative or lower side of the coordinate while the right boundary condition is applied on the positive or higher side.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.BoundaryConditions.FieldBoundaryConditions","page":"Library","title":"Oceananigans.BoundaryConditions.FieldBoundaryConditions","text":"FieldBoundaryConditions\n\nAn alias for NamedTuple{(:x, :y, :z)} that represents a set of three CoordinateBoundaryConditions applied to a field along x, y, and z.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.BoundaryConditions.FieldBoundaryConditions-Tuple{Any,Any,Any}","page":"Library","title":"Oceananigans.BoundaryConditions.FieldBoundaryConditions","text":"FieldBoundaryConditions(x, y, z)\n\nConstruct a FieldBoundaryConditions using a CoordinateBoundaryCondition for each of the x, y, and z coordinates.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.BoundaryConditions.FieldBoundaryConditions-Tuple{Any,Any}","page":"Library","title":"Oceananigans.BoundaryConditions.FieldBoundaryConditions","text":"FieldBoundaryConditions(grid, loc;   east = DefaultBoundaryCondition(topology(grid, 1), loc[1]),\n                                     west = DefaultBoundaryCondition(topology(grid, 1], loc[1]),\n                                    south = DefaultBoundaryCondition(topology(grid, 2), loc[2]),\n                                    north = DefaultBoundaryCondition(topology(grid, 2), loc[2]),\n                                   bottom = DefaultBoundaryCondition(topology(grid, 3), loc[3]),\n                                      top = DefaultBoundaryCondition(topology(grid, 3), loc[3]))\n\nConstruct FieldBoundaryConditions for a field with location loc (a 3-tuple of Face or Center) defined on grid.\n\nBoundary conditions on x-, y-, and z-boundaries are specified via keyword arguments:\n\n* `west` and `east` for the `-x` and `+x` boundary;\n* `south` and `north` for the `-y` and `+y` boundary;\n* `bottom` and `top` for the `-z` and `+z` boundary.\n\nDefault boundary conditions depend on topology(grid) and loc.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.BoundaryConditions.TracerBoundaryConditions-Tuple{Any}","page":"Library","title":"Oceananigans.BoundaryConditions.TracerBoundaryConditions","text":"TracerBoundaryConditions(grid;   east = DefaultBoundaryCondition(topology(grid, 1), Center),\n                                 west = DefaultBoundaryCondition(topology(grid, 1), Center),\n                                south = DefaultBoundaryCondition(topology(grid, 2), Center),\n                                north = DefaultBoundaryCondition(topology(grid, 2), Center),\n                               bottom = DefaultBoundaryCondition(topology(grid, 3), Center),\n                                  top = DefaultBoundaryCondition(topology(grid, 3), Center))\n\nConstruct FieldBoundaryConditions for a tracer field on grid. Boundary conditions on x-, y-, and z-boundaries are specified via keyword arguments:\n\n* `west` and `east` for the `-x` and `+x` boundary;\n* `south` and `north` for the `-y` and `+y` boundary;\n* `bottom` and `top` for the `-z` and `+z` boundary.\n\nDefault boundary conditions depend on topology(grid). See DefaultBoundaryCondition.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.BoundaryConditions.UVelocityBoundaryConditions-Tuple{Any}","page":"Library","title":"Oceananigans.BoundaryConditions.UVelocityBoundaryConditions","text":"UVelocityBoundaryConditions(grid;   east = DefaultBoundaryCondition(topology(grid, 1), Face),\n                                    west = DefaultBoundaryCondition(topology(grid, 1), Face),\n                                   south = DefaultBoundaryCondition(topology(grid, 2), Center),\n                                   north = DefaultBoundaryCondition(topology(grid, 2), Center),\n                                  bottom = DefaultBoundaryCondition(topology(grid, 3), Center),\n                                     top = DefaultBoundaryCondition(topology(grid, 3), Center))\n\nConstruct FieldBoundaryConditions for the u-velocity field on grid. Boundary conditions on x-, y-, and z-boundaries are specified via keyword arguments:\n\n* `west` and `east` for the `-x` and `+x` boundary;\n* `south` and `north` for the `-y` and `+y` boundary;\n* `bottom` and `top` for the `-z` and `+z` boundary.\n\nDefault boundary conditions depend on topology(grid). See DefaultBoundaryCondition.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.BoundaryConditions.VVelocityBoundaryConditions-Tuple{Any}","page":"Library","title":"Oceananigans.BoundaryConditions.VVelocityBoundaryConditions","text":"VVelocityBoundaryConditions(grid;   east = DefaultBoundaryCondition(topology(grid, 1), Center),\n                                    west = DefaultBoundaryCondition(topology(grid, 1), Center),\n                                   south = DefaultBoundaryCondition(topology(grid, 2), Face),\n                                   north = DefaultBoundaryCondition(topology(grid, 2), Face),\n                                  bottom = DefaultBoundaryCondition(topology(grid, 3), Center),\n                                     top = DefaultBoundaryCondition(topology(grid, 3), Center))\n\nConstruct FieldBoundaryConditions for the v-velocity field on grid. Boundary conditions on x-, y-, and z-boundaries are specified via keyword arguments:\n\n* `west` and `east` for the `-x` and `+x` boundary;\n* `south` and `north` for the `-y` and `+y` boundary;\n* `bottom` and `top` for the `-z` and `+z` boundary.\n\nDefault boundary conditions depend on topology(grid). See DefaultBoundaryCondition.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.BoundaryConditions.WVelocityBoundaryConditions-Tuple{Any}","page":"Library","title":"Oceananigans.BoundaryConditions.WVelocityBoundaryConditions","text":"WVelocityBoundaryConditions(grid;   east = DefaultBoundaryCondition(topology(grid, 1), Center),\n                                    west = DefaultBoundaryCondition(topology(grid, 1), Center),\n                                   south = DefaultBoundaryCondition(topology(grid, 2), Center),\n                                   north = DefaultBoundaryCondition(topology(grid, 2), Center),\n                                  bottom = DefaultBoundaryCondition(topology(grid, 3), Face),\n                                     top = DefaultBoundaryCondition(topology(grid, 3), Face))\n\nConstruct FieldBoundaryConditions for the w-velocity field on grid. Boundary conditions on x-, y-, and z-boundaries are specified via keyword arguments:\n\n* `west` and `east` for the `-x` and `+x` boundary;\n* `south` and `north` for the `-y` and `+y` boundary;\n* `bottom` and `top` for the `-z` and `+z` boundary.\n\nDefault boundary conditions depend on topology(grid). See DefaultBoundaryCondition.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.BoundaryConditions.fill_halo_regions!-Tuple{OffsetArrays.OffsetArray,Any,Any,Any,Vararg{Any,N} where N}","page":"Library","title":"Oceananigans.BoundaryConditions.fill_halo_regions!","text":"Fill halo regions in x, y, and z for a given field's data.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.BoundaryConditions.fill_halo_regions!-Tuple{Union{Tuple, NamedTuple},Any,Vararg{Any,N} where N}","page":"Library","title":"Oceananigans.BoundaryConditions.fill_halo_regions!","text":"fill_halo_regions!(fields, arch)\n\nFill halo regions for each field in the tuple fields according to their boundary conditions, possibly recursing into fields if it is a nested tuple-of-tuples.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.BoundaryConditions.apply_x_bcs!-Tuple{Any,Any,Any,Any,Vararg{Any,N} where N}","page":"Library","title":"Oceananigans.BoundaryConditions.apply_x_bcs!","text":"apply_x_bcs!(Gc, arch, grid, args...)\n\nApply flux boundary conditions to a field c by adding the associated flux divergence to the source term Gc at the left and right.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.BoundaryConditions.apply_y_bcs!-Tuple{Any,Any,Any,Any,Vararg{Any,N} where N}","page":"Library","title":"Oceananigans.BoundaryConditions.apply_y_bcs!","text":"apply_y_bcs!(Gc, arch, grid, args...)\n\nApply flux boundary conditions to a field c by adding the associated flux divergence to the source term Gc at the left and right.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.BoundaryConditions.apply_z_bcs!-Tuple{Any,Any,Any,Any,Vararg{Any,N} where N}","page":"Library","title":"Oceananigans.BoundaryConditions.apply_z_bcs!","text":"apply_z_bcs!(Gc, arch, grid, args...)\n\nApply flux boundary conditions to a field c by adding the associated flux divergence to the source term Gc at the top and bottom.\n\n\n\n\n\n","category":"method"},{"location":"library/#BuoyancyModels","page":"Library","title":"BuoyancyModels","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.BuoyancyModels]\nPrivate = false\nPages   = [\n    \"BuoyancyModels/no_buoyancy.jl\",\n    \"BuoyancyModels/buoyancy_tracer.jl\",\n    \"BuoyancyModels/seawater_buoyancy.jl\",\n    \"BuoyancyModels/BuoyancyModels.jl\",\n    \"BuoyancyModels/linear_equation_of_state.jl\",\n    \"BuoyancyModels/nonlinear_equation_of_state.jl\",\n    \"BuoyancyModels/roquet_idealized_nonlinear_eos.jl\",\n    \"BuoyancyModels/show_buoyancy.jl\",\n    \"BuoyancyModels/buoyancy_utils.jl\"\n]","category":"page"},{"location":"library/#Oceananigans.BuoyancyModels.BuoyancyTracer","page":"Library","title":"Oceananigans.BuoyancyModels.BuoyancyTracer","text":"BuoyancyTracer <: AbstractBuoyancyModel{Nothing}\n\nType indicating that the tracer b represents buoyancy.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.BuoyancyModels.SeawaterBuoyancy","page":"Library","title":"Oceananigans.BuoyancyModels.SeawaterBuoyancy","text":"SeawaterBuoyancy{FT, EOS, T, S} <: AbstractBuoyancyModel{EOS}\n\nBuoyancyModels model for seawater. T and S are either nothing if both temperature and salinity are active, or of type FT if temperature or salinity are constant, respectively.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.BuoyancyModels.SeawaterBuoyancy-2","page":"Library","title":"Oceananigans.BuoyancyModels.SeawaterBuoyancy","text":"SeawaterBuoyancy([FT=Float64;] gravitational_acceleration = g_Earth,\n                              equation_of_state = LinearEquationOfState(FT),\n                              constant_temperature = false, constant_salinity = false)\n\nReturns parameters for a temperature- and salt-stratified seawater buoyancy model with a gravitational_acceleration constant (typically called 'g'), and an equation_of_state that related temperature and salinity (or conservative temperature and absolute salinity) to density anomalies and buoyancy.\n\nconstant_temperature indicates that buoyancy depends only on salinity. For a nonlinear equation of state, constant_temperature is used as the temperature of the system. true. The same logic with the role of salinity and temperature reversed holds when constant_salinity is provided.\n\nFor a linear equation of state, the values of constant_temperature or constant_salinity are irrelevant; in this case, constant_temperature=true (and similar for constant_salinity) is valid input.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.BuoyancyModels.∂x_b-Tuple{Any,Any,Any,Any,SeawaterBuoyancy,Any}","page":"Library","title":"Oceananigans.BuoyancyModels.∂x_b","text":"∂x_b(i, j, k, grid, b::SeawaterBuoyancy, C)\n\nReturns the x-derivative of buoyancy for temperature and salt-stratified water,\n\n_x b = g ( α _x Θ - β _x sᴬ ) \n\nwhere g is gravitational acceleration, α is the thermal expansion coefficient, β is the haline contraction coefficient, Θ is conservative temperature, and sᴬ is absolute salinity.\n\nNote: In Oceananigans, model.tracers.T is conservative temperature and model.tracers.S is absolute salinity.\n\nNote that ∂x_Θ, ∂x_sᴬ, α, and β are all evaluated at cell interfaces in x and cell centers in y and z.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.BuoyancyModels.∂y_b-Tuple{Any,Any,Any,Any,SeawaterBuoyancy,Any}","page":"Library","title":"Oceananigans.BuoyancyModels.∂y_b","text":"∂y_b(i, j, k, grid, b::SeawaterBuoyancy, C)\n\nReturns the y-derivative of buoyancy for temperature and salt-stratified water,\n\n_y b = g ( α _y Θ - β _y sᴬ ) \n\nwhere g is gravitational acceleration, α is the thermal expansion coefficient, β is the haline contraction coefficient, Θ is conservative temperature, and sᴬ is absolute salinity.\n\nNote: In Oceananigans, model.tracers.T is conservative temperature and model.tracers.S is absolute salinity.\n\nNote that ∂y_Θ, ∂y_sᴬ, α, and β are all evaluated at cell interfaces in y and cell centers in x and z.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.BuoyancyModels.∂z_b-Tuple{Any,Any,Any,Any,SeawaterBuoyancy,Any}","page":"Library","title":"Oceananigans.BuoyancyModels.∂z_b","text":"∂z_b(i, j, k, grid, b::SeawaterBuoyancy, C)\n\nReturns the vertical derivative of buoyancy for temperature and salt-stratified water,\n\n_z b = N^2 = g ( α _z Θ - β _z sᴬ ) \n\nwhere g is gravitational acceleration, α is the thermal expansion coefficient, β is the haline contraction coefficient, Θ is conservative temperature, and sᴬ is absolute salinity.\n\nNote: In Oceananigans, model.tracers.T is conservative temperature and model.tracers.S is absolute salinity.\n\nNote that ∂z_Θ, ∂z_sᴬ, α, and β are all evaluated at cell interfaces in z and cell centers in x and y.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.BuoyancyModels.LinearEquationOfState","page":"Library","title":"Oceananigans.BuoyancyModels.LinearEquationOfState","text":"LinearEquationOfState{FT} <: AbstractEquationOfState\n\nLinear equation of state for seawater.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.BuoyancyModels.LinearEquationOfState-2","page":"Library","title":"Oceananigans.BuoyancyModels.LinearEquationOfState","text":"LinearEquationOfState([FT=Float64;] α=1.67e-4, β=7.80e-4)\n\nReturns parameters for a linear equation of state for seawater with thermal expansion coefficient α [K⁻¹] and haline contraction coefficient β [ppt⁻¹]. The buoyancy perturbation associated with a linear equation of state is\n\n    b = g (α T - β S)\n\nDefault constants are taken from Table 1.2 (page 33) of Vallis, \"Atmospheric and Oceanic Fluid Dynamics: Fundamentals and Large-Scale Circulation\" (2ed, 2017).\n\n\n\n\n\n","category":"type"},{"location":"library/#Coriolis","page":"Library","title":"Coriolis","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Coriolis]\nPrivate = false\nPages   = [\n    \"Coriolis/Coriolis.jl\",\n    \"Coriolis/no_rotation.jl\",\n    \"Coriolis/f_plane.jl\",\n    \"Coriolis/beta_plane.jl\",\n    \"Coriolis/non_traditional_f_plane.jl\",\n    \"Coriolis/non_traditional_beta_plane.jl\"\n]","category":"page"},{"location":"library/#Oceananigans.Coriolis.FPlane","page":"Library","title":"Oceananigans.Coriolis.FPlane","text":"FPlane{FT} <: AbstractRotation\n\nA parameter object for constant rotation around a vertical axis.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Coriolis.FPlane-2","page":"Library","title":"Oceananigans.Coriolis.FPlane","text":"FPlane([FT=Float64;] f=nothing, rotation_rate=Ω_Earth, latitude=nothing)\n\nReturns a parameter object for constant rotation at the angular frequency f/2, and therefore with background vorticity f, around a vertical axis. If f is not specified, it is calculated from rotation_rate and latitude according to the relation `f = 2rotation_ratesind(latitude).\n\nBy default, rotation_rate is assumed to be Earth's.\n\nAlso called FPlane, after the \"f-plane\" approximation for the local effect of a planet's rotation in a planar coordinate system tangent to the planet's surface.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Coriolis.BetaPlane","page":"Library","title":"Oceananigans.Coriolis.BetaPlane","text":"BetaPlane{T} <: AbstractRotation\n\nA parameter object for meridionally increasing Coriolis parameter (f = f₀ + βy) that accounts for the variation of the locally vertical component of the rotation vector with latitude.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Coriolis.BetaPlane-2","page":"Library","title":"Oceananigans.Coriolis.BetaPlane","text":"BetaPlane([T=Float64;] f₀=nothing, β=nothing,\n                       rotation_rate=Ω_Earth, latitude=nothing, radius=R_Earth)\n\nThe user may specify both f₀ and β, or the three parameters rotation_rate, latitude, and radius that specify the rotation rate and radius of a planet, and the central latitude (where y = 0) at which the β-plane approximation is to be made.\n\nBy default, the rotation_rate and planet radius is assumed to be Earth's.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Coriolis.NonTraditionalFPlane","page":"Library","title":"Oceananigans.Coriolis.NonTraditionalFPlane","text":"NonTraditionalFPlane{FT} <: AbstractRotation\n\nA Coriolis implementation that accounts for both the locally vertical and the locally horizontal components of the rotation vector. Traditionally (see FPlane) only the locally vertical component is accounted for.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Coriolis.NonTraditionalFPlane-2","page":"Library","title":"Oceananigans.Coriolis.NonTraditionalFPlane","text":"NonTraditionalFPlane([FT=Float64;] fz=nothing, fy=nothing,\n                                   rotation_rate=Ω_Earth, latitude=nothing)\n\nReturns a parameter object for constant rotation about an axis in the y-z plane with y- and z-components fy/2 and fz/2, and the background vorticity is (0, fy, fz).\n\nIn oceanography fz and fy represent the components of planetary voriticity which are perpendicular and parallel to the ocean surface in a domain in which x, y, z correspond to the directions east, north, and up.\n\nIf fz and fy are not specified, they are calculated from rotation_rate and latitude according to the relations fz = 2*rotation_rate*sind(latitude) and fy = 2*rotation_rate*cosd(latitude), respectively. By default, rotation_rate is assumed to be Earth's.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Coriolis.NonTraditionalBetaPlane","page":"Library","title":"Oceananigans.Coriolis.NonTraditionalBetaPlane","text":"NonTraditionalBetaPlane{FT} <: AbstractRotation\n\nA Coriolis implementation that accounts for the latitudinal variation of both the locally vertical and the locally horizontal components of the rotation vector. The \"traditional\" approximation in ocean models accounts for only the locally vertical component of the rotation vector (see BetaPlane).\n\nThis implementation is based off of section 5 of Dellar (2011). It conserve energy, angular momentum, and potential vorticity.\n\nReferences\n\nDellar, P. (2011). Variations on a beta-plane: Derivation of non-traditional     beta-plane equations from Hamilton's principle on a sphere. Journal of     Fluid Mechanics, 674, 174-195. doi:10.1017/S0022112010006464\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Coriolis.NonTraditionalBetaPlane-2","page":"Library","title":"Oceananigans.Coriolis.NonTraditionalBetaPlane","text":"NonTraditionalBetaPlane(FT=Float64;\n    fz=nothing, fy=nothing, β=nothing, γ=nothing,\n    rotation_rate=Ω_Earth, latitude=nothing, radius=R_Earth)\n\nThe user may directly specify fz, fy, β, γ, and radius or the three parameters rotation_rate, latitude, and radius that specify the rotation rate and radius of a planet, and the central latitude (where y = 0) at which the non-traditional β-plane approximation is to be made.\n\nBy default, the rotation_rate and planet radius is assumed to be Earth's.\n\n\n\n\n\n","category":"type"},{"location":"library/#Diagnostics","page":"Library","title":"Diagnostics","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Diagnostics]\nPrivate = false\nPages   = [\n    \"Diagnostics/Diagnostics.jl\",\n    \"Diagnostics/diagnostics_kernels.jl\",\n    \"Diagnostics/average.jl\",\n    \"Diagnostics/time_series.jl\",\n    \"Diagnostics/cfl.jl\",\n    \"Diagnostics/field_maximum.jl\",\n    \"Diagnostics/nan_checker.jl\"\n]","category":"page"},{"location":"library/#Oceananigans.Diagnostics.CFL","page":"Library","title":"Oceananigans.Diagnostics.CFL","text":"CFL{D, S}\n\nAn object for computing the Courant-Freidrichs-Lewy (CFL) number.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Diagnostics.CFL-Tuple{Any}","page":"Library","title":"Oceananigans.Diagnostics.CFL","text":"CFL(Δt [, timescale=Oceananigans.cell_advection_timescale])\n\nReturns an object for computing the Courant-Freidrichs-Lewy (CFL) number associated with time step or TimeStepWizard Δt and timescale.\n\nSee also AdvectiveCFL and DiffusiveCFL.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Diagnostics.AdvectiveCFL-Tuple{Any}","page":"Library","title":"Oceananigans.Diagnostics.AdvectiveCFL","text":"AdvectiveCFL(Δt)\n\nReturns an object for computing the Courant-Freidrichs-Lewy (CFL) number associated with time step or TimeStepWizard Δt and the time scale for advection across a cell.\n\nExample\n\njulia> model = IncompressibleModel(grid=RegularRectilinearGrid(size=(16, 16, 16), length=(8, 8, 8)));\n\njulia> cfl = AdvectiveCFL(1.0);\n\njulia> data(model.velocities.u) .= π;\n\njulia> cfl(model)\n6.283185307179586\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Diagnostics.DiffusiveCFL-Tuple{Any}","page":"Library","title":"Oceananigans.Diagnostics.DiffusiveCFL","text":"DiffusiveCFL(Δt)\n\nReturns an object for computing the diffusive Courant-Freidrichs-Lewy (CFL) number associated with time step or TimeStepWizard Δt and the time scale for diffusion across a cell associated with model.closure.\n\nThe maximum diffusive CFL number among viscosity and all tracer diffusivities is returned.\n\nExample\n\njulia> model = IncompressibleModel(grid=RegularRectilinearGrid(size=(16, 16, 16), length=(1, 1, 1)));\n\njulia> dcfl = DiffusiveCFL(0.1);\n\njulia> dcfl(model)\n2.688e-5\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Diagnostics.NaNChecker","page":"Library","title":"Oceananigans.Diagnostics.NaNChecker","text":"NaNChecker(; schedule, fields)\n\nReturns a NaNChecker that checks for a NaN anywhere in fields when schedule actuates. fields should be a named tuple. The simulation is aborted if a NaN is found.\n\n\n\n\n\n","category":"type"},{"location":"library/#Fields","page":"Library","title":"Fields","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Fields]\nPrivate = false\nPages   = [\n    \"Fields/Fields.jl\",\n    \"Fields/field.jl\",\n    \"Fields/set!.jl\",\n    \"Fields/show_fields.jl\",\n    \"Fields/field_utils.jl\"\n]","category":"page"},{"location":"library/#Oceananigans.Fields.Field","page":"Library","title":"Oceananigans.Fields.Field","text":"Field(X, Y, Z, [arch = CPU()], grid,\n      [ bcs = FieldBoundaryConditions(grid, (X, Y, Z)),\n       data = new_data(eltype(grid), arch, grid, (X, Y, Z))])\n\nConstruct a Field on grid with data on architecture arch with boundary conditions bcs. Each of (X, Y, Z) is either Center or Face and determines the field's location in (x, y, z).\n\nExample\n\njulia> using Oceananigans, Oceananigans.Grids\n\njulia> ω = Field(Face, Face, Center, CPU(), RegularRectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)))\nField located at (Face, Face, Center)\n├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (1, 1, 1)\n├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1)\n└── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, north=Periodic), z=(bottom=ZeroFlux, top=ZeroFlux)\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Fields.Field-Tuple{Tuple,Vararg{Any,N} where N}","page":"Library","title":"Oceananigans.Fields.Field","text":"Field(L::Tuple, arch, grid, data, bcs)\n\nConstruct a Field at the location defined by the 3-tuple L, whose elements are Center or Face.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Fields.CenterField","page":"Library","title":"Oceananigans.Fields.CenterField","text":"CenterField([arch=CPU()], grid\n            bcs = TracerBoundaryConditions(grid),\n            data = new_data(eltype(grid), arch, grid, (Center, Center, Center)))\n\nReturn a Field{Center, Center, Center} on architecture arch and grid containing data with field boundary conditions bcs.\n\n\n\n\n\n","category":"function"},{"location":"library/#Oceananigans.Fields.XFaceField","page":"Library","title":"Oceananigans.Fields.XFaceField","text":"XFaceField([arch=CPU()], grid\n           bcs = UVelocityBoundaryConditions(grid),\n           data = new_data(eltype(grid), arch, grid, (Face, Center, Center)))\n\nReturn a Field{Face, Center, Center} on architecture arch and grid containing data with field boundary conditions bcs.\n\n\n\n\n\n","category":"function"},{"location":"library/#Oceananigans.Fields.YFaceField","page":"Library","title":"Oceananigans.Fields.YFaceField","text":"YFaceField([arch=CPU()], grid,\n           bcs = VVelocityBoundaryConditions(grid),\n           data = new_data(eltype(grid), arch, grid, (Center, Face, Center)))\n\nReturn a Field{Center, Face, Center} on architecture arch and grid containing data with field boundary conditions bcs.\n\n\n\n\n\n","category":"function"},{"location":"library/#Oceananigans.Fields.ZFaceField","page":"Library","title":"Oceananigans.Fields.ZFaceField","text":"ZFaceField([arch=CPU()], grid\n           bcs = WVelocityBoundaryConditions(grid),\n           data = new_data(eltype(grid), arch, grid, (Center, Center, Face)))\n\nReturn a Field{Center, Center, Face} on architecture arch and grid containing data with field boundary conditions bcs.\n\n\n\n\n\n","category":"function"},{"location":"library/#Oceananigans.Fields.set!-Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,var\"#s167\",G,T,N} where N where T where G<:Union{Nothing, AbstractGrid} where var\"#s167\"<:Oceananigans.Architectures.AbstractCPUArchitecture where Z where Y where X,Function}","page":"Library","title":"Oceananigans.Fields.set!","text":"Set the CPU field u data to the function f(x, y, z). \n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Fields.set!-Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,var\"#s167\",G,T,N} where N where T where G<:Union{Nothing, AbstractGrid} where var\"#s167\"<:Oceananigans.Architectures.AbstractCPUArchitecture where Z where Y where X,Oceananigans.Fields.AbstractField{X,Y,Z,var\"#s167\",G,T,N} where N where T where G<:Union{Nothing, AbstractGrid} where var\"#s167\"<:Oceananigans.Architectures.AbstractGPUArchitecture where Z where Y where X}","page":"Library","title":"Oceananigans.Fields.set!","text":"Set the CPU field u data to the GPU field data of v. \n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Fields.set!-Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,var\"#s167\",G,T,N} where N where T where G<:Union{Nothing, AbstractGrid} where var\"#s167\"<:Oceananigans.Architectures.AbstractGPUArchitecture where Z where Y where X,Oceananigans.Fields.AbstractField{X,Y,Z,var\"#s167\",G,T,N} where N where T where G<:Union{Nothing, AbstractGrid} where var\"#s167\"<:Oceananigans.Architectures.AbstractCPUArchitecture where Z where Y where X}","page":"Library","title":"Oceananigans.Fields.set!","text":"Set the GPU field u data to the CPU field data of v. \n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Fields.set!-Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,var\"#s167\",G,T,N} where N where T where G<:Union{Nothing, AbstractGrid} where var\"#s167\"<:Oceananigans.Architectures.AbstractGPUArchitecture where Z where Y where X,Union{Function, Array}}","page":"Library","title":"Oceananigans.Fields.set!","text":"Set the GPU field u to the array or function v. \n\n\n\n\n\n","category":"method"},{"location":"library/#Forcings","page":"Library","title":"Forcings","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Forcings]\nPrivate = false\nPages   = [\n    \"Forcings/Forcings.jl\",\n    \"Forcings/continuous_forcing.jl\",\n    \"Forcings/discrete_forcing.jl\",\n    \"Forcings/forcing.jl\",\n    \"Forcings/model_forcing.jl\",\n    \"Forcings/relaxation.jl\"\n]","category":"page"},{"location":"library/#Oceananigans.Forcings.ContinuousForcing","page":"Library","title":"Oceananigans.Forcings.ContinuousForcing","text":"ContinuousForcing{LX, LY, LZ, P, F, D, I}\n\nA callable object that implements a \"continuous form\" forcing function on a field at the location LX, LY, LZ with optional parameters.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Forcings.ContinuousForcing-Tuple{Any}","page":"Library","title":"Oceananigans.Forcings.ContinuousForcing","text":"ContinuousForcing(func; parameters=nothing, field_dependencies=())\n\nConstruct a \"continuous form\" forcing with optional parameters and optional field_dependencies on other fields in a model.\n\nIf neither parameters nor field_dependencies are provided, then func must be callable with the signature\n\n`func(x, y, z, t)`\n\nwhere x, y, z are the east-west, north-south, and vertical spatial coordinates, and t is time.\n\nIf field_dependencies are provided, the signature of func must include them. For example, if field_dependencies=(:u, :S) (and parameters are not provided), then func must be callable with the signature\n\n`func(x, y, z, t, u, S)`\n\nwhere u is assumed to be the u-velocity component, and S is a tracer. Note that any field which does not have the name u, v, or w is assumed to be a tracer and must be present in model.tracers.\n\nIf parameters are provided, then the last argument to func must be parameters. For example, if func has no field_dependencies but does depend on parameters, then it must be callable with the signature\n\n`func(x, y, z, t, parameters)`\n\nWith field_dependencies=(:u, :v, :w, :c) and parameters, then func must be callable with the signature\n\n`func(x, y, z, t, u, v, w, c, parameters)`\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Forcings.DiscreteForcing","page":"Library","title":"Oceananigans.Forcings.DiscreteForcing","text":"struct DiscreteForcing{P, F}\n\nWrapper for \"discrete form\" forcing functions with optional parameters.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Forcings.DiscreteForcing-Tuple{Any}","page":"Library","title":"Oceananigans.Forcings.DiscreteForcing","text":"DiscreteForcing(func; parameters=nothing)\n\nConstruct a \"discrete form\" forcing function with optional parameters. The forcing function is applied at grid point i, j, k.\n\nWhen parameters are not specified, func must be callable with the signature\n\n`func(i, j, k, grid, clock, model_fields)`\n\nwhere grid is model.grid, clock.time is the current simulation time and clock.iteration is the current model iteration, and model_fields is a NamedTuple with u, v, w and the fields in model.tracers.\n\nNote that the index end does not access the final physical grid point of a model field in any direction. The final grid point must be explicitly specified, as in model_fields.u[i, j, grid.Nz].\n\nWhen parameters is specified, func must be callable with the signature.\n\n`func(i, j, k, grid, clock, model_fields, parameters)`\n\nparameters is arbitrary in principle, however GPU compilation can place constraints on typeof(parameters).\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Forcings.Forcing-Tuple{Any}","page":"Library","title":"Oceananigans.Forcings.Forcing","text":"Forcing(func; parameters=nothing, field_dependencies=(), discrete_form=false)\n\nReturns a forcing function added to the tendency of an Oceananigans model field.\n\nIf discrete_form=false (the default), and neither parameters nor field_dependencies are provided, then func must be callable with the signature\n\n`func(x, y, z, t)`\n\nwhere x, y, z are the east-west, north-south, and vertical spatial coordinates, and t is time. Note that this form is also default in the constructor for IncompressibleModel, so that Forcing is not needed.\n\nIf discrete_form=false (the default), and field_dependencies are provided, the signature of func must include them. For example, if field_dependencies=(:u, :S) (and parameters are not provided), then func must be callable with the signature\n\n`func(x, y, z, t, u, S)`\n\nwhere u is assumed to be the u-velocity component, and S is a tracer. Note that any field which does not have the name u, v, or w is assumed to be a tracer and must be present in model.tracers.\n\nIf discrete_form=false (the default) and parameters are provided, then the last argument to func must be parameters. For example, if func has no field_dependencies but does depend on parameters, then it must be callable with the signature\n\n`func(x, y, z, t, parameters)`\n\nThe object parameters is arbitrary in principle, however GPU compilation can place constraints on typeof(parameters).\n\nWith field_dependencies=(:u, :v, :w, :c) and parameters, then func must be callable with the signature\n\n`func(x, y, z, t, u, v, w, c, parameters)`\n\nIf discrete_form=true then func must be callable with the \"discrete form\"\n\n`func(i, j, k, grid, clock, model_fields)`\n\nwhere i, j, k is the grid point at which the forcing is applied, grid is model.grid, clock.time is the current simulation time and clock.iteration is the current model iteration, and model_fields is a NamedTuple with u, v, w, the fields in model.tracers, and the fields in model.diffusivities, each of which is an OffsetArrays (or NamedTuples of OffsetArrays depending on the turbulence closure) of field data.\n\nWhen discrete_form=true and parameters is specified, func must be callable with the signature\n\n`func(i, j, k, grid, clock, model_fields, parameters)`\n\nExamples\n\nusing Oceananigans\n\n# Parameterized forcing\nparameterized_func(x, y, z, t, p) = p.μ * exp(z / p.λ) * cos(p.ω * t)\n\nv_forcing = Forcing(parameterized_func, parameters = (μ=42, λ=0.1, ω=π))\n\n# output\nContinuousForcing{NamedTuple{(:μ, :λ, :ω),Tuple{Int64,Float64,Irrational{:π}}}}\n├── func: parameterized_func\n├── parameters: (μ = 42, λ = 0.1, ω = π)\n└── field dependencies: ()\n\nNote that because forcing locations are regularized within the IncompressibleModel constructor:\n\ngrid = RegularRectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))\nmodel = IncompressibleModel(grid=grid, forcing=(v=v_forcing,))\n\nmodel.forcing.v\n\n# output\nContinuousForcing{NamedTuple{(:μ, :λ, :ω),Tuple{Int64,Float64,Irrational{:π}}}} at (Center, Face, Center)\n├── func: parameterized_func\n├── parameters: (μ = 42, λ = 0.1, ω = π)\n└── field dependencies: ()\n\nAfter passing through the constructor for IncompressibleModel, the v-forcing location information is available and set to Center, Face, Center.\n\n# Field-dependent forcing\ngrowth_in_sunlight(x, y, z, t, P) = exp(z) * P\n\nplankton_forcing = Forcing(growth_in_sunlight, field_dependencies=:P)\n\n# output\nContinuousForcing{Nothing}\n├── func: growth_in_sunlight\n├── parameters: nothing\n└── field dependencies: (:P,)\n\n# Parameterized, field-dependent forcing\ntracer_relaxation(x, y, z, t, c, p) = p.μ * exp((z + p.H) / p.λ) * (p.dCdz * z - c) \n\nc_forcing = Forcing(tracer_relaxation,\n                    field_dependencies = :c,\n                            parameters = (μ=1/60, λ=10, H=1000, dCdz=1))\n\n# output\nContinuousForcing{NamedTuple{(:μ, :λ, :H, :dCdz),Tuple{Float64,Int64,Int64,Int64}}}\n├── func: tracer_relaxation\n├── parameters: (μ = 0.016666666666666666, λ = 10, H = 1000, dCdz = 1)\n└── field dependencies: (:c,)\n\n# Unparameterized discrete-form forcing function\nfiltered_relaxation(i, j, k, grid, clock, model_fields) =\n    @inbounds - (model_fields.c[i-1, j, k] + model_fields.c[i, j, k] + model_fields.c[i+1, j, k]) / 3\n\nfiltered_forcing = Forcing(filtered_relaxation, discrete_form=true)\n\n# output\nDiscreteForcing{Nothing}\n├── func: filtered_relaxation\n└── parameters: nothing\n\n# Discrete-form forcing function with parameters\nmasked_damping(i, j, k, grid, clock, model_fields, parameters) = \n    @inbounds - parameters.μ * exp(grid.zC[k] / parameters.λ) * model_fields.u[i, j, k]\n\nmasked_damping_forcing = Forcing(masked_damping, parameters=(μ=42, λ=π), discrete_form=true)\n\n# output\nDiscreteForcing{NamedTuple{(:μ, :λ),Tuple{Int64,Irrational{:π}}}}\n├── func: masked_damping\n└── parameters: (μ = 42, λ = π)\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Forcings.GaussianMask","page":"Library","title":"Oceananigans.Forcings.GaussianMask","text":"GaussianMask{D}(center, width)\n\nCallable object that returns a Gaussian masking function centered on center, with width, and varying along direction D.\n\nExamples\n\nCreate a Gaussian mask centered on z=0 with width 1 meter.\n\njulia> mask = GaussianMask{:z}(center=0, width=1)\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Forcings.LinearTarget","page":"Library","title":"Oceananigans.Forcings.LinearTarget","text":"LinearTarget{D}(intercept, gradient)\n\nCallable object that returns a Linear target function with intercept and gradient, and varying along direction D.\n\nExamples\n\nCreate a linear target function varying in z, equal to 0 at z=0 and with gradient 10⁻⁶:\n\njulia> target = LinearTarget{:z}(intercept=0, gradient=1e-6)\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Forcings.Relaxation","page":"Library","title":"Oceananigans.Forcings.Relaxation","text":"struct Relaxation{R, M, T}\n\nCallable object for restoring fields to a target at some rate and within a masked region in x, y, z.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Forcings.Relaxation-Tuple{}","page":"Library","title":"Oceananigans.Forcings.Relaxation","text":"Relaxation(; rate, mask=onefunction, target=zerofunction)\n\nReturns a Forcing that restores a field to target(x, y, z, t) at the specified rate, in the region mask(x, y, z).\n\nThe functions onefunction and zerofunction always return 1 and 0, respectively. Thus the default mask leaves the whole domain uncovered, and the default target is zero.\n\nExample\n\nRestore a field to zero on a timescale of \"3600\" (equal to one hour if the time units of the simulation are seconds).\n\nusing Oceananigans\n\ndamping = Relaxation(rate = 1/3600)\n\n# output\nRelaxation{Float64, typeof(Oceananigans.Forcings.onefunction), typeof(Oceananigans.Forcings.zerofunction)}\n├── rate: 0.0002777777777777778\n├── mask: 1\n└── target: 0\n\nRestore a field to a linear z-gradient within the bottom 1/4 of a domain on a timescale of \"60\" (equal to one minute if the time units of the simulation are seconds).\n\ndTdz = 0.001 # ⁰C m⁻¹, temperature gradient\n\nT₀ = 20 # ⁰C, surface temperature at z=0\n\nLz = 100 # m, depth of domain\n\nbottom_sponge_layer = Relaxation(; rate = 1/60,\n                                   target = LinearTarget{:z}(intercept=T₀, gradient=dTdz),\n                                   mask = GaussianMask{:z}(center=-Lz, width=Lz/4))\n\n# output\nRelaxation{Float64, GaussianMask{:z,Float64}, LinearTarget{:z,Float64}}\n├── rate: 0.016666666666666666\n├── mask: exp(-(z + 100.0)^2 / (2 * 25.0^2))\n└── target: 20.0 + 0.001 * z\n\n\n\n\n\n","category":"method"},{"location":"library/#Grids","page":"Library","title":"Grids","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Grids]\nPrivate = false\nPages   = [\n    \"Grids/Grids.jl\",\n    \"Grids/grid_utils.jl\",\n    \"Grids/regular_rectilinear_grid.jl\",\n    \"Grids/vertically_stretched_rectilinear_grid.jl\"\n]","category":"page"},{"location":"library/#Oceananigans.Grids.AbstractCurvilinearGrid","page":"Library","title":"Oceananigans.Grids.AbstractCurvilinearGrid","text":"AbstractCurvilinearGrid{FT, TX, TY, TZ}\n\nAbstract supertype for curvilinear grids with elements of type FT and topology {TX, TY, TZ}.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Grids.AbstractGrid","page":"Library","title":"Oceananigans.Grids.AbstractGrid","text":"AbstractGrid{FT, TX, TY, TZ}\n\nAbstract supertype for grids with elements of type FT and topology {TX, TY, TZ}.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Grids.AbstractHorizontallyCurvilinearGrid","page":"Library","title":"Oceananigans.Grids.AbstractHorizontallyCurvilinearGrid","text":"AbstractHorizontallyCurvilinearGrid{FT, TX, TY, TZ}\n\nAbstract supertype for horizontally-curvilinear grids with elements of type FT and topology {TX, TY, TZ}.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Grids.AbstractPrimaryGrid","page":"Library","title":"Oceananigans.Grids.AbstractPrimaryGrid","text":"AbstractPrimaryGrid{FT, TX, TY, TZ}\n\nAbstract supertype for \"primary\" grids (as opposed to grids with immersed boundaries) with elements of type FT and topology {TX, TY, TZ}.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Grids.AbstractRectilinearGrid","page":"Library","title":"Oceananigans.Grids.AbstractRectilinearGrid","text":"AbstractRectilinearGrid{FT, TX, TY, TZ}\n\nAbstract supertype for rectilinear grids with elements of type FT and topology {TX, TY, TZ}.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Grids.AbstractTopology","page":"Library","title":"Oceananigans.Grids.AbstractTopology","text":"AbstractTopology\n\nAbstract supertype for grid topologies.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Grids.Bounded","page":"Library","title":"Oceananigans.Grids.Bounded","text":"Bounded\n\nGrid topology for bounded dimensions. These could be wall-bounded dimensions or dimensions\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Grids.Center","page":"Library","title":"Oceananigans.Grids.Center","text":"Center\n\nA type describing the location at the center of a grid cell.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Grids.Connected","page":"Library","title":"Oceananigans.Grids.Connected","text":"Connected\n\nGrid topology for dimensions that are connected to other models or domains on both sides.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Grids.Face","page":"Library","title":"Oceananigans.Grids.Face","text":"Face\n\nA type describing the location at the face of a grid cell.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Grids.Flat","page":"Library","title":"Oceananigans.Grids.Flat","text":"Flat\n\nGrid topology for flat dimensions, generally with one grid point, along which the solution is uniform and does not vary.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Grids.Periodic","page":"Library","title":"Oceananigans.Grids.Periodic","text":"Periodic\n\nGrid topology for periodic dimensions.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Grids.nodes-Tuple{Any,AbstractGrid}","page":"Library","title":"Oceananigans.Grids.nodes","text":"nodes(loc, grid; reshape=false)\n\nReturns a 3-tuple of views over the interior nodes at the locations in loc in x, y, z.\n\nIf reshape=true, the views are reshaped to 3D arrays with non-singleton dimensions 1, 2, 3 for x, y, z, respectively. These reshaped arrays can then be used in broadcast operations with 3D fields or arrays.\n\nSee xnodes, ynodes, and znodes.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Grids.xnodes-Tuple{Any,Any}","page":"Library","title":"Oceananigans.Grids.xnodes","text":"xnodes(loc, grid, reshape=false)\n\nReturns a view over the interior loc=Center or loc=Face nodes on grid in the x-direction. For Bounded directions, Face nodes include the boundary points. reshape=false will return a 1D array while reshape=true will return a 3D array with size Nx×1×1.\n\nSee znodes for examples.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Grids.ynodes-Tuple{Any,Any}","page":"Library","title":"Oceananigans.Grids.ynodes","text":"ynodes(loc, grid, reshape=false)\n\nReturns a view over the interior loc=Center or loc=Face nodes on grid in the y-direction. For Bounded directions, Face nodes include the boundary points. reshape=false will return a 1D array while reshape=true will return a 3D array with size 1×Ny×1.\n\nSee znodes for examples.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Grids.znodes-Tuple{Any,Any}","page":"Library","title":"Oceananigans.Grids.znodes","text":"znodes(loc, grid, reshape=false)\n\nReturns a view over the interior loc=Center or loc=Face nodes on grid in the z-direction. For Bounded directions, Face nodes include the boundary points. reshape=false will return a 1D array while reshape=true will return a 3D array with size 1×1×Nz.\n\nExamples\n\njulia> using Oceananigans, Oceananigans.Grids\n\njulia> horz_periodic_grid = RegularRectilinearGrid(size=(3, 3, 3), extent=(2π, 2π, 1),\n                                                 topology=(Periodic, Periodic, Bounded));\n\njulia> zC = znodes(Center, horz_periodic_grid)\n3-element view(OffsetArray(::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}, 0:4), 1:3) with eltype Float64:\n -0.8333333333333331\n -0.4999999999999999\n -0.16666666666666652\n\njulia> zF = znodes(Face, horz_periodic_grid)\n4-element view(OffsetArray(::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}, 0:5), 1:4) with eltype Float64:\n -1.0\n -0.6666666666666666\n -0.33333333333333337\n -4.44089209850063e-17\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Grids.RegularRectilinearGrid","page":"Library","title":"Oceananigans.Grids.RegularRectilinearGrid","text":"RegularRectilinearGrid{FT, TX, TY, TZ, R} <: AbstractRectilinearGrid{FT, TX, TY, TZ}\n\nA rectilinear grid with with constant grid spacings Δx, Δy, and Δz between cell centers and cell faces, elements of type FT, topology {TX, TY, TZ}, and coordinate ranges of type R.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Grids.RegularRectilinearGrid-2","page":"Library","title":"Oceananigans.Grids.RegularRectilinearGrid","text":"RegularRectilinearGrid([FT=Float64]; size,\n                       extent = nothing, x = nothing, y = nothing, z = nothing,\n                       topology = (Periodic, Periodic, Bounded), halo = (1, 1, 1))\n\nCreates a RegularRectilinearGrid with size = (Nx, Ny, Nz) grid points.\n\nKeyword arguments\n\nsize (required): A tuple prescribing the number of grid points in non-Flat directions.                    size is a 3-tuple for 3D models, a 2-tuple for 2D models, and either a                    scalar or 1-tuple for 1D models.\ntopology: A 3-tuple (Tx, Ty, Tz) specifying the topology of the domain.             Tx, Ty, and Tz specify whether the x-, y-, and z directions are             Periodic, Bounded, or Flat. The topology Flat indicates that a model does             not vary in that directions so that derivatives and interpolation are zero.             The default is topology=(Periodic, Periodic, Bounded).\nextent: A tuple prescribing the physical extent of the grid in non-Flat directions.           The origin for three-dimensional domains is the oceanic default (0, 0, -Lz).\nx, y, and z: Each of x, y, z are 2-tuples that specify the end points of the domain                    in their respect directions. Scalar values may be used in Flat directions.\n\nNote: Either extent, or all of x, y, and z must be specified.\n\nhalo: A tuple of integers that specifies the size of the halo region of cells surrounding         the physical interior for each non-Flat direction.\n\nThe physical extent of the domain can be specified via x, y, and z keyword arguments indicating the left and right endpoints of each dimensions, e.g. x=(-π, π) or via the extent argument, e.g. extent=(Lx, Ly, Lz) which specifies the extent of each dimension in which case 0 ≤ x ≤ Lx, 0 ≤ y ≤ Ly, and -Lz ≤ z ≤ 0.\n\nA grid topology may be specified via a tuple assigning one of Periodic, Bounded, andFlatto each dimension. By default, a horizontally periodic grid topology(Periodic, Periodic, Bounded)` is assumed.\n\nConstants are stored using floating point values of type FT. By default this is Float64. Make sure to specify the desired FT if not using Float64.\n\nGrid properties\n\n(Nx, Ny, Nz)::Int: Number of physical points in the (x, y, z)-direction\n(Hx, Hy, Hz)::Int: Number of halo points in the (x, y, z)-direction\n(Lx, Ly, Lz)::FT: Physical extent of the grid in the (x, y, z)-direction\n(Δx, Δy, Δz)::FT: Grid spacing (distance between grid nodes) in the (x, y, z)-direction\n(xC, yC, zC): (x, y, z) coordinates of cell centers.\n(xF, yF, zF): (x, y, z) coordinates of cell faces.\n\nExamples\n\nA default grid with Float64 type:\n\njulia> using Oceananigans\n\njulia> grid = RegularRectilinearGrid(size=(32, 32, 32), extent=(1, 2, 3))\nRegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}\n                   domain: x ∈ [0.0, 1.0], y ∈ [0.0, 2.0], z ∈ [-3.0, 0.0]\n                 topology: (Periodic, Periodic, Bounded)\n  resolution (Nx, Ny, Nz): (32, 32, 32)\n   halo size (Hx, Hy, Hz): (1, 1, 1)\ngrid spacing (Δx, Δy, Δz): (0.03125, 0.0625, 0.09375)\n\nA default grid with Float32 type:\n\njulia> using Oceananigans\n\njulia> grid = RegularRectilinearGrid(Float32; size=(32, 32, 16), x=(0, 8), y=(-10, 10), z=(-π, π))\nRegularRectilinearGrid{Float32, Periodic, Periodic, Bounded}\n                   domain: x ∈ [0.0, 8.0], y ∈ [-10.0, 10.0], z ∈ [-3.1415927, 3.1415927]\n                 topology: (Periodic, Periodic, Bounded)\n  resolution (Nx, Ny, Nz): (32, 32, 16)\n   halo size (Hx, Hy, Hz): (1, 1, 1)\ngrid spacing (Δx, Δy, Δz): (0.25f0, 0.625f0, 0.3926991f0)\n\nA two-dimenisional, horizontally-periodic grid:\n\njulia> using Oceananigans\n\njulia> grid = RegularRectilinearGrid(size=(32, 32), extent=(2π, 4π), topology=(Periodic, Periodic, Flat))\nRegularRectilinearGrid{Float64, Periodic, Periodic, Flat}\n                   domain: x ∈ [0.0, 6.283185307179586], y ∈ [0.0, 12.566370614359172], z ∈ [0.0, 0.0]\n                 topology: (Periodic, Periodic, Flat)\n  resolution (Nx, Ny, Nz): (32, 32, 1)\n   halo size (Hx, Hy, Hz): (1, 1, 0)\ngrid spacing (Δx, Δy, Δz): (0.19634954084936207, 0.39269908169872414, 0.0)\n\nA one-dimensional \"column\" grid:\n\njulia> using Oceananigans\n\njulia> grid = RegularRectilinearGrid(size=256, z=(-128, 0), topology=(Flat, Flat, Bounded))\nRegularRectilinearGrid{Float64, Flat, Flat, Bounded}\n                   domain: x ∈ [0.0, 0.0], y ∈ [0.0, 0.0], z ∈ [-128.0, 0.0]\n                 topology: (Flat, Flat, Bounded)\n  resolution (Nx, Ny, Nz): (1, 1, 256)\n   halo size (Hx, Hy, Hz): (0, 0, 1)\ngrid spacing (Δx, Δy, Δz): (0.0, 0.0, 0.5)\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Grids.VerticallyStretchedRectilinearGrid","page":"Library","title":"Oceananigans.Grids.VerticallyStretchedRectilinearGrid","text":"VerticallyStretchedRectilinearGrid([FT=Float64]; architecture=CPU(), size, z_faces,\n                                    x = nothing, y = nothing,\n                                    topology = (Periodic, Periodic, Bounded), halo = nothing)\n\nCreates a VerticallyStretchedRectilinearGrid with size = (Nx, Ny, Nz) grid points and a vertical grid specified by z_faces.\n\nKeyword arguments\n\nsize (required): A tuple prescribing the number of grid points in non-Flat directions.                    size is a 3-tuple for 3D models, a 2-tuple for 2D models, and either a                    scalar or 1-tuple for 1D models.\ntopology: A 3-tuple (Tx, Ty, Tz) specifying the topology of the domain.             Tz must be Bounded for VerticallyStretchedRectilinearGrid.             Tx and Ty specify whether the x- and y-directions arePeriodic,Bounded, orFlat. The topologyFlatindicates that a model does             not vary in that directions so that derivatives and interpolation are zero.             The default istopology=(Periodic, Periodic, Bounded)`.\narchitecture: Specifies whether the array of vertical coordinates, interfaces, and spacings                 are stored on the CPU or GPU. Default: architecture = CPU().\nz_faces: An array or function of vertical index k that specifies the location of cell faces       in the z-direction for indices k=1 through k=Nz+1, where Nz is the third element       of size.\nx, y: Each of x, y are 2-tuples that specify the end points of the domain           in their respect directions. Scalar values may be used in Flat directions.\nhalo: A tuple of integers that specifies the size of the halo region of cells surrounding         the physical interior for each non-Flat direction.\n\nThe physical extent of the domain can be specified via x and y keyword arguments indicating the left and right endpoints of each dimensions, e.g. x=(-π, π).\n\nA grid topology may be specified via a tuple assigning one of Periodic, Bounded, andFlatto each dimension. By default, a horizontally periodic grid topology(Periodic, Periodic, Bounded)` is assumed.\n\nConstants are stored using floating point values of type FT. By default this is Float64. Make sure to specify the desired FT if not using Float64.\n\nGrid properties\n\n(Nx, Ny, Nz)::Int: Number of physical points in the (x, y, z)-direction\n(Hx, Hy, Hz)::Int: Number of halo points in the (x, y, z)-direction\n(Lx, Ly, Lz)::FT: Physical extent of the grid in the (x, y, z)-direction\n(Δx, Δy)::FT: Grid spacing (distance between grid nodes) in the (x, y)-direction\nΔzᵃᵃᶜ: Grid spacing in the z-direction between cell faces.          Defined at cell centers in z and independent of cell location in (x, y).\nΔzᵃᵃᶠ: Grid spacing in the z-direction between cell centers, and defined at cell faces in z.          Defined at cell faces in z and independent of cell location in (x, y).\n(xᶜᵃᵃ, yᵃᶜᵃ, zᵃᵃᶜ): (x, y, z) coordinates of cell centers.\n(xᶠᵃᵃ, yᵃᶠᵃ, zᵃᵃᶠ): (x, y, z) coordinates of cell faces.\n\n\n\n\n\n","category":"type"},{"location":"library/#Lagrangian-particle-tracking","page":"Library","title":"Lagrangian particle tracking","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.LagrangianParticleTracking]\nPrivate = false\nPages   = [\n    \"LagrangianParticleTracking/LagrangianParticleTracking.jl\",\n    \"LagrangianParticleTracking/advect_particles.jl\"\n]","category":"page"},{"location":"library/#Oceananigans.LagrangianParticleTracking.LagrangianParticles-Tuple{StructArrays.StructArray}","page":"Library","title":"Oceananigans.LagrangianParticleTracking.LagrangianParticles","text":"LagrangianParticles(particles::StructArray; restitution=1.0, tracked_fields::NamedTuple=NamedTuple(), dynamics=no_dynamics)\n\nConstruct some LagrangianParticles that can be passed to a model. The particles should be a StructArray and can contain custom fields. The coefficient of restitution for particle-wall collisions is specified by restitution.\n\nA number of tracked_fields may be passed in as a NamedTuple of fields. Each particle will track the value of each field. Each tracked field must have a corresponding particle property. So if T is a tracked field, then T must also be a custom particle property.\n\ndynamics is a function of (lagrangian_particles, model, Δt) that is called prior to advecting particles. parameters can be accessed inside the dynamics function.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.LagrangianParticleTracking.LagrangianParticles-Tuple{}","page":"Library","title":"Oceananigans.LagrangianParticleTracking.LagrangianParticles","text":"LagrangianParticles(; x, y, z, restitution=1.0, dynamics=no_dynamics, parameters=nothing)\n\nConstruct some LagrangianParticles that can be passed to a model. The particles will have initial locations x, y, and z. The coefficient of restitution for particle-wall collisions is specified by restitution.\n\ndynamics is a function of (lagrangian_particles, model, Δt) that is called prior to advecting particles. parameters can be accessed inside the dynamics function.\n\n\n\n\n\n","category":"method"},{"location":"library/#Logger","page":"Library","title":"Logger","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Logger]\nPrivate = false\nPages   = [\"Logger.jl\"]","category":"page"},{"location":"library/#Oceananigans.Logger.OceananigansLogger","page":"Library","title":"Oceananigans.Logger.OceananigansLogger","text":"OceananigansLogger(stream::IO=stdout, level=Logging.Info; show_info_source=false)\n\nBased on Logging.SimpleLogger, it tries to log all messages in the following format:\n\n[yyyy/mm/dd HH:MM:SS.sss] log_level message [-@-> source_file:line_number]\n\nwhere the source of the message between the square brackets is included only if show_info_source=true or if the message is not an info level message.\n\n\n\n\n\n","category":"type"},{"location":"library/#Models","page":"Library","title":"Models","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Models]\nPrivate = false\nPages   = [\n    \"Models/Models.jl\",\n    \"Models/clock.jl\",\n    \"Models/incompressible_model.jl\",\n    \"Models/non_dimensional_model.jl\",\n    \"Models/show_models.jl\"\n]","category":"page"},{"location":"library/#Output-writers","page":"Library","title":"Output writers","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.OutputWriters]\nPrivate = false\nPages   = [\n    \"OutputWriters/OutputWriters.jl\",\n    \"OutputWriters/output_writer_utils.jl\",\n    \"OutputWriters/jld2_output_writer.jl\",\n    \"OutputWriters/netcdf_output_writer.jl\",\n    \"OutputWriters/windowed_time_average.jl\",\n    \"OutputWriters/checkpointer.jl\"\n]","category":"page"},{"location":"library/#Oceananigans.OutputWriters.JLD2OutputWriter","page":"Library","title":"Oceananigans.OutputWriters.JLD2OutputWriter","text":"JLD2OutputWriter{I, T, O, IF, IN, KW} <: AbstractOutputWriter\n\nAn output writer for writing to JLD2 files.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.OutputWriters.JLD2OutputWriter-Tuple{Any,Any}","page":"Library","title":"Oceananigans.OutputWriters.JLD2OutputWriter","text":"JLD2OutputWriter(model, outputs; prefix, schedule,\n                          dir = \".\",\n                 field_slicer = FieldSlicer(),\n                   array_type = Array{Float32},\n                 max_filesize = Inf,\n                        force = false,\n                         init = noinit,\n                    including = [:grid, :coriolis, :buoyancy, :closure],\n                      verbose = false,\n                         part = 1,\n                      jld2_kw = Dict{Symbol, Any}())\n\nConstruct a JLD2OutputWriter for an Oceananigans model that writes label, output pairs in outputs to a JLD2 file.\n\nThe argument outputs may be a Dict or NamedTuple. The keys of outputs are symbols or strings that \"name\" output data. The values of outputs are either AbstractFields, objects that are called with the signature output(model), or WindowedTimeAverages of AbstractFieldss, functions, or callable objects.\n\nKeyword arguments\n\n## Filenaming\n\n- `prefix` (required): Descriptive filename prefixed to all output files.\n\n- `dir`: Directory to save output to.\n         Default: \".\" (current working directory).\n\n## Output frequency and time-averaging\n\n- `schedule` (required): `AbstractSchedule` that determines when output is saved.\n\n## Slicing and type conversion prior to output\n\n- `field_slicer`: An object for slicing field output in ``(x, y, z)``, including omitting halos.\n                  Has no effect on output that is not a field. `field_slicer = nothing` means\n                  no slicing occurs, so that all field data, including halo regions, is saved.\n                  Default: FieldSlicer(), which slices halo regions.\n\n- `array_type`: The array type to which output arrays are converted to prior to saving.\n                Default: Array{Float32}.\n\n## File management\n\n- `max_filesize`: The writer will stop writing to the output file once the file size exceeds `max_filesize`,\n                  and write to a new one with a consistent naming scheme ending in `part1`, `part2`, etc.\n                  Defaults to `Inf`.\n\n- `force`: Remove existing files if their filenames conflict.\n           Default: `false`.\n\n## Output file metadata management\n\n- `init`: A function of the form `init(file, model)` that runs when a JLD2 output file is initialized.\n          Default: `noinit(args...) = nothing`.\n\n- `including`: List of model properties to save with every file.\n               Default: `[:grid, :coriolis, :buoyancy, :closure]`\n\n## Miscellaneous keywords\n\n- `verbose`: Log what the output writer is doing with statistics on compute/write times and file sizes.\n             Default: `false`.\n\n- `part`: The starting part number used if `max_filesize` is finite.\n          Default: 1.\n\n- `jld2_kw`: Dict of kwargs to be passed to `jldopen` when data is written.\n\nExample\n\nWrite out 3D fields for w and T and a horizontal average:\n\nusing Oceananigans, Oceananigans.OutputWriters, Oceananigans.Fields\nusing Oceananigans.Utils: hour, minute\n\nmodel = IncompressibleModel(grid=RegularRectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)))\nsimulation = Simulation(model, Δt=12, stop_time=1hour)\n\nfunction init_save_some_metadata!(file, model)\n    file[\"author\"] = \"Chim Riggles\"\n    file[\"parameters/coriolis_parameter\"] = 1e-4\n    file[\"parameters/density\"] = 1027\n    return nothing\nend\n\nT_avg =  AveragedField(model.tracers.T, dims=(1, 2))\n\n# Note that model.velocities is NamedTuple\nsimulation.output_writers[:velocities] = JLD2OutputWriter(model, model.velocities,\n                                                          prefix = \"some_data\",\n                                                          schedule = TimeInterval(20minute),\n                                                          init = init_save_some_metadata!)\n\n# output\nJLD2OutputWriter scheduled on TimeInterval(20 minutes):\n├── filepath: ./some_data.jld2\n├── 3 outputs: (:u, :v, :w)\n├── field slicer: FieldSlicer(:, :, :, with_halos=false)\n├── array type: Array{Float32}\n├── including: [:grid, :coriolis, :buoyancy, :closure]\n└── max filesize: Inf YiB\n\nand a time- and horizontal-average of temperature T every 1 hour of simulation time to a file called some_averaged_data.jld2\n\nsimulation.output_writers[:avg_T] = JLD2OutputWriter(model, (T=T_avg,),\n                                                     prefix = \"some_averaged_data\",\n                                                     schedule = AveragedTimeInterval(20minute, window=5minute))\n\n# output\nJLD2OutputWriter scheduled on TimeInterval(20 minutes):\n├── filepath: ./some_averaged_data.jld2\n├── 1 outputs: (:T,) averaged on AveragedTimeInterval(window=5 minutes, stride=1, interval=20 minutes)\n├── field slicer: FieldSlicer(:, :, :, with_halos=false)\n├── array type: Array{Float32}\n├── including: [:grid, :coriolis, :buoyancy, :closure]\n└── max filesize: Inf YiB\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.OutputWriters.NetCDFOutputWriter","page":"Library","title":"Oceananigans.OutputWriters.NetCDFOutputWriter","text":"NetCDFOutputWriter{D, O, I, T, S} <: AbstractOutputWriter\n\nAn output writer for writing to NetCDF files.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.OutputWriters.NetCDFOutputWriter-Tuple{Any,Any}","page":"Library","title":"Oceananigans.OutputWriters.NetCDFOutputWriter","text":"NetCDFOutputWriter(model, outputs; filepath, schedule\n                               array_type = Array{Float32},\n                             field_slicer = FieldSlicer(),\n                        global_attributes = Dict(),\n                        output_attributes = Dict(),\n                               dimensions = Dict(),\n                                     mode = nothing,\n                              compression = 0,\n                                  verbose = false)\n\nConstruct a NetCDFOutputWriter that writes (label, output) pairs in outputs (which should be a Dict) to a NetCDF file, where label is a string that labels the output and output is either a Field (e.g. model.velocities.u or an AveragedField) or a function f(model) that returns something to be written to disk. Custom output requires the spatial dimensions (a Dict) to be manually specified (see examples).\n\nKeyword arguments\n\nfilepath (required): Filepath to save output to.\nschedule (required): AbstractSchedule that determines when output is saved.\narray_type: The array type to which output arrays are converted to prior to saving.               Default: Array{Float32}.\nfield_slicer: An object for slicing field output in (x y z), including omitting halos,                 which can be done with the keyword with_halos.                 Has no effect on output that is not a field. field_slicer = nothing means                 no slicing occurs, so that all field data, including halo regions, is saved.                 Default: FieldSlicer(), which slices halo regions.\nglobal_attributes: Dict of model properties to save with every file (deafult: Dict())\noutput_attributes: Dict of attributes to be saved with each field variable (reasonable                      defaults are provided for velocities, buoyancy, temperature, and salinity;                      otherwise output_attributes must be user-provided).\ndimensions: A Dict of dimension tuples to apply to outputs (required for function outputs)\nmode: \"a\" (for append) and \"c\" (for clobber or create). Default: \"c\". See NCDatasets.jl         documentation for more information on the mode option.\ncompression: Determines the compression level of data (0-9, default 0)\n\nExamples\n\nSaving the u velocity field and temperature fields, the full 3D fields and surface 2D slices to separate NetCDF files:\n\nusing Oceananigans, Oceananigans.OutputWriters\n\ngrid = RegularRectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1));\n\nmodel = IncompressibleModel(grid=grid);\n\nsimulation = Simulation(model, Δt=12, stop_time=3600);\n\nfields = Dict(\"u\" => model.velocities.u, \"T\" => model.tracers.T);\n\nsimulation.output_writers[:field_writer] =\n    NetCDFOutputWriter(model, fields, filepath=\"fields.nc\", schedule=TimeInterval(60))\n\n# output\nNetCDFOutputWriter scheduled on TimeInterval(1 minute):\n├── filepath: fields.nc\n├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0)\n├── 2 outputs: [\"T\", \"u\"]\n├── field slicer: FieldSlicer(:, :, :, with_halos=false)\n└── array type: Array{Float32}\n\nsimulation.output_writers[:surface_slice_writer] =\n    NetCDFOutputWriter(model, fields, filepath=\"surface_xy_slice.nc\",\n                       schedule=TimeInterval(60), field_slicer=FieldSlicer(k=grid.Nz))\n\n# output\nNetCDFOutputWriter scheduled on TimeInterval(1 minute):\n├── filepath: surface_xy_slice.nc\n├── dimensions: zC(1), zF(1), xC(16), yF(16), xF(16), yC(16), time(0)\n├── 2 outputs: [\"T\", \"u\"]\n├── field slicer: FieldSlicer(:, :, 16, with_halos=false)\n└── array type: Array{Float32}\n\nsimulation.output_writers[:averaged_profile_writer] =\n    NetCDFOutputWriter(model, fields,\n                       filepath = \"averaged_z_profile.nc\",\n                       schedule = AveragedTimeInterval(60, window=20),\n                       field_slicer = FieldSlicer(i=1, j=1))\n\n# output\nNetCDFOutputWriter scheduled on TimeInterval(1 minute):\n├── filepath: averaged_z_profile.nc\n├── dimensions: zC(16), zF(17), xC(1), yF(1), xF(1), yC(1), time(0)\n├── 2 outputs: [\"T\", \"u\"] averaged on AveragedTimeInterval(window=20 seconds, stride=1, interval=1 minute)\n├── field slicer: FieldSlicer(1, 1, :, with_halos=false)\n└── array type: Array{Float32}\n\nNetCDFOutputWriter also accepts output functions that write scalars and arrays to disk, provided that their dimensions are provided:\n\nusing Oceananigans, Oceananigans.OutputWriters\n\ngrid = RegularRectilinearGrid(size=(16, 16, 16), extent=(1, 2, 3));\n\nmodel = IncompressibleModel(grid=grid);\n\nsimulation = Simulation(model, Δt=1.25, stop_iteration=3);\n\nf(model) = model.clock.time^2; # scalar output\n\ng(model) = model.clock.time .* exp.(znodes(Center, grid)); # vector/profile output\n\nh(model) = model.clock.time .* (   sin.(xnodes(Center, grid, reshape=true)[:, :, 1])\n                            .*     cos.(ynodes(Face, grid, reshape=true)[:, :, 1])); # xy slice output\n\noutputs = Dict(\"scalar\" => f, \"profile\" => g, \"slice\" => h);\n\ndims = Dict(\"scalar\" => (), \"profile\" => (\"zC\",), \"slice\" => (\"xC\", \"yC\"));\n\noutput_attributes = Dict(\n    \"scalar\"  => Dict(\"longname\" => \"Some scalar\", \"units\" => \"bananas\"),\n    \"profile\" => Dict(\"longname\" => \"Some vertical profile\", \"units\" => \"watermelons\"),\n    \"slice\"   => Dict(\"longname\" => \"Some slice\", \"units\" => \"mushrooms\")\n);\n\nglobal_attributes = Dict(\"location\" => \"Bay of Fundy\", \"onions\" => 7);\n\nsimulation.output_writers[:things] =\n    NetCDFOutputWriter(model, outputs,\n                       schedule=IterationInterval(1), filepath=\"things.nc\", dimensions=dims, verbose=true,\n                       global_attributes=global_attributes, output_attributes=output_attributes)\n\n# output\nNetCDFOutputWriter scheduled on IterationInterval(1):\n├── filepath: things.nc\n├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0)\n├── 3 outputs: [\"profile\", \"slice\", \"scalar\"]\n├── field slicer: FieldSlicer(:, :, :, with_halos=false)\n└── array type: Array{Float32}\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.OutputWriters.AveragedTimeInterval","page":"Library","title":"Oceananigans.OutputWriters.AveragedTimeInterval","text":"mutable struct AveragedTimeInterval <: AbstractSchedule\n\nContainer for parameters that configure and handle time-averaged output.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.OutputWriters.AveragedTimeInterval-Tuple{Any}","page":"Library","title":"Oceananigans.OutputWriters.AveragedTimeInterval","text":"AveragedTimeInterval(interval; window=interval, stride=1)\n\nReturns a schedule that specifies periodic time-averaging of output. The time window specifies the extent of the time-average, which reoccurs every interval.\n\noutput is computed and accumulated into the average every stride iterations during the averaging window. For example, stride=1 computs output every iteration, whereas stride=2 computes output every other iteration. Time-averages with longer strides are faster to compute, but less accurate.\n\nThe time-average of a is a left Riemann sum corresponding to\n\na = 1T int_tᵢ-T^T a mathrmd t \n\nwhere a is the time-average of a, T is the time-window for averaging, and the tᵢ are discrete times separated by the time interval. The tᵢ specify both the end of the averaging window and the time at which output is written.\n\nExample\n\nusing Oceananigans.OutputWriters: AveragedTimeInterval\nusing Oceananigans.Utils: year, years\n\nschedule = AveragedTimeInterval(4years, window=1year)\n\n# output\nAveragedTimeInterval(window=1 year, stride=1, interval=4 years)\n\nAn AveragedTimeInterval schedule directs an output writer to time-average its outputs before writing them to disk:\n\nusing Oceananigans\nusing Oceananigans.OutputWriters: JLD2OutputWriter\nusing Oceananigans.Utils: minutes\n\nmodel = IncompressibleModel(grid=RegularRectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)))\n\nsimulation = Simulation(model, Δt=10minutes, stop_time=30years)\n\nsimulation.output_writers[:velocities] = JLD2OutputWriter(model, model.velocities,\n                                                          prefix = \"averaged_velocity_data\",\n                                                          schedule = AveragedTimeInterval(4years, window=1year, stride=2))\n\n# output\nJLD2OutputWriter scheduled on TimeInterval(4 years):\n├── filepath: ./averaged_velocity_data.jld2\n├── 3 outputs: (:u, :v, :w) averaged on AveragedTimeInterval(window=1 year, stride=2, interval=4 years)\n├── field slicer: FieldSlicer(:, :, :, with_halos=false)\n├── array type: Array{Float32}\n├── including: [:grid, :coriolis, :buoyancy, :closure]\n└── max filesize: Inf YiB\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.OutputWriters.WindowedTimeAverage","page":"Library","title":"Oceananigans.OutputWriters.WindowedTimeAverage","text":"WindowedTimeAverage{OP, R, FS} <: AbstractDiagnostic\n\nAn object for computing 'windowed' time averages, or moving time-averages of a operand over a specified window, collected on interval.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.OutputWriters.WindowedTimeAverage-2","page":"Library","title":"Oceananigans.OutputWriters.WindowedTimeAverage","text":"WindowedTimeAverage(operand, model=nothing; schedule, field_slicer=FieldSlicer())\n\nReturns an object for computing running averages of operand over schedule.window and recurring on schedule.interval, where schedule is an AveragedTimeInterval. During the collection period, averages are computed every schedule.stride iteration.\n\noperand may be a Oceananigans.Field or a function that returns an array or scalar.\n\nCalling wta(model) for wta::WindowedTimeAverage object returns wta.result.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.OutputWriters.Checkpointer","page":"Library","title":"Oceananigans.OutputWriters.Checkpointer","text":"Checkpointer{I, T, P} <: AbstractOutputWriter\n\nAn output writer for checkpointing models to a JLD2 file from which models can be restored.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.OutputWriters.Checkpointer-Tuple{Any}","page":"Library","title":"Oceananigans.OutputWriters.Checkpointer","text":"Checkpointer(model; schedule,\n                    dir = \".\",\n                 prefix = \"checkpoint\",\n                  force = false,\n                verbose = false,\n                cleanup = false,\n             properties = [:architecture, :boundary_conditions, :grid, :clock, :coriolis,\n                           :buoyancy, :closure, :velocities, :tracers, :timestepper]\n             )\n\nConstruct a Checkpointer that checkpoints the model to a JLD2 file every so often as specified by schedule. The model.clock.iteration is included in the filename to distinguish between multiple checkpoint files.\n\nNote that extra model properties can be safely specified, but removing crucial properties such as :velocities will make restoring from the checkpoint impossible.\n\nThe checkpoint file is generated by serializing model properties to JLD2. However, functions cannot be serialized to disk with JLD2. So if a model property contains a reference somewhere in its hierarchy it will not be included in the checkpoint file (and you will have to manually restore them).\n\nKeyword arguments\n\nschedule (required): Schedule that determines when to checkpoint.\ndir: Directory to save output to. Default: \".\" (current working directory).\nprefix: Descriptive filename prefixed to all output files. Default: \"checkpoint\".\nforce: Remove existing files if their filenames conflict. Default: false.\nverbose: Log what the output writer is doing with statistics on compute/write times            and file sizes. Default: false.\ncleanup: Previous checkpoint files will be deleted once a new checkpoint file is written.            Default: false.\nproperties: List of model properties to checkpoint. Some are required.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.OutputWriters.restore_from_checkpoint-Tuple{Any}","page":"Library","title":"Oceananigans.OutputWriters.restore_from_checkpoint","text":"restore_from_checkpoint(filepath; kwargs=Dict())\n\nRestore a model from the checkpoint file stored at filepath. kwargs can be passed to the model constructor, which can be especially useful if you need to manually restore forcing functions or boundary conditions that rely on functions.\n\n\n\n\n\n","category":"method"},{"location":"library/#Time-steppers","page":"Library","title":"Time steppers","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.TimeSteppers]\nPrivate = false\nPages   = [\n    \"TimeSteppers/TimeSteppers.jl\",\n    \"TimeSteppers/kernels.jl\",\n    \"TimeSteppers/adams_bashforth.jl\"\n]","category":"page"},{"location":"library/#Simulations","page":"Library","title":"Simulations","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Simulations]\nPrivate = false\nPages   = [\n    \"Simulations/Simulations.jl\",\n    \"Simulations/time_step_wizard.jl\",\n    \"Simulations/simulation.jl\",\n    \"Simulations/run.jl\"\n]","category":"page"},{"location":"library/#Oceananigans.Simulations.TimeStepWizard","page":"Library","title":"Oceananigans.Simulations.TimeStepWizard","text":"TimeStepWizard(cfl=0.1, max_change=2.0, min_change=0.5, max_Δt=Inf, min_Δt=0.0, Δt=0.01)\n\nA type for calculating adaptive time steps based on capping the CFL number at cfl.\n\nOn calling update_Δt!(wizard, model), the TimeStepWizard computes a time-step such that cfl = max(uΔx vΔy wΔz) Δt, where max(uΔx vΔy wΔz) is the maximum ratio between model velocity and along-velocity grid spacing anywhere on the model grid. The new Δt is constrained to change by a multiplicative factor no more than max_change or no less than min_change from the previous Δt, and to be no greater in absolute magnitude than max_Δt and no less than min_Δt.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Simulations.Simulation-Tuple{Any}","page":"Library","title":"Oceananigans.Simulations.Simulation","text":"Simulation(model; Δt,\n     stop_criteria = Function[iteration_limit_exceeded, stop_time_exceeded, wall_time_limit_exceeded],\n    stop_iteration = Inf,\n         stop_time = Inf,\n   wall_time_limit = Inf,\n       diagnostics = OrderedDict{Symbol, AbstractDiagnostic}(),\n    output_writers = OrderedDict{Symbol, AbstractOutputWriter}(),\n          progress = nothing,\niteration_interval = 1,\n        parameters = nothing)\n\nConstruct an Oceananigans.jl Simulation for a model with time step Δt.\n\nKeyword arguments\n\nΔt: Required keyword argument specifying the simulation time step. Can be a Number for constant time steps or a TimeStepWizard for adaptive time-stepping.\nstop_criteria: A list of functions or callable objects (each taking a single argument, the simulation). If any of the functions return true when the stop criteria is evaluated the simulation will stop.\nstop_iteration: Stop the simulation after this many iterations.\nstop_time: Stop the simulation once this much model clock time has passed.\nwall_time_limit: Stop the simulation if it's been running for longer than this many  seconds of wall clock time.\nprogress: A function with a single argument, the simulation. Will be called every iteration_interval iterations. Useful for logging simulation health.\niteration_interval: How often to update the time step, check stop criteria, and call progress function (in number of iterations).\nparameters: Parameters that can be accessed in the progress function.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Simulations.run!-Tuple{Any}","page":"Library","title":"Oceananigans.Simulations.run!","text":"run!(simulation; pickup=false)\n\nRun a simulation until one of simulation.stop_criteria evaluates true. The simulation will then stop.\n\nPicking simulations up from a checkpoint\n\nSimulations will be \"picked up\" from a checkpoint if pickup is either true, a String, or an Integer greater than 0.\n\nPicking up a simulation sets field and tendency data to the specified checkpoint, leaving all other model properties unchanged.\n\nPossible values for pickup are:\n\n* `pickup=true` will pick a simulation up from the latest checkpoint associated with\n  the `Checkpointer` in simulation.output_writers`.\n\n* `pickup=iteration::Int` will pick a simulation up from the checkpointed file associated\n   with `iteration` and the `Checkpointer` in simulation.output_writers`.\n\n* `pickup=filepath::String` will pick a simulation up from checkpointer data in `filepath`.\n\nNote that pickup=true and pickup=iteration will fail if simulation.output_writers contains more than one checkpointer.\n\n\n\n\n\n","category":"method"},{"location":"library/#Tubrulence-closures","page":"Library","title":"Tubrulence closures","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.TurbulenceClosures]\nPrivate = false\nPages   = [\n    \"TurbulenceClosures/TurbulenceClosures.jl\",\n    \"TurbulenceClosures/turbulence_closure_utils.jl\",\n    \"TurbulenceClosures/closure_operators.jl\",\n    \"TurbulenceClosures/viscous_dissipation_operators.jl\",\n    \"TurbulenceClosures/diffusion_operators.jl\",\n    \"TurbulenceClosures/velocity_tracer_gradients.jl\",\n    \"TurbulenceClosures/closure_tuples.jl\",\n    \"TurbulenceClosures/turbulence_closure_diagnostics.jl\",\n    \"TurbulenceClosures/turbulence_closure_implementations/anisotropic_biharmonic_diffusivity.jl\",\n    \"TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl\",\n    \"TurbulenceClosures/turbulence_closure_implementations/isotropic_diffusivity.jl\",\n    \"TurbulenceClosures/turbulence_closure_implementations/anisotropic_diffusivity.jl\",\n    \"TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl\",\n    \"TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl\"\n]","category":"page"},{"location":"library/#Oceananigans.TurbulenceClosures.ConstantSmagorinsky","page":"Library","title":"Oceananigans.TurbulenceClosures.ConstantSmagorinsky","text":"ConstantSmagorinsky\n\nAn alias for SmagorinskyLilly.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.TurbulenceClosures.∇_dot_qᶜ-Union{Tuple{tracer_index}, Tuple{Any,Any,Any,Any,Oceananigans.TurbulenceClosures.AbstractTurbulenceClosure,Any,Val{tracer_index},Vararg{Any,N} where N}} where tracer_index","page":"Library","title":"Oceananigans.TurbulenceClosures.∇_dot_qᶜ","text":"∇_dot_qᶜ(i, j, k, grid, clock, closure::AbstractTurbulenceClosure, c, ::Val{tracer_index}, args...)\n\nCalculates the divergence of the diffusive flux qᶜ for a tracer c via\n\n1/V * [δxᶜᵃᵃ(Ax * diffusive_flux_x) + δyᵃᶜᵃ(Ay * diffusive_flux_y) + δzᵃᵃᶜ(Az * diffusive_flux_z)]\n\nwhich will end up at the location ccc.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.TurbulenceClosures.AnisotropicBiharmonicDiffusivity","page":"Library","title":"Oceananigans.TurbulenceClosures.AnisotropicBiharmonicDiffusivity","text":"AnisotropicBiharmonicDiffusivity{FT, KH, KZ}\n\nParameters for anisotropic biharmonic diffusivity models.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.TurbulenceClosures.AnisotropicBiharmonicDiffusivity-2","page":"Library","title":"Oceananigans.TurbulenceClosures.AnisotropicBiharmonicDiffusivity","text":"AnisotropicBiharmonicDiffusivity(FT=Float64; νx=0, νy=0, νz=0, νh=nothing, κx=0, κy=0, κz=0, κh=nothing)\n\nReturns parameters for a fourth-order, anisotropic biharmonic diffusivity closure with constant x-, y, and z-direction biharmonic viscosities νx, νy, and νz, and constant x-, y, and z-direction biharmonic diffusivities κx, κy, and κz, κx, κy, and κz may be NamedTuples with fields corresponding to each tracer, or a single number to be a applied to all tracers.\n\nIf νh or κh are provided, then νx = νy = νh or κx = κy = κh.\n\nThe tracer flux divergence associated with an anisotropic biharmonic diffusivity is, for example\n\n    ᵢ κᵢⱼ ⱼc = - κx ⁴x + κy ⁴y + κz ⁴z c\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.TurbulenceClosures.SmagorinskyLilly-Union{Tuple{}, Tuple{Any}, Tuple{TD}} where TD","page":"Library","title":"Oceananigans.TurbulenceClosures.SmagorinskyLilly","text":"SmagorinskyLilly([FT=Float64;] C=0.23, Pr=1, ν=0, κ=0,\n                               time_discretization=ExplicitTimeDiscretization())\n\nReturn a SmagorinskyLilly type associated with the turbulence closure proposed by Lilly (1962) and Smagorinsky (1958, 1963), which has an eddy viscosity of the form\n\n`νₑ = (C * Δᶠ)² * √(2Σ²) * √(1 - Cb * N² / Σ²) + ν`,\n\nand an eddy diffusivity of the form\n\n`κₑ = (νₑ - ν) / Pr + κ`\n\nwhere Δᶠ is the filter width, Σ² = ΣᵢⱼΣᵢⱼ is the double dot product of the strain tensor Σᵢⱼ, Pr is the turbulent Prandtl number, and N² is the total buoyancy gradient, and Cb is a constant the multiplies the Richardson number modification to the eddy viscosity.\n\nKeyword arguments\n\n- `C`  : Model constant\n- `Cb` : Buoyancy term multipler (`Cb = 0` turns it off, `Cb ≠ 0` turns it on.\n         Typically `Cb=1/Pr`.)\n- `Pr` : Turbulent Prandtl numbers for each tracer. Either a constant applied to every\n         tracer, or a `NamedTuple` with fields for each tracer individually.\n- `ν`  : Constant background viscosity for momentum\n- `κ`  : Constant background diffusivity for tracer. Can either be a single number\n         applied to all tracers, or `NamedTuple` of diffusivities corresponding to each\n         tracer.\n- `time_discretization` : Either `ExplicitTimeDiscretization()` or `VerticallyImplicitTimeDiscretization()`, \n                          which integrates the terms involving only z-derivatives in the\n                          viscous and diffusive fluxes with an implicit time discretization.\n\nReferences\n\nSmagorinsky, J. \"On the numerical integration of the primitive equations of motion for     baroclinic flow in a closed region.\" Monthly Weather Review (1958)\n\nLilly, D. K. \"On the numerical simulation of buoyant convection.\" Tellus (1962)\n\nSmagorinsky, J. \"General circulation experiments with the primitive equations: I.     The basic experiment.\" Monthly weather review (1963)\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.TurbulenceClosures.IsotropicDiffusivity-Union{Tuple{}, Tuple{Any}, Tuple{TD}} where TD","page":"Library","title":"Oceananigans.TurbulenceClosures.IsotropicDiffusivity","text":"IsotropicDiffusivity(; ν=0, κ=0)\n\nReturns parameters for an isotropic diffusivity model with viscosity ν and thermal diffusivities κ for each tracer field in tracers ν and the fields of κ may be constants, arrays, fields, or functions of (x, y, z, t).\n\nκ may be a NamedTuple with fields corresponding to each tracer, or a single number to be a applied to all tracers.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.TurbulenceClosures.AnisotropicDiffusivity","page":"Library","title":"Oceananigans.TurbulenceClosures.AnisotropicDiffusivity","text":"AnisotropicDiffusivity{NX, NY, NZ, KX, KY, KZ}\n\nParameters for anisotropic diffusivity models.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.TurbulenceClosures.AnisotropicDiffusivity-Union{Tuple{}, Tuple{Any}, Tuple{TD}} where TD","page":"Library","title":"Oceananigans.TurbulenceClosures.AnisotropicDiffusivity","text":"AnisotropicDiffusivity(; νx=0, νy=0, νz=0, κx=0, κy=0, κz=0,\n                         νh=nothing, κh=nothing)\n\nReturns parameters for a closure with a diagonal diffusivity tensor with heterogeneous 'anisotropic' components labeled by x, y, z. Each component may be a number or function. The tracer diffusivities κx, κy, and κz may be NamedTuples with fields corresponding to each tracer, or a single number or function to be a applied to all tracers.\n\nIf νh or κh are provided, then νx = νy = νh, and κx = κy = κh, respectively.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation","page":"Library","title":"Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation","text":"AnisotropicMinimumDissipation{FT} <: AbstractTurbulenceClosure\n\nParameters for the \"anisotropic minimum dissipation\" turbulence closure for large eddy simulation proposed originally by Wybe Rozema , Hyun J. Bae , Parviz Moin , Roel Verstappen  (2015) and Mahdi Abkar , Hyun J. Bae , Parviz Moin  (2016), and then modified by Roel Verstappen  (2018), and finally described and validated for by Catherine A. Vreugdenhil , John R. Taylor  (2018).\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation-Union{Tuple{}, Tuple{Any}, Tuple{TD}} where TD","page":"Library","title":"Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation","text":"AnisotropicMinimumDissipation(FT=Float64; C=1/12, Cν=nothing, Cκ=nothing,\n                                          Cb=0.0, ν=0, κ=0,\n                                          time_discretization=ExplicitTimeDiscretization())\n\nReturns parameters of type FT for the AnisotropicMinimumDissipation turbulence closure.\n\nKeyword arguments\n\n- `C` : Poincaré constant for both eddy viscosity and eddy diffusivities. `C` is overridden\n        for eddy viscosity or eddy diffusivity if `Cν` or `Cκ` are set, respecitvely.\n- `Cν` : Poincaré constant for momentum eddy viscosity.\n- `Cκ` : Poincaré constant for tracer eddy diffusivities. If one number or function, the same\n         number or function is applied to all tracers. If a `NamedTuple`, it must possess\n         a field specifying the Poncaré constant for every tracer.\n- `Cb` : Buoyancy modification multiplier (`Cb = nothing` turns it off, `Cb = 1` was used by [Abkar16](@cite)).\n         *Note*: that we _do not_ subtract the horizontally-average component before computing this\n         buoyancy modification term. This implementation differs from [Abkar16](@cite)'s proposal\n         and the impact of this approximation has not been tested or validated.\n- `ν` : Constant background viscosity for momentum.\n- `κ` : Constant background diffusivity for tracer. If a single number, the same background\n        diffusivity is applied to all tracers. If a `NamedTuple`, it must possess a field\n        specifying a background diffusivity for every tracer.\n- `time_discretization` : Either `ExplicitTimeDiscretization()` or `VerticallyImplicitTimeDiscretization()`, \n                          which integrates the terms involving only z-derivatives in the\n                          viscous and diffusive fluxes with an implicit time discretization.\n\nBy default: C = Cν = Cκ = 1/12, which is appropriate for a finite-volume method employing a second-order advection scheme, Cb = nothing, which terms off the buoyancy modification term.\n\nCν or Cκ may be constant numbers, or functions of x, y, z.\n\nExample\n\njulia> pretty_diffusive_closure = AnisotropicMinimumDissipation(C=1/2)\nAnisotropicMinimumDissipation{Float64} turbulence closure with:\n           Poincaré constant for momentum eddy viscosity Cν: 0.5\n    Poincaré constant for tracer(s) eddy diffusivit(ies) Cκ: 0.5\n                        Buoyancy modification multiplier Cb: nothing\n                Background diffusivit(ies) for tracer(s), κ: 0.0\n             Background kinematic viscosity for momentum, ν: 0.0\n\njulia> const Δz = 0.5; # grid resolution at surface\n\njulia> surface_enhanced_tracer_C(x, y, z) = 1/12 * (1 + exp((z + Δz/2) / 8Δz))\nsurface_enhanced_tracer_C (generic function with 1 method)\n\njulia> fancy_closure = AnisotropicMinimumDissipation(Cκ=surface_enhanced_tracer_C)\nAnisotropicMinimumDissipation{Float64} turbulence closure with:\n           Poincaré constant for momentum eddy viscosity Cν: 0.08333333333333333\n    Poincaré constant for tracer(s) eddy diffusivit(ies) Cκ: surface_enhanced_tracer_C\n                        Buoyancy modification multiplier Cb: nothing\n                Background diffusivit(ies) for tracer(s), κ: 0.0\n             Background kinematic viscosity for momentum, ν: 0.0\n\njulia> tracer_specific_closure = AnisotropicMinimumDissipation(Cκ=(c₁=1/12, c₂=1/6))\nAnisotropicMinimumDissipation{Float64} turbulence closure with:\n           Poincaré constant for momentum eddy viscosity Cν: 0.08333333333333333\n    Poincaré constant for tracer(s) eddy diffusivit(ies) Cκ: (c₁ = 0.08333333333333333, c₂ = 0.16666666666666666)\n                        Buoyancy modification multiplier Cb: nothing\n                Background diffusivit(ies) for tracer(s), κ: 0.0\n             Background kinematic viscosity for momentum, ν: 0.0\n\nReferences\n\nVreugdenhil C., and Taylor J. (2018), \"Large-eddy simulations of stratified plane Couette     flow using the anisotropic minimum-dissipation model\", Physics of Fluids 30, 085104.\n\nVerstappen, R. (2018), \"How much eddy dissipation is needed to counterbalance the nonlinear     production of small, unresolved scales in a large-eddy simulation of turbulence?\",     Computers & Fluids 176, pp. 276-284.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.TurbulenceClosures.TwoDimensionalLeith","page":"Library","title":"Oceananigans.TurbulenceClosures.TwoDimensionalLeith","text":"TwoDimensionalLeith([FT=Float64;] C=0.3, C_Redi=1, C_GM=1)\n\nReturn a TwoDimensionalLeith type associated with the turbulence closure proposed by Leith (1965) and Fox-Kemper & Menemenlis (2008) which has an eddy viscosity of the form\n\n`νₑ = (C * Δᶠ)³ * √(|∇h ζ|² + |∇h ∂z w|²)`\n\nand an eddy diffusivity of the form...\n\nwhere Δᶠ is the filter width, ζ = ∂x v - ∂y u is the vertical vorticity, and C is a model constant.\n\nKeyword arguments\n\n- `C`      : Model constant\n- `C_Redi` : Coefficient for down-gradient tracer diffusivity for each tracer.\n             Either a constant applied to every tracer, or a `NamedTuple` with fields\n             for each tracer individually.\n- `C_GM`   : Coefficient for down-gradient tracer diffusivity for each tracer.\n             Either a constant applied to every tracer, or a `NamedTuple` with fields\n             for each tracer individually.\n\nReferences\n\nLeith, C. E. (1968). \"Diffusion Approximation for Two‐Dimensional Turbulence\", The Physics of     Fluids 11, 671. doi: 10.1063/1.1691968\n\nFox‐Kemper, B., & D. Menemenlis (2008), \"Can large eddy simulation techniques improve mesoscale rich     ocean models?\", in Ocean Modeling in an Eddying Regime, Geophys. Monogr. Ser., vol. 177, pp. 319–337.     doi: 10.1029/177GM19\n\nPearson, B. et al. (2017) , \"Evaluation of scale-aware subgrid mesoscale eddy models in a global eddy     rich model\", Ocean Modelling 115, 42-58. doi: 10.1016/j.ocemod.2017.05.007\n\n\n\n\n\n","category":"type"},{"location":"library/#Utilities","page":"Library","title":"Utilities","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Utils]\nPrivate = false\nPages   = [\n    \"Utils/Utils.jl\",\n    \"Utils/adapt_structure.jl\",\n    \"Utils/units.jl\",\n    \"Utils/loop_macros.jl\",\n    \"Utils/launch_config.jl\",\n    \"Utils/pretty_time.jl\",\n    \"Utils/pretty_filesize.jl\",\n    \"Utils/time_step_wizard.jl\",\n    \"Utils/tuple_utils.jl\",\n    \"Utils/ordered_dict_show.jl\",\n    \"Utils/cell_advection_timescale.jl\",\n    \"Utils/output_writer_diagnostic_utils.jl\",\n    \"Utils/with_tracers.jl\"\n]","category":"page"},{"location":"library/#Oceananigans.Utils.prettytime-Tuple{Any}","page":"Library","title":"Oceananigans.Utils.prettytime","text":"prettytime(t)\n\nConvert a floating point value t representing an amount of time in seconds to a more human-friendly formatted string with three decimal places. Depending on the value of t the string will be formatted to show t in nanoseconds (ns), microseconds (μs), milliseconds (ms), seconds, minutes, hours, days, or years.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Utils.pretty_filesize","page":"Library","title":"Oceananigans.Utils.pretty_filesize","text":"pretty_filesize(s, suffix=\"B\")\n\nConvert a floating point value s representing a file size to a more human-friendly formatted string with one decimal places with a suffix defaulting to \"B\". Depending on the value of s the string will be formatted to show s using an SI prefix from bytes, kiB (1024 bytes), MiB (1024² bytes), and so on up to YiB (1024⁸ bytes).\n\n\n\n\n\n","category":"function"},{"location":"library/#Oceananigans.Utils.cell_advection_timescale-Tuple{Any,Any,Any,RegularRectilinearGrid}","page":"Library","title":"Oceananigans.Utils.cell_advection_timescale","text":"Returns the time-scale for advection on a regular grid across a single grid cell.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Utils.with_tracers-Tuple{Any,NamedTuple,Any}","page":"Library","title":"Oceananigans.Utils.with_tracers","text":"with_tracers(tracer_names, initial_tuple, tracer_default)\n\nCreate a tuple corresponding to the solution variables u, v, w, and tracer_names. initial_tuple is a NamedTuple that at least has fields u, v, and w, and may have some fields corresponding to the names in tracer_names. tracer_default is a function that produces a default tuple value for each tracer if not included in initial_tuple.\n\n\n\n\n\n","category":"method"},{"location":"library/#Abstract-operations","page":"Library","title":"Abstract operations","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [Oceananigans, Oceananigans.AbstractOperations]\nPrivate = false\nPages   = [\n    \"AbstractOperations/AbstractOperations.jl\",\n    \"AbstractOperations/unary_operations.jl\",\n    \"AbstractOperations/binary_operations.jl\",\n    \"AbstractOperations/multiary_operations.jl\",\n    \"AbstractOperations/derivatives.jl\",\n    \"AbstractOperations/function_fields.jl\",\n    \"AbstractOperations/computations.jl\",\n    \"AbstractOperations/interpolation_utils.jl\",\n    \"AbstractOperations/show_abstract_operations.jl\",\n    \"AbstractOperations/grid_validation.jl\"\n]","category":"page"},{"location":"library/#Oceananigans.AbstractOperations.@unary-Tuple","page":"Library","title":"Oceananigans.AbstractOperations.@unary","text":"@unary op1 op2 op3...\n\nTurn each unary function in the list (op1, op2, op3...) into a unary operator on Oceananigans.Fields for use in AbstractOperations.\n\nNote: a unary function is a function with one argument: for example, sin(x) is a unary function.\n\nAlso note: a unary function in Base must be imported to be extended: use import Base: op; @unary op.\n\nExample\n\njulia> using Oceananigans, Oceananigans.Grids, Oceananigans.AbstractOperations\n\njulia> square_it(x) = x^2\nsquare_it (generic function with 1 method)\n\njulia> @unary square_it\nSet{Any} with 8 elements:\n  :sqrt\n  :square_it\n  :cos\n  :exp\n  :interpolate_identity\n  :-\n  :tanh\n  :sin\n\njulia> c = Field(Center, Center, Center, CPU(), RegularRectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)));\n\njulia> square_it(c)\nUnaryOperation at (Center, Center, Center)\n├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1)\n│   └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]\n└── tree:\n    square_it at (Center, Center, Center) via identity\n    └── Field located at (Center, Center, Center)\n\n\n\n\n\n","category":"macro"},{"location":"library/#Oceananigans.AbstractOperations.@binary-Tuple","page":"Library","title":"Oceananigans.AbstractOperations.@binary","text":"@binary op1 op2 op3...\n\nTurn each binary function in the list (op1, op2, op3...) into a binary operator on Oceananigans.Fields for use in AbstractOperations.\n\nNote: a binary function is a function with two arguments: for example, +(x, y) is a binary function.\n\nAlso note: a binary function in Base must be imported to be extended: use import Base: op; @binary op.\n\nExample\n\n```jldoctest julia> using Oceananigans, Oceananigans.AbstractOperations, Oceananigans.Grids\n\njulia> plusortimes(x, y) = x < 0 ? x + y : x * y plusortimes (generic function with 1 method)\n\njulia> @binary plusortimes 6-element Array{Any,1}:  :+  :-  :/  :^  :*  :plusortimes\n\njulia> c, d = (Field(Center, Center, Center, CPU(), RegularRectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))) for i = 1:2);\n\njulia> plusortimes(c, d) BinaryOperation at (Center, Center, Center) ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1) │   └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0] └── tree:     plusortimes at (Center, Center, Center) via identity     ├── Field located at (Center, Center, Center)     └── Field located at (Center, Center, Center)\n\n\n\n\n\n","category":"macro"},{"location":"library/#Oceananigans.AbstractOperations.@multiary-Tuple","page":"Library","title":"Oceananigans.AbstractOperations.@multiary","text":"@multiary op1 op2 op3...\n\nTurn each multiary operator in the list (op1, op2, op3...) into a multiary operator on Oceananigans.Fields for use in AbstractOperations.\n\nNote that a multiary operator:     * is a function with two or more arguments: for example, +(x, y, z) is a multiary function;     * must be imported to be extended if part of Base: use import Base: op; @multiary op;     * can only be called on Oceananigans.Fields if the \"location\" is noted explicitly; see example.\n\nExample\n\n```jldoctest julia> using Oceananigans, Oceananigans.Grids, Oceananigans.AbstractOperations\n\njulia> harmonicplus(a, b, c) = 1/3 * (1/a + 1/b + 1/c) harmonicplus(generic function with 1 method)\n\njulia> c, d, e = Tuple(Field(Center, Center, Center, CPU(), RegularRectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))) for i = 1:3);\n\njulia> harmonic_plus(c, d, e) # before magic @multiary transformation BinaryOperation at (Center, Center, Center) ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1) │   └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0] └── tree:     * at (Center, Center, Center) via identity     ├── 0.3333333333333333     └── + at (Center, Center, Center)         ├── / at (Center, Center, Center) via identity         │   ├── 1         │   └── Field located at (Center, Center, Center)         ├── / at (Center, Center, Center) via identity         │   ├── 1         │   └── Field located at (Center, Center, Center)         └── / at (Center, Center, Center) via identity             ├── 1             └── Field located at (Center, Center, Center)\n\njulia> @multiary harmonicplus Set{Any} with 3 elements:   :+   :harmonicplus   :*\n\njulia> harmonicplus(c, d, e) MultiaryOperation at (Center, Center, Center) ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1) │   └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0] └── tree:     harmonicplus at (Center, Center, Center)     ├── Field located at (Center, Center, Center)     ├── Field located at (Center, Center, Center)     └── Field located at (Center, Center, Center)\n\n\n\n\n\n","category":"macro"},{"location":"library/#Oceananigans.AbstractOperations.∂x-Tuple{Union{Type{Nothing}, Type{Center}, Type{Face}},Union{Type{Nothing}, Type{Center}, Type{Face}},Union{Type{Nothing}, Type{Center}, Type{Face}}}","page":"Library","title":"Oceananigans.AbstractOperations.∂x","text":"Return the x-derivative function acting at (X, Y, Any).\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.AbstractOperations.∂x-Union{Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,A,G,T,N} where N where T where G<:Union{Nothing, AbstractGrid} where A<:Union{Nothing, Oceananigans.Architectures.AbstractArchitecture}}, Tuple{Z}, Tuple{Y}, Tuple{X}} where Z where Y where X","page":"Library","title":"Oceananigans.AbstractOperations.∂x","text":"∂x(a::AbstractField)\n\nReturn an abstract representation of a x-derivative acting on a.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.AbstractOperations.∂x-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{Tuple,Oceananigans.Fields.AbstractField{X,Y,Z,A,G,T,N} where N where T where G<:Union{Nothing, AbstractGrid} where A<:Union{Nothing, Oceananigans.Architectures.AbstractArchitecture}}} where Z where Y where X","page":"Library","title":"Oceananigans.AbstractOperations.∂x","text":"∂x(L::Tuple, a::AbstractField)\n\nReturn an abstract representation of an x-derivative acting on a followed by interpolation to L, where L is a 3-tuple of Faces and Centers.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.AbstractOperations.∂y-Tuple{Union{Type{Nothing}, Type{Center}, Type{Face}},Union{Type{Nothing}, Type{Center}, Type{Face}},Union{Type{Nothing}, Type{Center}, Type{Face}}}","page":"Library","title":"Oceananigans.AbstractOperations.∂y","text":"Return the y-derivative function acting at (X, Y, Any).\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.AbstractOperations.∂y-Union{Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,A,G,T,N} where N where T where G<:Union{Nothing, AbstractGrid} where A<:Union{Nothing, Oceananigans.Architectures.AbstractArchitecture}}, Tuple{Z}, Tuple{Y}, Tuple{X}} where Z where Y where X","page":"Library","title":"Oceananigans.AbstractOperations.∂y","text":"∂y(a::AbstractField)\n\nReturn an abstract representation of a y-derivative acting on a.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.AbstractOperations.∂y-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{Tuple,Oceananigans.Fields.AbstractField{X,Y,Z,A,G,T,N} where N where T where G<:Union{Nothing, AbstractGrid} where A<:Union{Nothing, Oceananigans.Architectures.AbstractArchitecture}}} where Z where Y where X","page":"Library","title":"Oceananigans.AbstractOperations.∂y","text":"∂y(L::Tuple, a::AbstractField)\n\nReturn an abstract representation of a y-derivative acting on a followed by interpolation to L, where L is a 3-tuple of Faces and Centers.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.AbstractOperations.∂z-Tuple{Union{Type{Nothing}, Type{Center}, Type{Face}},Union{Type{Nothing}, Type{Center}, Type{Face}},Union{Type{Nothing}, Type{Center}, Type{Face}}}","page":"Library","title":"Oceananigans.AbstractOperations.∂z","text":"Return the z-derivative function acting at (Any, Any, Z).\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.AbstractOperations.∂z-Union{Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,A,G,T,N} where N where T where G<:Union{Nothing, AbstractGrid} where A<:Union{Nothing, Oceananigans.Architectures.AbstractArchitecture}}, Tuple{Z}, Tuple{Y}, Tuple{X}} where Z where Y where X","page":"Library","title":"Oceananigans.AbstractOperations.∂z","text":"∂z(a::AbstractField)\n\nReturn an abstract representation of a z-derivative acting on a.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.AbstractOperations.∂z-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{Tuple,Oceananigans.Fields.AbstractField{X,Y,Z,A,G,T,N} where N where T where G<:Union{Nothing, AbstractGrid} where A<:Union{Nothing, Oceananigans.Architectures.AbstractArchitecture}}} where Z where Y where X","page":"Library","title":"Oceananigans.AbstractOperations.∂z","text":"∂z(L::Tuple, a::AbstractField)\n\nReturn an abstract representation of a z-derivative acting on a followed by interpolation to L, where L is a 3-tuple of Faces and Centers.\n\n\n\n\n\n","category":"method"},{"location":"model_setup/architecture/#Architecture","page":"Architecture","title":"Architecture","text":"","category":"section"},{"location":"model_setup/architecture/","page":"Architecture","title":"Architecture","text":"Passing architecture = CPU() or architecture = GPU() to the Model constructor will determine whether the model is time stepped on a CPU or GPU.","category":"page"},{"location":"model_setup/architecture/","page":"Architecture","title":"Architecture","text":"Ideally a set up or simulation script does not need to be modified to run on a GPU but we are still smoothing out rough edges. Generally the CPU wants Array objects while the GPU wants CuArray objects.","category":"page"},{"location":"model_setup/architecture/","page":"Architecture","title":"Architecture","text":"tip: Running on GPUs\nIf you are having issues with running Oceananigans on a GPU, please open an issue and we'll do our best to help out.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#numerical_les","page":"Large eddy simulation","title":"Large eddy simulation","text":"","category":"section"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"The idea behind large eddy simulation (LES) is to resolve the \"large eddies\" while modeling the effect of unresolved sub-grid scale motions. This is done usually be assuming eddy viscosity and eddy diffusivity models and providing an estimate for the eddy viscosity nu_e and diffusivity kappa_e.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"Much of the early work on LES was motivated by the study of atmospheric boundary layer turbulence, being developed by J. Smagorinsky  (1963) and D K Lilly  (1966), then first implemented by J. W. Deardorff  (1970) and J. W. Deardorff  (1974).","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"In the LES framework, the Navier-Stokes equations are averaged in the same way as Osborne Reynolds  (1895) except that the mean field overlineboldsymbolu is obtained via convolution with a filter convolution kernel G","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"overlineboldsymbolu(boldsymbolx t) = G star boldsymbolu =\n  int_-infty^infty int_-infty^infty\n  boldsymbolu(boldsymbolx^prime t) G(boldsymbolx - boldsymbolx^prime t - tau)  dboldsymbolx^prime  mathrmd tau  ","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"as described by A. Leonard  (1975) who introduced the general filtering formalism.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"The overlineu_i^prime u_j^prime terms are now components of what is called the sub-grid scale (SGS) stress tensor tau^textSGS_ij, which looks the same as the Reynolds stress tensor so we will drop the SGS superscript.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"It is probably important to note that the large eddy simulation filtering operation does not satisfy the properties of a Reynolds operator (§2.1)P. Sagaut , C. Meneveau  (2006) and that in general, the filtered residual is not zero: overlineboldsymbolu^prime(boldsymbolx t) ne 0.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"§13.2 of S. B. Pope  (2000) lists a number of popular choices for the filter function G. For practical reasons we simply employ the box kernel","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"  beginequation\n  labeleqbox-kernel\n  G_Delta = G(boldsymbolx t) = frac1Delta H left( frac12Delta - boldsymbolx right) delta(t - t_n)  \n  endequation","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"where H is the Heaviside function, Delta is the grid spacing, and t_n is the current time step. With \\eqref{eq:box-kernel} we get back the averaging operator originally used by J. W. Deardorff  (1970)","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"overlineboldsymbolu(x y z t) =\n  frac1Delta x Delta y Delta z\n  int_x - frac12Delta x^x + frac12Delta x\n  int_y - frac12Delta y^y + frac12Delta y\n  int_z - frac12Delta z^z + frac12Delta z\n  boldsymbolu(xi eta zeta t)  mathrmd xi  mathrmd eta  mathrmd zeta  ","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"which if evaluated at the cell centers just returns the cell averages we already compute in the finite volume method.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#Smagorinsky-Lilly-model","page":"Large eddy simulation","title":"Smagorinsky-Lilly model","text":"","category":"section"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"J. Smagorinsky  (1963) estimated the eddy viscosity nu_e via a characteristic length scale Delta times a velocity scale given by Delta overlineS where overlineS = sqrt2overlineS_ijoverlineS_ij. Thus the SGS stress tensor is given by","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"tau_ij = -2nu_e overlineS_ij = -2 (C_s Delta)^2 overlineS overlineS_ij  ","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"where C_s is a dimensionless constant. The grid spacing is usually used for the characteristic length scale Delta. The eddy diffusivities are calculated via kappa_e = nu_e  textPr_t where the turbulent Prandtl number textPr_t is usually chosen to be mathcalO(1) from experimental observations.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"Assuming that the SGS energy cascade is equal to the overall dissipation rate varepsilon from the A. Kolmogorov  (1941) theory, D K Lilly  (1966) was able to derive a value of","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"C_s = left( frac32C_Kpi^frac43 right)^-frac34 approx 016  ","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"using an empirical value of C_K approx 16 for the Kolmogorov constant. This seems reasonable for isotropic turbulence if the grid spacing Delta falls in the inertial range. In practice, C_s is a tunable parameter.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"Due to the presence of the constant C_s, the model is sometimes referred to as the constant Smagorinsky model in contrast to dynamic Smagorinsky models that dynamically compute C_s to account for effects such as buoyant convection.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#Anisotropic-minimum-dissipation-models","page":"Large eddy simulation","title":"Anisotropic minimum dissipation models","text":"","category":"section"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"Minimum-dissipation eddy-viscosity models are a class of LES closures that use the minimum eddy dissipation required to dissipate the energy of sub-grid scale motion. Wybe Rozema , Hyun J. Bae , Parviz Moin , Roel Verstappen  (2015) proposed the first minimum-dissipation model appropriate for use on anisotropic grids, termed the anisotropic minimum dissipation (AMD) model.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"It has a number of desirable properties over Smagorinsky-type closures: it is more cost-effective than dynamic Smagorinsky, it appropriately switches off in laminar and transitional flows, and it is consistent with the exact SGS stress tensor on both isotropic and anisotropic grids. Mahdi Abkar , Hyun J. Bae , Parviz Moin  (2016) extended the AMD model to model SGS scalar fluxes for tracer transport. Mahdi Abkar , Parviz Moin  (2017) further extended the model to include a buoyancy term that accounts for the contribution of buoyant forces to the production and suppression of turbulence.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"Catherine A. Vreugdenhil , John R. Taylor  (2018) derive a modified AMD model by following the requirement suggested by Roel Verstappen  (2018), which entail normalising the displacement, the velocity, and the velocity gradient by the filter width to ensure that the resulting eddy dissipation properly counteracts the spurious kinetic energy transferred by convective nonlinearity, to derive a modified AMD model.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"The eddy viscosity and diffusivity are defined in terms of eddy viscosity and diffusivity predictors nu_e^dagger and kappa_e^dagger, such that","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"nu_e = max lbrace 0 nu_e^dagger rbrace\nquad textand quad\nkappa_e = max lbrace 0 kappa_e^dagger rbrace  ","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"to ensure that nu_e ge 0 and kappa_e ge 0. Leaving out the overlines and understanding that all variables represent the resolved/filtered variables, the eddy viscosity predictor is given by","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"    beginequation\n    labeleqnu-dagger\n    nu_e^dagger = -(CDelta)^2\n      frac\n        left( hatpartial_k hatu_i right) left( hatpartial_k hatu_j right) hatS_ij\n        + C_bhatdelta_i3 alpha g left( hatpartial_k hatu_i right) hatpartial_k theta\n        left( hatpartial_l hatu_m right) left( hatpartial_l hatu_m right)  \n    endequation","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"and the eddy diffusivity predictor by","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"    beginequation\n    kappa_e^dagger = -(CDelta)^2\n    frac\n        left( hatpartial_k hatu_i right) left( hatpartial_k hattheta right) hatpartial_i theta\n        left( hatpartial_l hattheta right) left( hatpartial_l hattheta right)  \n    endequation","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"where","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"  beginequation\n  hatx_i = fracx_iDelta_i quad\n  hatu_i(hatx t) = fracu_i(x t)Delta_i quad\n  hatpartial_i hatu_j(hatx t) = fracDelta_iDelta_j partial_i u_j(x t) quad\n  hatdelta_i3 = fracdelta_i3Delta_3  \n  endequation","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"so that the normalized rate of strain tensor is","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"    beginequation\n    labeleqS-hat\n    hatS_ij =\n      frac12 left hatpartial_i hatu_j(hatx t) + hatpartial_j hatu_i(hatx t) right  \n    endequation","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"In equations \\eqref{eq:nu-dagger}–\\eqref{eq:S-hat}, C is a modified Poincaré \"constant\" that is independent from the filter width Delta but does depend on the accuracy of the discretization method used. Mahdi Abkar , Hyun J. Bae , Parviz Moin  (2016) cite C^2 = frac112 for a spectral method and C^2 = frac13 for a second-order accurate scheme. Delta_i is the filter width in the x_i-direction, and Delta is given by the square root of the harmonic mean of the squares of the filter widths in each direction","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"    frac1Delta^2 = frac13 left( frac1Delta x^2 + frac1Delta y^2 + frac1Delta z^2 right)  ","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"The term multiplying C_b is the buoyancy modification introduced by Mahdi Abkar , Parviz Moin  (2017) and is small for weakly stratified flows. We have introduced the C_b constant so that the buoyancy modification term may be turned on and off.","category":"page"},{"location":"physics/boundary_conditions/#Boundary-conditions","page":"Boundary conditions","title":"Boundary conditions","text":"","category":"section"},{"location":"physics/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"In Oceananigans.jl the user may impose \\textit{no-penetration}, \\textit{flux}, \\textit{gradient} (Neumann), and \\textit{value} (Dirichlet) boundary conditions in bounded, non-periodic directions. Note that the only boundary condition available for a velocity field normal to the bounded direction is \\textit{no-penetration}.","category":"page"},{"location":"physics/boundary_conditions/#Flux-boundary-conditions","page":"Boundary conditions","title":"Flux boundary conditions","text":"","category":"section"},{"location":"physics/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"A flux boundary condition prescribes flux of a quantity normal to the boundary.   For a tracer c this corresponds to prescribing","category":"page"},{"location":"physics/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"q_c  _b equiv boldsymbolq_c boldsymbolcdot hatboldsymboln  _partial Omega_b  ","category":"page"},{"location":"physics/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"where partial Omega_b is an external boundary.","category":"page"},{"location":"physics/boundary_conditions/#Gradient-(Neumann)-boundary-condition","page":"Boundary conditions","title":"Gradient (Neumann) boundary condition","text":"","category":"section"},{"location":"physics/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"A gradient boundary condition prescribes the gradient of a field normal to the boundary. For a tracer c this prescribes","category":"page"},{"location":"physics/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"gamma equiv boldsymbolnabla c boldsymbolcdot hatboldsymboln  _partial Omega_b  ","category":"page"},{"location":"physics/boundary_conditions/#Value-(Dirichlet)-boundary-condition","page":"Boundary conditions","title":"Value (Dirichlet) boundary condition","text":"","category":"section"},{"location":"physics/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"A value boundary condition prescribes the value of a field on a boundary; for a tracer this prescribes","category":"page"},{"location":"physics/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"c_b equiv c  _partial Omega_b  ","category":"page"},{"location":"physics/boundary_conditions/#No-penetration-boundary-condition","page":"Boundary conditions","title":"No penetration boundary condition","text":"","category":"section"},{"location":"physics/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"A no penetration boundary condition prescribes the velocity component normal to a boundary to be 0, so that","category":"page"},{"location":"physics/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"boldsymbolhatn boldsymbolcdot boldsymbolu  _partial Omega_b = 0  ","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"EditURL = \"<unknown>/examples/one_dimensional_diffusion.jl\"","category":"page"},{"location":"generated/one_dimensional_diffusion/#Simple-diffusion-example","page":"One-dimensional diffusion","title":"Simple diffusion example","text":"","category":"section"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"This is Oceananigans.jl's simplest example: the diffusion of a one-dimensional Gaussian. This example demonstrates","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"How to load Oceananigans.jl.\nHow to instantiate an Oceananigans.jl model.\nHow to create simple Oceananigans.jl output.\nHow to set an initial condition with a function.\nHow to time-step a model forward.\nHow to look at results.","category":"page"},{"location":"generated/one_dimensional_diffusion/#Install-dependencies","page":"One-dimensional diffusion","title":"Install dependencies","text":"","category":"section"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"using Pkg\npkg\"add Oceananigans, JLD2, Plots\"","category":"page"},{"location":"generated/one_dimensional_diffusion/#Using-Oceananigans.jl","page":"One-dimensional diffusion","title":"Using Oceananigans.jl","text":"","category":"section"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Write","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"using Oceananigans","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"to load Oceananigans functions and objects into our script.","category":"page"},{"location":"generated/one_dimensional_diffusion/#Instantiating-and-configuring-a-model","page":"One-dimensional diffusion","title":"Instantiating and configuring a model","text":"","category":"section"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"A core Oceananigans type is IncompressibleModel. We build an IncompressibleModel by passing it a grid, plus information about the equations we would like to solve.","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Below, we build a regular rectilinear grid with 128 grid points in the z-direction, where z spans from z = -0.5 to z = 0.5,","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"grid = RegularRectilinearGrid(size=128, z=(-0.5, 0.5), topology=(Flat, Flat, Bounded))","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"The default topology is (Periodic, Periodic, Bounded) but since we only want to solve a one-dimensional problem, we assign the x and y dimensions to Flat. We could specify each of them to be either Periodic or Bounded but that will define a halo in each of those directions, and that is numerically more costly. Note that we only specify the extent and size for the Bounded dimension.","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"We next specify a model with an IsotropicDiffusivity, which models either molecular or turbulent diffusion,","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"closure = IsotropicDiffusivity(κ=1.0)","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"We finally pass these two ingredients to IncompressibleModel,","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"model = IncompressibleModel(grid=grid, closure=closure)","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Our simple grid and model use a number of defaults:","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"The default grid topology is periodic in x, y and bounded in z.\nThe default Model has no-flux (insulating and stress-free) boundary conditions on non-periodic boundaries for velocities u, v, w and tracers.\nThe default Model has two tracers: temperature T, and salinity S.\nThe default Model uses a SeawaterBuoyancy model with a LinearEquationOfState. However, buoyancy is not active in the simulation we run below.","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Next, we set! an initial condition on the temperature field, model.tracers.T. Our objective is to observe the diffusion of a Gaussian.","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"width = 0.1\n\ninitial_temperature(x, y, z) = exp(-z^2 / (2width^2))\n\nset!(model, T=initial_temperature)","category":"page"},{"location":"generated/one_dimensional_diffusion/#Visualizing-model-data","page":"One-dimensional diffusion","title":"Visualizing model data","text":"","category":"section"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Calling set! above changes the data contained in model.tracers.T, which was initialized as 0's when the model was created. To see the new data in model.tracers.T, we plot it:","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"using Plots\n\nz = znodes(model.tracers.T)\n\nT_plot = plot(interior(model.tracers.T)[1, 1, :], z,\n              linewidth = 2,\n              label = \"t = 0\",\n              xlabel = \"Temperature (ᵒC)\",\n              ylabel = \"z\")","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"The function interior above extracts a view of the physical interior points of model.tracers.T. This is useful because model.tracers.T also contains \"halo\" points that lie outside the physical domain (halo points are used to set boundary conditions during time-stepping).","category":"page"},{"location":"generated/one_dimensional_diffusion/#Running-a-Simulation","page":"One-dimensional diffusion","title":"Running a Simulation","text":"","category":"section"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Next we set-up a Simulation that time-steps the model forward and manages output.","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"# Time-scale for diffusion across a grid cell\ndiffusion_time_scale = model.grid.Δz^2 / model.closure.κ.T\n\nsimulation = Simulation(model, Δt = 0.1 * diffusion_time_scale, stop_iteration = 1000)","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"simulation will run for 1000 iterations with a time-step that resolves the time-scale at which our temperature field diffuses. All that's left is to","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"run!(simulation)","category":"page"},{"location":"generated/one_dimensional_diffusion/#Visualizing-the-results","page":"One-dimensional diffusion","title":"Visualizing the results","text":"","category":"section"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Let's look at how model.tracers.T changed during the simulation.","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"using Printf\n\nplot!(T_plot, interior(model.tracers.T)[1, 1, :], z, linewidth=2,\n      label=@sprintf(\"t = %.3f\", model.clock.time))","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Very interesting! Next, we run the simulation a bit longer and make an animation. For this, we use the JLD2OutputWriter to write data to disk as the simulation progresses.","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"using Oceananigans.OutputWriters: JLD2OutputWriter, IterationInterval\n\nsimulation.output_writers[:temperature] =\n    JLD2OutputWriter(model, model.tracers, prefix = \"one_dimensional_diffusion\",\n                     schedule=IterationInterval(100), force = true)","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"We run the simulation for 10,000 more iterations,","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"simulation.stop_iteration += 10000\n\nrun!(simulation)","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Finally, we animate the results by opening the JLD2 file, extract the iterations we ended up saving at, and plot the evolution of the temperature profile in a loop over the iterations.","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"using JLD2\n\nfile = jldopen(simulation.output_writers[:temperature].filepath)\n\niterations = parse.(Int, keys(file[\"timeseries/t\"]))\n\nanim = @animate for (i, iter) in enumerate(iterations)\n\n    T = file[\"timeseries/T/$iter\"][1, 1, :]\n    t = file[\"timeseries/t/$iter\"]\n\n    plot(T, z, linewidth=2, title=@sprintf(\"t = %.3f\", t),\n         label=\"\", xlabel=\"Temperature\", ylabel=\"z\", xlims=(0, 1))\nend\n\nmp4(anim, \"one_dimensional_diffusion.mp4\", fps = 15) # hide","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"This page was generated using Literate.jl.","category":"page"},{"location":"appendix/fractional_step/#Fractional-step-method","page":"Fractional step method","title":"Fractional step method","text":"","category":"section"},{"location":"appendix/fractional_step/","page":"Fractional step method","title":"Fractional step method","text":"Solving the momentum equation \\eqref{eq:momentumFV} coupled with the continuity equation can  be cumbersome so instead we employ a fractional step method. To approximate the solution of  the coupled system we first solve an approximation to the discretized momentum equation for an  intermediate velocity field boldsymbolu^star without worrying about satisfying the  incompressibility constraint. We then project boldsymbolu^star onto the space of  divergence-free velocity fields to obtain a value for boldsymbolu^n+1 that satisfies  continuity.","category":"page"},{"location":"appendix/fractional_step/","page":"Fractional step method","title":"Fractional step method","text":"We thus discretize the momentum equation as","category":"page"},{"location":"appendix/fractional_step/","page":"Fractional step method","title":"Fractional step method","text":"  fracboldsymbolu^star - boldsymbolu^nDelta t\n    = - left boldsymbolu boldsymbolcdot boldsymbolnabla boldsymbolu right^n+frac12\n      - 2 boldsymbolOmega times boldsymbolu^n+frac12\n      + boldsymbolnabla boldsymbolcdot left ( nu boldsymbolnabla boldsymbolu^n+frac12 right )\n      + boldsymbolF^n+frac12  ","category":"page"},{"location":"appendix/fractional_step/","page":"Fractional step method","title":"Fractional step method","text":"where the superscript n + frac12 indicates that these terms are evaluated at time step n + frac12, which we compute explicitly (see \\S\\ref{sec:time-stepping}).","category":"page"},{"location":"appendix/fractional_step/","page":"Fractional step method","title":"Fractional step method","text":"The projection is then performed","category":"page"},{"location":"appendix/fractional_step/","page":"Fractional step method","title":"Fractional step method","text":"   boldsymbolu^n+1 = boldsymbolu^star - Delta t  boldsymbolnabla phi^n+1  ","category":"page"},{"location":"appendix/fractional_step/","page":"Fractional step method","title":"Fractional step method","text":"to obtain a divergence-free velocity field boldsymbolu^n+1. Here the projection is performed by solving an elliptic problem for the pressure phi^n+1 with the boundary condition","category":"page"},{"location":"appendix/fractional_step/","page":"Fractional step method","title":"Fractional step method","text":"  boldsymbolhatn boldsymbolcdot boldsymbolnabla phi^n+1 _partialOmega = 0  ","category":"page"},{"location":"appendix/fractional_step/","page":"Fractional step method","title":"Fractional step method","text":"Steven A. Orszag , Moshe Israeli , Michel O. Deville  (1986) and David L. Brown , Ricardo Cortez , Michael L. Minion  (2001) raise an important issue regarding these fractional step  methods, which is that \"while the velocity can be reliably computed to second-order accuracy  in time and space, the pressure is typically only first-order accurate in the L_infty-norm.\"  The numerical boundary conditions must be carefully accounted for to ensure the second-order  accuracy promised by the fractional step methods.","category":"page"},{"location":"appendix/fractional_step/","page":"Fractional step method","title":"Fractional step method","text":"We are currently investigating whether our projection method is indeed second-order accurate  in both velocity and pressure (see \\S\\ref{sec:forced-flow}). However, it may not matter too  much for simulating high Reynolds number geophysical fluids as David L. Brown , Ricardo Cortez , Michael L. Minion  (2001) conclude that  \"Quite often, semi-implicit projection methods are applied to problems in which the viscosity  is small. Since the predicted first-order errors in the pressure are scaled by nu, it is  not clear whether the improved pressure-update formula is beneficial in such situations. ...  Finally, in some applications of projection methods, second-order accuracy in the pressure may  not be relevant or in some cases even possible due to the treatment of other terms in the equations.\"","category":"page"},{"location":"validation/lid_driven_cavity/#Lid-driven-cavity","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"","category":"section"},{"location":"validation/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"The lid-driven cavity test problem has been used for a long time as a simple validation test for computational fluid dynamics codes. First described by Odus R. Burggraf  (1966), the fluid is contained in a square cavity with Dirchlet boundary conditions on all four sides. The top wall moves with velocity U = 1 while the other three walls are stationary. The solution reaches a laminar steady-state whose properties can be compared with a huge amount of existing data. The canonical database is given by U Ghia , K.N Ghia , C.T Shin  (1982) who report detailed information on the velocity fields as well as the streamline and vorticity contours at various Reynolds numbers. More accurate data is reported by O. Botella , R. Peyret  (1998), E. Erturk , T. C. Corke , C. Gökçöl  (2005), and Charles-Henri Bruneau , Mazen Saad  (2006).","category":"page"},{"location":"validation/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"Below are lid-driven cavity simulation results from Oceananigans.jl compared with U Ghia , K.N Ghia , C.T Shin  (1982) for Re = 100, 400, 1000, 3200, 5000, 7500, and 10000.","category":"page"},{"location":"validation/lid_driven_cavity/#Re-100","page":"Lid-driven cavity","title":"Re = 100","text":"","category":"section"},{"location":"validation/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"<!-- See: https://jameshfisher.com/2017/08/30/how-do-i-make-a-full-width-iframe/ -->\n<div>\n  <div style=\"position:relative;padding-top:100%;\">\n    <iframe src=\"https://www.youtube.com/embed/Siv8XpcRRDw\" frameborder=\"0\"\n      allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen\n      style=\"position:absolute;top:0;left:0;width:100%;height:100%;\"></iframe>\n  </div>\n</div>","category":"page"},{"location":"validation/lid_driven_cavity/#Re-400","page":"Lid-driven cavity","title":"Re = 400","text":"","category":"section"},{"location":"validation/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"<div>\n  <div style=\"position:relative;padding-top:100%;\">\n    <iframe src=\"https://www.youtube.com/embed/5f9JELFuDX0\" frameborder=\"0\"\n      allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen\n      style=\"position:absolute;top:0;left:0;width:100%;height:100%;\"></iframe>\n  </div>\n</div>","category":"page"},{"location":"validation/lid_driven_cavity/#Re-1,000","page":"Lid-driven cavity","title":"Re = 1,000","text":"","category":"section"},{"location":"validation/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"<div>\n  <div style=\"position:relative;padding-top:100%;\">\n    <iframe src=\"https://www.youtube.com/embed/oTZj2o94AJU\" frameborder=\"0\"\n      allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen\n      style=\"position:absolute;top:0;left:0;width:100%;height:100%;\"></iframe>\n  </div>\n</div>","category":"page"},{"location":"validation/lid_driven_cavity/#Re-3,200","page":"Lid-driven cavity","title":"Re = 3,200","text":"","category":"section"},{"location":"validation/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"<div>\n  <div style=\"position:relative;padding-top:100%;\">\n    <iframe src=\"https://www.youtube.com/embed/GWPFwtWIcnY\" frameborder=\"0\"\n      allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen\n      style=\"position:absolute;top:0;left:0;width:100%;height:100%;\"></iframe>\n  </div>\n</div>","category":"page"},{"location":"validation/lid_driven_cavity/#Re-5,000","page":"Lid-driven cavity","title":"Re = 5,000","text":"","category":"section"},{"location":"validation/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"<div>\n  <div style=\"position:relative;padding-top:100%;\">\n    <iframe src=\"https://www.youtube.com/embed/_2beZxGmIDI\" frameborder=\"0\"\n      allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen\n      style=\"position:absolute;top:0;left:0;width:100%;height:100%;\"></iframe>\n  </div>\n</div>","category":"page"},{"location":"validation/lid_driven_cavity/#Re-7,500","page":"Lid-driven cavity","title":"Re = 7,500","text":"","category":"section"},{"location":"validation/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"<div>\n  <div style=\"position:relative;padding-top:100%;\">\n    <iframe src=\"https://www.youtube.com/embed/frwxgSG6rt0\" frameborder=\"0\"\n      allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen\n      style=\"position:absolute;top:0;left:0;width:100%;height:100%;\"></iframe>\n  </div>\n</div>","category":"page"},{"location":"validation/lid_driven_cavity/#Re-10,000","page":"Lid-driven cavity","title":"Re = 10,000","text":"","category":"section"},{"location":"validation/lid_driven_cavity/","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"<div>\n  <div style=\"position:relative;padding-top:100%;\">\n    <iframe src=\"https://www.youtube.com/embed/D8-fKSMc7DQ\" frameborder=\"0\"\n      allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen\n      style=\"position:absolute;top:0;left:0;width:100%;height:100%;\"></iframe>\n  </div>\n</div>","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#Buoyancy-models-and-equations-of-state","page":"Buoyancy models and equation of state","title":"Buoyancy models and equations of state","text":"","category":"section"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"The buoyancy option selects how buoyancy is treated. There are currently three options:","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"No buoyancy (and no gravity).\nEvolve buoyancy as a tracer.\nSeawater buoyancy: evolve temperature T and salinity S as tracers with a value for the gravitational acceleration g and an equation of state of your choosing. This is the default setting.","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#No-buoyancy","page":"Buoyancy models and equation of state","title":"No buoyancy","text":"","category":"section"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"To turn off buoyancy (and gravity) simply pass buoyancy = nothing to the model constructor.","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"DocTestSetup = quote\n    using Oceananigans\nend","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> grid = RegularRectilinearGrid(size=(64, 64, 64), extent=(1, 1, 1));\n\njulia> model = IncompressibleModel(grid=grid, buoyancy=nothing)\nIncompressibleModel{CPU, Float64}(time = 0 seconds, iteration = 0)\n├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=64)\n├── tracers: (:T, :S)\n├── closure: Nothing\n├── buoyancy: Nothing\n└── coriolis: Nothing","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"In this case, you might want to explicitly specify which tracers to evolve. In particular, you may not want to evolve temperature and salinity, which are included by default. To specify no tracers, also passtracers = () to the model constructor.","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> model = IncompressibleModel(grid=grid, buoyancy=nothing, tracers=())\nIncompressibleModel{CPU, Float64}(time = 0 seconds, iteration = 0)\n├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=64)\n├── tracers: ()\n├── closure: Nothing\n├── buoyancy: Nothing\n└── coriolis: Nothing","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#Buoyancy-as-a-tracer","page":"Buoyancy models and equation of state","title":"Buoyancy as a tracer","text":"","category":"section"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"To directly evolve buoyancy as a tracer simply pass buoyancy = BuoyancyTracer() to the model constructor. BuoyancyModels :b must be included as a tracer, for example,","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> model = IncompressibleModel(grid=grid, buoyancy=BuoyancyTracer(), tracers=(:b))\nIncompressibleModel{CPU, Float64}(time = 0 seconds, iteration = 0)\n├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=64)\n├── tracers: (:b,)\n├── closure: Nothing\n├── buoyancy: BuoyancyTracer\n└── coriolis: Nothing","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#Seawater-buoyancy","page":"Buoyancy models and equation of state","title":"Seawater buoyancy","text":"","category":"section"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"To evolve temperature T and salinity S and diagnose the buoyancy, you can pass buoyancy = SeawaterBuoyancy() which is the default.","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> model = IncompressibleModel(grid=grid, buoyancy=SeawaterBuoyancy())\nIncompressibleModel{CPU, Float64}(time = 0 seconds, iteration = 0)\n├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=64)\n├── tracers: (:T, :S)\n├── closure: Nothing\n├── buoyancy: SeawaterBuoyancy{Float64,LinearEquationOfState{Float64},Nothing,Nothing}\n└── coriolis: Nothing","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"Without any options specified, a value of g = 980665  textmtexts^-2 is used for the gravitational acceleration (corresponding to standard gravity) along with a linear equation of state with thermal expansion and haline contraction coefficients suitable for seawater.","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"If, for example, you wanted to simulate fluids on another planet such as Europa where g = 13  textmtexts^-2, then use","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> buoyancy = SeawaterBuoyancy(gravitational_acceleration=1.3)\nSeawaterBuoyancy{Float64}: g = 1.3\n└── equation of state: LinearEquationOfState{Float64}: α = 1.67e-04, β = 7.80e-04\n\njulia> model = IncompressibleModel(grid=grid, buoyancy=buoyancy)\nIncompressibleModel{CPU, Float64}(time = 0 seconds, iteration = 0)\n├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=64)\n├── tracers: (:T, :S)\n├── closure: Nothing\n├── buoyancy: SeawaterBuoyancy{Float64,LinearEquationOfState{Float64},Nothing,Nothing}\n└── coriolis: Nothing","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"When using SeawaterBuoyancy temperature :T and salinity :S tracers must be specified. Explicitly this can be accomplished by passing tracers = (:T, :S) to a model constructor.","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#Linear-equation-of-state","page":"Buoyancy models and equation of state","title":"Linear equation of state","text":"","category":"section"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"To use non-default thermal expansion and haline contraction coefficients, say alpha = 2 times 10^-3  textK^-1 and beta = 5 times 10^-4 textppt^-1 corresponding to some other fluid, then use","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> buoyancy = SeawaterBuoyancy(equation_of_state=LinearEquationOfState(α=1.67e-4, β=7.80e-4))\nSeawaterBuoyancy{Float64}: g = 9.80665\n└── equation of state: LinearEquationOfState{Float64}: α = 1.67e-04, β = 7.80e-04","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#Idealized-nonlinear-equations-of-state","page":"Buoyancy models and equation of state","title":"Idealized nonlinear equations of state","text":"","category":"section"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"Instead of a linear equation of state, five idealized (second-order) nonlinear equation of state as described by Fabien Roquet , Gurvan Madec , Laurent Brodeau , J. Nycander  (2015) may be used. These equations of state are provided via the SeawaterPolynomials.jl package.","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> using SeawaterPolynomials.SecondOrderSeawaterPolynomials\n\njulia> eos = RoquetSeawaterPolynomial(:Freezing)\nSecondOrderSeawaterPolynomial{Float64}(0.7718, -0.0491, 0.0, -2.5681e-5, 0.0, -0.005027, 0.0)\n\njulia> buoyancy = SeawaterBuoyancy(equation_of_state=eos)\nSeawaterBuoyancy{Float64}: g = 9.80665\n└── equation of state: SeawaterPolynomials.SecondOrderSeawaterPolynomials.SecondOrderSeawaterPolynomial{Float64}(0.7718, -0.0491, 0.0, -2.5681e-5, 0.0, -0.005027, 0.0)","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#TEOS-10-equation-of-state","page":"Buoyancy models and equation of state","title":"TEOS-10 equation of state","text":"","category":"section"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"A high-accuracy 55-term polynomial approximation to the TEOS-10 equation of state suitable for use in Boussinesq models as described by F. Roquet , G. Madec , Trevor J. McDougall , Paul M. Barker  (2015) is implemented in the SeawaterPolynomials.jl package and may be used.","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> using SeawaterPolynomials.TEOS10\n\njulia> eos = TEOS10EquationOfState()\nSeawaterPolynomials.BoussinesqEquationOfState{TEOS10SeawaterPolynomial{Float64},Int64}(TEOS10SeawaterPolynomial{Float64}(), 1020)","category":"page"},{"location":"appendix/staggered_grid/#Staggered-grid","page":"Staggered grid","title":"Staggered grid","text":"","category":"section"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"Velocities u, v, and w are defined on the faces of the cells, which are coincident with three orthogonal coordinate axes (the Cartesian axes in the case of Oceananigans). Pressure p and tracers c are stored at the cell  centers as cell averages. See schematic below of the different control volumes. Other quantities may be defined at other locations. For example, vorticity boldsymbolomega = boldsymbolnabla times boldsymbolu is defined at the cell edges.[1]","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"[1]: In 2D it would more correct to say the cell corners. In 3D, variables like vorticity lie at the same vertical levels as the cell-centered variables and so they really lie at the cell edges.","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"(Image: Schematic of control volumes) A schematic of Oceananigans.jl finite volumes for a two-dimensional staggered grid in (x z). Tracers c and pressure p are defined at the center of the control volume. The u control volumes are  centered on the left and right edges of the pressure control volume while the w control volumes are centered  on the top and bottom edges of the pressure control volumes. The indexing convention places the i^rmth  u-node on cell x-faces to the left of the i tracer point at cell centers. Figure credit: N. Kumar , J.H.M. Boonkkamp , B. Koren  (2016)","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"This staggered arrangement of variables is more complicated than the collocated grid arrangement but is greatly beneficial as it avoids the odd-even decoupling between the pressure and velocity if they are stored at the same positions. §6.1 of Suhas Patankar  (1980) discusses this problem in the presence of a zigzag pressure field: on a 1D collocated grid the velocity at the point i is influenced by the pressure at points i-1 and i+1, and a zigzag pressure field will be felt as a uniform pressure, which is obviously wrong and would reduce the accuracy of the solution. The pressure is effectively taken from a coarser grid than what is actually used. The basic problem is that the momentum equations will use the pressure difference between two alternate points when it should be using two adjacent points.","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"From the viewpoint of linear algebra, these spurious pressure modes correspond to solutions in the null space of the pressure projection operator with eigenvalue zero and are thus indistinguishable from a uniform pressure field R. L. Sani , P. M. Gresho , R. L. Lee , D. F. Griffiths  (1981).","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"The staggered grid was first introduced by Francis H. Harlow , J. Eddie Welch  (1965) with their marker and cell method. In meteorology and oceanography, this particular staggered grid configuration is referred to as the Arakawa C-grid after Akio Arakawa , Vivian R. Lamb  (1977), who investigated four different staggered grids and the unstaggered A-grid for use in an atmospheric model.","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"Akio Arakawa , Vivian R. Lamb  (1977) investigated the dispersion relation of inertia-gravity waves[2] traveling in the x-direction","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"  omega^2 = f^2 + gHk^2  ","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"in the linearized rotating shallow-water equations for five grids. Here omega is the angular frequency, H is the height of the fluid and k is the wavenumber in the x-direction. Looking at the effect of spatial discretization error on the frequency of these waves they find that the B and C-grids reproduce the dispersion relation most closely out of the five Akio Arakawa , Vivian R. Lamb  (1977) (Figure 5). In particular, the dispersion relation for the C-grid is given by","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"  omega^2 = f^2 left cos^2 left( frackDelta2 right)\n             + 4 left( fraclambdaDelta right)^2 sin^2 left( frackDelta2 right) right  ","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"where lambda is the wavelength and Delta is the grid spacing. Paraphrasing p. 184 of Akio Arakawa , Vivian R. Lamb  (1977): The wavelength of the shortest resolvable wave is 2Delta with corresponding wavenumber k = piDelta so it is sufficient to evaluate the dispersion relation over the range 0  k Delta  pi. The frequency is monotonically increasing for lambda  Delta  frac12 and monotonically decreasing for lambda  Delta  frac12. For the fourth smallest wave lambda  Delta = frac12 we get omega^2 = f^2 which matches the k = 0 wave. Furthermore, the group velocity is zero for all k. On the other grids, waves with k Delta = pi can behave like pure inertial oscillations or stationary waves, which is bad.","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"The B and C-grids are less oscillatory than the others and quite faithfully simulate geostrophic adjustment. However, the C-grid is the only one that faithfully reproduces the two-dimensional dispersion relation omega^2(k ell), all the other grids have false maxima, and so Akio Arakawa , Vivian R. Lamb  (1977) conclude that the C-grid is best for simulating geostrophic adjustment except for abnormal situations in which lambda  Delta is less than or close to 1. This seems to have held true for most atmospheric and oceanographic simulations as the C-grid is popular and widely used.","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"[2]: Apparently also called Poincaré waves, Sverdrup waves, and rotational gravity waves §13.9 of Pijush K. Kundu , Ira M. Cohen , David R Dowling  (2015).","category":"page"},{"location":"model_setup/setting_initial_conditions/#Setting-initial-conditions","page":"Setting initial conditions","title":"Setting initial conditions","text":"","category":"section"},{"location":"model_setup/setting_initial_conditions/","page":"Setting initial conditions","title":"Setting initial conditions","text":"Initial conditions are imposed after model construction. This can be easily done using the the set! function, which allows the setting of initial conditions using constant values, arrays, or functions.","category":"page"},{"location":"model_setup/setting_initial_conditions/","page":"Setting initial conditions","title":"Setting initial conditions","text":"DocTestSetup = quote\n    using Oceananigans\nend","category":"page"},{"location":"model_setup/setting_initial_conditions/","page":"Setting initial conditions","title":"Setting initial conditions","text":"julia> grid = RegularRectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1));\n\njulia> model = IncompressibleModel(grid=grid);\n\njulia> set!(model, u=0.1, v=1.5)","category":"page"},{"location":"model_setup/setting_initial_conditions/","page":"Setting initial conditions","title":"Setting initial conditions","text":"julia> grid = RegularRectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1));\n\njulia> model = IncompressibleModel(grid=grid);\n\njulia> ∂T∂z = 0.01;\n\njulia> ϵ(σ) = σ * randn();\n\njulia> T₀(x, y, z) = ∂T∂z * z + ϵ(1e-8);\n\njulia> set!(model, T=T₀)","category":"page"},{"location":"model_setup/setting_initial_conditions/","page":"Setting initial conditions","title":"Setting initial conditions","text":"tip: Divergence-free velocity fields\nNote that as part of the time-stepping algorithm, the velocity field is made divergence-free at every time step. So if a model is not initialized with a divergence-free velocity field, it may change on the first time step. As a result tracers may not be conserved up to machine precision at the first time step.","category":"page"},{"location":"model_setup/tracers/#Tracers","page":"Tracers","title":"Tracers","text":"","category":"section"},{"location":"model_setup/tracers/","page":"Tracers","title":"Tracers","text":"The tracers to be advected around can be specified via a list of symbols. By default the model evolves temperature and salinity","category":"page"},{"location":"model_setup/tracers/","page":"Tracers","title":"Tracers","text":"DocTestSetup = quote\n    using Oceananigans\nend","category":"page"},{"location":"model_setup/tracers/","page":"Tracers","title":"Tracers","text":"julia> grid = RegularRectilinearGrid(size=(64, 64, 64), extent=(1, 1, 1));\n\njulia> model = IncompressibleModel(grid=grid)\nIncompressibleModel{CPU, Float64}(time = 0 seconds, iteration = 0)\n├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=64)\n├── tracers: (:T, :S)\n├── closure: Nothing\n├── buoyancy: SeawaterBuoyancy{Float64,LinearEquationOfState{Float64},Nothing,Nothing}\n└── coriolis: Nothing","category":"page"},{"location":"model_setup/tracers/","page":"Tracers","title":"Tracers","text":"whose fields can be accessed via model.tracers.T and model.tracers.S.","category":"page"},{"location":"model_setup/tracers/","page":"Tracers","title":"Tracers","text":"julia> model.tracers.T\nField located at (Center, Center, Center)\n├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (64, 64, 64)\n├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=64)\n└── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, north=Periodic), z=(bottom=ZeroFlux, top=ZeroFlux)\n\njulia> model.tracers.S\nField located at (Center, Center, Center)\n├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (64, 64, 64)\n├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=64)\n└── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, north=Periodic), z=(bottom=ZeroFlux, top=ZeroFlux)\n","category":"page"},{"location":"model_setup/tracers/","page":"Tracers","title":"Tracers","text":"Any number of arbitrary tracers can be appended to this list and passed to a model constructor. For example, to evolve quantities C_1, CO₂, and nitrogen as additional passive tracers you could set them up as","category":"page"},{"location":"model_setup/tracers/","page":"Tracers","title":"Tracers","text":"julia> model = IncompressibleModel(grid=grid, tracers=(:T, :S, :C₁, :CO₂, :nitrogen))\nIncompressibleModel{CPU, Float64}(time = 0 seconds, iteration = 0)\n├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=64)\n├── tracers: (:T, :S, :C₁, :CO₂, :nitrogen)\n├── closure: Nothing\n├── buoyancy: SeawaterBuoyancy{Float64,LinearEquationOfState{Float64},Nothing,Nothing}\n└── coriolis: Nothing","category":"page"},{"location":"model_setup/tracers/","page":"Tracers","title":"Tracers","text":"info: Active vs. passive tracers\nAn active tracer typically denotes a tracer quantity that affects the fluid dynamics through buoyancy. In the ocean temperature and salinity are active tracers. Passive tracers, on the other hand, typically do not affect the fluid dynamics are are passively advected around by the flow field.","category":"page"},{"location":"validation/convergence_tests/#Convergence-Tests","page":"Convergence tests","title":"Convergence Tests","text":"","category":"section"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"Convergence tests are implemented in /validation/convergence_tests and range from zero-dimensional time-stepper tests to two-dimensional integration tests that involve non-trivial pressure fields, advection, and diffusion.","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"For all tests except point exponential decay, we use the L_1 norm,","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    L_1 equiv fracmathrmmean  phi_mathrmsim - phi_mathrmexact mathrmmean  phi_mathrmexact ","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"and L_infty norm,","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    L_infty equiv fracmax  phi_mathrmsim - phi_mathrmexact max  phi_mathrmexact   ","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"to compare simulated fields, phi_mathrmsim, with exact, analytically-derived solutions phi_mathrmexact. The field phi may be a tracer field or a velocity field.","category":"page"},{"location":"validation/convergence_tests/#Point-Exponential-Decay","page":"Convergence tests","title":"Point Exponential Decay","text":"","category":"section"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"This test analyzes time-stepper convergence by simulating the zero-dimensional, or spatially-uniform equation","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    partial_t c = - c  ","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"with the initial condition c = 1, which has the analytical solution c = mathrme^-t.","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"We find the expected first-order convergence with decreasing time-step Delta t using our first-order accurate, \"modified second-order\" Adams-Bashforth time-stepping method:","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"(Image: Point exponential decay)","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"This result validates the correctness of the Oceananigans implementation of Adams-Bashforth time-stepping.","category":"page"},{"location":"validation/convergence_tests/#One-dimensional-advection-and-diffusion-of-a-Gaussian","page":"Convergence tests","title":"One-dimensional advection and diffusion of a Gaussian","text":"","category":"section"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"This and the following tests focus on convergence with grid spacing, Delta x.","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"In one dimension with constant diffusivity kappa and in the presence of a constant velocity U, a Gaussian evolves according to","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    c = fracmathrme^- (x - U t)^2  4 kappa tsqrt4 pi kappa t  ","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"For this test we take the initial time as t=t_0. We simulate this problem with advection and diffusion, as well as with U=0 and thus diffusion only, as well as with kappa approx 0 and thus \"advection only\". The solutions are","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"(Image: Gaussian advection diffusion solutions)","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"which exhibit the expected second-order convergence with Delta x^2 propto 1  N_x^2:","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"(Image: Gaussian advection diffusion convergence)","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"These results validate the correctness of time-stepping, constant diffusivity operators, and advection operators.","category":"page"},{"location":"validation/convergence_tests/#One-dimensional-advection-and-diffusion-of-a-cosine","page":"Convergence tests","title":"One-dimensional advection and diffusion of a cosine","text":"","category":"section"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"In one dimension with constant diffusivity kappa and in the presence of a constant velocity U, a cosine evolves according to","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    c = mathrme^-kappa t cos (x - U t)  ","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"The solutions are","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"(Image: Cosine advection diffusion solutions)","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"which exhibit the expected second-order convergence with Delta x^2 propto 1  N_x^2:","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"(Image: Cosine advection diffusion convergence)","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"These results validate the correctness of time-stepping, constant diffusivity operators, and advection operators.","category":"page"},{"location":"validation/convergence_tests/#Two-dimensional-diffusion","page":"Convergence tests","title":"Two-dimensional diffusion","text":"","category":"section"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"With zero velocity field and constant diffusivity kappa, the tracer field","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    c(x y t=0) = cos(x) cos(y)  ","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"decays according to","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    c(x y t) = mathrme^-2 kappa t cos(x) cos(y)  ","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"with either periodic boundary conditions, or insulating boundary conditions in either x or y.","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"The expected convergence with Delta x^2 propto 1  N_x^2 is observed:","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"(Image: Two dimensional diffusion convergence)","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"This validates the correctness of multi-dimensional diffusion operators.","category":"page"},{"location":"validation/convergence_tests/#Decaying,-advected-Taylor-Green-vortex","page":"Convergence tests","title":"Decaying, advected Taylor-Green vortex","text":"","category":"section"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"The velocity field","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"beginalign\n    u(x y t)  = U + mathrme^-t cos(x - U t) sin(y)   \n    v(x y t)  =   - mathrme^-t sin(x - U t) cos(y)  \nendalign","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"is a solution to the Navier-Stokes equations with viscosity nu = 1.","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"The expected convergence with spatial resolution is observed:","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"(Image: Decaying advected Taylor Green)","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"This validates the correctness of the advection and diffusion of a velocity field.","category":"page"},{"location":"validation/convergence_tests/#Forced-two-dimensional-flows","page":"Convergence tests","title":"Forced two-dimensional flows","text":"","category":"section"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"We introduce two convergence tests associated with forced flows in domains that are  bounded in y, and periodic in x with no tracers.","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"Note: in this section, subscripts are used to denote derivatives to make reading  and typing equations easier.","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"In a two-dimensional flow in (x y), the velocity field (u v) can be expressed in terms of a streamfunction psi(x y t) such that","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    u equiv - psi_y   quad textand quad v equiv psi_x  ","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"where subscript denote derivatives such that psi_y equiv partial_y psi, for example. With an isotropic Laplacian viscosity nu = 1, the momentum and continuity equations are","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    beginalign\n    boldsymbolu_t + left ( boldsymbolu boldsymbolcdot boldsymbolnabla right ) boldsymbolu + boldsymbolnabla p  = nabla^2 boldsymbolu + boldsymbolF_u   \n    boldsymbolnabla boldsymbolcdot boldsymbolu  = 0  \n    endalign","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"while the equation for vorticity, omega = v_x - u_y = nabla^2 psi, is","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    omega_t + mathrmJ left ( psi omega right ) = nabla^2 omega + F_omega  ","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"Finally, taking the divergence of the momentum equation, we find a Poisson equation for pressure,","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    nabla^2 p = - u_x^2 - v_y^2 - 2 u_y v_x + partial_x F_u + partial_y F_v  ","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"To pose the problem, we first pick a streamfunction psi. This choice then yields the vorticity  forcing F_omega that satisfies the vorticity equation. We then determine F_u by solving  partial_y F_u = - F_omega, and pick F_v so that we can solve the Poisson equation  for pressure.","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"We restrict ourselves to a class of problems in which","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"psi(x y t) = - f(x t) g(y)   quad textwith quad f equiv cos x - xi(t)   quad\nxi(t) equiv 1 + sin(t^2)  ","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"Grinding through the algebra, this particular form implies that F_omega is given by","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    F_omega = -xi^prime f_x (g - g^primeprime) + f f_x (g g^primeprimeprime - g^prime g^primeprime) + f (g - 2 g^primeprime + g^primeprimeprimeprime)  ","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"where primes denote derivatives of functions of a single argument.  Setting partial_y F_u = F_omega, we find that if F_v satisfies","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    partial_y F_v = (g^prime)^2 + g g^primeprime  ","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"then the pressure Poisson equation becomes","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    nabla^2 p = cos 2 (x - xi) (g^prime)^2 - g g^primeprime + partial_x F_u  ","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"This completes the specification of the problem.","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"We set up the problem by imposing the time-dependent forcing functions F_u and F_v on u and v, initializing the flow at t=0, and integrating the problem forwards in time using Oceananigans. We find the expected convergence of the numerical solution to the analytical solution: the error between the numerical and analytical solutions decreases with 1N_x^2 sim Delta x^2, where N_x is the number of grid points and Delta x is the spatial resolution:","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"(Image: Forced free slip convergence)","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"The convergence tests are performed using both y and z as the bounded direction.","category":"page"},{"location":"validation/convergence_tests/#Forced,-free-slip-flow","page":"Convergence tests","title":"Forced, free-slip flow","text":"","category":"section"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"A forced flow satisfying free-slip conditions at y = 0 and y = pi has the streamfunction","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    psi(x y t) = - cos x - xi(t) sin (y)  ","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"and thus g(y) = sin y. The velocity field (u v) is","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    u = cos (x - xi) cos y   quad textand quad v = sin (x - xi) sin y  ","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"which satisfies the boundary conditions u_y _y=0 = u_y _y=pi = 0 and v _y=0 = v _y=pi = 0. The vorticity forcing is","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    F_omega = - 2 xi^prime f_x sin y + 4 f sin y  ","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"which implies that","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    F_u = - 2 xi^prime f_x cos y + 4 f cos y  ","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"and F_v = tfrac12 sin 2 y.","category":"page"},{"location":"validation/convergence_tests/#Forced,-fixed-slip-flow","page":"Convergence tests","title":"Forced, fixed-slip flow","text":"","category":"section"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"A forced flow satisfying \"fixed-slip\" boundary conditions at y=0 and y=1 has the streamfunction","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    psi(x y t) = - cos x - xi(t) (y^3 - y^2)  ","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"and thus g(y) = y^3 - y^2. The velocity field (u v) is","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    u = f (3y^2 - 2 y)   quad textand quad v = - f_x (y^3 - y^2)  ","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"which satisfies the boundary conditions","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    u _y=0 = 0   quad u _y=1 = f   quad textand quad v _y=0 = v _y=1 = 0  ","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"The vorticity forcing is","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    F_omega = - xi^prime f_x (y^3 - y^2 - 6y + 2) - f f_x (12 y^3 - 12 y^2 + 4 y) + f (y^3 - y^2 - 12 y + 4)  ","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"which implies that","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    F_u = xi^prime f_x (tfrac14 y^4 - tfrac13 y^3 - 3 y^2 + 2y)\n        + f f_x (3 y^4 - 4 y^3 + 2y^2 ) \n        - f (tfrac14 y^4 - tfrac13 y^3 - 6 y^2 + 4 y)  ","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"and","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    F_v = 3 y^5 - 5 y^4 + 2y^3  ","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"We set up the problem in the same manner as the forced, free-slip problem above. Note that we  also must the no-slip boundary condition u _y=0 = 0 and the time-dependent fixed-slip  condition u _y=1 = f. As for the free-slip problem, we find that the error between the  numerical and analytical solutions decreases with 1  N_x^2 sim Delta x^2, where N_x is the number of grid points and Delta x is the spatial resolution:","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"(Image: Forced fixed slip convergence)","category":"page"},{"location":"validation/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"The convergence tests are performed using both y and z as the bounded direction.","category":"page"},{"location":"model_setup/lagrangian_particles/#Lagrangian-particle-tracking","page":"Lagrangian particles","title":"Lagrangian particle tracking","text":"","category":"section"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"Models can keep track of the location and properties of neutrally buoyant particles. Particles are advected with the flow field using forward Euler time-stepping at every model iteration.","category":"page"},{"location":"model_setup/lagrangian_particles/#Simple-particles","page":"Lagrangian particles","title":"Simple particles","text":"","category":"section"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"If you just need to keep of particle locations (x y z) then you can construct some Lagrangian particles using the regular LagrangianParticles constructor","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"DocTestSetup = quote\n    using Oceananigans\nend","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"grid = RegularRectilinearGrid(size=(10, 10, 10), extent=(1, 1, 1));\n\nn_particles = 10;\n\nx₀ = zeros(n_particles);\n\ny₀ = rand(n_particles);\n\nz₀ = -0.5 * ones(n_particles);\n\nlagrangian_particles = LagrangianParticles(x=x₀, y=y₀, z=z₀)\n\n# output\n10 Lagrangian particles with\n├── 3 properties: (:x, :y, :z)\n└── 0 tracked fields: ()","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"then pass it to a model constructor","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"model = IncompressibleModel(grid=grid, particles=lagrangian_particles)\n\n# output\nIncompressibleModel{CPU, Float64}(time = 0 seconds, iteration = 0)\n├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=10, Ny=10, Nz=10)\n├── tracers: (:T, :S)\n├── closure: Nothing\n├── buoyancy: SeawaterBuoyancy{Float64,LinearEquationOfState{Float64},Nothing,Nothing}\n├── coriolis: Nothing\n└── particles: 10 Lagrangian particles with 3 properties: (:x, :y, :z)","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"warn: Lagrangian particles on GPUs\nRemember to use CuArray instead of regular Array when storing particle locations and properties on the GPU.","category":"page"},{"location":"model_setup/lagrangian_particles/#Custom-particles","page":"Lagrangian particles","title":"Custom particles","text":"","category":"section"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"If you want to keep track of custom properties, such as the species or DNA of a Lagrangian particle representing a microbe in an agent-based model, then you can create your own custom particle type and pass a StructArray to the LagrangianParticles constructor.","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"using Oceananigans\nusing StructArrays\n\nstruct LagrangianMicrobe{T, S, D}\n    x :: T\n    y :: T\n    z :: T\n    species :: S\n    dna :: D\nend\n\nn_particles = 3;\n\nx₀ = zeros(n_particles);\n\ny₀ = rand(n_particles);\n\nz₀ = -0.5 * ones(n_particles);\n\nspecies = [:rock, :paper, :scissors]\n\ndna = [\"TATACCCC\", \"CCTAGGAC\", \"CGATTTAA\"]\n\nparticles = StructArray{LagrangianMicrobe}((x₀, y₀, z₀, species, dna));\n\nlagrangian_particles = LagrangianParticles(particles)\n\n# output\n3 Lagrangian particles with\n├── 5 properties: (:x, :y, :z, :species, :dna)\n└── 0 tracked fields: ()","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"warn: Custom properties on GPUs\nNot all data types can be passed to GPU kernels. If you intend to advect particles on the GPU make sure particle properties consist of only simple data types. The symbols and strings in this example won't work on the GPU.","category":"page"},{"location":"model_setup/lagrangian_particles/#Writing-particle-properties-to-disk","page":"Lagrangian particles","title":"Writing particle properties to disk","text":"","category":"section"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"Particle properties can be written to disk using JLD2 or NetCDF.","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"When writing to JLD2 you can pass model.particles as part of the named tuple of outputs.","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"JLD2OutputWriter(model, (particles=model.particles,), prefix=\"particles\", schedule=TimeInterval(15))","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"When writing to NetCDF you should write particles to a separate file as the NetCDF dimensions differ for particle trajectories. You can just pass model.particles straight to NetCDFOutputWriter:","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"NetCDFOutputWriter(model, model.particles, filepath=\"particles.nc\", schedule=TimeInterval(15))","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"warn: Outputting custom particle properties to NetCDF\nNetCDF does not support arbitrary data types. If you need to write custom particle properties to disk that are not supported by NetCDF then you should use JLD2 (which should support almost any Julia data type).","category":"page"},{"location":"model_setup/diagnostics/#Diagnostics","page":"Diagnostics","title":"Diagnostics","text":"","category":"section"},{"location":"model_setup/diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"Diagnostics are a set of general utilities that can be called on-demand during time-stepping to compute quantities of interest you may want to save to disk, such as the horizontal average of the temperature, the maximum velocity, or to produce a time series of salinity. They also include utilities for diagnosing model health, such as the CFL number or to check for NaNs.","category":"page"},{"location":"model_setup/diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"Diagnostics are stored as a list of diagnostics in simulation.diagnostics. Diagnostics can be specified at model creation time or be specified at any later time and appended (or assigned with a key value pair) to simulation.diagnostics.","category":"page"},{"location":"model_setup/diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"Most diagnostics can be run at specified frequencies (e.g. every 25 time steps) or specified intervals (e.g. every 15 minutes of simulation time). If you'd like to run a diagnostic on demand then do not specify any intervals (and do not add it to simulation.diagnostics).","category":"page"},{"location":"model_setup/number_type/#Number-type","page":"Number type","title":"Number type","text":"","category":"section"},{"location":"model_setup/number_type/","page":"Number type","title":"Number type","text":"Passing float_type=Float64 or float_type=Float32 to the Model constructor causes the model to store all numbers with 64-bit or 32-bit floating point precision.","category":"page"},{"location":"model_setup/number_type/","page":"Number type","title":"Number type","text":"note: Avoiding mixed-precision operations\nWhen not using Float64 be careful to not mix different precisions as it could introduce implicit type conversions which can negatively effect performance. You can pass the number type desires to many constructors to enforce the type you want: e.g. RegularRectilinearGrid(Float32; size=(16, 16, 16), extent=(1, 1, 1)) and IsotropicDiffusivity(Float16; κ=1//7, ν=2//7).","category":"page"},{"location":"model_setup/number_type/","page":"Number type","title":"Number type","text":"warning: Effect of floating point precision on simulation accuracy\nWhile we run many tests with both Float32 and Float64 it is not clear whether Float32 is precise enough to provide similar accuracy in all use cases. If accuracy is a concern, stick to Float64.We will be actively investigating the possibility of using lower precision floating point numbers such as Float32 and Float16 for fluid dynamics as well as the use of alternative number types such as Posits and Sonums.","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"EditURL = \"<unknown>/examples/eady_turbulence.jl\"","category":"page"},{"location":"generated/eady_turbulence/#Eady-turbulence-example","page":"Eady turbulence","title":"Eady turbulence example","text":"","category":"section"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"In this example, we initialize a random velocity field and observe its viscous, turbulent decay in a two-dimensional domain. This example demonstrates:","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"How to use a tuple of turbulence closures\nHow to use hyperdiffusivity\nHow to implement background velocity and tracer distributions\nHow to use ComputedFields for output","category":"page"},{"location":"generated/eady_turbulence/#Install-dependencies","page":"Eady turbulence","title":"Install dependencies","text":"","category":"section"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"using Pkg\npkg\"add Oceananigans, JLD2, Plots\"","category":"page"},{"location":"generated/eady_turbulence/#The-Eady-problem","page":"Eady turbulence","title":"The Eady problem","text":"","category":"section"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"The \"Eady problem\" simulates the baroclinic instability problem proposed by Eric Eady in the classic paper \"Long waves and cyclone waves,\" Tellus (1949). The Eady problem is a simple, canonical model for the generation of mid-latitude atmospheric storms and the ocean eddies that permeate the world sea.","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"In the Eady problem, baroclinic motion and turublence is generated by the interaction between turbulent motions and a stationary, geostrophically-balanced basic state that is unstable to baroclinic instability. In this example, the baroclinic generation of turbulence due to extraction of energy from the geostrophic basic state is balanced by a bottom boundary condition that extracts momentum from turbulent motions and serves as a crude model for the drag associated with an unresolved and small-scale turbulent bottom boundary layer.","category":"page"},{"location":"generated/eady_turbulence/#The-geostrophic-basic-state","page":"Eady turbulence","title":"The geostrophic basic state","text":"","category":"section"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"The geostrophic basic state in the Eady problem is represented by the streamfunction,","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"ψ(y z) = - α y (z + L_z)  ","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"where α is the geostrophic shear and L_z is the depth of the domain. The background buoyancy includes both the geostrophic flow component, f _z ψ, where f is the Coriolis parameter, and a background stable stratification component, N^2 z, where N is the buoyancy frequency:","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"B(y z) = f _z ψ + N^2 z = - α f y + N^2 z  ","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"The background velocity field is related to the geostrophic streamfunction via U = - _y ψ such that","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"U(z) = α (z + L_z)  ","category":"page"},{"location":"generated/eady_turbulence/#Boundary-conditions","page":"Eady turbulence","title":"Boundary conditions","text":"","category":"section"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"All fields are periodic in the horizontal directions. We use \"insulating\", or zero-flux boundary conditions on the buoyancy perturbation at the top and bottom. We thus implicitly assume that the background vertical density gradient, N^2 z, is maintained by a process external to our simulation. We use free-slip, or zero-flux boundary conditions on u and v at the surface where z=0. At the bottom, we impose a momentum flux that extracts momentum and energy from the flow.","category":"page"},{"location":"generated/eady_turbulence/#Bottom-boundary-condition:-quadratic-bottom-drag","page":"Eady turbulence","title":"Bottom boundary condition: quadratic bottom drag","text":"","category":"section"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"We model the effects of a turbulent bottom boundary layer on the eddy momentum budget with quadratic bottom drag. A quadratic cottom drag is introduced by imposing a vertical flux of horizontal momentum that removes momentum from the layer immediately above: in other words, the flux is negative (downwards) when the velocity at the bottom boundary is positive, and positive (upwards) with the velocity at the bottom boundary is negative. This drag term is \"quadratic\" because the rate at which momentum is removed is proportional to boldsymbolu_h boldsymbolu_h, where boldsymbolu_h = u boldsymbolhatx + v boldsymbolhaty is the horizontal velocity.","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"The x-component of the quadratic bottom drag is thus","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"tau_xz(z=L_z) = - c^D u sqrtu^2 + v^2  ","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"while the y-component is","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"tau_yz(z=L_z) = - c^D v sqrtu^2 + v^2  ","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"where c^D is a dimensionless drag coefficient and tau_xz(z=L_z) and tau_yz(z=L_z) denote the flux of u and v momentum at z = L_z, the bottom of the domain.","category":"page"},{"location":"generated/eady_turbulence/#Vertical-and-horizontal-viscosity-and-diffusivity","page":"Eady turbulence","title":"Vertical and horizontal viscosity and diffusivity","text":"","category":"section"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"Vertical and horizontal viscosities and diffusivities are required to stabilize the Eady problem and can be idealized as modeling the effect of turbulent mixing below the grid scale. For both tracers and velocities we use a Laplacian vertical diffusivity κ_z _z^2 c and a horizontal hyperdiffusivity ϰ_h (_x^4 + _y^4) c.","category":"page"},{"location":"generated/eady_turbulence/#Eady-problem-summary-and-parameters","page":"Eady turbulence","title":"Eady problem summary and parameters","text":"","category":"section"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"To summarize, the Eady problem parameters along with the values we use in this example are","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"Parameter name Description Value Units\nf Coriolis parameter 10^-4 mathrms^-1\nN Buoyancy frequency (square root of partial_z B) 10^-3 mathrms^-1\nalpha Background vertical shear partial_z U 10^-3 mathrms^-1\nc^D Bottom quadratic drag coefficient 10^-4 none\nκ_z Laplacian vertical diffusivity 10^-2 mathrmm^2 s^-1\nϰ_h Biharmonic horizontal diffusivity 10^-2 times Delta x^4  mathrmday mathrmm^4 s^-1","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"We start off by importing Oceananigans, Printf, and some convenient constants for specifying dimensional units:","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"using Printf\nusing Oceananigans\nusing Oceananigans.Units: hours, day, days","category":"page"},{"location":"generated/eady_turbulence/#The-grid","page":"Eady turbulence","title":"The grid","text":"","category":"section"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"We use a three-dimensional grid with a depth of 4000 m and a horizontal extent of 1000 km, appropriate for mesoscale ocean dynamics with characteristic scales of 50-200 km.","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"grid = RegularRectilinearGrid(size=(48, 48, 16), x=(0, 1e6), y=(0, 1e6), z=(-4e3, 0))","category":"page"},{"location":"generated/eady_turbulence/#Rotation","page":"Eady turbulence","title":"Rotation","text":"","category":"section"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"The classical Eady problem is posed on an f-plane. We use a Coriolis parameter typical to mid-latitudes on Earth,","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"coriolis = FPlane(f=1e-4) # [s⁻¹]","category":"page"},{"location":"generated/eady_turbulence/#The-background-flow","page":"Eady turbulence","title":"The background flow","text":"","category":"section"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"We build a NamedTuple of parameters that describe the background flow,","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"basic_state_parameters = ( α = 10 * coriolis.f, # s⁻¹, geostrophic shear\n                           f = coriolis.f,      # s⁻¹, Coriolis parameter\n                           N = 1e-3,            # s⁻¹, buoyancy frequency\n                          Lz = grid.Lz)         # m, ocean depth","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"and then construct the background fields U and B","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"# Background fields are defined via functions of x, y, z, t, and optional parameters\nU(x, y, z, t, p) = + p.α * (z + p.Lz)\nB(x, y, z, t, p) = - p.α * p.f * y + p.N^2 * z\n\nU_field = BackgroundField(U, parameters=basic_state_parameters)\nB_field = BackgroundField(B, parameters=basic_state_parameters)","category":"page"},{"location":"generated/eady_turbulence/#Boundary-conditions-2","page":"Eady turbulence","title":"Boundary conditions","text":"","category":"section"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"The boundary conditions prescribe a quadratic drag at the bottom as a flux condition.","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"cᴰ = 1e-4 # quadratic drag coefficient\n\n@inline drag_u(x, y, t, u, v, cᴰ) = - cᴰ * u * sqrt(u^2 + v^2)\n@inline drag_v(x, y, t, u, v, cᴰ) = - cᴰ * v * sqrt(u^2 + v^2)\n\ndrag_bc_u = FluxBoundaryCondition(drag_u, field_dependencies=(:u, :v), parameters=cᴰ)\ndrag_bc_v = FluxBoundaryCondition(drag_v, field_dependencies=(:u, :v), parameters=cᴰ)\n\nu_bcs = UVelocityBoundaryConditions(grid, bottom = drag_bc_u)\nv_bcs = VVelocityBoundaryConditions(grid, bottom = drag_bc_v)","category":"page"},{"location":"generated/eady_turbulence/#Turbulence-closures","page":"Eady turbulence","title":"Turbulence closures","text":"","category":"section"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"We use a horizontal hyperdiffusivity and a Laplacian vertical diffusivity to dissipate energy in the Eady problem. To use both of these closures at the same time, we set the keyword argument closure to a tuple of two closures.","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"κ₂z = 1e-2 # [m² s⁻¹] Laplacian vertical viscosity and diffusivity\nκ₄h = 1e-1 / day * grid.Δx^4 # [m⁴ s⁻¹] horizontal hyperviscosity and hyperdiffusivity\n\nLaplacian_vertical_diffusivity = AnisotropicDiffusivity(νh=0, κh=0, νz=κ₂z, κz=κ₂z)\nbiharmonic_horizontal_diffusivity = AnisotropicBiharmonicDiffusivity(νh=κ₄h, κh=κ₄h)","category":"page"},{"location":"generated/eady_turbulence/#Model-instantiation","page":"Eady turbulence","title":"Model instantiation","text":"","category":"section"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"We instantiate the model with the fifth-order WENO advection scheme, a 3rd order Runge-Kutta time-stepping scheme, and a BuoyancyTracer.","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"model = IncompressibleModel(\n           architecture = CPU(),\n                   grid = grid,\n              advection = WENO5(),\n            timestepper = :RungeKutta3,\n               coriolis = coriolis,\n                tracers = :b,\n               buoyancy = BuoyancyTracer(),\n      background_fields = (b=B_field, u=U_field),\n                closure = (Laplacian_vertical_diffusivity, biharmonic_horizontal_diffusivity),\n    boundary_conditions = (u=u_bcs, v=v_bcs)\n)","category":"page"},{"location":"generated/eady_turbulence/#Initial-conditions","page":"Eady turbulence","title":"Initial conditions","text":"","category":"section"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"We seed our initial conditions with random noise stimulate the growth of baroclinic instability.","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"# A noise function, damped at the top and bottom\nΞ(z) = randn() * z/grid.Lz * (z/grid.Lz + 1)\n\n# Scales for the initial velocity and buoyancy\nŨ = 1e-1 * basic_state_parameters.α * grid.Lz\nB̃ = 1e-2 * basic_state_parameters.α * coriolis.f\n\nuᵢ(x, y, z) = Ũ * Ξ(z)\nvᵢ(x, y, z) = Ũ * Ξ(z)\nbᵢ(x, y, z) = B̃ * Ξ(z)\n\nset!(model, u=uᵢ, v=vᵢ, b=bᵢ)","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"We subtract off any residual mean velocity to avoid exciting domain-scale inertial oscillations. We use a sum over the entire parent arrays or data to ensure this operation is efficient on the GPU (set architecture = GPU() in IncompressibleModel constructor to run this problem on the GPU if one is available).","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"ū = sum(model.velocities.u.data.parent) / (grid.Nx * grid.Ny * grid.Nz)\nv̄ = sum(model.velocities.v.data.parent) / (grid.Nx * grid.Ny * grid.Nz)\n\nmodel.velocities.u.data.parent .-= ū\nmodel.velocities.v.data.parent .-= v̄\nnothing # hide","category":"page"},{"location":"generated/eady_turbulence/#Simulation-set-up","page":"Eady turbulence","title":"Simulation set-up","text":"","category":"section"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"We set up a simulation that runs for 10 days with a JLD2OutputWriter that saves the vertical vorticity and divergence every 2 hours.","category":"page"},{"location":"generated/eady_turbulence/#The-TimeStepWizard","page":"Eady turbulence","title":"The TimeStepWizard","text":"","category":"section"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"The TimeStepWizard manages the time-step adaptively, keeping the Courant-Freidrichs-Lewy (CFL) number close to 1.0 while ensuring the time-step does not increase beyond the maximum allowable value for numerical stability given the specified background flow, Coriolis time scales, and diffusion time scales.","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"# Calculate absolute limit on time-step using diffusivities and\n# background velocity.\nŪ = basic_state_parameters.α * grid.Lz\n\nmax_Δt = min(grid.Δx / Ū, grid.Δx^4 / κ₄h, grid.Δz^2 / κ₂z, 1/basic_state_parameters.N)\n\nwizard = TimeStepWizard(cfl=0.85, Δt=max_Δt, max_change=1.1, max_Δt=max_Δt)","category":"page"},{"location":"generated/eady_turbulence/#A-progress-messenger","page":"Eady turbulence","title":"A progress messenger","text":"","category":"section"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"We write a function that prints out a helpful progress message while the simulation runs.","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"CFL = AdvectiveCFL(wizard)\n\nstart_time = time_ns()\n\nprogress(sim) = @printf(\"i: % 6d, sim time: % 10s, wall time: % 10s, Δt: % 10s, CFL: %.2e\\n\",\n                        sim.model.clock.iteration,\n                        prettytime(sim.model.clock.time),\n                        prettytime(1e-9 * (time_ns() - start_time)),\n                        prettytime(sim.Δt.Δt),\n                        CFL(sim.model))\nnothing # hide","category":"page"},{"location":"generated/eady_turbulence/#Build-the-simulation","page":"Eady turbulence","title":"Build the simulation","text":"","category":"section"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"We're ready to build and run the simulation. We ask for a progress message and time-step update every 20 iterations,","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"simulation = Simulation(model, Δt = wizard, iteration_interval = 20,\n                                                     stop_time = 8days,\n                                                      progress = progress)","category":"page"},{"location":"generated/eady_turbulence/#Output","page":"Eady turbulence","title":"Output","text":"","category":"section"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"To visualize the baroclinic turbulence ensuing in the Eady problem, we use ComputedFields to diagnose and output vertical vorticity and divergence. Note that ComputedFields take \"AbstractOperations\" on Fields as input:","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"u, v, w = model.velocities # unpack velocity `Field`s\n\n# Vertical vorticity [s⁻¹]\nζ = ComputedField(∂x(v) - ∂y(u))\n\n# Horizontal divergence, or ∂x(u) + ∂y(v) [s⁻¹]\nδ = ComputedField(-∂z(w))","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"With the vertical vorticity, ζ, and the horizontal divergence, δ in hand, we create a JLD2OutputWriter that saves ζ and δ and add them to simulation.","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"simulation.output_writers[:fields] = JLD2OutputWriter(model, (ζ=ζ, δ=δ),\n                                                      schedule = TimeInterval(4hours),\n                                                        prefix = \"eady_turbulence\",\n                                                         force = true)\nnothing # hide","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"All that's left is to press the big red button:","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"run!(simulation)","category":"page"},{"location":"generated/eady_turbulence/#Visualizing-Eady-turbulence","page":"Eady turbulence","title":"Visualizing Eady turbulence","text":"","category":"section"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"We animate the results by opening the JLD2 file, extracting data for the iterations we ended up saving at, and ploting slices of the saved fields. We prepare for animating the flow by creating coordinate arrays, opening the file, building a vector of the iterations that we saved data at, and defining a function for computing colorbar limits:","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"using JLD2, Plots\n\n# Coordinate arrays\nxζ, yζ, zζ = nodes(ζ)\nxδ, yδ, zδ = nodes(δ)\n\n# Open the file with our data\nfile = jldopen(simulation.output_writers[:fields].filepath)\n\n# Extract a vector of iterations\niterations = parse.(Int, keys(file[\"timeseries/t\"]))","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"This utility is handy for calculating nice contour intervals:","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"function nice_divergent_levels(c, clim, nlevels=31)\n    levels = range(-clim, stop=clim, length=nlevels)\n    cmax = maximum(abs, c)\n    clim < cmax && (levels = vcat([-cmax], levels, [cmax]))\n    return levels\nend\nnothing # hide","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"Now we're ready to animate.","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"@info \"Making an animation from saved data...\"\n\nanim = @animate for (i, iter) in enumerate(iterations)\n\n    # Load 3D fields from file\n    t = file[\"timeseries/t/$iter\"]\n    R_snapshot = file[\"timeseries/ζ/$iter\"] ./ coriolis.f\n    δ_snapshot = file[\"timeseries/δ/$iter\"]\n\n    surface_R = R_snapshot[:, :, grid.Nz]\n    surface_δ = δ_snapshot[:, :, grid.Nz]\n\n    slice_R = R_snapshot[:, 1, :]\n    slice_δ = δ_snapshot[:, 1, :]\n\n    Rlim = 0.5 * maximum(abs, R_snapshot) + 1e-9\n    δlim = 0.5 * maximum(abs, δ_snapshot) + 1e-9\n\n    Rlevels = nice_divergent_levels(R_snapshot, Rlim)\n    δlevels = nice_divergent_levels(δ_snapshot, δlim)\n\n    @info @sprintf(\"Drawing frame %d from iteration %d: max(ζ̃ / f) = %.3f \\n\",\n                   i, iter, maximum(abs, surface_R))\n\n    xy_kwargs = (xlims = (0, grid.Lx), ylims = (0, grid.Lx),\n                 xlabel = \"x (m)\", ylabel = \"y (m)\",\n                 aspectratio = 1,\n                 linewidth = 0, color = :balance, legend = false)\n\n    xz_kwargs = (xlims = (0, grid.Lx), ylims = (-grid.Lz, 0),\n                 xlabel = \"x (m)\", ylabel = \"z (m)\",\n                 aspectratio = grid.Lx / grid.Lz * 0.5,\n                 linewidth = 0, color = :balance, legend = false)\n\n    R_xy = contourf(xζ, yζ, surface_R'; clims=(-Rlim, Rlim), levels=Rlevels, xy_kwargs...)\n    δ_xy = contourf(xδ, yδ, surface_δ'; clims=(-δlim, δlim), levels=δlevels, xy_kwargs...)\n    R_xz = contourf(xζ, zζ, slice_R'; clims=(-Rlim, Rlim), levels=Rlevels, xz_kwargs...)\n    δ_xz = contourf(xδ, zδ, slice_δ'; clims=(-δlim, δlim), levels=δlevels, xz_kwargs...)\n\n    plot(R_xy, δ_xy, R_xz, δ_xz,\n           size = (1000, 800),\n           link = :x,\n         layout = Plots.grid(2, 2, heights=[0.5, 0.5, 0.2, 0.2]),\n          title = [@sprintf(\"ζ(t=%s) / f\", prettytime(t)) @sprintf(\"δ(t=%s) (s⁻¹)\", prettytime(t)) \"\" \"\"])\n\n    iter == iterations[end] && close(file)\nend\n\nmp4(anim, \"eady_turbulence.mp4\", fps = 8) # hide","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"","category":"page"},{"location":"generated/eady_turbulence/","page":"Eady turbulence","title":"Eady turbulence","text":"This page was generated using Literate.jl.","category":"page"},{"location":"model_setup/overview/#Model-setup","page":"Overview","title":"Model setup","text":"","category":"section"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"This section describes all the options and features that can be used to set up a model. For more detailed information consult the API documentation.","category":"page"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"Each structure covered in this section can be constructed and passed to the IncompressibleModel constructor. For examples of model construction, see the examples. The validation experiments provide more advanced examples.","category":"page"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"For reference, here are all the option or keyword arguments that can be passed to IncompressibleModel. See the different sections on the sidebar for more details and examples for each keyword argument.","category":"page"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"IncompressibleModel","category":"page"},{"location":"model_setup/overview/#Oceananigans.Models.IncompressibleModels.IncompressibleModel","page":"Overview","title":"Oceananigans.Models.IncompressibleModels.IncompressibleModel","text":"IncompressibleModel(;\n               grid,\n       architecture = CPU(),\n         float_type = Float64,\n              clock = Clock{float_type}(0, 0, 1),\n          advection = CenteredSecondOrder(),\n           buoyancy = Buoyancy(SeawaterBuoyancy(float_type)),\n           coriolis = nothing,\n       stokes_drift = nothing,\n            forcing = NamedTuple(),\n            closure = nothing,\nboundary_conditions = NamedTuple(),\n            tracers = (:T, :S),\n        timestepper = :QuasiAdamsBashforth2,\n  background_fields = NamedTuple(),\n          particles = nothing,\n         velocities = nothing,\n          pressures = nothing,\n      diffusivities = nothing,\n    pressure_solver = nothing,\n  immersed_boundary = nothing\n)\n\nConstruct an incompressible Oceananigans.jl model on grid.\n\nKeyword arguments\n\n- `grid`: (required) The resolution and discrete geometry on which `model` is solved.\n- `architecture`: `CPU()` or `GPU()`. The computer architecture used to time-step `model`.\n- `float_type`: `Float32` or `Float64`. The floating point type used for `model` data.\n- `advection`: The scheme that advects velocities and tracers. See `Oceananigans.Advection`.\n- `buoyancy`: The buoyancy model. See `Oceananigans.BuoyancyModels`.\n- `closure`: The turbulence closure for `model`. See `Oceananigans.TurbulenceClosures`.\n- `coriolis`: Parameters for the background rotation rate of the model.\n- `forcing`: `NamedTuple` of user-defined forcing functions that contribute to solution tendencies.\n- `boundary_conditions`: `NamedTuple` containing field boundary conditions.\n- `tracers`: A tuple of symbols defining the names of the modeled tracers, or a `NamedTuple` of\n             preallocated `CenterField`s.\n- `timestepper`: A symbol that specifies the time-stepping method. Either `:QuasiAdamsBashforth2` or\n                 `:RungeKutta3`.\n\n\n\n\n\n","category":"type"},{"location":"physics/buoyancy_and_equations_of_state/#Buoyancy-model-and-equations-of-state","page":"Buoyancy models and equations of state","title":"Buoyancy model and equations of state","text":"","category":"section"},{"location":"physics/buoyancy_and_equations_of_state/","page":"Buoyancy models and equations of state","title":"Buoyancy models and equations of state","text":"The buoyancy model determines the relationship between tracers and the buoyancy b in the momentum equation.","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/#Buoyancy-tracer","page":"Buoyancy models and equations of state","title":"Buoyancy tracer","text":"","category":"section"},{"location":"physics/buoyancy_and_equations_of_state/","page":"Buoyancy models and equations of state","title":"Buoyancy models and equations of state","text":"The simplest buoyancy model uses buoyancy b itself as a tracer: b obeys the tracer conservation equation and is used directly in the momentum equations in the momentum equation.","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/#Seawater-buoyancy","page":"Buoyancy models and equations of state","title":"Seawater buoyancy","text":"","category":"section"},{"location":"physics/buoyancy_and_equations_of_state/","page":"Buoyancy models and equations of state","title":"Buoyancy models and equations of state","text":"For seawater buoyancy is, in general, modeled as a function of conservative temperature theta, absolute salinity S, and depth below the ocean surface d via","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/","page":"Buoyancy models and equations of state","title":"Buoyancy models and equations of state","text":"    beginequation\n    b = - fracgrho_0 rho left (theta S d right )  \n    labeleqseawater-buoyancy\n    endequation","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/","page":"Buoyancy models and equations of state","title":"Buoyancy models and equations of state","text":"where g is gravitational acceleration, rho_0 is the reference density. The function rho(theta S d) in the seawater buoyancy relationship that links conservative temperature, salinity, and depth to the density perturbation is called the equation of state. Both theta and S obey the tracer conservation equation.","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/#Linear-equation-of-state","page":"Buoyancy models and equations of state","title":"Linear equation of state","text":"","category":"section"},{"location":"physics/buoyancy_and_equations_of_state/","page":"Buoyancy models and equations of state","title":"Buoyancy models and equations of state","text":"Buoyancy is determined from a linear equation of state via","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/","page":"Buoyancy models and equations of state","title":"Buoyancy models and equations of state","text":"    b = g left ( alpha_theta theta - beta_S S right )  ","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/","page":"Buoyancy models and equations of state","title":"Buoyancy models and equations of state","text":"where g is gravitational acceleration, alpha_theta is the thermal expansion coefficient, and beta_S is the haline contraction coefficient.","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/#Nonlinear-equation-of-state","page":"Buoyancy models and equations of state","title":"Nonlinear equation of state","text":"","category":"section"},{"location":"physics/buoyancy_and_equations_of_state/","page":"Buoyancy models and equations of state","title":"Buoyancy models and equations of state","text":"Buoyancy is determined by the simplified equations of state introduced by F. Roquet , G. Madec , Trevor J. McDougall , Paul M. Barker  (2015).","category":"page"},{"location":"model_setup/boundary_conditions/#model_step_bcs","page":"Boundary conditions","title":"Boundary conditions","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"A boundary condition is applied to each field, dimension, and endpoint. There are left and right boundary conditions for each of the x, y, and z dimensions so each field has 6 boundary conditions. Each of these boundary conditions may be specified individually. Each boundary condition can be specified via a constant value, an array, or a function.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"The left and right boundary conditions associated with the x-dimension are called west and east, respectively. For the y-dimension, left and right are called south and north. For the z-dimension, left and right are called bottom and top.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"See Numerical implementation of boundary conditions for more details.","category":"page"},{"location":"model_setup/boundary_conditions/#Types-of-boundary-conditions","page":"Boundary conditions","title":"Types of boundary conditions","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Periodic\nFlux\nValue (Dirchlet)\nGradient (Neumann)\nNormalFlow","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"To construct a Flux boundary condition use the FluxBoundaryCondition constructor and so on.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Notice that open boundary conditions and radiation boundary conditions can be imposed via flux or value boundary conditions defined by a function or array. Or alternatively, through a forcing function if more flexibility is desired.","category":"page"},{"location":"model_setup/boundary_conditions/#Default-boundary-conditions","page":"Boundary conditions","title":"Default boundary conditions","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"By default, periodic boundary conditions are applied on all fields along periodic dimensions. Otherwise tracers get no-flux boundary conditions and velocities get free-slip and no normal flow boundary conditions.","category":"page"},{"location":"model_setup/boundary_conditions/#Boundary-condition-structures","page":"Boundary conditions","title":"Boundary condition structures","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Oceananigans uses a hierarchical structure to express boundary conditions.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"A BoundaryCondition is associated with every field, dimension, and endpoint.\nBoundary conditions specifying the condition at the left and right endpoints are grouped into CoordinateBoundaryConditions.\nA set of three CoordinateBoundaryConditions specifying the boundary conditions along the x-, y-, and z-dimensions. for a single field are grouped into a FieldBoundaryConditions NamedTuple.\nA set of FieldBoundaryConditions, up to one for each field, are grouped into a NamedTuple and passed to the model constructor.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Boundary conditions are defined at model construction time by passing a NamedTuple of FieldBoundaryConditions specifying non-default boundary conditions for fields such as velocities (u, v, w) and tracers. Fields for which boundary conditions are not specified are assigned a default boundary conditions. Note that default boundary conditions depend on the grid topology.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"A few illustrations are provided below. See the validation experiments and examples for further illustrations of boundary condition specification.","category":"page"},{"location":"model_setup/boundary_conditions/#Creating-individual-boundary-conditions-with-BoundaryCondition","page":"Boundary conditions","title":"Creating individual boundary conditions with BoundaryCondition","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"DocTestSetup = quote\n   using Oceananigans\n   using Oceananigans.BoundaryConditions\n\n   using Random\n   Random.seed!(1234)\nend","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Boundary conditions may be specified with constants, functions, or arrays. In this section we illustrate usage of the different BoundaryCondition constructors.","category":"page"},{"location":"model_setup/boundary_conditions/#.-Constant-Value-(Dirchlet)-boundary-condition","page":"Boundary conditions","title":"1. Constant Value (Dirchlet) boundary condition","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> constant_T_bc = ValueBoundaryCondition(20.0)\nBoundaryCondition: type=Value, condition=20.0","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"A constant Value boundary condition can be used to specify constant tracer (such as temperature), or a constant tangential velocity component at a boundary. Note that boundary conditions on the normal velocity component must use the NormalFlow boundary condition type.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Finally, note that ValueBoundaryCondition(condition) is an alias for BoundaryCondition(Value, condition).","category":"page"},{"location":"model_setup/boundary_conditions/#.-Constant-Flux-boundary-condition","page":"Boundary conditions","title":"2. Constant Flux boundary condition","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> ρ₀ = 1027;  # Reference density [kg/m³]\n\njulia> τₓ = 0.08;  # Wind stress [N/m²]\n\njulia> wind_stress_bc = FluxBoundaryCondition(-τₓ/ρ₀)\nBoundaryCondition: type=Flux, condition=-7.789678675754625e-5","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"A constant Flux boundary condition can be imposed on tracers and tangential velocity components can can be used, for example, to specify cooling, heating, evaporation, or wind stress at the ocean surface.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"info: The flux convention in Oceananigans\nOceananigans uses the convention that positive fluxes produce transport in the positive direction (east, north, and up for x, y, z). This means, for example, that a negative flux of momentum or velocity at a top boundary, such as in the above example, produces currents in the positive direction, because it prescribes a downwards flux of momentum into the domain from the top. Likewise, a positive temperature flux at the top boundary causes cooling, because it transports heat upwards, out of the domain. Conversely, a positive flux at a bottom boundary acts to increase the interior values of a quantity.","category":"page"},{"location":"model_setup/boundary_conditions/#.-Spatially-and-temporally-varying-flux","page":"Boundary conditions","title":"3. Spatially- and temporally-varying flux","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Boundary conditions may be specified by functions,","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> @inline surface_flux(x, y, t) = cos(2π * x) * cos(t);\n\njulia> top_tracer_bc = FluxBoundaryCondition(surface_flux)\nBoundaryCondition: type=Flux, condition=surface_flux(x, y, t) in Main at none:1","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"info: Boundary condition functions\nBy default, a function boundary condition is called with the signaturef(ξ, η, t)where t is time and ξ, η are spatial coordinates that vary along the boundary:f(y, z, t) on x-boundaries;\nf(x, z, t) on y-boundaries;\nf(x, y, t) on z-boundaries.Alternative function signatures are specified by keyword arguments to BoundaryCondition, as illustrated in subsequent examples.","category":"page"},{"location":"model_setup/boundary_conditions/#.-Spatially-and-temporally-varying-flux-with-parameters","page":"Boundary conditions","title":"4. Spatially- and temporally-varying flux with parameters","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Boundary condition functions may be 'parameterized',","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> @inline wind_stress(x, y, t, p) = - p.τ * cos(p.k * x) * cos(p.ω * t); # function with parameters\n\njulia> top_u_bc = BoundaryCondition(Flux, wind_stress, parameters=(k=4π, ω=3.0, τ=1e-4))\nBoundaryCondition: type=Flux, condition=wind_stress(x, y, t, p) in Main at none:1","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"info: Boundary condition functions with parameters\nThe keyword argument parameters above specifies that wind_stress is called with the signature wind_stress(x, y, t, parameters). In principle, parameters is arbitrary. However, relatively simple objects such as floating point numbers or NamedTuples must be used when running on the GPU.","category":"page"},{"location":"model_setup/boundary_conditions/#.-'Field-dependent'-boundary-conditions","page":"Boundary conditions","title":"5. 'Field-dependent' boundary conditions","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Boundary conditions may also depend on model fields. For example, a linear drag boundary condition is implemented with","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> @inline linear_drag(x, y, z, t, u) = - 0.2 * u\nlinear_drag (generic function with 1 method)\n\njulia> u_bottom_bc = FluxBoundaryCondition(linear_drag, field_dependencies=:u)\nBoundaryCondition: type=Flux, condition=linear_drag(x, y, z, t, u) in Main at none:1","category":"page"},{"location":"model_setup/boundary_conditions/#.-'Field-dependent'-boundary-conditions-with-parameters","page":"Boundary conditions","title":"6. 'Field-dependent' boundary conditions with parameters","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"When boundary conditions depends on fields and parameters, their functions take the form","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> @inline quadratic_drag(x, y, z, t, u, v, drag_coeff) = - drag_coeff * u * sqrt(u^2 + v^2)\nquadratic_drag (generic function with 1 method)\n\njulia> u_bottom_bc = FluxBoundaryCondition(quadratic_drag, field_dependencies=(:u, :v), parameters=1e-3)\nBoundaryCondition: type=Flux, condition=quadratic_drag(x, y, z, t, u, v, drag_coeff) in Main at none:1","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Put differently, field dependencies follow ξ, η, t come first in the function signature, which are in turn followed by parameters.","category":"page"},{"location":"model_setup/boundary_conditions/#.-Discrete-form-boundary-condition-with-parameters","page":"Boundary conditions","title":"7. Discrete-form boundary condition with parameters","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Discrete field data may also be accessed directly from boundary condition functions using the discrete_form. For example:","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"@inline filtered_drag(i, j, grid, clock, model_fields) =\n   @inbounds - 0.05 * (model_fields.u[i-1, j, 1] + 2 * model_fields.u[i, j, 1] + model_fields.u[i-1, j, 1])\n\nu_bottom_bc = FluxBoundaryCondition(filtered_drag, discrete_form=true)\n\n# output\nBoundaryCondition: type=Flux, condition=filtered_drag(i, j, grid, clock, model_fields) in Main at none:1","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"info: The 'discrete form' for boundary condition functions\nThe argument discrete_form=true indicates to BoundaryCondition that filtered_drag uses the 'discrete form'. Boundary condition functions that use the 'discrete form' are called with the signaturef(i, j, grid, clock, model_fields)where i, j are grid indices that vary along the boundary, grid is model.grid, clock is the model.clock, and model_fields is a NamedTuple containing u, v, w and the fields in model.tracers. The signature is similar for x and y boundary conditions expect that i, j is replaced with j, k and i, k respectively.","category":"page"},{"location":"model_setup/boundary_conditions/#.-Discrete-form-boundary-condition-with-parameters-2","page":"Boundary conditions","title":"8. Discrete-form boundary condition with parameters","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> Cd = 0.2;  # drag coefficient\n\njulia> @inline linear_drag(i, j, grid, clock, model_fields, Cd) = @inbounds - Cd * model_fields.u[i, j, 1];\n\njulia> u_bottom_bc = BoundaryCondition(Flux, linear_drag, discrete_form=true, parameters=Cd)\nBoundaryCondition: type=Flux, condition=linear_drag(i, j, grid, clock, model_fields, Cd) in Main at none:1","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"info: Inlining and avoiding bounds-checking in boundary condition functions\nBoundary condition functions should be decorated with @inline when running on CPUs for performance reasons. On the GPU, all functions are force-inlined by default. In addition, the annotation @inbounds should be used when accessing the elements of an array in a boundary condition function (such as model_fields.u[i, j, 1] in the above example). Using @inbounds will avoid a relatively expensive check that the index i, j, 1 is 'in bounds'.","category":"page"},{"location":"model_setup/boundary_conditions/#.-A-random,-spatially-varying,-constant-in-time-temperature-flux-specified-by-an-array","page":"Boundary conditions","title":"9. A random, spatially-varying, constant-in-time temperature flux specified by an array","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> Nx = Ny = 16;  # Number of grid points.\n\njulia> Q = randn(Nx, Ny); # temperature flux\n\njulia> white_noise_T_bc = FluxBoundaryCondition(Q)\nBoundaryCondition: type=Flux, condition=16×16 Array{Float64,2}","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"When running on the GPU, Q must be converted to a CuArray.","category":"page"},{"location":"model_setup/boundary_conditions/#Building-boundary-conditions-on-a-field","page":"Boundary conditions","title":"Building boundary conditions on a field","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"To create, for example, a set of horizontally-periodic field boundary conditions, write","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> topology = (Periodic, Periodic, Bounded);\n\njulia> grid = RegularRectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1), topology=topology);\n\njulia> T_bcs = TracerBoundaryConditions(grid,    top = ValueBoundaryCondition(20),\n                                              bottom = GradientBoundaryCondition(0.01))\nOceananigans.FieldBoundaryConditions (NamedTuple{(:x, :y, :z)}), with boundary conditions\n├── x: CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}\n├── y: CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}\n└── z: CoordinateBoundaryConditions{BoundaryCondition{Gradient,Float64},BoundaryCondition{Value,Int64}}","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"T_bcs is a FieldBoundaryConditions object for temperature T appropriate for horizontally periodic grid topologies. The default Periodic boundary conditions in x and y are inferred from the topology of grid.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"For u, v, and w, use the UVelocityBoundaryConditions VVelocityBoundaryConditions, and WVelocityBoundaryConditions constructors, respectively.","category":"page"},{"location":"model_setup/boundary_conditions/#Specifying-model-boundary-conditions","page":"Boundary conditions","title":"Specifying model boundary conditions","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"To specify non-default boundary conditions, a named tuple of FieldBoundaryConditions objects is passed to the keyword argument boundary_conditions in the IncompressibleModel constructor. The keys of boundary_conditions indicate the field to which the boundary condition is applied. Below, non-default boundary conditions are imposed on the u-velocity and temperature.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> topology = (Periodic, Periodic, Bounded);\n\njulia> grid = RegularRectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1), topology=topology);\n\njulia> u_bcs = UVelocityBoundaryConditions(grid, top = ValueBoundaryCondition(+0.1),\n                                              bottom = ValueBoundaryCondition(-0.1));\n\njulia> T_bcs = TracerBoundaryConditions(grid, top = ValueBoundaryCondition(20),\n                                           bottom = GradientBoundaryCondition(0.01));\n\njulia> model = IncompressibleModel(grid=grid, boundary_conditions=(u=u_bcs, T=T_bcs))\nIncompressibleModel{CPU, Float64}(time = 0 seconds, iteration = 0)\n├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=16, Ny=16, Nz=16)\n├── tracers: (:T, :S)\n├── closure: Nothing\n├── buoyancy: SeawaterBuoyancy{Float64,LinearEquationOfState{Float64},Nothing,Nothing}\n└── coriolis: Nothing\n\njulia> model.velocities.u\nField located at (Face, Center, Center)\n├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (16, 16, 16)\n├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=16, Ny=16, Nz=16)\n└── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, north=Periodic), z=(bottom=Value, top=Value)\n\njulia> model.tracers.T\nField located at (Center, Center, Center)\n├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (16, 16, 16)\n├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=16, Ny=16, Nz=16)\n└── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, north=Periodic), z=(bottom=Gradient, top=Value)","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Notice that the specified non-default boundary conditions have been applied at top and bottom of both model.velocities.u and model.tracers.T.","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"EditURL = \"<unknown>/examples/convecting_plankton.jl\"","category":"page"},{"location":"generated/convecting_plankton/#Plankton-mixing-and-blooming","page":"Convecting plankton","title":"Plankton mixing and blooming","text":"","category":"section"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"In this example, we simulate the mixing of phytoplankton by convection that decreases in time and eventually shuts off, thereby precipitating a phytoplankton bloom. A similar scenario was simulated by Taylor and Ferrari (2011), providing evidence that the \"critical turbulence hypothesis\" explains the explosive bloom of oceanic phytoplankton observed in spring.","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"The phytoplankton in our model are advected, diffuse, grow, and die according to","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"_t P + boldsymbolu   P - κ ²P = (μ₀ exp(z  λ) - m)  P  ","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"where boldsymbolu is the turbulent velocity field, κ is an isotropic diffusivity,  μ₀ is the phytoplankton growth rate at the surface, λ is the scale over which sunlight attenuates away from the surface, and m is the mortality rate of phytoplankton due to viruses and grazing by zooplankton. We use Oceananigans'  Forcing abstraction to implement the phytoplankton dynamics described by the right side of the phytoplankton equation above.","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"This example demonstrates","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"How to use a user-defined forcing function to simulate the dynamics of phytoplankton growth in sunlight and grazing by zooplankton.\nHow to set time-dependent boundary conditions.\nHow to use the TimeStepWizard to adapt the simulation time-step.\nHow to use AveragedField to diagnose spatial averages of model fields.","category":"page"},{"location":"generated/convecting_plankton/#Install-dependencies","page":"Convecting plankton","title":"Install dependencies","text":"","category":"section"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"using Pkg\npkg\"add Oceananigans, Plots, JLD2, Measures\"","category":"page"},{"location":"generated/convecting_plankton/#The-grid","page":"Convecting plankton","title":"The grid","text":"","category":"section"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"We use a two-dimensional grid with 64² points and 1 m grid spacing and assign Flat to the y direction:","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"using Oceananigans\nusing Oceananigans.Units: minutes, hour, hours, day\n\ngrid = RegularRectilinearGrid(size=(64, 64), extent=(64, 64), topology=(Periodic, Flat, Bounded))","category":"page"},{"location":"generated/convecting_plankton/#Boundary-conditions","page":"Convecting plankton","title":"Boundary conditions","text":"","category":"section"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"We impose a surface buoyancy flux that's initially constant and then decays to zero,","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"buoyancy_flux(x, y, t, p) = p.initial_buoyancy_flux * exp(-t^4 / (24 * p.shut_off_time^4))\n\nbuoyancy_flux_parameters = (initial_buoyancy_flux = 1e-8, # m² s⁻³\n                                    shut_off_time = 2hours)\n\nbuoyancy_flux_bc = FluxBoundaryCondition(buoyancy_flux, parameters = buoyancy_flux_parameters)","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"The fourth power in the argument of exp above helps keep the buoyancy flux relatively constant during the first phase of the simulation. We produce a plot of this time-dependent buoyancy flux for the visually-oriented,","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"using Plots, Measures\n\ntime = range(0, 12hours, length=100)\n\nflux_plot = plot(time ./ hour, [buoyancy_flux(0, 0, t, buoyancy_flux_parameters) for t in time],\n                 linewidth = 2, xlabel = \"Time (hours)\", ylabel = \"Surface buoyancy flux (m² s⁻³)\",\n                 size = (800, 300), margin = 5mm, label = nothing)","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"The buoyancy flux effectively shuts off after 6 hours of simulation time.","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"info: The flux convention in Oceananigans.jl\nFluxes are defined by the direction a quantity is carried: positive velocities produce positive fluxes, while negative velocities produce negative fluxes. Diffusive fluxes are defined with the same convention. A positive flux at the top boundary transports buoyancy upwards, out of the domain. This means that a positive flux of buoyancy at the top boundary reduces the buoyancy of near-surface fluid, causing convection.","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"The initial condition and bottom boundary condition impose the constant buoyancy gradient","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"N² = 1e-4 # s⁻²\n\nbuoyancy_gradient_bc = GradientBoundaryCondition(N²)","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"In summary, the buoyancy boundary conditions impose a destabilizing flux at the top and a stable buoyancy gradient at the bottom:","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"buoyancy_bcs = TracerBoundaryConditions(grid, top = buoyancy_flux_bc, bottom = buoyancy_gradient_bc)","category":"page"},{"location":"generated/convecting_plankton/#Phytoplankton-dynamics:-light-dependent-growth-and-uniform-mortality","page":"Convecting plankton","title":"Phytoplankton dynamics: light-dependent growth and uniform mortality","text":"","category":"section"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"We use a simple model for the growth of phytoplankton in sunlight and decay due to viruses and grazing by zooplankton,","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"growing_and_grazing(x, y, z, t, P, p) = (p.μ₀ * exp(z / p.λ) - p.m) * P\nnothing # hide","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"with parameters","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"plankton_dynamics_parameters = (μ₀ = 1/day,   # surface growth rate\n                                 λ = 5,       # sunlight attenuation length scale (m)\n                                 m = 0.1/day) # mortality rate due to virus and zooplankton grazing","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"We tell Forcing that our plankton model depends on the plankton concentration P and the chosen parameters,","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"plankton_dynamics = Forcing(growing_and_grazing, field_dependencies = :P,\n                            parameters = plankton_dynamics_parameters)","category":"page"},{"location":"generated/convecting_plankton/#The-model","page":"Convecting plankton","title":"The model","text":"","category":"section"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"The name \"P\" for phytoplankton is specified in the constructor for IncompressibleModel. We additionally specify a fifth-order advection scheme, third-order Runge-Kutta time-stepping, isotropic viscosity and diffusivities, and Coriolis forces appropriate for planktonic convection at mid-latitudes on Earth.","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"model = IncompressibleModel(\n                   grid = grid,\n              advection = UpwindBiasedFifthOrder(),\n            timestepper = :RungeKutta3,\n                closure = IsotropicDiffusivity(ν=1e-4, κ=1e-4),\n               coriolis = FPlane(f=1e-4),\n                tracers = (:b, :P), # P for Plankton\n               buoyancy = BuoyancyTracer(),\n                forcing = (P=plankton_dynamics,),\n    boundary_conditions = (b=buoyancy_bcs,)\n)","category":"page"},{"location":"generated/convecting_plankton/#Initial-condition","page":"Convecting plankton","title":"Initial condition","text":"","category":"section"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"We set the initial phytoplankton at P = 1  rmμM. For buoyancy, we use a stratification that's mixed near the surface and linearly stratified below, superposed with surface-concentrated random noise.","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"mixed_layer_depth = 32 # m\n\nstratification(z) = z < -mixed_layer_depth ? N² * z : - N² * mixed_layer_depth\n\nnoise(z) = 1e-4 * N² * grid.Lz * randn() * exp(z / 4)\n\ninitial_buoyancy(x, y, z) = stratification(z) + noise(z)\n\nset!(model, b=initial_buoyancy, P=1)","category":"page"},{"location":"generated/convecting_plankton/#Adaptive-time-stepping,-logging,-output-and-simulation-setup","page":"Convecting plankton","title":"Adaptive time-stepping, logging, output and simulation setup","text":"","category":"section"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"We use a TimeStepWizard that limits the time-step to 2 minutes, and adapts the time-step such that CFL (Courant-Freidrichs-Lewy) number hovers around 1.0,","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"wizard = TimeStepWizard(cfl=1.0, Δt=2minutes, max_change=1.1, max_Δt=2minutes)","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"We also write a function that prints the progress of the simulation","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"using Printf\n\nprogress(sim) = @printf(\"Iteration: %d, time: %s, Δt: %s\\n\",\n                        sim.model.clock.iteration,\n                        prettytime(sim.model.clock.time),\n                        prettytime(sim.Δt.Δt))\n\nsimulation = Simulation(model, Δt=wizard, stop_time=24hours,\n                        iteration_interval=20, progress=progress)","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"We add a basic JLD2OutputWriter that writes velocities and both the two-dimensional and horizontally-averaged plankton concentration,","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"averaged_plankton = AveragedField(model.tracers.P, dims=(1, 2))\n\noutputs = (w = model.velocities.w,\n           plankton = model.tracers.P,\n           averaged_plankton = averaged_plankton)\n\nsimulation.output_writers[:simple_output] =\n    JLD2OutputWriter(model, outputs,\n                     schedule = TimeInterval(20minutes),\n                     prefix = \"convecting_plankton\",\n                     force = true)","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"info: Using multiple output writers\nBecause each output writer is associated with a single output schedule, it often makes sense to use different output writers for different types of output. For example, reduced fields like AveragedField usually consume less disk space than two- or three-dimensional fields, and can thus be output more frequently without blowing up your hard drive. An arbitrary number of output writers may be added to simulation.output_writers.","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"The simulation is set up. Let there be plankton:","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"run!(simulation)","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"Notice how the time-step is reduced at early times, when turbulence is strong, and increases again towards the end of the simulation when turbulence fades.","category":"page"},{"location":"generated/convecting_plankton/#Visualizing-the-solution","page":"Convecting plankton","title":"Visualizing the solution","text":"","category":"section"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"We'd like to a make a plankton movie. First we load the output file and build a time-series of the buoyancy flux,","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"using JLD2\n\nfile = jldopen(simulation.output_writers[:simple_output].filepath)\n\niterations = parse.(Int, keys(file[\"timeseries/t\"]))\n\ntimes = [file[\"timeseries/t/$iter\"] for iter in iterations]\n\nbuoyancy_flux_time_series = [buoyancy_flux(0, 0, t, buoyancy_flux_parameters) for t in times]\nnothing # hide","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"and then we construct the x z grid,","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"xw, yw, zw = nodes(model.velocities.w)\nxp, yp, zp = nodes(model.tracers.P)\nnothing # hide","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"Finally, we animate plankton mixing and blooming,","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"using Plots\n\n@info \"Making a movie about plankton...\"\n\nw_lim = 0   # the maximum(abs(w)) across the whole timeseries\n\nfor (i, iteration) in enumerate(iterations)\n    w = file[\"timeseries/w/$iteration\"][:, 1, :]\n\n    global w_lim = maximum([w_lim, maximum(abs.(w))])\nend\n\nanim = @animate for (i, iteration) in enumerate(iterations)\n\n    @info \"Plotting frame $i from iteration $iteration...\"\n\n    t = file[\"timeseries/t/$iteration\"]\n    w = file[\"timeseries/w/$iteration\"][:, 1, :]\n    P = file[\"timeseries/plankton/$iteration\"][:, 1, :]\n    averaged_P = file[\"timeseries/averaged_plankton/$iteration\"][1, 1, :]\n\n    P_min = minimum(P) - 1e-9\n    P_max = maximum(P) + 1e-9\n    P_lims = (0.95, 1.1)\n\n    w_levels = range(-w_lim, stop=w_lim, length=20)\n\n    P_levels = collect(range(P_lims[1], stop=P_lims[2], length=20))\n    P_lims[1] > P_min && pushfirst!(P_levels, P_min)\n    P_lims[2] < P_max && push!(P_levels, P_max)\n\n    kwargs = (xlabel=\"x (m)\", ylabel=\"y (m)\", aspectratio=1, linewidth=0, colorbar=true,\n              xlims=(0, model.grid.Lx), ylims=(-model.grid.Lz, 0))\n\n    w_contours = contourf(xw, zw, w';\n                          color = :balance,\n                          levels = w_levels,\n                          clims = (-w_lim, w_lim),\n                          kwargs...)\n\n    P_contours = contourf(xp, zp, clamp.(P, P_lims[1], P_lims[2])';\n                          color = :matter,\n                          levels = P_levels,\n                          clims = P_lims,\n                          kwargs...)\n\n    P_profile = plot(averaged_P, zp,\n                     linewidth = 2,\n                     label = nothing,\n                     xlims = (0.9, 1.3),\n                     ylabel = \"z (m)\",\n                     xlabel = \"Plankton concentration (μM)\")\n\n    flux_plot = plot(times ./ hour, buoyancy_flux_time_series,\n                     linewidth = 1,\n                     label = \"Buoyancy flux time series\",\n                     color = :black,\n                     alpha = 0.4,\n                     legend = :topright,\n                     xlabel = \"Time (hours)\",\n                     ylabel = \"Buoyancy flux (m² s⁻³)\",\n                     ylims = (0.0, 1.1 * buoyancy_flux_parameters.initial_buoyancy_flux))\n\n    plot!(flux_plot, times[1:i] ./ hour, buoyancy_flux_time_series[1:i],\n          color = :steelblue,\n          linewidth = 6,\n          label = nothing)\n\n    scatter!(flux_plot, times[i:i] / hour, buoyancy_flux_time_series[i:i],\n             markershape = :circle,\n             color = :steelblue,\n             markerstrokewidth = 0,\n             markersize = 15,\n             label = \"Current buoyancy flux\")\n\n    layout = Plots.grid(2, 2, widths=(0.7, 0.3))\n\n    w_title = @sprintf(\"Vertical velocity (m s⁻¹) at %s\", prettytime(t))\n    P_title = @sprintf(\"Plankton concentration (μM) at %s\", prettytime(t))\n\n    plot(w_contours, flux_plot, P_contours, P_profile,\n         title=[w_title \"\" P_title \"\"],\n         layout=layout, size=(1000.5, 1000.5))\nend\n\nmp4(anim, \"convecting_plankton.mp4\", fps = 8) # hide","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"This page was generated using Literate.jl.","category":"page"},{"location":"gallery/#Gallery","page":"Gallery","title":"Gallery","text":"","category":"section"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"Collection of cool movies!","category":"page"},{"location":"gallery/#[Deep-convection](https://www.youtube.com/watch?vkpUrxnKKMjI)","page":"Gallery","title":"Deep convection","text":"","category":"section"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"An idealized simulation of deep convection in the ocean. The simulation employs a resolution of 256x256x128 volumes in a 2x2x1 km horizontally periodic domain. Heat is sucked out of the ocean surface within a cooling disk of radius 600 m at a rate of 800 W/m² which cools the surface water and making it denser. This cold dense water then sinks into the ocean interior, initiating a convective process that penetrates deep into the ocean.","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"This deep convection process can happen when a cold storm passes through warmer waters, which happens for example in the Labrador Sea.","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"The video shows the temperature field and the domain is sliced in half so the convection happening under the cooling disk is clear.","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"(Image: Watch deep convection in action)","category":"page"},{"location":"gallery/#[Free-convection](https://www.youtube.com/watch?vyq4op9h3xcU)","page":"Gallery","title":"Free convection","text":"","category":"section"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"An idealized simulation of free convection in the ocean. The simulation employs a resolution of 256x256x256 volumes in a 100x100x100 m horizontally periodic domain. Heat is sucked out of the ocean surface at a rate of 75 W/m² which cools the surface water and making it denser. This cold dense water then sinks into the ocean interior, initiating a convective process that keeps mixing the upper layer of the ocean. This \"mixed layer\" has a relatively constant temperature and keeps deepening as the surface is cooled.","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"The video shows the temperature field and the domain is sliced in half.","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"(Image: Watch free convection in action)","category":"page"},{"location":"gallery/#[Winds-blowing-over-the-ocean](https://www.youtube.com/watch?vIRncfbvuiy8)","page":"Gallery","title":"Winds blowing over the ocean","text":"","category":"section"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"An idealized simulation of a strong wind stress acting on the surface of a stratified ocean. The simulation employs a resolution of 256x256x256 volumes in a 100x100x100 m horizontally periodic domain. A pretty strong wind stress of 0.1 N/m² is applied in the x direction which mechanically mixes the upper layer of the ocean. This leads to a \"mixed layer\" of constant temperature near the surface of the ocean. You can also see the onset of Kelvin-Helmholtz instabilities as the mechanical mixing sets in.","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"The video shows the temperature field in the top 25 meters and the domain is sliced in half for visualization. The line plots show the horizontally averaged temperature profile (top right), horizontally averaged turbulent kinetic energy (middle right), and the horizontally averaged buoyancy flux (or temperature flux).","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"(Image: Watch winds blowing over the ocean)","category":"page"},{"location":"gallery/#[Free-convection-with-wind-stress](https://www.youtube.com/watch?vob6OMQgPfI4)","page":"Gallery","title":"Free convection with wind stress","text":"","category":"section"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"An idealized simulation of a strong wind stress acting on the surface of a stratified ocean along with a cooling flux that sucks heat out of the surface. The simulation employs a resolution of 256x256x256 volumes in a 100x100x100 m horizontally periodic domain. A pretty strong wind stress of 0.1 N/m² is applied in the x direction which mechanically mixes the upper layer of the ocean. Also, heat is sucked out of the ocean surface at a rate of 75 W/m² which cools the surface water and making it denser. This cold dense water then sinks into the ocean interior, initiating a convective process that keeps mixing the upper layer of the ocean. This leads to a \"mixed layer\" of constant temperature near the surface of the ocean. You can also see the onset of Kelvin-Helmholtz instabilities as the mechanical mixing sets in.","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"The video shows the temperature field and the domain is sliced in half for visualization. The line plots show the horizontally averaged temperature profile (top right), horizontally averaged turbulent kinetic energy (middle right), and the horizontally averaged buoyancy flux (or temperature flux). The unusual periodic prism colormap is used to show the fine details at the surface as it cools and the layers of different temperatures (the isopycnals) being perturbed by internal waves.","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"(Image: Watch free convection with wind stress in action)","category":"page"},{"location":"model_setup/background_fields/#Background-fields","page":"Background fields","title":"Background fields","text":"","category":"section"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"BackgroundFields are velocity and tracer fields around which the resolved velocity and tracer fields evolve. In Oceananigans, only the advective terms associated with the interaction between background and resolved fields are included. For example, tracer advection is described by","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"boldsymbolnabla boldsymbolcdot left ( boldsymbolu c right )  ","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"where boldsymbolu is the resolved velocity field and c is the resolved tracer field corresponding to model.tracers.c. ","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"When a background field C is provided, the tracer advection term becomes","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"boldsymbolnabla boldsymbolcdot left ( boldsymbolu c right ) \n    + boldsymbolnabla boldsymbolcdot left ( boldsymbolu C right )  ","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"When both a background field velocity field boldsymbolU and a background tracer field C are provided, then the tracer advection term becomes","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"boldsymbolnabla boldsymbolcdot left ( boldsymbolu c right ) \n    + boldsymbolnabla boldsymbolcdot left ( boldsymbolu C right )\n    + boldsymbolnabla boldsymbolcdot left ( boldsymbolU c right )  ","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"Notice that the term boldsymbolnabla boldsymbolcdot left ( boldsymbolU C right )  is neglected: only the terms describing the advection of resolved tracer by the background  velocity field and the advection of background tracer by the resolved velocity field are included. An analgous statement holds for the advection of background momentum by the resolved velocity field. Other possible terms associated with the Coriolis force, buoyancy, turbulence closures, and surface waves acting on background fields are neglected.","category":"page"},{"location":"model_setup/background_fields/#Specifying-background-fields","page":"Background fields","title":"Specifying background fields","text":"","category":"section"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"BackgroundFields are defined by functions of (x y z t) and optional parameters. A  simple example is","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"using Oceananigans\n\nU(x, y, z, t) = 0.2 * z\n\ngrid = RegularRectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))\n\nmodel = IncompressibleModel(grid = grid, background_fields = (u=U,))\n\nmodel.background_fields.velocities.u\n\n# output\nFunctionField located at (Face, Center, Center)\n├── func: U\n├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1)\n├── clock: Clock(time=0 seconds, iteration=0)\n└── parameters: nothing","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"BackgroundFields are specified by passing them to the kwarg background_fields in the IncompressibleModel constructor. The kwarg background_fields expects a NamedTuple of fields, which are internally sorted into velocities and tracers, wrapped in FunctionFields, and assigned their appropriate locations.","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"BackgroundFields with parameters require using the BackgroundField wrapper:","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"using Oceananigans\n\nparameters = (α=3.14, N=1.0, f=0.1)\n\n## Background fields are defined via function of x, y, z, t, and optional parameters\nU(x, y, z, t, α) = α * z\nB(x, y, z, t, p) = - p.α * p.f * y + p.N^2 * z \n\nU_field = BackgroundField(U, parameters=parameters.α)\nB_field = BackgroundField(B, parameters=parameters)\n\n# output\nBackgroundField{typeof(B), NamedTuple{(:α, :N, :f),Tuple{Float64,Float64,Float64}}}\n├── func: B\n└── parameters: (α = 3.14, N = 1.0, f = 0.1)","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"When inserted into IncompressibleModel, we get out","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"grid = RegularRectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))\n\nmodel = IncompressibleModel(grid = grid, background_fields = (u=U_field, b=B_field),\n                            tracers=:b, buoyancy=BuoyancyTracer())\n\nmodel.background_fields.tracers.b\n\n# output\nFunctionField located at (Center, Center, Center)\n├── func: B\n├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1)\n├── clock: Clock(time=0 seconds, iteration=0)\n└── parameters: (α = 3.14, N = 1.0, f = 0.1)","category":"page"},{"location":"physics/coriolis_forces/#Coriolis-forces","page":"Coriolis forces","title":"Coriolis forces","text":"","category":"section"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"The Coriolis model controls the manifestation of the term boldsymbolf times boldsymbolu in the momentum equation.","category":"page"},{"location":"physics/coriolis_forces/#f-plane-approximation","page":"Coriolis forces","title":"f-plane approximation","text":"","category":"section"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"Under an f-plane approximation[3] the reference frame in which the momentum and tracer equations are solved rotates at a constant rate.","category":"page"},{"location":"physics/coriolis_forces/#The-traditional-f-plane-approximation","page":"Coriolis forces","title":"The traditional f-plane approximation","text":"","category":"section"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"In the traditional f-plane approximation, the coordinate system rotates around a vertical axis such that","category":"page"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"    boldsymbolf = f boldsymbolhat z  ","category":"page"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"where f is constant and determined by the user.","category":"page"},{"location":"physics/coriolis_forces/#The-non-traditional-f-plane-approximation","page":"Coriolis forces","title":"The non-traditional f-plane approximation","text":"","category":"section"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"In the non-traditional f-plane approximation, the coordinate system rotates around an axis in the yz-plane, such that","category":"page"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"    boldsymbolf = f_y boldsymbolhat y + f_z boldsymbolhat z  ","category":"page"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"where f_y and f_z are constants determined by the user.","category":"page"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"[3]: The f-plane approximation is used to model the effects of Earth's rotation on anisotropic    fluid motion in a plane tangent to the Earth's surface. In this case, the projection of    the Earth's rotation vector at latitude varphi and onto a coordinate system in which    x y z correspond to the directions east, north, and up is   math       \\boldsymbol{f} \\approx \\frac{4 \\pi}{\\text{day}} \\left ( \\cos \\varphi \\boldsymbol{\\hat y} + \\sin \\varphi \\boldsymbol{\\hat z} \\right ) \\, ,   where the Earth's rotation rate is approximately 2 pi  textday. The traditional    f-plane approximation neglects the y-component of this projection, which is appropriate    for fluid motions with large horizontal-to-vertical aspect ratios.","category":"page"},{"location":"physics/coriolis_forces/#\\beta-plane-approximation","page":"Coriolis forces","title":"beta-plane approximation","text":"","category":"section"},{"location":"physics/coriolis_forces/#The-traditional-\\beta-plane-approximation","page":"Coriolis forces","title":"The traditional beta-plane approximation","text":"","category":"section"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"Under the traditional beta-plane approximation, the rotation axis is vertical as for the f-plane approximation, but f is expanded in a Taylor series around a central latitude  such that","category":"page"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"    boldsymbolf = left ( f_0 + beta y right ) boldsymbolhat z  ","category":"page"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"where f_0 is the planetary vorticity at some central latitude, and beta is the planetary vorticity gradient. The beta-plane model is not periodic in y and thus can be used only in domains that are bounded in the y-direction.","category":"page"},{"location":"physics/coriolis_forces/#The-non-traditional-\\beta-plane-approximation","page":"Coriolis forces","title":"The non-traditional beta-plane approximation","text":"","category":"section"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"The non-traditional beta-plane approximation accounts for the latitudinal variation of both the locally vertical and the locally horizontal components of the rotation vector","category":"page"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"    boldsymbolf = left 2Omegacosvarphi_0 left( 1 -  fraczR right) + gamma y right boldsymbolhat y\n           + left 2Omegasinvarphi_0 left( 1 + 2fraczR right) + beta  y right boldsymbolhat z  ","category":"page"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"as can be found in the paper by Paul J Dellar  (2011) where  beta = 2 Omega cos varphi_0  R and gamma = -4 Omega sin varphi_0  R.","category":"page"},{"location":"model_setup/coriolis/#Coriolis","page":"Coriolis (rotation)","title":"Coriolis","text":"","category":"section"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"The Coriolis option determines whether the fluid experiences the effect of the Coriolis force, or rotation. Currently three options are available: no rotation, f-plane, and beta-plane.","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"info: Coriolis vs. rotation\nIf you are wondering why this option is called \"Coriolis\" it is because rotational effects could include the Coriolis and centripetal forces, both of which arise in non-inertial reference frames. But here the model only considers the Coriolis force.","category":"page"},{"location":"model_setup/coriolis/#No-rotation","page":"Coriolis (rotation)","title":"No rotation","text":"","category":"section"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"By default there is no rotation. This can be made explicit by passing coriolis = nothing to a model constructor.","category":"page"},{"location":"model_setup/coriolis/#Traditional-f-plane","page":"Coriolis (rotation)","title":"Traditional f-plane","text":"","category":"section"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"To set up an f-plane with, for example, Coriolis parameter f = 10^-4 texts^-1","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"DocTestSetup = quote\n    using Oceananigans\nend","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"julia> coriolis = FPlane(f=1e-4)\nFPlane{Float64}: f = 1.00e-04","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"An f-plane can also be specified at some latitude on a spherical planet with a planetary rotation rate. For example, to specify an f-plane at a latitude of varphi = 45textN on Earth which has a rotation rate of Omega = 7292115 times 10^-5 texts^-1","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"julia> coriolis = FPlane(rotation_rate=7.292115e-5, latitude=45)\nFPlane{Float64}: f = 1.03e-04","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"in which case the value of f is given by 2Omegasinvarphi.","category":"page"},{"location":"model_setup/coriolis/#Non-traditional-f-plane","page":"Coriolis (rotation)","title":"Non-traditional f-plane","text":"","category":"section"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"To set up an f-plane with non-traditional Coriolis terms, for example, with boldsymbolf = (0 f_y f_z) = (0 2 1) times 10^-4 texts^-1,","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"julia> coriolis = NonTraditionalFPlane(fz=1e-4, fy=2e-4)\nNonTraditionalFPlane{Float64}: fz = 1.00e-04, fy = 2.00e-04","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"An f-plane with non-traditional Coriolis terms can also be specified at some latitude on a spherical planet with a planetary rotation rate. For example, to specify an f-plane at a latitude of varphi = 45textN on Earth which has a rotation rate of Omega = 7292115 times 10^-5 texts^-1","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"julia> coriolis = NonTraditionalFPlane(rotation_rate=7.292115e-5, latitude=45)\nNonTraditionalFPlane{Float64}: fz = 1.03e-04, fy = 1.03e-04","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"in which case f_z = 2Omegasinvarphi and f_y = 2Omegacosvarphi.","category":"page"},{"location":"model_setup/coriolis/#Traditional-\\beta-plane","page":"Coriolis (rotation)","title":"Traditional beta-plane","text":"","category":"section"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"To set up a beta-plane the background rotation rate f_0 and the beta parameter must be specified. For example, a beta-plane with f_0 = 10^-4 texts^-1 and beta = 15 times 10^-11 texts^-1textm^-1 can be set up with","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"julia> coriolis = BetaPlane(f₀=1e-4, β=1.5e-11)\nBetaPlane{Float64}: f₀ = 1.00e-04, β = 1.50e-11","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"Alternatively, a beta-plane can also be set up at some latitude on a spherical planet with a planetary rotation rate and planetary radius. For example, to specify a beta-plane at a latitude of varphi = 10degreeS on Earth which has a rotation rate of Omega = 7292115 times 10^-5 texts^-1 and a radius of R = 6371 textkm","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"julia> coriolis = BetaPlane(rotation_rate=7.292115e-5, latitude=-10, radius=6371e3)\nBetaPlane{Float64}: f₀ = -2.53e-05, β = 2.25e-11","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"in which case f_0 = 2Omegasinvarphi and beta = 2Omegacosvarphi  R.","category":"page"},{"location":"model_setup/coriolis/#Non-traditional-\\beta-plane","page":"Coriolis (rotation)","title":"Non-traditional beta-plane","text":"","category":"section"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"A non-traditional beta-plane requires either 5 parameters (by default Earth's radius and rotation rate are used):","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"julia> NonTraditionalBetaPlane(fz=1e-4, fy=2e-4, β=4e-11, γ=-8e-11)\nNonTraditionalBetaPlane{Float64}: fz = 1.00e-04, fy = 2.00e-04, β = 4.00e-11, γ = -8.00e-11, R = 6.37e+06","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"or the rotation rate, radius, and latitude:","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"julia> NonTraditionalBetaPlane(rotation_rate=5.31e-5, radius=252.1e3, latitude=10)\nNonTraditionalBetaPlane{Float64}: fz = 1.84e-05, fy = 1.05e-04, β = 4.15e-10, γ = -1.46e-10, R = 2.52e+05","category":"page"},{"location":"numerical_implementation/boundary_conditions/#numerical_bcs","page":"Boundary conditions","title":"Numerical implementation of boundary conditions","text":"","category":"section"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"We adopt a mixed approach for implementing boundary conditions that uses both halo regions and \"direct\" imposition of boundary conditions, depending on the condition prescribed.","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"We illustrate how boundary conditions are implemented by considering the tracer equation \\eqref{eq:tracer}.","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"See Model setup: boundary conditions for how to create and use these boundary conditions in Oceananigans.","category":"page"},{"location":"numerical_implementation/boundary_conditions/#Gradient-boundary-conditions","page":"Boundary conditions","title":"Gradient boundary conditions","text":"","category":"section"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Users impose gradient boundary conditions by prescribing the gradient gamma of a field  c across an external boundary partial Omega_b. The prescribed gradient gamma  may be a constant, discrete array of values, or an arbitrary function. The gradient boundary  condition is enforced setting the value of halo points located outside the domain interior  such that","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"    beginequation\n    labeleqgradient-bc\n    hatboldsymboln boldsymbolcdot boldsymbolnabla c _partial Omega_b = gamma  \n    endequation","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"where hatboldsymboln is the vector normal to partial Omega_b.","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Across the bottom boundary in z, for example, this requires that","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"    beginequation\n    labeleqlinear-extrapolation\n    c_i j 0 = c_i j 1 + gamma_i j 1 tfrac12 left ( Delta z_i j 1 + Delta z_i j 0 right )  \n    endequation","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"where Delta z_i j 1 = Delta z_i j 0 are the heights of the finite volume at i j and k=1 and k=0. This prescription implies that the z-derivative of c across the boundary at k=1 is","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"    beginequation\n    partial_z c  _i j 1 equiv\n        fracc_i j 1 - c_i j 0tfrac12 left ( Delta z_i j 1 + Delta z_i j 0 right )\n            = gamma_i j 1  \n    endequation","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"as prescribed by the user.","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Gradient boundary conditions are represented by the Gradient type.","category":"page"},{"location":"numerical_implementation/boundary_conditions/#Value-boundary-conditions","page":"Boundary conditions","title":"Value boundary conditions","text":"","category":"section"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Users impose value boundary conditions by prescribing c^b, the value of c on the external boundary partial Omega_b. The value c^b may be a constant, array of discrete values, or an arbitrary function. To enforce a value boundary condition, the gradient associated with the difference between c^b and c at boundary-adjacent nodes is diagnosed and used to set the value of the c halo point located outside the boundary.","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"At the bottom boundary in z, for example, this means that the gradient of c is determined by","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"    beginequation\n    gamma = fracc_i j 1 - c^b_i j 1tfrac12 Delta z_i j 1  \n    endequation","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"which is then used to set the halo point c_i j 0 via linear extrapolation.","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Value boundary conditions are represented by the Value type.","category":"page"},{"location":"numerical_implementation/boundary_conditions/#Flux-boundary-conditions","page":"Boundary conditions","title":"Flux boundary conditions","text":"","category":"section"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Users impose flux boundary conditions by prescribing the flux q_c  _b of c across the external boundary partial Omega_b. The flux q_c  _b may be a constant, array  of discrete values, or arbitrary function. To explain how flux boundary conditions are imposed  in Oceananigans.jl, we note that the average of the tracer conservation equation over a finite  volume yields","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"    beginequation\n    labeleqdcdt\n    partial_t c_i j k = - frac1V_i j k oint_partial Omega_i j k (boldsymbolu c + boldsymbolq_c)  mathrmd S\n                             + frac1V_i j k int_V_i j k F_c  mathrmd V  \n    endequation","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"where the surface integral over partial Omega_i j k averages the flux of c across  the six faces of the finite volume. The right-hand-side of \\eqref{eq:dc/dt} above is denoted as  G_c _i j k.","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"An external boundary of a finite volume is associated with a no-penetration condition such that hatboldsymboln boldsymbolcdot boldsymbolu  _partial Omega_b = 0, where  hatboldsymboln is the vector normal to partial Omega_b. Furthermore, the closures  currently available in \\texttt{Oceananigans.jl} have the property that boldsymbolq_c propto boldsymbolnabla c. Thus setting hatboldsymboln boldsymbolcdot boldsymbolnabla c  _partial Omega_b = 0  on the external boundary implies that the total flux of c across the external boundary is","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"    beginequation\n    hatboldsymboln boldsymbolcdot left ( boldsymbolu c + boldsymbolq_c right ) _partial Omega_b = 0  \n    endequation","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Oceananigans.jl exploits this fact to define algorithm that prescribe fluxes across external  boundaries partial Omega_b:","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Impose a constant gradient hatboldsymboln boldsymbolcdot boldsymbolnabla c   _partial Omega_b = 0 across external boundaries via using halo points (similar  to \\eqref{eq:gradient-bc}), which ensures that the evaluation of G_c in boundary-adjacent cells does not include fluxes across the external boundary, and;\nAdd the prescribed flux to the boundary-adjacent volumes prior to calculating G_c:  G_c  _b = G_c  _b - fracA_bV_b q_c  _b  textsign(hatboldsymboln),  where G_c  _b denotes values of G_c in boundary-adjacent volumes, q_c  _b  is the flux prescribed along the boundary, V_b is the volume of the boundary-adjacent  cell, and A_b is the area of the external boundary of the boundary-adjacent cell.\nThe factor textsign(hatboldsymboln) is -1 and +1 on \"left\" and \"right\"  boundaries, and accounts for the fact that a positive flux on a left boundary where  textsign(hatboldsymboln) = -1 implies an \"inward\" flux of c that increases  interior values of c, whereas a positive flux on a right boundary where  textsign(hatboldsymboln) = 1 implies an \"outward\" flux that decreases interior values of c.","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Flux boundary conditions are represented by the Flux type.","category":"page"},{"location":"numerical_implementation/pressure_decomposition/#Pressure-decomposition","page":"Pressure decomposition","title":"Pressure decomposition","text":"","category":"section"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"In the numerical implementation of the momentum equations, the kinematic potential phi  is split into \"hydrostatic anomaly\" and \"non-hydrostatic\" parts via","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"    beginequation\n    labeleqpressure\n    phi(boldsymbolx t) = phi_rmhyd(boldsymbolx t) + phi_rmnon(boldsymbolx t)  \n    endequation","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"The anomalous hydrostatic component of the kinematic potential is defined by ","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"    beginalign\n    labeleqhydrostaticpressure\n    partial_z phi_rmhyd equiv -b  \n    endalign","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"such that the sum of the kinematic potential and buoyancy perturbation becomes","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"    beginalign\n    -boldsymbolnabla phi + b boldsymbolhat z = \n        - boldsymbolnabla phi_rmnon\n        - boldsymbolnabla_h phi_rmhyd  \n    endalign","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"where boldsymbolnabla_h equiv partial_x boldsymbolhat x + partial_y boldsymbolhat y  is the horizontal gradient. The hydrostatic pressure anomaly is so named because the \"total\"  hydrostatic pressure contains additional components:","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"beginalign\npartial_z phi_texttotal hydrostatic  = - g left ( 1 + fracrho_*rho_0 + fracrhorho_0 right )   \n                                            = partial_z phi_rmhyd - g left ( 1 + fracrho_*rho_0 right )  \nendalign","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"Under this pressure decomposition the pressure gradient that appears in the momentum equations becomes","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"   boldsymbolnabla phi mapsto boldsymbolnabla phi_rmnon + boldsymbolnabla_h phi_rmhyd ","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"Mathematically, the non-hydrostatic potential phi_rmnon enforces the incompressibility constraint.","category":"page"}]
}

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · Oceananigans.jl</title><link rel="canonical" href="https://clima.github.io/OceananigansDocumentation/stable/library/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Oceananigans.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../installation_instructions/">Installation instructions</a></li><li><a class="tocitem" href="../using_gpus/">Using GPUs</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../generated/one_dimensional_diffusion/">One-dimensional diffusion</a></li><li><a class="tocitem" href="../generated/two_dimensional_turbulence/">Two-dimensional turbulence</a></li><li><a class="tocitem" href="../generated/internal_wave/">Internal wave</a></li><li><a class="tocitem" href="../generated/convecting_plankton/">Convecting plankton</a></li><li><a class="tocitem" href="../generated/ocean_wind_mixing_and_convection/">Ocean wind mixing and convection</a></li><li><a class="tocitem" href="../generated/langmuir_turbulence/">Langmuir turbulence</a></li><li><a class="tocitem" href="../generated/eady_turbulence/">Eady turbulence</a></li><li><a class="tocitem" href="../generated/kelvin_helmholtz_instability/">Kelvin-Helmholtz instability</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Model setup</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../model_setup/overview/">Overview</a></li><li><a class="tocitem" href="../model_setup/architecture/">Architecture</a></li><li><a class="tocitem" href="../model_setup/number_type/">Number type</a></li><li><a class="tocitem" href="../model_setup/grids/">Grid</a></li><li><a class="tocitem" href="../model_setup/clock/">Clock</a></li><li><a class="tocitem" href="../model_setup/coriolis/">Coriolis (rotation)</a></li><li><a class="tocitem" href="../model_setup/tracers/">Tracers</a></li><li><a class="tocitem" href="../model_setup/buoyancy_and_equation_of_state/">Buoyancy and equation of state</a></li><li><a class="tocitem" href="../model_setup/boundary_conditions/">Boundary conditions</a></li><li><a class="tocitem" href="../model_setup/forcing_functions/">Forcing functions</a></li><li><a class="tocitem" href="../model_setup/background_fields/">Background fields</a></li><li><a class="tocitem" href="../model_setup/turbulent_diffusivity_closures_and_les_models/">Turbulent diffusivity closures and LES models</a></li><li><a class="tocitem" href="../model_setup/lagrangian_particles/">Lagrangian particles</a></li><li><a class="tocitem" href="../model_setup/diagnostics/">Diagnostics</a></li><li><a class="tocitem" href="../model_setup/output_writers/">Output writers</a></li><li><a class="tocitem" href="../model_setup/checkpointing/">Checkpointing</a></li><li><a class="tocitem" href="../model_setup/time_stepping/">Time stepping</a></li><li><a class="tocitem" href="../model_setup/setting_initial_conditions/">Setting initial conditions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Physics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../physics/navier_stokes_and_tracer_conservation/">Navier-Stokes and tracer conservation equations</a></li><li><a class="tocitem" href="../physics/coriolis_forces/">Coriolis forces</a></li><li><a class="tocitem" href="../physics/buoyancy_and_equations_of_state/">Buoyancy model and equations of state</a></li><li><a class="tocitem" href="../physics/turbulence_closures/">Turbulence closures</a></li><li><a class="tocitem" href="../physics/surface_gravity_waves/">Surface gravity waves and the Craik-Leibovich approximation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Numerical implementation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../numerical_implementation/pressure_decomposition/">Pressure decomposition</a></li><li><a class="tocitem" href="../numerical_implementation/time_stepping/">Time stepping</a></li><li><a class="tocitem" href="../numerical_implementation/finite_volume/">Finite volume method</a></li><li><a class="tocitem" href="../numerical_implementation/spatial_operators/">Spatial operators</a></li><li><a class="tocitem" href="../numerical_implementation/boundary_conditions/">Boundary conditions</a></li><li><a class="tocitem" href="../numerical_implementation/poisson_solvers/">Poisson solvers</a></li><li><a class="tocitem" href="../numerical_implementation/large_eddy_simulation/">Large eddy simulation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Validation experiments</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../validation/convergence_tests/">Convergence tests</a></li><li><a class="tocitem" href="../validation/lid_driven_cavity/">Lid-driven cavity</a></li><li><a class="tocitem" href="../validation/stratified_couette_flow/">Stratified Couette flow</a></li></ul></li><li><a class="tocitem" href="../gallery/">Gallery</a></li><li><a class="tocitem" href="../benchmarks/">Performance benchmarks</a></li><li><a class="tocitem" href="../contributing/">Contributor&#39;s guide</a></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">Appendix</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../appendix/staggered_grid/">Staggered grid</a></li><li><a class="tocitem" href="../appendix/fractional_step/">Fractional step method</a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li><li class="is-active"><a class="tocitem" href>Library</a><ul class="internal"><li><a class="tocitem" href="#Advection"><span>Advection</span></a></li><li><a class="tocitem" href="#Architectures"><span>Architectures</span></a></li><li><a class="tocitem" href="#Boundary-conditions"><span>Boundary conditions</span></a></li><li><a class="tocitem" href="#Buoyancy"><span>Buoyancy</span></a></li><li><a class="tocitem" href="#Coriolis"><span>Coriolis</span></a></li><li><a class="tocitem" href="#Diagnostics"><span>Diagnostics</span></a></li><li><a class="tocitem" href="#Fields"><span>Fields</span></a></li><li><a class="tocitem" href="#Forcings"><span>Forcings</span></a></li><li><a class="tocitem" href="#Grids"><span>Grids</span></a></li><li><a class="tocitem" href="#Lagrangian-particle-tracking"><span>Lagrangian particle tracking</span></a></li><li><a class="tocitem" href="#Logger"><span>Logger</span></a></li><li><a class="tocitem" href="#Models"><span>Models</span></a></li><li><a class="tocitem" href="#Output-writers"><span>Output writers</span></a></li><li><a class="tocitem" href="#Time-steppers"><span>Time steppers</span></a></li><li><a class="tocitem" href="#Simulations"><span>Simulations</span></a></li><li><a class="tocitem" href="#Tubrulence-closures"><span>Tubrulence closures</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li><li><a class="tocitem" href="#Abstract-operations"><span>Abstract operations</span></a></li></ul></li><li><a class="tocitem" href="../function_index/">Function index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/CliMA/Oceananigans.jl/blob/master/docs/src/library.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><p>Documenting the public user interface.</p><h2 id="Advection"><a class="docs-heading-anchor" href="#Advection">Advection</a><a id="Advection-1"></a><a class="docs-heading-anchor-permalink" href="#Advection" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.div_Uc-NTuple{7,Any}" href="#Oceananigans.Advection.div_Uc-NTuple{7,Any}"><code>Oceananigans.Advection.div_Uc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">div_uc(i, j, k, grid, advection, U, c)</code></pre><p>Calculates the divergence of the flux of a tracer quantity c being advected by a velocity field U = (u, v, w), ∇·(Uc),</p><pre><code class="language-none">1/V * [δxᶜᵃᵃ(Ax * u * ℑxᶠᵃᵃ(c)) + δyᵃᶜᵃ(Ay * v * ℑyᵃᶠᵃ(c)) + δzᵃᵃᶜ(Az * w * ℑzᵃᵃᶠ(c))]</code></pre><p>which will end up at the location <code>ccc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Advection/tracer_advection_operators.jl#L5-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.div_Uu-NTuple{7,Any}" href="#Oceananigans.Advection.div_Uu-NTuple{7,Any}"><code>Oceananigans.Advection.div_Uu</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">div_Uu(i, j, k, grid, advection, U, u)</code></pre><p>Calculate the advection of momentum in the x-direction using the conservative form, ∇·(Uu)</p><pre><code class="language-none">1/Vᵘ * [δxᶠᵃᵃ(ℑxᶜᵃᵃ(Ax * u) * ℑxᶜᵃᵃ(u)) + δy_fca(ℑxᶠᵃᵃ(Ay * v) * ℑyᵃᶠᵃ(u)) + δz_fac(ℑxᶠᵃᵃ(Az * w) * ℑzᵃᵃᶠ(u))]</code></pre><p>which will end up at the location <code>fcc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Advection/momentum_advection_operators.jl#L5-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.div_Uv-NTuple{7,Any}" href="#Oceananigans.Advection.div_Uv-NTuple{7,Any}"><code>Oceananigans.Advection.div_Uv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">div_Uv(i, j, k, grid, advection, U, v)</code></pre><p>Calculate the advection of momentum in the y-direction using the conservative form, ∇·(Uv)</p><pre><code class="language-none">1/Vʸ * [δx_cfa(ℑyᵃᶠᵃ(Ax * u) * ℑxᶠᵃᵃ(v)) + δyᵃᶠᵃ(ℑyᵃᶜᵃ(Ay * v) * ℑyᵃᶜᵃ(v)) + δz_afc(ℑxᶠᵃᵃ(Az * w) * ℑzᵃᵃᶠ(w))]</code></pre><p>which will end up at the location <code>cfc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Advection/momentum_advection_operators.jl#L20-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.div_Uw-NTuple{7,Any}" href="#Oceananigans.Advection.div_Uw-NTuple{7,Any}"><code>Oceananigans.Advection.div_Uw</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">div_Uw(i, j, k, grid, advection, U, w)</code></pre><p>Calculate the advection of momentum in the z-direction using the conservative form, ∇·(Uw)</p><pre><code class="language-none">1/Vʷ * [δx_caf(ℑzᵃᵃᶠ(Ax * u) * ℑxᶠᵃᵃ(w)) + δy_acf(ℑzᵃᵃᶠ(Ay * v) * ℑyᵃᶠᵃ(w)) + δzᵃᵃᶠ(ℑzᵃᵃᶜ(Az * w) * ℑzᵃᵃᶜ(w))]</code></pre><p>which will end up at the location <code>ccf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Advection/momentum_advection_operators.jl#L35-L43">source</a></section></article><h2 id="Architectures"><a class="docs-heading-anchor" href="#Architectures">Architectures</a><a id="Architectures-1"></a><a class="docs-heading-anchor-permalink" href="#Architectures" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Architectures.AbstractArchitecture" href="#Oceananigans.Architectures.AbstractArchitecture"><code>Oceananigans.Architectures.AbstractArchitecture</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractArchitecture</code></pre><p>Abstract supertype for architectures supported by Oceananigans.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Architectures.jl#L12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Architectures.CPU" href="#Oceananigans.Architectures.CPU"><code>Oceananigans.Architectures.CPU</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CPU &lt;: AbstractArchitecture</code></pre><p>Run Oceananigans on one CPU node. Uses multiple threads if the environment variable <code>JULIA_NUM_THREADS</code> is set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Architectures.jl#L19-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Architectures.GPU" href="#Oceananigans.Architectures.GPU"><code>Oceananigans.Architectures.GPU</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GPU &lt;: AbstractArchitecture</code></pre><p>Run Oceananigans on a single NVIDIA CUDA GPU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Architectures.jl#L27-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Architectures.@hascuda-Tuple{Any}" href="#Oceananigans.Architectures.@hascuda-Tuple{Any}"><code>Oceananigans.Architectures.@hascuda</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@hascuda expr</code></pre><p>A macro to compile and execute <code>expr</code> only if CUDA is installed and available. Generally used to wrap expressions that can only be compiled if <code>CuArrays</code> and <code>CUDAnative</code> can be loaded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Architectures.jl#L34-L39">source</a></section></article><h2 id="Boundary-conditions"><a class="docs-heading-anchor" href="#Boundary-conditions">Boundary conditions</a><a id="Boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-conditions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.BCType" href="#Oceananigans.BoundaryConditions.BCType"><code>Oceananigans.BoundaryConditions.BCType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BCType</code></pre><p>Abstract supertype for boundary condition types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/BoundaryConditions/boundary_condition_types.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.Flux" href="#Oceananigans.BoundaryConditions.Flux"><code>Oceananigans.BoundaryConditions.Flux</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Flux</code></pre><p>A type specifying a boundary condition on the flux of a field.</p><p>The sign convention is such that a positive flux represents the flux of a quantity in the positive direction. For example, a positive vertical flux implies a quantity is fluxed upwards, in the +z direction.</p><p>Due to this convention, a positive flux applied to the top boundary specifies that a quantity is fluxed upwards across the top boundary and thus out of the domain. As a result, a positive flux applied to a top boundary leads to a reduction of that quantity in the interior of the domain; for example, a positive, upwards flux of heat at the top of the domain acts to cool the interior of the domain. Conversely, a positive flux applied to the bottom boundary leads to an increase of the quantity in the interior of the domain. The same logic holds for east, west, north, and south boundaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/BoundaryConditions/boundary_condition_types.jl#L17-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.Gradient" href="#Oceananigans.BoundaryConditions.Gradient"><code>Oceananigans.BoundaryConditions.Gradient</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Gradient</code></pre><p>A type specifying a boundary condition on the derivative or gradient of a field. Also called a Neumann boundary condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/BoundaryConditions/boundary_condition_types.jl#L36-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.NormalFlow" href="#Oceananigans.BoundaryConditions.NormalFlow"><code>Oceananigans.BoundaryConditions.NormalFlow</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NormalFlow</code></pre><p>A type specifying the component of a velocity field normal to a boundary.</p><p>Thus <code>NormalFlow</code> can only be applied to <code>u</code> along x, <code>v</code> along y, or <code>w</code> along z. For all other cases –- fields located at (Center, Center, Center), or <code>u</code>, <code>v</code>, and <code>w</code> in (y, z), (x, z), and (x, y), respectively, either <code>Value</code>, <code>Gradient</code>, or <code>Flux</code> conditions must be used.</p><p>Note that <code>NormalFlow</code> differs from a zero <code>Value</code> boundary condition:  <code>Value</code> imposes values at cell centers, while <code>NormalFlow</code> imposes values <em>on</em> a boundary, at cell faces. Only wall-normal components of the velocity field are defined on cell faces with respect to the wall-normal direction, and therefore only wall-normal components of the velocity field are defined on boundaries.  Both tracers and wall-tangential components of velocity fields are defined at cell centers with respect to the wall-normal direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/BoundaryConditions/boundary_condition_types.jl#L52-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.Value" href="#Oceananigans.BoundaryConditions.Value"><code>Oceananigans.BoundaryConditions.Value</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Value</code></pre><p>A type specifying a boundary condition on the value of a field. Also called a Dirchlet boundary condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/BoundaryConditions/boundary_condition_types.jl#L44-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.BoundaryCondition" href="#Oceananigans.BoundaryConditions.BoundaryCondition"><code>Oceananigans.BoundaryConditions.BoundaryCondition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct BoundaryCondition{C&lt;:BCType, T}</code></pre><p>Container for boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/BoundaryConditions/boundary_condition.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.BoundaryCondition-Tuple{Any,Any}" href="#Oceananigans.BoundaryConditions.BoundaryCondition-Tuple{Any,Any}"><code>Oceananigans.BoundaryConditions.BoundaryCondition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">BoundaryCondition(BC, condition)</code></pre><p>Construct a boundary condition of type <code>BC</code> with a number or array as a <code>condition</code>.</p><p>Boundary condition types include <code>Periodic</code>, <code>Flux</code>, <code>Value</code>, <code>Gradient</code>, and <code>NormalFlow</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/BoundaryConditions/boundary_condition.jl#L12-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.BoundaryCondition-Tuple{Any,Function}" href="#Oceananigans.BoundaryConditions.BoundaryCondition-Tuple{Any,Function}"><code>Oceananigans.BoundaryConditions.BoundaryCondition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">BoundaryCondition(BC, condition::Function; parameters=nothing, discrete_form=false)</code></pre><p>Construct a boundary condition of type <code>BC</code> with a function boundary <code>condition</code>.</p><p>By default, the function boudnary <code>condition</code> is assumed to have the &#39;continuous form&#39; <code>condition(ξ, η, t)</code>, where <code>t</code> is time and <code>ξ</code> and <code>η</code> vary along the boundary. In particular:</p><ul><li>On <code>x</code>-boundaries, <code>condition(y, z, t)</code>.</li><li>On <code>y</code>-boundaries, <code>condition(x, z, t)</code>.</li><li>On <code>z</code>-boundaries, <code>condition(x, y, t)</code>.</li></ul><p>If <code>parameters</code> is not <code>nothing</code>, then function boundary conditions have the form <code>func(ξ, η, t, parameters)</code>, where <code>ξ</code> and <code>η</code> are spatial coordinates varying along the boundary as explained above.</p><p>If <code>discrete_form=true</code>, the function <code>condition</code> is assumed to have the &quot;discrete form&quot;,</p><pre><code class="language-none">`condition(i, j, grid, clock, model_fields)`,</code></pre><p>where <code>i</code>, and <code>j</code> are indices that vary along the boundary. If <code>discrete_form=true</code> and <code>parameters</code> is not <code>nothing</code>, the function <code>condition</code> is called with</p><pre><code class="language-none">`condition(i, j, grid, clock, model_fields, parameters)`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/BoundaryConditions/boundary_condition.jl#L21-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.CoordinateBoundaryConditions" href="#Oceananigans.BoundaryConditions.CoordinateBoundaryConditions"><code>Oceananigans.BoundaryConditions.CoordinateBoundaryConditions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CoordinateBoundaryConditions(left, right)</code></pre><p>A set of two <code>BoundaryCondition</code>s to be applied along a coordinate x, y, or z.</p><p>The <code>left</code> boundary condition is applied on the negative or lower side of the coordinate while the <code>right</code> boundary condition is applied on the positive or higher side.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/BoundaryConditions/coordinate_boundary_conditions.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.FieldBoundaryConditions" href="#Oceananigans.BoundaryConditions.FieldBoundaryConditions"><code>Oceananigans.BoundaryConditions.FieldBoundaryConditions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FieldBoundaryConditions</code></pre><p>An alias for <code>NamedTuple{(:x, :y, :z)}</code> that represents a set of three <code>CoordinateBoundaryCondition</code>s applied to a field along x, y, and z.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/BoundaryConditions/field_boundary_conditions.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.FieldBoundaryConditions-Tuple{Any,Any,Any}" href="#Oceananigans.BoundaryConditions.FieldBoundaryConditions-Tuple{Any,Any,Any}"><code>Oceananigans.BoundaryConditions.FieldBoundaryConditions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">FieldBoundaryConditions(x, y, z)</code></pre><p>Construct a <code>FieldBoundaryConditions</code> using a <code>CoordinateBoundaryCondition</code> for each of the <code>x</code>, <code>y</code>, and <code>z</code> coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/BoundaryConditions/field_boundary_conditions.jl#L11-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.FieldBoundaryConditions-Tuple{Any,Any}" href="#Oceananigans.BoundaryConditions.FieldBoundaryConditions-Tuple{Any,Any}"><code>Oceananigans.BoundaryConditions.FieldBoundaryConditions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">FieldBoundaryConditions(grid, loc;   east = DefaultBoundaryCondition(topology(grid, 1), loc[1]),
                                     west = DefaultBoundaryCondition(topology(grid, 1], loc[1]),
                                    south = DefaultBoundaryCondition(topology(grid, 2), loc[2]),
                                    north = DefaultBoundaryCondition(topology(grid, 2), loc[2]),
                                   bottom = DefaultBoundaryCondition(topology(grid, 3), loc[3]),
                                      top = DefaultBoundaryCondition(topology(grid, 3), loc[3]))</code></pre><p>Construct <code>FieldBoundaryConditions</code> for a field with location <code>loc</code> (a 3-tuple of <code>Face</code> or <code>Center</code>) defined on <code>grid</code>.</p><p>Boundary conditions on <code>x</code>-, <code>y</code>-, and <code>z</code>-boundaries are specified via keyword arguments:</p><pre><code class="language-none">* `west` and `east` for the `-x` and `+x` boundary;
* `south` and `north` for the `-y` and `+y` boundary;
* `bottom` and `top` for the `-z` and `+z` boundary.</code></pre><p>Default boundary conditions depend on <code>topology(grid)</code> and <code>loc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/BoundaryConditions/field_boundary_conditions.jl#L58-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.TracerBoundaryConditions-Tuple{Any}" href="#Oceananigans.BoundaryConditions.TracerBoundaryConditions-Tuple{Any}"><code>Oceananigans.BoundaryConditions.TracerBoundaryConditions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">TracerBoundaryConditions(grid;   east = DefaultBoundaryCondition(topology(grid, 1), Center),
                                 west = DefaultBoundaryCondition(topology(grid, 1), Center),
                                south = DefaultBoundaryCondition(topology(grid, 2), Center),
                                north = DefaultBoundaryCondition(topology(grid, 2), Center),
                               bottom = DefaultBoundaryCondition(topology(grid, 3), Center),
                                  top = DefaultBoundaryCondition(topology(grid, 3), Center))</code></pre><p>Construct <code>FieldBoundaryConditions</code> for a tracer field on <code>grid</code>. Boundary conditions on <code>x</code>-, <code>y</code>-, and <code>z</code>-boundaries are specified via keyword arguments:</p><pre><code class="language-none">* `west` and `east` for the `-x` and `+x` boundary;
* `south` and `north` for the `-y` and `+y` boundary;
* `bottom` and `top` for the `-z` and `+z` boundary.</code></pre><p>Default boundary conditions depend on <code>topology(grid)</code>. See <code>DefaultBoundaryCondition</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/BoundaryConditions/field_boundary_conditions.jl#L161-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.UVelocityBoundaryConditions-Tuple{Any}" href="#Oceananigans.BoundaryConditions.UVelocityBoundaryConditions-Tuple{Any}"><code>Oceananigans.BoundaryConditions.UVelocityBoundaryConditions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">UVelocityBoundaryConditions(grid;   east = DefaultBoundaryCondition(topology(grid, 1), Face),
                                    west = DefaultBoundaryCondition(topology(grid, 1), Face),
                                   south = DefaultBoundaryCondition(topology(grid, 2), Center),
                                   north = DefaultBoundaryCondition(topology(grid, 2), Center),
                                  bottom = DefaultBoundaryCondition(topology(grid, 3), Center),
                                     top = DefaultBoundaryCondition(topology(grid, 3), Center))</code></pre><p>Construct <code>FieldBoundaryConditions</code> for the <code>u</code>-velocity field on <code>grid</code>. Boundary conditions on <code>x</code>-, <code>y</code>-, and <code>z</code>-boundaries are specified via keyword arguments:</p><pre><code class="language-none">* `west` and `east` for the `-x` and `+x` boundary;
* `south` and `north` for the `-y` and `+y` boundary;
* `bottom` and `top` for the `-z` and `+z` boundary.</code></pre><p>Default boundary conditions depend on <code>topology(grid)</code>. See <code>DefaultBoundaryCondition</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/BoundaryConditions/field_boundary_conditions.jl#L101-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.VVelocityBoundaryConditions-Tuple{Any}" href="#Oceananigans.BoundaryConditions.VVelocityBoundaryConditions-Tuple{Any}"><code>Oceananigans.BoundaryConditions.VVelocityBoundaryConditions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">VVelocityBoundaryConditions(grid;   east = DefaultBoundaryCondition(topology(grid, 1), Center),
                                    west = DefaultBoundaryCondition(topology(grid, 1), Center),
                                   south = DefaultBoundaryCondition(topology(grid, 2), Face),
                                   north = DefaultBoundaryCondition(topology(grid, 2), Face),
                                  bottom = DefaultBoundaryCondition(topology(grid, 3), Center),
                                     top = DefaultBoundaryCondition(topology(grid, 3), Center))</code></pre><p>Construct <code>FieldBoundaryConditions</code> for the <code>v</code>-velocity field on <code>grid</code>. Boundary conditions on <code>x</code>-, <code>y</code>-, and <code>z</code>-boundaries are specified via keyword arguments:</p><pre><code class="language-none">* `west` and `east` for the `-x` and `+x` boundary;
* `south` and `north` for the `-y` and `+y` boundary;
* `bottom` and `top` for the `-z` and `+z` boundary.</code></pre><p>Default boundary conditions depend on <code>topology(grid)</code>. See <code>DefaultBoundaryCondition</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/BoundaryConditions/field_boundary_conditions.jl#L121-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.WVelocityBoundaryConditions-Tuple{Any}" href="#Oceananigans.BoundaryConditions.WVelocityBoundaryConditions-Tuple{Any}"><code>Oceananigans.BoundaryConditions.WVelocityBoundaryConditions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">WVelocityBoundaryConditions(grid;   east = DefaultBoundaryCondition(topology(grid, 1), Center),
                                    west = DefaultBoundaryCondition(topology(grid, 1), Center),
                                   south = DefaultBoundaryCondition(topology(grid, 2), Center),
                                   north = DefaultBoundaryCondition(topology(grid, 2), Center),
                                  bottom = DefaultBoundaryCondition(topology(grid, 3), Face),
                                     top = DefaultBoundaryCondition(topology(grid, 3), Face))</code></pre><p>Construct <code>FieldBoundaryConditions</code> for the <code>w</code>-velocity field on <code>grid</code>. Boundary conditions on <code>x</code>-, <code>y</code>-, and <code>z</code>-boundaries are specified via keyword arguments:</p><pre><code class="language-none">* `west` and `east` for the `-x` and `+x` boundary;
* `south` and `north` for the `-y` and `+y` boundary;
* `bottom` and `top` for the `-z` and `+z` boundary.</code></pre><p>Default boundary conditions depend on <code>topology(grid)</code>. See <code>DefaultBoundaryCondition</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/BoundaryConditions/field_boundary_conditions.jl#L141-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.fill_halo_regions!-Tuple{AbstractArray,Any,Any,Any,Vararg{Any,N} where N}" href="#Oceananigans.BoundaryConditions.fill_halo_regions!-Tuple{AbstractArray,Any,Any,Any,Vararg{Any,N} where N}"><code>Oceananigans.BoundaryConditions.fill_halo_regions!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Fill halo regions in x, y, and z for a given field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/BoundaryConditions/fill_halo_regions.jl#L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.fill_halo_regions!-Tuple{Union{Tuple, NamedTuple},Any,Vararg{Any,N} where N}" href="#Oceananigans.BoundaryConditions.fill_halo_regions!-Tuple{Union{Tuple, NamedTuple},Any,Vararg{Any,N} where N}"><code>Oceananigans.BoundaryConditions.fill_halo_regions!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fill_halo_regions!(fields, arch)</code></pre><p>Fill halo regions for each field in the tuple <code>fields</code> according to their boundary conditions, possibly recursing into <code>fields</code> if it is a nested tuple-of-tuples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/BoundaryConditions/fill_halo_regions.jl#L7-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.apply_x_bcs!-Tuple{Any,Any,Any,Any,Vararg{Any,N} where N}" href="#Oceananigans.BoundaryConditions.apply_x_bcs!-Tuple{Any,Any,Any,Any,Vararg{Any,N} where N}"><code>Oceananigans.BoundaryConditions.apply_x_bcs!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">apply_x_bcs!(Gc, arch, grid, args...)</code></pre><p>Apply flux boundary conditions to a field <code>c</code> by adding the associated flux divergence to the source term <code>Gc</code> at the left and right.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/BoundaryConditions/apply_flux_bcs.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.apply_y_bcs!-Tuple{Any,Any,Any,Any,Vararg{Any,N} where N}" href="#Oceananigans.BoundaryConditions.apply_y_bcs!-Tuple{Any,Any,Any,Any,Vararg{Any,N} where N}"><code>Oceananigans.BoundaryConditions.apply_y_bcs!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">apply_y_bcs!(Gc, arch, grid, args...)</code></pre><p>Apply flux boundary conditions to a field <code>c</code> by adding the associated flux divergence to the source term <code>Gc</code> at the left and right.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/BoundaryConditions/apply_flux_bcs.jl#L18-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.apply_z_bcs!-Tuple{Any,Any,Any,Any,Vararg{Any,N} where N}" href="#Oceananigans.BoundaryConditions.apply_z_bcs!-Tuple{Any,Any,Any,Any,Vararg{Any,N} where N}"><code>Oceananigans.BoundaryConditions.apply_z_bcs!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">apply_z_bcs!(Gc, arch, grid, args...)</code></pre><p>Apply flux boundary conditions to a field <code>c</code> by adding the associated flux divergence to the source term <code>Gc</code> at the top and bottom.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/BoundaryConditions/apply_flux_bcs.jl#L28-L33">source</a></section></article><h2 id="Buoyancy"><a class="docs-heading-anchor" href="#Buoyancy">Buoyancy</a><a id="Buoyancy-1"></a><a class="docs-heading-anchor-permalink" href="#Buoyancy" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Buoyancy.SeawaterBuoyancy" href="#Oceananigans.Buoyancy.SeawaterBuoyancy"><code>Oceananigans.Buoyancy.SeawaterBuoyancy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SeawaterBuoyancy{FT, EOS, T, S} &lt;: AbstractBuoyancy{EOS}</code></pre><p>Buoyancy model for seawater. <code>T</code> and <code>S</code> are either <code>nothing</code> if both temperature and salinity are active, or of type <code>FT</code> if temperature or salinity are constant, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Buoyancy/seawater_buoyancy.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Buoyancy.SeawaterBuoyancy" href="#Oceananigans.Buoyancy.SeawaterBuoyancy"><code>Oceananigans.Buoyancy.SeawaterBuoyancy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SeawaterBuoyancy([FT=Float64;] gravitational_acceleration = g_Earth,
                              equation_of_state = LinearEquationOfState(FT), 
                              constant_temperature = false, constant_salinity = false)</code></pre><p>Returns parameters for a temperature- and salt-stratified seawater buoyancy model with a <code>gravitational_acceleration</code> constant (typically called &#39;g&#39;), and an <code>equation_of_state</code> that related temperature and salinity (or conservative temperature and absolute salinity) to density anomalies and buoyancy.</p><p><code>constant_temperature</code> indicates that buoyancy depends only on salinity. For a nonlinear  equation of state, <code>constant_temperature</code> is used as the temperature of the system. <code>true</code>. The same logic with the role of salinity and temperature reversed holds when <code>constant_salinity</code> is provided.</p><p>For a linear equation of state, the values of <code>constant_temperature</code> or <code>constant_salinity</code> are irrelevant; in this case, <code>constant_temperature=true</code> (and similar for <code>constant_salinity</code>) is valid input.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Buoyancy/seawater_buoyancy.jl#L19-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Buoyancy.∂x_b-Tuple{Any,Any,Any,Any,SeawaterBuoyancy,Any}" href="#Oceananigans.Buoyancy.∂x_b-Tuple{Any,Any,Any,Any,SeawaterBuoyancy,Any}"><code>Oceananigans.Buoyancy.∂x_b</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∂x_b(i, j, k, grid, b::SeawaterBuoyancy, C)</code></pre><p>Returns the x-derivative of buoyancy for temperature and salt-stratified water,</p><p class="math-container">\[∂_x b = g ( α ∂_x Θ - β ∂_x sᴬ ) ,\]</p><p>where <code>g</code> is gravitational acceleration, <code>α</code> is the thermal expansion coefficient, <code>β</code> is the haline contraction coefficient, <code>Θ</code> is conservative temperature, and <code>sᴬ</code> is absolute salinity.</p><p>Note: In Oceananigans, <code>model.tracers.T</code> is conservative temperature and <code>model.tracers.S</code> is absolute salinity.</p><p>Note that <code>∂x_Θ</code>, <code>∂x_sᴬ</code>, <code>α</code>, and <code>β</code> are all evaluated at cell interfaces in <code>x</code> and cell centers in <code>y</code> and <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Buoyancy/seawater_buoyancy.jl#L61-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Buoyancy.∂y_b-Tuple{Any,Any,Any,Any,SeawaterBuoyancy,Any}" href="#Oceananigans.Buoyancy.∂y_b-Tuple{Any,Any,Any,Any,SeawaterBuoyancy,Any}"><code>Oceananigans.Buoyancy.∂y_b</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∂y_b(i, j, k, grid, b::SeawaterBuoyancy, C)</code></pre><p>Returns the y-derivative of buoyancy for temperature and salt-stratified water,</p><p class="math-container">\[∂_y b = g ( α ∂_y Θ - β ∂_y sᴬ ) ,\]</p><p>where <code>g</code> is gravitational acceleration, <code>α</code> is the thermal expansion coefficient, <code>β</code> is the haline contraction coefficient, <code>Θ</code> is conservative temperature, and <code>sᴬ</code> is absolute salinity.</p><p>Note: In Oceananigans, <code>model.tracers.T</code> is conservative temperature and <code>model.tracers.S</code> is absolute salinity.</p><p>Note that <code>∂y_Θ</code>, <code>∂y_sᴬ</code>, <code>α</code>, and <code>β</code> are all evaluated at cell interfaces in <code>y</code> and cell centers in <code>x</code> and <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Buoyancy/seawater_buoyancy.jl#L87-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Buoyancy.∂z_b-Tuple{Any,Any,Any,Any,SeawaterBuoyancy,Any}" href="#Oceananigans.Buoyancy.∂z_b-Tuple{Any,Any,Any,Any,SeawaterBuoyancy,Any}"><code>Oceananigans.Buoyancy.∂z_b</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∂z_b(i, j, k, grid, b::SeawaterBuoyancy, C)</code></pre><p>Returns the vertical derivative of buoyancy for temperature and salt-stratified water,</p><p class="math-container">\[∂_z b = N^2 = g ( α ∂_z Θ - β ∂_z sᴬ ) ,\]</p><p>where <code>g</code> is gravitational acceleration, <code>α</code> is the thermal expansion coefficient, <code>β</code> is the haline contraction coefficient, <code>Θ</code> is conservative temperature, and <code>sᴬ</code> is absolute salinity.</p><p>Note: In Oceananigans, <code>model.tracers.T</code> is conservative temperature and <code>model.tracers.S</code> is absolute salinity.</p><p>Note that <code>∂z_Θ</code>, <code>∂z_sᴬ</code>, <code>α</code>, and <code>β</code> are all evaluated at cell interfaces in <code>z</code> and cell centers in <code>x</code> and <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Buoyancy/seawater_buoyancy.jl#L113-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Buoyancy.BuoyancyTracer" href="#Oceananigans.Buoyancy.BuoyancyTracer"><code>Oceananigans.Buoyancy.BuoyancyTracer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BuoyancyTracer &lt;: AbstractBuoyancy{Nothing}</code></pre><p>Type indicating that the tracer <code>b</code> represents buoyancy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Buoyancy/Buoyancy.jl#L52-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Buoyancy.LinearEquationOfState" href="#Oceananigans.Buoyancy.LinearEquationOfState"><code>Oceananigans.Buoyancy.LinearEquationOfState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LinearEquationOfState{FT} &lt;: AbstractEquationOfState</code></pre><p>Linear equation of state for seawater.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Buoyancy/linear_equation_of_state.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Buoyancy.LinearEquationOfState" href="#Oceananigans.Buoyancy.LinearEquationOfState"><code>Oceananigans.Buoyancy.LinearEquationOfState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LinearEquationOfState([FT=Float64;] α=1.67e-4, β=7.80e-4)</code></pre><p>Returns parameters for a linear equation of state for seawater with thermal expansion coefficient <code>α</code> [K⁻¹] and haline contraction coefficient <code>β</code> [ppt⁻¹]. The buoyancy perturbation associated with a linear equation of state is</p><p class="math-container">\[    b = g (α T - β S)\]</p><p>Default constants are taken from Table 1.2 (page 33) of Vallis, &quot;Atmospheric and Oceanic Fluid Dynamics: Fundamentals and Large-Scale Circulation&quot; (2ed, 2017).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Buoyancy/linear_equation_of_state.jl#L11-L24">source</a></section></article><h2 id="Coriolis"><a class="docs-heading-anchor" href="#Coriolis">Coriolis</a><a id="Coriolis-1"></a><a class="docs-heading-anchor-permalink" href="#Coriolis" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.FPlane" href="#Oceananigans.Coriolis.FPlane"><code>Oceananigans.Coriolis.FPlane</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FPlane{FT} &lt;: AbstractRotation</code></pre><p>A parameter object for constant rotation around a vertical axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Coriolis/f_plane.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.FPlane" href="#Oceananigans.Coriolis.FPlane"><code>Oceananigans.Coriolis.FPlane</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FPlane([FT=Float64;] f=nothing, rotation_rate=Ω_Earth, latitude=nothing)</code></pre><p>Returns a parameter object for constant rotation at the angular frequency <code>f/2</code>, and therefore with background vorticity <code>f</code>, around a vertical axis. If <code>f</code> is not specified, it is calculated from <code>rotation_rate</code> and <code>latitude</code> according to the relation `f = 2<em>rotation_rate</em>sind(latitude).</p><p>By default, <code>rotation_rate</code> is assumed to be Earth&#39;s.</p><p>Also called <code>FPlane</code>, after the &quot;f-plane&quot; approximation for the local effect of a planet&#39;s rotation in a planar coordinate system tangent to the planet&#39;s surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Coriolis/f_plane.jl#L10-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.BetaPlane" href="#Oceananigans.Coriolis.BetaPlane"><code>Oceananigans.Coriolis.BetaPlane</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BetaPlane{T} &lt;: AbstractRotation</code></pre><p>A parameter object for meridionally increasing Coriolis parameter (<code>f = f₀ + βy</code>) that accounts for the variation of the locally vertical component of the rotation vector with latitude.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Coriolis/beta_plane.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.BetaPlane" href="#Oceananigans.Coriolis.BetaPlane"><code>Oceananigans.Coriolis.BetaPlane</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BetaPlane([T=Float64;] f₀=nothing, β=nothing,
                       rotation_rate=Ω_Earth, latitude=nothing, radius=R_Earth)</code></pre><p>The user may specify both <code>f₀</code> and <code>β</code>, or the three parameters <code>rotation_rate</code>, <code>latitude</code>, and <code>radius</code> that specify the rotation rate and radius of a planet, and the central latitude (where y = 0) at which the <code>β</code>-plane approximation is to be made.</p><p>By default, the <code>rotation_rate</code> and planet <code>radius</code> is assumed to be Earth&#39;s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Coriolis/beta_plane.jl#L13-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.NonTraditionalFPlane" href="#Oceananigans.Coriolis.NonTraditionalFPlane"><code>Oceananigans.Coriolis.NonTraditionalFPlane</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NonTraditionalFPlane{FT} &lt;: AbstractRotation</code></pre><p>A Coriolis implementation that accounts for both the locally vertical and the locally horizontal components of the rotation vector. Traditionally (see <a href="#Oceananigans.Coriolis.FPlane"><code>FPlane</code></a>) only the locally vertical component is accounted for.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Coriolis/non_traditional_f_plane.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.NonTraditionalFPlane" href="#Oceananigans.Coriolis.NonTraditionalFPlane"><code>Oceananigans.Coriolis.NonTraditionalFPlane</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NonTraditionalFPlane([FT=Float64;] fz=nothing, fy=nothing,
                                   rotation_rate=Ω_Earth, latitude=nothing)</code></pre><p>Returns a parameter object for constant rotation about an axis in the <code>y-z</code> plane with <code>y</code>- and <code>z</code>-components <code>fy/2</code> and <code>fz/2</code>, and the background vorticity is <code>(0, fy, fz)</code>.</p><p>In oceanography <code>fz</code> and <code>fy</code> represent the components of planetary voriticity which are perpendicular and parallel to the ocean surface in a domain in which <code>x, y, z</code> correspond to the directions east, north, and up.</p><p>If <code>fz</code> and <code>fy</code> are not specified, they are calculated from <code>rotation_rate</code> and <code>latitude</code> according to the relations <code>fz = 2*rotation_rate*sind(latitude)</code> and <code>fy = 2*rotation_rate*cosd(latitude)</code>, respectively. By default, <code>rotation_rate</code> is assumed to be Earth&#39;s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Coriolis/non_traditional_f_plane.jl#L13-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.NonTraditionalBetaPlane" href="#Oceananigans.Coriolis.NonTraditionalBetaPlane"><code>Oceananigans.Coriolis.NonTraditionalBetaPlane</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NonTraditionalBetaPlane{FT} &lt;: AbstractRotation</code></pre><p>A Coriolis implementation that accounts for the latitudinal variation of both the locally vertical and the locally horizontal components of the rotation vector. The &quot;traditional&quot; approximation in ocean models accounts for only the locally vertical component of the rotation vector (see <a href="#Oceananigans.Coriolis.BetaPlane"><code>BetaPlane</code></a>).</p><p>This implementation is based off of section 5 of Dellar (2011). It conserve energy, angular momentum, and potential vorticity.</p><p><strong>References</strong></p><p>Dellar, P. (2011). Variations on a beta-plane: Derivation of non-traditional     beta-plane equations from Hamilton&#39;s principle on a sphere. Journal of     Fluid Mechanics, 674, 174-195. doi:10.1017/S0022112010006464</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Coriolis/non_traditional_beta_plane.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.NonTraditionalBetaPlane" href="#Oceananigans.Coriolis.NonTraditionalBetaPlane"><code>Oceananigans.Coriolis.NonTraditionalBetaPlane</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NonTraditionalBetaPlane(FT=Float64;
    fz=nothing, fy=nothing, β=nothing, γ=nothing,
    rotation_rate=Ω_Earth, latitude=nothing, radius=R_Earth)</code></pre><p>The user may directly specify <code>fz</code>, <code>fy</code>, <code>β</code>, <code>γ</code>, and <code>radius</code> or the three parameters <code>rotation_rate</code>, <code>latitude</code>, and <code>radius</code> that specify the rotation rate and radius of a planet, and the central latitude (where y = 0) at which the non-traditional <code>β</code>-plane approximation is to be made.</p><p>By default, the <code>rotation_rate</code> and planet <code>radius</code> is assumed to be Earth&#39;s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Coriolis/non_traditional_beta_plane.jl#L26-L37">source</a></section></article><h2 id="Diagnostics"><a class="docs-heading-anchor" href="#Diagnostics">Diagnostics</a><a id="Diagnostics-1"></a><a class="docs-heading-anchor-permalink" href="#Diagnostics" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.CFL" href="#Oceananigans.Diagnostics.CFL"><code>Oceananigans.Diagnostics.CFL</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CFL{D, S}</code></pre><p>An object for computing the Courant-Freidrichs-Lewy (CFL) number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Diagnostics/cfl.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.CFL-Tuple{Any}" href="#Oceananigans.Diagnostics.CFL-Tuple{Any}"><code>Oceananigans.Diagnostics.CFL</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CFL(Δt [, timescale=Oceananigans.cell_advection_timescale])</code></pre><p>Returns an object for computing the Courant-Freidrichs-Lewy (CFL) number associated with time step or <code>TimeStepWizard</code> <code>Δt</code> and <code>timescale</code>.</p><p>See also <code>AdvectiveCFL</code> and <code>DiffusiveCFL</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Diagnostics/cfl.jl#L14-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.AdvectiveCFL-Tuple{Any}" href="#Oceananigans.Diagnostics.AdvectiveCFL-Tuple{Any}"><code>Oceananigans.Diagnostics.AdvectiveCFL</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">AdvectiveCFL(Δt)</code></pre><p>Returns an object for computing the Courant-Freidrichs-Lewy (CFL) number associated with time step or <code>TimeStepWizard</code> <code>Δt</code> and the time scale for advection across a cell.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; model = IncompressibleModel(grid=RegularCartesianGrid(size=(16, 16, 16), length=(8, 8, 8)));

julia&gt; cfl = AdvectiveCFL(1.0);

julia&gt; data(model.velocities.u) .= π;

julia&gt; cfl(model)
6.283185307179586</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Diagnostics/cfl.jl#L26-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.DiffusiveCFL-Tuple{Any}" href="#Oceananigans.Diagnostics.DiffusiveCFL-Tuple{Any}"><code>Oceananigans.Diagnostics.DiffusiveCFL</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">DiffusiveCFL(Δt)</code></pre><p>Returns an object for computing the diffusive Courant-Freidrichs-Lewy (CFL) number associated with time step or <code>TimeStepWizard</code> <code>Δt</code> and the time scale for diffusion across a cell associated with <code>model.closure</code>.</p><p>The maximum diffusive CFL number among viscosity and all tracer diffusivities is returned.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; model = IncompressibleModel(grid=RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1)));

julia&gt; dcfl = DiffusiveCFL(0.1);

julia&gt; dcfl(model)
2.688e-5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Diagnostics/cfl.jl#L48-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.FieldMaximum" href="#Oceananigans.Diagnostics.FieldMaximum"><code>Oceananigans.Diagnostics.FieldMaximum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FieldMaximum(mapping, field)</code></pre><p>An object for calculating the maximum of a <code>mapping</code> function applied element-wise to <code>field</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; model = IncompressibleModel(grid=RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1)));

julia&gt; max_abs_u = FieldMaximum(abs, model.velocities.u);

julia&gt; max_w² = FieldMaximum(x-&gt;x^2, model.velocities.w);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Diagnostics/field_maximum.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.NaNChecker" href="#Oceananigans.Diagnostics.NaNChecker"><code>Oceananigans.Diagnostics.NaNChecker</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NaNChecker(; schedule, fields)</code></pre><p>Returns a <code>NaNChecker</code> that checks for a <code>NaN</code> anywhere in <code>fields</code> when <code>schedule</code> actuates. <code>fields</code> should be a named tuple. The simulation is aborted if a <code>NaN</code> is found.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Diagnostics/nan_checker.jl#L6-L11">source</a></section></article><h2 id="Fields"><a class="docs-heading-anchor" href="#Fields">Fields</a><a id="Fields-1"></a><a class="docs-heading-anchor-permalink" href="#Fields" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.Field" href="#Oceananigans.Fields.Field"><code>Oceananigans.Fields.Field</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Field{X, Y, Z, A, G, B} &lt;: AbstractField{X, Y, Z, A, G}</code></pre><p>A field defined at the location (<code>X</code>, <code>Y</code>, <code>Z</code>), each of which can be either <code>Center</code> or <code>Face</code>, and with data stored in a container of type <code>A</code> (typically an array). The field is defined on a grid <code>G</code> and has field boundary conditions <code>B</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Fields/field.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.Field" href="#Oceananigans.Fields.Field"><code>Oceananigans.Fields.Field</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Field(X, Y, Z, arch, grid, [  bcs = FieldBoundaryConditions(grid, (X, Y, Z)),
                             data = new_data(arch, grid, (X, Y, Z)) ] )</code></pre><p>Construct a <code>Field</code> on <code>grid</code> with <code>data</code> on architecture <code>arch</code> with boundary conditions <code>bcs</code>. Each of <code>(X, Y, Z)</code> is either <code>Center</code> or <code>Face</code> and determines the field&#39;s location in <code>(x, y, z)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using Oceananigans, Oceananigans.Grids

julia&gt; ω = Field(Face, Face, Center, CPU(), RegularCartesianGrid(size=(1, 1, 1), extent=(1, 1, 1)))
Field located at (Face, Face, Center)
├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (3, 3, 3)
├── grid: RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1)
└── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, north=Periodic), z=(bottom=ZeroFlux, top=ZeroFlux)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Fields/field.jl#L21-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.Field-Tuple{Tuple,Vararg{Any,N} where N}" href="#Oceananigans.Fields.Field-Tuple{Tuple,Vararg{Any,N} where N}"><code>Oceananigans.Fields.Field</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Field(L::Tuple, arch, grid, data, bcs)</code></pre><p>Construct a <code>Field</code> at the location defined by the 3-tuple <code>L</code>, whose elements are <code>Center</code> or <code>Face</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Fields/field.jl#L57-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.CenterField" href="#Oceananigans.Fields.CenterField"><code>Oceananigans.Fields.CenterField</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">CenterField([ FT=eltype(grid) ], arch::AbstractArchitecture, grid,
          [  bcs = TracerBoundaryConditions(grid),
            data = new_data(FT, arch, grid, (Center, Center, Center) ] )</code></pre><p>Return a <code>Field{Center, Center, Center}</code> on architecture <code>arch</code> and <code>grid</code> containing <code>data</code> with field boundary conditions <code>bcs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Fields/field.jl#L69-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.XFaceField" href="#Oceananigans.Fields.XFaceField"><code>Oceananigans.Fields.XFaceField</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">XFaceField([ FT=eltype(grid) ], arch::AbstractArchitecture, grid,
           [  bcs = UVelocityBoundaryConditions(grid),
             data = new_data(FT, arch, grid, (Face, Center, Center) ] )</code></pre><p>Return a <code>Field{Face, Center, Center}</code> on architecture <code>arch</code> and <code>grid</code> containing <code>data</code> with field boundary conditions <code>bcs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Fields/field.jl#L84-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.YFaceField" href="#Oceananigans.Fields.YFaceField"><code>Oceananigans.Fields.YFaceField</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">YFaceField([ FT=eltype(grid) ], arch::AbstractArchitecture, grid,
           [  bcs = VVelocityBoundaryConditions(grid),
             data = new_data(FT, arch, grid, (Center, Face, Center)) ] )</code></pre><p>Return a <code>Field{Center, Face, Center}</code> on architecture <code>arch</code> and <code>grid</code> containing <code>data</code> with field boundary conditions <code>bcs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Fields/field.jl#L99-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.ZFaceField" href="#Oceananigans.Fields.ZFaceField"><code>Oceananigans.Fields.ZFaceField</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ZFaceField([ FT=eltype(grid) ], arch::AbstractArchitecture, grid,
           [  bcs = WVelocityBoundaryConditions(grid),
             data = new_data(FT, arch, grid, (Center, Center, Face)) ] )</code></pre><p>Return a <code>Field{Center, Center, Face}</code> on architecture <code>arch</code> and <code>grid</code> containing <code>data</code> with field boundary conditions <code>bcs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Fields/field.jl#L114-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.set!-Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A&lt;:(OffsetArrays.OffsetArray{T,D,var&quot;#s64&quot;} where var&quot;#s64&quot;&lt;:Array where D where T) where Z where Y where X,Array}" href="#Oceananigans.Fields.set!-Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A&lt;:(OffsetArrays.OffsetArray{T,D,var&quot;#s64&quot;} where var&quot;#s64&quot;&lt;:Array where D where T) where Z where Y where X,Array}"><code>Oceananigans.Fields.set!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Set the CPU field <code>u</code> to the array <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Fields/set!.jl#L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.set!-Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A&lt;:(OffsetArrays.OffsetArray{T,D,var&quot;#s64&quot;} where var&quot;#s64&quot;&lt;:Array where D where T) where Z where Y where X,Function}" href="#Oceananigans.Fields.set!-Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A&lt;:(OffsetArrays.OffsetArray{T,D,var&quot;#s64&quot;} where var&quot;#s64&quot;&lt;:Array where D where T) where Z where Y where X,Function}"><code>Oceananigans.Fields.set!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Set the CPU field <code>u</code> data to the function <code>f(x, y, z)</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Fields/set!.jl#L43">source</a></section></article><h2 id="Forcings"><a class="docs-heading-anchor" href="#Forcings">Forcings</a><a id="Forcings-1"></a><a class="docs-heading-anchor-permalink" href="#Forcings" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.ContinuousForcing" href="#Oceananigans.Forcings.ContinuousForcing"><code>Oceananigans.Forcings.ContinuousForcing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ContinuousForcing{X, Y, Z, P, F, D, I}</code></pre><p>A callable object that implements a &quot;continuous form&quot; forcing function on a field at the location <code>X, Y, Z</code> with optional parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Forcings/continuous_forcing.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.ContinuousForcing-Tuple{Any}" href="#Oceananigans.Forcings.ContinuousForcing-Tuple{Any}"><code>Oceananigans.Forcings.ContinuousForcing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ContinuousForcing(func; parameters=nothing, field_dependencies=())</code></pre><p>Construct a &quot;continuous form&quot; forcing with optional <code>parameters</code> and optional <code>field_dependencies</code> on other fields in a model.</p><p>If neither <code>parameters</code> nor <code>field_dependencies</code> are provided, then <code>func</code> must be callable with the signature</p><pre><code class="language-none">`func(x, y, z, t)`</code></pre><p>where <code>x, y, z</code> are the east-west, north-south, and vertical spatial coordinates, and <code>t</code> is time.</p><p>If <code>field_dependencies</code> are provided, the signature of <code>func</code> must include them. For example, if <code>field_dependencies=(:u, :S)</code> (and <code>parameters</code> are <em>not</em> provided), then <code>func</code> must be callable with the signature</p><pre><code class="language-none">`func(x, y, z, t, u, S)`</code></pre><p>where <code>u</code> is assumed to be the <code>u</code>-velocity component, and <code>S</code> is a tracer. Note that any field which does not have the name <code>u</code>, <code>v</code>, or <code>w</code> is assumed to be a tracer and must be present in <code>model.tracers</code>.</p><p>If <code>parameters</code> are provided, then the <em>last</em> argument to <code>func</code> must be <code>parameters</code>. For example, if <code>func</code> has no <code>field_dependencies</code> but does depend on <code>parameters</code>, then it must be callable with the signature</p><pre><code class="language-none">`func(x, y, z, t, parameters)`</code></pre><p>With <code>field_dependencies=(:u, :v, :w, :c)</code> and <code>parameters</code>, then <code>func</code> must be callable with the signature</p><pre><code class="language-none">`func(x, y, z, t, u, v, w, c, parameters)`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Forcings/continuous_forcing.jl#L48-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.DiscreteForcing" href="#Oceananigans.Forcings.DiscreteForcing"><code>Oceananigans.Forcings.DiscreteForcing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct DiscreteForcing{P, F}</code></pre><p>Wrapper for &quot;discrete form&quot; forcing functions with optional <code>parameters</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Forcings/discrete_forcing.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.DiscreteForcing-Tuple{Any}" href="#Oceananigans.Forcings.DiscreteForcing-Tuple{Any}"><code>Oceananigans.Forcings.DiscreteForcing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">DiscreteForcing(func; parameters=nothing)</code></pre><p>Construct a &quot;discrete form&quot; forcing function with optional parameters. The forcing function is applied at grid point <code>i, j, k</code>.</p><p>When <code>parameters</code> are not specified, <code>func</code> must be callable with the signature</p><pre><code class="language-none">`func(i, j, k, grid, clock, model_fields)`</code></pre><p>where <code>grid</code> is <code>model.grid</code>, <code>clock.time</code> is the current simulation time and <code>clock.iteration</code> is the current model iteration, and <code>model_fields</code> is a <code>NamedTuple</code> with <code>u, v, w</code> and the fields in <code>model.tracers</code>.</p><p><em>Note</em> that the index <code>end</code> does <em>not</em> access the final physical grid point of a model field in any direction. The final grid point must be explicitly specified, as in <code>model_fields.u[i, j, grid.Nz]</code>.</p><p>When <code>parameters</code> <em>is</em> specified, <code>func</code> must be callable with the signature.</p><pre><code class="language-none">`func(i, j, k, grid, clock, model_fields, parameters)`</code></pre><p><code>parameters</code> is arbitrary in principle, however GPU compilation can place constraints on <code>typeof(parameters)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Forcings/discrete_forcing.jl#L14-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.Forcing-Tuple{Any}" href="#Oceananigans.Forcings.Forcing-Tuple{Any}"><code>Oceananigans.Forcings.Forcing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Forcing(func; parameters=nothing, field_dependencies=(), discrete_form=false)</code></pre><p>Returns a forcing function added to the tendency of an Oceananigans model field.</p><p>If <code>discrete_form=false</code> (the default), and neither <code>parameters</code> nor <code>field_dependencies</code> are provided, then <code>func</code> must be callable with the signature</p><pre><code class="language-none">`func(x, y, z, t)`</code></pre><p>where <code>x, y, z</code> are the east-west, north-south, and vertical spatial coordinates, and <code>t</code> is time. Note that this form is also default in the constructor for <code>IncompressibleModel</code>, so that <code>Forcing</code> is not needed.</p><p>If <code>discrete_form=false</code> (the default), and <code>field_dependencies</code> are provided, the signature of <code>func</code> must include them. For example, if <code>field_dependencies=(:u, :S)</code> (and <code>parameters</code> are <em>not</em> provided), then <code>func</code> must be callable with the signature</p><pre><code class="language-none">`func(x, y, z, t, u, S)`</code></pre><p>where <code>u</code> is assumed to be the <code>u</code>-velocity component, and <code>S</code> is a tracer. Note that any field which does not have the name <code>u</code>, <code>v</code>, or <code>w</code> is assumed to be a tracer and must be present in <code>model.tracers</code>.</p><p>If <code>discrete_form=false</code> (the default) and <code>parameters</code> are provided, then the <em>last</em> argument to <code>func</code> must be <code>parameters</code>. For example, if <code>func</code> has no <code>field_dependencies</code> but does depend on <code>parameters</code>, then it must be callable with the signature</p><pre><code class="language-none">`func(x, y, z, t, parameters)`</code></pre><p>The object <code>parameters</code> is arbitrary in principle, however GPU compilation can place constraints on <code>typeof(parameters)</code>.</p><p>With <code>field_dependencies=(:u, :v, :w, :c)</code> and <code>parameters</code>, then <code>func</code> must be callable with the signature</p><pre><code class="language-none">`func(x, y, z, t, u, v, w, c, parameters)`</code></pre><p>If <code>discrete_form=true</code> then <code>func</code> must be callable with the &quot;discrete form&quot;</p><pre><code class="language-none">`func(i, j, k, grid, clock, model_fields)`</code></pre><p>where <code>i, j, k</code> is the grid point at which the forcing is applied, <code>grid</code> is <code>model.grid</code>, <code>clock.time</code> is the current simulation time and <code>clock.iteration</code> is the current model iteration, and <code>model_fields</code> is a <code>NamedTuple</code> with <code>u, v, w</code>, the fields in <code>model.tracers</code>, and the fields in <code>model.diffusivities</code>, each of which is an <code>OffsetArray</code>s (or <code>NamedTuple</code>s of <code>OffsetArray</code>s depending on the turbulence closure) of field data.</p><p>When <code>discrete_form=true</code> and <code>parameters</code> <em>is</em> specified, <code>func</code> must be callable with the signature</p><pre><code class="language-none">`func(i, j, k, grid, clock, model_fields, parameters)`</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia">using Oceananigans

# Parameterized forcing
parameterized_func(x, y, z, t, p) = p.μ * exp(z / p.λ) * cos(p.ω * t)

v_forcing = Forcing(parameterized_func, parameters = (μ=42, λ=0.1, ω=π))

# output
ContinuousForcing{NamedTuple{(:μ, :λ, :ω),Tuple{Int64,Float64,Irrational{:π}}}}
├── func: parameterized_func
├── parameters: (μ = 42, λ = 0.1, ω = π)
└── field dependencies: ()</code></pre><p>Note that because forcing locations are regularized within the <code>IncompressibleModel</code> constructor:</p><pre><code class="language-julia">grid = RegularCartesianGrid(size=(1, 1, 1), extent=(1, 1, 1))
model = IncompressibleModel(grid=grid, forcing=(v=v_forcing,))

model.forcing.v

# output
ContinuousForcing{NamedTuple{(:μ, :λ, :ω),Tuple{Int64,Float64,Irrational{:π}}}} at (Center, Face, Center)
├── func: parameterized_func
├── parameters: (μ = 42, λ = 0.1, ω = π)
└── field dependencies: ()</code></pre><p>After passing through the constructor for <code>IncompressibleModel</code>, the <code>v</code>-forcing location information is available and set to <code>Center, Face, Center</code>.</p><pre><code class="language-julia"># Field-dependent forcing
growth_in_sunlight(x, y, z, t, P) = exp(z) * P

plankton_forcing = Forcing(growth_in_sunlight, field_dependencies=:P)

# output
ContinuousForcing{Nothing}
├── func: growth_in_sunlight
├── parameters: nothing
└── field dependencies: (:P,)</code></pre><pre><code class="language-julia"># Parameterized, field-dependent forcing
tracer_relaxation(x, y, z, t, c, p) = p.μ * exp((z + p.H) / p.λ) * (p.dCdz * z - c) 

c_forcing = Forcing(tracer_relaxation,
                    field_dependencies = :c,
                            parameters = (μ=1/60, λ=10, H=1000, dCdz=1))

# output
ContinuousForcing{NamedTuple{(:μ, :λ, :H, :dCdz),Tuple{Float64,Int64,Int64,Int64}}}
├── func: tracer_relaxation
├── parameters: (μ = 0.016666666666666666, λ = 10, H = 1000, dCdz = 1)
└── field dependencies: (:c,)</code></pre><pre><code class="language-julia"># Unparameterized discrete-form forcing function
filtered_relaxation(i, j, k, grid, clock, model_fields) =
    @inbounds - (model_fields.c[i-1, j, k] + model_fields.c[i, j, k] + model_fields.c[i+1, j, k]) / 3

filtered_forcing = Forcing(filtered_relaxation, discrete_form=true)

# output
DiscreteForcing{Nothing}
├── func: filtered_relaxation
└── parameters: nothing</code></pre><pre><code class="language-julia"># Discrete-form forcing function with parameters
masked_damping(i, j, k, grid, clock, model_fields, parameters) = 
    @inbounds - parameters.μ * exp(grid.zC[k] / parameters.λ) * model_fields.u[i, j, k]

masked_damping_forcing = Forcing(masked_damping, parameters=(μ=42, λ=π), discrete_form=true)

# output
DiscreteForcing{NamedTuple{(:μ, :λ),Tuple{Int64,Irrational{:π}}}}
├── func: masked_damping
└── parameters: (μ = 42, λ = π)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Forcings/forcing.jl#L1-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.GaussianMask" href="#Oceananigans.Forcings.GaussianMask"><code>Oceananigans.Forcings.GaussianMask</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GaussianMask{D}(center, width)</code></pre><p>Callable object that returns a Gaussian masking function centered on <code>center</code>, with <code>width</code>, and varying along direction <code>D</code>.</p><p><strong>Examples</strong></p><ul><li>Create a Gaussian mask centered on <code>z=0</code> with width <code>1</code> meter.</li></ul><pre><code class="language-julia">julia&gt; mask = GaussianMask{:z}(center=0, width=1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Forcings/relaxation.jl#L101-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.LinearTarget" href="#Oceananigans.Forcings.LinearTarget"><code>Oceananigans.Forcings.LinearTarget</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LinearTarget{D}(intercept, gradient)</code></pre><p>Callable object that returns a Linear target function with <code>intercept</code> and <code>gradient</code>, and varying along direction <code>D</code>.</p><p><strong>Examples</strong></p><ul><li>Create a linear target function varying in <code>z</code>, equal to <code>0</code> at <code>z=0</code> and with gradient 10⁻⁶:</li></ul><pre><code class="language-julia">julia&gt; target = LinearTarget{:z}(intercept=0, gradient=1e-6)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Forcings/relaxation.jl#L141-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.Relaxation" href="#Oceananigans.Forcings.Relaxation"><code>Oceananigans.Forcings.Relaxation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Relaxation{R, M, T}</code></pre><p>Callable object for restoring fields to a <code>target</code> at some <code>rate</code> and within a <code>mask</code>ed region in <code>x, y, z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Forcings/relaxation.jl#L12-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.Relaxation-Tuple{}" href="#Oceananigans.Forcings.Relaxation-Tuple{}"><code>Oceananigans.Forcings.Relaxation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Relaxation(; rate, mask=onefunction, target=zerofunction)</code></pre><p>Returns a <code>Forcing</code> that restores a field to <code>target(x, y, z, t)</code> at the specified <code>rate</code>, in the region <code>mask(x, y, z)</code>.</p><p>The functions <code>onefunction</code> and <code>zerofunction</code> always return 1 and 0, respectively. Thus the default <code>mask</code> leaves the whole domain uncovered, and the default <code>target</code> is zero.</p><p><strong>Example</strong></p><ul><li>Restore a field to zero on a timescale of &quot;3600&quot; (equal to one hour if the time units of the simulation are seconds).</li></ul><pre><code class="language-julia">using Oceananigans

damping = Relaxation(rate = 1/3600)

# output
Relaxation{Float64, typeof(Oceananigans.Forcings.onefunction), typeof(Oceananigans.Forcings.zerofunction)}
├── rate: 0.0002777777777777778
├── mask: 1
└── target: 0</code></pre><ul><li>Restore a field to a linear z-gradient within the bottom 1/4 of a domain on a timescale of &quot;60&quot; (equal to one minute if the time units of the simulation are seconds).</li></ul><pre><code class="language-julia">dTdz = 0.001 # ⁰C m⁻¹, temperature gradient

T₀ = 20 # ⁰C, surface temperature at z=0

Lz = 100 # m, depth of domain

bottom_sponge_layer = Relaxation(; rate = 1/60,
                                   target = LinearTarget{:z}(intercept=T₀, gradient=dTdz),
                                   mask = GaussianMask{:z}(center=-Lz, width=Lz/4))

# output
Relaxation{Float64, GaussianMask{:z,Float64}, LinearTarget{:z,Float64}}
├── rate: 0.016666666666666666
├── mask: exp(-(z + 100.0)^2 / (2 * 25.0^2))
└── target: 20.0 + 0.001 * z</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Forcings/relaxation.jl#L24-L72">source</a></section></article><h2 id="Grids"><a class="docs-heading-anchor" href="#Grids">Grids</a><a id="Grids-1"></a><a class="docs-heading-anchor-permalink" href="#Grids" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.AbstractGrid" href="#Oceananigans.Grids.AbstractGrid"><code>Oceananigans.Grids.AbstractGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractGrid{FT, TX, TY, TZ}</code></pre><p>Abstract supertype for grids with elements of type <code>FT</code> and topology <code>{TX, TY, TZ}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Grids/Grids.jl#L67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.AbstractTopology" href="#Oceananigans.Grids.AbstractTopology"><code>Oceananigans.Grids.AbstractTopology</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractTopology</code></pre><p>Abstract supertype for grid topologies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Grids/Grids.jl#L37-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.Bounded" href="#Oceananigans.Grids.Bounded"><code>Oceananigans.Grids.Bounded</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Bounded</code></pre><p>Grid topology for bounded dimensions. These could be wall-bounded dimensions or dimensions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Grids/Grids.jl#L51-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.Center" href="#Oceananigans.Grids.Center"><code>Oceananigans.Grids.Center</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Center</code></pre><p>A type describing the location at the center of a grid cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Grids/Grids.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.Face" href="#Oceananigans.Grids.Face"><code>Oceananigans.Grids.Face</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Face</code></pre><p>A type describing the location at the face of a grid cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Grids/Grids.jl#L30-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.Flat" href="#Oceananigans.Grids.Flat"><code>Oceananigans.Grids.Flat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Flat</code></pre><p>Grid topology for flat dimensions, generally with one grid point, along which the solution is uniform and does not vary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Grids/Grids.jl#L59-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.Periodic" href="#Oceananigans.Grids.Periodic"><code>Oceananigans.Grids.Periodic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Periodic</code></pre><p>Grid topology for periodic dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Grids/Grids.jl#L44-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.nodes-Tuple{Any,AbstractGrid}" href="#Oceananigans.Grids.nodes-Tuple{Any,AbstractGrid}"><code>Oceananigans.Grids.nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nodes(loc, grid; reshape=false)</code></pre><p>Returns a 3-tuple of views over the interior nodes at the locations in <code>loc</code> in <code>x, y, z</code>.</p><p>If <code>reshape=true</code>, the views are reshaped to 3D arrays with non-singleton dimensions 1, 2, 3 for <code>x, y, z</code>, respectively. These reshaped arrays can then be used in broadcast operations with 3D fields or arrays.</p><p>See <code>xnodes</code>, <code>ynodes</code>, and <code>znodes</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Grids/grid_utils.jl#L249-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.xnodes-Tuple{Any,Any}" href="#Oceananigans.Grids.xnodes-Tuple{Any,Any}"><code>Oceananigans.Grids.xnodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">xnodes(loc, grid, reshape=false)</code></pre><p>Returns a view over the interior <code>loc=Center</code> or <code>loc=Face</code> nodes on <code>grid</code> in the x-direction. For <code>Bounded</code> directions, <code>Face</code> nodes include the boundary points. <code>reshape=false</code> will return a 1D array while <code>reshape=true</code> will return a 3D array with size Nx×1×1.</p><p>See <code>znodes</code> for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Grids/grid_utils.jl#L167-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.ynodes-Tuple{Any,Any}" href="#Oceananigans.Grids.ynodes-Tuple{Any,Any}"><code>Oceananigans.Grids.ynodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ynodes(loc, grid, reshape=false)</code></pre><p>Returns a view over the interior <code>loc=Center</code> or <code>loc=Face</code> nodes on <code>grid</code> in the y-direction. For <code>Bounded</code> directions, <code>Face</code> nodes include the boundary points. <code>reshape=false</code> will return a 1D array while <code>reshape=true</code> will return a 3D array with size 1×Ny×1.</p><p>See <code>znodes</code> for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Grids/grid_utils.jl#L186-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.znodes-Tuple{Any,Any}" href="#Oceananigans.Grids.znodes-Tuple{Any,Any}"><code>Oceananigans.Grids.znodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">znodes(loc, grid, reshape=false)</code></pre><p>Returns a view over the interior <code>loc=Center</code> or <code>loc=Face</code> nodes on <code>grid</code> in the z-direction. For <code>Bounded</code> directions, <code>Face</code> nodes include the boundary points. <code>reshape=false</code> will return a 1D array while <code>reshape=true</code> will return a 3D array with size 1×1×Nz.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Oceananigans, Oceananigans.Grids

julia&gt; horz_periodic_grid = RegularCartesianGrid(size=(3, 3, 3), extent=(2π, 2π, 1),
                                                 topology=(Periodic, Periodic, Bounded));

julia&gt; zC = znodes(Center, horz_periodic_grid)
3-element view(OffsetArray(::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}, 0:4), 1:3) with eltype Float64:
 -0.8333333333333331
 -0.4999999999999999
 -0.16666666666666652</code></pre><pre><code class="language-julia-repl">julia&gt; zF = znodes(Face, horz_periodic_grid)
4-element view(OffsetArray(::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}, 0:5), 1:4) with eltype Float64:
 -1.0
 -0.6666666666666666
 -0.33333333333333337
 -4.44089209850063e-17</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Grids/grid_utils.jl#L206-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.RegularCartesianGrid" href="#Oceananigans.Grids.RegularCartesianGrid"><code>Oceananigans.Grids.RegularCartesianGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RegularCartesianGrid{FT, TX, TY, TZ, R} &lt;: AbstractGrid{FT, TX, TY, TZ}</code></pre><p>A Cartesian grid with with constant grid spacings <code>Δx</code>, <code>Δy</code>, and <code>Δz</code> between cell centers and cell faces, elements of type <code>FT</code>, topology <code>{TX, TY, TZ}</code>, and coordinate ranges of type <code>R</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Grids/regular_cartesian_grid.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.RegularCartesianGrid" href="#Oceananigans.Grids.RegularCartesianGrid"><code>Oceananigans.Grids.RegularCartesianGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RegularCartesianGrid([FT=Float64]; size,
                     extent = nothing, x = nothing, y = nothing, z = nothing,
                     topology = (Periodic, Periodic, Bounded), halo = (1, 1, 1))</code></pre><p>Creates a <code>RegularCartesianGrid</code> with <code>size = (Nx, Ny, Nz)</code> grid points.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>size</code> (required): A tuple prescribing the number of grid points in non-<code>Flat</code> directions.                    <code>size</code> is a 3-tuple for 3D models, a 2-tuple for 2D models, and either a                    scalar or 1-tuple for 1D models.</p></li><li><p><code>topology</code>: A 3-tuple <code>(Tx, Ty, Tz)</code> specifying the topology of the domain.             <code>Tx</code>, <code>Ty</code>, and <code>Tz</code> specify whether the <code>x</code>-, <code>y</code>-, and <code>z</code> directions are             <code>Periodic</code>, <code>Bounded</code>, or <code>Flat</code>. The topology <code>Flat</code> indicates that a model does             not vary in that directions so that derivatives and interpolation are zero.             The default is <code>topology=(Periodic, Periodic, Bounded)</code>.</p></li><li><p><code>extent</code>: A tuple prescribing the physical extent of the grid in non-<code>Flat</code> directions.           The origin for three-dimensional domains is the oceanic default <code>(0, 0, -Lz)</code>.</p></li><li><p><code>x</code>, <code>y</code>, and <code>z</code>: Each of <code>x, y, z</code> are 2-tuples that specify the end points of the domain                    in their respect directions. Scalar values may be used in <code>Flat</code> directions.</p></li></ul><p><em>Note</em>: <em>Either</em> <code>extent</code>, or all of <code>x</code>, <code>y</code>, and <code>z</code> must be specified.</p><ul><li><code>halo</code>: A tuple of integers that specifies the size of the halo region of cells surrounding         the physical interior for each non-<code>Flat</code> direction.</li></ul><p>The physical extent of the domain can be specified via <code>x</code>, <code>y</code>, and <code>z</code> keyword arguments indicating the left and right endpoints of each dimensions, e.g. <code>x=(-π, π)</code> or via the <code>extent</code> argument, e.g. <code>extent=(Lx, Ly, Lz)</code> which specifies the extent of each dimension in which case 0 ≤ x ≤ Lx, 0 ≤ y ≤ Ly, and -Lz ≤ z ≤ 0.</p><p>A grid topology may be specified via a tuple assigning one of <code>Periodic</code>, <code>Bounded, and</code>Flat<code>to each dimension. By default, a horizontally periodic grid topology</code>(Periodic, Periodic, Bounded)` is assumed.</p><p>Constants are stored using floating point values of type <code>FT</code>. By default this is <code>Float64</code>. Make sure to specify the desired <code>FT</code> if not using <code>Float64</code>.</p><p><strong>Grid properties</strong></p><ul><li><p><code>(Nx, Ny, Nz)::Int</code>: Number of physical points in the (x, y, z)-direction</p></li><li><p><code>(Hx, Hy, Hz)::Int</code>: Number of halo points in the (x, y, z)-direction</p></li><li><p><code>(Lx, Ly, Lz)::FT</code>: Physical extent of the grid in the (x, y, z)-direction</p></li><li><p><code>(Δx, Δy, Δz)::FT</code>: Center width in the (x, y, z)-direction</p></li><li><p><code>(xC, yC, zC)</code>: (x, y, z) coordinates of cell centers.</p></li><li><p><code>(xF, yF, zF)</code>: (x, y, z) coordinates of cell faces.</p></li></ul><p><strong>Examples</strong></p><ul><li>A default grid with Float64 type:</li></ul><pre><code class="language-julia-repl">julia&gt; using Oceananigans

julia&gt; grid = RegularCartesianGrid(size=(32, 32, 32), extent=(1, 2, 3))
RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}
                   domain: x ∈ [0.0, 1.0], y ∈ [0.0, 2.0], z ∈ [-3.0, 0.0]
                 topology: (Periodic, Periodic, Bounded)
  resolution (Nx, Ny, Nz): (32, 32, 32)
   halo size (Hx, Hy, Hz): (1, 1, 1)
grid spacing (Δx, Δy, Δz): (0.03125, 0.0625, 0.09375)</code></pre><ul><li>A default grid with Float32 type:</li></ul><pre><code class="language-julia-repl">julia&gt; using Oceananigans

julia&gt; grid = RegularCartesianGrid(Float32; size=(32, 32, 16), x=(0, 8), y=(-10, 10), z=(-π, π))
RegularCartesianGrid{Float32, Periodic, Periodic, Bounded}
                   domain: x ∈ [0.0, 8.0], y ∈ [-10.0, 10.0], z ∈ [-3.1415927, 3.1415927]
                 topology: (Periodic, Periodic, Bounded)
  resolution (Nx, Ny, Nz): (32, 32, 16)
   halo size (Hx, Hy, Hz): (1, 1, 1)
grid spacing (Δx, Δy, Δz): (0.25f0, 0.625f0, 0.3926991f0)</code></pre><ul><li>A two-dimenisional, horizontally-periodic grid:</li></ul><pre><code class="language-julia-repl">julia&gt; using Oceananigans

julia&gt; grid = RegularCartesianGrid(size=(32, 32), extent=(2π, 4π), topology=(Periodic, Periodic, Flat))
RegularCartesianGrid{Float64, Periodic, Periodic, Flat}
                   domain: x ∈ [0.0, 6.283185307179586], y ∈ [0.0, 12.566370614359172], z ∈ [0.0, 0.0]
                 topology: (Periodic, Periodic, Flat)
  resolution (Nx, Ny, Nz): (32, 32, 1)
   halo size (Hx, Hy, Hz): (1, 1, 0)
grid spacing (Δx, Δy, Δz): (0.19634954084936207, 0.39269908169872414, 0.0)</code></pre><ul><li>A one-dimensional &quot;column&quot; grid:</li></ul><pre><code class="language-julia-repl">julia&gt; using Oceananigans

julia&gt; grid = RegularCartesianGrid(size=256, z=(-128, 0), topology=(Flat, Flat, Bounded))
RegularCartesianGrid{Float64, Flat, Flat, Bounded}
                   domain: x ∈ [0.0, 0.0], y ∈ [0.0, 0.0], z ∈ [-128.0, 0.0]
                 topology: (Flat, Flat, Bounded)
  resolution (Nx, Ny, Nz): (1, 1, 256)
   halo size (Hx, Hy, Hz): (0, 0, 1)
grid spacing (Δx, Δy, Δz): (0.0, 0.0, 0.5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Grids/regular_cartesian_grid.jl#L35-L151">source</a></section></article><h2 id="Lagrangian-particle-tracking"><a class="docs-heading-anchor" href="#Lagrangian-particle-tracking">Lagrangian particle tracking</a><a id="Lagrangian-particle-tracking-1"></a><a class="docs-heading-anchor-permalink" href="#Lagrangian-particle-tracking" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.LagrangianParticleTracking.LagrangianParticles-Tuple{StructArrays.StructArray}" href="#Oceananigans.LagrangianParticleTracking.LagrangianParticles-Tuple{StructArrays.StructArray}"><code>Oceananigans.LagrangianParticleTracking.LagrangianParticles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">LagrangianParticles(particles::StructArray; restitution=1.0, tracked_fields::NamedTuple=NamedTuple(), dynamics=no_dynamics)</code></pre><p>Construct some <code>LagrangianParticles</code> that can be passed to a model. The <code>particles</code> should be a <code>StructArray</code> and can contain custom fields. The coefficient of restitution for particle-wall collisions is specified by <code>restitution</code>.</p><p>A number of <code>tracked_fields</code> may be passed in as a <code>NamedTuple</code> of fields. Each particle will track the value of each field. Each tracked field must have a corresponding particle property. So if <code>T</code> is a tracked field, then <code>T</code> must also be a custom particle property.</p><p><code>dynamics</code> is a function of <code>(lagrangian_particles, model, Δt)</code> that is called prior to advecting particles. <code>parameters</code> can be accessed inside the <code>dynamics</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/LagrangianParticleTracking/LagrangianParticleTracking.jl#L55-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.LagrangianParticleTracking.LagrangianParticles-Tuple{}" href="#Oceananigans.LagrangianParticleTracking.LagrangianParticles-Tuple{}"><code>Oceananigans.LagrangianParticleTracking.LagrangianParticles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">LagrangianParticles(; x, y, z, restitution=1.0, dynamics=no_dynamics, parameters=nothing)</code></pre><p>Construct some <code>LagrangianParticles</code> that can be passed to a model. The particles will have initial locations <code>x</code>, <code>y</code>, and <code>z</code>. The coefficient of restitution for particle-wall collisions is specified by <code>restitution</code>.</p><p><code>dynamics</code> is a function of <code>(lagrangian_particles, model, Δt)</code> that is called prior to advecting particles. <code>parameters</code> can be accessed inside the <code>dynamics</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/LagrangianParticleTracking/LagrangianParticleTracking.jl#L34-L42">source</a></section></article><h2 id="Logger"><a class="docs-heading-anchor" href="#Logger">Logger</a><a id="Logger-1"></a><a class="docs-heading-anchor-permalink" href="#Logger" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Logger.OceananigansLogger" href="#Oceananigans.Logger.OceananigansLogger"><code>Oceananigans.Logger.OceananigansLogger</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OceananigansLogger(stream::IO=stdout, level=Logging.Info; show_info_source=false)</code></pre><p>Based on Logging.SimpleLogger, it tries to log all messages in the following format:</p><pre><code class="language-none">[yyyy/mm/dd HH:MM:SS.sss] log_level message [-@-&gt; source_file:line_number]</code></pre><p>where the source of the message between the square brackets is included only if <code>show_info_source=true</code> or if the message is not an info level message.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Logger.jl#L26-L35">source</a></section></article><h2 id="Models"><a class="docs-heading-anchor" href="#Models">Models</a><a id="Models-1"></a><a class="docs-heading-anchor-permalink" href="#Models" title="Permalink"></a></h2><h2 id="Output-writers"><a class="docs-heading-anchor" href="#Output-writers">Output writers</a><a id="Output-writers-1"></a><a class="docs-heading-anchor-permalink" href="#Output-writers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.JLD2OutputWriter" href="#Oceananigans.OutputWriters.JLD2OutputWriter"><code>Oceananigans.OutputWriters.JLD2OutputWriter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">JLD2OutputWriter{I, T, O, IF, IN, KW} &lt;: AbstractOutputWriter</code></pre><p>An output writer for writing to JLD2 files.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/OutputWriters/jld2_output_writer.jl#L6-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.JLD2OutputWriter-Tuple{Any,Any}" href="#Oceananigans.OutputWriters.JLD2OutputWriter-Tuple{Any,Any}"><code>Oceananigans.OutputWriters.JLD2OutputWriter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JLD2OutputWriter(model, outputs; prefix, schedule,
                          dir = &quot;.&quot;,
                 field_slicer = FieldSlicer(),
                   array_type = Array{Float32},
                 max_filesize = Inf,
                        force = false,
                         init = noinit,
                    including = [:grid, :coriolis, :buoyancy, :closure],
                      verbose = false,
                         part = 1,
                      jld2_kw = Dict{Symbol, Any}())</code></pre><p>Construct a <code>JLD2OutputWriter</code> for an Oceananigans <code>model</code> that writes <code>label, output</code> pairs in <code>outputs</code> to a JLD2 file.</p><p>The argument <code>outputs</code> may be a <code>Dict</code> or <code>NamedTuple</code>. The keys of <code>outputs</code> are symbols or strings that &quot;name&quot; output data. The values of <code>outputs</code> are either <code>AbstractField</code>s, objects that are called with the signature <code>output(model)</code>, or <code>WindowedTimeAverage</code>s of <code>AbstractFields</code>s, functions, or callable objects.</p><p><strong>Keyword arguments</strong></p><pre><code class="language-none">## Filenaming

- `prefix` (required): Descriptive filename prefixed to all output files.

- `dir`: Directory to save output to.
         Default: &quot;.&quot; (current working directory).

## Output frequency and time-averaging

- `schedule` (required): `AbstractSchedule` that determines when output is saved.

## Slicing and type conversion prior to output

- `field_slicer`: An object for slicing field output in ``(x, y, z)``, including omitting halos.
                  Has no effect on output that is not a field. `field_slicer = nothing` means
                  no slicing occurs, so that all field data, including halo regions, is saved.
                  Default: FieldSlicer(), which slices halo regions.

- `array_type`: The array type to which output arrays are converted to prior to saving.
                Default: Array{Float32}.

## File management

- `max_filesize`: The writer will stop writing to the output file once the file size exceeds `max_filesize`,
                  and write to a new one with a consistent naming scheme ending in `part1`, `part2`, etc.
                  Defaults to `Inf`.

- `force`: Remove existing files if their filenames conflict.
           Default: `false`.

## Output file metadata management

- `init`: A function of the form `init(file, model)` that runs when a JLD2 output file is initialized.
          Default: `noinit(args...) = nothing`.

- `including`: List of model properties to save with every file.
               Default: `[:grid, :coriolis, :buoyancy, :closure]`

## Miscellaneous keywords

- `verbose`: Log what the output writer is doing with statistics on compute/write times and file sizes.
             Default: `false`.

- `part`: The starting part number used if `max_filesize` is finite.
          Default: 1.

- `jld2_kw`: Dict of kwargs to be passed to `jldopen` when data is written.</code></pre><p><strong>Example</strong></p><p>Write out 3D fields for w and T and a horizontal average:</p><pre><code class="language-julia">using Oceananigans, Oceananigans.OutputWriters, Oceananigans.Fields
using Oceananigans.Utils: hour, minute

model = IncompressibleModel(grid=RegularCartesianGrid(size=(1, 1, 1), extent=(1, 1, 1)))
simulation = Simulation(model, Δt=12, stop_time=1hour)

function init_save_some_metadata!(file, model)
    file[&quot;author&quot;] = &quot;Chim Riggles&quot;
    file[&quot;parameters/coriolis_parameter&quot;] = 1e-4
    file[&quot;parameters/density&quot;] = 1027
    return nothing
end

T_avg =  AveragedField(model.tracers.T, dims=(1, 2))

# Note that model.velocities is NamedTuple
simulation.output_writers[:velocities] = JLD2OutputWriter(model, model.velocities,
                                                          prefix = &quot;some_data&quot;,
                                                          schedule = TimeInterval(20minute),
                                                          init = init_save_some_metadata!)

# output
JLD2OutputWriter scheduled on TimeInterval(20 minutes):
├── filepath: ./some_data.jld2
├── 3 outputs: (:u, :v, :w)
├── field slicer: FieldSlicer(:, :, :, with_halos=false)
├── array type: Array{Float32}
├── including: [:grid, :coriolis, :buoyancy, :closure]
└── max filesize: Inf YiB</code></pre><p>and a time- and horizontal-average of temperature <code>T</code> every 1 hour of simulation time to a file called <code>some_averaged_data.jld2</code></p><pre><code class="language-julia">simulation.output_writers[:avg_T] = JLD2OutputWriter(model, (T=T_avg,),
                                                     prefix = &quot;some_averaged_data&quot;,
                                                     schedule = AveragedTimeInterval(20minute, window=5minute))

# output
JLD2OutputWriter scheduled on TimeInterval(20 minutes):
├── filepath: ./some_averaged_data.jld2
├── 1 outputs: (:T,) averaged on AveragedTimeInterval(window=5 minutes, stride=1, interval=20 minutes)
├── field slicer: FieldSlicer(:, :, :, with_halos=false)
├── array type: Array{Float32}
├── including: [:grid, :coriolis, :buoyancy, :closure]
└── max filesize: Inf YiB</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/OutputWriters/jld2_output_writer.jl#L28-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.NetCDFOutputWriter" href="#Oceananigans.OutputWriters.NetCDFOutputWriter"><code>Oceananigans.OutputWriters.NetCDFOutputWriter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NetCDFOutputWriter{D, O, I, T, S} &lt;: AbstractOutputWriter</code></pre><p>An output writer for writing to NetCDF files.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/OutputWriters/netcdf_output_writer.jl#L109-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.NetCDFOutputWriter-Tuple{Any,Any}" href="#Oceananigans.OutputWriters.NetCDFOutputWriter-Tuple{Any,Any}"><code>Oceananigans.OutputWriters.NetCDFOutputWriter</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function NetCDFOutputWriter(model, outputs; filepath, schedule                                    array<em>type = Array{Float32},                                  field</em>slicer = FieldSlicer(),                             global<em>attributes = Dict(),                             output</em>attributes = Dict(),                                    dimensions = Dict(),                                          mode = nothing,                                   compression = 0,                                       verbose = false)</p><p>Construct a <code>NetCDFOutputWriter</code> that writes <code>(label, output)</code> pairs in <code>outputs</code> (which should be a <code>Dict</code>) to a NetCDF file, where <code>label</code> is a string that labels the output and <code>output</code> is either a <code>Field</code> (e.g. <code>model.velocities.u</code> or an <code>AveragedField</code>) or a function <code>f(model)</code> that returns something to be written to disk. Custom output requires the spatial <code>dimensions</code> (a <code>Dict</code>) to be manually specified (see examples).</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>filepath</code> (required): Filepath to save output to.</p></li><li><p><code>schedule</code> (required): <code>AbstractSchedule</code> that determines when output is saved.</p></li><li><p><code>array_type</code>: The array type to which output arrays are converted to prior to saving.               Default: Array{Float32}.</p></li><li><p><code>field_slicer</code>: An object for slicing field output in <span>$(x, y, z)$</span>, including omitting halos,                 which can be done with the keyword <code>with_halos</code>.                 Has no effect on output that is not a field. <code>field_slicer = nothing</code> means                 no slicing occurs, so that all field data, including halo regions, is saved.                 Default: <code>FieldSlicer()</code>, which slices halo regions.</p></li><li><p><code>global_attributes</code>: Dict of model properties to save with every file (deafult: <code>Dict()</code>)</p></li><li><p><code>output_attributes</code>: Dict of attributes to be saved with each field variable (reasonable                      defaults are provided for velocities, buoyancy, temperature, and salinity;                      otherwise <code>output_attributes</code> <em>must</em> be user-provided).</p></li><li><p><code>dimensions</code>: A <code>Dict</code> of dimension tuples to apply to outputs (required for function outputs)</p></li><li><p><code>mode</code>: &quot;a&quot; (for append) and &quot;c&quot; (for clobber or create). Default: &quot;c&quot;. See NCDatasets.jl         documentation for more information on the <code>mode</code> option.</p></li><li><p><code>compression</code>: Determines the compression level of data (0-9, default 0)</p></li></ul><p><strong>Examples</strong></p><p>Saving the u velocity field and temperature fields, the full 3D fields and surface 2D slices to separate NetCDF files:</p><pre><code class="language-julia">using Oceananigans, Oceananigans.OutputWriters

grid = RegularCartesianGrid(size=(16, 16, 16), extent=(1, 1, 1));

model = IncompressibleModel(grid=grid);

simulation = Simulation(model, Δt=12, stop_time=3600);

fields = Dict(&quot;u&quot; =&gt; model.velocities.u, &quot;T&quot; =&gt; model.tracers.T);

simulation.output_writers[:field_writer] =
    NetCDFOutputWriter(model, fields, filepath=&quot;fields.nc&quot;, schedule=TimeInterval(60))

# output
NetCDFOutputWriter scheduled on TimeInterval(1 minute):
├── filepath: fields.nc
├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0)
├── 2 outputs: [&quot;T&quot;, &quot;u&quot;]
├── field slicer: FieldSlicer(:, :, :, with_halos=false)
└── array type: Array{Float32}</code></pre><pre><code class="language-julia">simulation.output_writers[:surface_slice_writer] =
    NetCDFOutputWriter(model, fields, filepath=&quot;surface_xy_slice.nc&quot;,
                       schedule=TimeInterval(60), field_slicer=FieldSlicer(k=grid.Nz))

# output
NetCDFOutputWriter scheduled on TimeInterval(1 minute):
├── filepath: surface_xy_slice.nc
├── dimensions: zC(1), zF(1), xC(16), yF(16), xF(16), yC(16), time(0)
├── 2 outputs: [&quot;T&quot;, &quot;u&quot;]
├── field slicer: FieldSlicer(:, :, 16, with_halos=false)
└── array type: Array{Float32}</code></pre><pre><code class="language-julia">simulation.output_writers[:averaged_profile_writer] =
    NetCDFOutputWriter(model, fields,
                       filepath = &quot;averaged_z_profile.nc&quot;,
                       schedule = AveragedTimeInterval(60, window=20),
                       field_slicer = FieldSlicer(i=1, j=1))

# output
NetCDFOutputWriter scheduled on TimeInterval(1 minute):
├── filepath: averaged_z_profile.nc
├── dimensions: zC(16), zF(17), xC(1), yF(1), xF(1), yC(1), time(0)
├── 2 outputs: [&quot;T&quot;, &quot;u&quot;] averaged on AveragedTimeInterval(window=20 seconds, stride=1, interval=1 minute)
├── field slicer: FieldSlicer(1, 1, :, with_halos=false)
└── array type: Array{Float32}</code></pre><p><code>NetCDFOutputWriter</code> also accepts output functions that write scalars and arrays to disk, provided that their <code>dimensions</code> are provided:</p><pre><code class="language-julia">using Oceananigans, Oceananigans.OutputWriters

grid = RegularCartesianGrid(size=(16, 16, 16), extent=(1, 2, 3));

model = IncompressibleModel(grid=grid);

simulation = Simulation(model, Δt=1.25, stop_iteration=3);

f(model) = model.clock.time^2; # scalar output

g(model) = model.clock.time .* exp.(znodes(Center, grid)); # vector/profile output

h(model) = model.clock.time .* (   sin.(xnodes(Center, grid, reshape=true)[:, :, 1])
                            .*     cos.(ynodes(Face, grid, reshape=true)[:, :, 1])); # xy slice output

outputs = Dict(&quot;scalar&quot; =&gt; f, &quot;profile&quot; =&gt; g, &quot;slice&quot; =&gt; h);

dims = Dict(&quot;scalar&quot; =&gt; (), &quot;profile&quot; =&gt; (&quot;zC&quot;,), &quot;slice&quot; =&gt; (&quot;xC&quot;, &quot;yC&quot;));

output_attributes = Dict(
    &quot;scalar&quot;  =&gt; Dict(&quot;longname&quot; =&gt; &quot;Some scalar&quot;, &quot;units&quot; =&gt; &quot;bananas&quot;),
    &quot;profile&quot; =&gt; Dict(&quot;longname&quot; =&gt; &quot;Some vertical profile&quot;, &quot;units&quot; =&gt; &quot;watermelons&quot;),
    &quot;slice&quot;   =&gt; Dict(&quot;longname&quot; =&gt; &quot;Some slice&quot;, &quot;units&quot; =&gt; &quot;mushrooms&quot;)
);

global_attributes = Dict(&quot;location&quot; =&gt; &quot;Bay of Fundy&quot;, &quot;onions&quot; =&gt; 7);

simulation.output_writers[:things] =
    NetCDFOutputWriter(model, outputs,
                       schedule=IterationInterval(1), filepath=&quot;things.nc&quot;, dimensions=dims, verbose=true,
                       global_attributes=global_attributes, output_attributes=output_attributes)

# output
NetCDFOutputWriter scheduled on IterationInterval(1):
├── filepath: things.nc
├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0)
├── 3 outputs: [&quot;profile&quot;, &quot;slice&quot;, &quot;scalar&quot;]
├── field slicer: FieldSlicer(:, :, :, with_halos=false)
└── array type: Array{Float32}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/OutputWriters/netcdf_output_writer.jl#L126-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.write_output!-Tuple{NetCDFOutputWriter,Any}" href="#Oceananigans.OutputWriters.write_output!-Tuple{NetCDFOutputWriter,Any}"><code>Oceananigans.OutputWriters.write_output!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">write_output!(output_writer, model)</code></pre><p>Writes output to netcdf file <code>output_writer.filepath</code> at specified intervals. Increments the <code>time</code> dimension every time an output is written to the file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/OutputWriters/netcdf_output_writer.jl#L406-L411">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.AveragedTimeInterval" href="#Oceananigans.OutputWriters.AveragedTimeInterval"><code>Oceananigans.OutputWriters.AveragedTimeInterval</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct AveragedTimeInterval &lt;: AbstractSchedule</code></pre><p>Container for parameters that configure and handle time-averaged output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/OutputWriters/windowed_time_average.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.AveragedTimeInterval-Tuple{Any}" href="#Oceananigans.OutputWriters.AveragedTimeInterval-Tuple{Any}"><code>Oceananigans.OutputWriters.AveragedTimeInterval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">AveragedTimeInterval(interval; window=interval, stride=1)</code></pre><p>Returns a <code>schedule</code> that specifies periodic time-averaging of output. The time <code>window</code> specifies the extent of the time-average, which reoccurs every <code>interval</code>. </p><p><code>output</code> is computed and accumulated into the average every <code>stride</code> iterations during the averaging window. For example, <code>stride=1</code> computs output every iteration, whereas <code>stride=2</code> computes output every other iteration. Time-averages with longer <code>stride</code>s are faster to compute, but less accurate.</p><p>The time-average of <span>$a$</span> is a left Riemann sum corresponding to</p><p><span>$⟨a⟩ = 1/T \int_{tᵢ-T}^T a \mathrm{d} t ,$</span></p><p>where <span>$⟨a⟩$</span> is the time-average of <span>$a$</span>, <span>$T$</span> is the time-window for averaging, and the <span>$tᵢ$</span> are discrete times separated by the time <code>interval</code>. The <span>$tᵢ$</span> specify both the end of the averaging window and the time at which output is written.</p><p><strong>Example</strong></p><pre><code class="language-julia">using Oceananigans.OutputWriters: AveragedTimeInterval
using Oceananigans.Utils: year, years

schedule = AveragedTimeInterval(4years, window=1year)

# output
AveragedTimeInterval(window=1 year, stride=1, interval=4 years)</code></pre><p>An <code>AveragedTimeInterval</code> schedule directs an output writer to time-average its outputs before writing them to disk:</p><pre><code class="language-julia">using Oceananigans
using Oceananigans.OutputWriters: JLD2OutputWriter
using Oceananigans.Utils: minutes

model = IncompressibleModel(grid=RegularCartesianGrid(size=(1, 1, 1), extent=(1, 1, 1)))

simulation = Simulation(model, Δt=10minutes, stop_time=30years)

simulation.output_writers[:velocities] = JLD2OutputWriter(model, model.velocities,
                                                          prefix = &quot;averaged_velocity_data&quot;,
                                                          schedule = AveragedTimeInterval(4years, window=1year, stride=2))

# output
JLD2OutputWriter scheduled on TimeInterval(4 years):
├── filepath: ./averaged_velocity_data.jld2
├── 3 outputs: (:u, :v, :w) averaged on AveragedTimeInterval(window=1 year, stride=2, interval=4 years)
├── field slicer: FieldSlicer(:, :, :, with_halos=false)
├── array type: Array{Float32}
├── including: [:grid, :coriolis, :buoyancy, :closure]
└── max filesize: Inf YiB</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/OutputWriters/windowed_time_average.jl#L21-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.WindowedTimeAverage" href="#Oceananigans.OutputWriters.WindowedTimeAverage"><code>Oceananigans.OutputWriters.WindowedTimeAverage</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">WindowedTimeAverage{OP, R, FS} &lt;: AbstractDiagnostic</code></pre><p>An object for computing &#39;windowed&#39; time averages, or moving time-averages of a <code>operand</code> over a specified <code>window</code>, collected on <code>interval</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/OutputWriters/windowed_time_average.jl#L89-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.WindowedTimeAverage" href="#Oceananigans.OutputWriters.WindowedTimeAverage"><code>Oceananigans.OutputWriters.WindowedTimeAverage</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">WindowedTimeAverage(operand, model=nothing; schedule, field_slicer=FieldSlicer())</code></pre><p>Returns an object for computing running averages of <code>operand</code> over <code>schedule.window</code> and recurring on <code>schedule.interval</code>, where <code>schedule</code> is an <code>AveragedTimeInterval</code>. During the collection period, averages are computed every <code>schedule.stride</code> iteration. </p><p><code>operand</code> may be a <code>Oceananigans.Field</code> or a function that returns an array or scalar.</p><p>Calling <code>wta(model)</code> for <code>wta::WindowedTimeAverage</code> object returns <code>wta.result</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/OutputWriters/windowed_time_average.jl#L105-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.Checkpointer" href="#Oceananigans.OutputWriters.Checkpointer"><code>Oceananigans.OutputWriters.Checkpointer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Checkpointer{I, T, P} &lt;: AbstractOutputWriter</code></pre><p>An output writer for checkpointing models to a JLD2 file from which models can be restored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/OutputWriters/checkpointer.jl#L6-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.Checkpointer-Tuple{Any}" href="#Oceananigans.OutputWriters.Checkpointer-Tuple{Any}"><code>Oceananigans.OutputWriters.Checkpointer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Checkpointer(model; schedule,
                    dir = &quot;.&quot;,
                 prefix = &quot;checkpoint&quot;,
                  force = false,
                verbose = false,
             properties = [:architecture, :boundary_conditions, :grid, :clock, :coriolis,
                           :buoyancy, :closure, :velocities, :tracers, :timestepper]
             )</code></pre><p>Construct a <code>Checkpointer</code> that checkpoints the model to a JLD2 file every so often as specified by <code>schedule</code>. The <code>model.clock.iteration</code> is included in the filename to distinguish between multiple checkpoint files.</p><p>Note that extra model <code>properties</code> can be safely specified, but removing crucial properties such as <code>:velocities</code> will make restoring from the checkpoint impossible.</p><p>The checkpoint file is generated by serializing model properties to JLD2. However, functions cannot be serialized to disk with JLD2. So if a model property contains a reference somewhere in its hierarchy it will not be included in the checkpoint file (and you will have to manually restore them).</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>schedule</code> (required): Schedule that determines when to checkpoint.</p></li><li><p><code>dir</code>: Directory to save output to. Default: &quot;.&quot; (current working directory).</p></li><li><p><code>prefix</code>: Descriptive filename prefixed to all output files. Default: &quot;checkpoint&quot;.</p></li><li><p><code>force</code>: Remove existing files if their filenames conflict. Default: <code>false</code>.</p></li><li><p><code>verbose</code>: Log what the output writer is doing with statistics on compute/write times            and file sizes. Default: <code>false</code>.</p></li><li><p><code>properties</code>: List of model properties to checkpoint. Some are required.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/OutputWriters/checkpointer.jl#L20-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.restore_from_checkpoint-Tuple{Any}" href="#Oceananigans.OutputWriters.restore_from_checkpoint-Tuple{Any}"><code>Oceananigans.OutputWriters.restore_from_checkpoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">restore_from_checkpoint(filepath; kwargs=Dict())</code></pre><p>Restore a model from the checkpoint file stored at <code>filepath</code>. <code>kwargs</code> can be passed to the model constructor, which can be especially useful if you need to manually restore forcing functions or boundary conditions that rely on functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/OutputWriters/checkpointer.jl#L156-L162">source</a></section></article><h2 id="Time-steppers"><a class="docs-heading-anchor" href="#Time-steppers">Time steppers</a><a id="Time-steppers-1"></a><a class="docs-heading-anchor-permalink" href="#Time-steppers" title="Permalink"></a></h2><h2 id="Simulations"><a class="docs-heading-anchor" href="#Simulations">Simulations</a><a id="Simulations-1"></a><a class="docs-heading-anchor-permalink" href="#Simulations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Simulations.TimeStepWizard-Tuple{}" href="#Oceananigans.Simulations.TimeStepWizard-Tuple{}"><code>Oceananigans.Simulations.TimeStepWizard</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">TimeStepWizard(cfl=0.1, max_change=2.0, min_change=0.5, max_Δt=Inf, min_Δt=0.0, Δt=0.01)</code></pre><p>A type for calculating adaptive time steps based on capping the CFL number at <code>cfl</code>.</p><p>On calling <code>update_Δt!(wizard, model)</code>, the <code>TimeStepWizard</code> computes a time-step such that <span>$cfl = max(u/Δx, v/Δy, w/Δz) Δt$</span>, where <span>$max(u/Δx, v/Δy, w/Δz)$</span> is the maximum ratio between model velocity and along-velocity grid spacing anywhere on the model grid. The new <code>Δt</code> is constrained to change by a multiplicative factor no more than <code>max_change</code> or no less than <code>min_change</code> from the previous <code>Δt</code>, and to be no greater in absolute magnitude than <code>max_Δt</code> and no less than <code>min_Δt</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Simulations/time_step_wizard.jl#L11-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Simulations.Simulation-Tuple{Any}" href="#Oceananigans.Simulations.Simulation-Tuple{Any}"><code>Oceananigans.Simulations.Simulation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Simulation(model; Δt,
     stop_criteria = Function[iteration_limit_exceeded, stop_time_exceeded, wall_time_limit_exceeded],
    stop_iteration = Inf,
         stop_time = Inf,
   wall_time_limit = Inf,
       diagnostics = OrderedDict{Symbol, AbstractDiagnostic}(),
    output_writers = OrderedDict{Symbol, AbstractOutputWriter}(),
          progress = nothing,
iteration_interval = 1,
        parameters = nothing)</code></pre><p>Construct an Oceananigans.jl <code>Simulation</code> for a <code>model</code> with time step <code>Δt</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>Δt</code>: Required keyword argument specifying the simulation time step. Can be a <code>Number</code> for constant time steps or a <code>TimeStepWizard</code> for adaptive time-stepping.</li><li><code>stop_criteria</code>: A list of functions or callable objects (each taking a single argument, the <code>simulation</code>). If any of the functions return <code>true</code> when the stop criteria is evaluated the simulation will stop.</li><li><code>stop_iteration</code>: Stop the simulation after this many iterations.</li><li><code>stop_time</code>: Stop the simulation once this much model clock time has passed.</li><li><code>wall_time_limit</code>: Stop the simulation if it&#39;s been running for longer than this many  seconds of wall clock time.</li><li><code>progress</code>: A function with a single argument, the <code>simulation</code>. Will be called every <code>iteration_interval</code> iterations. Useful for logging simulation health.</li><li><code>iteration_interval</code>: How often to update the time step, check stop criteria, and call <code>progress</code> function (in number of iterations).</li><li><code>parameters</code>: Parameters that can be accessed in the <code>progress</code> function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Simulations/simulation.jl#L20-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Simulations.run!-Tuple{Any}" href="#Oceananigans.Simulations.run!-Tuple{Any}"><code>Oceananigans.Simulations.run!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">run!(simulation; pickup=false)</code></pre><p>Run a <code>simulation</code> until one of <code>simulation.stop_criteria</code> evaluates <code>true</code>. The simulation will then stop.</p><p><strong>Picking simulations up from a checkpoint</strong></p><p>Simulations will be &quot;picked up&quot; from a checkpoint if <code>pickup</code> is either <code>true</code>, a <code>String</code>, or an <code>Integer</code> greater than 0.</p><p>Picking up a simulation sets field and tendency data to the specified checkpoint, leaving all other model properties unchanged.</p><p>Possible values for <code>pickup</code> are:</p><pre><code class="language-none">* `pickup=true` will pick a simulation up from the latest checkpoint associated with
  the `Checkpointer` in simulation.output_writers`.

* `pickup=iteration::Int` will pick a simulation up from the checkpointed file associated
   with `iteration` and the `Checkpointer` in simulation.output_writers`.

* `pickup=filepath::String` will pick a simulation up from checkpointer data in `filepath`.</code></pre><p>Note that <code>pickup=true</code> and <code>pickup=iteration</code> will fail if <code>simulation.output_writers</code> contains more than one checkpointer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Simulations/run.jl#L98-L124">source</a></section></article><h2 id="Tubrulence-closures"><a class="docs-heading-anchor" href="#Tubrulence-closures">Tubrulence closures</a><a id="Tubrulence-closures-1"></a><a class="docs-heading-anchor-permalink" href="#Tubrulence-closures" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.AbstractIsotropicDiffusivity" href="#Oceananigans.TurbulenceClosures.AbstractIsotropicDiffusivity"><code>Oceananigans.TurbulenceClosures.AbstractIsotropicDiffusivity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractIsotropicDiffusivity &lt;: AbstractTurbulenceClosure</code></pre><p>Abstract supertype for turbulence closures that are defined by an isotropic viscosity and isotropic diffusivities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/TurbulenceClosures/TurbulenceClosures.jl#L64-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation" href="#Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation"><code>Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AnisotropicMinimumDissipation</code></pre><p>An alias for <code>VerstappenAnisotropicMinimumDissipation</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/TurbulenceClosures/TurbulenceClosures.jl#L182-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.ConstantSmagorinsky" href="#Oceananigans.TurbulenceClosures.ConstantSmagorinsky"><code>Oceananigans.TurbulenceClosures.ConstantSmagorinsky</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConstantSmagorinsky</code></pre><p>An alias for <code>SmagorinskyLilly</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/TurbulenceClosures/TurbulenceClosures.jl#L189-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.∂ⱼ_2ν_Σ₁ⱼ-Tuple{Any,Any,Any,Any,Any,AbstractIsotropicDiffusivity,Any,Any}" href="#Oceananigans.TurbulenceClosures.∂ⱼ_2ν_Σ₁ⱼ-Tuple{Any,Any,Any,Any,Any,AbstractIsotropicDiffusivity,Any,Any}"><code>Oceananigans.TurbulenceClosures.∂ⱼ_2ν_Σ₁ⱼ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∂ⱼ_2ν_Σ₁ⱼ(i, j, k, grid, closure, U, diffusivities)</code></pre><p>Return the <span>$x$</span>-component of the turbulent diffusive flux divergence:</p><p><code>∂x(2 ν Σ₁₁) + ∂y(2 ν Σ₁₁) + ∂z(2 ν Σ₁₁)</code></p><p>at the location <code>fcc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/TurbulenceClosures/closure_operators.jl#L107-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.∂ⱼ_2ν_Σ₂ⱼ-Tuple{Any,Any,Any,Any,Any,AbstractIsotropicDiffusivity,Any,Any}" href="#Oceananigans.TurbulenceClosures.∂ⱼ_2ν_Σ₂ⱼ-Tuple{Any,Any,Any,Any,Any,AbstractIsotropicDiffusivity,Any,Any}"><code>Oceananigans.TurbulenceClosures.∂ⱼ_2ν_Σ₂ⱼ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∂ⱼ_2ν_Σ₂ⱼ(i, j, k, grid, closure, U, diffusivities)</code></pre><p>Return the <span>$y$</span>-component of the turbulent diffusive flux divergence:</p><p><code>∂x(2 ν Σ₂₁) + ∂y(2 ν Σ₂₂) + ∂z(2 ν Σ₂₂)</code></p><p>at the location <code>ccf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/TurbulenceClosures/closure_operators.jl#L122-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.∂ⱼ_2ν_Σ₃ⱼ-Tuple{Any,Any,Any,Any,Any,AbstractIsotropicDiffusivity,Any,Any}" href="#Oceananigans.TurbulenceClosures.∂ⱼ_2ν_Σ₃ⱼ-Tuple{Any,Any,Any,Any,Any,AbstractIsotropicDiffusivity,Any,Any}"><code>Oceananigans.TurbulenceClosures.∂ⱼ_2ν_Σ₃ⱼ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∂ⱼ_2ν_Σ₃ⱼ(i, j, k, grid, closure, diffusivities)</code></pre><p>Return the <span>$z$</span>-component of the turbulent diffusive flux divergence:</p><p><code>∂x(2 ν Σ₃₁) + ∂y(2 ν Σ₃₂) + ∂z(2 ν Σ₃₃)</code></p><p>at the location <code>ccf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/TurbulenceClosures/closure_operators.jl#L137-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.AnisotropicBiharmonicDiffusivity" href="#Oceananigans.TurbulenceClosures.AnisotropicBiharmonicDiffusivity"><code>Oceananigans.TurbulenceClosures.AnisotropicBiharmonicDiffusivity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AnisotropicBiharmonicDiffusivity{FT, KH, KZ}</code></pre><p>Parameters for anisotropic biharmonic diffusivity models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_biharmonic_diffusivity.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.AnisotropicBiharmonicDiffusivity" href="#Oceananigans.TurbulenceClosures.AnisotropicBiharmonicDiffusivity"><code>Oceananigans.TurbulenceClosures.AnisotropicBiharmonicDiffusivity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AnisotropicBiharmonicDiffusivity(FT=Float64; νx=0, νy=0, νz=0, νh=nothing, κx=0, κy=0, κz=0, κh=nothing)</code></pre><p>Returns parameters for a fourth-order, anisotropic biharmonic diffusivity closure with constant x-, y, and z-direction biharmonic viscosities <code>νx</code>, <code>νy</code>, and <code>νz</code>, and constant x-, y, and z-direction biharmonic diffusivities <code>κx</code>, <code>κy</code>, and <code>κz</code>, <code>κx</code>, <code>κy</code>, and <code>κz</code> may be <code>NamedTuple</code>s with fields corresponding to each tracer, or a single number to be a applied to all tracers.</p><p>If <code>νh</code> or <code>κh</code> are provided, then <code>νx = νy = νh</code> or <code>κx = κy = κh</code>.</p><p>The tracer flux divergence associated with an anisotropic biharmonic diffusivity is, for example</p><p class="math-container">\[    ∂ᵢ κᵢⱼ ∂ⱼc = - [κx ∂⁴x + κy ∂⁴y + κz ∂⁴z] c\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_biharmonic_diffusivity.jl#L17-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.SmagorinskyLilly" href="#Oceananigans.TurbulenceClosures.SmagorinskyLilly"><code>Oceananigans.TurbulenceClosures.SmagorinskyLilly</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SmagorinskyLilly{FT} &lt;: AbstractSmagorinsky{FT}</code></pre><p>Parameters for the Smagorinsky-Lilly turbulence closure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl#L6-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.SmagorinskyLilly" href="#Oceananigans.TurbulenceClosures.SmagorinskyLilly"><code>Oceananigans.TurbulenceClosures.SmagorinskyLilly</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SmagorinskyLilly([FT=Float64;] C=0.23, Pr=1, ν=1.05e-6, κ=1.46e-7)</code></pre><p>Return a <code>SmagorinskyLilly</code> type associated with the turbulence closure proposed by Lilly (1962) and Smagorinsky (1958, 1963), which has an eddy viscosity of the form</p><pre><code class="language-none">`νₑ = (C * Δᶠ)² * √(2Σ²) * √(1 - Cb * N² / Σ²) + ν`,</code></pre><p>and an eddy diffusivity of the form</p><pre><code class="language-none">`κₑ = (νₑ - ν) / Pr + κ`</code></pre><p>where <code>Δᶠ</code> is the filter width, <code>Σ² = ΣᵢⱼΣᵢⱼ</code> is the double dot product of the strain tensor <code>Σᵢⱼ</code>, <code>Pr</code> is the turbulent Prandtl number, and <code>N²</code> is the total buoyancy gradient, and <code>Cb</code> is a constant the multiplies the Richardson number modification to the eddy viscosity.</p><p><strong>Keyword arguments</strong></p><pre><code class="language-none">- `C`  : Model constant
- `Cb` : Buoyancy term multipler (`Cb = 0` turns it off, `Cb ≠ 0` turns it on.
         Typically `Cb=1/Pr`.)
- `Pr` : Turbulent Prandtl numbers for each tracer. Either a constant applied to every
         tracer, or a `NamedTuple` with fields for each tracer individually.
- `ν`  : Constant background viscosity for momentum
- `κ`  : Constant background diffusivity for tracer. Can either be a single number
         applied to all tracers, or `NamedTuple` of diffusivities corresponding to each
         tracer.</code></pre><p><strong>References</strong></p><p>Smagorinsky, J. &quot;On the numerical integration of the primitive equations of motion for     baroclinic flow in a closed region.&quot; Monthly Weather Review (1958)</p><p>Lilly, D. K. &quot;On the numerical simulation of buoyant convection.&quot; Tellus (1962)</p><p>Smagorinsky, J. &quot;General circulation experiments with the primitive equations: I.     The basic experiment.&quot; Monthly weather review (1963)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl#L25-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.∇_κ_∇c-Tuple{Any,Any,Any,Any,Any,Oceananigans.TurbulenceClosures.AbstractSmagorinsky,Any,Any,Any,Vararg{Any,N} where N}" href="#Oceananigans.TurbulenceClosures.∇_κ_∇c-Tuple{Any,Any,Any,Any,Any,Oceananigans.TurbulenceClosures.AbstractSmagorinsky,Any,Any,Any,Vararg{Any,N} where N}"><code>Oceananigans.TurbulenceClosures.∇_κ_∇c</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∇_κ_∇c(i, j, k, grid, clock, c, closure, diffusivities)</code></pre><p>Return the diffusive flux divergence <code>∇ ⋅ (κ ∇ c)</code> for the turbulence <code>closure</code>, where <code>c</code> is an array of scalar data located at cell centers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl#L166-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.IsotropicDiffusivity" href="#Oceananigans.TurbulenceClosures.IsotropicDiffusivity"><code>Oceananigans.TurbulenceClosures.IsotropicDiffusivity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IsotropicDiffusivity{N, K}</code></pre><p>Holds viscosity and diffusivities for models with prescribed isotropic diffusivities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/TurbulenceClosures/turbulence_closure_implementations/isotropic_diffusivity.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.IsotropicDiffusivity" href="#Oceananigans.TurbulenceClosures.IsotropicDiffusivity"><code>Oceananigans.TurbulenceClosures.IsotropicDiffusivity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IsotropicDiffusivity(; ν=ν₀, κ=κ₀)</code></pre><p>Returns parameters for an isotropic diffusivity model with viscosity <code>ν</code> and thermal diffusivities <code>κ</code> for each tracer field in <code>tracers</code> <code>ν</code> and the fields of <code>κ</code> may be constants or functions of <code>(x, y, z, t)</code>, and may represent molecular diffusivities in cases that all flow features are explicitly resovled, or turbulent eddy diffusivities that model the effect of unresolved, subgrid-scale turbulence. <code>κ</code> may be a <code>NamedTuple</code> with fields corresponding to each tracer, or a single number to be a applied to all tracers.</p><p>By default, a molecular viscosity of <code>ν₀ = 1.05×10⁻⁶</code> m² s⁻¹ and a molecular thermal diffusivity of <code>κ₀ = 1.46×10⁻⁷</code> m² s⁻¹ is used for each tracer. These molecular values are the approximate viscosity and thermal diffusivity for seawater at 20°C and 35 psu, according to Sharqawy et al., &quot;Thermophysical properties of seawater: A review of existing correlations and data&quot; (2010).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/TurbulenceClosures/turbulence_closure_implementations/isotropic_diffusivity.jl#L11-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.VerstappenAnisotropicMinimumDissipation" href="#Oceananigans.TurbulenceClosures.VerstappenAnisotropicMinimumDissipation"><code>Oceananigans.TurbulenceClosures.VerstappenAnisotropicMinimumDissipation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">VerstappenAnisotropicMinimumDissipation{FT} &lt;: AbstractAnisotropicMinimumDissipation{FT}</code></pre><p>Parameters for the anisotropic minimum dissipation large eddy simulation model proposed by Verstappen (2018) and described by Vreugdenhil &amp; Taylor (2018).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/TurbulenceClosures/turbulence_closure_implementations/verstappen_anisotropic_minimum_dissipation.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.VerstappenAnisotropicMinimumDissipation" href="#Oceananigans.TurbulenceClosures.VerstappenAnisotropicMinimumDissipation"><code>Oceananigans.TurbulenceClosures.VerstappenAnisotropicMinimumDissipation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">VerstappenAnisotropicMinimumDissipation(FT=Float64; C=1/12, Cν=nothing, Cκ=nothing,
                                        Cb=0.0, ν=ν₀, κ=κ₀)</code></pre><p>Returns parameters of type <code>FT</code> for the <code>VerstappenAnisotropicMinimumDissipation</code> turbulence closure.</p><p><strong>Keyword arguments</strong></p><pre><code class="language-none">- `C`  : Poincaré constant for both eddy viscosity and eddy diffusivities. `C` is overridden
         for eddy viscosity or eddy diffusivity if `Cν` or `Cκ` are set, respecitvely.
- `Cν` : Poincaré constant for momentum eddy viscosity.
- `Cκ` : Poincaré constant for tracer eddy diffusivities. If one number or function, the same
         number or function is applied to all tracers. If a `NamedTuple`, it must possess
         a field specifying the Poncaré constant for every tracer.
- `Cb` : Buoyancy modification multiplier (`Cb = 0` turns it off, `Cb = 1` turns it on)
- `ν`  : Constant background viscosity for momentum.
- `κ`  : Constant background diffusivity for tracer. If a single number, the same background
         diffusivity is applied to all tracers. If a `NamedTuple`, it must possess a field
         specifying a background diffusivity for every tracer.</code></pre><p>By default: <code>C = Cν = Cκ</code> = 1/12, which is appropriate for a finite-volume method employing a second-order advection scheme, <code>Cb</code> = 0, which terms off the buoyancy modification term, the molecular viscosity of seawater at 20 deg C and 35 psu is used for <code>ν</code>, and the molecular diffusivity of heat in seawater at 20 deg C and 35 psu is used for <code>κ</code>.</p><p><code>Cν</code> or <code>Cκ</code> may be constant numbers, or functions of <code>x, y, z</code>.</p><p><strong>Example</strong></p><p>julia&gt; pretty<em>diffusive</em>closure = AnisotropicMinimumDissipation(C=1/2) VerstappenAnisotropicMinimumDissipation{Float64} turbulence closure with:            Poincaré constant for momentum eddy viscosity Cν: 0.5     Poincaré constant for tracer(s) eddy diffusivit(ies) Cκ: 0.5                         Buoyancy modification multiplier Cb: 0.0                 Background diffusivit(ies) for tracer(s), κ: 1.46e-7              Background kinematic viscosity for momentum, ν: 1.05e-6</p><p>julia&gt; const Δz = 0.5; # grid resolution at surface</p><p>julia&gt; surface<em>enhanced</em>tracer<em>C(x, y, z) = 1/12 * (1 + exp((z + Δz/2) / 8Δz)) surface</em>enhanced<em>tracer</em>C (generic function with 1 method)</p><p>julia&gt; fancy<em>closure = AnisotropicMinimumDissipation(Cκ=surface</em>enhanced<em>tracer</em>C) VerstappenAnisotropicMinimumDissipation{Float64} turbulence closure with:            Poincaré constant for momentum eddy viscosity Cν: 0.08333333333333333     Poincaré constant for tracer(s) eddy diffusivit(ies) Cκ: surface<em>enhanced</em>tracer_C                         Buoyancy modification multiplier Cb: 0.0                 Background diffusivit(ies) for tracer(s), κ: 1.46e-7              Background kinematic viscosity for momentum, ν: 1.05e-6</p><p>julia&gt; tracer<em>specific</em>closure = AnisotropicMinimumDissipation(Cκ=(c₁=1/12, c₂=1/6)) VerstappenAnisotropicMinimumDissipation{Float64} turbulence closure with:            Poincaré constant for momentum eddy viscosity Cν: 0.08333333333333333     Poincaré constant for tracer(s) eddy diffusivit(ies) Cκ: (c₁ = 0.08333333333333333, c₂ = 0.16666666666666666)                         Buoyancy modification multiplier Cb: 0.0                 Background diffusivit(ies) for tracer(s), κ: 1.46e-7              Background kinematic viscosity for momentum, ν: 1.05e-6</p><p><strong>References</strong></p><p>Vreugdenhil C., and Taylor J. (2018), &quot;Large-eddy simulations of stratified plane Couette     flow using the anisotropic minimum-dissipation model&quot;, Physics of Fluids 30, 085104.</p><p>Verstappen, R. (2018), &quot;How much eddy dissipation is needed to counterbalance the nonlinear     production of small, unresolved scales in a large-eddy simulation of turbulence?&quot;,     Computers &amp; Fluids 176, pp. 276-284.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/TurbulenceClosures/turbulence_closure_implementations/verstappen_anisotropic_minimum_dissipation.jl#L29-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.∇_κ_∇c-Union{Tuple{tracer_index}, Tuple{Any,Any,Any,Any,Any,Oceananigans.TurbulenceClosures.AbstractAnisotropicMinimumDissipation,Any,Val{tracer_index},Any,Vararg{Any,N} where N}} where tracer_index" href="#Oceananigans.TurbulenceClosures.∇_κ_∇c-Union{Tuple{tracer_index}, Tuple{Any,Any,Any,Any,Any,Oceananigans.TurbulenceClosures.AbstractAnisotropicMinimumDissipation,Any,Val{tracer_index},Any,Vararg{Any,N} where N}} where tracer_index"><code>Oceananigans.TurbulenceClosures.∇_κ_∇c</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∇_κ_∇c(i, j, k, grid, clock, c, tracer_index, closure, diffusivities)</code></pre><p>Return the diffusive flux divergence <code>∇ ⋅ (κ ∇ c)</code> for the turbulence <code>closure</code>, where <code>c</code> is an array of scalar data located at cell centers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/TurbulenceClosures/turbulence_closure_implementations/verstappen_anisotropic_minimum_dissipation.jl#L159-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.BlasiusSmagorinsky" href="#Oceananigans.TurbulenceClosures.BlasiusSmagorinsky"><code>Oceananigans.TurbulenceClosures.BlasiusSmagorinsky</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BlasiusSmagorinsky{ML, FT}</code></pre><p>Parameters for the version of the Smagorinsky closure used in the UK Met Office code Blasius, according to Polton and Belcher (2007).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/TurbulenceClosures/turbulence_closure_implementations/blasius_smagorinsky.jl#L6-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.BlasiusSmagorinsky" href="#Oceananigans.TurbulenceClosures.BlasiusSmagorinsky"><code>Oceananigans.TurbulenceClosures.BlasiusSmagorinsky</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BlasiusSmagorinsky(FT=Float64; Pr=1.0, ν=1.05e-6, κ=1.46e-7)</code></pre><p>Returns a <code>BlasiusSmagorinsky</code> closure object of type <code>FT</code>.</p><p><strong>Keyword arguments</strong></p><pre><code class="language-none">- `Pr` : Turbulent Prandtl numbers for each tracer. Either a constant applied to every
         tracer, or a `NamedTuple` with fields for each tracer individually.
- `ν`  : Constant background viscosity for momentum
- `κ`  : Constant background diffusivity for tracer. Can either be a single number
         applied to all tracers, or `NamedTuple` of diffusivities corresponding to each
         tracer.</code></pre><p><strong>References</strong></p><p>Polton, J. A., and Belcher, S. E. (2007), &quot;Langmuir turbulence and deeply penetrating jets     in an unstratified mixed layer.&quot; Journal of Geophysical Research: Oceans.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/TurbulenceClosures/turbulence_closure_implementations/blasius_smagorinsky.jl#L25-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.AnisotropicDiffusivity" href="#Oceananigans.TurbulenceClosures.AnisotropicDiffusivity"><code>Oceananigans.TurbulenceClosures.AnisotropicDiffusivity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AnisotropicDiffusivity{NX, NY, NZ, KX, KY, KZ}</code></pre><p>Parameters for anisotropic diffusivity models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_diffusivity.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.AnisotropicDiffusivity" href="#Oceananigans.TurbulenceClosures.AnisotropicDiffusivity"><code>Oceananigans.TurbulenceClosures.AnisotropicDiffusivity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AnisotropicDiffusivity(; νx=ν₀, νy=ν₀, νz=ν₀, κx=κ₀, κy=κ₀, κz=κ₀,
                         νh=nothing, κh=nothing)</code></pre><p>Returns parameters for a closure with a diagonal diffusivity tensor with heterogeneous &#39;anisotropic&#39; components labeled by <code>x</code>, <code>y</code>, <code>z</code>. Each component may be a number or function. The tracer diffusivities <code>κx</code>, <code>κy</code>, and <code>κz</code> may be <code>NamedTuple</code>s with fields corresponding to each tracer, or a single number or function to be a applied to all tracers.</p><p>If <code>νh</code> or <code>κh</code> are provided, then <code>νx = νy = νh</code>, and <code>κx = κy = κh</code>, respectively.</p><p>By default, a viscosity of <code>ν₀ = 1.05×10⁻⁶</code> m² s⁻¹ is used for all viscosity components and a diffusivity of <code>κ₀ = 1.46×10⁻⁷</code> m² s⁻¹ is used for all diffusivity components for every tracer. These values are the approximate viscosity and thermal diffusivity for seawater at 20°C and 35 psu, according to Sharqawy et al., &quot;Thermophysical properties of seawater: A review of existing correlations and data&quot; (2010).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_diffusivity.jl#L15-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.RozemaAnisotropicMinimumDissipation" href="#Oceananigans.TurbulenceClosures.RozemaAnisotropicMinimumDissipation"><code>Oceananigans.TurbulenceClosures.RozemaAnisotropicMinimumDissipation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RozemaAnisotropicMinimumDissipation(FT=Float64; C=0.33, ν=1.05e-6, κ=1.46e-7)</code></pre><p>Returns a <code>RozemaAnisotropicMinimumDissipation</code> closure object of type <code>FT</code> with</p><pre><code class="language-none">* `C` : Poincaré constant
* `ν` : &#39;molecular&#39; background viscosity
* `κ` : &#39;molecular&#39; background diffusivity for each tracer</code></pre><p>See Rozema et al., &quot; (2015)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/TurbulenceClosures/turbulence_closure_implementations/rozema_anisotropic_minimum_dissipation.jl#L12-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.TwoDimensionalLeith" href="#Oceananigans.TurbulenceClosures.TwoDimensionalLeith"><code>Oceananigans.TurbulenceClosures.TwoDimensionalLeith</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TwoDimensionalLeith{FT} &lt;: AbstractLeith{FT}</code></pre><p>Parameters for the 2D Leith turbulence closure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.TwoDimensionalLeith" href="#Oceananigans.TurbulenceClosures.TwoDimensionalLeith"><code>Oceananigans.TurbulenceClosures.TwoDimensionalLeith</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TwoDimensionalLeith([FT=Float64;] C=0.3, C_Redi=1, C_GM=1)</code></pre><p>Return a <code>TwoDimensionalLeith</code> type associated with the turbulence closure proposed by Leith (1965) and Fox-Kemper &amp; Menemenlis (2008) which has an eddy viscosity of the form</p><pre><code class="language-none">`νₑ = (C * Δᶠ)³ * √(|∇h ζ|² + |∇h ∂z w|²)`</code></pre><p>and an eddy diffusivity of the form...</p><p>where <code>Δᶠ</code> is the filter width, <code>ζ = ∂x v - ∂y u</code> is the vertical vorticity, and <code>C</code> is a model constant.</p><p><strong>Keyword arguments</strong></p><pre><code class="language-none">- `C`      : Model constant
- `C_Redi` : Coefficient for down-gradient tracer diffusivity for each tracer.
             Either a constant applied to every tracer, or a `NamedTuple` with fields
             for each tracer individually.
- `C_GM`   : Coefficient for down-gradient tracer diffusivity for each tracer.
             Either a constant applied to every tracer, or a `NamedTuple` with fields
             for each tracer individually.</code></pre><p><strong>References</strong></p><p>Leith, C. E. (1968). &quot;Diffusion Approximation for Two‐Dimensional Turbulence&quot;, The Physics of     Fluids 11, 671. doi: 10.1063/1.1691968</p><p>Fox‐Kemper, B., &amp; D. Menemenlis (2008), &quot;Can large eddy simulation techniques improve mesoscale rich     ocean models?&quot;, in Ocean Modeling in an Eddying Regime, Geophys. Monogr. Ser., vol. 177, pp. 319–337.     doi: 10.1029/177GM19</p><p>Pearson, B. et al. (2017) , &quot;Evaluation of scale-aware subgrid mesoscale eddy models in a global eddy     rich model&quot;, Ocean Modelling 115, 42-58. doi: 10.1016/j.ocemod.2017.05.007</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl#L24-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.∇_κ_∇c-Tuple{Any,Any,Any,Any,Any,Oceananigans.TurbulenceClosures.AbstractLeith,Any,Any,Any,Any,Any}" href="#Oceananigans.TurbulenceClosures.∇_κ_∇c-Tuple{Any,Any,Any,Any,Any,Oceananigans.TurbulenceClosures.AbstractLeith,Any,Any,Any,Any,Any}"><code>Oceananigans.TurbulenceClosures.∇_κ_∇c</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∇_κ_∇c(i, j, k, grid, clock, c, closure, diffusivities)</code></pre><p>Return the diffusive flux divergence <code>∇ ⋅ (κ ∇ c)</code> for the turbulence <code>closure</code>, where <code>c</code> is an array of scalar data located at cell centers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl#L200-L205">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.GiB" href="#Oceananigans.Utils.GiB"><code>Oceananigans.Utils.GiB</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">GiB</code></pre><p>A <code>Float64</code> constant equal to 1024<code>MiB</code>. Useful for increasing the clarity of scripts, e.g. <code>max_filesize = 50GiB</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Utils/units.jl#L117-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.KiB" href="#Oceananigans.Utils.KiB"><code>Oceananigans.Utils.KiB</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">KiB</code></pre><p>A <code>Float64</code> constant equal to 1024.0. Useful for increasing the clarity of scripts, e.g. <code>max_filesize = 250KiB</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Utils/units.jl#L103-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.MiB" href="#Oceananigans.Utils.MiB"><code>Oceananigans.Utils.MiB</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">MiB</code></pre><p>A <code>Float64</code> constant equal to 1024<code>KiB</code>. Useful for increasing the clarity of scripts, e.g. <code>max_filesize = 100MiB</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Utils/units.jl#L110-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.TiB" href="#Oceananigans.Utils.TiB"><code>Oceananigans.Utils.TiB</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">TiB</code></pre><p>A <code>Float64</code> constant equal to 1024<code>GiB</code>. Useful for increasing the clarity of scripts, e.g. <code>max_filesize = 2TiB</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Utils/units.jl#L124-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.day" href="#Oceananigans.Utils.day"><code>Oceananigans.Utils.day</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">day</code></pre><p>A <code>Float64</code> constant equal to 24<code>hours</code>. Useful for increasing the clarity of scripts, e.g. <code>stop_time = 1day</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Utils/units.jl#L47-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.days" href="#Oceananigans.Utils.days"><code>Oceananigans.Utils.days</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">days</code></pre><p>A <code>Float64</code> constant equal to 24<code>hours</code>. Useful for increasing the clarity of scripts, e.g. <code>stop_time = 7days</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Utils/units.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.hour" href="#Oceananigans.Utils.hour"><code>Oceananigans.Utils.hour</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">hour</code></pre><p>A <code>Float64</code> constant equal to 60<code>minutes</code>. Useful for increasing the clarity of scripts, e.g. <code>Δt = 1hour</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Utils/units.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.hours" href="#Oceananigans.Utils.hours"><code>Oceananigans.Utils.hours</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">hours</code></pre><p>A <code>Float64</code> constant equal to 60<code>minutes</code>. Useful for increasing the clarity of scripts, e.g. <code>Δt = 3hours</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Utils/units.jl#L40-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.kilometer" href="#Oceananigans.Utils.kilometer"><code>Oceananigans.Utils.kilometer</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">kilometer</code></pre><p>A <code>Float64</code> constant equal to 1000<code>meters</code>. Useful for increasing the clarity of scripts, e.g. <code>Lx = 1kilometer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Utils/units.jl#L89-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.kilometers" href="#Oceananigans.Utils.kilometers"><code>Oceananigans.Utils.kilometers</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">kilometers</code></pre><p>A <code>Float64</code> constant equal to 1000<code>meters</code>. Useful for increasing the clarity of scripts, e.g. <code>Lx = 5000kilometers</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Utils/units.jl#L96-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.meter" href="#Oceananigans.Utils.meter"><code>Oceananigans.Utils.meter</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">meter</code></pre><p>A <code>Float64</code> constant equal to 1.0. Useful for increasing the clarity of scripts, e.g. <code>Lx = 1meter</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Utils/units.jl#L75-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.meters" href="#Oceananigans.Utils.meters"><code>Oceananigans.Utils.meters</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">meters</code></pre><p>A <code>Float64</code> constant equal to 1.0. Useful for increasing the clarity of scripts, e.g. <code>Lx = 50meters</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Utils/units.jl#L82-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.minute" href="#Oceananigans.Utils.minute"><code>Oceananigans.Utils.minute</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">minute</code></pre><p>A <code>Float64</code> constant equal to 60<code>seconds</code>. Useful for increasing the clarity of scripts, e.g. <code>Δt = 1minute</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Utils/units.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.minutes" href="#Oceananigans.Utils.minutes"><code>Oceananigans.Utils.minutes</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">minutes</code></pre><p>A <code>Float64</code> constant equal to 60<code>seconds</code>. Useful for increasing the clarity of scripts, e.g. <code>Δt = 15minutes</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Utils/units.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.second" href="#Oceananigans.Utils.second"><code>Oceananigans.Utils.second</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">second</code></pre><p>A <code>Float64</code> constant equal to 1.0. Useful for increasing the clarity of scripts, e.g. <code>Δt = 1second</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Utils/units.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.seconds" href="#Oceananigans.Utils.seconds"><code>Oceananigans.Utils.seconds</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">seconds</code></pre><p>A <code>Float64</code> constant equal to 1.0. Useful for increasing the clarity of scripts, e.g. <code>Δt = 7seconds</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Utils/units.jl#L12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.year" href="#Oceananigans.Utils.year"><code>Oceananigans.Utils.year</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">year</code></pre><p>A <code>Float64</code> constant equal to 365<code>days</code>. Useful for increasing the clarity of scripts, e.g. <code>stop_time = 1year</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Utils/units.jl#L61-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.years" href="#Oceananigans.Utils.years"><code>Oceananigans.Utils.years</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">years</code></pre><p>A <code>Float64</code> constant equal to 365<code>days</code>. Useful for increasing the clarity of scripts, e.g. <code>stop_time = 100years</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Utils/units.jl#L68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.prettytime-Tuple{Any}" href="#Oceananigans.Utils.prettytime-Tuple{Any}"><code>Oceananigans.Utils.prettytime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">prettytime(t)</code></pre><p>Convert a floating point value <code>t</code> representing an amount of time in seconds to a more human-friendly formatted string with three decimal places. Depending on the value of <code>t</code> the string will be formatted to show <code>t</code> in nanoseconds (ns), microseconds (μs), milliseconds (ms), seconds, minutes, hours, days, or years.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Utils/pretty_time.jl#L6-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.pretty_filesize" href="#Oceananigans.Utils.pretty_filesize"><code>Oceananigans.Utils.pretty_filesize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pretty_filesize(s, suffix=&quot;B&quot;)</code></pre><p>Convert a floating point value <code>s</code> representing a file size to a more human-friendly formatted string with one decimal places with a <code>suffix</code> defaulting to &quot;B&quot;. Depending on the value of <code>s</code> the string will be formatted to show <code>s</code> using an SI prefix from bytes, kiB (1024 bytes), MiB (1024² bytes), and so on up to YiB (1024⁸ bytes).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Utils/pretty_filesize.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.cell_advection_timescale-NTuple{4,Any}" href="#Oceananigans.Utils.cell_advection_timescale-NTuple{4,Any}"><code>Oceananigans.Utils.cell_advection_timescale</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns the time-scale for advection on a regular grid across a single grid cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Utils/cell_advection_timescale.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.with_tracers-Tuple{Any,NamedTuple,Any}" href="#Oceananigans.Utils.with_tracers-Tuple{Any,NamedTuple,Any}"><code>Oceananigans.Utils.with_tracers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">with_tracers(tracer_names, initial_tuple, tracer_default)</code></pre><p>Create a tuple corresponding to the solution variables <code>u</code>, <code>v</code>, <code>w</code>, and <code>tracer_names</code>. <code>initial_tuple</code> is a <code>NamedTuple</code> that at least has fields <code>u</code>, <code>v</code>, and <code>w</code>, and may have some fields corresponding to the names in <code>tracer_names</code>. <code>tracer_default</code> is a function that produces a default tuple value for each tracer if not included in <code>initial_tuple</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/Utils/with_tracers.jl#L1-L9">source</a></section></article><h2 id="Abstract-operations"><a class="docs-heading-anchor" href="#Abstract-operations">Abstract operations</a><a id="Abstract-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-operations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.@unary-Tuple" href="#Oceananigans.AbstractOperations.@unary-Tuple"><code>Oceananigans.AbstractOperations.@unary</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@unary op1 op2 op3...</code></pre><p>Turn each unary function in the list <code>(op1, op2, op3...)</code> into a unary operator on <code>Oceananigans.Fields</code> for use in <code>AbstractOperations</code>.</p><p>Note: a unary function is a function with one argument: for example, <code>sin(x)</code> is a unary function.</p><p>Also note: a unary function in <code>Base</code> must be imported to be extended: use <code>import Base: op; @unary op</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using Oceananigans, Oceananigans.Grids, Oceananigans.AbstractOperations

julia&gt; square_it(x) = x^2
square_it (generic function with 1 method)

julia&gt; @unary square_it
Set{Any} with 7 elements:
  :sqrt
  :square_it
  :cos
  :exp
  :-
  :tanh
  :sin

julia&gt; c = Field(Center, Center, Center, CPU(), RegularCartesianGrid(size=(1, 1, 1), extent=(1, 1, 1)));

julia&gt; square_it(c)
UnaryOperation at (Center, Center, Center)
├── grid: RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1)
│   └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]
└── tree:
    square_it at (Center, Center, Center) via identity
    └── Field located at (Center, Center, Center)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/AbstractOperations/unary_operations.jl#L39-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.@binary-Tuple" href="#Oceananigans.AbstractOperations.@binary-Tuple"><code>Oceananigans.AbstractOperations.@binary</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@binary op1 op2 op3...</code></pre><p>Turn each binary function in the list <code>(op1, op2, op3...)</code> into a binary operator on <code>Oceananigans.Fields</code> for use in <code>AbstractOperations</code>.</p><p>Note: a binary function is a function with two arguments: for example, <code>+(x, y)</code> is a binary function.</p><p>Also note: a binary function in <code>Base</code> must be imported to be extended: use <code>import Base: op; @binary op</code>.</p><p><strong>Example</strong></p><p>```jldoctest julia&gt; using Oceananigans, Oceananigans.AbstractOperations, Oceananigans.Grids</p><p>julia&gt; plus<em>or</em>times(x, y) = x &lt; 0 ? x + y : x * y plus<em>or</em>times (generic function with 1 method)</p><p>julia&gt; @binary plus<em>or</em>times 6-element Array{Any,1}:  :+  :-  :/  :^  :*  :plus<em>or</em>times</p><p>julia&gt; c, d = (Field(Center, Center, Center, CPU(), RegularCartesianGrid(size=(1, 1, 1), extent=(1, 1, 1))) for i = 1:2);</p><p>julia&gt; plus<em>or</em>times(c, d) BinaryOperation at (Center, Center, Center) ├── grid: RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1) │   └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0] └── tree:     plus<em>or</em>times at (Center, Center, Center) via identity     ├── Field located at (Center, Center, Center)     └── Field located at (Center, Center, Center)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/AbstractOperations/binary_operations.jl#L94-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.@multiary-Tuple" href="#Oceananigans.AbstractOperations.@multiary-Tuple"><code>Oceananigans.AbstractOperations.@multiary</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@multiary op1 op2 op3...</code></pre><p>Turn each multiary operator in the list <code>(op1, op2, op3...)</code> into a multiary operator on <code>Oceananigans.Fields</code> for use in <code>AbstractOperations</code>.</p><p>Note that a multiary operator:     * is a function with two or more arguments: for example, <code>+(x, y, z)</code> is a multiary function;     * must be imported to be extended if part of <code>Base</code>: use <code>import Base: op; @multiary op</code>;     * can only be called on <code>Oceananigans.Field</code>s if the &quot;location&quot; is noted explicitly; see example.</p><p><strong>Example</strong></p><p>```jldoctest julia&gt; using Oceananigans, Oceananigans.Grids, Oceananigans.AbstractOperations</p><p>julia&gt; harmonic<em>plus(a, b, c) = 1/3 * (1/a + 1/b + 1/c) harmonic</em>plus(generic function with 1 method)</p><p>julia&gt; c, d, e = Tuple(Field(Center, Center, Center, CPU(), RegularCartesianGrid(size=(1, 1, 1), extent=(1, 1, 1))) for i = 1:3);</p><p>julia&gt; harmonic_plus(c, d, e) # before magic @multiary transformation BinaryOperation at (Center, Center, Center) ├── grid: RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1) │   └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0] └── tree:     * at (Center, Center, Center) via identity     ├── 0.3333333333333333     └── + at (Center, Center, Center)         ├── / at (Center, Center, Center) via identity         │   ├── 1         │   └── Field located at (Center, Center, Center)         ├── / at (Center, Center, Center) via identity         │   ├── 1         │   └── Field located at (Center, Center, Center)         └── / at (Center, Center, Center) via identity             ├── 1             └── Field located at (Center, Center, Center)</p><p>julia&gt; @multiary harmonic<em>plus Set{Any} with 3 elements:   :+   :harmonic</em>plus   :*</p><p>julia&gt; harmonic<em>plus(c, d, e) MultiaryOperation at (Center, Center, Center) ├── grid: RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1) │   └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0] └── tree:     harmonic</em>plus at (Center, Center, Center)     ├── Field located at (Center, Center, Center)     ├── Field located at (Center, Center, Center)     └── Field located at (Center, Center, Center)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/AbstractOperations/multiary_operations.jl#L52-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.∂x-Tuple{Union{Type{Center}, Type{Face}}}" href="#Oceananigans.AbstractOperations.∂x-Tuple{Union{Type{Center}, Type{Face}}}"><code>Oceananigans.AbstractOperations.∂x</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the x-derivative function acting at (<code>X</code>, <code>Any</code>, <code>Any</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/AbstractOperations/derivatives.jl#L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.∂x-Union{Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}, Tuple{Z}, Tuple{Y}, Tuple{X}} where Z where Y where X" href="#Oceananigans.AbstractOperations.∂x-Union{Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}, Tuple{Z}, Tuple{Y}, Tuple{X}} where Z where Y where X"><code>Oceananigans.AbstractOperations.∂x</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∂x(a::AbstractField)</code></pre><p>Return an abstract representation of a x-derivative acting on <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/AbstractOperations/derivatives.jl#L82-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.∂x-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{Tuple,Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}} where Z where Y where X" href="#Oceananigans.AbstractOperations.∂x-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{Tuple,Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}} where Z where Y where X"><code>Oceananigans.AbstractOperations.∂x</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∂x(L::Tuple, a::AbstractField)</code></pre><p>Return an abstract representation of an x-derivative acting on <code>a</code> followed by interpolation to <code>L</code>, where <code>L</code> is a 3-tuple of <code>Face</code>s and <code>Center</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/AbstractOperations/derivatives.jl#L54-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.∂y-Tuple{Union{Type{Center}, Type{Face}}}" href="#Oceananigans.AbstractOperations.∂y-Tuple{Union{Type{Center}, Type{Face}}}"><code>Oceananigans.AbstractOperations.∂y</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the y-derivative function acting at (<code>Any</code>, <code>Y</code>, <code>Any</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/AbstractOperations/derivatives.jl#L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.∂y-Union{Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}, Tuple{Z}, Tuple{Y}, Tuple{X}} where Z where Y where X" href="#Oceananigans.AbstractOperations.∂y-Union{Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}, Tuple{Z}, Tuple{Y}, Tuple{X}} where Z where Y where X"><code>Oceananigans.AbstractOperations.∂y</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∂y(a::AbstractField)</code></pre><p>Return an abstract representation of a y-derivative acting on <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/AbstractOperations/derivatives.jl#L89-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.∂y-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{Tuple,Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}} where Z where Y where X" href="#Oceananigans.AbstractOperations.∂y-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{Tuple,Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}} where Z where Y where X"><code>Oceananigans.AbstractOperations.∂y</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∂y(L::Tuple, a::AbstractField)</code></pre><p>Return an abstract representation of a y-derivative acting on <code>a</code> followed by interpolation to <code>L</code>, where <code>L</code> is a 3-tuple of <code>Face</code>s and <code>Center</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/AbstractOperations/derivatives.jl#L63-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.∂z-Tuple{Union{Type{Center}, Type{Face}}}" href="#Oceananigans.AbstractOperations.∂z-Tuple{Union{Type{Center}, Type{Face}}}"><code>Oceananigans.AbstractOperations.∂z</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the z-derivative function acting at (<code>Any</code>, <code>Any</code>, <code>Z</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/AbstractOperations/derivatives.jl#L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.∂z-Union{Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}, Tuple{Z}, Tuple{Y}, Tuple{X}} where Z where Y where X" href="#Oceananigans.AbstractOperations.∂z-Union{Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}, Tuple{Z}, Tuple{Y}, Tuple{X}} where Z where Y where X"><code>Oceananigans.AbstractOperations.∂z</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∂z(a::AbstractField)</code></pre><p>Return an abstract representation of a z-derivative acting on <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/AbstractOperations/derivatives.jl#L95-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.∂z-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{Tuple,Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}} where Z where Y where X" href="#Oceananigans.AbstractOperations.∂z-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{Tuple,Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}} where Z where Y where X"><code>Oceananigans.AbstractOperations.∂z</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∂z(L::Tuple, a::AbstractField)</code></pre><p>Return an abstract representation of a z-derivative acting on <code>a</code> followed by interpolation to <code>L</code>, where <code>L</code> is a 3-tuple of <code>Face</code>s and <code>Center</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/47caa85138047acb4584cf97092c62c3e59b3543/src/AbstractOperations/derivatives.jl#L72-L77">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../references/">« References</a><a class="docs-footer-nextpage" href="../function_index/">Function index »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 8 February 2021 15:36">Monday 8 February 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

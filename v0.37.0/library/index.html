<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · Oceananigans.jl</title><link rel="canonical" href="https://clima.github.io/OceananigansDocumentation/latest/library/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Oceananigans.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../installation_instructions/">Installation instructions</a></li><li><a class="tocitem" href="../using_gpus/">Using GPUs</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../generated/one_dimensional_diffusion/">One-dimensional diffusion</a></li><li><a class="tocitem" href="../generated/two_dimensional_turbulence/">Two-dimensional turbulence</a></li><li><a class="tocitem" href="../generated/ocean_wind_mixing_and_convection/">Ocean wind mixing and convection</a></li><li><a class="tocitem" href="../generated/ocean_convection_with_plankton/">Ocean convection with plankton</a></li><li><a class="tocitem" href="../generated/internal_wave/">Internal wave</a></li><li><a class="tocitem" href="../generated/langmuir_turbulence/">Langmuir turbulence</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Model setup</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../model_setup/overview/">Overview</a></li><li><a class="tocitem" href="../model_setup/architecture/">Architecture</a></li><li><a class="tocitem" href="../model_setup/number_type/">Number type</a></li><li><a class="tocitem" href="../model_setup/grids/">Grid</a></li><li><a class="tocitem" href="../model_setup/clock/">Clock</a></li><li><a class="tocitem" href="../model_setup/coriolis/">Coriolis (rotation)</a></li><li><a class="tocitem" href="../model_setup/tracers/">Tracers</a></li><li><a class="tocitem" href="../model_setup/buoyancy_and_equation_of_state/">Buoyancy and equation of state</a></li><li><a class="tocitem" href="../model_setup/boundary_conditions/">Boundary conditions</a></li><li><a class="tocitem" href="../model_setup/forcing_functions/">Forcing functions</a></li><li><a class="tocitem" href="../model_setup/turbulent_diffusivity_closures_and_les_models/">Turbulent diffusivity closures and LES models</a></li><li><a class="tocitem" href="../model_setup/diagnostics/">Diagnostics</a></li><li><a class="tocitem" href="../model_setup/output_writers/">Output writers</a></li><li><a class="tocitem" href="../model_setup/checkpointing/">Checkpointing</a></li><li><a class="tocitem" href="../model_setup/time_stepping/">Time stepping</a></li><li><a class="tocitem" href="../model_setup/setting_initial_conditions/">Setting initial conditions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Physics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../physics/navier_stokes_and_tracer_conservation/">Navier-Stokes and tracer conservation equations</a></li><li><a class="tocitem" href="../physics/coordinate_system_and_notation/">Coordinate system and notation</a></li><li><a class="tocitem" href="../physics/boussinesq_approximation/">The Boussinesq approximation</a></li><li><a class="tocitem" href="../physics/coriolis_forces/">Coriolis forces</a></li><li><a class="tocitem" href="../physics/buoyancy_and_equations_of_state/">Buoyancy model and equations of state</a></li><li><a class="tocitem" href="../physics/turbulence_closures/">Turbulence closures</a></li><li><a class="tocitem" href="../physics/surface_gravity_waves/">Surface gravity waves and the Craik-Leibovich approximation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Numerical implementation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../numerical_implementation/pressure_decomposition/">Pressure decomposition</a></li><li><a class="tocitem" href="../numerical_implementation/time_stepping/">Time stepping</a></li><li><a class="tocitem" href="../numerical_implementation/finite_volume/">Finite volume method</a></li><li><a class="tocitem" href="../numerical_implementation/spatial_operators/">Spatial operators</a></li><li><a class="tocitem" href="../numerical_implementation/boundary_conditions/">Boundary conditions</a></li><li><a class="tocitem" href="../numerical_implementation/poisson_solvers/">Poisson solvers</a></li><li><a class="tocitem" href="../numerical_implementation/large_eddy_simulation/">Large eddy simulation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Verification experiments</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../verification/taylor_green_vortex/">Taylor-Green vortex</a></li><li><a class="tocitem" href="../verification/stratified_couette_flow/">Stratified Couette flow</a></li><li><a class="tocitem" href="../verification/convergence_tests/">Convergence tests</a></li></ul></li><li><a class="tocitem" href="../gallery/">Gallery</a></li><li><a class="tocitem" href="../benchmarks/">Performance benchmarks</a></li><li><a class="tocitem" href="../contributing/">Contributor&#39;s guide</a></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">Appendix</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../appendix/staggered_grid/">Staggered grid</a></li><li><a class="tocitem" href="../appendix/fractional_step/">Fractional step method</a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li><li class="is-active"><a class="tocitem" href>Library</a><ul class="internal"><li><a class="tocitem" href="#Advection"><span>Advection</span></a></li><li><a class="tocitem" href="#Architectures"><span>Architectures</span></a></li><li><a class="tocitem" href="#Boundary-conditions"><span>Boundary conditions</span></a></li><li><a class="tocitem" href="#Buoyancy"><span>Buoyancy</span></a></li><li><a class="tocitem" href="#Coriolis"><span>Coriolis</span></a></li><li><a class="tocitem" href="#Diagnostics"><span>Diagnostics</span></a></li><li><a class="tocitem" href="#Fields"><span>Fields</span></a></li><li><a class="tocitem" href="#Forcing"><span>Forcing</span></a></li><li><a class="tocitem" href="#Grids"><span>Grids</span></a></li><li><a class="tocitem" href="#Logger"><span>Logger</span></a></li><li><a class="tocitem" href="#Models"><span>Models</span></a></li><li><a class="tocitem" href="#Output-writers"><span>Output writers</span></a></li><li><a class="tocitem" href="#Time-steppers"><span>Time steppers</span></a></li><li><a class="tocitem" href="#Simulations"><span>Simulations</span></a></li><li><a class="tocitem" href="#Tubrulence-closures"><span>Tubrulence closures</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li><li><a class="tocitem" href="#Abstract-operations"><span>Abstract operations</span></a></li></ul></li><li><a class="tocitem" href="../function_index/">Function index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/CliMA/Oceananigans.jl/blob/master/docs/src/library.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><p>Documenting the public user interface.</p><h2 id="Advection"><a class="docs-heading-anchor" href="#Advection">Advection</a><a id="Advection-1"></a><a class="docs-heading-anchor-permalink" href="#Advection" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.div_uc-NTuple{7,Any}" href="#Oceananigans.Advection.div_uc-NTuple{7,Any}"><code>Oceananigans.Advection.div_uc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">div_flux(i, j, k, grid, U, c)</code></pre><p>Calculates the divergence of the flux of a tracer quantity c being advected by a velocity field U = (u, v, w), ∇·(Uc),</p><pre><code class="language-none">1/V * [δxᶜᵃᵃ(Ax * u * ℑxᶠᵃᵃ(c)) + δyᵃᶜᵃ(Ay * v * ℑyᵃᶠᵃ(c)) + δzᵃᵃᶜ(Az * w * ℑzᵃᵃᶠ(c))]</code></pre><p>which will end up at the location <code>ccc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Advection/tracer_advection_operators.jl#L7-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.div_ũu-NTuple{6,Any}" href="#Oceananigans.Advection.div_ũu-NTuple{6,Any}"><code>Oceananigans.Advection.div_ũu</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">u∇u(i, j, k, grid, U)</code></pre><p>Calculate the advection of momentum in the x-direction U·∇u</p><pre><code class="language-none">1/Vᵘ * [δxᶠᵃᵃ(ℑxᶜᵃᵃ(Ax * u) * ℑxᶜᵃᵃ(u)) + δy_fca(ℑxᶠᵃᵃ(Ay * v) * ℑyᵃᶠᵃ(u)) + δz_fac(ℑxᶠᵃᵃ(Az * w) * ℑzᵃᵃᶠ(u))]</code></pre><p>which will end up at the location <code>fcc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Advection/momentum_advection_operators.jl#L7-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.div_ũv-NTuple{6,Any}" href="#Oceananigans.Advection.div_ũv-NTuple{6,Any}"><code>Oceananigans.Advection.div_ũv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">u∇v(i, j, k, grid, U)</code></pre><p>Calculates the advection of momentum in the y-direction U·∇v</p><pre><code class="language-none">1/Vʸ * [δx_cfa(ℑyᵃᶠᵃ(Ax * u) * ℑxᶠᵃᵃ(v)) + δyᵃᶠᵃ(ℑyᵃᶜᵃ(Ay * v) * ℑyᵃᶜᵃ(v)) + δz_afc(ℑxᶠᵃᵃ(Az * w) * ℑzᵃᵃᶠ(w))]</code></pre><p>which will end up at the location <code>cfc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Advection/momentum_advection_operators.jl#L22-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.div_ũw-NTuple{6,Any}" href="#Oceananigans.Advection.div_ũw-NTuple{6,Any}"><code>Oceananigans.Advection.div_ũw</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">u∇w(i, j, k, grid, U)</code></pre><p>Calculates the advection of momentum in the z-direction U·∇w</p><pre><code class="language-none">1/Vʷ * [δx_caf(ℑzᵃᵃᶠ(Ax * u) * ℑxᶠᵃᵃ(w)) + δy_acf(ℑzᵃᵃᶠ(Ay * v) * ℑyᵃᶠᵃ(w)) + δzᵃᵃᶠ(ℑzᵃᵃᶜ(Az * w) * ℑzᵃᵃᶜ(w))]</code></pre><p>which will end up at the location <code>ccf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Advection/momentum_advection_operators.jl#L37-L45">source</a></section></article><h2 id="Architectures"><a class="docs-heading-anchor" href="#Architectures">Architectures</a><a id="Architectures-1"></a><a class="docs-heading-anchor-permalink" href="#Architectures" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Architectures.AbstractArchitecture" href="#Oceananigans.Architectures.AbstractArchitecture"><code>Oceananigans.Architectures.AbstractArchitecture</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractArchitecture</code></pre><p>Abstract supertype for architectures supported by Oceananigans.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Architectures.jl#L12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Architectures.CPU" href="#Oceananigans.Architectures.CPU"><code>Oceananigans.Architectures.CPU</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CPU &lt;: AbstractArchitecture</code></pre><p>Run Oceananigans on one CPU node. Uses multiple threads if the environment variable <code>JULIA_NUM_THREADS</code> is set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Architectures.jl#L19-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Architectures.GPU" href="#Oceananigans.Architectures.GPU"><code>Oceananigans.Architectures.GPU</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GPU &lt;: AbstractArchitecture</code></pre><p>Run Oceananigans on a single NVIDIA CUDA GPU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Architectures.jl#L27-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Architectures.@hascuda-Tuple{Any}" href="#Oceananigans.Architectures.@hascuda-Tuple{Any}"><code>Oceananigans.Architectures.@hascuda</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@hascuda expr</code></pre><p>A macro to compile and execute <code>expr</code> only if CUDA is installed and available. Generally used to wrap expressions that can only be compiled if <code>CuArrays</code> and <code>CUDAnative</code> can be loaded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Architectures.jl#L34-L39">source</a></section></article><h2 id="Boundary-conditions"><a class="docs-heading-anchor" href="#Boundary-conditions">Boundary conditions</a><a id="Boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-conditions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.BCType" href="#Oceananigans.BoundaryConditions.BCType"><code>Oceananigans.BoundaryConditions.BCType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BCType</code></pre><p>Abstract supertype for boundary condition types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/BoundaryConditions/boundary_condition_types.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.Flux" href="#Oceananigans.BoundaryConditions.Flux"><code>Oceananigans.BoundaryConditions.Flux</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Flux</code></pre><p>A type specifying a boundary condition on the flux of a field.</p><p>The sign convention is such that a positive flux represents the flux of a quantity in the positive direction. For example, a positive vertical flux implies a quantity is fluxed upwards, in the +z direction.</p><p>Due to this convention, a positive flux applied to the top boundary specifies that a quantity is fluxed upwards across the top boundary and thus out of the domain. As a result, a positive flux applied to a top boundary leads to a reduction of that quantity in the interior of the domain; for example, a positive, upwards flux of heat at the top of the domain acts to cool the interior of the domain. Conversely, a positive flux applied to the bottom boundary leads to an increase of the quantity in the interior of the domain. The same logic holds for east, west, north, and south boundaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/BoundaryConditions/boundary_condition_types.jl#L17-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.Gradient" href="#Oceananigans.BoundaryConditions.Gradient"><code>Oceananigans.BoundaryConditions.Gradient</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Gradient</code></pre><p>A type specifying a boundary condition on the derivative or gradient of a field. Also called a Neumann boundary condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/BoundaryConditions/boundary_condition_types.jl#L36-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.NormalFlow" href="#Oceananigans.BoundaryConditions.NormalFlow"><code>Oceananigans.BoundaryConditions.NormalFlow</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NormalFlow</code></pre><p>A type specifying the component of a velocity field normal to a boundary.</p><p>Thus <code>NormalFlow</code> can only be applied to <code>u</code> along x, <code>v</code> along y, or <code>w</code> along z. For all other cases –- fields located at (Cell, Cell, Cell), or <code>u</code>, <code>v</code>, and <code>w</code> in (y, z), (x, z), and (x, y), respectively, either <code>Value</code>, <code>Gradient</code>, or <code>Flux</code> conditions must be used.</p><p>Note that <code>NormalFlow</code> differs from a zero <code>Value</code> boundary condition:  <code>Value</code> imposes values at cell centers, while <code>NormalFlow</code> imposes values <em>on</em> a boundary, at cell faces. Only wall-normal components of the velocity field are defined on cell faces with respect to the wall-normal direction, and therefore only wall-normal components of the velocity field are defined on boundaries.  Both tracers and wall-tangential components of velocity fields are defined at cell centers with respect to the wall-normal direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/BoundaryConditions/boundary_condition_types.jl#L52-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.Value" href="#Oceananigans.BoundaryConditions.Value"><code>Oceananigans.BoundaryConditions.Value</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Value</code></pre><p>A type specifying a boundary condition on the value of a field. Also called a Dirchlet boundary condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/BoundaryConditions/boundary_condition_types.jl#L44-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.BoundaryCondition" href="#Oceananigans.BoundaryConditions.BoundaryCondition"><code>Oceananigans.BoundaryConditions.BoundaryCondition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct BoundaryCondition{C&lt;:BCType, T}</code></pre><p>Container for boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/BoundaryConditions/boundary_condition.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.BoundaryCondition-Tuple{Any,Any}" href="#Oceananigans.BoundaryConditions.BoundaryCondition-Tuple{Any,Any}"><code>Oceananigans.BoundaryConditions.BoundaryCondition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">BoundaryCondition(BC, condition)</code></pre><p>Construct a boundary condition of type <code>BC</code> with a number or array as a <code>condition</code>.</p><p>Boundary condition types include <code>Periodic</code>, <code>Flux</code>, <code>Value</code>, <code>Gradient</code>, and <code>NormalFlow</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/BoundaryConditions/boundary_condition.jl#L12-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.BoundaryCondition-Tuple{Any,Function}" href="#Oceananigans.BoundaryConditions.BoundaryCondition-Tuple{Any,Function}"><code>Oceananigans.BoundaryConditions.BoundaryCondition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">BoundaryCondition(BC, condition::Function; parameters=nothing, discrete_form=false)</code></pre><p>Construct a boundary condition of type <code>BC</code> with a function boundary <code>condition</code>.</p><p>By default, the function boudnary <code>condition</code> is assumed to have the &#39;continuous form&#39; <code>condition(ξ, η, t)</code>, where <code>t</code> is time and <code>ξ</code> and <code>η</code> vary along the boundary. In particular:</p><ul><li>On <code>x</code>-boundaries, <code>condition(y, z, t)</code>.</li><li>On <code>y</code>-boundaries, <code>condition(x, z, t)</code>.</li><li>On <code>z</code>-boundaries, <code>condition(x, y, t)</code>.</li></ul><p>If <code>parameters</code> is not <code>nothing</code>, then function boundary conditions have the form <code>func(ξ, η, t, parameters)</code>, where <code>ξ</code> and <code>η</code> are spatial coordinates varying along the boundary as explained above.</p><p>If <code>discrete_form=true</code>, the function <code>condition</code> is assumed to have the &quot;discrete form&quot;,</p><pre><code class="language-none">`condition(i, j, grid, clock, state)`,</code></pre><p>where <code>i</code>, and <code>j</code> are indices that vary along the boundary. If <code>discrete_form=true</code> and <code>parameters</code> is not <code>nothing</code>, the function <code>condition</code> is called with</p><pre><code class="language-none">`condition(i, j, grid, clock, state, parameters)`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/BoundaryConditions/boundary_condition.jl#L21-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.CoordinateBoundaryConditions" href="#Oceananigans.BoundaryConditions.CoordinateBoundaryConditions"><code>Oceananigans.BoundaryConditions.CoordinateBoundaryConditions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CoordinateBoundaryConditions(left, right)</code></pre><p>A set of two <code>BoundaryCondition</code>s to be applied along a coordinate x, y, or z.</p><p>The <code>left</code> boundary condition is applied on the negative or lower side of the coordinate while the <code>right</code> boundary condition is applied on the positive or higher side.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/BoundaryConditions/coordinate_boundary_conditions.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.FieldBoundaryConditions" href="#Oceananigans.BoundaryConditions.FieldBoundaryConditions"><code>Oceananigans.BoundaryConditions.FieldBoundaryConditions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FieldBoundaryConditions</code></pre><p>An alias for <code>NamedTuple{(:x, :y, :z)}</code> that represents a set of three <code>CoordinateBoundaryCondition</code>s applied to a field along x, y, and z.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/BoundaryConditions/field_boundary_conditions.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.FieldBoundaryConditions-Tuple{Any,Any,Any}" href="#Oceananigans.BoundaryConditions.FieldBoundaryConditions-Tuple{Any,Any,Any}"><code>Oceananigans.BoundaryConditions.FieldBoundaryConditions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">FieldBoundaryConditions(x, y, z)</code></pre><p>Construct a <code>FieldBoundaryConditions</code> using a <code>CoordinateBoundaryCondition</code> for each of the <code>x</code>, <code>y</code>, and <code>z</code> coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/BoundaryConditions/field_boundary_conditions.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.FieldBoundaryConditions-Tuple{Any,Any}" href="#Oceananigans.BoundaryConditions.FieldBoundaryConditions-Tuple{Any,Any}"><code>Oceananigans.BoundaryConditions.FieldBoundaryConditions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">FieldBoundaryConditions(grid, loc;   east = DefaultBoundaryCondition(topology(grid, 1), loc[1]),
                                     west = DefaultBoundaryCondition(topology(grid, 1], loc[1]),
                                    south = DefaultBoundaryCondition(topology(grid, 2), loc[2]),
                                    north = DefaultBoundaryCondition(topology(grid, 2), loc[2]),
                                   bottom = DefaultBoundaryCondition(topology(grid, 3), loc[3]),
                                      top = DefaultBoundaryCondition(topology(grid, 3), loc[3]))</code></pre><p>Construct <code>FieldBoundaryConditions</code> for a field with location <code>loc</code> (a 3-tuple of <code>Face</code> or <code>Cell</code>) defined on <code>grid</code>.</p><p>Boundary conditions on <code>x</code>-, <code>y</code>-, and <code>z</code>-boundaries are specified via keyword arguments:</p><pre><code class="language-none">* `west` and `east` for the `-x` and `+x` boundary;
* `south` and `north` for the `-y` and `+y` boundary;
* `bottom` and `top` for the `-z` and `+z` boundary.</code></pre><p>Default boundary conditions depend on <code>topology(grid)</code> and <code>loc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/BoundaryConditions/field_boundary_conditions.jl#L52-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.TracerBoundaryConditions-Tuple{Any}" href="#Oceananigans.BoundaryConditions.TracerBoundaryConditions-Tuple{Any}"><code>Oceananigans.BoundaryConditions.TracerBoundaryConditions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">TracerBoundaryConditions(grid;   east = DefaultBoundaryCondition(topology(grid, 1), Cell),
                                 west = DefaultBoundaryCondition(topology(grid, 1), Cell),
                                south = DefaultBoundaryCondition(topology(grid, 2), Cell),
                                north = DefaultBoundaryCondition(topology(grid, 2), Cell),
                               bottom = DefaultBoundaryCondition(topology(grid, 3), Cell),
                                  top = DefaultBoundaryCondition(topology(grid, 3), Cell))</code></pre><p>Construct <code>FieldBoundaryConditions</code> for a tracer field on <code>grid</code>. Boundary conditions on <code>x</code>-, <code>y</code>-, and <code>z</code>-boundaries are specified via keyword arguments:</p><pre><code class="language-none">* `west` and `east` for the `-x` and `+x` boundary;
* `south` and `north` for the `-y` and `+y` boundary;
* `bottom` and `top` for the `-z` and `+z` boundary.</code></pre><p>Default boundary conditions depend on <code>topology(grid)</code>. See <code>DefaultBoundaryCondition</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/BoundaryConditions/field_boundary_conditions.jl#L162-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.UVelocityBoundaryConditions-Tuple{Any}" href="#Oceananigans.BoundaryConditions.UVelocityBoundaryConditions-Tuple{Any}"><code>Oceananigans.BoundaryConditions.UVelocityBoundaryConditions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">UVelocityBoundaryConditions(grid;   east = DefaultBoundaryCondition(topology(grid, 1), Face),
                                    west = DefaultBoundaryCondition(topology(grid, 1), Face),
                                   south = DefaultBoundaryCondition(topology(grid, 2), Cell),
                                   north = DefaultBoundaryCondition(topology(grid, 2), Cell),
                                  bottom = DefaultBoundaryCondition(topology(grid, 3), Cell),
                                     top = DefaultBoundaryCondition(topology(grid, 3), Cell))</code></pre><p>Construct <code>FieldBoundaryConditions</code> for the <code>u</code>-velocity field on <code>grid</code>. Boundary conditions on <code>x</code>-, <code>y</code>-, and <code>z</code>-boundaries are specified via keyword arguments:</p><pre><code class="language-none">* `west` and `east` for the `-x` and `+x` boundary;
* `south` and `north` for the `-y` and `+y` boundary;
* `bottom` and `top` for the `-z` and `+z` boundary.</code></pre><p>Default boundary conditions depend on <code>topology(grid)</code>. See <code>DefaultBoundaryCondition</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/BoundaryConditions/field_boundary_conditions.jl#L102-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.VVelocityBoundaryConditions-Tuple{Any}" href="#Oceananigans.BoundaryConditions.VVelocityBoundaryConditions-Tuple{Any}"><code>Oceananigans.BoundaryConditions.VVelocityBoundaryConditions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">VVelocityBoundaryConditions(grid;   east = DefaultBoundaryCondition(topology(grid, 1), Cell),
                                    west = DefaultBoundaryCondition(topology(grid, 1), Cell),
                                   south = DefaultBoundaryCondition(topology(grid, 2), Face),
                                   north = DefaultBoundaryCondition(topology(grid, 2), Face),
                                  bottom = DefaultBoundaryCondition(topology(grid, 3), Cell),
                                     top = DefaultBoundaryCondition(topology(grid, 3), Cell))</code></pre><p>Construct <code>FieldBoundaryConditions</code> for the <code>v</code>-velocity field on <code>grid</code>. Boundary conditions on <code>x</code>-, <code>y</code>-, and <code>z</code>-boundaries are specified via keyword arguments:</p><pre><code class="language-none">* `west` and `east` for the `-x` and `+x` boundary;
* `south` and `north` for the `-y` and `+y` boundary;
* `bottom` and `top` for the `-z` and `+z` boundary.</code></pre><p>Default boundary conditions depend on <code>topology(grid)</code>. See <code>DefaultBoundaryCondition</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/BoundaryConditions/field_boundary_conditions.jl#L122-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.WVelocityBoundaryConditions-Tuple{Any}" href="#Oceananigans.BoundaryConditions.WVelocityBoundaryConditions-Tuple{Any}"><code>Oceananigans.BoundaryConditions.WVelocityBoundaryConditions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">WVelocityBoundaryConditions(grid;   east = DefaultBoundaryCondition(topology(grid, 1), Cell),
                                    west = DefaultBoundaryCondition(topology(grid, 1), Cell),
                                   south = DefaultBoundaryCondition(topology(grid, 2), Cell),
                                   north = DefaultBoundaryCondition(topology(grid, 2), Cell),
                                  bottom = DefaultBoundaryCondition(topology(grid, 3), Face),
                                     top = DefaultBoundaryCondition(topology(grid, 3), Face))</code></pre><p>Construct <code>FieldBoundaryConditions</code> for the <code>w</code>-velocity field on <code>grid</code>. Boundary conditions on <code>x</code>-, <code>y</code>-, and <code>z</code>-boundaries are specified via keyword arguments:</p><pre><code class="language-none">* `west` and `east` for the `-x` and `+x` boundary;
* `south` and `north` for the `-y` and `+y` boundary;
* `bottom` and `top` for the `-z` and `+z` boundary.</code></pre><p>Default boundary conditions depend on <code>topology(grid)</code>. See <code>DefaultBoundaryCondition</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/BoundaryConditions/field_boundary_conditions.jl#L142-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.zero_halo_regions!-Tuple{Any,Any,Any}" href="#Oceananigans.BoundaryConditions.zero_halo_regions!-Tuple{Any,Any,Any}"><code>Oceananigans.BoundaryConditions.zero_halo_regions!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">zero_halo_regions!(underlying_data, loc, grid)</code></pre><p>Zero out the halo regions of the <code>underlying_data</code> of a field at <code>loc</code>ation on <code>grid</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/BoundaryConditions/zero_halo_regions.jl#L25-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.zero_halo_regions!-Tuple{Any}" href="#Oceananigans.BoundaryConditions.zero_halo_regions!-Tuple{Any}"><code>Oceananigans.BoundaryConditions.zero_halo_regions!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">zero_halo_regions!(field)</code></pre><p>Zero out the halo regions of <code>field</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/BoundaryConditions/zero_halo_regions.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.zero_halo_regions!-Tuple{Union{Tuple, NamedTuple}}" href="#Oceananigans.BoundaryConditions.zero_halo_regions!-Tuple{Union{Tuple, NamedTuple}}"><code>Oceananigans.BoundaryConditions.zero_halo_regions!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">zero_halo_regions!(fields::Union{Tuple, NamedTuple})</code></pre><p>Zero out the halo regions of each field in <code>fields</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/BoundaryConditions/zero_halo_regions.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.fill_halo_regions!-Tuple{AbstractArray,Any,Any,Any,Vararg{Any,N} where N}" href="#Oceananigans.BoundaryConditions.fill_halo_regions!-Tuple{AbstractArray,Any,Any,Any,Vararg{Any,N} where N}"><code>Oceananigans.BoundaryConditions.fill_halo_regions!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Fill halo regions in x, y, and z for a given field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/BoundaryConditions/fill_halo_regions.jl#L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.fill_halo_regions!-Tuple{Union{Tuple, NamedTuple},Any,Vararg{Any,N} where N}" href="#Oceananigans.BoundaryConditions.fill_halo_regions!-Tuple{Union{Tuple, NamedTuple},Any,Vararg{Any,N} where N}"><code>Oceananigans.BoundaryConditions.fill_halo_regions!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fill_halo_regions!(fields, arch)</code></pre><p>Fill halo regions for each field in the tuple <code>fields</code> according to their boundary conditions, possibly recursing into <code>fields</code> if it is a nested tuple-of-tuples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/BoundaryConditions/fill_halo_regions.jl#L7-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.apply_x_bcs!-Tuple{Any,Any,Any,Any,Vararg{Any,N} where N}" href="#Oceananigans.BoundaryConditions.apply_x_bcs!-Tuple{Any,Any,Any,Any,Vararg{Any,N} where N}"><code>Oceananigans.BoundaryConditions.apply_x_bcs!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">apply_x_bcs!(Gc, arch, grid, args...)</code></pre><p>Apply flux boundary conditions to a field <code>c</code> by adding the associated flux divergence to the source term <code>Gc</code> at the left and right.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/BoundaryConditions/apply_flux_bcs.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.apply_y_bcs!-Tuple{Any,Any,Any,Any,Vararg{Any,N} where N}" href="#Oceananigans.BoundaryConditions.apply_y_bcs!-Tuple{Any,Any,Any,Any,Vararg{Any,N} where N}"><code>Oceananigans.BoundaryConditions.apply_y_bcs!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">apply_y_bcs!(Gc, arch, grid, args...)</code></pre><p>Apply flux boundary conditions to a field <code>c</code> by adding the associated flux divergence to the source term <code>Gc</code> at the left and right.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/BoundaryConditions/apply_flux_bcs.jl#L18-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.apply_z_bcs!-Tuple{Any,Any,Any,Any,Vararg{Any,N} where N}" href="#Oceananigans.BoundaryConditions.apply_z_bcs!-Tuple{Any,Any,Any,Any,Vararg{Any,N} where N}"><code>Oceananigans.BoundaryConditions.apply_z_bcs!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">apply_z_bcs!(Gc, arch, grid, args...)</code></pre><p>Apply flux boundary conditions to a field <code>c</code> by adding the associated flux divergence to the source term <code>Gc</code> at the top and bottom.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/BoundaryConditions/apply_flux_bcs.jl#L28-L33">source</a></section></article><h2 id="Buoyancy"><a class="docs-heading-anchor" href="#Buoyancy">Buoyancy</a><a id="Buoyancy-1"></a><a class="docs-heading-anchor-permalink" href="#Buoyancy" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Buoyancy.SeawaterBuoyancy" href="#Oceananigans.Buoyancy.SeawaterBuoyancy"><code>Oceananigans.Buoyancy.SeawaterBuoyancy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SeawaterBuoyancy{FT, EOS, T, S} &lt;: AbstractBuoyancy{EOS}</code></pre><p>Buoyancy model for seawater. <code>T</code> and <code>S</code> are either <code>nothing</code> if both temperature and salinity are active, or of type <code>FT</code> if temperature or salinity are constant, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Buoyancy/seawater_buoyancy.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Buoyancy.SeawaterBuoyancy" href="#Oceananigans.Buoyancy.SeawaterBuoyancy"><code>Oceananigans.Buoyancy.SeawaterBuoyancy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SeawaterBuoyancy([FT=Float64;] gravitational_acceleration = g_Earth,
                              equation_of_state = LinearEquationOfState(FT), 
                              constant_temperature = false, constant_salinity = false)</code></pre><p>Returns parameters for a temperature- and salt-stratified seawater buoyancy model with a <code>gravitational_acceleration</code> constant (typically called &#39;g&#39;), and an <code>equation_of_state</code> that related temperature and salinity (or conservative temperature and absolute salinity) to density anomalies and buoyancy. If either <code>temperature</code> or <code>salinity</code> are specified, buoyancy is calculated</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Buoyancy/seawater_buoyancy.jl#L19-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Buoyancy.∂x_b-Tuple{Any,Any,Any,Any,SeawaterBuoyancy,Any}" href="#Oceananigans.Buoyancy.∂x_b-Tuple{Any,Any,Any,Any,SeawaterBuoyancy,Any}"><code>Oceananigans.Buoyancy.∂x_b</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∂x_b(i, j, k, grid, b::SeawaterBuoyancy, C)</code></pre><p>Returns the x-derivative of buoyancy for temperature and salt-stratified water,</p><div>\[∂_x b = g ( α ∂_x Θ - β ∂_x sᴬ ) ,\]</div><p>where <code>g</code> is gravitational acceleration, <code>α</code> is the thermal expansion coefficient, <code>β</code> is the haline contraction coefficient, <code>Θ</code> is conservative temperature, and <code>sᴬ</code> is absolute salinity.</p><p>Note: In Oceananigans, <code>model.tracers.T</code> is conservative temperature and <code>model.tracers.S</code> is absolute salinity.</p><p>Note that <code>∂x_Θ</code>, <code>∂x_sᴬ</code>, <code>α</code>, and <code>β</code> are all evaluated at cell interfaces in <code>x</code> and cell centers in <code>y</code> and <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Buoyancy/seawater_buoyancy.jl#L54-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Buoyancy.∂y_b-Tuple{Any,Any,Any,Any,SeawaterBuoyancy,Any}" href="#Oceananigans.Buoyancy.∂y_b-Tuple{Any,Any,Any,Any,SeawaterBuoyancy,Any}"><code>Oceananigans.Buoyancy.∂y_b</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∂y_b(i, j, k, grid, b::SeawaterBuoyancy, C)</code></pre><p>Returns the y-derivative of buoyancy for temperature and salt-stratified water,</p><div>\[∂_y b = g ( α ∂_y Θ - β ∂_y sᴬ ) ,\]</div><p>where <code>g</code> is gravitational acceleration, <code>α</code> is the thermal expansion coefficient, <code>β</code> is the haline contraction coefficient, <code>Θ</code> is conservative temperature, and <code>sᴬ</code> is absolute salinity.</p><p>Note: In Oceananigans, <code>model.tracers.T</code> is conservative temperature and <code>model.tracers.S</code> is absolute salinity.</p><p>Note that <code>∂y_Θ</code>, <code>∂y_sᴬ</code>, <code>α</code>, and <code>β</code> are all evaluated at cell interfaces in <code>y</code> and cell centers in <code>x</code> and <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Buoyancy/seawater_buoyancy.jl#L80-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Buoyancy.∂z_b-Tuple{Any,Any,Any,Any,SeawaterBuoyancy,Any}" href="#Oceananigans.Buoyancy.∂z_b-Tuple{Any,Any,Any,Any,SeawaterBuoyancy,Any}"><code>Oceananigans.Buoyancy.∂z_b</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∂z_b(i, j, k, grid, b::SeawaterBuoyancy, C)</code></pre><p>Returns the vertical derivative of buoyancy for temperature and salt-stratified water,</p><div>\[∂_z b = N^2 = g ( α ∂_z Θ - β ∂_z sᴬ ) ,\]</div><p>where <code>g</code> is gravitational acceleration, <code>α</code> is the thermal expansion coefficient, <code>β</code> is the haline contraction coefficient, <code>Θ</code> is conservative temperature, and <code>sᴬ</code> is absolute salinity.</p><p>Note: In Oceananigans, <code>model.tracers.T</code> is conservative temperature and <code>model.tracers.S</code> is absolute salinity.</p><p>Note that <code>∂z_Θ</code>, <code>∂z_sᴬ</code>, <code>α</code>, and <code>β</code> are all evaluated at cell interfaces in <code>z</code> and cell centers in <code>x</code> and <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Buoyancy/seawater_buoyancy.jl#L106-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Buoyancy.BuoyancyTracer" href="#Oceananigans.Buoyancy.BuoyancyTracer"><code>Oceananigans.Buoyancy.BuoyancyTracer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BuoyancyTracer &lt;: AbstractBuoyancy{Nothing}</code></pre><p>Type indicating that the tracer <code>b</code> represents buoyancy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Buoyancy/Buoyancy.jl#L52-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Buoyancy.LinearEquationOfState" href="#Oceananigans.Buoyancy.LinearEquationOfState"><code>Oceananigans.Buoyancy.LinearEquationOfState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LinearEquationOfState{FT} &lt;: AbstractEquationOfState</code></pre><p>Linear equation of state for seawater.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Buoyancy/linear_equation_of_state.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Buoyancy.LinearEquationOfState" href="#Oceananigans.Buoyancy.LinearEquationOfState"><code>Oceananigans.Buoyancy.LinearEquationOfState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LinearEquationOfState([FT=Float64;] α=1.67e-4, β=7.80e-4)</code></pre><p>Returns parameters for a linear equation of state for seawater with thermal expansion coefficient <code>α</code> [K⁻¹] and haline contraction coefficient <code>β</code> [ppt⁻¹]. The buoyancy perturbation associated with a linear equation of state is</p><div>\[    b = g (α T - β S)\]</div><p>Default constants are taken from Table 1.2 (page 33) of Vallis, &quot;Atmospheric and Oceanic Fluid Dynamics: Fundamentals and Large-Scale Circulation&quot; (2ed, 2017).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Buoyancy/linear_equation_of_state.jl#L11-L24">source</a></section></article><h2 id="Coriolis"><a class="docs-heading-anchor" href="#Coriolis">Coriolis</a><a id="Coriolis-1"></a><a class="docs-heading-anchor-permalink" href="#Coriolis" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.FPlane" href="#Oceananigans.Coriolis.FPlane"><code>Oceananigans.Coriolis.FPlane</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FPlane{FT} &lt;: AbstractRotation</code></pre><p>A parameter object for constant rotation around a vertical axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Coriolis/f_plane.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.FPlane" href="#Oceananigans.Coriolis.FPlane"><code>Oceananigans.Coriolis.FPlane</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FPlane([FT=Float64;] f=nothing, rotation_rate=Ω_Earth, latitude=nothing)</code></pre><p>Returns a parameter object for constant rotation at the angular frequency <code>f/2</code>, and therefore with background vorticity <code>f</code>, around a vertical axis. If <code>f</code> is not specified, it is calculated from <code>rotation_rate</code> and <code>latitude</code> according to the relation `f = 2<em>rotation_rate</em>sind(latitude).</p><p>By default, <code>rotation_rate</code> is assumed to be Earth&#39;s.</p><p>Also called <code>FPlane</code>, after the &quot;f-plane&quot; approximation for the local effect of a planet&#39;s rotation in a planar coordinate system tangent to the planet&#39;s surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Coriolis/f_plane.jl#L10-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.BetaPlane" href="#Oceananigans.Coriolis.BetaPlane"><code>Oceananigans.Coriolis.BetaPlane</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BetaPlane{T} &lt;: AbstractRotation</code></pre><p>A parameter object for meridionally increasing Coriolis parameter (<code>f = f₀ + βy</code>) that accounts for the variation of the locally vertical component of the rotation vector with latitude.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Coriolis/beta_plane.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.BetaPlane" href="#Oceananigans.Coriolis.BetaPlane"><code>Oceananigans.Coriolis.BetaPlane</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BetaPlane([T=Float64;] f₀=nothing, β=nothing,
                       rotation_rate=Ω_Earth, latitude=nothing, radius=R_Earth)</code></pre><p>The user may specify both <code>f₀</code> and <code>β</code>, or the three parameters <code>rotation_rate</code>, <code>latitude</code>, and <code>radius</code> that specify the rotation rate and radius of a planet, and the central latitude (where y = 0) at which the <code>β</code>-plane approximation is to be made.</p><p>By default, the <code>rotation_rate</code> and planet <code>radius</code> is assumed to be Earth&#39;s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Coriolis/beta_plane.jl#L13-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.NonTraditionalFPlane" href="#Oceananigans.Coriolis.NonTraditionalFPlane"><code>Oceananigans.Coriolis.NonTraditionalFPlane</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NonTraditionalFPlane{FT} &lt;: AbstractRotation</code></pre><p>A Coriolis implementation that accounts for both the locally vertical and the locally horizontal components of the rotation vector. Traditionally (see <a href="#Oceananigans.Coriolis.FPlane"><code>FPlane</code></a>) only the locally vertical component is accounted for.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Coriolis/non_traditional_f_plane.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.NonTraditionalFPlane" href="#Oceananigans.Coriolis.NonTraditionalFPlane"><code>Oceananigans.Coriolis.NonTraditionalFPlane</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NonTraditionalFPlane([FT=Float64;] fz=nothing, fy=nothing,
                                   rotation_rate=Ω_Earth, latitude=nothing)</code></pre><p>Returns a parameter object for constant rotation about an axis in the <code>y-z</code> plane with <code>y</code>- and <code>z</code>-components <code>fy/2</code> and <code>fz/2</code>, and the background vorticity is <code>(0, fy, fz)</code>.</p><p>In oceanography <code>fz</code> and <code>fy</code> represent the components of planetary voriticity which are perpendicular and parallel to the ocean surface in a domain in which <code>x, y, z</code> correspond to the directions east, north, and up.</p><p>If <code>fz</code> and <code>fy</code> are not specified, they are calculated from <code>rotation_rate</code> and <code>latitude</code> according to the relations <code>fz = 2*rotation_rate*sind(latitude)</code> and <code>fy = 2*rotation_rate*cosd(latitude)</code>, respectively. By default, <code>rotation_rate</code> is assumed to be Earth&#39;s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Coriolis/non_traditional_f_plane.jl#L13-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.NonTraditionalBetaPlane" href="#Oceananigans.Coriolis.NonTraditionalBetaPlane"><code>Oceananigans.Coriolis.NonTraditionalBetaPlane</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NonTraditionalBetaPlane{FT} &lt;: AbstractRotation</code></pre><p>A Coriolis implementation that accounts for the latitudinal variation of both the locally vertical and the locally horizontal components of the rotation vector. The &quot;traditional&quot; approximation in ocean models accounts for only the locally vertical component of the rotation vector (see <a href="#Oceananigans.Coriolis.BetaPlane"><code>BetaPlane</code></a>).</p><p>This implementation is based off of section 5 of Dellar (2011). It conserve energy, angular momentum, and potential vorticity.</p><p><strong>References</strong></p><p>Dellar, P. (2011). Variations on a beta-plane: Derivation of non-traditional     beta-plane equations from Hamilton&#39;s principle on a sphere. Journal of     Fluid Mechanics, 674, 174-195. doi:10.1017/S0022112010006464</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Coriolis/non_traditional_beta_plane.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.NonTraditionalBetaPlane" href="#Oceananigans.Coriolis.NonTraditionalBetaPlane"><code>Oceananigans.Coriolis.NonTraditionalBetaPlane</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NonTraditionalBetaPlane(FT=Float64;
    fz=nothing, fy=nothing, β=nothing, γ=nothing,
    rotation_rate=Ω_Earth, latitude=nothing, radius=R_Earth)</code></pre><p>The user may directly specify <code>fz</code>, <code>fy</code>, <code>β</code>, <code>γ</code>, and <code>radius</code> or the three parameters <code>rotation_rate</code>, <code>latitude</code>, and <code>radius</code> that specify the rotation rate and radius of a planet, and the central latitude (where y = 0) at which the non-traditional <code>β</code>-plane approximation is to be made.</p><p>By default, the <code>rotation_rate</code> and planet <code>radius</code> is assumed to be Earth&#39;s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Coriolis/non_traditional_beta_plane.jl#L26-L37">source</a></section></article><h2 id="Diagnostics"><a class="docs-heading-anchor" href="#Diagnostics">Diagnostics</a><a id="Diagnostics-1"></a><a class="docs-heading-anchor-permalink" href="#Diagnostics" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.Average" href="#Oceananigans.Diagnostics.Average"><code>Oceananigans.Diagnostics.Average</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Average{F, R, D, P, I, T} &lt;: AbstractDiagnostic</code></pre><p>A diagnostic for computing the averages of a field along particular dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Diagnostics/average.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.Average-Tuple{Field}" href="#Oceananigans.Diagnostics.Average-Tuple{Field}"><code>Oceananigans.Diagnostics.Average</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Average(field::Field; dims, iteration_interval=nothing, time_interval=nothing, return_type=Array)</code></pre><p>Construct an <code>Average</code> of <code>field</code> along the dimensions specified by the tuple <code>dims</code>.</p><p>After the average is computed it will be stored in the <code>result</code> property.</p><p>The <code>Average</code> can be used as a callable object that computes and returns the average.</p><p>An <code>iteration_interval</code> or <code>time_interval</code> (or both) can be passed to indicate how often to run this diagnostic if it is part of <code>simulation.diagnostics</code>. <code>iteration_interval</code> is a number of iterations while <code>time_interval</code> is a time interval in units of <code>model.clock.time</code>.</p><p>A <code>return_type</code> can be used to specify the type returned when the <code>Average</code> is used as a callable object. The default <code>return_type=Array</code> is useful when running a GPU model and you want to save the output to disk by passing it to an output writer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Diagnostics/average.jl#L29-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.run_diagnostic-Tuple{Any,Average}" href="#Oceananigans.Diagnostics.run_diagnostic-Tuple{Any,Average}"><code>Oceananigans.Diagnostics.run_diagnostic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">run_diagnostic(model, avg::Average)</code></pre><p>Compute the horizontal average of <code>avg.field</code> and store the result in <code>avg.result</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Diagnostics/average.jl#L75-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.TimeSeries" href="#Oceananigans.Diagnostics.TimeSeries"><code>Oceananigans.Diagnostics.TimeSeries</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TimeSeries{D, II, TI, T, TT} &lt;: AbstractDiagnostic</code></pre><p>A diagnostic for collecting and storing time series.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Diagnostics/time_series.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.TimeSeries-Tuple{Any,Any}" href="#Oceananigans.Diagnostics.TimeSeries-Tuple{Any,Any}"><code>Oceananigans.Diagnostics.TimeSeries</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">TimeSeries(diagnostic, model; iteration_interval=nothing, time_interval=nothing)</code></pre><p>A <code>TimeSeries</code> <code>Diagnostic</code> that records a time series of <code>diagnostic(model)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using Oceananigans, Oceananigans.Diagnostics

julia&gt; model = IncompressibleModel(grid=RegularCartesianGrid(size=(16, 16, 16), extent=(1, 1, 1)));

julia&gt; sim = Simulation(model, Δt=1, stop_iteration=3);

julia&gt; max_u = TimeSeries(FieldMaximum(abs, model.velocities.u), model; iteration_interval=1);

julia&gt; sim.diagnostics[:max_u] = max_u;

julia&gt; run!(sim);
[ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.</code></pre><pre><code class="language-julia-repl">julia&gt; max_u.data
4-element Array{Float64,1}:
 0.0
 0.0
 0.0
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Diagnostics/time_series.jl#L14-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.TimeSeries-Tuple{NamedTuple,Any}" href="#Oceananigans.Diagnostics.TimeSeries-Tuple{NamedTuple,Any}"><code>Oceananigans.Diagnostics.TimeSeries</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">TimeSeries(diagnostics::NamedTuple, model; iteration_interval=nothing, time_interval=nothing)</code></pre><p>A <code>TimeSeries</code> <code>Diagnostic</code> that records a <code>NamedTuple</code> of time series of <code>diag(model)</code> for each <code>diag</code> in <code>diagnostics</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using Oceananigans, Oceananigans.Diagnostics

julia&gt; model = IncompressibleModel(grid=RegularCartesianGrid(size=(16, 16, 16), extent=(1, 1, 1)));

julia&gt; Δt = 1.0;

julia&gt; cfl = TimeSeries((adv=AdvectiveCFL(Δt), diff=DiffusiveCFL(Δt)), model; iteration_interval=1);

julia&gt; sim = Simulation(model, Δt=Δt, stop_iteration=3);

julia&gt; sim.diagnostics[:cfl] = cfl;

julia&gt; run!(sim);
[ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.</code></pre><pre><code class="language-julia-repl">julia&gt; cfl.data
(adv = [0.0, 0.0, 0.0, 0.0], diff = [0.0002688, 0.0002688, 0.0002688, 0.0002688])</code></pre><pre><code class="language-julia-repl">julia&gt; cfl.adv
4-element Array{Float64,1}:
 0.0
 0.0
 0.0
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Diagnostics/time_series.jl#L60-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.CFL" href="#Oceananigans.Diagnostics.CFL"><code>Oceananigans.Diagnostics.CFL</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CFL{D, S}</code></pre><p>An object for computing the Courant-Freidrichs-Lewy (CFL) number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Diagnostics/cfl.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.CFL-Tuple{Any}" href="#Oceananigans.Diagnostics.CFL-Tuple{Any}"><code>Oceananigans.Diagnostics.CFL</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CFL(Δt [, timescale=Oceananigans.cell_advection_timescale])</code></pre><p>Returns an object for computing the Courant-Freidrichs-Lewy (CFL) number associated with time step or <code>TimeStepWizard</code> <code>Δt</code> and <code>timescale</code>.</p><p>See also <code>AdvectiveCFL</code> and <code>DiffusiveCFL</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Diagnostics/cfl.jl#L14-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.AdvectiveCFL-Tuple{Any}" href="#Oceananigans.Diagnostics.AdvectiveCFL-Tuple{Any}"><code>Oceananigans.Diagnostics.AdvectiveCFL</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">AdvectiveCFL(Δt)</code></pre><p>Returns an object for computing the Courant-Freidrichs-Lewy (CFL) number associated with time step or <code>TimeStepWizard</code> <code>Δt</code> and the time scale for advection across a cell.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; model = IncompressibleModel(grid=RegularCartesianGrid(size=(16, 16, 16), length=(8, 8, 8)));

julia&gt; cfl = AdvectiveCFL(1.0);

julia&gt; data(model.velocities.u) .= π;

julia&gt; cfl(model)
6.283185307179586</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Diagnostics/cfl.jl#L26-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.DiffusiveCFL-Tuple{Any}" href="#Oceananigans.Diagnostics.DiffusiveCFL-Tuple{Any}"><code>Oceananigans.Diagnostics.DiffusiveCFL</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">DiffusiveCFL(Δt)</code></pre><p>Returns an object for computing the diffusive Courant-Freidrichs-Lewy (CFL) number associated with time step or <code>TimeStepWizard</code> <code>Δt</code> and the time scale for diffusion across a cell associated with <code>model.closure</code>.</p><p>The maximum diffusive CFL number among viscosity and all tracer diffusivities is returned.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; model = IncompressibleModel(grid=RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1)));

julia&gt; dcfl = DiffusiveCFL(0.1);

julia&gt; dcfl(model)
2.688e-5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Diagnostics/cfl.jl#L48-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.FieldMaximum" href="#Oceananigans.Diagnostics.FieldMaximum"><code>Oceananigans.Diagnostics.FieldMaximum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FieldMaximum(mapping, field)</code></pre><p>An object for calculating the maximum of a <code>mapping</code> function applied element-wise to <code>field</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; model = IncompressibleModel(grid=RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1)));

julia&gt; max_abs_u = FieldMaximum(abs, model.velocities.u);

julia&gt; max_w² = FieldMaximum(x-&gt;x^2, model.velocities.w);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Diagnostics/field_maximum.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.NaNChecker" href="#Oceananigans.Diagnostics.NaNChecker"><code>Oceananigans.Diagnostics.NaNChecker</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NaNChecker{F} &lt;: AbstractDiagnostic</code></pre><p>A diagnostic that checks for <code>NaN</code> values and aborts the simulation if any are found.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Diagnostics/nan_checker.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.NaNChecker-Tuple{Any}" href="#Oceananigans.Diagnostics.NaNChecker-Tuple{Any}"><code>Oceananigans.Diagnostics.NaNChecker</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">NaNChecker(model; iteration_interval, fields)</code></pre><p>Construct a <code>NaNChecker</code> for <code>model</code>. <code>fields</code> should be a <code>Dict{Symbol,Field}</code>. An <code>iteration_interval</code> should be passed to indicate how often to check for NaNs (in number of iterations).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Diagnostics/nan_checker.jl#L11-L17">source</a></section></article><h2 id="Fields"><a class="docs-heading-anchor" href="#Fields">Fields</a><a id="Fields-1"></a><a class="docs-heading-anchor-permalink" href="#Fields" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.Field" href="#Oceananigans.Fields.Field"><code>Oceananigans.Fields.Field</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Field{X, Y, Z, A, G, B} &lt;: AbstractField{X, Y, Z, A, G}</code></pre><p>A field defined at the location (<code>X</code>, <code>Y</code>, <code>Z</code>), each of which can be either <code>Cell</code> or <code>Face</code>, and with data stored in a container of type <code>A</code> (typically an array). The field is defined on a grid <code>G</code> and has field boundary conditions <code>B</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Fields/field.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.Field" href="#Oceananigans.Fields.Field"><code>Oceananigans.Fields.Field</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Field(X, Y, Z, arch, grid, [  bcs = FieldBoundaryConditions(grid, (X, Y, Z)),
                             data = new_data(arch, grid, (X, Y, Z)) ] )</code></pre><p>Construct a <code>Field</code> on <code>grid</code> with <code>data</code> on architecture <code>arch</code> with boundary conditions <code>bcs</code>. Each of <code>(X, Y, Z)</code> is either <code>Cell</code> or <code>Face</code> and determines the field&#39;s location in <code>(x, y, z)</code>.</p><p><strong>Example</strong></p><p>julia&gt; ω = Field(Face, Face, Cell, CPU(), RegularCartesianmodel.grid)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Fields/field.jl#L19-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.Field-Tuple{Tuple,Vararg{Any,N} where N}" href="#Oceananigans.Fields.Field-Tuple{Tuple,Vararg{Any,N} where N}"><code>Oceananigans.Fields.Field</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Field(L::Tuple, arch, grid, data, bcs)</code></pre><p>Construct a <code>Field</code> at the location defined by the 3-tuple <code>L</code>, whose elements are <code>Cell</code> or <code>Face</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Fields/field.jl#L48-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.CellField" href="#Oceananigans.Fields.CellField"><code>Oceananigans.Fields.CellField</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">CellField([ FT=eltype(grid) ], arch::AbstractArchitecture, grid,
          [  bcs = TracerBoundaryConditions(grid),
            data = new_data(FT, arch, grid, (Cell, Cell, Cell) ] )</code></pre><p>Return a <code>Field{Cell, Cell, Cell}</code> on architecture <code>arch</code> and <code>grid</code> containing <code>data</code> with field boundary conditions <code>bcs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Fields/field.jl#L60-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.XFaceField" href="#Oceananigans.Fields.XFaceField"><code>Oceananigans.Fields.XFaceField</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">XFaceField([ FT=eltype(grid) ], arch::AbstractArchitecture, grid,
           [  bcs = UVelocityBoundaryConditions(grid),
             data = new_data(FT, arch, grid, (Face, Cell, Cell) ] )</code></pre><p>Return a <code>Field{Face, Cell, Cell}</code> on architecture <code>arch</code> and <code>grid</code> containing <code>data</code> with field boundary conditions <code>bcs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Fields/field.jl#L75-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.YFaceField" href="#Oceananigans.Fields.YFaceField"><code>Oceananigans.Fields.YFaceField</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">YFaceField([ FT=eltype(grid) ], arch::AbstractArchitecture, grid,
           [  bcs = VVelocityBoundaryConditions(grid),
             data = new_data(FT, arch, grid, (Cell, Face, Cell)) ] )</code></pre><p>Return a <code>Field{Cell, Face, Cell}</code> on architecture <code>arch</code> and <code>grid</code> containing <code>data</code> with field boundary conditions <code>bcs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Fields/field.jl#L90-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.ZFaceField" href="#Oceananigans.Fields.ZFaceField"><code>Oceananigans.Fields.ZFaceField</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ZFaceField([ FT=eltype(grid) ], arch::AbstractArchitecture, grid,
           [  bcs = WVelocityBoundaryConditions(grid),
             data = new_data(FT, arch, grid, (Cell, Cell, Face)) ] )</code></pre><p>Return a <code>Field{Cell, Cell, Face}</code> on architecture <code>arch</code> and <code>grid</code> containing <code>data</code> with field boundary conditions <code>bcs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Fields/field.jl#L105-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.set!-Tuple{Any}" href="#Oceananigans.Fields.set!-Tuple{Any}"><code>Oceananigans.Fields.set!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set!(model; kwargs...)</code></pre><p>Set velocity and tracer fields of <code>model</code>. The keyword arguments <code>kwargs...</code> take the form <code>name=data</code>, where <code>name</code> refers to one of the fields of <code>model.velocities</code> or <code>model.tracers</code>, and the <code>data</code> may be an array, a function with arguments <code>(x, y, z)</code>, or any data type for which a <code>set!(ϕ::AbstractField, data)</code> function exists.</p><p><strong>Example</strong></p><pre><code class="language-julia">model = IncompressibleModel(grid=RegularCartesianGrid(size=(32, 32, 32), length=(1, 1, 1))

# Set u to a parabolic function of z, v to random numbers damped
# at top and bottom, and T to some silly array of half zeros,
# half random numbers.

u₀(x, y, z) = z/model.grid.Lz * (1 + z/model.grid.Lz)
v₀(x, y, z) = 1e-3 * rand() * u₀(x, y, z)

T₀ = rand(size(model.grid)...)
T₀[T₀ .&lt; 0.5] .= 0

set!(model, u=u₀, v=v₀, T=T₀)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Fields/set!.jl#L6-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.set!-Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A&lt;:(OffsetArrays.OffsetArray{T,D,#s43} where #s43&lt;:Array where D where T) where Z where Y where X,Array}" href="#Oceananigans.Fields.set!-Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A&lt;:(OffsetArrays.OffsetArray{T,D,#s43} where #s43&lt;:Array where D where T) where Z where Y where X,Array}"><code>Oceananigans.Fields.set!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Set the CPU field <code>u</code> to the array <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Fields/set!.jl#L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.set!-Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A&lt;:(OffsetArrays.OffsetArray{T,D,#s43} where #s43&lt;:Array where D where T) where Z where Y where X,Function}" href="#Oceananigans.Fields.set!-Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A&lt;:(OffsetArrays.OffsetArray{T,D,#s43} where #s43&lt;:Array where D where T) where Z where Y where X,Function}"><code>Oceananigans.Fields.set!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Set the CPU field <code>u</code> data to the function <code>f(x, y, z)</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Fields/set!.jl#L84">source</a></section></article><h2 id="Forcing"><a class="docs-heading-anchor" href="#Forcing">Forcing</a><a id="Forcing-1"></a><a class="docs-heading-anchor-permalink" href="#Forcing" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcing.SimpleForcing" href="#Oceananigans.Forcing.SimpleForcing"><code>Oceananigans.Forcing.SimpleForcing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SimpleForcing{X, Y, Z, M, F, P}</code></pre><p>A callable object that implements a &#39;simple&#39; forcing function on a field at the location <code>X, Y, Z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Forcing/simple_forcing.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcing.SimpleForcing-Tuple{Any}" href="#Oceananigans.Forcing.SimpleForcing-Tuple{Any}"><code>Oceananigans.Forcing.SimpleForcing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SimpleForcing(forcing; parameters=nothing, field_in_signature=false)</code></pre><p>Construct forcing for a field named <code>field_name</code> based on a <code>forcing</code> function, with optional parameters. The keyword arguments determine the expected function  signature of <code>forcing</code>. The keyword <code>field_in_signature=true</code> specifies that the field being forced appears in the user-defined function signature. If <code>parameters</code> is anything other than <code>nothing</code>, it is assumed to be part of the function signature of <code>forcing</code>.</p><p>The four possible signatures of function <code>forcing</code> are thus</p><ul><li><p><code>parameters=nothing, field_in_signature=false</code>:</p><p><code>forcing(x, y, z, t)</code></p></li></ul><p>This is the function signature for default choices of <code>parameters</code> and <code>field_in_signature</code>.</p><ul><li><p><code>field_in_signature=false</code>, specified parameters:</p><p><code>forcing(x, y, z, t, parameters)</code>,</p></li></ul><p>where <code>parameters</code> is the object passed as keyword argument. To compile on the GPU this must be a simple object; typically, a <code>NamedTuple</code> of floats and other constants.</p><ul><li><p><code>parameters=nothing, field_in_signature=true</code>:</p><p><code>forcing(x, y, z, t, field)</code></p></li></ul><p>where <code>field</code> is the value of the field the forcing is applied to at <code>x, y, z</code>.</p><ul><li><p><code>field_in_signature=true</code>, specified parameters:</p><p><code>forcing(x, y, z, t, field, parameters)</code></p></li></ul><p><strong>Examples</strong></p><ul><li>The simplest case: no parameters, additive forcing:</li></ul><pre><code class="language-julia">julia&gt; const a = 2.1

julia&gt; fun_forcing(x, y, z, t) = a * exp(z) * cos(t)

julia&gt; u_forcing = SimpleForcing(fun_forcing)</code></pre><ul><li>Parameterized, additive forcing:</li></ul><pre><code class="language-julia">julia&gt; parameterized_forcing(x, y, z, t, p) = p.μ * exp(z / p.λ) * cos(p.ω * t)

julia&gt; v_forcing = SimpleForcing(parameterized_forcing, parameters = (μ=42, λ=0.1, ω=π))</code></pre><ul><li>Field-dependent forcing with no parameters:</li></ul><pre><code class="language-julia">julia&gt; growth_in_sunlight(x, y, z, t, P) = exp(z) * P

julia&gt; plankton_forcing = SimpleForcing(growth_in_sunlight, field_in_signature=true)</code></pre><ul><li>Field-dependent forcing with parameters. This example relaxes a tracer to some reference   linear profile.</li></ul><pre><code class="language-julia">julia&gt; tracer_relaxation(x, y, z, t, c, p) = p.μ * exp((z + p.H) / p.λ) * (p.dCdz * z - c) 

julia&gt; c_forcing = SimpleForcing(tracer_relaxation, parameters=(μ=1/60, λ=10, H=1000, dCdz=1), 
                                 field_in_signature=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Forcing/simple_forcing.jl#L23-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcing.ModelForcing-Tuple{}" href="#Oceananigans.Forcing.ModelForcing-Tuple{}"><code>Oceananigans.Forcing.ModelForcing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ModelForcing(; u=zeroforcing, v=zeroforcing, w=zeroforcing, tracer_forcings...)</code></pre><p>Return a named tuple of forcing functions for each solution field.</p><p><strong>Example</strong></p><p>julia&gt; u_forcing = SimpleForcing((x, y, z, t) -&gt; exp(z) * cos(t))</p><p>julia&gt; model = IncompressibleModel(forcing=ModelForcing(u=u_forcing))</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Forcing/model_forcing.jl#L11-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcing.ParameterizedForcing" href="#Oceananigans.Forcing.ParameterizedForcing"><code>Oceananigans.Forcing.ParameterizedForcing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ParameterizedForcing(func, parameters)</code></pre><p>Construct a forcing function with parameters. The forcing function, which is applied at grid point <code>i, j, k</code>, is called with the signature</p><pre><code class="language-none">`func(i, j, k, grid, clock, state, parameters)`</code></pre><p><strong>Example</strong></p><p>function cool<em>forcing</em>function(i, j, k, grid, clock, state, parameters) =      return @inbounds - parameters.μ * exp(grid.zC[k] / parameters.λ) * state.velocities.u[i, j, k] end</p><p>parameters = (μ=42, λ=π)</p><p>cool<em>forcing = ParameterizedForcing(cool</em>forcing_function, parameters)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Forcing/parameterized_forcing.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcing.GaussianMask" href="#Oceananigans.Forcing.GaussianMask"><code>Oceananigans.Forcing.GaussianMask</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GaussianMask{D}(center, width)</code></pre><p>Callable object that returns a Gaussian masking function centered on <code>center</code>, with <code>width</code>, and varying along direction <code>D</code>.</p><p><strong>Examples</strong></p><ul><li>Create a Gaussian mask centered on <code>z=0</code> with width <code>1</code> meter.</li></ul><pre><code class="language-julia">julia&gt; mask = GaussianMask{:z}(0, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Forcing/relaxation.jl#L50-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcing.LinearTarget" href="#Oceananigans.Forcing.LinearTarget"><code>Oceananigans.Forcing.LinearTarget</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LinearTarget{D}(intercept, gradient)</code></pre><p>Callable object that returns a Linear target function with <code>intercept</code> and <code>gradient</code>, and varying along direction <code>D</code>.</p><p><strong>Examples</strong></p><ul><li>Create a linear target function varying in <code>z</code>, equal to <code>0</code> at  <code>z=0</code> and with gradient 10⁻⁶:</li></ul><pre><code class="language-julia">julia&gt; target = LinearTarget{:z}(0, 1e-6)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Forcing/relaxation.jl#L83-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcing.Relaxation-Tuple{}" href="#Oceananigans.Forcing.Relaxation-Tuple{}"><code>Oceananigans.Forcing.Relaxation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Relaxation(; rate, mask=onefunction, target=zerofunction)</code></pre><p>Returns a <code>SimpleForcing</code> that restores a field to <code>target(x, y, z, t)</code> at the specified <code>rate</code>, in the region <code>mask(x, y, z)</code>.</p><p><strong>Example</strong></p><ul><li>Restore a field to a linear z-gradient everywhere on a timescale of &quot;60&quot; (equal to one minute if the time units of the simulation are seconds).</li></ul><pre><code class="language-julia">julia&gt; restore_stratification = Relaxation(; rate = 1/60, target = (x, y, z, t) -&gt; z)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Forcing/relaxation.jl#L26-L41">source</a></section></article><h2 id="Grids"><a class="docs-heading-anchor" href="#Grids">Grids</a><a id="Grids-1"></a><a class="docs-heading-anchor-permalink" href="#Grids" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.AbstractGrid" href="#Oceananigans.Grids.AbstractGrid"><code>Oceananigans.Grids.AbstractGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractGrid{FT, TX, TY, TZ}</code></pre><p>Abstract supertype for grids with elements of type <code>FT</code> and topology <code>{TX, TY, TZ}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Grids/Grids.jl#L65-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.AbstractTopology" href="#Oceananigans.Grids.AbstractTopology"><code>Oceananigans.Grids.AbstractTopology</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractTopology</code></pre><p>Abstract supertype for grid topologies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Grids/Grids.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.Bounded" href="#Oceananigans.Grids.Bounded"><code>Oceananigans.Grids.Bounded</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Bounded</code></pre><p>Grid topology for bounded dimensions. These could be wall-bounded dimensions or dimensions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Grids/Grids.jl#L49-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.Cell" href="#Oceananigans.Grids.Cell"><code>Oceananigans.Grids.Cell</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Cell</code></pre><p>A type describing the location at the center of a grid cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Grids/Grids.jl#L21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.Face" href="#Oceananigans.Grids.Face"><code>Oceananigans.Grids.Face</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Face</code></pre><p>A type describing the location at the face of a grid cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Grids/Grids.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.Flat" href="#Oceananigans.Grids.Flat"><code>Oceananigans.Grids.Flat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Flat</code></pre><p>Grid topology for flat dimensions, generally with one grid point, along which the solution is uniform and does not vary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Grids/Grids.jl#L57-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.Periodic" href="#Oceananigans.Grids.Periodic"><code>Oceananigans.Grids.Periodic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Periodic</code></pre><p>Grid topology for periodic dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Grids/Grids.jl#L42-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.nodes-Tuple{Any,AbstractGrid}" href="#Oceananigans.Grids.nodes-Tuple{Any,AbstractGrid}"><code>Oceananigans.Grids.nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nodes(loc, grid; reshape=false)</code></pre><p>Returns a 3-tuple of views over the interior nodes at the locations in <code>loc</code> in <code>x, y, z</code>.</p><p>If <code>reshape=true</code>, the views are reshaped to 3D arrays with non-singleton dimensions 1, 2, 3 for <code>x, y, z</code>, respectively. These reshaped arrays can then be used in broadcast operations with 3D fields or arrays.</p><p>See <code>xnodes</code>, <code>ynodes</code>, and <code>znodes</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Grids/grid_utils.jl#L249-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.xnodes-Tuple{Any,Any}" href="#Oceananigans.Grids.xnodes-Tuple{Any,Any}"><code>Oceananigans.Grids.xnodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">xnodes(loc, grid, reshape=false)</code></pre><p>Returns a view over the interior <code>loc=Cell</code> or <code>loc=Face</code> nodes on <code>grid</code> in the x-direction. For <code>Bounded</code> directions, <code>Face</code> nodes include the boundary points. <code>reshape=false</code> will return a 1D array while <code>reshape=true</code> will return a 3D array with size Nx×1×1.</p><p>See <code>znodes</code> for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Grids/grid_utils.jl#L167-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.ynodes-Tuple{Any,Any}" href="#Oceananigans.Grids.ynodes-Tuple{Any,Any}"><code>Oceananigans.Grids.ynodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ynodes(loc, grid, reshape=false)</code></pre><p>Returns a view over the interior <code>loc=Cell</code> or <code>loc=Face</code> nodes on <code>grid</code> in the y-direction. For <code>Bounded</code> directions, <code>Face</code> nodes include the boundary points. <code>reshape=false</code> will return a 1D array while <code>reshape=true</code> will return a 3D array with size 1×Ny×1.</p><p>See <code>znodes</code> for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Grids/grid_utils.jl#L186-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.znodes-Tuple{Any,Any}" href="#Oceananigans.Grids.znodes-Tuple{Any,Any}"><code>Oceananigans.Grids.znodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">znodes(loc, grid, reshape=false)</code></pre><p>Returns a view over the interior <code>loc=Cell</code> or <code>loc=Face</code> nodes on <code>grid</code> in the z-direction. For <code>Bounded</code> directions, <code>Face</code> nodes include the boundary points. <code>reshape=false</code> will return a 1D array while <code>reshape=true</code> will return a 3D array with size 1×1×Nz.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Oceananigans, Oceananigans.Grids

julia&gt; horz_periodic_grid = RegularCartesianGrid(size=(3, 3, 3), extent=(2π, 2π, 1),
                                                 topology=(Periodic, Periodic, Bounded));

julia&gt; zC = znodes(Cell, horz_periodic_grid)
3-element view(OffsetArray(::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}, 0:4), 1:3) with eltype Float64:
 -0.8333333333333331
 -0.4999999999999999
 -0.16666666666666652</code></pre><pre><code class="language-julia-repl">julia&gt; zF = znodes(Face, horz_periodic_grid)
4-element view(OffsetArray(::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}, 0:5), 1:4) with eltype Float64:
 -1.0
 -0.6666666666666666
 -0.33333333333333337
 -4.44089209850063e-17</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Grids/grid_utils.jl#L206-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.RegularCartesianGrid" href="#Oceananigans.Grids.RegularCartesianGrid"><code>Oceananigans.Grids.RegularCartesianGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RegularCartesianGrid{FT, TX, TY, TZ, R} &lt;: AbstractGrid{FT, TX, TY, TZ}</code></pre><p>A Cartesian grid with with constant grid spacings <code>Δx</code>, <code>Δy</code>, and <code>Δz</code> between cell centers and cell faces, elements of type <code>FT</code>, topology <code>{TX, TY, TZ}</code>, and coordinate ranges of type <code>R</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Grids/regular_cartesian_grid.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.RegularCartesianGrid" href="#Oceananigans.Grids.RegularCartesianGrid"><code>Oceananigans.Grids.RegularCartesianGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RegularCartesianGrid([FT=Float64]; size,
                     extent = nothing, x = nothing, y = nothing, z = nothing,
                     topology = (Periodic, Periodic, Bounded), halo = (1, 1, 1))</code></pre><p>Creates a <code>RegularCartesianGrid</code> with <code>size = (Nx, Ny, Nz)</code> grid points.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>size</code> (required): A 3-tuple <code>(Nx, Ny, Nz)</code> prescribing the number of grid points in <code>x, y, z</code></p></li><li><p><code>extent</code>: A 3-tuple <code>(Lx, Ly, Lz)</code> prescribing the physical extent of the grid.                    The origin is the oceanic default <code>(0, 0, -Lz)</code>.</p></li><li><p><code>x</code>, <code>y</code>, and <code>z</code>: Each of <code>x, y, z</code> are 2-tuples that specify the end points of the domain                    in their respect directions.</p></li></ul><p><em>Note</em>: <em>Either</em> <code>extent</code>, or all of <code>x</code>, <code>y</code>, and <code>z</code> must be specified.</p><ul><li><p><code>topology</code>: A 3-tuple <code>(Tx, Ty, Tz)</code> specifying the topology of the domain.             <code>Tx</code>, <code>Ty</code>, and <code>Tz</code> specify whether the <code>x</code>-, <code>y</code>-, and <code>z</code> directions are             <code>Periodic</code>, <code>Bounded</code>, or <code>Flat</code>. In a <code>Flat</code> direction, derivatives are             zero. The default is <code>(Periodic, Periodic, Bounded)</code>.</p></li><li><p><code>halo</code>: A 3-tuple of integers that specifies the size of the halo region of cells surrounding         the physical interior in <code>x</code>, <code>y</code>, and <code>z</code>.</p></li></ul><p>The physical extent of the domain can be specified via <code>x</code>, <code>y</code>, and <code>z</code> keyword arguments indicating the left and right endpoints of each dimensions, e.g. <code>x=(-π, π)</code> or via the <code>extent</code> argument, e.g. <code>extent=(Lx, Ly, Lz)</code> which specifies the extent of each dimension in which case 0 ≤ x ≤ Lx, 0 ≤ y ≤ Ly, and -Lz ≤ z ≤ 0.</p><p>A grid topology may be specified via a tuple assigning one of <code>Periodic</code>, <code>Bounded, and</code>Flat<code>to each dimension. By default, a horizontally periodic grid topology</code>(Periodic, Periodic, Flat)` is assumed.</p><p>Constants are stored using floating point values of type <code>FT</code>. By default this is <code>Float64</code>. Make sure to specify the desired <code>FT</code> if not using <code>Float64</code>.</p><p><strong>Grid properties</strong></p><ul><li><p><code>(Nx, Ny, Nz)::Int</code>: Number of physical points in the (x, y, z)-direction</p></li><li><p><code>(Hx, Hy, Hz)::Int</code>: Number of halo points in the (x, y, z)-direction</p></li><li><p><code>(Lx, Ly, Lz)::FT</code>: Physical extent of the grid in the (x, y, z)-direction</p></li><li><p><code>(Δx, Δy, Δz)::FT</code>: Cell width in the (x, y, z)-direction</p></li><li><p><code>(xC, yC, zC)</code>: (x, y, z) coordinates of cell centers.</p></li><li><p><code>(xF, yF, zF)</code>: (x, y, z) coordinates of cell faces.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Oceananigans

julia&gt; grid = RegularCartesianGrid(size=(32, 32, 32), extent=(1, 2, 3))
RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}
                   domain: x ∈ [0.0, 1.0], y ∈ [0.0, 2.0], z ∈ [-3.0, 0.0]
                 topology: (Periodic, Periodic, Bounded)
  resolution (Nx, Ny, Nz): (32, 32, 32)
   halo size (Hx, Hy, Hz): (1, 1, 1)
grid spacing (Δx, Δy, Δz): (0.03125, 0.0625, 0.09375)</code></pre><pre><code class="language-julia-repl">julia&gt; using Oceananigans

julia&gt; grid = RegularCartesianGrid(Float32; size=(32, 32, 16), x=(0, 8), y=(-10, 10), z=(-π, π))
RegularCartesianGrid{Float32, Periodic, Periodic, Bounded}
                   domain: x ∈ [0.0, 8.0], y ∈ [-10.0, 10.0], z ∈ [-3.1415927, 3.1415927]
                 topology: (Periodic, Periodic, Bounded)
  resolution (Nx, Ny, Nz): (32, 32, 16)
   halo size (Hx, Hy, Hz): (1, 1, 1)
grid spacing (Δx, Δy, Δz): (0.25f0, 0.625f0, 0.3926991f0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Grids/regular_cartesian_grid.jl#L35-L116">source</a></section></article><h2 id="Logger"><a class="docs-heading-anchor" href="#Logger">Logger</a><a id="Logger-1"></a><a class="docs-heading-anchor-permalink" href="#Logger" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Logger.OceananigansLogger" href="#Oceananigans.Logger.OceananigansLogger"><code>Oceananigans.Logger.OceananigansLogger</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OceananigansLogger(stream::IO=stdout, level=Logging.Info; show_info_source=false)</code></pre><p>Based on Logging.SimpleLogger, it tries to log all messages in the following format:</p><pre><code class="language-none">[yyyy/mm/dd HH:MM:SS.sss] log_level message [-@-&gt; source_file:line_number]</code></pre><p>where the source of the message between the square brackets is included only if <code>show_info_source=true</code> or if the message is not an info level message.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Logger.jl#L26-L35">source</a></section></article><h2 id="Models"><a class="docs-heading-anchor" href="#Models">Models</a><a id="Models-1"></a><a class="docs-heading-anchor-permalink" href="#Models" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Models.state-Tuple{Any}" href="#Oceananigans.Models.state-Tuple{Any}"><code>Oceananigans.Models.state</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">state(model)</code></pre><p>Returns a <code>NamedTuple</code> with fields <code>velocities, tracers, diffusivities, tendencies</code>  corresponding to <code>NamedTuple</code>s of <code>OffsetArray</code>s that reference each of the field&#39;s data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Models/Models.jl#L24-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Models.Clock" href="#Oceananigans.Models.Clock"><code>Oceananigans.Models.Clock</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Clock{T&lt;:Number}</code></pre><p>Keeps track of the current <code>time</code>, <code>iteration</code> number, and time-stepping <code>stage</code>. <code>stage</code> is updated only for multi-stage time-stepping methods. The <code>time::T</code> can be either a number of a <code>DateTime</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Models/clock.jl#L5-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Models.Clock-Tuple{}" href="#Oceananigans.Models.Clock-Tuple{}"><code>Oceananigans.Models.Clock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Clock(; time, iteration=0, stage=1)</code></pre><p>Returns a <code>Clock</code> initialized to the zeroth iteration and first time step stage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Models/clock.jl#L27-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Models.IncompressibleModel-Tuple{}" href="#Oceananigans.Models.IncompressibleModel-Tuple{}"><code>Oceananigans.Models.IncompressibleModel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">IncompressibleModel(;
               grid,
       architecture = CPU(),
         float_type = Float64,
              clock = Clock{float_type}(0, 0, 1),
          advection = CenteredSecondOrder(),
           buoyancy = SeawaterBuoyancy(float_type),
           coriolis = nothing,
      surface_waves = nothing,
            forcing = ModelForcing(),
            closure = IsotropicDiffusivity(float_type, ν=ν₀, κ=κ₀),
boundary_conditions = (u=UVelocityBoundaryConditions(grid),
                       v=VVelocityBoundaryConditions(grid),
                       w=WVelocityBoundaryConditions(grid)),
            tracers = (:T, :S),
        timestepper = :QuasiAdamsBashforth2,
         velocities = VelocityFields(architecture, grid, boundary_conditions),
          pressures = PressureFields(architecture, grid, boundary_conditions),
      diffusivities = DiffusivityFields(architecture, grid, tracernames(tracers), boundary_conditions, closure),
    pressure_solver = PressureSolver(architecture, grid, PressureBoundaryConditions(grid))
)</code></pre><p>Construct an incompressible <code>Oceananigans.jl</code> model on <code>grid</code>.</p><p><strong>Keyword arguments</strong></p><pre><code class="language-none">- `grid`: (required) The resolution and discrete geometry on which `model` is solved.
- `architecture`: `CPU()` or `GPU()`. The computer architecture used to time-step `model`.
- `float_type`: `Float32` or `Float64`. The floating point type used for `model` data.
- `advection`: The scheme that advects velocities and tracers. See `Oceananigans.Advection`.
- `buoyancy`: The buoyancy model. See `Oceananigans.Buoyancy`.
- `closure`: The turbulence closure for `model`. See `Oceananigans.TurbulenceClosures`.
- `coriolis`: Parameters for the background rotation rate of the model.
- `forcing`: User-defined forcing functions that contribute to solution tendencies.
- `boundary_conditions`: `NamedTuple` containing field boundary conditions.
- `tracers`: A tuple of symbols defining the names of the modeled tracers, or a `NamedTuple` of
             preallocated `CellField`s.
- `timestepper`: A symbol that species the time-stepping method. Either `:QuasiAdamsBashforth2` or
                 `:RungeKutta3`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Models/incompressible_model.jl#L29-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Models.NonDimensionalModel-Tuple{}" href="#Oceananigans.Models.NonDimensionalModel-Tuple{}"><code>Oceananigans.Models.NonDimensionalModel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">NonDimensionalModel(; N, L, Re, Pr=0.7, Ro=Inf, float_type=Float64, kwargs...)</code></pre><p>Construct a &quot;Non-dimensional&quot; <code>Model</code> with resolution <code>N</code>, domain extent <code>L</code>, precision <code>float_type</code>, and the four non-dimensional numbers:</p><pre><code class="language-none">* `Re = U λ / ν` (Reynolds number)
* `Pr = U λ / κ` (Prandtl number)
* `Ro = U / f λ` (Rossby number)</code></pre><p>for characteristic velocity scale <code>U</code>, length-scale <code>λ</code>, viscosity <code>ν</code>, tracer diffusivity <code>κ</code>, and Coriolis parameter <code>f</code>. Buoyancy is scaled with <code>λ U²</code>, so that the Richardson number is <code>Ri=B</code>, where <code>B</code> is a non-dimensional buoyancy scale set by the user via initial conditions or forcing.</p><p>Note that <code>N</code>, <code>L</code>, and <code>Re</code> are required.</p><p>Additional <code>kwargs</code> are passed to the regular <code>IncompressibleModel</code> constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Models/non_dimensional_model.jl#L3-L22">source</a></section></article><h2 id="Output-writers"><a class="docs-heading-anchor" href="#Output-writers">Output writers</a><a id="Output-writers-1"></a><a class="docs-heading-anchor-permalink" href="#Output-writers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.JLD2OutputWriter" href="#Oceananigans.OutputWriters.JLD2OutputWriter"><code>Oceananigans.OutputWriters.JLD2OutputWriter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">JLD2OutputWriter{I, T, O, IF, IN, KW} &lt;: AbstractOutputWriter</code></pre><p>An output writer for writing to JLD2 files.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/OutputWriters/jld2_output_writer.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.JLD2OutputWriter-Tuple{Any,Any}" href="#Oceananigans.OutputWriters.JLD2OutputWriter-Tuple{Any,Any}"><code>Oceananigans.OutputWriters.JLD2OutputWriter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JLD2OutputWriter(model, outputs; prefix,
                                                   dir = &quot;.&quot;,
                                    iteration_interval = nothing,
                                         time_interval = nothing,
                                 time_averaging_window = nothing,
                                 time_averaging_stride = 1,
                                          max_filesize = Inf,
                                                 force = false,
                                                  init = noinit,
                                             including = [:grid, :coriolis, :buoyancy, :closure],
                                               verbose = false,
                                                  part = 1,
                                            array_type = Array{Float32},
                                               jld2_kw = Dict{Symbol, Any}())</code></pre><p>Construct a <code>JLD2OutputWriter</code> for an Oceananigans <code>model</code> that writes <code>label, output</code> pairs in <code>outputs</code> to a JLD2 file.</p><p>The argument <code>outputs</code> may be a <code>Dict</code> or <code>NamedTuple</code>. The keys of <code>outputs</code> are symbols or strings that &quot;name&quot; output data. The values of <code>outputs</code> are either <code>AbstractField</code>s, objects that are called with the signature <code>output(model)</code>, or <code>WindowedTimeAverage</code>s of <code>AbstractFields</code>s, functions, or callable objects.</p><p><strong>Keyword arguments</strong></p><pre><code class="language-none">## Filenaming

- `prefix`: Descriptive filename prefixed to all output files.

- `dir`: Directory to save output to.
         Default: &quot;.&quot; (current working directory).

## Output frequency and time-averaging

- `iteration_interval`: Save output every `iteration_interval` model iterations.

- `time_interval`: Save output every `time_interval` units of `model.clock.time`.

- `time_averaging_window`: Specifies a time window over which each member of `output` is averaged before    
                           being saved. For this each member of output is converted to 
                           `Oceananigans.Diagnostics.WindowedTimeAverage`.
                           Default `nothing` indicates no averaging.

- `time_averaging_stride`: Specifies a iteration &#39;stride&#39; between the calculation of each `output` during
                           time-averaging. Longer strides means that output is calculated less frequently,
                           and that the resulting time-average is faster to compute, but less accurate.
                           Default: 1.

## Slicing and type conversion prior to output

- `field_slicer`: An object for slicing field output in ``(x, y, z)``, including omitting halos.
                  Has no effect on output that is not a field. `field_slicer = nothing` means
                  no slicing occurs, so that all field data, including halo regions, is saved.
                  Default: FieldSlicer(), which slices halo regions.

- `array_type`: The array type to which output arrays are converted to prior to saving.
                Default: Array{Float32}.

## File management

- `max_filesize`: The writer will stop writing to the output file once the file size exceeds `max_filesize`,
                  and write to a new one with a consistent naming scheme ending in `part1`, `part2`, etc.
                  Defaults to `Inf`.

- `force`: Remove existing files if their filenames conflict.
           Default: `false`.

## Output file metadata management

- `init`: A function of the form `init(file, model)` that runs when a JLD2 output file is initialized.
          Default: `noinit(args...) = nothing`.

- `including`: List of model properties to save with every file.
               Default: `[:grid, :coriolis, :buoyancy, :closure]`

## Miscellaneous keywords

- `verbose`: Log what the output writer is doing with statistics on compute/write times and file sizes.
             Default: `false`.

- `part`: The starting part number used if `max_filesize` is finite.
          Default: 1.

- `jld2_kw`: Dict of kwargs to be passed to `jldopen` when data is written.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/OutputWriters/jld2_output_writer.jl#L29-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.NetCDFOutputWriter" href="#Oceananigans.OutputWriters.NetCDFOutputWriter"><code>Oceananigans.OutputWriters.NetCDFOutputWriter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NetCDFOutputWriter{D, O, I, T, S} &lt;: AbstractOutputWriter</code></pre><p>An output writer for writing to NetCDF files.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/OutputWriters/netcdf_output_writer.jl#L24-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.NetCDFOutputWriter-Tuple{Any,Any}" href="#Oceananigans.OutputWriters.NetCDFOutputWriter-Tuple{Any,Any}"><code>Oceananigans.OutputWriters.NetCDFOutputWriter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">NetCDFOutputWriter(model, outputs; filename, iteration_interval=nothing, time_interval=nothing,
                   global_attributes=Dict(), output_attributes=Dict(), dimensions=Dict(),
                   mode=&quot;c&quot;, compression=0, with_halos=false, verbose=false, slice_kwargs...)</code></pre><p>Construct a <code>NetCDFOutputWriter</code> that writes <code>(label, output)</code> pairs in <code>outputs</code> (which should be a <code>Dict</code>) to a NetCDF file, where <code>label</code> is a string that labels the output and <code>output</code> is either a field from the model (e.g. <code>model.velocities.u</code>) or a function <code>f(model)</code> that returns something to be written to disk. Custom output requires the spatial <code>dimensions</code> to be manually specified.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>iteration_interval</code>: Save output every <code>n</code> model iterations.</p></li><li><p><code>time_interval</code>: Save output every <code>t</code> units of model clock time.</p></li><li><p><code>filename</code>: Filepath to save output to.</p></li><li><p><code>global_attributes</code>: Dict of model properties to save with every file (deafult: <code>Dict()</code>)</p></li><li><p><code>output_attributes</code>: Dict of attributes to be saved with each field variable (reasonable defaults are provided for velocities, buoyancy, temperature, and salinity).</p></li><li><p><code>dimensions</code>: A <code>Dict</code> of dimension tuples to apply to outputs (useful for function outputs as field dimensions can be inferred).</p></li><li><p><code>with_halos</code>: Include the halo regions in the grid coordinates and output fields (default: <code>false</code>).</p></li><li><p><code>mode</code>: &quot;a&quot; (for append) and &quot;c&quot; (for clobber or create). Default: &quot;c&quot;. See NCDatasets.jl documentation for more information on the <code>mode</code> option.</p></li><li><p><code>compression</code>: Determines the compression level of data (0-9, default 0)</p></li><li><p><code>slice_kwargs</code>: <code>dimname = Union{OrdinalRange, Integer}</code> will slice the dimension <code>dimname</code>. All other keywords are ignored. E.g. <code>xC = 3:10</code> will only produce output along the dimension <code>xC</code> between indices 3 and 10 for all fields with <code>xC</code> as one of their dimensions. <code>xC = 1</code> is treated like <code>xC = 1:1</code>. Multiple dimensions can be sliced in one call. Not providing slices writes output over the entire domain (including halo regions if <code>with_halos=true</code>).</p></li></ul><p><strong>Examples</strong></p><p>Saving the u velocity field and temperature fields, the full 3D fields and surface 2D slices to separate NetCDF files:</p><pre><code class="language-julia">using Oceananigans, Oceananigans.OutputWriters

grid = RegularCartesianGrid(size=(16, 16, 16), extent=(1, 1, 1));

model = IncompressibleModel(grid=grid);

simulation = Simulation(model, Δt=12, stop_time=3600);

fields = Dict(&quot;u&quot; =&gt; model.velocities.u, &quot;T&quot; =&gt; model.tracers.T);

simulation.output_writers[:field_writer] =
    NetCDFOutputWriter(model, fields, filename=&quot;fields.nc&quot;, time_interval=60)

# output
NetCDFOutputWriter (time_interval=60): fields.nc
├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0)
└── 2 outputs: [&quot;T&quot;, &quot;u&quot;]</code></pre><pre><code class="language-julia">simulation.output_writers[:surface_slice_writer] =
    NetCDFOutputWriter(model, fields, filename=&quot;surface_xy_slice.nc&quot;,
                       time_interval=60, zC=grid.Nz, zF=grid.Nz+1)

# output
NetCDFOutputWriter (time_interval=60): surface_xy_slice.nc
├── dimensions: zC(1), zF(1), xC(16), yF(16), xF(16), yC(16), time(0)
└── 2 outputs: [&quot;T&quot;, &quot;u&quot;]</code></pre><p>Writing a scalar, profile, and slice to NetCDF:</p><pre><code class="language-julia">using Oceananigans, Oceananigans.OutputWriters

grid = RegularCartesianGrid(size=(16, 16, 16), extent=(1, 2, 3));

model = IncompressibleModel(grid=grid);

simulation = Simulation(model, Δt=1.25, stop_iteration=3);

f(model) = model.clock.time^2; # scalar output

g(model) = model.clock.time .* exp.(znodes(Cell, grid)); # vector/profile output

h(model) = model.clock.time .* (   sin.(xnodes(Cell, grid, reshape=true)[:, :, 1])
                            .*     cos.(ynodes(Face, grid, reshape=true)[:, :, 1])); # xy slice output

outputs = Dict(&quot;scalar&quot; =&gt; f, &quot;profile&quot; =&gt; g, &quot;slice&quot; =&gt; h);

dims = Dict(&quot;scalar&quot; =&gt; (), &quot;profile&quot; =&gt; (&quot;zC&quot;,), &quot;slice&quot; =&gt; (&quot;xC&quot;, &quot;yC&quot;));

output_attributes = Dict(
    &quot;scalar&quot;  =&gt; Dict(&quot;longname&quot; =&gt; &quot;Some scalar&quot;, &quot;units&quot; =&gt; &quot;bananas&quot;),
    &quot;profile&quot; =&gt; Dict(&quot;longname&quot; =&gt; &quot;Some vertical profile&quot;, &quot;units&quot; =&gt; &quot;watermelons&quot;),
    &quot;slice&quot;   =&gt; Dict(&quot;longname&quot; =&gt; &quot;Some slice&quot;, &quot;units&quot; =&gt; &quot;mushrooms&quot;)
);

global_attributes = Dict(&quot;location&quot; =&gt; &quot;Bay of Fundy&quot;, &quot;onions&quot; =&gt; 7);

simulation.output_writers[:things] =
    NetCDFOutputWriter(model, outputs,
                       iteration_interval=1, filename=&quot;things.nc&quot;, dimensions=dims, verbose=true,
                       global_attributes=global_attributes, output_attributes=output_attributes)

# output
NetCDFOutputWriter (iteration_interval=1): things.nc
├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0)
└── 3 outputs: [&quot;profile&quot;, &quot;slice&quot;, &quot;scalar&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/OutputWriters/netcdf_output_writer.jl#L41-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.write_output-Tuple{Any,NetCDFOutputWriter}" href="#Oceananigans.OutputWriters.write_output-Tuple{Any,NetCDFOutputWriter}"><code>Oceananigans.OutputWriters.write_output</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">write_output(model, OutputWriter)</code></pre><p>Writes output to the netcdf file at specified intervals. Increments the <code>time</code> dimension every time an output is written to the file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/OutputWriters/netcdf_output_writer.jl#L322-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.Checkpointer" href="#Oceananigans.OutputWriters.Checkpointer"><code>Oceananigans.OutputWriters.Checkpointer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Checkpointer{I, T, P} &lt;: AbstractOutputWriter</code></pre><p>An output writer for checkpointing models to a JLD2 file from which models can be restored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/OutputWriters/checkpointer.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.Checkpointer-Tuple{Any}" href="#Oceananigans.OutputWriters.Checkpointer-Tuple{Any}"><code>Oceananigans.OutputWriters.Checkpointer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Checkpointer(model; iteration_interval=nothing, time_interval=nothing, dir=&quot;.&quot;,
             prefix=&quot;checkpoint&quot;, force=false, verbose=false,
             properties = [:architecture, :boundary_conditions, :grid, :clock, :coriolis,
                           :buoyancy, :closure, :velocities, :tracers, :timestepper])</code></pre><p>Construct a <code>Checkpointer</code> that checkpoints the model to a JLD2 file every so often as specified by <code>iteration_interval</code> or <code>time_interval</code>. The <code>model.clock.iteration</code> is included in the filename to distinguish between multiple checkpoint files.</p><p>Note that extra model <code>properties</code> can be safely specified, but removing crucial properties such as <code>:velocities</code> will make restoring from the checkpoint impossible.</p><p>The checkpoint file is generated by serializing model properties to JLD2. However, functions cannot be serialized to disk (at least not with JLD2). So if a model property contains a reference somewhere in its hierarchy it will not be included in the checkpoint file (and you will have to manually restore them).</p><p><strong>Keyword arguments</strong></p><ul><li><code>iteration_interval</code>: Save output every <code>n</code> model iterations.</li><li><code>time_interval</code>: Save output every <code>t</code> units of model clock time.</li><li><code>dir</code>: Directory to save output to. Default: &quot;.&quot; (current working directory).</li><li><code>prefix</code>: Descriptive filename prefixed to all output files. Default: &quot;checkpoint&quot;.</li><li><code>force</code>: Remove existing files if their filenames conflict. Default: <code>false</code>.</li><li><code>verbose</code>: Log what the output writer is doing with statistics on compute/write times and file sizes. Default: <code>false</code>.</li><li><code>properties</code>: List of model properties to checkpoint. Some are required.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/OutputWriters/checkpointer.jl#L17-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.restore_from_checkpoint-Tuple{Any}" href="#Oceananigans.OutputWriters.restore_from_checkpoint-Tuple{Any}"><code>Oceananigans.OutputWriters.restore_from_checkpoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">restore_from_checkpoint(filepath; kwargs=Dict())</code></pre><p>Restore a model from the checkpoint file stored at <code>filepath</code>. <code>kwargs</code> can be passed to the model constructor, which can be especially useful if you need to manually restore forcing functions or boundary conditions that rely on functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/OutputWriters/checkpointer.jl#L129-L135">source</a></section></article><h2 id="Time-steppers"><a class="docs-heading-anchor" href="#Time-steppers">Time steppers</a><a id="Time-steppers-1"></a><a class="docs-heading-anchor-permalink" href="#Time-steppers" title="Permalink"></a></h2><h2 id="Simulations"><a class="docs-heading-anchor" href="#Simulations">Simulations</a><a id="Simulations-1"></a><a class="docs-heading-anchor-permalink" href="#Simulations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Simulations.TimeStepWizard-Tuple{}" href="#Oceananigans.Simulations.TimeStepWizard-Tuple{}"><code>Oceananigans.Simulations.TimeStepWizard</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">TimeStepWizard(cfl=0.1, max_change=2.0, min_change=0.5, max_Δt=Inf)</code></pre><p>A type for calculating adaptive time steps based on capping the CFL number at <code>cfl</code>.</p><p>On calling <code>update_Δt!(wizard, model)</code>, the <code>TimeStepWizard</code> computes a time-step such that <span>$cfl = max(u/Δx, v/Δy, w/Δz) Δt$</span>, where <span>$max(u/Δx, v/Δy, w/Δz)$</span> is the maximum ratio between model velocity and along-velocity grid spacing anywhere on the model grid. The new <code>Δt</code> is constrained to change by a multiplicative factor no more than <code>max_change</code> or no less than <code>min_change</code> from the previous <code>Δt</code>, and to be no greater in absolute magnitude than <code>max_Δt</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Simulations/time_step_wizard.jl#L10-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Simulations.Simulation-Tuple{Any}" href="#Oceananigans.Simulations.Simulation-Tuple{Any}"><code>Oceananigans.Simulations.Simulation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Simulation(model; Δt,
     stop_criteria = Function[iteration_limit_exceeded, stop_time_exceeded, wall_time_limit_exceeded],
    stop_iteration = Inf,
         stop_time = Inf,
   wall_time_limit = Inf,
       diagnostics = OrderedDict{Symbol, AbstractDiagnostic}(),
    output_writers = OrderedDict{Symbol, AbstractOutputWriter}(),
          progress = nothing,
iteration_interval = 1,
        parameters = nothing)</code></pre><p>Construct an Oceananigans.jl <code>Simulation</code> for a <code>model</code> with time step <code>Δt</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>Δt</code>: Required keyword argument specifying the simulation time step. Can be a <code>Number</code> for constant time steps or a <code>TimeStepWizard</code> for adaptive time-stepping.</li><li><code>stop_criteria</code>: A list of functions or callable objects (each taking a single argument, the <code>simulation</code>). If any of the functions return <code>true</code> when the stop criteria is evaluated the simulation will stop.</li><li><code>stop_iteration</code>: Stop the simulation after this many iterations.</li><li><code>stop_time</code>: Stop the simulation once this much model clock time has passed.</li><li><code>wall_time_limit</code>: Stop the simulation if it&#39;s been running for longer than this many  seconds of wall clock time.</li><li><code>progress</code>: A function with a single argument, the <code>simulation</code>. Will be called every <code>iteration_interval</code> iterations. Useful for logging simulation health.</li><li><code>iteration_interval</code>: How often to update the time step, check stop criteria, and call <code>progress</code> function (in number of iterations).</li><li><code>parameters</code>: Parameters that can be accessed in the <code>progress</code> function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Simulations/simulation.jl#L18-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Simulations.run!-Tuple{Any}" href="#Oceananigans.Simulations.run!-Tuple{Any}"><code>Oceananigans.Simulations.run!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">run!(simulation)</code></pre><p>Run a <code>simulation</code> until one of the stop criteria evaluates to true. The simulation will then stop.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Simulations/run.jl#L63-L68">source</a></section></article><h2 id="Tubrulence-closures"><a class="docs-heading-anchor" href="#Tubrulence-closures">Tubrulence closures</a><a id="Tubrulence-closures-1"></a><a class="docs-heading-anchor-permalink" href="#Tubrulence-closures" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.AbstractIsotropicDiffusivity" href="#Oceananigans.TurbulenceClosures.AbstractIsotropicDiffusivity"><code>Oceananigans.TurbulenceClosures.AbstractIsotropicDiffusivity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractIsotropicDiffusivity &lt;: AbstractTurbulenceClosure</code></pre><p>Abstract supertype for turbulence closures that are defined by an isotropic viscosity and isotropic diffusivities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/TurbulenceClosures/TurbulenceClosures.jl#L64-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation" href="#Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation"><code>Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AnisotropicMinimumDissipation</code></pre><p>An alias for <code>VerstappenAnisotropicMinimumDissipation</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/TurbulenceClosures/TurbulenceClosures.jl#L182-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.ConstantSmagorinsky" href="#Oceananigans.TurbulenceClosures.ConstantSmagorinsky"><code>Oceananigans.TurbulenceClosures.ConstantSmagorinsky</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConstantSmagorinsky</code></pre><p>An alias for <code>SmagorinskyLilly</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/TurbulenceClosures/TurbulenceClosures.jl#L189-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.∂ⱼ_2ν_Σ₁ⱼ-Tuple{Any,Any,Any,Any,Any,AbstractIsotropicDiffusivity,Any,Any}" href="#Oceananigans.TurbulenceClosures.∂ⱼ_2ν_Σ₁ⱼ-Tuple{Any,Any,Any,Any,Any,AbstractIsotropicDiffusivity,Any,Any}"><code>Oceananigans.TurbulenceClosures.∂ⱼ_2ν_Σ₁ⱼ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∂ⱼ_2ν_Σ₁ⱼ(i, j, k, grid, closure, U, diffusivities)</code></pre><p>Return the <span>$x$</span>-component of the turbulent diffusive flux divergence:</p><p><code>∂x(2 ν Σ₁₁) + ∂y(2 ν Σ₁₁) + ∂z(2 ν Σ₁₁)</code></p><p>at the location <code>fcc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/TurbulenceClosures/closure_operators.jl#L107-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.∂ⱼ_2ν_Σ₂ⱼ-Tuple{Any,Any,Any,Any,Any,AbstractIsotropicDiffusivity,Any,Any}" href="#Oceananigans.TurbulenceClosures.∂ⱼ_2ν_Σ₂ⱼ-Tuple{Any,Any,Any,Any,Any,AbstractIsotropicDiffusivity,Any,Any}"><code>Oceananigans.TurbulenceClosures.∂ⱼ_2ν_Σ₂ⱼ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∂ⱼ_2ν_Σ₂ⱼ(i, j, k, grid, closure, U, diffusivities)</code></pre><p>Return the <span>$y$</span>-component of the turbulent diffusive flux divergence:</p><p><code>∂x(2 ν Σ₂₁) + ∂y(2 ν Σ₂₂) + ∂z(2 ν Σ₂₂)</code></p><p>at the location <code>ccf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/TurbulenceClosures/closure_operators.jl#L122-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.∂ⱼ_2ν_Σ₃ⱼ-Tuple{Any,Any,Any,Any,Any,AbstractIsotropicDiffusivity,Any,Any}" href="#Oceananigans.TurbulenceClosures.∂ⱼ_2ν_Σ₃ⱼ-Tuple{Any,Any,Any,Any,Any,AbstractIsotropicDiffusivity,Any,Any}"><code>Oceananigans.TurbulenceClosures.∂ⱼ_2ν_Σ₃ⱼ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∂ⱼ_2ν_Σ₃ⱼ(i, j, k, grid, closure, diffusivities)</code></pre><p>Return the <span>$z$</span>-component of the turbulent diffusive flux divergence:</p><p><code>∂x(2 ν Σ₃₁) + ∂y(2 ν Σ₃₂) + ∂z(2 ν Σ₃₃)</code></p><p>at the location <code>ccf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/TurbulenceClosures/closure_operators.jl#L137-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.AnisotropicBiharmonicDiffusivity" href="#Oceananigans.TurbulenceClosures.AnisotropicBiharmonicDiffusivity"><code>Oceananigans.TurbulenceClosures.AnisotropicBiharmonicDiffusivity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AnisotropicBiharmonicDiffusivity{FT, KH, KZ}</code></pre><p>Parameters for anisotropic biharmonic diffusivity models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_biharmonic_diffusivity.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.AnisotropicBiharmonicDiffusivity" href="#Oceananigans.TurbulenceClosures.AnisotropicBiharmonicDiffusivity"><code>Oceananigans.TurbulenceClosures.AnisotropicBiharmonicDiffusivity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AnisotropicBiharmonicDiffusivity(FT=Float64; νx=0, νy=0, νz=0, νh=nothing, κx=0, κy=0, κz=0, κh=nothing)</code></pre><p>Returns parameters for a fourth-order, anisotropic biharmonic diffusivity closure with constant x-, y, and z-direction biharmonic viscosities <code>νx</code>, <code>νy</code>, and <code>νz</code>, and constant x-, y, and z-direction biharmonic diffusivities <code>κx</code>, <code>κy</code>, and <code>κz</code>, <code>κx</code>, <code>κy</code>, and <code>κz</code> may be <code>NamedTuple</code>s with fields corresponding to each tracer, or a single number to be a applied to all tracers.</p><p>If <code>νh</code> or <code>κh</code> are provided, then <code>νx = νy = νh</code> or <code>κx = κy = κh</code>.</p><p>The tracer flux divergence associated with an anisotropic biharmonic diffusivity is, for example</p><div>\[    ∂ᵢ κᵢⱼ ∂ⱼc = - [κx ∂⁴x + κy ∂⁴y + κz ∂⁴z] c\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_biharmonic_diffusivity.jl#L15-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.SmagorinskyLilly" href="#Oceananigans.TurbulenceClosures.SmagorinskyLilly"><code>Oceananigans.TurbulenceClosures.SmagorinskyLilly</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SmagorinskyLilly{FT} &lt;: AbstractSmagorinsky{FT}</code></pre><p>Parameters for the Smagorinsky-Lilly turbulence closure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl#L6-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.SmagorinskyLilly" href="#Oceananigans.TurbulenceClosures.SmagorinskyLilly"><code>Oceananigans.TurbulenceClosures.SmagorinskyLilly</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SmagorinskyLilly([FT=Float64;] C=0.23, Pr=1, ν=1.05e-6, κ=1.46e-7)</code></pre><p>Return a <code>SmagorinskyLilly</code> type associated with the turbulence closure proposed by Lilly (1962) and Smagorinsky (1958, 1963), which has an eddy viscosity of the form</p><pre><code class="language-none">`νₑ = (C * Δᶠ)² * √(2Σ²) * √(1 - Cb * N² / Σ²) + ν`,</code></pre><p>and an eddy diffusivity of the form</p><pre><code class="language-none">`κₑ = (νₑ - ν) / Pr + κ`</code></pre><p>where <code>Δᶠ</code> is the filter width, <code>Σ² = ΣᵢⱼΣᵢⱼ</code> is the double dot product of the strain tensor <code>Σᵢⱼ</code>, <code>Pr</code> is the turbulent Prandtl number, and <code>N²</code> is the total buoyancy gradient, and <code>Cb</code> is a constant the multiplies the Richardson number modification to the eddy viscosity.</p><p><strong>Keyword arguments</strong></p><pre><code class="language-none">- `C`  : Model constant
- `Cb` : Buoyancy term multipler (`Cb = 0` turns it off, `Cb ≠ 0` turns it on.
         Typically `Cb=1/Pr`.)
- `Pr` : Turbulent Prandtl numbers for each tracer. Either a constant applied to every
         tracer, or a `NamedTuple` with fields for each tracer individually.
- `ν`  : Constant background viscosity for momentum
- `κ`  : Constant background diffusivity for tracer. Can either be a single number
         applied to all tracers, or `NamedTuple` of diffusivities corresponding to each
         tracer.</code></pre><p><strong>References</strong></p><p>Smagorinsky, J. &quot;On the numerical integration of the primitive equations of motion for     baroclinic flow in a closed region.&quot; Monthly Weather Review (1958)</p><p>Lilly, D. K. &quot;On the numerical simulation of buoyant convection.&quot; Tellus (1962)</p><p>Smagorinsky, J. &quot;General circulation experiments with the primitive equations: I.     The basic experiment.&quot; Monthly weather review (1963)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl#L25-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.∇_κ_∇c-Tuple{Any,Any,Any,Any,Any,Oceananigans.TurbulenceClosures.AbstractSmagorinsky,Any,Any,Any,Vararg{Any,N} where N}" href="#Oceananigans.TurbulenceClosures.∇_κ_∇c-Tuple{Any,Any,Any,Any,Any,Oceananigans.TurbulenceClosures.AbstractSmagorinsky,Any,Any,Any,Vararg{Any,N} where N}"><code>Oceananigans.TurbulenceClosures.∇_κ_∇c</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∇_κ_∇c(i, j, k, grid, clock, c, closure, diffusivities)</code></pre><p>Return the diffusive flux divergence <code>∇ ⋅ (κ ∇ c)</code> for the turbulence <code>closure</code>, where <code>c</code> is an array of scalar data located at cell centers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl#L166-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.IsotropicDiffusivity" href="#Oceananigans.TurbulenceClosures.IsotropicDiffusivity"><code>Oceananigans.TurbulenceClosures.IsotropicDiffusivity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IsotropicDiffusivity{N, K}</code></pre><p>Holds viscosity and diffusivities for models with prescribed isotropic diffusivities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/TurbulenceClosures/turbulence_closure_implementations/isotropic_diffusivity.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.IsotropicDiffusivity" href="#Oceananigans.TurbulenceClosures.IsotropicDiffusivity"><code>Oceananigans.TurbulenceClosures.IsotropicDiffusivity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IsotropicDiffusivity(; ν=ν₀, κ=κ₀)</code></pre><p>Returns parameters for an isotropic diffusivity model with viscosity <code>ν</code> and thermal diffusivities <code>κ</code> for each tracer field in <code>tracers</code> <code>ν</code> and the fields of <code>κ</code> may be constants or functions of <code>(x, y, z, t)</code>, and may represent molecular diffusivities in cases that all flow features are explicitly resovled, or turbulent eddy diffusivities that model the effect of unresolved, subgrid-scale turbulence. <code>κ</code> may be a <code>NamedTuple</code> with fields corresponding to each tracer, or a single number to be a applied to all tracers.</p><p>By default, a molecular viscosity of <code>ν₀ = 1.05×10⁻⁶</code> m² s⁻¹ and a molecular thermal diffusivity of <code>κ₀ = 1.46×10⁻⁷</code> m² s⁻¹ is used for each tracer. These molecular values are the approximate viscosity and thermal diffusivity for seawater at 20°C and 35 psu, according to Sharqawy et al., &quot;Thermophysical properties of seawater: A review of existing correlations and data&quot; (2010).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/TurbulenceClosures/turbulence_closure_implementations/isotropic_diffusivity.jl#L11-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.VerstappenAnisotropicMinimumDissipation" href="#Oceananigans.TurbulenceClosures.VerstappenAnisotropicMinimumDissipation"><code>Oceananigans.TurbulenceClosures.VerstappenAnisotropicMinimumDissipation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">VerstappenAnisotropicMinimumDissipation{FT} &lt;: AbstractAnisotropicMinimumDissipation{FT}</code></pre><p>Parameters for the anisotropic minimum dissipation large eddy simulation model proposed by Verstappen (2018) and described by Vreugdenhil &amp; Taylor (2018).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/TurbulenceClosures/turbulence_closure_implementations/verstappen_anisotropic_minimum_dissipation.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.VerstappenAnisotropicMinimumDissipation" href="#Oceananigans.TurbulenceClosures.VerstappenAnisotropicMinimumDissipation"><code>Oceananigans.TurbulenceClosures.VerstappenAnisotropicMinimumDissipation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">VerstappenAnisotropicMinimumDissipation(FT=Float64; C=1/12, Cν=nothing, Cκ=nothing,
                                        Cb=0.0, ν=ν₀, κ=κ₀)</code></pre><p>Returns parameters of type <code>FT</code> for the <code>VerstappenAnisotropicMinimumDissipation</code> turbulence closure.</p><p><strong>Keyword arguments</strong></p><pre><code class="language-none">- `C`  : Poincaré constant for both eddy viscosity and eddy diffusivities. `C` is overridden
         for eddy viscosity or eddy diffusivity if `Cν` or `Cκ` are set, respecitvely.
- `Cν` : Poincaré constant for momentum eddy viscosity.
- `Cκ` : Poincaré constant for tracer eddy diffusivities. If one number or function, the same
         number or function is applied to all tracers. If a `NamedTuple`, it must possess
         a field specifying the Poncaré constant for every tracer.
- `Cb` : Buoyancy modification multiplier (`Cb = 0` turns it off, `Cb = 1` turns it on)
- `ν`  : Constant background viscosity for momentum.
- `κ`  : Constant background diffusivity for tracer. If a single number, the same background
         diffusivity is applied to all tracers. If a `NamedTuple`, it must possess a field
         specifying a background diffusivity for every tracer.</code></pre><p>By default: <code>C = Cν = Cκ</code> = 1/12, which is appropriate for a finite-volume method employing a second-order advection scheme, <code>Cb</code> = 0, which terms off the buoyancy modification term, the molecular viscosity of seawater at 20 deg C and 35 psu is used for <code>ν</code>, and the molecular diffusivity of heat in seawater at 20 deg C and 35 psu is used for <code>κ</code>.</p><p><code>Cν</code> or <code>Cκ</code> may be constant numbers, or functions of <code>x, y, z</code>.</p><p><strong>Example</strong></p><p>julia&gt; pretty<em>diffusive</em>closure = AnisotropicMinimumDissipation(C=1/2) VerstappenAnisotropicMinimumDissipation{Float64} turbulence closure with:            Poincaré constant for momentum eddy viscosity Cν: 0.5     Poincaré constant for tracer(s) eddy diffusivit(ies) Cκ: 0.5                         Buoyancy modification multiplier Cb: 0.0                 Background diffusivit(ies) for tracer(s), κ: 1.46e-7              Background kinematic viscosity for momentum, ν: 1.05e-6</p><p>julia&gt; const Δz = 0.5; # grid resolution at surface</p><p>julia&gt; surface<em>enhanced</em>tracer<em>C(x, y, z) = 1/12 * (1 + exp((z + Δz/2) / 8Δz)) surface</em>enhanced<em>tracer</em>C (generic function with 1 method)</p><p>julia&gt; fancy<em>closure = AnisotropicMinimumDissipation(Cκ=surface</em>enhanced<em>tracer</em>C) VerstappenAnisotropicMinimumDissipation{Float64} turbulence closure with:            Poincaré constant for momentum eddy viscosity Cν: 0.08333333333333333     Poincaré constant for tracer(s) eddy diffusivit(ies) Cκ: surface<em>enhanced</em>tracer_C                         Buoyancy modification multiplier Cb: 0.0                 Background diffusivit(ies) for tracer(s), κ: 1.46e-7              Background kinematic viscosity for momentum, ν: 1.05e-6</p><p>julia&gt; tracer<em>specific</em>closure = AnisotropicMinimumDissipation(Cκ=(c₁=1/12, c₂=1/6)) VerstappenAnisotropicMinimumDissipation{Float64} turbulence closure with:            Poincaré constant for momentum eddy viscosity Cν: 0.08333333333333333     Poincaré constant for tracer(s) eddy diffusivit(ies) Cκ: (c₁ = 0.08333333333333333, c₂ = 0.16666666666666666)                         Buoyancy modification multiplier Cb: 0.0                 Background diffusivit(ies) for tracer(s), κ: 1.46e-7              Background kinematic viscosity for momentum, ν: 1.05e-6</p><p><strong>References</strong></p><p>Vreugdenhil C., and Taylor J. (2018), &quot;Large-eddy simulations of stratified plane Couette     flow using the anisotropic minimum-dissipation model&quot;, Physics of Fluids 30, 085104.</p><p>Verstappen, R. (2018), &quot;How much eddy dissipation is needed to counterbalance the nonlinear     production of small, unresolved scales in a large-eddy simulation of turbulence?&quot;,     Computers &amp; Fluids 176, pp. 276-284.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/TurbulenceClosures/turbulence_closure_implementations/verstappen_anisotropic_minimum_dissipation.jl#L29-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.∇_κ_∇c-Union{Tuple{tracer_index}, Tuple{Any,Any,Any,Any,Any,Oceananigans.TurbulenceClosures.AbstractAnisotropicMinimumDissipation,Any,Val{tracer_index},Any,Vararg{Any,N} where N}} where tracer_index" href="#Oceananigans.TurbulenceClosures.∇_κ_∇c-Union{Tuple{tracer_index}, Tuple{Any,Any,Any,Any,Any,Oceananigans.TurbulenceClosures.AbstractAnisotropicMinimumDissipation,Any,Val{tracer_index},Any,Vararg{Any,N} where N}} where tracer_index"><code>Oceananigans.TurbulenceClosures.∇_κ_∇c</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∇_κ_∇c(i, j, k, grid, clock, c, tracer_index, closure, diffusivities)</code></pre><p>Return the diffusive flux divergence <code>∇ ⋅ (κ ∇ c)</code> for the turbulence <code>closure</code>, where <code>c</code> is an array of scalar data located at cell centers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/TurbulenceClosures/turbulence_closure_implementations/verstappen_anisotropic_minimum_dissipation.jl#L159-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.BlasiusSmagorinsky" href="#Oceananigans.TurbulenceClosures.BlasiusSmagorinsky"><code>Oceananigans.TurbulenceClosures.BlasiusSmagorinsky</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BlasiusSmagorinsky{ML, FT}</code></pre><p>Parameters for the version of the Smagorinsky closure used in the UK Met Office code Blasius, according to Polton and Belcher (2007).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/TurbulenceClosures/turbulence_closure_implementations/blasius_smagorinsky.jl#L6-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.BlasiusSmagorinsky" href="#Oceananigans.TurbulenceClosures.BlasiusSmagorinsky"><code>Oceananigans.TurbulenceClosures.BlasiusSmagorinsky</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BlasiusSmagorinsky(FT=Float64; Pr=1.0, ν=1.05e-6, κ=1.46e-7)</code></pre><p>Returns a <code>BlasiusSmagorinsky</code> closure object of type <code>FT</code>.</p><p><strong>Keyword arguments</strong></p><pre><code class="language-none">- `Pr` : Turbulent Prandtl numbers for each tracer. Either a constant applied to every
         tracer, or a `NamedTuple` with fields for each tracer individually.
- `ν`  : Constant background viscosity for momentum
- `κ`  : Constant background diffusivity for tracer. Can either be a single number
         applied to all tracers, or `NamedTuple` of diffusivities corresponding to each
         tracer.</code></pre><p><strong>References</strong></p><p>Polton, J. A., and Belcher, S. E. (2007), &quot;Langmuir turbulence and deeply penetrating jets     in an unstratified mixed layer.&quot; Journal of Geophysical Research: Oceans.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/TurbulenceClosures/turbulence_closure_implementations/blasius_smagorinsky.jl#L25-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.AnisotropicDiffusivity" href="#Oceananigans.TurbulenceClosures.AnisotropicDiffusivity"><code>Oceananigans.TurbulenceClosures.AnisotropicDiffusivity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AnisotropicDiffusivity{NX, NY, NZ, KX, KY, KZ}</code></pre><p>Parameters for anisotropic diffusivity models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_diffusivity.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.AnisotropicDiffusivity" href="#Oceananigans.TurbulenceClosures.AnisotropicDiffusivity"><code>Oceananigans.TurbulenceClosures.AnisotropicDiffusivity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AnisotropicDiffusivity(; νx=ν₀, νy=ν₀, νz=ν₀, κx=κ₀, κy=κ₀, κz=κ₀,
                         νh=nothing, κh=nothing)</code></pre><p>Returns parameters for a closure with a diagonal diffusivity tensor with heterogeneous &#39;anisotropic&#39; components labeled by <code>x</code>, <code>y</code>, <code>z</code>. Each component may be a number or function. The tracer diffusivities <code>κx</code>, <code>κy</code>, and <code>κz</code> may be <code>NamedTuple</code>s with fields corresponding to each tracer, or a single number or function to be a applied to all tracers.</p><p>If <code>νh</code> or <code>κh</code> are provided, then <code>νx = νy = νh</code>, and <code>κx = κy = κh</code>, respectively.</p><p>By default, a viscosity of <code>ν₀ = 1.05×10⁻⁶</code> m² s⁻¹ is used for all viscosity components and a diffusivity of <code>κ₀ = 1.46×10⁻⁷</code> m² s⁻¹ is used for all diffusivity components for every tracer. These values are the approximate viscosity and thermal diffusivity for seawater at 20°C and 35 psu, according to Sharqawy et al., &quot;Thermophysical properties of seawater: A review of existing correlations and data&quot; (2010).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_diffusivity.jl#L15-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.RozemaAnisotropicMinimumDissipation" href="#Oceananigans.TurbulenceClosures.RozemaAnisotropicMinimumDissipation"><code>Oceananigans.TurbulenceClosures.RozemaAnisotropicMinimumDissipation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RozemaAnisotropicMinimumDissipation(FT=Float64; C=0.33, ν=1.05e-6, κ=1.46e-7)</code></pre><p>Returns a <code>RozemaAnisotropicMinimumDissipation</code> closure object of type <code>FT</code> with</p><pre><code class="language-none">* `C` : Poincaré constant
* `ν` : &#39;molecular&#39; background viscosity
* `κ` : &#39;molecular&#39; background diffusivity for each tracer</code></pre><p>See Rozema et al., &quot; (2015)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/TurbulenceClosures/turbulence_closure_implementations/rozema_anisotropic_minimum_dissipation.jl#L12-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.TwoDimensionalLeith" href="#Oceananigans.TurbulenceClosures.TwoDimensionalLeith"><code>Oceananigans.TurbulenceClosures.TwoDimensionalLeith</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TwoDimensionalLeith{FT} &lt;: AbstractLeith{FT}</code></pre><p>Parameters for the 2D Leith turbulence closure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.TwoDimensionalLeith" href="#Oceananigans.TurbulenceClosures.TwoDimensionalLeith"><code>Oceananigans.TurbulenceClosures.TwoDimensionalLeith</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TwoDimensionalLeith([FT=Float64;] C=0.3, C_Redi=1, C_GM=1)</code></pre><p>Return a <code>TwoDimensionalLeith</code> type associated with the turbulence closure proposed by Leith (1965) and Fox-Kemper &amp; Menemenlis (2008) which has an eddy viscosity of the form</p><pre><code class="language-none">`νₑ = (C * Δᶠ)³ * √(ζ² + (∇h ∂z w)²)`</code></pre><p>and an eddy diffusivity of the form...</p><p>where <code>Δᶠ</code> is the filter width, <code>ζ² = (∂x v - ∂y u)²</code> is the squared vertical vorticity, and <code>C</code> is a model constant.</p><p><strong>Keyword arguments</strong></p><pre><code class="language-none">- `C`      : Model constant
- `C_Redi` : Coefficient for down-gradient tracer diffusivity for each tracer.
             Either a constant applied to every tracer, or a `NamedTuple` with fields
             for each tracer individually.
- `C_GM`   : Coefficient for down-gradient tracer diffusivity for each tracer.
             Either a constant applied to every tracer, or a `NamedTuple` with fields
             for each tracer individually.</code></pre><p><strong>References</strong></p><p>Leith, C. E. (1968). &quot;Diffusion Approximation for Two‐Dimensional Turbulence&quot;, The Physics of     Fluids 11, 671. doi: 10.1063/1.1691968</p><p>Fox‐Kemper, B., &amp; D. Menemenlis (2008), &quot;Can large eddy simulation techniques improve mesoscale rich     ocean models?&quot;, in Ocean Modeling in an Eddying Regime, Geophys. Monogr. Ser., vol. 177, pp. 319–337.     doi:10.1029/177GM19</p><p>Pearson, B. et al. (2017) , &quot;Evaluation of scale-aware subgrid mesoscale eddy models in a global eddy     rich model&quot;, Ocean Modelling 115, 42-58. doi: 10.1016/j.ocemod.2017.05.007</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl#L22-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.∇_κ_∇c-Tuple{Any,Any,Any,Any,Any,Oceananigans.TurbulenceClosures.AbstractLeith,Any,Any,Any,Any,Any}" href="#Oceananigans.TurbulenceClosures.∇_κ_∇c-Tuple{Any,Any,Any,Any,Any,Oceananigans.TurbulenceClosures.AbstractLeith,Any,Any,Any,Any,Any}"><code>Oceananigans.TurbulenceClosures.∇_κ_∇c</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∇_κ_∇c(i, j, k, grid, clock, c, closure, diffusivities)</code></pre><p>Return the diffusive flux divergence <code>∇ ⋅ (κ ∇ c)</code> for the turbulence <code>closure</code>, where <code>c</code> is an array of scalar data located at cell centers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl#L196-L201">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.GiB" href="#Oceananigans.Utils.GiB"><code>Oceananigans.Utils.GiB</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">GiB</code></pre><p>A <code>Float64</code> constant equal to 1024<code>MiB</code>. Useful for increasing the clarity of scripts, e.g. <code>max_filesize = 50GiB</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Utils/units.jl#L61-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.KiB" href="#Oceananigans.Utils.KiB"><code>Oceananigans.Utils.KiB</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">KiB</code></pre><p>A <code>Float64</code> constant equal to 1024.0. Useful for increasing the clarity of scripts, e.g. <code>max_filesize = 250KiB</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Utils/units.jl#L47-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.MiB" href="#Oceananigans.Utils.MiB"><code>Oceananigans.Utils.MiB</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">MiB</code></pre><p>A <code>Float64</code> constant equal to 1024<code>KiB</code>. Useful for increasing the clarity of scripts, e.g. <code>max_filesize = 100MiB</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Utils/units.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.TiB" href="#Oceananigans.Utils.TiB"><code>Oceananigans.Utils.TiB</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">TiB</code></pre><p>A <code>Float64</code> constant equal to 1024<code>GiB</code>. Useful for increasing the clarity of scripts, e.g. <code>max_filesize = 2TiB</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Utils/units.jl#L68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.day" href="#Oceananigans.Utils.day"><code>Oceananigans.Utils.day</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">day</code></pre><p>A <code>Float64</code> constant equal to 24<code>hour</code>. Useful for increasing the clarity of scripts, e.g. <code>Δt = 0.5day</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Utils/units.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.hour" href="#Oceananigans.Utils.hour"><code>Oceananigans.Utils.hour</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">hour</code></pre><p>A <code>Float64</code> constant equal to 60<code>minute</code>. Useful for increasing the clarity of scripts, e.g. <code>Δt = 3hour</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Utils/units.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.kilometer" href="#Oceananigans.Utils.kilometer"><code>Oceananigans.Utils.kilometer</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">kilometer</code></pre><p>A <code>Float64</code> constant equal to 1000<code>meter</code>. Useful for increasing the clarity of scripts, e.g. <code>Lx = 250kilometer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Utils/units.jl#L40-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.meter" href="#Oceananigans.Utils.meter"><code>Oceananigans.Utils.meter</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">meter</code></pre><p>A <code>Float64</code> constant equal to 1.0. Useful for increasing the clarity of scripts, e.g. <code>Lx = 100meter</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Utils/units.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.minute" href="#Oceananigans.Utils.minute"><code>Oceananigans.Utils.minute</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">minute</code></pre><p>A <code>Float64</code> constant equal to 60<code>second</code>. Useful for increasing the clarity of scripts, e.g. <code>Δt = 15minute</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Utils/units.jl#L12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.second" href="#Oceananigans.Utils.second"><code>Oceananigans.Utils.second</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">second</code></pre><p>A <code>Float64</code> constant equal to 1.0. Useful for increasing the clarity of scripts, e.g. <code>Δt = 1second</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Utils/units.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.prettytime-Tuple{Any}" href="#Oceananigans.Utils.prettytime-Tuple{Any}"><code>Oceananigans.Utils.prettytime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">prettytime(t)</code></pre><p>Convert a floating point value <code>t</code> representing an amount of time in seconds to a more human-friendly formatted string with three decimal places. Depending on the value of <code>t</code> the string will be formatted to show <code>t</code> in nanoseconds (ns), microseconds (μs), milliseconds (ms), seconds (s), minutes (min), hours (hr), or days (day).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Utils/pretty_time.jl#L4-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.pretty_filesize" href="#Oceananigans.Utils.pretty_filesize"><code>Oceananigans.Utils.pretty_filesize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pretty_filesize(s, suffix=&quot;B&quot;)</code></pre><p>Convert a floating point value <code>s</code> representing a file size to a more human-friendly formatted string with one decimal places with a <code>suffix</code> defaulting to &quot;B&quot;. Depending on the value of <code>s</code> the string will be formatted to show <code>s</code> using an SI prefix from bytes, kiB (1024 bytes), MiB (1024² bytes), and so on up to YiB (1024⁸ bytes).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Utils/pretty_filesize.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.cell_advection_timescale-NTuple{4,Any}" href="#Oceananigans.Utils.cell_advection_timescale-NTuple{4,Any}"><code>Oceananigans.Utils.cell_advection_timescale</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns the time-scale for advection on a regular grid across a single grid cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Utils/cell_advection_timescale.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.validate_intervals-Tuple{Any,Any}" href="#Oceananigans.Utils.validate_intervals-Tuple{Any,Any}"><code>Oceananigans.Utils.validate_intervals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">validate_intervals(iteration_interval, time_interval)</code></pre><p>Warn the user if iteration and time intervals are both <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Utils/output_writer_diagnostic_utils.jl#L31-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.with_tracers-Tuple{Any,NamedTuple,Any}" href="#Oceananigans.Utils.with_tracers-Tuple{Any,NamedTuple,Any}"><code>Oceananigans.Utils.with_tracers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">with_tracers(tracer_names, initial_tuple, tracer_default)</code></pre><p>Create a tuple corresponding to the solution variables <code>u</code>, <code>v</code>, <code>w</code>, and <code>tracer_names</code>. <code>initial_tuple</code> is a <code>NamedTuple</code> that at least has fields <code>u</code>, <code>v</code>, and <code>w</code>, and may have some fields corresponding to the names in <code>tracer_names</code>. <code>tracer_default</code> is a function that produces a default tuple value for each tracer if not included in <code>initial_tuple</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/Utils/with_tracers.jl#L1-L9">source</a></section></article><h2 id="Abstract-operations"><a class="docs-heading-anchor" href="#Abstract-operations">Abstract operations</a><a id="Abstract-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-operations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.@unary-Tuple" href="#Oceananigans.AbstractOperations.@unary-Tuple"><code>Oceananigans.AbstractOperations.@unary</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@unary op1 op2 op3...</code></pre><p>Turn each unary function in the list <code>(op1, op2, op3...)</code> into a unary operator on <code>Oceananigans.Fields</code> for use in <code>AbstractOperations</code>.</p><p>Note: a unary function is a function with one argument: for example, <code>sin(x)</code> is a unary function.</p><p>Also note: a unary function in <code>Base</code> must be imported to be extended: use <code>import Base: op; @unary op</code>.</p><p><strong>Example</strong></p><p>julia&gt; square<em>it(x) = x^2 square</em>it (generic function with 1 method)</p><p>julia&gt; @unary square<em>it 7-element Array{Any,1}:  :sqrt  :sin  :cos  :exp  :tanh  :-  :square</em>it</p><p>julia&gt; c = Field(Cell, Cell, Cell, CPU(), RegularCartesianGrid((1, 1, 16), (1, 1, 1)));</p><p>julia&gt; square_it(c) UnaryOperation at (Cell, Cell, Cell) ├── grid: RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}} │   ├── size: (1, 1, 16) │   └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [0.0, -1.0] └── tree:</p><p>square_it at (Cell, Cell, Cell) via identity └── OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/AbstractOperations/unary_operations.jl#L39-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.@binary-Tuple" href="#Oceananigans.AbstractOperations.@binary-Tuple"><code>Oceananigans.AbstractOperations.@binary</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@binary op1 op2 op3...</code></pre><p>Turn each binary function in the list <code>(op1, op2, op3...)</code> into a binary operator on <code>Oceananigans.Fields</code> for use in <code>AbstractOperations</code>.</p><p>Note: a binary function is a function with two arguments: for example, <code>+(x, y)</code> is a binary function.</p><p>Also note: a binary function in <code>Base</code> must be imported to be extended: use <code>import Base: op; @binary op</code>.</p><p><strong>Example</strong></p><p>```jldoctest julia&gt; plus<em>or</em>times(x, y) = x &lt; 0 ? x + y : x * y plus<em>or</em>times (generic function with 1 method)</p><p>julia&gt; @binary plus<em>or</em>times 6-element Array{Any,1}:  :+  :-  :/  :^  :*  :plus<em>or</em>times</p><p>julia&gt; c, d = (Field(Cell, Cell, Cell, CPU(), RegularCartesianGrid((1, 1, 16), (1, 1, 1))) for i = 1:2);</p><p>julia&gt; plus<em>or</em>times(c, d) BinaryOperation at (Cell, Cell, Cell) ├── grid: RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}} │   ├── size: (1, 1, 16) │   └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [0.0, -1.0] └── tree:</p><p>plus<em>or</em>times at (Cell, Cell, Cell) via Oceananigans.AbstractOperations.identity ├── OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}} └── OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/AbstractOperations/binary_operations.jl#L90-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.@multiary-Tuple" href="#Oceananigans.AbstractOperations.@multiary-Tuple"><code>Oceananigans.AbstractOperations.@multiary</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@multiary op1 op2 op3...</code></pre><p>Turn each multiary operator in the list <code>(op1, op2, op3...)</code> into a multiary operator on <code>Oceananigans.Fields</code> for use in <code>AbstractOperations</code>.</p><p>Note that a multiary operator:     * is a function with two or more arguments: for example, <code>+(x, y, z)</code> is a multiary function;     * must be imported to be extended if part of <code>Base</code>: use <code>import Base: op; @multiary op</code>;     * can only be called on <code>Oceananigans.Field</code>s if the &quot;location&quot; is noted explicitly; see example.</p><p><strong>Example</strong></p><p>```jldoctest julia&gt; harmonic<em>plus(a, b, c) = 1/3 * (1/a + 1/b + 1/c) harmonic</em>plus(generic function with 1 method)</p><p>julia&gt; @multiary harmonic<em>plus 3-element Array{Any,1}:  :+  :*  :harmonic</em>plus</p><p>julia&gt; c, d, e = Tuple(Field(Cell, Cell, Cell, CPU(), RegularCartesianGrid((1, 1, 16), (1, 1, 1))) for i = 1:3);</p><p>julia&gt; harmonic_plus(c, d, e) # this calls the original function, which in turn returns a (correct) operation tree BinaryOperation at (Cell, Cell, Cell) ├── grid: RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}} │   ├── size: (1, 1, 16) │   └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [0.0, -1.0] └── tree:</p><ul><li>at (Cell, Cell, Cell) via Oceananigans.AbstractOperations.identity</li></ul><p>├── 0.3333333333333333 └── + at (Cell, Cell, Cell) via Oceananigans.AbstractOperations.identity     ├── + at (Cell, Cell, Cell) via Oceananigans.AbstractOperations.identity     │   ├── / at (Cell, Cell, Cell) via Oceananigans.AbstractOperations.identity     │   │   ├── 1     │   │   └── OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}     │   └── / at (Cell, Cell, Cell) via Oceananigans.AbstractOperations.identity         │   ├── 1         │   └── OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}     └── / at (Cell, Cell, Cell) via Oceananigans.AbstractOperations.identity         ├── 1         └── OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}</p><p>julia&gt; @at (Cell, Cell, Cell) harmonic_plus(c, d, e) # this returns a <code>MultiaryOperation</code> as expected MultiaryOperation at (Cell, Cell, Cell) ├── grid: RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}} │   ├── size: (1, 1, 16) │   └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [0.0, -1.0] └── tree:</p><p>harmonic_plus at (Cell, Cell, Cell) ├── OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}} ├── OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}} └── OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/AbstractOperations/multiary_operations.jl#L52-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.∂x-Tuple{Union{Type{Cell}, Type{Face}}}" href="#Oceananigans.AbstractOperations.∂x-Tuple{Union{Type{Cell}, Type{Face}}}"><code>Oceananigans.AbstractOperations.∂x</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the x-derivative function acting at (<code>X</code>, <code>Any</code>, <code>Any</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/AbstractOperations/derivatives.jl#L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.∂x-Union{Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}, Tuple{Z}, Tuple{Y}, Tuple{X}} where Z where Y where X" href="#Oceananigans.AbstractOperations.∂x-Union{Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}, Tuple{Z}, Tuple{Y}, Tuple{X}} where Z where Y where X"><code>Oceananigans.AbstractOperations.∂x</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∂x(a::AbstractField)</code></pre><p>Return an abstract representation of a x-derivative acting on <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/AbstractOperations/derivatives.jl#L80-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.∂x-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{Tuple,Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}} where Z where Y where X" href="#Oceananigans.AbstractOperations.∂x-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{Tuple,Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}} where Z where Y where X"><code>Oceananigans.AbstractOperations.∂x</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∂x(L::Tuple, a::AbstractField)</code></pre><p>Return an abstract representation of an x-derivative acting on <code>a</code> followed by interpolation to <code>L</code>, where <code>L</code> is a 3-tuple of <code>Face</code>s and <code>Cell</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/AbstractOperations/derivatives.jl#L52-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.∂y-Tuple{Union{Type{Cell}, Type{Face}}}" href="#Oceananigans.AbstractOperations.∂y-Tuple{Union{Type{Cell}, Type{Face}}}"><code>Oceananigans.AbstractOperations.∂y</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the y-derivative function acting at (<code>Any</code>, <code>Y</code>, <code>Any</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/AbstractOperations/derivatives.jl#L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.∂y-Union{Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}, Tuple{Z}, Tuple{Y}, Tuple{X}} where Z where Y where X" href="#Oceananigans.AbstractOperations.∂y-Union{Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}, Tuple{Z}, Tuple{Y}, Tuple{X}} where Z where Y where X"><code>Oceananigans.AbstractOperations.∂y</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∂y(a::AbstractField)</code></pre><p>Return an abstract representation of a y-derivative acting on <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/AbstractOperations/derivatives.jl#L87-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.∂y-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{Tuple,Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}} where Z where Y where X" href="#Oceananigans.AbstractOperations.∂y-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{Tuple,Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}} where Z where Y where X"><code>Oceananigans.AbstractOperations.∂y</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∂y(L::Tuple, a::AbstractField)</code></pre><p>Return an abstract representation of a y-derivative acting on <code>a</code> followed by interpolation to <code>L</code>, where <code>L</code> is a 3-tuple of <code>Face</code>s and <code>Cell</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/AbstractOperations/derivatives.jl#L61-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.∂z-Tuple{Union{Type{Cell}, Type{Face}}}" href="#Oceananigans.AbstractOperations.∂z-Tuple{Union{Type{Cell}, Type{Face}}}"><code>Oceananigans.AbstractOperations.∂z</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the z-derivative function acting at (<code>Any</code>, <code>Any</code>, <code>Z</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/AbstractOperations/derivatives.jl#L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.∂z-Union{Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}, Tuple{Z}, Tuple{Y}, Tuple{X}} where Z where Y where X" href="#Oceananigans.AbstractOperations.∂z-Union{Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}, Tuple{Z}, Tuple{Y}, Tuple{X}} where Z where Y where X"><code>Oceananigans.AbstractOperations.∂z</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∂z(a::AbstractField)</code></pre><p>Return an abstract representation of a z-derivative acting on <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/AbstractOperations/derivatives.jl#L93-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.∂z-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{Tuple,Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}} where Z where Y where X" href="#Oceananigans.AbstractOperations.∂z-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{Tuple,Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}} where Z where Y where X"><code>Oceananigans.AbstractOperations.∂z</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∂z(L::Tuple, a::AbstractField)</code></pre><p>Return an abstract representation of a z-derivative acting on <code>a</code> followed by interpolation to <code>L</code>, where <code>L</code> is a 3-tuple of <code>Face</code>s and <code>Cell</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/AbstractOperations/derivatives.jl#L70-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.Computation" href="#Oceananigans.AbstractOperations.Computation"><code>Oceananigans.AbstractOperations.Computation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Computation{T, R, O, G}</code></pre><p>Represents an operation performed over the elements of a field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/AbstractOperations/computations.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.Computation-Tuple" href="#Oceananigans.AbstractOperations.Computation-Tuple"><code>Oceananigans.AbstractOperations.Computation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(computation::Computation)(args...)</code></pre><p>Performs the <code>compute(computation)</code> and returns the result if <code>isnothing(return_type)</code>, or the result after being converted to <code>return_type</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/AbstractOperations/computations.jl#L63-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.Computation-Tuple{Any,Any}" href="#Oceananigans.AbstractOperations.Computation-Tuple{Any,Any}"><code>Oceananigans.AbstractOperations.Computation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Computation(operation, result; return_type=Array)</code></pre><p>Returns a <code>Computation</code> representing an <code>operation</code> performed over the elements of <code>operation.grid</code> and stored in <code>result</code>. <code>return_type</code> specifies the output type when the <code>Computation</code> instances is called as a function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/AbstractOperations/computations.jl#L20-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.compute!-Tuple{Computation}" href="#Oceananigans.Fields.compute!-Tuple{Computation}"><code>Oceananigans.Fields.compute!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute!(computation::Computation)</code></pre><p>Perform a <code>computation</code>. The result is stored in <code>computation.result</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/AbstractOperations/computations.jl#L36-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.@at-Tuple{Any,Any}" href="#Oceananigans.AbstractOperations.@at-Tuple{Any,Any}"><code>Oceananigans.AbstractOperations.@at</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@at location abstract_operation</code></pre><p>Modify the <code>abstract_operation</code> so that it returns values at <code>location</code>, where <code>location</code> is a 3-tuple of <code>Face</code>s and <code>Cell</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/d6ce0feeebe46aa56491d80653063a1142d8c963/src/AbstractOperations/interpolation_utils.jl#L75-L80">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../references/">« References</a><a class="docs-footer-nextpage" href="../function_index/">Function index »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 17 September 2020 15:35">Thursday 17 September 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

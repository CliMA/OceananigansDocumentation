var documenterSearchIndex = {"docs":
[{"location":"appendix/convergence_tests/#Convergence-Tests","page":"Convergence tests","title":"Convergence Tests","text":"","category":"section"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"Convergence tests are implemented in /validation/convergence_tests and range from zero-dimensional time-stepper tests to two-dimensional integration tests that involve non-trivial pressure fields, advection, and diffusion.","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"For all tests except point exponential decay, we use the L_1 norm,","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    L_1 equiv fracmathrmmean  phi_mathrmsim - phi_mathrmexact mathrmmean  phi_mathrmexact ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"and L_infty norm,","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    L_infty equiv fracmax  phi_mathrmsim - phi_mathrmexact max  phi_mathrmexact   ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"to compare simulated fields, phi_mathrmsim, with exact, analytically-derived solutions phi_mathrmexact. The field phi may be a tracer field or a velocity field.","category":"page"},{"location":"appendix/convergence_tests/#Point-Exponential-Decay","page":"Convergence tests","title":"Point Exponential Decay","text":"","category":"section"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"This test analyzes time-stepper convergence by simulating the zero-dimensional, or spatially-uniform equation","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    partial_t c = - c  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"with the initial condition c = 1, which has the analytical solution c = mathrme^-t.","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"We find the expected first-order convergence with decreasing time-step Delta t using our first-order accurate, \"modified second-order\" Adams-Bashforth time-stepping method:","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"(Image: Point exponential decay)","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"This result validates the correctness of the Oceananigans implementation of Adams-Bashforth time-stepping.","category":"page"},{"location":"appendix/convergence_tests/#One-dimensional-advection-and-diffusion-of-a-Gaussian","page":"Convergence tests","title":"One-dimensional advection and diffusion of a Gaussian","text":"","category":"section"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"This and the following tests focus on convergence with grid spacing, Delta x.","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"In one dimension with constant diffusivity kappa and in the presence of a constant velocity U, a Gaussian evolves according to","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    c = fracmathrme^- (x - U t)^2  4 kappa tsqrt4 pi kappa t  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"For this test we take the initial time as t=t_0. We simulate this problem with advection and diffusion, as well as with U=0 and thus diffusion only, as well as with kappa approx 0 and thus \"advection only\". The solutions are","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"(Image: Gaussian advection diffusion solutions)","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"which exhibit the expected second-order convergence with Delta x^2 propto 1  N_x^2:","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"(Image: Gaussian advection diffusion convergence)","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"These results validate the correctness of time-stepping, constant diffusivity operators, and advection operators.","category":"page"},{"location":"appendix/convergence_tests/#One-dimensional-advection-and-diffusion-of-a-cosine","page":"Convergence tests","title":"One-dimensional advection and diffusion of a cosine","text":"","category":"section"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"In one dimension with constant diffusivity kappa and in the presence of a constant velocity U, a cosine evolves according to","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    c = mathrme^-kappa t cos (x - U t)  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"The solutions are","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"(Image: Cosine advection diffusion solutions)","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"which exhibit the expected second-order convergence with Delta x^2 propto 1  N_x^2:","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"(Image: Cosine advection diffusion convergence)","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"These results validate the correctness of time-stepping, constant diffusivity operators, and advection operators.","category":"page"},{"location":"appendix/convergence_tests/#Two-dimensional-diffusion","page":"Convergence tests","title":"Two-dimensional diffusion","text":"","category":"section"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"With zero velocity field and constant diffusivity kappa, the tracer field","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    c(x y t=0) = cos(x) cos(y)  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"decays according to","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    c(x y t) = mathrme^-2 kappa t cos(x) cos(y)  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"with either periodic boundary conditions, or insulating boundary conditions in either x or y.","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"The expected convergence with Delta x^2 propto 1  N_x^2 is observed:","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"(Image: Two dimensional diffusion convergence)","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"This validates the correctness of multi-dimensional diffusion operators.","category":"page"},{"location":"appendix/convergence_tests/#Decaying,-advected-Taylor-Green-vortex","page":"Convergence tests","title":"Decaying, advected Taylor-Green vortex","text":"","category":"section"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"The velocity field","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"beginalign\n    u(x y t)  = U + mathrme^-t cos(x - U t) sin(y)   \n    v(x y t)  =   - mathrme^-t sin(x - U t) cos(y)  \nendalign","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"is a solution to the Navier-Stokes equations with viscosity nu = 1.","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"The expected convergence with spatial resolution is observed:","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"(Image: Decaying advected Taylor Green)","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"This validates the correctness of the advection and diffusion of a velocity field.","category":"page"},{"location":"appendix/convergence_tests/#Forced-two-dimensional-flows","page":"Convergence tests","title":"Forced two-dimensional flows","text":"","category":"section"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"We introduce two convergence tests associated with forced flows in domains that are  bounded in y, and periodic in x with no tracers.","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"Note: in this section, subscripts are used to denote derivatives to make reading  and typing equations easier.","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"In a two-dimensional flow in (x y), the velocity field (u v) can be expressed in terms of a streamfunction psi(x y t) such that","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    u equiv - psi_y   quad textand quad v equiv psi_x  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"where subscript denote derivatives such that psi_y equiv partial_y psi, for example. With an isotropic Laplacian viscosity nu = 1, the momentum and continuity equations are","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    beginalign\n    boldsymbolv_t + left ( boldsymbolv boldsymbolcdot boldsymbolnabla right ) boldsymbolv + boldsymbolnabla p  = nabla^2 boldsymbolv + boldsymbolF_v   \n    boldsymbolnabla boldsymbolcdot boldsymbolv  = 0  \n    endalign","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"while the equation for vorticity, omega = v_x - u_y = nabla^2 psi, is","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    omega_t + mathrmJ left ( psi omega right ) = nabla^2 omega + F_omega  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"Finally, taking the divergence of the momentum equation, we find a Poisson equation for pressure,","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    nabla^2 p = - u_x^2 - v_y^2 - 2 u_y v_x + partial_x F_v + partial_y F_v  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"To pose the problem, we first pick a streamfunction psi. This choice then yields the vorticity  forcing F_omega that satisfies the vorticity equation. We then determine F_u by solving  partial_y F_v = - F_omega, and pick F_v so that we can solve the Poisson equation  for pressure.","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"We restrict ourselves to a class of problems in which","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"psi(x y t) = - f(x t) g(y)   quad textwith quad f equiv cos x - xi(t)   quad\nxi(t) equiv 1 + sin(t^2)  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"Grinding through the algebra, this particular form implies that F_omega is given by","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    F_omega = -xi^prime f_x (g - g^primeprime) + f f_x (g g^primeprimeprime - g^prime g^primeprime) + f (g - 2 g^primeprime + g^primeprimeprimeprime)  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"where primes denote derivatives of functions of a single argument.  Setting partial_y F_v = F_omega, we find that if F_v satisfies","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    partial_y F_v = (g^prime)^2 + g g^primeprime  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"then the pressure Poisson equation becomes","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    nabla^2 p = cos 2 (x - xi) (g^prime)^2 - g g^primeprime + partial_x F_v  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"This completes the specification of the problem.","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"We set up the problem by imposing the time-dependent forcing functions F_u and F_v on u and v, initializing the flow at t=0, and integrating the problem forwards in time using Oceananigans. We find the expected convergence of the numerical solution to the analytical solution: the error between the numerical and analytical solutions decreases with 1N_x^2 sim Delta x^2, where N_x is the number of grid points and Delta x is the spatial resolution:","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"(Image: Forced free slip convergence)","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"The convergence tests are performed using both y and z as the bounded direction.","category":"page"},{"location":"appendix/convergence_tests/#Forced,-free-slip-flow","page":"Convergence tests","title":"Forced, free-slip flow","text":"","category":"section"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"A forced flow satisfying free-slip conditions at y = 0 and y = pi has the streamfunction","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    psi(x y t) = - cos x - xi(t) sin (y)  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"and thus g(y) = sin y. The velocity field (u v) is","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    u = cos (x - xi) cos y   quad textand quad v = sin (x - xi) sin y  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"which satisfies the boundary conditions u_y _y=0 = u_y _y=pi = 0 and v _y=0 = v _y=pi = 0. The vorticity forcing is","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    F_omega = - 2 xi^prime f_x sin y + 4 f sin y  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"which implies that","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    F_v = - 2 xi^prime f_x cos y + 4 f cos y  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"and F_v = tfrac12 sin 2 y.","category":"page"},{"location":"appendix/convergence_tests/#Forced,-fixed-slip-flow","page":"Convergence tests","title":"Forced, fixed-slip flow","text":"","category":"section"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"A forced flow satisfying \"fixed-slip\" boundary conditions at y=0 and y=1 has the streamfunction","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    psi(x y t) = - cos x - xi(t) (y^3 - y^2)  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"and thus g(y) = y^3 - y^2. The velocity field (u v) is","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    u = f (3y^2 - 2 y)   quad textand quad v = - f_x (y^3 - y^2)  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"which satisfies the boundary conditions","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    u _y=0 = 0   quad u _y=1 = f   quad textand quad v _y=0 = v _y=1 = 0  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"The vorticity forcing is","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    F_omega = - xi^prime f_x (y^3 - y^2 - 6y + 2) - f f_x (12 y^3 - 12 y^2 + 4 y) + f (y^3 - y^2 - 12 y + 4)  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"which implies that","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    F_v = xi^prime f_x (tfrac14 y^4 - tfrac13 y^3 - 3 y^2 + 2y)\n        + f f_x (3 y^4 - 4 y^3 + 2y^2 ) \n        - f (tfrac14 y^4 - tfrac13 y^3 - 6 y^2 + 4 y)  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"and","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    F_v = 3 y^5 - 5 y^4 + 2y^3  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"We set up the problem in the same manner as the forced, free-slip problem above. Note that we  also must the no-slip boundary condition u _y=0 = 0 and the time-dependent fixed-slip  condition u _y=1 = f. As for the free-slip problem, we find that the error between the  numerical and analytical solutions decreases with 1  N_x^2 sim Delta x^2, where N_x is the number of grid points and Delta x is the spatial resolution:","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"(Image: Forced fixed slip convergence)","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"The convergence tests are performed using both y and z as the bounded direction.","category":"page"},{"location":"appendix/library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Documenting the public user interface.","category":"page"},{"location":"appendix/library/#Oceananigans.jl","page":"Library","title":"Oceananigans.jl","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.Oceananigans","page":"Library","title":"Oceananigans.Oceananigans","text":"Main module for Oceananigans.jl â€“ a Julia software for fast, friendly, flexible, data-driven, ocean-flavored fluid dynamics on CPUs and GPUs.\n\n\n\n\n\n","category":"module"},{"location":"appendix/library/#Abstract-operations","page":"Library","title":"Abstract operations","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.AbstractOperations]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.AbstractOperations.volume","page":"Library","title":"Oceananigans.AbstractOperations.volume","text":"volume = VolumeMetric()\n\nInstance of VolumeMetric that generates BinaryOperations between AbstractFields and their cell volumes. Summing this BinaryOperation yields an integral of AbstractField over the domain.\n\nExample\n\njulia> using Oceananigans\n\njulia> using Oceananigans.AbstractOperations: volume\n\njulia> c = CenterField(RectilinearGrid(size=(2, 2, 2), extent=(1, 2, 3)));\n\njulia> c .= 1;\n\njulia> c_dV = c * volume\nBinaryOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 2Ã—2Ã—2 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ””â”€â”€ tree:\n    * at (Center, Center, Center)\n Â Â  â”œâ”€â”€ 2Ã—2Ã—2 Field{Center, Center, Center} on RectilinearGrid on CPU\n Â Â  â””â”€â”€ Vá¶œá¶œá¶œ at (Center, Center, Center)\n\njulia> c_dV[1, 1, 1]\n0.75\n\njulia> sum(c_dV)\n6.0\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.AbstractOperations.Î”z","page":"Library","title":"Oceananigans.AbstractOperations.Î”z","text":"Î”z = ZSpacingMetric()\n\nInstance of ZSpacingMetric that generates BinaryOperations between AbstractFields and the vertical grid spacing evaluated at the same location as the AbstractField. \n\nÎ”x and Î”y play a similar role for horizontal grid spacings.\n\nExample\n\njulia> using Oceananigans\n\njulia> using Oceananigans.AbstractOperations: Î”z\n\njulia> c = CenterField(RectilinearGrid(size=(1, 1, 1), extent=(1, 2, 3)));\n\njulia> c_dz = c * Î”z # returns BinaryOperation between Field and GridMetricOperation\nBinaryOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 1Ã—1Ã—1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ””â”€â”€ tree:\n    * at (Center, Center, Center)\n Â Â  â”œâ”€â”€ 1Ã—1Ã—1 Field{Center, Center, Center} on RectilinearGrid on CPU\n Â Â  â””â”€â”€ Î”zá¶œá¶œá¶œ at (Center, Center, Center)\n\njulia> c .= 1;\n\njulia> c_dz[1, 1, 1]\n3.0\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.AbstractOperations.Average-Tuple{Oceananigans.Fields.AbstractField}","page":"Library","title":"Oceananigans.AbstractOperations.Average","text":"Average(field::AbstractField; condition = nothing, mask = 0, dims=:)\n\nReturn Reduction representing a spatial average of field over dims.\n\nOver regularly-spaced dimensions this is equivalent to a numerical mean!.\n\nOver dimensions of variable spacing, field is multiplied by the appropriate grid length, area or volume, and divided by the total spatial extent of the interval.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.BinaryOperation-Union{Tuple{G}, Tuple{IB}, Tuple{IA}, Tuple{B}, Tuple{A}, Tuple{O}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{O, A, B, IA, IB, G}} where {LX, LY, LZ, O, A, B, IA, IB, G}","page":"Library","title":"Oceananigans.AbstractOperations.BinaryOperation","text":"BinaryOperation{LX, LY, LZ}(op, a, b, â–¶a, â–¶b, grid)\n\nReturn an abstract representation of the binary operation op(â–¶a(a), â–¶b(b)) on grid, where â–¶a and â–¶b interpolate a and b to locations (LX, LY, LZ).\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.ConditionalOperation-Tuple{Oceananigans.Fields.AbstractField}","page":"Library","title":"Oceananigans.AbstractOperations.ConditionalOperation","text":"ConditionalOperation(operand::AbstractField;\n                     func = identity,\n                     condition = nothing,\n                     mask = 0)\n\nReturn an abstract representation of a masking procedure applied when condition is satisfied on a field described by func(operand).\n\nPositional arguments\n\noperand: The AbstractField to be masked (it must have a grid property!)\n\nKeyword arguments\n\nfunc: A unary transformation applied element-wise to the field operand at locations where         condition == true. Default is identity.\ncondition: either a function of (i, j, k, grid, operand) returning a Boolean,              or a 3-dimensional Boolean AbstractArray. At locations where condition == false,              operand will be masked by mask\nmask: the scalar mask\n\ncondition_operand is a convenience function used to construct a ConditionalOperation\n\ncondition_operand(func::Function, operand::AbstractField, condition, mask) = ConditionalOperation(operand; func, condition, mask)\n\nExample\n\njulia> using Oceananigans\n\njulia> using Oceananigans.Fields: condition_operand\n\njulia> c = CenterField(RectilinearGrid(size=(2, 1, 1), extent=(1, 1, 1)));\n\njulia> f(i, j, k, grid, c) = i < 2; d = condition_operand(cos, c, f, 10)\nConditionalOperation at (Center, Center, Center)\nâ”œâ”€â”€ operand: 2Ã—1Ã—1 Field{Center, Center, Center} on RectilinearGrid on CPU\nâ”œâ”€â”€ grid: 2Ã—1Ã—1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ func: cos (generic function with 30 methods)\nâ”œâ”€â”€ condition: f (generic function with 1 method)\nâ””â”€â”€ mask: 10\n\njulia> d[1, 1, 1]\n1.0\n\njulia> d[2, 1, 1]\n10\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.Derivative-Union{Tuple{G}, Tuple{AD}, Tuple{IN}, Tuple{A}, Tuple{D}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{D, A, IN, AD, G}} where {LX, LY, LZ, D, A, IN, AD, G}","page":"Library","title":"Oceananigans.AbstractOperations.Derivative","text":"Derivative{LX, LY, LZ}(âˆ‚, arg, â–¶, grid)\n\nReturn an abstract representation of the derivative âˆ‚ on arg, and subsequent interpolation by â–¶ on grid.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.Integral-Tuple{Oceananigans.Fields.AbstractField}","page":"Library","title":"Oceananigans.AbstractOperations.Integral","text":"Integral(field; dims=:)\n\nReturn a Reduction representing a spatial integral of field over dims.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.KernelFunctionOperation-Union{Tuple{G}, Tuple{K}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{K, G, Vararg{Any}}} where {LX, LY, LZ, K, G}","page":"Library","title":"Oceananigans.AbstractOperations.KernelFunctionOperation","text":"KernelFunctionOperation{LX, LY, LZ}(kernel_function, grid, arguments...)\n\nConstruct a KernelFunctionOperation at location (LX, LY, LZ) on grid with arguments.\n\nkernel_function is called with\n\nkernel_function(i, j, k, grid, arguments...)\n\nNote that compute!(kfo::KernelFunctionOperation) calls compute! on all kfo.arguments.\n\nExamples\n\nConstruct a KernelFunctionOperation that returns random numbers:\n\nusing Oceananigans\n\ngrid = RectilinearGrid(size=(1, 8, 8), extent=(1, 1, 1));\n\nrandom_kernel_function(i, j, k, grid) = rand(); # use CUDA.rand on the GPU\n\nkernel_op = KernelFunctionOperation{Center, Center, Center}(random_kernel_function, grid)\n\n# output\n\nKernelFunctionOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 1Ã—8Ã—8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ kernel_function: random_kernel_function (generic function with 1 method)\nâ””â”€â”€ arguments: ()\n\nConstruct a KernelFunctionOperation using the vertical vorticity operator used internally to compute vertical vorticity on all grids:\n\nusing Oceananigans.Operators: Î¶â‚ƒá¶ á¶ á¶œ # called with signature Î¶â‚ƒá¶ á¶ á¶œ(i, j, k, grid, u, v)\n\nmodel = HydrostaticFreeSurfaceModel(; grid);\n\nu, v, w = model.velocities;\n\nÎ¶_op = KernelFunctionOperation{Face, Face, Center}(Î¶â‚ƒá¶ á¶ á¶œ, grid, u, v)\n\n# output\n\nKernelFunctionOperation at (Face, Face, Center)\nâ”œâ”€â”€ grid: 1Ã—8Ã—8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ kernel_function: Î¶â‚ƒá¶ á¶ á¶œ (generic function with 1 method)\nâ””â”€â”€ arguments: (\"1Ã—8Ã—8 Field{Face, Center, Center} on RectilinearGrid on CPU\", \"1Ã—8Ã—8 Field{Center, Face, Center} on RectilinearGrid on CPU\")\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.UnaryOperation-Union{Tuple{G}, Tuple{IN}, Tuple{A}, Tuple{O}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{O, A, IN, G}} where {LX, LY, LZ, O, A, IN, G}","page":"Library","title":"Oceananigans.AbstractOperations.UnaryOperation","text":"UnaryOperation{LX, LY, LZ}(op, arg, â–¶, grid)\n\nReturns an abstract UnaryOperation representing the action of op on arg, and subsequent interpolation by â–¶ on grid.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.âˆ‚x-Tuple{Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}}","page":"Library","title":"Oceananigans.AbstractOperations.âˆ‚x","text":"Return the x-derivative function acting at (X, Y, Any).\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.âˆ‚x-Union{Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Tuple, Oceananigans.Fields.AbstractField{LX, LY, LZ}}} where {LX, LY, LZ}","page":"Library","title":"Oceananigans.AbstractOperations.âˆ‚x","text":"âˆ‚x(L::Tuple, arg::AbstractField)\n\nReturn an abstract representation of an x-derivative acting on field arg followed by interpolation to L, where L is a 3-tuple of Faces and Centers.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.âˆ‚x-Union{Tuple{Oceananigans.Fields.AbstractField{LX, LY, LZ}}, Tuple{LZ}, Tuple{LY}, Tuple{LX}} where {LX, LY, LZ}","page":"Library","title":"Oceananigans.AbstractOperations.âˆ‚x","text":"âˆ‚x(arg::AbstractField)\n\nReturn an abstract representation of a x-derivative acting on field arg.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.âˆ‚y-Tuple{Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}}","page":"Library","title":"Oceananigans.AbstractOperations.âˆ‚y","text":"Return the y-derivative function acting at (X, Y, Any).\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.âˆ‚y-Union{Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Tuple, Oceananigans.Fields.AbstractField{LX, LY, LZ}}} where {LX, LY, LZ}","page":"Library","title":"Oceananigans.AbstractOperations.âˆ‚y","text":"âˆ‚y(L::Tuple, arg::AbstractField)\n\nReturn an abstract representation of a y-derivative acting on field arg followed by interpolation to L, where L is a 3-tuple of Faces and Centers.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.âˆ‚y-Union{Tuple{Oceananigans.Fields.AbstractField{LX, LY, LZ}}, Tuple{LZ}, Tuple{LY}, Tuple{LX}} where {LX, LY, LZ}","page":"Library","title":"Oceananigans.AbstractOperations.âˆ‚y","text":"âˆ‚y(arg::AbstractField)\n\nReturn an abstract representation of a y-derivative acting on field arg.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.âˆ‚z-Tuple{Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}}","page":"Library","title":"Oceananigans.AbstractOperations.âˆ‚z","text":"Return the z-derivative function acting at (Any, Any, Z).\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.âˆ‚z-Union{Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Tuple, Oceananigans.Fields.AbstractField{LX, LY, LZ}}} where {LX, LY, LZ}","page":"Library","title":"Oceananigans.AbstractOperations.âˆ‚z","text":"âˆ‚z(L::Tuple, arg::AbstractField)\n\nReturn an abstract representation of a z-derivative acting on field arg followed by  interpolation to L, where L is a 3-tuple of Faces and Centers.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.âˆ‚z-Union{Tuple{Oceananigans.Fields.AbstractField{LX, LY, LZ}}, Tuple{LZ}, Tuple{LY}, Tuple{LX}} where {LX, LY, LZ}","page":"Library","title":"Oceananigans.AbstractOperations.âˆ‚z","text":"âˆ‚z(arg::AbstractField)\n\nReturn an abstract representation of a z-derivative acting on field arg.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.@at-Tuple{Any, Any}","page":"Library","title":"Oceananigans.AbstractOperations.@at","text":"@at location abstract_operation\n\nModify the abstract_operation so that it returns values at location, where location is a 3-tuple of Faces and Centers.\n\n\n\n\n\n","category":"macro"},{"location":"appendix/library/#Oceananigans.AbstractOperations.@binary-Tuple","page":"Library","title":"Oceananigans.AbstractOperations.@binary","text":"@binary op1 op2 op3...\n\nTurn each binary function in the list (op1, op2, op3...) into a binary operator on Oceananigans.Fields for use in AbstractOperations.\n\nNote: a binary function is a function with two arguments: for example, +(x, y) is a binary function.\n\nAlso note: a binary function in Base must be imported to be extended: use import Base: op; @binary op.\n\nExample\n\njulia> using Oceananigans, Oceananigans.AbstractOperations\n\njulia> using Oceananigans.AbstractOperations: BinaryOperation, AbstractGridMetric, choose_location\n\njulia> plus_or_times(x, y) = x < 0 ? x + y : x * y\nplus_or_times (generic function with 1 method)\n\njulia> @binary plus_or_times\nSet{Any} with 6 elements:\n  :+\n  :/\n  :^\n  :-\n  :*\n  :plus_or_times\n\njulia> c, d = (CenterField(RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))) for i = 1:2);\n\njulia> plus_or_times(c, d)\nBinaryOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 1Ã—1Ã—1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ””â”€â”€ tree:\n    plus_or_times at (Center, Center, Center)\n Â Â  â”œâ”€â”€ 1Ã—1Ã—1 Field{Center, Center, Center} on RectilinearGrid on CPU\n Â Â  â””â”€â”€ 1Ã—1Ã—1 Field{Center, Center, Center} on RectilinearGrid on CPU\n\n\n\n\n\n","category":"macro"},{"location":"appendix/library/#Oceananigans.AbstractOperations.@multiary-Tuple","page":"Library","title":"Oceananigans.AbstractOperations.@multiary","text":"@multiary op1 op2 op3...\n\nTurn each multiary operator in the list (op1, op2, op3...) into a multiary operator on Oceananigans.Fields for use in AbstractOperations.\n\nNote that a multiary operator:\n\nis a function with two or more arguments: for example, +(x, y, z) is a multiary function;\nmust be imported to be extended if part of Base: use import Base: op; @multiary op;\ncan only be called on Oceananigans.Fields if the \"location\" is noted explicitly; see example.\n\nExample\n\njulia> using Oceananigans, Oceananigans.AbstractOperations\n\njulia> harmonic_plus(a, b, c) = 1/3 * (1/a + 1/b + 1/c)\nharmonic_plus (generic function with 1 method)\n\njulia> c, d, e = Tuple(CenterField(RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))) for i = 1:3);\n\njulia> harmonic_plus(c, d, e) # before magic @multiary transformation\nBinaryOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 1Ã—1Ã—1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ””â”€â”€ tree:\n    * at (Center, Center, Center)\n Â Â  â”œâ”€â”€ 0.3333333333333333\n Â Â  â””â”€â”€ + at (Center, Center, Center)\n Â Â   Â Â  â”œâ”€â”€ / at (Center, Center, Center)\n Â Â   Â Â  â”‚Â Â  â”œâ”€â”€ 1\n Â Â   Â Â  â”‚Â Â  â””â”€â”€ 1Ã—1Ã—1 Field{Center, Center, Center} on RectilinearGrid on CPU\n Â Â   Â Â  â”œâ”€â”€ / at (Center, Center, Center)\n Â Â   Â Â  â”‚Â Â  â”œâ”€â”€ 1\n Â Â   Â Â  â”‚Â Â  â””â”€â”€ 1Ã—1Ã—1 Field{Center, Center, Center} on RectilinearGrid on CPU\n Â Â   Â Â  â””â”€â”€ / at (Center, Center, Center)\n Â Â   Â Â   Â Â  â”œâ”€â”€ 1\n Â Â   Â Â   Â Â  â””â”€â”€ 1Ã—1Ã—1 Field{Center, Center, Center} on RectilinearGrid on CPU\n\njulia> @multiary harmonic_plus\nSet{Any} with 3 elements:\n  :+\n  :harmonic_plus\n  :*\n\njulia> harmonic_plus(c, d, e)\nMultiaryOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 1Ã—1Ã—1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ””â”€â”€ tree:\n    harmonic_plus at (Center, Center, Center)\n Â Â  â”œâ”€â”€ 1Ã—1Ã—1 Field{Center, Center, Center} on RectilinearGrid on CPU\n Â Â  â”œâ”€â”€ 1Ã—1Ã—1 Field{Center, Center, Center} on RectilinearGrid on CPU\n Â Â  â””â”€â”€ 1Ã—1Ã—1 Field{Center, Center, Center} on RectilinearGrid on CPU\n\n\n\n\n\n","category":"macro"},{"location":"appendix/library/#Oceananigans.AbstractOperations.@unary-Tuple","page":"Library","title":"Oceananigans.AbstractOperations.@unary","text":"@unary op1 op2 op3...\n\nTurn each unary function in the list (op1, op2, op3...) into a unary operator on Oceananigans.Fields for use in AbstractOperations.\n\nNote: a unary function is a function with one argument: for example, sin(x) is a unary function.\n\nAlso note: a unary function in Base must be imported to be extended: use import Base: op; @unary op.\n\nExample\n\njulia> using Oceananigans, Oceananigans.Grids, Oceananigans.AbstractOperations\n\njulia> square_it(x) = x^2\nsquare_it (generic function with 1 method)\n\njulia> @unary square_it\nSet{Any} with 10 elements:\n  :+\n  :sqrt\n  :square_it\n  :cos\n  :exp\n  :interpolate_identity\n  :-\n  :tanh\n  :sin\n  :abs\n\njulia> c = CenterField(RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)));\n\njulia> square_it(c)\nUnaryOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 1Ã—1Ã—1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ””â”€â”€ tree:\n    square_it at (Center, Center, Center) via identity\n Â Â  â””â”€â”€ 1Ã—1Ã—1 Field{Center, Center, Center} on RectilinearGrid on CPU\n\n\n\n\n\n","category":"macro"},{"location":"appendix/library/#Advection","page":"Library","title":"Advection","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Advection]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.Advection.Centered","page":"Library","title":"Oceananigans.Advection.Centered","text":"struct Centered{N, FT, XT, YT, ZT, CA} <: AbstractCenteredAdvectionScheme{N, FT}\n\nCentered reconstruction scheme.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Advection.UpwindBiased","page":"Library","title":"Oceananigans.Advection.UpwindBiased","text":"struct UpwindBiasedFifthOrder <: AbstractUpwindBiasedAdvectionScheme{3}\n\nUpwind-biased fifth-order advection scheme.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Advection.VectorInvariant-Union{Tuple{}, Tuple{FT}, Tuple{N}} where {N, FT}","page":"Library","title":"Oceananigans.Advection.VectorInvariant","text":"VectorInvariant(; vorticity_scheme::AbstractAdvectionScheme{N, FT} = EnstrophyConservingScheme(), \n                  divergence_scheme  = nothing, \n                  vorticity_stencil  = VelocityStencil(),\n                  divergence_stencil = DefaultStencil(),\n                  vertical_scheme    = EnergyConservingScheme()) where {N, FT}\n\nConstruct a vector invariant momentum advection scheme of order N * 2 - 1.\n\nKeyword arguments\n\nvorticity_scheme: Scheme used for Center reconstruction of vorticity, options are upwind advection schemes                     - UpwindBiased and WENO - in addition to an EnergyConservingScheme and an EnstrophyConservingScheme                     (defaults to EnstrophyConservingScheme)\ndivergence_scheme: Scheme used for Face reconstruction of divergence. Options are upwind advection schemes                      - UpwindBiased and WENO - or nothing. In case nothing is specified, divergence flux is                      absorbed into the vertical advection term (defaults to nothing). If vertical_scheme isa EnergyConservingScheme,                      divergence flux is absorbed in vertical advection and this keyword argument has no effect\nvorticity_stencil: Stencil used for smoothness indicators in case of a WENO upwind reconstruction. Choices are between VelocityStencil                      which uses the horizontal velocity field to diagnose smoothness and DefaultStencil which uses the variable                      being transported (defaults to VelocityStencil)\ndivergence_stencil: same as vorticity_stencil but for divergence reconstruction (defaults to DefaultStencil)\nvertical_scheme: Scheme used for vertical advection of horizontal momentum. It has to be consistent with the choice of                     divergence_stencil. If the latter is a Nothing, only EnergyConservingScheme is available (this keyword                    argument has no effect). In case divergence_scheme is an AbstractUpwindBiasedAdvectionScheme,                     vertical_scheme describes a flux form reconstruction of vertical momentum advection, and any                     advection scheme can be used - Centered, UpwindBiased and WENO (defaults to EnergyConservingScheme)\n\nExamples\n\njulia> using Oceananigans\n\njulia> VectorInvariant()\nVector Invariant reconstruction, maximum order 1 \n Vorticity flux scheme: \n    â””â”€â”€ EnstrophyConservingScheme{Float64} \n Divergence flux scheme: \n    â””â”€â”€ Nothing \n Vertical advection scheme: \n    â””â”€â”€ EnergyConservingScheme{Float64}\n\n\njulia> using Oceananigans\n\njulia> VectorInvariant(vorticity_scheme = WENO(), divergence_scheme = WENO(), vertical_scheme = WENO(order = 3))\nVector Invariant reconstruction, maximum order 5 \n Vorticity flux scheme: \n    â””â”€â”€ WENO reconstruction order 5 with smoothness stencil Oceananigans.Advection.VelocityStencil()\n Divergence flux scheme: \n    â””â”€â”€ WENO reconstruction order 5 with smoothness stencil Oceananigans.Advection.DefaultStencil()\n Vertical advection scheme: \n    â””â”€â”€ WENO reconstruction order 3\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Advection.WENO","page":"Library","title":"Oceananigans.Advection.WENO","text":"WENO([FT=Float64;] \n     order = 5,\n     grid = nothing, \n     zweno = true, \n     bounds = nothing)\n\nConstruct a weigthed essentially non-oscillatory advection scheme of order order.\n\nKeyword arguments\n\norder: The order of the WENO advection scheme. Default: 5\ngrid: (defaults to nothing)\nzweno: When true implement a Z-WENO formulation for the WENO weights calculation.          (defaults to true)\n\nExamples\n\njulia> using Oceananigans\n\njulia> WENO()\nWENO reconstruction order 5\n Smoothness formulation: \n    â””â”€â”€ Z-weno  \n Boundary scheme: \n    â””â”€â”€ WENO reconstruction order 3\n Symmetric scheme: \n    â””â”€â”€ Centered reconstruction order 4\n Directions:\n    â”œâ”€â”€ X regular \n    â”œâ”€â”€ Y regular \n    â””â”€â”€ Z regular\n\njulia> using Oceananigans\n\njulia> Nx, Nz = 16, 10;\n\njulia> Lx, Lz = 1e4, 1e3;\n\njulia> chebychev_spaced_z_faces(k) = - Lz/2 - Lz/2 * cos(Ï€ * (k - 1) / Nz);\n\njulia> grid = RectilinearGrid(size = (Nx, Nz), halo = (4, 4), topology=(Periodic, Flat, Bounded),\n                              x = (0, Lx), z = chebychev_spaced_z_faces);\n\njulia> WENO(grid; order=7)\nWENO reconstruction order 7\n Smoothness formulation: \n    â””â”€â”€ Z-weno  \n Boundary scheme: \n    â””â”€â”€ WENO reconstruction order 5\n Symmetric scheme: \n    â””â”€â”€ Centered reconstruction order 6\n Directions:\n    â”œâ”€â”€ X regular \n    â”œâ”€â”€ Y regular \n    â””â”€â”€ Z stretched\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Advection.div_Uc-NTuple{7, Any}","page":"Library","title":"Oceananigans.Advection.div_Uc","text":"div_uc(i, j, k, grid, advection, U, c)\n\nCalculate the divergence of the flux of a tracer quantity c being advected by a velocity field, (ğ¯ c),\n\n1/V * [Î´xá¶œáµƒáµƒ(Ax * u * â„‘xá¶ áµƒáµƒ(c)) + Î´yáµƒá¶œáµƒ(Ay * v * â„‘yáµƒá¶ áµƒ(c)) + Î´záµƒáµƒá¶œ(Az * w * â„‘záµƒáµƒá¶ (c))]\n\nwhich ends up at the location ccc.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Advection.div_ğ¯u-NTuple{7, Any}","page":"Library","title":"Oceananigans.Advection.div_ğ¯u","text":"div_ğ¯u(i, j, k, grid, advection, U, u)\n\nCalculate the advection of momentum in the x-direction using the conservative form, (ğ¯ u),\n\n1/Váµ˜ * [Î´xá¶ áµƒáµƒ(â„‘xá¶œáµƒáµƒ(Ax * u) * â„‘xá¶œáµƒáµƒ(u)) + Î´y_fca(â„‘xá¶ áµƒáµƒ(Ay * v) * â„‘yáµƒá¶ áµƒ(u)) + Î´z_fac(â„‘xá¶ áµƒáµƒ(Az * w) * â„‘záµƒáµƒá¶ (u))]\n\nwhich ends up at the location fcc.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Advection.div_ğ¯v-NTuple{7, Any}","page":"Library","title":"Oceananigans.Advection.div_ğ¯v","text":"div_ğ¯v(i, j, k, grid, advection, U, v)\n\nCalculate the advection of momentum in the y-direction using the conservative form, (ğ¯ v),\n\n1/VÊ¸ * [Î´x_cfa(â„‘yáµƒá¶ áµƒ(Ax * u) * â„‘xá¶ áµƒáµƒ(v)) + Î´yáµƒá¶ áµƒ(â„‘yáµƒá¶œáµƒ(Ay * v) * â„‘yáµƒá¶œáµƒ(v)) + Î´z_afc(â„‘xá¶ áµƒáµƒ(Az * w) * â„‘záµƒáµƒá¶ (w))]\n\nwhich ends up at the location cfc.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Advection.div_ğ¯w-NTuple{7, Any}","page":"Library","title":"Oceananigans.Advection.div_ğ¯w","text":"div_ğ¯w(i, j, k, grid, advection, U, w)\n\nCalculate the advection of momentum in the z-direction using the conservative form, (ğ¯ w),\n\n1/VÊ· * [Î´x_caf(â„‘záµƒáµƒá¶ (Ax * u) * â„‘xá¶ áµƒáµƒ(w)) + Î´y_acf(â„‘záµƒáµƒá¶ (Ay * v) * â„‘yáµƒá¶ áµƒ(w)) + Î´záµƒáµƒá¶ (â„‘záµƒáµƒá¶œ(Az * w) * â„‘záµƒáµƒá¶œ(w))]\n\nwhich ends up at the location ccf.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Architectures","page":"Library","title":"Architectures","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Architectures]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.Architectures.AbstractArchitecture","page":"Library","title":"Oceananigans.Architectures.AbstractArchitecture","text":"AbstractArchitecture\n\nAbstract supertype for architectures supported by Oceananigans.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Architectures.CPU","page":"Library","title":"Oceananigans.Architectures.CPU","text":"CPU <: AbstractArchitecture\n\nRun Oceananigans on one CPU node. Uses multiple threads if the environment variable JULIA_NUM_THREADS is set.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Architectures.GPU","page":"Library","title":"Oceananigans.Architectures.GPU","text":"GPU <: AbstractArchitecture\n\nRun Oceananigans on a single NVIDIA CUDA GPU.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Boundary-conditions","page":"Library","title":"Boundary conditions","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.BoundaryConditions]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.BoundaryConditions.BoundaryCondition","page":"Library","title":"Oceananigans.BoundaryConditions.BoundaryCondition","text":"struct BoundaryCondition{C<:AbstractBoundaryConditionClassification, T}\n\nContainer for boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.BoundaryConditions.BoundaryCondition-Tuple{DataType, Any}","page":"Library","title":"Oceananigans.BoundaryConditions.BoundaryCondition","text":"BoundaryCondition(Classification::DataType, condition)\n\nConstruct a boundary condition of type BC with a number or array as a condition.\n\nBoundary condition types include Periodic, Flux, Value, Gradient, and Open.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.BoundaryConditions.BoundaryCondition-Tuple{DataType, Function}","page":"Library","title":"Oceananigans.BoundaryConditions.BoundaryCondition","text":"BoundaryCondition(Classification::DataType, condition::Function;\n                  parameters = nothing,\n                  discrete_form = false,\n                  field_dependencies=())\n\nConstruct a boundary condition of type Classification with a function boundary condition.\n\nBy default, the function boudnary condition is assumed to have the 'continuous form' condition(Î¾, Î·, t), where t is time and Î¾ and Î· vary along the boundary. In particular:\n\nOn x-boundaries, condition(y, z, t).\nOn y-boundaries, condition(x, z, t).\nOn z-boundaries, condition(x, y, t).\n\nIf parameters is not nothing, then function boundary conditions have the form func(Î¾, Î·, t, parameters), where Î¾ and Î· are spatial coordinates varying along the boundary as explained above.\n\nIf discrete_form = true, the function condition is assumed to have the \"discrete form\",\n\ncondition(i, j, grid, clock, model_fields)\n\nwhere i, and j are indices that vary along the boundary. If discrete_form = true and parameters is not nothing, the function condition is called with\n\ncondition(i, j, grid, clock, model_fields, parameters)\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.BoundaryConditions.FieldBoundaryConditions","page":"Library","title":"Oceananigans.BoundaryConditions.FieldBoundaryConditions","text":"FieldBoundaryConditions(grid, location, indices=(:, :, :);\n                        west     = default_auxiliary_bc(topology(grid, 1)(), location[1]()),\n                        east     = default_auxiliary_bc(topology(grid, 1)(), location[1]()),\n                        south    = default_auxiliary_bc(topology(grid, 2)(), location[2]()),\n                        north    = default_auxiliary_bc(topology(grid, 2)(), location[2]()),\n                        bottom   = default_auxiliary_bc(topology(grid, 3)(), location[3]()),\n                        top      = default_auxiliary_bc(topology(grid, 3)(), location[3]()),\n                        immersed = NoFluxBoundaryCondition())\n\nReturn boundary conditions for auxiliary fields (fields whose values are derived from a model's prognostic fields) on grid and at location.\n\nKeyword arguments\n\nKeyword arguments specify boundary conditions on the 6 possible boundaries:\n\nwest, left end point in the x-direction where i = 1\neast, right end point in the x-direction where i = grid.Nx\nsouth, left end point in the y-direction where j = 1\nnorth, right end point in the y-direction where j = grid.Ny\nbottom, right end point in the z-direction where k = 1\ntop, right end point in the z-direction where k = grid.Nz\nimmersed: boundary between solid and fluid for immersed boundaries\n\nIf a boundary condition is unspecified, the default for auxiliary fields and the topology in the boundary-normal direction is used:\n\nPeriodicBoundaryCondition for Periodic directions\nGradientBoundaryCondition(0) for Bounded directions and Centered-located fields\nnothing for Bounded directions and Face-located fields\nnothing for Flat directions and/or Nothing-located fields\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.BoundaryConditions.FieldBoundaryConditions-2","page":"Library","title":"Oceananigans.BoundaryConditions.FieldBoundaryConditions","text":"FieldBoundaryConditions(; kwargs...)\n\nReturn a template for boundary conditions on prognostic fields.\n\nKeyword arguments\n\nKeyword arguments specify boundary conditions on the 7 possible boundaries:\n\nwest: left end point in the x-direction where i = 1\neast: right end point in the x-direction where i = grid.Nx\nsouth: left end point in the y-direction where j = 1\nnorth: right end point in the y-direction where j = grid.Ny\nbottom: right end point in the z-direction where k = 1\ntop: right end point in the z-direction where k = grid.Nz\nimmersed: boundary between solid and fluid for immersed boundaries\n\nIf a boundary condition is unspecified, the default for prognostic fields and the topology in the boundary-normal direction is used:\n\nPeriodicBoundaryCondition for Periodic directions\nNoFluxBoundaryCondition for Bounded directions and Centered-located fields\nImpenetrableBoundaryCondition for Bounded directions and Face-located fields\nnothing for Flat directions and/or Nothing-located fields\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.BoundaryConditions.Flux","page":"Library","title":"Oceananigans.BoundaryConditions.Flux","text":"struct Flux <: AbstractBoundaryConditionClassification\n\nA classification specifying a boundary condition on the flux of a field.\n\nThe sign convention is such that a positive flux represents the flux of a quantity in the positive direction. For example, a positive vertical flux implies a quantity is fluxed upwards, in the +z direction.\n\nDue to this convention, a positive flux applied to the top boundary specifies that a quantity is fluxed upwards across the top boundary and thus out of the domain. As a result, a positive flux applied to a top boundary leads to a reduction of that quantity in the interior of the domain; for example, a positive, upwards flux of heat at the top of the domain acts to cool the interior of the domain. Conversely, a positive flux applied to the bottom boundary leads to an increase of the quantity in the interior of the domain. The same logic holds for east, west, north, and south boundaries.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.BoundaryConditions.Gradient","page":"Library","title":"Oceananigans.BoundaryConditions.Gradient","text":"struct Gradient <: AbstractBoundaryConditionClassification\n\nA classification specifying a boundary condition on the derivative or gradient of a field. Also called a Neumann boundary condition.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.BoundaryConditions.Open","page":"Library","title":"Oceananigans.BoundaryConditions.Open","text":"struct Open <: AbstractBoundaryConditionClassification\n\nA classification that specifies the halo regions of a field directly.\n\nFor fields located at Faces, Open also specifies field value on the boundary.\n\nOpen boundary conditions are used to specify the component of a velocity field normal to a boundary and can also be used to describe nested or linked simulation domains.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.BoundaryConditions.Value","page":"Library","title":"Oceananigans.BoundaryConditions.Value","text":"struct Value <: AbstractBoundaryConditionClassification\n\nA classification specifying a boundary condition on the value of a field. Also called a Dirchlet boundary condition.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.BoundaryConditions.apply_x_bcs!-Tuple{Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any, Oceananigans.Architectures.AbstractArchitecture, Vararg{Any}}","page":"Library","title":"Oceananigans.BoundaryConditions.apply_x_bcs!","text":"Apply flux boundary conditions to a field c by adding the associated flux divergence to the source term Gc at the left and right.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.BoundaryConditions.apply_y_bcs!-Tuple{Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any, Oceananigans.Architectures.AbstractArchitecture, Vararg{Any}}","page":"Library","title":"Oceananigans.BoundaryConditions.apply_y_bcs!","text":"Apply flux boundary conditions to a field c by adding the associated flux divergence to the source term Gc at the left and right.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.BoundaryConditions.apply_z_bcs!-Tuple{Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any, Oceananigans.Architectures.AbstractArchitecture, Vararg{Any}}","page":"Library","title":"Oceananigans.BoundaryConditions.apply_z_bcs!","text":"Apply flux boundary conditions to a field c by adding the associated flux divergence to the source term Gc at the top and bottom.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.BoundaryConditions.fill_halo_regions!-Tuple{Union{Tuple{Vararg{OffsetArrays.OffsetArray, var\"#s312\"}} where var\"#s312\", OffsetArrays.OffsetArray}, Any, Any, Any, Any, Vararg{Any}}","page":"Library","title":"Oceananigans.BoundaryConditions.fill_halo_regions!","text":"Fill halo regions in x, y, and z for a given field's data.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Buoyancy-models","page":"Library","title":"Buoyancy models","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.BuoyancyModels]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.BuoyancyModels.Buoyancy-Tuple{}","page":"Library","title":"Oceananigans.BuoyancyModels.Buoyancy","text":"Buoyancy(; model, gravity_unit_vector=NegativeZDirection())\n\nConstruct a buoyancy given a buoyancy model. Optional keyword argument gravity_unit_vector can be used to specify the direction of gravity (default NegativeZDirection()). The buoyancy acceleration acts in the direction opposite to gravity.\n\nExample\n\n\nusing Oceananigans\n\ngrid = RectilinearGrid(size=(1, 8, 8), extent=(1, 1, 1))\n\nÎ¸ = 45 # degrees\ngÌƒ = (0, sind(Î¸), cosd(Î¸));\n\nbuoyancy = Buoyancy(model=BuoyancyTracer(), gravity_unit_vector=gÌƒ)\n\nmodel = NonhydrostaticModel(grid=grid, buoyancy=buoyancy, tracers=:b)\n\n# output\n\nâ”Œ Warning: The meaning of `gravity_unit_vector` changed in version 0.80.0.\nâ”‚ In versions 0.79 and earlier, `gravity_unit_vector` indicated the direction _opposite_ to gravity.\nâ”‚ In versions 0.80.0 and later, `gravity_unit_vector` indicates the direction of gravitational acceleration.\nâ”” @ Oceananigans.BuoyancyModels ~/builds/tartarus-16/clima/oceananigans/src/BuoyancyModels/buoyancy.jl:48\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 1Ã—8Ã—8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ timestepper: QuasiAdamsBashforth2TimeStepper\nâ”œâ”€â”€ tracers: b\nâ”œâ”€â”€ closure: Nothing\nâ”œâ”€â”€ buoyancy: BuoyancyTracer with gÌ‚ = Tuple{Float64, Float64, Float64}\nâ””â”€â”€ coriolis: Nothing\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.BuoyancyModels.BuoyancyTracer","page":"Library","title":"Oceananigans.BuoyancyModels.BuoyancyTracer","text":"BuoyancyTracer <: AbstractBuoyancyModel{Nothing}\n\nType indicating that the tracer b represents buoyancy.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.BuoyancyModels.LinearEquationOfState","page":"Library","title":"Oceananigans.BuoyancyModels.LinearEquationOfState","text":"LinearEquationOfState([FT=Float64;] thermal_expansion=1.67e-4, haline_contraction=7.80e-4)\n\nReturn LinearEquationOfState for SeawaterBuoyancy with thermal_expansion coefficient and haline_contraction coefficient. The buoyancy perturbation b for LinearEquationOfState is\n\n    b = g (Î± T - Î² S)\n\nwhere g is gravitational acceleration, Î± is thermal_expansion, Î² is haline_contraction, T is temperature, and S is practical salinity units.\n\nDefault constants in units inverse Kelvin and practical salinity units for thermal_expansion and haline_contraction, respectively, are taken from Table 1.2 (page 33) of Vallis, \"Atmospheric and Oceanic Fluid Dynamics: Fundamentals and Large-Scale Circulation\" (2nd ed, 2017).\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.BuoyancyModels.LinearEquationOfState-2","page":"Library","title":"Oceananigans.BuoyancyModels.LinearEquationOfState","text":"LinearEquationOfState{FT} <: AbstractEquationOfState\n\nLinear equation of state for seawater.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.BuoyancyModels.SeawaterBuoyancy","page":"Library","title":"Oceananigans.BuoyancyModels.SeawaterBuoyancy","text":"SeawaterBuoyancy([FT = Float64;]\n                 gravitational_acceleration = g_Earth,\n                 equation_of_state = LinearEquationOfState(FT),\n                 constant_temperature = false,\n                 constant_salinity = false)\n\nReturns parameters for a temperature- and salt-stratified seawater buoyancy model with a gravitational_acceleration constant (typically called g), and an equation_of_state that related temperature and salinity (or conservative temperature and absolute salinity) to density anomalies and buoyancy.\n\nconstant_temperature indicates that buoyancy depends only on salinity. For a nonlinear equation of state, constant_temperature is used as the temperature of the system. The same logic, with the roles of salinity and temperature reversed, holds when constant_salinity is provided.\n\nFor a linear equation of state, the values of constant_temperature or constant_salinity are irrelevant; in this case, constant_temperature=true (and similar for constant_salinity) is valid input.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.BuoyancyModels.SeawaterBuoyancy-2","page":"Library","title":"Oceananigans.BuoyancyModels.SeawaterBuoyancy","text":"SeawaterBuoyancy{FT, EOS, T, S} <: AbstractBuoyancyModel{EOS}\n\nBuoyancyModels model for seawater. T and S are either nothing if both temperature and salinity are active, or of type FT if temperature or salinity are constant, respectively.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.BuoyancyModels.âˆ‚x_b-Tuple{Any, Any, Any, Any, SeawaterBuoyancy, Any}","page":"Library","title":"Oceananigans.BuoyancyModels.âˆ‚x_b","text":"âˆ‚x_b(i, j, k, grid, b::SeawaterBuoyancy, C)\n\nReturns the x-derivative of buoyancy for temperature and salt-stratified water,\n\n_x b = g ( Î± _x T - Î² _x S ) \n\nwhere g is gravitational acceleration, Î± is the thermal expansion coefficient, Î² is the haline contraction coefficient, T is conservative temperature, and S is absolute salinity.\n\nNote: In Oceananigans, model.tracers.T is conservative temperature and model.tracers.S is absolute salinity.\n\nNote that _x T (âˆ‚x_T), _x S (âˆ‚x_S), Î±, and Î² are all evaluated at cell interfaces in x and cell centers in y and z.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.BuoyancyModels.âˆ‚y_b-Tuple{Any, Any, Any, Any, SeawaterBuoyancy, Any}","page":"Library","title":"Oceananigans.BuoyancyModels.âˆ‚y_b","text":"âˆ‚y_b(i, j, k, grid, b::SeawaterBuoyancy, C)\n\nReturns the y-derivative of buoyancy for temperature and salt-stratified water,\n\n_y b = g ( Î± _y T - Î² _y S ) \n\nwhere g is gravitational acceleration, Î± is the thermal expansion coefficient, Î² is the haline contraction coefficient, T is conservative temperature, and S is absolute salinity.\n\nNote: In Oceananigans, model.tracers.T is conservative temperature and model.tracers.S is absolute salinity.\n\nNote that _y T (âˆ‚y_T), _y S (âˆ‚y_S), Î±, and Î² are all evaluated at cell interfaces in y and cell centers in x and z.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.BuoyancyModels.âˆ‚z_b-Tuple{Any, Any, Any, Any, SeawaterBuoyancy, Any}","page":"Library","title":"Oceananigans.BuoyancyModels.âˆ‚z_b","text":"âˆ‚z_b(i, j, k, grid, b::SeawaterBuoyancy, C)\n\nReturns the vertical derivative of buoyancy for temperature and salt-stratified water,\n\n_z b = N^2 = g ( Î± _z T - Î² _z S ) \n\nwhere g is gravitational acceleration, Î± is the thermal expansion coefficient, Î² is the haline contraction coefficient, T is conservative temperature, and S is absolute salinity.\n\nNote: In Oceananigans, model.tracers.T is conservative temperature and model.tracers.S is absolute salinity.\n\nNote that _z T (âˆ‚z_T), _z S (âˆ‚z_S), Î±, and Î² are all evaluated at cell interfaces in z and cell centers in x and y.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Coriolis","page":"Library","title":"Coriolis","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Coriolis]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.Coriolis.ActiveCellEnstrophyConservingScheme","page":"Library","title":"Oceananigans.Coriolis.ActiveCellEnstrophyConservingScheme","text":"struct ActiveCellEnstrophyConservingScheme\n\nA parameter object for an enstrophy-conserving Coriolis scheme that excludes inactive (dry/land) edges (indices for which peripheral_node == true) from the velocity interpolation.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Coriolis.BetaPlane","page":"Library","title":"Oceananigans.Coriolis.BetaPlane","text":"BetaPlane([T=Float64;] fâ‚€=nothing, Î²=nothing,\n                       rotation_rate=Î©_Earth, latitude=nothing, radius=R_Earth)\n\nReturn a Î²-plane Coriolis parameter, f = fâ‚€ + Î² y. \n\nThe user may specify both fâ‚€ and Î², or the three parameters rotation_rate, latitude (in degrees), and radius that specify the rotation rate and radius of a planet, and the central latitude (where y = 0) at which the Î²-plane approximation is to be made.\n\nIf fâ‚€ and Î² are not specified, they are calculated from rotation_rate, latitude, and radius according to the relations fâ‚€ = 2 * rotation_rate * sind(latitude) and Î² = 2 * rotation_rate * cosd(latitude) / radius.\n\nBy default, the rotation_rate and planet radius are assumed to be Earth's.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Coriolis.BetaPlane-2","page":"Library","title":"Oceananigans.Coriolis.BetaPlane","text":"struct BetaPlane{T} <: AbstractRotation\n\nA parameter object for meridionally increasing Coriolis parameter (f = fâ‚€ + Î² y) that accounts for the variation of the locally vertical component of the rotation vector with latitude.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Coriolis.ConstantCartesianCoriolis","page":"Library","title":"Oceananigans.Coriolis.ConstantCartesianCoriolis","text":"ConstantCartesianCoriolis([FT=Float64;] fx=nothing, fy=nothing, fz=nothing,\n                                        f=nothing, rotation_axis=ZDirection(), \n                                        rotation_rate=Î©_Earth, latitude=nothing)\n\nReturn a parameter object for a constant rotation decomposed into the x, y, and z directions. In oceanography the components x, y, z correspond to the directions east, north, and up. This constant rotation can be specified in three different ways:\n\nSpecifying all components fx, fy and fz directly.\nSpecifying the Coriolis parameter f and (optionally) a rotation_axis (which defaults to the z direction if not specified).\nSpecifying latitude (in degrees) and (optionally) a rotation_rate in radians per second (which defaults to Earth's rotation rate).\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Coriolis.ConstantCartesianCoriolis-2","page":"Library","title":"Oceananigans.Coriolis.ConstantCartesianCoriolis","text":"struct ConstantCartesianCoriolis{FT} <: AbstractRotation\n\nA Coriolis implementation that accounts for the locally vertical and possibly both local horizontal components of a constant rotation vector. This is a more general implementation of FPlane, which only accounts for the locally vertical component.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Coriolis.FPlane","page":"Library","title":"Oceananigans.Coriolis.FPlane","text":"FPlane([FT=Float64;] f=nothing, rotation_rate=Î©_Earth, latitude=nothing)\n\nReturn a parameter object for constant rotation at the angular frequency f/2, and therefore with background vorticity f, around a vertical axis. If f is not specified, it is calculated from rotation_rate and latitude (in degrees) according to the relation f = 2 * rotation_rate * sind(latitude).\n\nBy default, rotation_rate is assumed to be Earth's.\n\nAlso called FPlane, after the \"f-plane\" approximation for the local effect of a planet's rotation in a planar coordinate system tangent to the planet's surface.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Coriolis.FPlane-2","page":"Library","title":"Oceananigans.Coriolis.FPlane","text":"struct FPlane{FT} <: AbstractRotation\n\nA parameter object for constant rotation around a vertical axis.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Coriolis.HydrostaticSphericalCoriolis","page":"Library","title":"Oceananigans.Coriolis.HydrostaticSphericalCoriolis","text":"struct HydrostaticSphericalCoriolis{S, FT} <: AbstractRotation\n\nA parameter object for constant rotation around a vertical axis on the sphere.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Coriolis.HydrostaticSphericalCoriolis-Union{Tuple{}, Tuple{DataType}, Tuple{S}} where S","page":"Library","title":"Oceananigans.Coriolis.HydrostaticSphericalCoriolis","text":"HydrostaticSphericalCoriolis([FT=Float64;]\n                             rotation_rate = Î©_Earth,\n                             scheme = EnergyConservingScheme())\n\nReturn a parameter object for Coriolis forces on a sphere rotating at rotation_rate. By default, rotation_rate is assumed to be Earth's.\n\nKeyword arguments\n\nscheme: Either EnergyConservingScheme() (default), EnstrophyConservingScheme(), or ActiveCellEnstrophyConservingScheme().\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Coriolis.NonTraditionalBetaPlane","page":"Library","title":"Oceananigans.Coriolis.NonTraditionalBetaPlane","text":"NonTraditionalBetaPlane(FT=Float64;\n                        fz=nothing, fy=nothing, Î²=nothing, Î³=nothing,\n                        rotation_rate=Î©_Earth, latitude=nothing, radius=R_Earth)\n\nThe user may directly specify fz, fy, Î², Î³, and radius or the three parameters rotation_rate, latitude (in degrees), and radius that specify the rotation rate and radius of a planet, and the central latitude (where y = 0) at which the non-traditional Î²-plane approximation is to be made.\n\nIf fz, fy, Î², and Î³ are not specified, they are calculated from rotation_rate,  latitude, and radius according to the relations fz = 2 * rotation_rate * sind(latitude), fy = 2 * rotation_rate * cosd(latitude), Î² = 2 * rotation_rate * cosd(latitude) / radius, and Î³ = - 4 * rotation_rate * sind(latitude) / radius.\n\nBy default, the rotation_rate and planet radius is assumed to be Earth's.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Coriolis.NonTraditionalBetaPlane-2","page":"Library","title":"Oceananigans.Coriolis.NonTraditionalBetaPlane","text":"struct NonTraditionalBetaPlane{FT} <: AbstractRotation\n\nA Coriolis implementation that accounts for the latitudinal variation of both the locally vertical and the locally horizontal components of the rotation vector. The \"traditional\" approximation in ocean models accounts for only the locally vertical component of the rotation vector (see BetaPlane).\n\nThis implementation is based off of section 5 of Dellar (2011). It conserve energy, angular momentum, and potential vorticity.\n\nReferences\n\nDellar, P. (2011). Variations on a beta-plane: Derivation of non-traditional     beta-plane equations from Hamilton's principle on a sphere. Journal of     Fluid Mechanics, 674, 174-195. doi:10.1017/S0022112010006464\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Diagnostics","page":"Library","title":"Diagnostics","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Diagnostics]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.Diagnostics.CFL","page":"Library","title":"Oceananigans.Diagnostics.CFL","text":"struct CFL{D, S}\n\nAn object for computing the Courant-Freidrichs-Lewy (CFL) number.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Diagnostics.CFL-Tuple{Any}","page":"Library","title":"Oceananigans.Diagnostics.CFL","text":"CFL(Î”t [, timescale = Oceananigans.Advection.cell_advection_timescale])\n\nReturn an object for computing the Courant-Freidrichs-Lewy (CFL) number associated with time step Î”t or TimeStepWizard and timescale.\n\nSee also AdvectiveCFL and DiffusiveCFL.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Diagnostics.StateChecker-Tuple{Any}","page":"Library","title":"Oceananigans.Diagnostics.StateChecker","text":"StateChecker(; schedule, fields)\n\nReturns a StateChecker that logs field information (minimum, maximum, mean) for each field in a named tuple of fields when schedule actuates.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Diagnostics.AdvectiveCFL-Tuple{Any}","page":"Library","title":"Oceananigans.Diagnostics.AdvectiveCFL","text":"AdvectiveCFL(Î”t)\n\nReturn an object for computing the Courant-Freidrichs-Lewy (CFL) number associated with time step Î”t or TimeStepWizard and the time scale for advection across a cell. The advective CFL is, e.g., U Î”t  Î”x.\n\nExample\n\njulia> using Oceananigans\n\njulia> model = NonhydrostaticModel(grid = RectilinearGrid(size=(16, 16, 16), extent=(8, 8, 8)));\n\njulia> Î”t = 1.0;\n\njulia> cfl = AdvectiveCFL(Î”t);\n\njulia> model.velocities.u .= Ï€;\n\njulia> cfl(model)\n6.283185307179586\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Diagnostics.DiffusiveCFL-Tuple{Any}","page":"Library","title":"Oceananigans.Diagnostics.DiffusiveCFL","text":"DiffusiveCFL(Î”t)\n\nReturns an object for computing the diffusive Courant-Freidrichs-Lewy (CFL) number associated with time step Î”t or TimeStepWizard and the time scale for diffusion across a cell associated with model.closure.  The diffusive CFL, e.g., for viscosity is Î½ Î”t  Î”xÂ².\n\nThe maximum diffusive CFL number among viscosity and all tracer diffusivities is returned.\n\nExample\n\njulia> using Oceananigans\n\njulia> model = NonhydrostaticModel(grid = RectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1)),\n                                   closure = ScalarDiffusivity(; Î½ = 1e-2));\n\njulia> Î”t = 0.1;\n\njulia> dcfl = DiffusiveCFL(Î”t);\n\njulia> dcfl(model)\n0.256\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Distributed","page":"Library","title":"Distributed","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Distributed]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.Distributed.DistributedArch","page":"Library","title":"Oceananigans.Distributed.DistributedArch","text":"DistributedArch(child_architecture = CPU(); \n                topology = (Periodic, Periodic, Periodic), \n                ranks, \n                use_buffers = false,\n                devices = nothing, \n                communicator = MPI.COMM_WORLD)\n\nConstructor for a distributed architecture that uses MPI for communications\n\nPositional arguments\n\nchild_architecture: Specifies whether the computation is performed on CPUs or GPUs.                        Default: child_architecture = CPU().\n\nKeyword arguments\n\ntopology: the topology we want the grid to have. It is used to establish connectivity.             Default: topology = (Periodic, Periodic, Periodic).\nranks (required): A 3-tuple (Rx, Ry, Rz) specifying the total processors in the x,                      y and z direction. NOTE: support for distributed z direction is                      limited, so Rz = 1 is strongly suggested.\nuse_buffers: if true, buffered halo communication is implemented. If false, halos will be                 exchanged through views. Buffered communication is not necessary in case of CPU                execution, but it is necessary for GPU execution without CUDA-aware MPI\ndevices: GPU device linked to local rank. The GPU will be assigned based on the             local node rank as such devices[node_rank]. Make sure to run --ntasks-per-node <= --gres=gpu.            If nothing, the devices will be assigned automatically based on the available resources\ncommunicator: the MPI communicator, MPI.COMM_WORLD. This keyword argument should not be tampered with                  if not for testing or developing. Change at your own risk!\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Distributed.DistributedFFTBasedPoissonSolver-Tuple{Any, Any}","page":"Library","title":"Oceananigans.Distributed.DistributedFFTBasedPoissonSolver","text":"DistributedFFTBasedPoissonSolver(global_grid, local_grid)\n\nReturn a FFT-based solver for the Poisson equation,\n\nÂ²Ï† = b\n\nfor DistributedArchitectures.\n\nSupported configurations\n\nWe support two \"modes\":\n\nVertical pencil decompositions: two-dimensional decompositions in (x y) for three dimensional problems that satisfy either Nz > Rx or Nz > Ry.\nOne-dimensional decompositions in either x or y.\n\nAbove, Nz = size(global_grid, 3) and Rx, Ry, Rz = architecture(local_grid).ranks.\n\nOther configurations that are decomposed in (x y) but have too few Nz, or any configuration decomposed in z, are not supported.\n\nAlgorithm for two-dimensional decompositions\n\nFor two-dimensional decompositions (useful for three-dimensional problems), there are three forward transforms, three backward transforms, and four transpositions requiring MPI communication. In the schematic below, the first dimension is always the local dimension. In our implementation of the PencilFFTs algorithm, we require either Nz >= Rx, or Nz >= Ry, where Nz is the number of vertical cells, Rx is the number of ranks in x, and Ry is the number of ranks in y. Below, we outline the algorithm for the case Nz >= Rx. If Nz < Rx, but Nz > Ry, a similar algorithm applies with x and y swapped:\n\nfirst(storage) is initialized with layout (z x y).\nTransform along z.\n\n3  Transpose + communicate to storage[2] in layout (x z y),    which is distributed into (Rx, Ry) processes in (z y).\n\nTransform along x.\nTranspose + communicate to last(storage) in layout (y x z), which is distributed into (Rx, Ry) processes in (x z).\nTransform in y.\n\nAt this point the three in-place forward transforms are complete, and we solve the Poisson equation by updating last(storage). Then the process is reversed to obtain first(storage) in physical space and with the layout (z x y).\n\nRestrictions\n\nThe algorithm for two-dimensional decompositions requires that Nz = size(global_grid, 3) is larger than either Rx = ranks[1] or Ry = ranks[2], where ranks are configured when building DistributedArch. If Nz does not satisfy this condition, we can only support a one-dimensional decomposition.\n\nAlgorithm for one-dimensional decompositions\n\nThis algorithm requires a one-dimensional decomposition with either Rx = 1 or Ry = 1, and is important to support two-dimensional transforms.\n\nFor one-dimensional decompositions, we place the decomposed direction last. If the number of ranks is Rh = max(Rx, Ry), this algorithm requires that  both Nx > Rh and Ny > Rh. The resulting flow of transposes and transforms is similar to the two-dimensional case. It remains somewhat of a mystery why this succeeds (i.e., why the last transform is correctly decomposed).\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Distributed.reconstruct_global_grid-Tuple{RectilinearGrid{FT, TX, TY, TZ, FX, FY, FZ, VX, VY, VZ, <:Oceananigans.Distributed.DistributedArch} where {FT, TX, TY, TZ, FX, FY, FZ, VX, VY, VZ}}","page":"Library","title":"Oceananigans.Distributed.reconstruct_global_grid","text":"reconstruct_global_grid(grid::DistributedGrid)\n\nReturn the global grid on child_architecture(grid)\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Fields","page":"Library","title":"Fields","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Fields]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.Fields.AbstractField","page":"Library","title":"Oceananigans.Fields.AbstractField","text":"AbstractField{LX, LY, LZ, G, T, N}\n\nAbstract supertype for fields located at (LX, LY, LZ) and defined on a grid G with eltype T and N dimensions.\n\nNote: we need the parameter T to subtype AbstractArray.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Fields.BackgroundField","page":"Library","title":"Oceananigans.Fields.BackgroundField","text":"BackgroundField{F, P}\n\nTemporary container for storing information about BackgroundFields.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Fields.BackgroundField-Tuple{Any}","page":"Library","title":"Oceananigans.Fields.BackgroundField","text":"BackgroundField(func; parameters=nothing)\n\nReturns a BackgroundField to be passed to NonhydrostaticModel for use as a background velocity or tracer field.\n\nIf parameters is not provided, func must be callable with the signature\n\nfunc(x, y, z, t)\n\nIf parameters is provided, func must be callable with the signature\n\nfunc(x, y, z, t, parameters)\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.Field-Union{Tuple{Oceananigans.Grids.AbstractGrid}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Oceananigans.Grids.AbstractGrid, DataType}} where {LX, LY, LZ}","page":"Library","title":"Oceananigans.Fields.Field","text":"Field{LX, LY, LZ}(grid::AbstractGrid,\n                  T::DataType=eltype(grid); kw...) where {LX, LY, LZ}\n\nConstruct a Field on grid with data type T at the location (LX, LY, LZ). Each of (LX, LY, LZ) is either Center or Face and determines the field's location in (x, y, z) respectively.\n\nKeyword arguments\n\ndata :: OffsetArray: An offset array with the fields data. If nothing is provided the field is filled with zeros.\nboundary_conditions: If nothing is provided, then field is created using the default\nboundary conditions via FieldBoundaryConditions.\nindices: Used to prescribe where a reduced field lives on. For example, at which k index does a two-dimensional x-y field lives on. Default: (:, :, :).\n\nExample\n\nA field at location (Face, Face, Center).\n\njulia> using Oceananigans\n\njulia> grid = RectilinearGrid(size=(2, 3, 4), extent=(1, 1, 1));\n\njulia> Ï‰ = Field{Face, Face, Center}(grid)\n2Ã—3Ã—4 Field{Face, Face, Center} on RectilinearGrid on CPU\nâ”œâ”€â”€ grid: 2Ã—3Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ boundary conditions: FieldBoundaryConditions\nâ”‚   â””â”€â”€ west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux\nâ””â”€â”€ data: 8Ã—9Ã—10 OffsetArray(::Array{Float64, 3}, -2:5, -2:6, -2:7) with eltype Float64 with indices -2:5Ã—-2:6Ã—-2:7\n    â””â”€â”€ max=0.0, min=0.0, mean=0.0\n\nNow, using indices we can create a two dimensional x-y field at location (Face, Face, Center) to compute, e.g., the vertical vorticity vx - uy at the fluid's surface z = 0, which for Center corresponds to k = Nz.\n\njulia> u = XFaceField(grid); v = YFaceField(grid);\n\njulia> Ï‰â‚› = Field(âˆ‚x(v) - âˆ‚y(u), indices=(:, :, grid.Nz))\n2Ã—3Ã—1 Field{Face, Face, Center} on RectilinearGrid on CPU\nâ”œâ”€â”€ grid: 2Ã—3Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ boundary conditions: FieldBoundaryConditions\nâ”‚   â””â”€â”€ west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux\nâ”œâ”€â”€ operand: BinaryOperation at (Face, Face, Center)\nâ”œâ”€â”€ status: time=0.0\nâ””â”€â”€ data: 8Ã—9Ã—1 OffsetArray(::Array{Float64, 3}, -2:5, -2:6, 4:4) with eltype Float64 with indices -2:5Ã—-2:6Ã—4:4\n    â””â”€â”€ max=0.0, min=0.0, mean=0.0\n\njulia> compute!(Ï‰â‚›)\n2Ã—3Ã—1 Field{Face, Face, Center} on RectilinearGrid on CPU\nâ”œâ”€â”€ grid: 2Ã—3Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ boundary conditions: FieldBoundaryConditions\nâ”‚   â””â”€â”€ west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux\nâ”œâ”€â”€ operand: BinaryOperation at (Face, Face, Center)\nâ”œâ”€â”€ status: time=0.0\nâ””â”€â”€ data: 8Ã—9Ã—1 OffsetArray(::Array{Float64, 3}, -2:5, -2:6, 4:4) with eltype Float64 with indices -2:5Ã—-2:6Ã—4:4\n    â””â”€â”€ max=0.0, min=0.0, mean=0.0\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.Reduction-Tuple{Any, Any}","page":"Library","title":"Oceananigans.Fields.Reduction","text":"Reduction(reduce!, operand; dims)\n\nReturn a Reduction of operand with reduce!, along dims. Note that Reduction expects reduce! to operate in-place.\n\nExample\n\nusing Oceananigans\n\nNx, Ny, Nz = 3, 3, 3\n\ngrid = RectilinearGrid(size=(Nx, Ny, Nz), x=(0, 1), y=(0, 1), z=(0, 1),\n                       topology=(Periodic, Periodic, Periodic))\n\nc = CenterField(grid)\n\nset!(c, (x, y, z) -> x + y + z)\n\nmax_cÂ² = Field(Reduction(maximum!, c^2, dims=3))\n\ncompute!(max_cÂ²)\n\nmax_cÂ²[1:Nx, 1:Ny]\n\n# output\n3Ã—3 Matrix{Float64}:\n 1.36111  2.25     3.36111\n 2.25     3.36111  4.69444\n 3.36111  4.69444  6.25\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.CenterField","page":"Library","title":"Oceananigans.Fields.CenterField","text":"CenterField(grid; kw...)\n\nReturn a Field{Center, Center, Center} on grid. Additional keyword arguments are passed to the Field constructor.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.Fields.PressureFields","page":"Library","title":"Oceananigans.Fields.PressureFields","text":"PressureFields(grid, bcs::NamedTuple)\n\nReturn a NamedTuple with pressure fields pHYâ€² and pNHS initialized as CenterFields on grid.  Boundary conditions bcs may be specified via a named tuple of FieldBoundaryConditions.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.Fields.PressureFields-Tuple{NamedTuple{(:pHYâ€², :pNHS)}, Any, Any}","page":"Library","title":"Oceananigans.Fields.PressureFields","text":"PressureFields(proposed_pressures::NamedTuple{(:pHYâ€², :pNHS)}, grid, bcs)\n\nReturn a NamedTuple of pressure fields with, overwriting boundary conditions in proposed_tracer_fields with corresponding fields in the NamedTuple bcs.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.TendencyFields-Tuple{Any, Any}","page":"Library","title":"Oceananigans.Fields.TendencyFields","text":"TendencyFields(grid, tracer_names;\n               u = XFaceField(grid),\n               v = YFaceField(grid),\n               w = ZFaceField(grid),\n               kwargs...)\n\nReturn a NamedTuple with tendencies for all solution fields (velocity fields and tracer fields), initialized on grid. Optional kwargs can be specified to assign data arrays to each tendency field.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.TracerFields-Tuple{Any, Any, Any}","page":"Library","title":"Oceananigans.Fields.TracerFields","text":"TracerFields(tracer_names, grid, user_bcs)\n\nReturn a NamedTuple with tracer fields specified by tracer_names initialized as CenterFields on grid. Boundary conditions user_bcs may be specified via a named tuple of FieldBoundaryConditions.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.TracerFields-Tuple{Any, Any}","page":"Library","title":"Oceananigans.Fields.TracerFields","text":"TracerFields(tracer_names, grid; kwargs...)\n\nReturn a NamedTuple with tracer fields specified by tracer_names initialized as CenterFields on grid. Fields may be passed via optional keyword arguments kwargs for each field.\n\nThis function is used by OutputWriters.Checkpointer and TendencyFields. ```\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.TracerFields-Tuple{NamedTuple, Any, Any}","page":"Library","title":"Oceananigans.Fields.TracerFields","text":"TracerFields(proposed_tracers::NamedTuple, grid, bcs)\n\nReturn a NamedTuple of tracers, overwriting boundary conditions in proposed_tracers with corresponding fields in the NamedTuple bcs.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.TracerFields-Tuple{NamedTuple{(), Tuple{}}, Any, Any}","page":"Library","title":"Oceananigans.Fields.TracerFields","text":"Shortcut constructor for empty tracer fields.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.VelocityFields","page":"Library","title":"Oceananigans.Fields.VelocityFields","text":"VelocityFields(grid, user_bcs = NamedTuple())\n\nReturn a NamedTuple with fields u, v, w initialized on grid. Boundary conditions bcs may be specified via a named tuple of FieldBoundaryConditions.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.Fields.VelocityFields-Tuple{NamedTuple{(:u, :v, :w)}, Any, Any}","page":"Library","title":"Oceananigans.Fields.VelocityFields","text":"VelocityFields(proposed_velocities::NamedTuple{(:u, :v, :w)}, grid, bcs)\n\nReturn a NamedTuple of velocity fields, overwriting boundary conditions in proposed_velocities with corresponding fields in the NamedTuple bcs.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.XFaceField","page":"Library","title":"Oceananigans.Fields.XFaceField","text":"XFaceField(grid; kw...)\n\nReturn a Field{Face, Center, Center} on grid. Additional keyword arguments are passed to the Field constructor.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.Fields.YFaceField","page":"Library","title":"Oceananigans.Fields.YFaceField","text":"YFaceField(grid; kw...)\n\nReturn a Field{Center, Face, Center} on grid. Additional keyword arguments are passed to the Field constructor.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.Fields.ZFaceField","page":"Library","title":"Oceananigans.Fields.ZFaceField","text":"ZFaceField(grid; kw...)\n\nReturn a Field{Center, Center, Face} on grid. Additional keyword arguments are passed to the Field constructor.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.Fields.compute!","page":"Library","title":"Oceananigans.Fields.compute!","text":"compute!(field)\n\nComputes field.data from field.operand.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.Fields.field-Tuple{Any, AbstractArray, Any}","page":"Library","title":"Oceananigans.Fields.field","text":"field(loc, a, grid)\n\nBuild a field from a at loc and on grid.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.interior-Tuple{Field}","page":"Library","title":"Oceananigans.Fields.interior","text":"interior(f::Field)\n\nReturns a view of f that excludes halo points.\"\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.interpolate-NTuple{4, Any}","page":"Library","title":"Oceananigans.Fields.interpolate","text":"interpolate(field, x, y, z)\n\nInterpolate field to the physical point (x, y, z) using trilinear interpolation.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.regrid!-Tuple{Any, Any}","page":"Library","title":"Oceananigans.Fields.regrid!","text":"regrid!(a, b)\n\nRegrid field b onto the grid of field a. \n\nExample\n\nGenerate a tracer field on a vertically stretched grid and regrid it on a regular grid.\n\nusing Oceananigans\n\nNz, Lz = 2, 1.0\ntopology = (Flat, Flat, Bounded)\n\ninput_grid = RectilinearGrid(size=Nz, z = [0, Lz/3, Lz], topology=topology, halo=1)\ninput_field = CenterField(input_grid)\ninput_field[1, 1, 1:Nz] = [2, 3]\n\noutput_grid = RectilinearGrid(size=Nz, z=(0, Lz), topology=topology, halo=1)\noutput_field = CenterField(output_grid)\n\nregrid!(output_field, input_field)\n\noutput_field[1, 1, :]\n\n# output\n4-element OffsetArray(::Vector{Float64}, 0:3) with eltype Float64 with indices 0:3:\n 0.0\n 2.333333333333333\n 3.0\n 0.0\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.location-Tuple{Any}","page":"Library","title":"Oceananigans.location","text":"Returns the location (LX, LY, LZ) of an AbstractField{LX, LY, LZ}.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.@compute-Tuple{Any}","page":"Library","title":"Oceananigans.Fields.@compute","text":"@compute(exprs...)\n\nCall compute! on fields after defining them.\n\n\n\n\n\n","category":"macro"},{"location":"appendix/library/#Forcings","page":"Library","title":"Forcings","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Forcings]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.Forcings.AdvectiveForcing","page":"Library","title":"Oceananigans.Forcings.AdvectiveForcing","text":"AdvectiveForcing(scheme=UpwindBiasedFifthOrder(), u=ZeroField(), v=ZeroField(), w=ZeroField())\n\nBuild a forcing term representing advection by the velocity field u, v, w with an advection scheme.\n\nExample\n\nUsing a tracer field to model sinking particles\n\nusing Oceananigans\n\n# Physical parameters\ngravitational_acceleration          = 9.81     # m sâ»Â²\nocean_density                       = 1026     # kg mâ»Â³\nmean_particle_density               = 2000     # kg mâ»Â³\nmean_particle_radius                = 1e-3     # m\nocean_molecular_kinematic_viscosity = 1.05e-6  # mÂ² sâ»Â¹\n\n# Terminal velocity of a sphere in viscous flow\nÎ”b = gravitational_acceleration * (mean_particle_density - ocean_density) / ocean_density\nÎ½ = ocean_molecular_kinematic_viscosity\nR = mean_particle_radius\n\nw_Stokes = - 2/9 * Î”b / Î½ * R^2 # m sâ»Â¹\n\nsettling = AdvectiveForcing(UpwindBiasedFifthOrder(), w=w_Stokes)\n\n# output\nAdvectiveForcing with the UpwindBiased scheme:\nâ”œâ”€â”€ u: ZeroField{Int64}\nâ”œâ”€â”€ v: ZeroField{Int64}\nâ””â”€â”€ w: ConstantField(-1.97096)\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Forcings.ContinuousForcing","page":"Library","title":"Oceananigans.Forcings.ContinuousForcing","text":"ContinuousForcing{LX, LY, LZ, P, F, D, I, â„‘}\n\nA callable object that implements a \"continuous form\" forcing function on a field at the location LX, LY, LZ with optional parameters.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Forcings.ContinuousForcing-Tuple{Any}","page":"Library","title":"Oceananigans.Forcings.ContinuousForcing","text":"ContinuousForcing(func; parameters=nothing, field_dependencies=())\n\nConstruct a \"continuous form\" forcing with optional parameters and optional field_dependencies on other fields in a model.\n\nIf neither parameters nor field_dependencies are provided, then func must be callable with the signature\n\nfunc(x, y, z, t)\n\nwhere x, y, z are the east-west, north-south, and vertical spatial coordinates, and t is time.\n\nIf field_dependencies are provided, the signature of func must include them. For example, if field_dependencies=(:u, :S) (and parameters are not provided), then func must be callable with the signature\n\nfunc(x, y, z, t, u, S)\n\nwhere u is assumed to be the u-velocity component, and S is a tracer. Note that any field which does not have the name u, v, or w is assumed to be a tracer and must be present in model.tracers.\n\nIf parameters are provided, then the last argument to func must be parameters. For example, if func has no field_dependencies but does depend on parameters, then it must be callable with the signature\n\nfunc(x, y, z, t, parameters)\n\nWith field_dependencies=(:u, :v, :w, :c) and parameters, then func must be callable with the signature\n\nfunc(x, y, z, t, u, v, w, c, parameters)\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Forcings.DiscreteForcing","page":"Library","title":"Oceananigans.Forcings.DiscreteForcing","text":"struct DiscreteForcing{P, F}\n\nWrapper for \"discrete form\" forcing functions with optional parameters.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Forcings.DiscreteForcing-Tuple{Any}","page":"Library","title":"Oceananigans.Forcings.DiscreteForcing","text":"DiscreteForcing(func; parameters=nothing)\n\nConstruct a \"discrete form\" forcing function with optional parameters. The forcing function is applied at grid point i, j, k.\n\nWhen parameters are not specified, func must be callable with the signature\n\nfunc(i, j, k, grid, clock, model_fields)\n\nwhere grid is model.grid, clock.time is the current simulation time and clock.iteration is the current model iteration, and model_fields is a NamedTuple with u, v, w and the fields in model.tracers.\n\nNote that the index end does not access the final physical grid point of a model field in any direction. The final grid point must be explicitly specified, as in model_fields.u[i, j, grid.Nz].\n\nWhen parameters is specified, func must be callable with the signature.\n\nfunc(i, j, k, grid, clock, model_fields, parameters)\n\nAbove, parameters is, in principle, arbitrary. Note, however, that GPU compilation can place constraints on typeof(parameters).\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Forcings.GaussianMask","page":"Library","title":"Oceananigans.Forcings.GaussianMask","text":"GaussianMask{D}(center, width)\n\nCallable object that returns a Gaussian masking function centered on center, with width, and varying along direction D, i.e.,\n\nexp(-(D - center)^2 / (2 * width^2))\n\nExamples\n\nCreate a Gaussian mask centered on z=0 with width 1 meter.\n\njulia> mask = GaussianMask{:z}(center=0, width=1)\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Forcings.LinearTarget","page":"Library","title":"Oceananigans.Forcings.LinearTarget","text":"LinearTarget{D}(intercept, gradient)\n\nCallable object that returns a Linear target function with intercept and gradient, and varying along direction D, i.e.,\n\nintercept + D * gradient\n\nExamples\n\nCreate a linear target function varying in z, equal to 0 at z=0 and with gradient 10â»â¶:\njulia> target = LinearTarget{:z}(intercept=0, gradient=1e-6)\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Forcings.Relaxation","page":"Library","title":"Oceananigans.Forcings.Relaxation","text":"struct Relaxation{R, M, T}\n\nCallable object for restoring fields to a target at some rate and within a masked region in x, y, z.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Forcings.Relaxation-Tuple{}","page":"Library","title":"Oceananigans.Forcings.Relaxation","text":"Relaxation(; rate, mask=onefunction, target=zerofunction)\n\nReturns a Forcing that restores a field to target(x, y, z, t) at the specified rate, in the region mask(x, y, z).\n\nThe functions onefunction and zerofunction always return 1 and 0, respectively. Thus the default mask leaves the whole domain uncovered, and the default target is zero.\n\nExample\n\nRestore a field to zero on a timescale of \"3600\" (equal to one hour if the time units of the simulation are seconds).\n\nusing Oceananigans\n\ndamping = Relaxation(rate = 1/3600)\n\n# output\nRelaxation{Float64, typeof(Oceananigans.Forcings.onefunction), typeof(Oceananigans.Forcings.zerofunction)}\nâ”œâ”€â”€ rate: 0.0002777777777777778\nâ”œâ”€â”€ mask: 1\nâ””â”€â”€ target: 0\n\nRestore a field to a linear z-gradient within the bottom 1/4 of a domain on a timescale of \"60\" (equal to one minute if the time units of the simulation are seconds).\n\ndTdz = 0.001 # â°C mâ»Â¹, temperature gradient\n\nTâ‚€ = 20 # â°C, surface temperature at z=0\n\nLz = 100 # m, depth of domain\n\nbottom_sponge_layer = Relaxation(; rate = 1/60,\n                                   target = LinearTarget{:z}(intercept=Tâ‚€, gradient=dTdz),\n                                   mask = GaussianMask{:z}(center=-Lz, width=Lz/4))\n\n# output\nRelaxation{Float64, GaussianMask{:z, Float64}, LinearTarget{:z, Float64}}\nâ”œâ”€â”€ rate: 0.016666666666666666\nâ”œâ”€â”€ mask: exp(-(z + 100.0)^2 / (2 * 25.0^2))\nâ””â”€â”€ target: 20.0 + 0.001 * z\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Forcings.Forcing-Tuple{Any}","page":"Library","title":"Oceananigans.Forcings.Forcing","text":"Forcing(func; parameters=nothing, field_dependencies=(), discrete_form=false)\n\nReturns a forcing function added to the tendency of an Oceananigans model field.\n\nIf discrete_form=false (the default), and neither parameters nor field_dependencies are provided, then func must be callable with the signature\n\nfunc(x, y, z, t)\n\nwhere x, y, z are the east-west, north-south, and vertical spatial coordinates, and t is time. Note that this form is also default in the constructor for NonhydrostaticModel, so that Forcing is not needed.\n\nIf discrete_form=false (the default), and field_dependencies are provided, the signature of func must include them. For example, if field_dependencies=(:u, :S) (and parameters are not provided), then func must be callable with the signature\n\nfunc(x, y, z, t, u, S)`\n\nwhere u is assumed to be the u-velocity component, and S is a tracer. Note that any field which does not have the name u, v, or w is assumed to be a tracer and must be present in model.tracers.\n\nIf discrete_form=false (the default) and parameters are provided, then the last argument to func must be parameters. For example, if func has no field_dependencies but does depend on parameters, then it must be callable with the signature\n\nfunc(x, y, z, t, parameters)\n\nThe object parameters is arbitrary in principle, however GPU compilation can place constraints on typeof(parameters).\n\nWith field_dependencies=(:u, :v, :w, :c) and parameters, then func must be callable with the signature\n\nfunc(x, y, z, t, u, v, w, c, parameters)\n\nIf discrete_form=true then func must be callable with the \"discrete form\"\n\nfunc(i, j, k, grid, clock, model_fields)\n\nwhere i, j, k is the grid point at which the forcing is applied, grid is model.grid, clock.time is the current simulation time and clock.iteration is the current model iteration, and model_fields is a NamedTuple with u, v, w, the fields in model.tracers, and the fields in model.diffusivity_fields, each of which is an OffsetArrays (or NamedTuples of OffsetArrays depending on the turbulence closure) of field data.\n\nWhen discrete_form=true and parameters is specified, func must be callable with the signature\n\nfunc(i, j, k, grid, clock, model_fields, parameters)\n\nExamples\n\nusing Oceananigans\n\n# Parameterized forcing\nparameterized_func(x, y, z, t, p) = p.Î¼ * exp(z / p.Î») * cos(p.Ï‰ * t)\n\nv_forcing = Forcing(parameterized_func, parameters = (Î¼=42, Î»=0.1, Ï‰=Ï€))\n\n# output\nContinuousForcing{NamedTuple{(:Î¼, :Î», :Ï‰), Tuple{Int64, Float64, Irrational{:Ï€}}}}\nâ”œâ”€â”€ func: parameterized_func (generic function with 1 method)\nâ”œâ”€â”€ parameters: (Î¼ = 42, Î» = 0.1, Ï‰ = Ï€)\nâ””â”€â”€ field dependencies: ()\n\nNote that because forcing locations are regularized within the NonhydrostaticModel constructor:\n\ngrid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))\nmodel = NonhydrostaticModel(grid=grid, forcing=(v=v_forcing,))\n\nmodel.forcing.v\n\n# output\nContinuousForcing{NamedTuple{(:Î¼, :Î», :Ï‰), Tuple{Int64, Float64, Irrational{:Ï€}}}} at (Center, Face, Center)\nâ”œâ”€â”€ func: parameterized_func (generic function with 1 method)\nâ”œâ”€â”€ parameters: (Î¼ = 42, Î» = 0.1, Ï‰ = Ï€)\nâ””â”€â”€ field dependencies: ()\n\nAfter passing through the constructor for NonhydrostaticModel, the v-forcing location information is available and set to Center, Face, Center.\n\n# Field-dependent forcing\ngrowth_in_sunlight(x, y, z, t, P) = exp(z) * P\n\nplankton_forcing = Forcing(growth_in_sunlight, field_dependencies=:P)\n\n# output\nContinuousForcing{Nothing}\nâ”œâ”€â”€ func: growth_in_sunlight (generic function with 1 method)\nâ”œâ”€â”€ parameters: nothing\nâ””â”€â”€ field dependencies: (:P,)\n\n# Parameterized, field-dependent forcing\ntracer_relaxation(x, y, z, t, c, p) = p.Î¼ * exp((z + p.H) / p.Î») * (p.dCdz * z - c) \n\nc_forcing = Forcing(tracer_relaxation,\n                    field_dependencies = :c,\n                            parameters = (Î¼=1/60, Î»=10, H=1000, dCdz=1))\n\n# output\nContinuousForcing{NamedTuple{(:Î¼, :Î», :H, :dCdz), Tuple{Float64, Int64, Int64, Int64}}}\nâ”œâ”€â”€ func: tracer_relaxation (generic function with 1 method)\nâ”œâ”€â”€ parameters: (Î¼ = 0.016666666666666666, Î» = 10, H = 1000, dCdz = 1)\nâ””â”€â”€ field dependencies: (:c,)\n\n# Unparameterized discrete-form forcing function\nfiltered_relaxation(i, j, k, grid, clock, model_fields) =\n    @inbounds - (model_fields.c[i-1, j, k] + model_fields.c[i, j, k] + model_fields.c[i+1, j, k]) / 3\n\nfiltered_forcing = Forcing(filtered_relaxation, discrete_form=true)\n\n# output\nDiscreteForcing{Nothing}\nâ”œâ”€â”€ func: filtered_relaxation (generic function with 1 method)\nâ””â”€â”€ parameters: nothing\n\n# Discrete-form forcing function with parameters\nmasked_damping(i, j, k, grid, clock, model_fields, parameters) = \n    @inbounds - parameters.Î¼ * exp(grid.záµƒáµƒá¶œ[k] / parameters.Î») * model_fields.u[i, j, k]\n\nmasked_damping_forcing = Forcing(masked_damping, parameters=(Î¼=42, Î»=Ï€), discrete_form=true)\n\n# output\nDiscreteForcing{NamedTuple{(:Î¼, :Î»), Tuple{Int64, Irrational{:Ï€}}}}\nâ”œâ”€â”€ func: masked_damping (generic function with 1 method)\nâ””â”€â”€ parameters: (Î¼ = 42, Î» = Ï€)\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Grids","page":"Library","title":"Grids","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Grids]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.Grids.AbstractCurvilinearGrid","page":"Library","title":"Oceananigans.Grids.AbstractCurvilinearGrid","text":"AbstractCurvilinearGrid{FT, TX, TY, TZ}\n\nAbstract supertype for curvilinear grids with elements of type FT and topology {TX, TY, TZ}.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.AbstractGrid","page":"Library","title":"Oceananigans.Grids.AbstractGrid","text":"AbstractGrid{FT, TX, TY, TZ}\n\nAbstract supertype for grids with elements of type FT and topology {TX, TY, TZ}.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.AbstractHorizontallyCurvilinearGrid","page":"Library","title":"Oceananigans.Grids.AbstractHorizontallyCurvilinearGrid","text":"AbstractHorizontallyCurvilinearGrid{FT, TX, TY, TZ}\n\nAbstract supertype for horizontally-curvilinear grids with elements of type FT and topology {TX, TY, TZ}.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.AbstractRectilinearGrid","page":"Library","title":"Oceananigans.Grids.AbstractRectilinearGrid","text":"AbstractRectilinearGrid{FT, TX, TY, TZ}\n\nAbstract supertype for rectilinear grids with elements of type FT and topology {TX, TY, TZ}.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.AbstractTopology","page":"Library","title":"Oceananigans.Grids.AbstractTopology","text":"AbstractTopology\n\nAbstract supertype for grid topologies.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.AbstractUnderlyingGrid","page":"Library","title":"Oceananigans.Grids.AbstractUnderlyingGrid","text":"AbstractUnderlyingGrid{FT, TX, TY, TZ}\n\nAbstract supertype for \"primary\" grids (as opposed to grids with immersed boundaries) with elements of type FT and topology {TX, TY, TZ}.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.Bounded","page":"Library","title":"Oceananigans.Grids.Bounded","text":"Bounded\n\nGrid topology for bounded dimensions, e.g., wall-bounded dimensions.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.Center","page":"Library","title":"Oceananigans.Grids.Center","text":"Center\n\nA type describing the location at the center of a grid cell.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.Face","page":"Library","title":"Oceananigans.Grids.Face","text":"Face\n\nA type describing the location at the face of a grid cell.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.Flat","page":"Library","title":"Oceananigans.Grids.Flat","text":"Flat\n\nGrid topology for flat dimensions, generally with one grid point, along which the solution is uniform and does not vary.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.FullyConnected","page":"Library","title":"Oceananigans.Grids.FullyConnected","text":"FullyConnected\n\nGrid topology for dimensions that are connected to other models or domains.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.LatitudeLongitudeGrid","page":"Library","title":"Oceananigans.Grids.LatitudeLongitudeGrid","text":"LatitudeLongitudeGrid([architecture = CPU(), FT = Float64];\n                      size,\n                      longitude,\n                      latitude,\n                      z = nothing,\n                      radius = R_Earth,\n                      topology = nothing,\n                      precompute_metrics = true,\n                      halo = nothing)\n\nCreates a LatitudeLongitudeGrid with coordinates (Î», Ï†, z) denoting longitude, latitude, and vertical coordinate respectively.\n\nPositional arguments\n\narchitecture: Specifies whether arrays of coordinates and spacings are stored                 on the CPU or GPU. Default: CPU().\nFT : Floating point data type. Default: Float64.\n\nKeyword arguments\n\nsize (required): A 3-tuple prescribing the number of grid points each direction.\nlongitude (required), latitude (required), z (default: nothing): Each is either a:\n2-tuple that specify the end points of the domain,\none-dimensional array specifying the cell interface locations, or\na single-argument function that takes an index and returns cell interface location.\nNote: the latitude and longitude coordinates extents are expected in degrees.\nradius: The radius of the sphere the grid lives on. By default is equal to the radius of Earth.\ntopology: Tuple of topologies (Flat, Bounded, Periodic) for each direction. The vertical              topology[3] must be Bounded, while the latitude-longitude topologies can be             Bounded, Periodic, or Flat. If no topology is provided then, by default, the             topology is (Periodic, Bounded, Bounded) if the latitudinal extent is 360 degrees             or (Bounded, Bounded, Bounded) otherwise.\nprecompute_metrics: Boolean specifying whether to precompute horizontal spacings and areas.                       Default: true. When false, horizontal spacings and areas are computed                       on-the-fly during a simulation.\nhalo: A 3-tuple of integers specifying the size of the halo region of cells surrounding         the physical interior. The default is 3 halo cells in every direction.\n\nExamples\n\nA default grid with Float64 type:\n\njulia> using Oceananigans\n\njulia> grid = LatitudeLongitudeGrid(size=(36, 34, 25),\n                                    longitude = (-180, 180),\n                                    latitude = (-85, 85),\n                                    z = (-1000, 0))\n36Ã—34Ã—25 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3Ã—3Ã—3 halo and with precomputed metrics\nâ”œâ”€â”€ longitude: Periodic Î» âˆˆ [-180.0, 180.0) regularly spaced with Î”Î»=10.0\nâ”œâ”€â”€ latitude:  Bounded  Ï† âˆˆ [-85.0, 85.0]   regularly spaced with Î”Ï†=5.0\nâ””â”€â”€ z:         Bounded  z âˆˆ [-1000.0, 0.0]  regularly spaced with Î”z=40.0\n\nA bounded spherical sector with cell interfaces stretched hyperbolically near the top:\n\njulia> using Oceananigans\n\njulia> Ïƒ = 1.1; # stretching factor\n\njulia> Nz = 24; # vertical resolution\n\njulia> Lz = 1000; # depth (m)\n\njulia> hyperbolically_spaced_faces(k) = - Lz * (1 - tanh(Ïƒ * (k - 1) / Nz) / tanh(Ïƒ));\n\njulia> grid = LatitudeLongitudeGrid(size=(36, 34, Nz),\n                                    longitude = (-180, 180),\n                                    latitude = (-20, 20),\n                                    z = hyperbolically_spaced_faces,\n                                    topology = (Bounded, Bounded, Bounded))\n36Ã—34Ã—24 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3Ã—3Ã—3 halo and with precomputed metrics\nâ”œâ”€â”€ longitude: Bounded  Î» âˆˆ [-180.0, 180.0] regularly spaced with Î”Î»=10.0\nâ”œâ”€â”€ latitude:  Bounded  Ï† âˆˆ [-20.0, 20.0]   regularly spaced with Î”Ï†=1.17647\nâ””â”€â”€ z:         Bounded  z âˆˆ [-1000.0, -0.0] variably spaced with min(Î”z)=21.3342, max(Î”z)=57.2159\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.LeftConnected","page":"Library","title":"Oceananigans.Grids.LeftConnected","text":"LeftConnected\n\nGrid topology for dimensions that are connected to other models or domains only on the left (the other direction is bounded)\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.OrthogonalSphericalShellGrid","page":"Library","title":"Oceananigans.Grids.OrthogonalSphericalShellGrid","text":"OrthogonalSphericalShellGrid(architecture::AbstractArchitecture = CPU(),\n                             FT::DataType = Float64;\n                             size,\n                             z,\n                             topology = (Bounded, Bounded, Bounded),\n                             Î¾ = (-1, 1),\n                             Î· = (-1, 1),\n                             radius = R_Earth,\n                             halo = (1, 1, 1),\n                             rotation = nothing)\n\nCreate a OrthogonalSphericalShellGrid that represents a section of a sphere after it has been  mapped from the face of a cube. The cube's coordinates are Î¾ and Î· (which, by default, take values in the range -1 1.\n\nThe mapping from the face of the cube to the sphere is done via the CubedSphere.jl package.\n\nPositional arguments\n\narchitecture: Specifies whether arrays of coordinates and spacings are stored                 on the CPU or GPU. Default: CPU().\nFT : Floating point data type. Default: Float64.\n\nKeyword arguments\n\nsize (required): A 3-tuple prescribing the number of grid points each direction.\nz (required): Either a\n2-tuple that specify the end points of the z-domain,\none-dimensional array specifying the cell interface locations, or\na single-argument function that takes an index and returns cell interface location.\nradius: The radius of the sphere the grid lives on. By default is equal to the radius of Earth.\nhalo: A 3-tuple of integers specifying the size of the halo region of cells surrounding         the physical interior. The default is 1 halo cells in every direction.\nrotation: Rotation of the spherical shell grid about some axis that passes through the center             of the sphere. If nothing is provided (default), then the spherical shell includes             the North Pole of the sphere in its center.\n\nExamples\n\nA default grid with Float64 type:\n\njulia> using Oceananigans\n\njulia> grid = OrthogonalSphericalShellGrid(size=(36, 34, 25), z=(-1000, 0))\n36Ã—34Ã—25 OrthogonalSphericalShellGrid{Float64, Bounded, Bounded, Bounded} on CPU with 1Ã—1Ã—1 halo and with precomputed metrics\nâ”œâ”€â”€ longitude: Bounded  Î» âˆˆ [-176.397, 180.0] variably spaced with min(Î”Î»)=48351.7, max(Î”Î»)=2.87833e5\nâ”œâ”€â”€ latitude:  Bounded  Ï† âˆˆ [35.2644, 90.0]   variably spaced with min(Î”Ï†)=50632.2, max(Î”Ï†)=3.04768e5\nâ””â”€â”€ z:         Bounded  z âˆˆ [-1000.0, 0.0]    regularly spaced with Î”z=40.0\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.Periodic","page":"Library","title":"Oceananigans.Grids.Periodic","text":"Periodic\n\nGrid topology for periodic dimensions.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.RectilinearGrid","page":"Library","title":"Oceananigans.Grids.RectilinearGrid","text":"RectilinearGrid([architecture = CPU(), FT = Float64];\n                size,\n                x = nothing,\n                y = nothing,\n                z = nothing,\n                halo = nothing,\n                extent = nothing,\n                topology = (Periodic, Periodic, Bounded))\n\nCreate a RectilinearGrid with size = (Nx, Ny, Nz) grid points.\n\nPositional arguments\n\narchitecture: Specifies whether arrays of coordinates and spacings are stored                 on the CPU or GPU. Default: CPU().\nFT : Floating point data type. Default: Float64.\n\nKeyword arguments\n\nsize (required): A tuple prescribing the number of grid points in non-Flat directions.                    size is a 3-tuple for 3D models, a 2-tuple for 2D models, and either a                    scalar or 1-tuple for 1D models.\ntopology: A 3-tuple (TX, TY, TZ) specifying the topology of the domain.             TX, TY, and TZ specify whether the x-, y-, and z directions are             Periodic, Bounded, or Flat. The topology Flat indicates that a model does             not vary in those directions so that derivatives and interpolation are zero.             The default is topology = (Periodic, Periodic, Bounded).\nextent: A tuple prescribing the physical extent of the grid in non-Flat directions, e.g.,           (Lx, Ly, Lz). All directions are contructed with regular grid spacing and the domain           (in the case that no direction is Flat) is 0  x  L_x, 0  y  L_y, and           -L_z  z  0, which is most appropriate for oceanic applications in which z = 0           usually is the ocean's surface.\nx, y, and z: Each of x, y, z are either (i) 2-tuples that specify the end points of the domain                    in their respect directions (in which case scalar values may be used in Flat                    directions), or (ii) arrays or functions of the corresponding indices i, j, or k                    that specify the locations of cell faces in the x-, y-, or z-direction, respectively.                    For example, to prescribe the cell faces in z we need to provide a function that takes                    k as argument and retuns the location of the faces for indices k = 1 through k = Nz + 1,                    where Nz is the size of the stretched z dimension.\n\nNote: Either extent, or all of x, y, and z must be specified.\n\nhalo: A tuple of integers that specifies the size of the halo region of cells surrounding         the physical interior for each non-Flat direction. The default is 3 halo cells in every direction.\n\nThe physical extent of the domain can be specified either via x, y, and z keyword arguments indicating the left and right endpoints of each dimensions, e.g., x = (-Ï€, Ï€) or via the extent argument, e.g., extent = (Lx, Ly, Lz), which specifies the extent of each dimension in which case 0  x  L_x, 0  y  L_y, and -L_z  z  0.\n\nA grid topology may be specified via a tuple assigning one of Periodic, Bounded, and, Flat to each dimension. By default, a horizontally periodic grid topology (Periodic, Periodic, Bounded) is assumed.\n\nConstants are stored using floating point values of type FT. By default this is Float64. Make sure to specify the desired FT if not using Float64.\n\nGrid properties\n\n(Nx, Ny, Nz) :: Int: Number of physical points in the (x y z)-direction.\n(Hx, Hy, Hz) :: Int: Number of halo points in the (x y z)-direction.\n(Lx, Ly, Lz) :: FT: Physical extent of the grid in the (x y z)-direction.\n(Î”xá¶œáµƒáµƒ, Î”yáµƒá¶œáµƒ, Î”záµƒáµƒá¶œ): Grid spacing in the (x y z)-direction between cell centers.                          Defined at cell centers in x, y, and z.\n(Î”xá¶ áµƒáµƒ, Î”yáµƒá¶ áµƒ, Î”záµƒáµƒá¶ ): Grid spacing in the (x y z)-direction between cell faces.                          Defined at cell faces in x, y, and z.\n(xá¶œáµƒáµƒ, yáµƒá¶œáµƒ, záµƒáµƒá¶œ): (x y z) coordinates of cell centers.\n(xá¶ áµƒáµƒ, yáµƒá¶ áµƒ, záµƒáµƒá¶ ): (x y z) coordinates of cell faces.\n\nExamples\n\nA grid with the default Float64 type:\n\njulia> using Oceananigans\n\njulia> grid = RectilinearGrid(size=(32, 32, 32), extent=(1, 2, 3))\n32Ã—32Ã—32 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ Periodic x âˆˆ [0.0, 1.0)  regularly spaced with Î”x=0.03125\nâ”œâ”€â”€ Periodic y âˆˆ [0.0, 2.0)  regularly spaced with Î”y=0.0625\nâ””â”€â”€ Bounded  z âˆˆ [-3.0, 0.0] regularly spaced with Î”z=0.09375\n\nA grid with Float32 type:\n\njulia> using Oceananigans\n\njulia> grid = RectilinearGrid(Float32; size=(32, 32, 16), x=(0, 8), y=(-10, 10), z=(-Ï€, Ï€))\n32Ã—32Ã—16 RectilinearGrid{Float32, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ Periodic x âˆˆ [0.0, 8.0)          regularly spaced with Î”x=0.25\nâ”œâ”€â”€ Periodic y âˆˆ [-10.0, 10.0)       regularly spaced with Î”y=0.625\nâ””â”€â”€ Bounded  z âˆˆ [-3.14159, 3.14159] regularly spaced with Î”z=0.392699\n\nA two-dimenisional, horizontally-periodic grid:\n\njulia> using Oceananigans\n\njulia> grid = RectilinearGrid(size=(32, 32), extent=(2Ï€, 4Ï€), topology=(Periodic, Periodic, Flat))\n32Ã—32Ã—1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3Ã—3Ã—0 halo\nâ”œâ”€â”€ Periodic x âˆˆ [3.60072e-17, 6.28319) regularly spaced with Î”x=0.19635\nâ”œâ”€â”€ Periodic y âˆˆ [7.20145e-17, 12.5664) regularly spaced with Î”y=0.392699\nâ””â”€â”€ Flat z\n\nA one-dimensional \"column\" grid:\n\njulia> using Oceananigans\n\njulia> grid = RectilinearGrid(size=256, z=(-128, 0), topology=(Flat, Flat, Bounded))\n1Ã—1Ã—256 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0Ã—0Ã—3 halo\nâ”œâ”€â”€ Flat x\nâ”œâ”€â”€ Flat y\nâ””â”€â”€ Bounded  z âˆˆ [-128.0, 0.0]    regularly spaced with Î”z=0.5\n\nA horizontally-periodic regular grid with cell interfaces stretched hyperbolically near the top:\n\njulia> using Oceananigans\n\njulia> Ïƒ = 1.1; # stretching factor\n\njulia> Nz = 24; # vertical resolution\n\njulia> Lz = 32; # depth (m)\n\njulia> hyperbolically_spaced_faces(k) = - Lz * (1 - tanh(Ïƒ * (k - 1) / Nz) / tanh(Ïƒ));\n\njulia> grid = RectilinearGrid(size = (32, 32, Nz),\n                              x = (0, 64), y = (0, 64),\n                              z = hyperbolically_spaced_faces)\n32Ã—32Ã—24 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ Periodic x âˆˆ [0.0, 64.0)   regularly spaced with Î”x=2.0\nâ”œâ”€â”€ Periodic y âˆˆ [0.0, 64.0)   regularly spaced with Î”y=2.0\nâ””â”€â”€ Bounded  z âˆˆ [-32.0, -0.0] variably spaced with min(Î”z)=0.682695, max(Î”z)=1.83091\n\nA three-dimensional grid with regular spacing in x, cell interfaces at Chebyshev nodes in y, and cell interfaces hyperbolically stretched in z near the top:\n\njulia> using Oceananigans\n\njulia> Nx, Ny, Nz = 32, 30, 24;\n\njulia> Lx, Ly, Lz = 200, 100, 32; # (m)\n\njulia> chebychev_nodes(j) = - Ly/2 * cos(Ï€ * (j - 1) / Ny);\n\njulia> Ïƒ = 1.1; # stretching factor\n\njulia> hyperbolically_spaced_faces(k) = - Lz * (1 - tanh(Ïƒ * (k - 1) / Nz) / tanh(Ïƒ));\n\njulia> grid = RectilinearGrid(size = (Nx, Ny, Nz),\n                              topology = (Periodic, Bounded, Bounded),\n                              x = (0, Lx),\n                              y = chebychev_nodes,\n                              z = hyperbolically_spaced_faces)\n32Ã—30Ã—24 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ Periodic x âˆˆ [0.0, 200.0)  regularly spaced with Î”x=6.25\nâ”œâ”€â”€ Bounded  y âˆˆ [-50.0, 50.0] variably spaced with min(Î”y)=0.273905, max(Î”y)=5.22642\nâ””â”€â”€ Bounded  z âˆˆ [-32.0, -0.0] variably spaced with min(Î”z)=0.682695, max(Î”z)=1.83091\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.RightConnected","page":"Library","title":"Oceananigans.Grids.RightConnected","text":"RightConnected\n\nGrid topology for dimensions that are connected to other models or domains only on the right (the other direction is bounded)\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.halo_size-Tuple{Any}","page":"Library","title":"Oceananigans.Grids.halo_size","text":"halo_size(grid)\n\nReturn a 3-tuple with the number of halo cells on either side of the domain in (x, y, z).\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.minimum_xspacing-NTuple{4, Any}","page":"Library","title":"Oceananigans.Grids.minimum_xspacing","text":"minimum_xspacing(grid, â„“x, â„“y, â„“z)\nminimum_xspacing(grid) = minimum_xspacing(grid, Center(), Center(), Center())\n\nReturn the minimum spacing for grid in x direction at location â„“x, â„“y, â„“z.\n\nExamples\n\njulia> using Oceananigans\n\njulia> grid = RectilinearGrid(size=(2, 4, 8), extent=(1, 1, 1));\n\njulia> minimum_xspacing(grid, Center(), Center(), Center())\n0.5\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.minimum_yspacing-NTuple{4, Any}","page":"Library","title":"Oceananigans.Grids.minimum_yspacing","text":"minimum_yspacing(grid, â„“x, â„“y, â„“z)\nminimum_yspacing(grid) = minimum_yspacing(grid, Center(), Center(), Center())\n\nReturn the minimum spacing for grid in y direction at location â„“x, â„“y, â„“z.\n\nExamples\n\njulia> using Oceananigans\n\njulia> grid = RectilinearGrid(size=(2, 4, 8), extent=(1, 1, 1));\n\njulia> minimum_yspacing(grid, Center(), Center(), Center())\n0.25\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.minimum_zspacing-NTuple{4, Any}","page":"Library","title":"Oceananigans.Grids.minimum_zspacing","text":"minimum_zspacing(grid, â„“x, â„“y, â„“z)\nminimum_zspacing(grid) = minimum_zspacing(grid, Center(), Center(), Center())\n\nReturn the minimum spacing for grid in z direction at location â„“x, â„“y, â„“z.\n\nExamples\n\njulia> using Oceananigans\n\njulia> grid = RectilinearGrid(size=(2, 4, 8), extent=(1, 1, 1));\n\njulia> minimum_zspacing(grid, Center(), Center(), Center())\n0.125\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.new_data","page":"Library","title":"Oceananigans.Grids.new_data","text":"new_data(FT, arch, loc, topo, sz, halo_sz, indices)\n\nReturns an OffsetArray of zeros of float type FT on architecture, with indices corresponding to a field on a grid of size(grid) and located at loc.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.Grids.nodes-Tuple{Oceananigans.Grids.AbstractGrid, Any}","page":"Library","title":"Oceananigans.Grids.nodes","text":"nodes(grid, (â„“x, â„“y, â„“z); reshape=false, with_halos=false)\nnodes(grid, â„“x, â„“y, â„“z; reshape=false, with_halos=false)\n\nReturn a 3-tuple of views over the interior nodes of the grid's native coordinates at the locations in loc=(â„“x, â„“y, â„“z) in x, y, z.\n\nIf reshape=true, the views are reshaped to 3D arrays with non-singleton dimensions 1, 2, 3 for x, y, z, respectively. These reshaped arrays can then be used in broadcast operations with 3D fields or arrays.\n\nFor RectilinearGrids the native coordinates are x, y, z; for curvilinear grids, like LatitudeLongitudeGrid or OrthogonalSphericalShellGrid the native coordinates are Î», Ï†, z.\n\nSee xnodes, ynodes, znodes, Î»nodes, and Ï†nodes.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.offset_data","page":"Library","title":"Oceananigans.Grids.offset_data","text":"offset_data(underlying_data, grid::AbstractGrid, loc)\n\nReturns an OffsetArray that maps to underlying_data in memory, with offset indices appropriate for the data of a field on a grid of size(grid) and located at loc.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.Grids.topology-Tuple{Any, Any}","page":"Library","title":"Oceananigans.Grids.topology","text":"topology(grid, dim)\n\nReturn the topology of the grid for the dim-th dimension.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.topology-Union{Tuple{Oceananigans.Grids.AbstractGrid{FT, TX, TY, TZ}}, Tuple{TZ}, Tuple{TY}, Tuple{TX}, Tuple{FT}} where {FT, TX, TY, TZ}","page":"Library","title":"Oceananigans.Grids.topology","text":"topology(grid)\n\nReturn a tuple with the topology of the grid for each dimension.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.total_size","page":"Library","title":"Oceananigans.Grids.total_size","text":"total_size(grid, loc)\n\nReturn the \"total\" size of a grid at loc. This is a 3-tuple of integers corresponding to the number of grid points along x, y, z.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.Grids.xnodes-NTuple{4, Any}","page":"Library","title":"Oceananigans.Grids.xnodes","text":"xnodes(grid, â„“x, â„“y, â„“z, with_halos=false)\n\nReturn the positions over the interior nodes on grid in the x-direction for the location â„“x, â„“y, â„“z. For Bounded directions, Face nodes include the boundary points.\n\nSee znodes for examples.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.xspacings-NTuple{4, Any}","page":"Library","title":"Oceananigans.Grids.xspacings","text":"xspacings(grid, â„“x, â„“y, â„“z; with_halos=true)\n\nReturn the spacings over the interior nodes on grid in the x-direction for the location â„“x, â„“y, â„“z. For Bounded directions, Face nodes include the boundary points.\n\njulia> using Oceananigans\n\njulia> grid = LatitudeLongitudeGrid(size=(8, 15, 10), longitude=(-20, 60), latitude=(-10, 50), z=(-100, 0));\n\njulia> xspacings(grid, Center(), Face(), Center())\n16-element view(OffsetArray(::Vector{Float64}, -2:18), 1:16) with eltype Float64:\n      1.0950562585518518e6\n      1.1058578920188267e6\n      1.1112718969963323e6\n      1.1112718969963323e6\n      1.1058578920188267e6\n      1.0950562585518518e6\n      1.0789196210678827e6\n      1.0575265956426917e6\n      1.0309814069457315e6\n 999413.38046802\n 962976.3124613502\n 921847.720658409\n 876227.979424229\n 826339.3435524226\n 772424.8654621692\n 714747.2110712599\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.ynodes-NTuple{4, Any}","page":"Library","title":"Oceananigans.Grids.ynodes","text":"ynodes(grid, â„“x, â„“y, â„“z, with_halos=false)\n\nReturn the positions over the interior nodes on grid in the y-direction for the location â„“x, â„“y, â„“z. For Bounded directions, Face nodes include the boundary points.\n\nSee znodes for examples.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.yspacings-NTuple{4, Any}","page":"Library","title":"Oceananigans.Grids.yspacings","text":"yspacings(grid, â„“x, â„“y, â„“z; with_halos=true)\n\nReturn the spacings over the interior nodes on grid in the y-direction for the location â„“x, â„“y, â„“z. For Bounded directions, Face nodes include the boundary points.\n\njulia> using Oceananigans\n\njulia> grid = LatitudeLongitudeGrid(size=(20, 15, 10), longitude=(0, 20), latitude=(-15, 15), z=(-100, 0));\n\njulia> yspacings(grid, Center(), Center(), Center())\n222389.85328911748\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.znodes-NTuple{4, Any}","page":"Library","title":"Oceananigans.Grids.znodes","text":"znodes(grid, â„“x, â„“y, â„“z; with_halos=false)\n\nReturn the positions over the interior nodes on grid in the z-direction for the location â„“x, â„“y, â„“z. For Bounded directions, Face nodes include the boundary points.\n\njulia> using Oceananigans\n\njulia> horz_periodic_grid = RectilinearGrid(size=(3, 3, 3), extent=(2Ï€, 2Ï€, 1), halo=(1, 1, 1),\n                                            topology=(Periodic, Periodic, Bounded));\n\njulia> zC = znodes(horz_periodic_grid, Center())\n3-element view(OffsetArray(::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, 0:4), 1:3) with eltype Float64:\n -0.8333333333333334\n -0.5\n -0.16666666666666666\n\njulia> zC = znodes(horz_periodic_grid, Center(), Center(), Center())\n3-element view(OffsetArray(::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, 0:4), 1:3) with eltype Float64:\n -0.8333333333333334\n -0.5\n -0.16666666666666666\n\njulia> zC = znodes(horz_periodic_grid, Center(), Center(), Center(), with_halos=true)\n-1.1666666666666667:0.3333333333333333:0.16666666666666666 with indices 0:4\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.zspacings-NTuple{4, Any}","page":"Library","title":"Oceananigans.Grids.zspacings","text":"zspacings(grid, â„“x, â„“y, â„“z; with_halos=true)\n\nReturn the spacings over the interior nodes on grid in the z-direction for the location â„“x, â„“y, â„“z. For Bounded directions, Face nodes include the boundary points.\n\njulia> using Oceananigans\n\njulia> grid = LatitudeLongitudeGrid(size=(20, 15, 10), longitude=(0, 20), latitude=(-15, 15), z=(-100, 0));\n\njulia> zspacings(grid, Center(), Center(), Center())\n10.0\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.Î»nodes-Tuple{Oceananigans.Grids.AbstractCurvilinearGrid, Any, Any, Any}","page":"Library","title":"Oceananigans.Grids.Î»nodes","text":"Î»nodes(grid::AbstractCurvilinearGrid, â„“x, â„“y, â„“z, with_halos=false)\n\nReturn the positions over the interior nodes on a curvilinear grid in the Î»-direction for the location â„“Î», â„“Ï†, â„“z. For Bounded directions, Face nodes include the boundary points.\n\nSee znodes for examples.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.Ï†nodes-Tuple{Oceananigans.Grids.AbstractCurvilinearGrid, Any, Any, Any}","page":"Library","title":"Oceananigans.Grids.Ï†nodes","text":"Ï†nodes(grid::AbstractCurvilinearGrid, â„“x, â„“y, â„“z, with_halos=false)\n\nReturn the positions over the interior nodes on a curvilinear grid in the Ï†-direction for the location â„“Î», â„“Ï†, â„“z. For Bounded directions, Face nodes include the boundary points.\n\nSee znodes for examples.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Immersed-boundaries","page":"Library","title":"Immersed boundaries","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.ImmersedBoundaries]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.ImmersedBoundaries.GridFittedBottom","page":"Library","title":"Oceananigans.ImmersedBoundaries.GridFittedBottom","text":"GridFittedBottom(bottom_height, [immersed_condition=CenterImmersedCondition()])\n\nReturn an immersed boundary with an irregular bottom fit to the underlying grid.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.ImmersedBoundaries.ImmersedBoundaryCondition-Tuple{}","page":"Library","title":"Oceananigans.ImmersedBoundaries.ImmersedBoundaryCondition","text":"ImmersedBoundaryCondition(; interfaces...)\n\nReturn an ImmersedBoundaryCondition with conditions on individual cell interfaces âˆˆ (west, east, south, north, bottom, top) between the fluid and immersed boundary.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.ImmersedBoundaries.ImmersedBoundaryGrid-Tuple{Any, Oceananigans.ImmersedBoundaries.AbstractGridFittedBottom}","page":"Library","title":"Oceananigans.ImmersedBoundaries.ImmersedBoundaryGrid","text":"ImmersedBoundaryGrid(grid, ib::GridFittedBottom)\n\nReturn a grid with GridFittedBottom immersed boundary.\n\nComputes ib.bottom_height and wraps in an array.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Lagrangian-particle-tracking","page":"Library","title":"Lagrangian particle tracking","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.LagrangianParticleTracking]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.LagrangianParticleTracking.LagrangianParticles-Tuple{StructArrays.StructArray}","page":"Library","title":"Oceananigans.LagrangianParticleTracking.LagrangianParticles","text":"LagrangianParticles(particles::StructArray; restitution=1.0, tracked_fields::NamedTuple=NamedTuple(), dynamics=no_dynamics)\n\nConstruct some LagrangianParticles that can be passed to a model. The particles should be a StructArray and can contain custom fields. The coefficient of restitution for particle-wall collisions is specified by restitution.\n\nA number of tracked_fields may be passed in as a NamedTuple of fields. Each particle will track the value of each field. Each tracked field must have a corresponding particle property. So if T is a tracked field, then T must also be a custom particle property.\n\ndynamics is a function of (lagrangian_particles, model, Î”t) that is called prior to advecting particles. parameters can be accessed inside the dynamics function.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.LagrangianParticleTracking.LagrangianParticles-Tuple{}","page":"Library","title":"Oceananigans.LagrangianParticleTracking.LagrangianParticles","text":"LagrangianParticles(; x, y, z, restitution=1.0, dynamics=no_dynamics, parameters=nothing)\n\nConstruct some LagrangianParticles that can be passed to a model. The particles will have initial locations x, y, and z. The coefficient of restitution for particle-wall collisions is specified by restitution.\n\ndynamics is a function of (lagrangian_particles, model, Î”t) that is called prior to advecting particles. parameters can be accessed inside the dynamics function.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Logger","page":"Library","title":"Logger","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Logger]\nPrivate = false\nPages   = [\"Logger.jl\"]","category":"page"},{"location":"appendix/library/#Oceananigans.Logger.OceananigansLogger","page":"Library","title":"Oceananigans.Logger.OceananigansLogger","text":"OceananigansLogger(stream::IO=stdout, level=Logging.Info; show_info_source=false)\n\nBased on Logging.SimpleLogger, it tries to log all messages in the following format:\n\n[yyyy/mm/dd HH:MM:SS.sss] log_level message [-@-> source_file:line_number]\n\nwhere the source of the message between the square brackets is included only if show_info_source=true or if the message is not an info level message.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Models","page":"Library","title":"Models","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Models]\nPrivate = false","category":"page"},{"location":"appendix/library/#Non-hydrostatic-models","page":"Library","title":"Non-hydrostatic models","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Models.NonhydrostaticModels]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.Models.NonhydrostaticModels.NonhydrostaticModel-Tuple{}","page":"Library","title":"Oceananigans.Models.NonhydrostaticModels.NonhydrostaticModel","text":"NonhydrostaticModel(;          grid,\n                              clock = Clock{eltype(grid)}(0, 0, 1),\n                          advection = CenteredSecondOrder(),\n                           buoyancy = nothing,\n                           coriolis = nothing,\n                       stokes_drift = nothing,\n                forcing::NamedTuple = NamedTuple(),\n                            closure = nothing,\n    boundary_conditions::NamedTuple = NamedTuple(),\n                            tracers = (),\n                        timestepper = :QuasiAdamsBashforth2,\n      background_fields::NamedTuple = NamedTuple(),\n      particles::ParticlesOrNothing = nothing,\n\nbiogeochemistry::AbstractBGCOrNothing = nothing,                              velocities = nothing,                               pressures = nothing,                      diffusivityfields = nothing,                         pressuresolver = nothing,                       immersedboundary = nothing,                        auxiliaryfields = NamedTuple())\n\nConstruct a model for a non-hydrostatic, incompressible fluid on grid, using the Boussinesq approximation when buoyancy != nothing. By default, all Bounded directions are rigid and impenetrable.\n\nKeyword arguments\n\ngrid: (required) The resolution and discrete geometry on which the model is solved. The         architecture (CPU/GPU) that the model is solved on is inferred from the architecture         of the grid. Note that the grid needs to be regularly spaced in the horizontal         dimensions, x and y.\nadvection: The scheme that advects velocities and tracers. See Oceananigans.Advection.\nbuoyancy: The buoyancy model. See Oceananigans.BuoyancyModels.\ncoriolis: Parameters for the background rotation rate of the model.\nstokes_drift: Parameters for Stokes drift fields associated with surface waves. Default: nothing.\nforcing: NamedTuple of user-defined forcing functions that contribute to solution tendencies.\nclosure: The turbulence closure for model. See Oceananigans.TurbulenceClosures.\nboundary_conditions: NamedTuple containing field boundary conditions.\ntracers: A tuple of symbols defining the names of the modeled tracers, or a NamedTuple of            preallocated CenterFields.\ntimestepper: A symbol that specifies the time-stepping method. Either :QuasiAdamsBashforth2 or                :RungeKutta3.\nbackground_fields: NamedTuple with background fields (e.g., background flow). Default: nothing.\nparticles: Lagrangian particles to be advected with the flow. Default: nothing.\nbiogeochemistry: Biogeochemical model for tracers.\nvelocities: The model velocities. Default: nothing.\npressures: Hydrostatic and non-hydrostatic pressure fields. Default: nothing.\ndiffusivity_fields: Diffusivity fields. Default: nothing.\npressure_solver: Pressure solver to be used in the model. If nothing (default), the model constructor chooses the default based on the grid provide.\nimmersed_boundary: The immersed boundary. Default: nothing.\nauxiliary_fields: NamedTuple of auxiliary fields. Default: nothing         \n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Hydrostatic-free-surface-models","page":"Library","title":"Hydrostatic free-surface models","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Models.HydrostaticFreeSurfaceModels]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.Models.HydrostaticFreeSurfaceModels.ExplicitFreeSurface","page":"Library","title":"Oceananigans.Models.HydrostaticFreeSurfaceModels.ExplicitFreeSurface","text":"struct ExplicitFreeSurface{E, T}\n\nThe explicit free surface solver.\n\nÎ·::Any: free surface elevation\ngravitational_acceleration::Any: gravitational accelerations\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Models.HydrostaticFreeSurfaceModels.HydrostaticFreeSurfaceModel-Tuple{}","page":"Library","title":"Oceananigans.Models.HydrostaticFreeSurfaceModels.HydrostaticFreeSurfaceModel","text":"HydrostaticFreeSurfaceModel(; grid,\n                                         clock = Clock{eltype(grid)}(0, 0, 1),\n                            momentum_advection = CenteredSecondOrder(),\n                              tracer_advection = CenteredSecondOrder(),\n                                      buoyancy = SeawaterBuoyancy(eltype(grid)),\n                                      coriolis = nothing,\n                                  free_surface = ImplicitFreeSurface(gravitational_acceleration=g_Earth),\n                           forcing::NamedTuple = NamedTuple(),\n                                       closure = nothing,\n               boundary_conditions::NamedTuple = NamedTuple(),\n                                       tracers = (:T, :S),\n                 particles::ParticlesOrNothing = nothing,\n         biogeochemistry::AbstractBGCOrNothing = nothing,\n                                    velocities = nothing,\n                                      pressure = nothing,\n                            diffusivity_fields = nothing,\n                              auxiliary_fields = NamedTuple(),\n        calculate_only_active_cells_tendencies = false\n)\n\nConstruct a hydrostatic model with a free surface on grid.\n\nKeyword arguments\n\ngrid: (required) The resolution and discrete geometry on which model is solved. The architecture (CPU/GPU) that the model is solve is inferred from the architecture of the grid.\nmomentum_advection: The scheme that advects velocities. See Oceananigans.Advection.\ntracer_advection: The scheme that advects tracers. See Oceananigans.Advection.\nbuoyancy: The buoyancy model. See Oceananigans.BuoyancyModels.\ncoriolis: Parameters for the background rotation rate of the model.\nforcing: NamedTuple of user-defined forcing functions that contribute to solution tendencies.\nfree_surface: The free surface model.\nclosure: The turbulence closure for model. See Oceananigans.TurbulenceClosures.\nboundary_conditions: NamedTuple containing field boundary conditions.\ntracers: A tuple of symbols defining the names of the modeled tracers, or a NamedTuple of            preallocated CenterFields.\nparticles: Lagrangian particles to be advected with the flow. Default: nothing.\nbiogeochemistry: Biogeochemical model for tracers.\nvelocities: The model velocities. Default: nothing.\npressure: Hydrostatic pressure field. Default: nothing.\ndiffusivity_fields: Diffusivity fields. Default: nothing.\nauxiliary_fields: NamedTuple of auxiliary fields. Default: nothing\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Models.HydrostaticFreeSurfaceModels.ImplicitFreeSurface-Tuple{}","page":"Library","title":"Oceananigans.Models.HydrostaticFreeSurfaceModels.ImplicitFreeSurface","text":"ImplicitFreeSurface(; solver_method=:Default, gravitational_acceleration=g_Earth, solver_settings...)\n\nReturn an implicit free-surface solver. The implicit free-surface equation is\n\nleft  _h  (H _h) - frac1g Î”t^2 right  Î·^n+1 = frac_h  ğ_g Î”t - fracÎ·^ng Î”t^2 \n\nwhere Î·^n is the free-surface elevation at the n-th time step, H is depth, g is the gravitational acceleration, Î”t is the time step, _h is the horizontal gradient operator, and ğ_ is the barotropic volume flux associated with the predictor velocity field ğ®_, i.e., \n\nğ_ = int_-H^0 ğ®_  ğ–½ z \n\nwhere \n\nğ®_ = ğ®^n + int_t_n^t_n+1 ğ†áµ¤  ğ–½t \n\nThis equation can be solved, in general, using the PreconditionedConjugateGradientSolver but  other solvers can be invoked in special cases.\n\nIf H is constant, we divide through out to obtain\n\nleft ( ^2_h - frac1g H Î”t^2 right ) Î·^n+1  = frac1g H Î”t left ( _h  ğ_ - fracÎ·^nÎ”t right ) \n\nThus, for constant H and on grids with regular spacing in x and y directions, the free surface can be obtained using the FFTBasedPoissonSolver.\n\nsolver_method can be either of:\n\n:FastFourierTransform for FFTBasedPoissonSolver\n:HeptadiagonalIterativeSolver  for HeptadiagonalIterativeSolver\n:PreconditionedConjugateGradient for PreconditionedConjugateGradientSolver\n\nBy default, if the grid has regular spacing in the horizontal directions then the :FastFourierTransform is chosen, otherwise the :HeptadiagonalIterativeSolver.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Models.HydrostaticFreeSurfaceModels.PrescribedVelocityFields-Tuple{}","page":"Library","title":"Oceananigans.Models.HydrostaticFreeSurfaceModels.PrescribedVelocityFields","text":"PrescribedVelocityFields(; u=zerofunc, v=zerofunc, w=zerofunc, parameters=nothing)\n\nBuilds PrescribedVelocityFields with prescribed functions u, v, and w.\n\nIf isnothing(parameters), then u, v, w are called with the signature\n\nu(x, y, z, t) = # something interesting\n\nIf !isnothing(parameters), then u, v, w are called with the signature\n\nu(x, y, z, t, parameters) = # something parameterized and interesting\n\nIn the constructor for HydrostaticFreeSurfaceModel, the functions u, v, w are wrapped in FunctionField and associated with the model's grid and clock.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurface","page":"Library","title":"Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurface","text":"struct SplitExplicitFreeSurface\n\nThe split-explicit free surface solver.\n\nÎ·: The instantaneous free surface (ReducedField)\nstate: The entire state for the split-explicit solver (SplitExplicitState)\nauxiliary: Parameters for timestepping split-explicit solver (NamedTuple)\ngravitational_acceleration: Gravitational acceleration\nsettings: Settings for the split-explicit scheme (NamedTuple)\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurface-Tuple{}","page":"Library","title":"Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurface","text":"SplitExplicitFreeSurface(; gravitational_acceleration = g_Earth, kwargs...)\n\nReturn a SplitExplicitFreeSurface representing an explicit time discretization of oceanic free surface dynamics with gravitational_acceleration.\n\nKeyword Arguments\n\nsubsteps: The number of substeps that divide the range (t, t + 2Î”t). Note that some averaging functions             do not require substepping until 2Î”t. The number of substeps is reduced automatically to the last             index of averaging_weights for which averaging_weights > 0.\nbarotropic_averaging_kernel: function of Ï„ used to average the barotropic transport U and free surface Î·                                within the barotropic advancement. Ï„ is the fractional substep going from 0 to 2                                with the baroclinic time step t + Î”t located at Ï„ = 1. This function should be                                centered at Ï„ = 1, that is,  (aâ‚˜ m M) = 1.\ntimestepper: Time stepping scheme used, either ForwardBackwardScheme() or AdamsBashforth3Scheme().\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Shallow-water-models","page":"Library","title":"Shallow-water models","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Models.ShallowWaterModels]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.Models.ShallowWaterModels.ShallowWaterModel-Tuple{}","page":"Library","title":"Oceananigans.Models.ShallowWaterModels.ShallowWaterModel","text":"ShallowWaterModel(; grid,\n                    gravitational_acceleration,\n                          clock = Clock{eltype(grid)}(0, 0, 1),\n             momentum_advection = UpwindBiasedFifthOrder(),\n               tracer_advection = WENO(),\n                 mass_advection = WENO(),\n                       coriolis = nothing,\n            forcing::NamedTuple = NamedTuple(),\n                        closure = nothing,\n                     bathymetry = nothing,\n                        tracers = (),\n             diffusivity_fields = nothing,\nboundary_conditions::NamedTuple = NamedTuple(),\n            timestepper::Symbol = :RungeKutta3,\n                    formulation = ConservativeFormulation())\n\nConstruct a shallow water model on grid with gravitational_acceleration constant.\n\nKeyword arguments\n\ngrid: (required) The resolution and discrete geometry on which model is solved. The         architecture (CPU/GPU) that the model is solve is inferred from the architecture         of the grid.\ngravitational_acceleration: (required) The gravitational acceleration constant.\nclock: The clock for the model.\nmomentum_advection: The scheme that advects velocities. See Oceananigans.Advection. Default: UpwindBiasedFifthOrder().\ntracer_advection: The scheme that advects tracers. See Oceananigans.Advection. Default: WENO().\nmass_advection: The scheme that advects the mass equation. See Oceananigans.Advection. Default: WENO().\ncoriolis: Parameters for the background rotation rate of the model.\nforcing: NamedTuple of user-defined forcing functions that contribute to solution tendencies.\nclosure: The turbulence closure for model. See Oceananigans.TurbulenceClosures.\nbathymetry: The bottom bathymetry.\ntracers: A tuple of symbols defining the names of the modeled tracers, or a NamedTuple of            preallocated CenterFields.\ndiffusivity_fields: Stores diffusivity fields when the closures require a diffusivity to be                       calculated at each timestep.\nboundary_conditions: NamedTuple containing field boundary conditions.\ntimestepper: A symbol that specifies the time-stepping method. Either :QuasiAdamsBashforth2 or                :RungeKutta3 (default).\nformulation: Whether the dynamics are expressed in conservative form (ConservativeFormulation();                default) or in non-conservative form with a vector-invariant formulation for the                non-linear terms (VectorInvariantFormulation()).\n\nwarning: Formulation-grid compatibility requirements\nThe ConservativeFormulation() requires RectilinearGrid. Use VectorInvariantFormulation() with LatitudeLongitudeGrid.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Models.ShallowWaterModels.ShallowWaterScalarDiffusivity","page":"Library","title":"Oceananigans.Models.ShallowWaterModels.ShallowWaterScalarDiffusivity","text":"ShallowWaterScalarDiffusivity([FT::DataType=Float64;]\n                              Î½=0, Î¾=0, discrete_form=false)\n\nReturn a scalar diffusivity for the shallow water model.\n\nThe diffusivity for the shallow water model is calculated as h * Î½ so that we get a viscous term in the form h^-1   (h Î½ t), where t is the 2D stress tensor plus a trace, i.e., t = ğ® + (ğ®)^T - Î¾ I  (  ğ®).\n\nWith the VectorInvariantFormulation() (that evolves u and v) we compute h^-1 (Î½ h  t), while with the ConservativeFormulation() (that evolves u h and v h) we compute  (Î½ h  t).\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#MultiRegion","page":"Library","title":"MultiRegion","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.MultiRegion]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.MultiRegion.MultiRegionGrid-Tuple{Any}","page":"Library","title":"Oceananigans.MultiRegion.MultiRegionGrid","text":"MultiRegionGrid(global_grid; partition = XPartition(2), devices = nothing)\n\nSplit a global_grid into different regions handled by devices.\n\nPositional Arguments\n\nglobal_grid: the grid to be divided into regions\n\nKeyword Arguments\n\npartition: the partitioning required. The implemented partitioning are XPartition               (division along the x direction) and YPartition (division along the y direction)\ndevices: the devices to allocate memory on. nothing will allocate memory on the CPU. For             GPU computation it is possible to specify the total number of GPUs or the specific            GPUs to allocate memory on. The number of devices does not have to match the number of            regions \n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Operators","page":"Library","title":"Operators","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Operators]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.Operators.div_xyá¶œá¶œá¶œ-NTuple{6, Any}","page":"Library","title":"Oceananigans.Operators.div_xyá¶œá¶œá¶œ","text":"div_xyá¶œá¶œáµƒ(i, j, k, grid, u, v)\n\nReturn the discrete div_xy = âˆ‚x u + âˆ‚y v of velocity field u, v defined as\n\n1 / Azá¶œá¶œáµƒ * [Î´xá¶œáµƒáµƒ(Î”yáµƒá¶œáµƒ * u) + Î´yáµƒá¶œáµƒ(Î”xá¶œáµƒáµƒ * v)]\n\nat i, j, k, where Azá¶œá¶œáµƒ is the area of the cell centered on (Center, Center, Any) â€“- a tracer cell, Î”y is the length of the cell centered on (Face, Center, Any) in y (a u cell), and Î”x is the length of the cell centered on (Center, Face, Any) in x (a v cell). div_xyá¶œá¶œáµƒ ends up at the location cca.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Operators.divá¶œá¶œá¶œ-NTuple{7, Any}","page":"Library","title":"Oceananigans.Operators.divá¶œá¶œá¶œ","text":"divá¶œá¶œá¶œ(i, j, k, grid, u, v, w)\n\nCalculate the divergence ğ• of a vector field ğ• = (u v w),\n\n1/V * [Î´xá¶œáµƒáµƒ(Ax * u) + Î´xáµƒá¶œáµƒ(Ay * v) + Î´záµƒáµƒá¶œ(Az * w)]\n\nwhich ends up at the cell centers ccc.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Operators.Î¶â‚ƒá¶ á¶ á¶œ-NTuple{6, Any}","page":"Library","title":"Oceananigans.Operators.Î¶â‚ƒá¶ á¶ á¶œ","text":"Î¶â‚ƒá¶ á¶ á¶œ(i, j, k, grid, u, v)\n\nThe vertical vorticity associated with horizontal velocities u and v.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Operators.âˆ‡Â²á¶œá¶œá¶œ-NTuple{5, Any}","page":"Library","title":"Oceananigans.Operators.âˆ‡Â²á¶œá¶œá¶œ","text":"âˆ‡Â²á¶œá¶œá¶œ(i, j, k, grid, c)\n\nCalculate the Laplacian of c via\n\n1/V * [Î´xá¶œáµƒáµƒ(Ax * âˆ‚xá¶ áµƒáµƒ(c)) + Î´yáµƒá¶œáµƒ(Ay * âˆ‚yáµƒá¶ áµƒ(c)) + Î´záµƒáµƒá¶œ(Az * âˆ‚záµƒáµƒá¶ (c))]\n\nwhich ends up at the location ccc.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Output-readers","page":"Library","title":"Output readers","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.OutputReaders]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.OutputReaders.FieldDataset-Tuple{Any}","page":"Library","title":"Oceananigans.OutputReaders.FieldDataset","text":"FieldDataset(filepath;\n             architecture=CPU(), grid=nothing, backend=InMemory(), metadata_paths=[\"metadata\"])\n\nReturns a Dict containing a FieldTimeSeries for each field in the JLD2 file located at filepath. Note that model output must have been saved with halos.\n\nKeyword arguments\n\nbackend: Either InMemory() (default) or OnDisk(). The InMemory backend will\n\nload the data fully in memory as a 4D multi-dimensional array while the OnDisk() backend will lazily load field time snapshots when the FieldTimeSeries is indexed linearly.\n\nmetadata_paths: A list of JLD2 paths to look for metadata. By default it looks in file[\"metadata\"].\ngrid: May be specified to override the grid used in the JLD2 file.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.OutputReaders.FieldTimeSeries-Tuple{Any, Any}","page":"Library","title":"Oceananigans.OutputReaders.FieldTimeSeries","text":"FieldTimeSeries(path, name;\n                backend = InMemory(),\n                grid = nothing,\n                iterations = nothing,\n                times = nothing)\n\nReturn a FieldTimeSeries containing a time-series of the field name load from JLD2 output located at path.\n\nKeyword arguments\n\nbackend: InMemory() to load data into a 4D array or OnDisk() to lazily load data from disk            when indexing into FieldTimeSeries.\ngrid: A grid to associated with data, in the case that the native grid was not serialized         properly.\niterations: Iterations to load. Defaults to all iterations found in the file.\ntimes: Save times to load, as determined through an approximate floating point          comparison to recorded save times. Defaults to times associated with iterations.          Takes precedence over iterations if times is specified.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.OutputReaders.FieldTimeSeries-Union{Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Any, Any}, Tuple{Any, Any, Any}} where {LX, LY, LZ}","page":"Library","title":"Oceananigans.OutputReaders.FieldTimeSeries","text":"FieldTimeSeries{LX, LY, LZ}(grid, times, [FT=eltype(grid);]\n                            indices = (:, :, :),\n                            boundary_conditions = nothing)\n\nReturn a FieldTimeSeries at location (LX, LY, LZ), on grid, at times.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Output-writers","page":"Library","title":"Output writers","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.OutputWriters]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.OutputWriters.AveragedTimeInterval","page":"Library","title":"Oceananigans.OutputWriters.AveragedTimeInterval","text":"mutable struct AveragedTimeInterval <: AbstractSchedule\n\nContainer for parameters that configure and handle time-averaged output.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.OutputWriters.AveragedTimeInterval-Tuple{Any}","page":"Library","title":"Oceananigans.OutputWriters.AveragedTimeInterval","text":"AveragedTimeInterval(interval; window=interval, stride=1)\n\nReturns a schedule that specifies periodic time-averaging of output. The time window specifies the extent of the time-average, which reoccurs every interval.\n\noutput is computed and accumulated into the average every stride iterations during the averaging window. For example, stride=1 computs output every iteration, whereas stride=2 computes output every other iteration. Time-averages with longer strides are faster to compute, but less accurate.\n\nThe time-average of a is a left Riemann sum corresponding to\n\na = TÂ¹ int_táµ¢-T^táµ¢ a mathrmd t  \n\nwhere a is the time-average of a, T is the time-window for averaging, and the táµ¢ are discrete times separated by the time interval. The táµ¢ specify both the end of the averaging window and the time at which output is written.\n\nExample\n\nusing Oceananigans.OutputWriters: AveragedTimeInterval\nusing Oceananigans.Utils: days\n\nschedule = AveragedTimeInterval(4days, window=2days)\n\n# output\nAveragedTimeInterval(window=2 days, stride=1, interval=4 days)\n\nAn AveragedTimeInterval schedule directs an output writer to time-average its outputs before writing them to disk:\n\nusing Oceananigans\nusing Oceananigans.OutputWriters: JLD2OutputWriter\nusing Oceananigans.Utils: minutes\n\nmodel = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)))\n\nsimulation = Simulation(model, Î”t=10minutes, stop_time=30days)\n\nsimulation.output_writers[:velocities] = JLD2OutputWriter(model, model.velocities,\n                                                          filename= \"averaged_velocity_data.jld2\",\n                                                          schedule = AveragedTimeInterval(4days, window=2days, stride=2))\n\n# output\nJLD2OutputWriter scheduled on TimeInterval(4 days):\nâ”œâ”€â”€ filepath: ./averaged_velocity_data.jld2\nâ”œâ”€â”€ 3 outputs: (u, v, w) averaged on AveragedTimeInterval(window=2 days, stride=2, interval=4 days)\nâ”œâ”€â”€ array type: Array{Float64}\nâ”œâ”€â”€ including: [:grid, :coriolis, :buoyancy, :closure]\nâ””â”€â”€ max filesize: Inf YiB\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.OutputWriters.Checkpointer-Tuple{Any}","page":"Library","title":"Oceananigans.OutputWriters.Checkpointer","text":"Checkpointer(model; schedule,\n             dir = \".\",\n             prefix = \"checkpoint\",\n             overwrite_existing = false,\n             cleanup = false,\n             additional_kwargs...)\n\nConstruct a Checkpointer that checkpoints the model to a JLD2 file on schedule. The model.clock.iteration is included in the filename to distinguish between multiple checkpoint files.\n\nTo restart or \"pickup\" a model from a checkpoint, specify pickup = true when calling run!, ensuring that the checkpoint file is in directory dir. See run! for more details.\n\nNote that extra model properties can be safely specified, but removing crucial properties such as :velocities will make restoring from the checkpoint impossible.\n\nThe checkpointer attempts to serialize as much of the model to disk as possible, but functions or objects containing functions cannot be serialized at this time.\n\nKeyword arguments\n\nschedule (required): Schedule that determines when to checkpoint.\ndir: Directory to save output to. Default: \".\" (current working directory).\nprefix: Descriptive filename prefixed to all output files. Default: \"checkpoint\".\noverwrite_existing: Remove existing files if their filenames conflict. Default: false.\nverbose: Log what the output writer is doing with statistics on compute/write times            and file sizes. Default: false.\ncleanup: Previous checkpoint files will be deleted once a new checkpoint file is written.            Default: false.\nproperties: List of model properties to checkpoint. This list must contain               [:grid, :architecture, :timestepper, :particles].               Default: [:architecture, :grid, :clock, :coriolis, :buoyancy, :closure,                         :velocities, :tracers, :timestepper, :particles]\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.OutputWriters.JLD2OutputWriter-Tuple{Any, Any}","page":"Library","title":"Oceananigans.OutputWriters.JLD2OutputWriter","text":"JLD2OutputWriter(model, outputs; filename, schedule,\n                          dir = \".\",\n                      indices = (:, :, :),\n                   with_halos = false,\n                   array_type = Array{Float64},\n                 max_filesize = Inf,\n           overwrite_existing = false,\n                         init = noinit,\n                    including = [:grid, :coriolis, :buoyancy, :closure],\n                      verbose = false,\n                         part = 1,\n                      jld2_kw = Dict{Symbol, Any}())\n\nConstruct a JLD2OutputWriter for an Oceananigans model that writes label, output pairs in outputs to a JLD2 file.\n\nThe argument outputs may be a Dict or NamedTuple. The keys of outputs are symbols or strings that \"name\" output data. The values of outputs are either AbstractFields, objects that are called with the signature output(model), or WindowedTimeAverages of AbstractFieldss, functions, or callable objects.\n\nKeyword arguments\n\nFilenaming\n\nfilename (required): Descriptive filename. \".jld2\" is appended to filename in the file path                       if filename does not end in \".jld2\".\ndir: Directory to save output to. Default: \".\" (current working directory).\n\nOutput frequency and time-averaging\n\nschedule (required): AbstractSchedule that determines when output is saved.\n\nSlicing and type conversion prior to output\n\nindices: Specifies the indices to write to disk with a Tuple of Colon, UnitRange,            or Int elements. Indices must be Colon, Int, or contiguous UnitRange.            Defaults to (:, :, :) or \"all indices\". If !with_halos,            halo regions are removed from indices. For example, indices = (:, :, 1)            will save xy-slices of the bottom-most index.\nwith_halos (Bool): Whether or not to slice halo regions from fields before writing output.                      Note, that to postprocess saved output (e.g., compute derivatives, etc)                      information about the boundary conditions is often crucial. In that case                      you might need to set with_halos = true.\narray_type: The array type to which output arrays are converted to prior to saving.               Default: Array{Float64}.\n\nFile management\n\nmax_filesize: The writer will stop writing to the output file once the file size exceeds max_filesize,                 and write to a new one with a consistent naming scheme ending in part1, part2, etc.                 Defaults to Inf.\noverwrite_existing: Remove existing files if their filenames conflict.                       Default: false.\n\nOutput file metadata management\n\ninit: A function of the form init(file, model) that runs when a JLD2 output file is initialized.         Default: noinit(args...) = nothing.\nincluding: List of model properties to save with every file.              Default: [:grid, :coriolis, :buoyancy, :closure]\n\nMiscellaneous keywords\n\nverbose: Log what the output writer is doing with statistics on compute/write times and file sizes.            Default: false.\npart: The starting part number used if max_filesize is finite.         Default: 1.\njld2_kw: Dict of kwargs to be passed to jldopen when data is written.\n\nExample\n\nWrite out 3D fields for u, v, w, and a tracer c, along with a horizontal average:\n\nusing Oceananigans\nusing Oceananigans.Utils: hour, minute\n\nmodel = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)), tracers=(:c,))\nsimulation = Simulation(model, Î”t=12, stop_time=1hour)\n\nfunction init_save_some_metadata!(file, model)\n    file[\"author\"] = \"Chim Riggles\"\n    file[\"parameters/coriolis_parameter\"] = 1e-4\n    file[\"parameters/density\"] = 1027\n    return nothing\nend\n\nc_avg =  Field(Average(model.tracers.c, dims=(1, 2)))\n\n# Note that model.velocities is NamedTuple\nsimulation.output_writers[:velocities] = JLD2OutputWriter(model, model.velocities,\n                                                          filename = \"some_data.jld2\",\n                                                          schedule = TimeInterval(20minute),\n                                                          init = init_save_some_metadata!)\n\n# output\nJLD2OutputWriter scheduled on TimeInterval(20 minutes):\nâ”œâ”€â”€ filepath: ./some_data.jld2\nâ”œâ”€â”€ 3 outputs: (u, v, w)\nâ”œâ”€â”€ array type: Array{Float64}\nâ”œâ”€â”€ including: [:grid, :coriolis, :buoyancy, :closure]\nâ””â”€â”€ max filesize: Inf YiB\n\nand a time- and horizontal-average of tracer c every 20 minutes of simulation time to a file called some_averaged_data.jld2\n\nsimulation.output_writers[:avg_c] = JLD2OutputWriter(model, (; c=c_avg),\n                                                     filename = \"some_averaged_data.jld2\",\n                                                     schedule = AveragedTimeInterval(20minute, window=5minute))\n\n# output\nJLD2OutputWriter scheduled on TimeInterval(20 minutes):\nâ”œâ”€â”€ filepath: ./some_averaged_data.jld2\nâ”œâ”€â”€ 1 outputs: c averaged on AveragedTimeInterval(window=5 minutes, stride=1, interval=20 minutes)\nâ”œâ”€â”€ array type: Array{Float64}\nâ”œâ”€â”€ including: [:grid, :coriolis, :buoyancy, :closure]\nâ””â”€â”€ max filesize: Inf YiB\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.OutputWriters.NetCDFOutputWriter-Tuple{Any, Any}","page":"Library","title":"Oceananigans.OutputWriters.NetCDFOutputWriter","text":"NetCDFOutputWriter(model, outputs; filename, schedule\n                                      dir = \".\",\n                               array_type = Array{Float64},\n                                  indices = nothing,\n                               with_halos = false,\n                        global_attributes = Dict(),\n                        output_attributes = Dict(),\n                               dimensions = Dict(),\n                       overwrite_existing = false,\n                              compression = 0,\n                                  verbose = false)\n\nConstruct a NetCDFOutputWriter that writes (label, output) pairs in outputs (which should be a Dict) to a NetCDF file, where label is a string that labels the output and output is either a Field (e.g. model.velocities.u) or a function f(model) that returns something to be written to disk. Custom output requires the spatial dimensions (a Dict) to be manually specified (see examples).\n\nKeyword arguments\n\nFilenaming\n\nfilename (required): Descriptive filename. \".nc\" is appended to filename if filename does                        not end in \".nc\".\ndir: Directory to save output to.\n\nOutput frequency and time-averaging\n\nschedule (required): AbstractSchedule that determines when output is saved.\n\nSlicing and type conversion prior to output\n\nindices: Tuple of indices of the output variables to include. Default is (:, :, :), which            includes the full fields.\nwith_halos: Boolean defining whether or not to include halos in the outputs. Default: false.               Note, that to postprocess saved output (e.g., compute derivatives, etc)               information about the boundary conditions is often crucial. In that case               you might need to set with_halos = true.\narray_type: The array type to which output arrays are converted to prior to saving.               Default: Array{Float64}.\ndimensions: A Dict of dimension tuples to apply to outputs (required for function outputs).\n\nFile management\n\noverwrite_existing: If false, NetCDFOutputWriter will be set to append to filepath. If true,                       NetCDFOutputWriter will overwrite filepath if it exists or create it if not.                       Default: false. See NCDatasets.jl documentation                       for more information about its mode option.\ncompression: Determines the compression level of data (0-9; default: 0).\n\nMiscellaneous keywords\n\nglobal_attributes: Dict of model properties to save with every file. Default: Dict().\noutput_attributes: Dict of attributes to be saved with each field variable (reasonable                      defaults are provided for velocities, buoyancy, temperature, and salinity;                      otherwise output_attributes must be user-provided).\n\nExamples\n\nSaving the u velocity field and temperature fields, the full 3D fields and surface 2D slices to separate NetCDF files:\n\nusing Oceananigans\n\ngrid = RectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1))\n\nmodel = NonhydrostaticModel(grid=grid, tracers=:c)\n\nsimulation = Simulation(model, Î”t=12, stop_time=3600)\n\nfields = Dict(\"u\" => model.velocities.u, \"c\" => model.tracers.c)\n\nsimulation.output_writers[:field_writer] =\n    NetCDFOutputWriter(model, fields, filename=\"fields.nc\", schedule=TimeInterval(60))\n\n# output\nNetCDFOutputWriter scheduled on TimeInterval(1 minute):\nâ”œâ”€â”€ filepath: ./fields.nc\nâ”œâ”€â”€ dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0)\nâ”œâ”€â”€ 2 outputs: (c, u)\nâ””â”€â”€ array type: Array{Float64}\n\nsimulation.output_writers[:surface_slice_writer] =\n    NetCDFOutputWriter(model, fields, filename=\"surface_xy_slice.nc\",\n                       schedule=TimeInterval(60), indices=(:, :, grid.Nz))\n\n# output\nNetCDFOutputWriter scheduled on TimeInterval(1 minute):\nâ”œâ”€â”€ filepath: ./surface_xy_slice.nc\nâ”œâ”€â”€ dimensions: zC(1), zF(1), xC(16), yF(16), xF(16), yC(16), time(0)\nâ”œâ”€â”€ 2 outputs: (c, u)\nâ””â”€â”€ array type: Array{Float64}\n\nsimulation.output_writers[:averaged_profile_writer] =\n    NetCDFOutputWriter(model, fields,\n                       filename = \"averaged_z_profile.nc\",\n                       schedule = AveragedTimeInterval(60, window=20),\n                       indices = (1, 1, :))\n\n# output\nNetCDFOutputWriter scheduled on TimeInterval(1 minute):\nâ”œâ”€â”€ filepath: ./averaged_z_profile.nc\nâ”œâ”€â”€ dimensions: zC(16), zF(17), xC(1), yF(1), xF(1), yC(1), time(0)\nâ”œâ”€â”€ 2 outputs: (c, u) averaged on AveragedTimeInterval(window=20 seconds, stride=1, interval=1 minute)\nâ””â”€â”€ array type: Array{Float64}\n\nNetCDFOutputWriter also accepts output functions that write scalars and arrays to disk, provided that their dimensions are provided:\n\nusing Oceananigans\n\nNx, Ny, Nz = 16, 16, 16\n\ngrid = RectilinearGrid(size=(Nx, Ny, Nz), extent=(1, 2, 3))\n\nmodel = NonhydrostaticModel(grid=grid)\n\nsimulation = Simulation(model, Î”t=1.25, stop_iteration=3)\n\nf(model) = model.clock.time^2; # scalar output\n\ng(model) = model.clock.time .* exp.(znodes(Center, grid)) # vector/profile output\n\nxC, yF = xnodes(grid, Center()), ynodes(grid, Face())\n\nXC = [xC[i] for i in 1:Nx, j in 1:Ny]\nYF = [yF[j] for i in 1:Nx, j in 1:Ny]\n\nh(model) = @. model.clock.time * sin(XC) * cos(YF) # xy slice output\n\noutputs = Dict(\"scalar\" => f, \"profile\" => g, \"slice\" => h)\n\ndims = Dict(\"scalar\" => (), \"profile\" => (\"zC\",), \"slice\" => (\"xC\", \"yC\"))\n\noutput_attributes = Dict(\n    \"scalar\"  => Dict(\"longname\" => \"Some scalar\", \"units\" => \"bananas\"),\n    \"profile\" => Dict(\"longname\" => \"Some vertical profile\", \"units\" => \"watermelons\"),\n    \"slice\"   => Dict(\"longname\" => \"Some slice\", \"units\" => \"mushrooms\")\n)\n\nglobal_attributes = Dict(\"location\" => \"Bay of Fundy\", \"onions\" => 7)\n\nsimulation.output_writers[:things] =\n    NetCDFOutputWriter(model, outputs,\n                       schedule=IterationInterval(1), filename=\"things.nc\", dimensions=dims, verbose=true,\n                       global_attributes=global_attributes, output_attributes=output_attributes)\n\n# output\nNetCDFOutputWriter scheduled on IterationInterval(1):\nâ”œâ”€â”€ filepath: ./things.nc\nâ”œâ”€â”€ dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0)\nâ”œâ”€â”€ 3 outputs: (profile, slice, scalar)\nâ””â”€â”€ array type: Array{Float64}\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.OutputWriters.WindowedTimeAverage","page":"Library","title":"Oceananigans.OutputWriters.WindowedTimeAverage","text":"WindowedTimeAverage(operand, model=nothing; schedule)\n\nReturns an object for computing running averages of operand over schedule.window and recurring on schedule.interval, where schedule is an AveragedTimeInterval. During the collection period, averages are computed every schedule.stride iteration.\n\noperand may be a Oceananigans.Field or a function that returns an array or scalar.\n\nCalling wta(model) for wta::WindowedTimeAverage object returns wta.result.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Simulations","page":"Library","title":"Simulations","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Simulations]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.Simulations.Callback","page":"Library","title":"Oceananigans.Simulations.Callback","text":"Callback(func, schedule=IterationInterval(1); parameters=nothing)\n\nReturn Callback that executes func on schedule with optional parameters. schedule = IterationInterval(1) by default.\n\nIf isnothing(parameters), func(sim::Simulation) is called. Otherwise, func is called via func(sim::Simulation, parameters).\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Simulations.Simulation-Tuple{Any}","page":"Library","title":"Oceananigans.Simulations.Simulation","text":"Simulation(model; Î”t,\n           verbose = true,\n           stop_iteration = Inf,\n           stop_time = Inf,\n           wall_time_limit = Inf)\n\nConstruct a Simulation for a model with time step Î”t.\n\nKeyword arguments\n\nÎ”t: Required keyword argument specifying the simulation time step. Can be a Number       for constant time steps or a TimeStepWizard for adaptive time-stepping.\nstop_iteration: Stop the simulation after this many iterations.\nstop_time: Stop the simulation once this much model clock time has passed.\nwall_time_limit: Stop the simulation if it's been running for longer than this many                    seconds of wall clock time.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Simulations.TimeStepWizard","page":"Library","title":"Oceananigans.Simulations.TimeStepWizard","text":"TimeStepWizard([FT=Float64;]\n               cfl = 0.2,\n               diffusive_cfl = Inf,\n               max_change = 1.1,\n               min_change = 0.5,\n               max_Î”t = Inf,\n               min_Î”t = 0.0,\n               cell_advection_timescale = cell_advection_timescale,\n               cell_diffusion_timescale = infinite_diffusion_timescale)\n\nCallback for adapting simulation to maintain the advective Courant-Freidrichs-Lewy (CFL) number to cfl, the diffusive_cfl, while also maintaining max_Î”t, min_Î”t, and satisfying max_change and min_change criteria so that the simulation's timestep simulation.Î”t is not adapted \"too quickly\".\n\nFor more information on the CFL number, see its wikipedia entry.\n\nExample\n\nTo use TimeStepWizard, adapt in a Callback and add it to a Simulation:\n\njulia> simulation = Simulation(model, Î”t=0.9, stop_iteration=100)\n\njulia> wizard = TimeStepWizard(cfl=0.2)\n\njulia> simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(4))\n\nThen when run!(simulation) is invoked, the time-step simulation.Î”t will be updated every 4 iterations.\n\n(Note that the name :wizard is unimportant.)\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Simulations.erroring_NaNChecker!-Tuple{Any}","page":"Library","title":"Oceananigans.Simulations.erroring_NaNChecker!","text":"erroring_NaNChecker!(simulation)\n\nToggles simulation's NaNChecker to throw an error when a NaN is detected.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Simulations.iteration-Tuple{Simulation}","page":"Library","title":"Oceananigans.Simulations.iteration","text":"iteration(sim::Simulation)\n\nReturn the current simulation iteration.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Simulations.run!-Tuple{Any}","page":"Library","title":"Oceananigans.Simulations.run!","text":"run!(simulation; pickup=false)\n\nRun a simulation until one of simulation.stop_criteria evaluates true. The simulation will then stop.\n\nPicking simulations up from a checkpoint\n\nSimulations are \"picked up\" from a checkpoint if pickup is either true, a String, or an Integer greater than 0.\n\nPicking up a simulation sets field and tendency data to the specified checkpoint, leaving all other model properties unchanged.\n\nPossible values for pickup are:\n\npickup=true picks a simulation up from the latest checkpoint associated with the Checkpointer in simulation.output_writers.\npickup=iteration::Int picks a simulation up from the checkpointed file associated  with iteration and the Checkpointer in simulation.output_writers.\npickup=filepath::String picks a simulation up from checkpointer data in filepath.\n\nNote that pickup=true and pickup=iteration fails if simulation.output_writers contains more than one checkpointer.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Solvers","page":"Library","title":"Solvers","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Solvers]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.Solvers.BatchedTridiagonalSolver","page":"Library","title":"Oceananigans.Solvers.BatchedTridiagonalSolver","text":"BatchedTridiagonalSolver\n\nA batched solver for large numbers of triadiagonal systems.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Solvers.BatchedTridiagonalSolver-Tuple{Any}","page":"Library","title":"Oceananigans.Solvers.BatchedTridiagonalSolver","text":"BatchedTridiagonalSolver(grid; lower_diagonal, diagonal, upper_diagonal, parameters=nothing, tridiagonal_direction=ZDirection())\n\nConstruct a solver for batched tridiagonal systems on grid of the form\n\n                       bâ±Ê²Â¹ Ï•â±Ê²Â¹ + câ±Ê²Â¹ Ï•â±Ê²Â²   = fâ±Ê²Â¹,  k = 1\n       aâ±Ê²áµâ»Â¹ Ï•â±Ê²áµâ»Â¹ + bâ±Ê²áµ Ï•â±Ê²áµ + câ±Ê²áµ Ï•â±Ê²áµâºÂ¹ = fâ±Ê²áµ,  k = 2, ..., N-1\n       aâ±Ê²á´ºâ»Â¹ Ï•â±Ê²á´ºâ»Â¹ + bâ±Ê²á´º Ï•â±Ê²á´º               = fâ±Ê²á´º,  k = N\n\nwhere a is the lower_diagonal, b is the diagonal, and c is the upper_diagonal. Ï• is the solution and f is the right hand side source term passed to solve!(Ï•, tridiagonal_solver, f)\n\na, b, c, and f can be specified in three ways:\n\nA 1D array means that aâ±Ê²áµ = a[k].\nA 3D array means that aâ±Ê²áµ = a[i, j, k].\nOtherwise, a is assumed to be callable:\nIf isnothing(parameters) then aâ±Ê²áµ = a(i, j, k, grid, args...).\nIf !isnothing(parameters) then aâ±Ê²áµ = a(i, j, k, grid, parameters, args...).\nwhere args... are Varargs passed to solve_batched_tridiagonal_system!(Ï•, solver, args...).\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Solvers.FFTBasedPoissonSolver","page":"Library","title":"Oceananigans.Solvers.FFTBasedPoissonSolver","text":"FFTBasedPoissonSolver(grid, planner_flag=FFTW.PATIENT)\n\nReturn an FFTBasedPoissonSolver that solves the \"generalized\" Poisson equation,\n\n(Â² + m) Ï• = b\n\nwhere m is a number, using a eigenfunction expansion of the discrete Poisson operator on a staggered grid and for periodic or Neumann boundary conditions.\n\nIn-place transforms are applied to b, which means b must have complex-valued elements (typically the same type as solver.storage).\n\nSee solve! for more information about the FFT-based Poisson solver algorithm.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Solvers.HeptadiagonalIterativeSolver-Tuple{Any}","page":"Library","title":"Oceananigans.Solvers.HeptadiagonalIterativeSolver","text":"HeptadiagonalIterativeSolver(coeffs;\n                             grid,\n                             iterative_solver = cg!,\n                             maximum_iterations = prod(size(grid)),\n                             tolerance = 1e-13,\n                             reduced_dim = (false, false, false), \n                             placeholder_timestep = -1.0, \n                             preconditioner_method = :Default, \n                             preconditioner_settings = nothing,\n                             template = arch_array(architecture(grid), zeros(prod(size(grid)))),\n                             verbose = false)\n\nReturn a HeptadiagonalIterativeSolver to solve the problem A * x = b, provided that A is a symmetric matrix.\n\nThe solver relies on a sparse version of the matrix A that is stored in matrix_constructors.\n\nIn particular, given coefficients Ax, Ay, Az, C, D, the solved problem is\n\n    Axáµ¢â‚Šâ‚ Î·áµ¢â‚Šâ‚ + Axáµ¢ Î·áµ¢â‚‹â‚ + Ayâ±¼â‚Šâ‚ Î·â±¼â‚Šâ‚ + Ayâ±¼ Î·â±¼â‚‹â‚ + Azâ‚–â‚Šâ‚ Î·â‚–â‚Šâ‚ + Azâ‚– Î·â‚–â‚‹â‚ \n    - 2 ( Axáµ¢â‚Šâ‚ + Axáµ¢ + Ayâ±¼â‚Šâ‚ + Ayâ±¼ + Azâ‚–â‚Šâ‚ + Azâ‚– ) Î·áµ¢â±¼â‚– \n    +   ( Cáµ¢â±¼â‚– + Dáµ¢â±¼â‚–/Î”t^2 ) Î·áµ¢â±¼â‚–  = b\n\nTo have the equation solved at location {Center, Center, Center}, the coefficients must be specified at:\n\nAx -> {Face,   Center, Center}\nAy -> {Center, Face,   Center}\nAz -> {Center, Center, Face}\nC  -> {Center, Center, Center}\nD  -> {Center, Center, Center}\n\nsolver.matrix is precomputed with a placeholder timestep value of placeholder_timestep = -1.0.\n\nThe sparse matrix A can be constructed with:\n\nSparseMatrixCSC(constructors...) for CPU\nCuSparseMatrixCSC(constructors...) for GPU\n\nThe matrix constructors are calculated based on the pentadiagonal coeffients passed as an input to matrix_from_coefficients function.\n\nTo allow for variable time step, the diagonal term - Az / (g * Î”tÂ²) is only added later on and it is updated only when the previous time step changes (previous_Î”t != Î”t).\n\nPreconditioning is done through the various methods implemented in Solvers/sparse_preconditioners.jl.\n\nThe iterative_solver used can is to be chosen from the IterativeSolvers.jl package.  The default solver is a Conjugate Gradient (cg):\n\nsolver = HeptadiagonalIterativeSolver((Ax, Ay, Az, C, D); grid)\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Solvers.PreconditionedConjugateGradientSolver-Tuple{Any}","page":"Library","title":"Oceananigans.Solvers.PreconditionedConjugateGradientSolver","text":"PreconditionedConjugateGradientSolver(linear_operation;\n                                      template_field,\n                                      maxiter = size(template_field.grid),\n                                      reltol = sqrt(eps(eltype(template_field.grid))),\n                                      abstol = 0,\n                                      preconditioner = nothing)\n\nReturns a PreconditionedConjugateGradientSolver that solves the linear equation A x = b using a iterative conjugate gradient method with optional preconditioning.\n\nThe solver is used by calling\n\nsolve!(x, solver::PreconditionedConjugateGradientOperator, b, args...)\n\nfor solver, right-hand side b, solution x, and optional arguments args....\n\nArguments\n\nlinear_operation: Function with signature linear_operation!(p, y, args...) that calculates                     A * y and stores the result in p for a \"candidate solution\" y. args...                     are optional positional arguments passed from solve!(x, solver, b, args...).\ntemplate_field: Dummy field that is the same type and size as x and b, which                   is used to infer the architecture, grid, and to create work arrays                   that are used internally by the solver.\nmaxiter: Maximum number of iterations the solver may perform before exiting.\nreltol, abstol: Relative and absolute tolerance for convergence of the algorithm.                   The iteration stops when norm(A * x - b) < tolerance.\npreconditioner: Object for which precondition!(z, preconditioner, r, args...) computes z = P * r,                   where r is the residual. Typically P is approximately Aâ»Â¹.\n\nSee solve! for more information about the preconditioned conjugate-gradient algorithm.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Solvers.solve!","page":"Library","title":"Oceananigans.Solvers.solve!","text":"solve!(Ï•, solver::FFTBasedPoissonSolver, b, m=0)\n\nSolves the \"generalized\" Poisson equation,\n\n(Â² + m) Ï• = b\n\nwhere m is a number, using a eigenfunction expansion of the discrete Poisson operator on a staggered grid and for periodic or Neumann boundary conditions.\n\nIn-place transforms are applied to b, which means b must have complex-valued elements (typically the same type as solver.storage).\n\ninfo: Alternative names for 'generalized' Poisson equation\nEquation (Â² + m) Ï• = b is sometimes referred to as the \"screened Poisson\" equation when m  0, or the Helmholtz equation when m  0.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.Solvers.solve!-Tuple{Any, Oceananigans.Solvers.BatchedTridiagonalSolver, Any, Vararg{Any}}","page":"Library","title":"Oceananigans.Solvers.solve!","text":"solve!(Ï•, solver::BatchedTridiagonalSolver, rhs, args...)\n\nSolve the batched tridiagonal system of linear equations with right hand side rhs and lower diagonal, diagonal, and upper diagonal coefficients described by the BatchedTridiagonalSolver solver. BatchedTridiagonalSolver uses a modified TriDiagonal Matrix Algorithm (TDMA).\n\nThe result is stored in Ï• which must have size (grid.Nx, grid.Ny, grid.Nz).\n\nReference implementation per Numerical Recipes, Press et. al 1992 (Â§ 2.4).\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Solvers.solve!-Tuple{Any, Oceananigans.Solvers.PreconditionedConjugateGradientSolver, Any, Vararg{Any}}","page":"Library","title":"Oceananigans.Solvers.solve!","text":"solve!(x, solver::PreconditionedConjugateGradientSolver, b, args...)\n\nSolve A * x = b using an iterative conjugate-gradient method, where A * x is determined by solver.linear_operation\n\nSee figure 2.5 in\n\nThe Preconditioned Conjugate Gradient Method in \"Templates for the Solution of Linear Systems: Building Blocks for Iterative Methods\" Barrett et. al, 2nd Edition.\n\nGiven:\n\nLinear Preconditioner operator M!(solution, x, other_args...) that computes M * x = solution\nA matrix operator A as a function A();\nA dot product function norm();\nA right-hand side b;\nAn initial guess x; and\nLocal vectors: z, r, p, q\n\nThis function executes the psuedocode algorithm\n\nÎ²  = 0\nr = b - A(x)\niteration  = 0\n\nLoop:\n     if iteration > maxiter\n        break\n     end\n\n     Ï = r â‹… z\n\n     z = M(r)\n     Î² = Ïâ±â»Â¹ / Ï\n     p = z + Î² * p\n     q = A(p)\n\n     Î± = Ï / (p â‹… q)\n     x = x + Î± * p\n     r = r - Î± * q\n\n     if |r| < tolerance\n        break\n     end\n\n     iteration += 1\n     Ïâ±â»Â¹ = Ï\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Stokes-drift","page":"Library","title":"Stokes drift","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.StokesDrift]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.StokesDrift.UniformStokesDrift","page":"Library","title":"Oceananigans.StokesDrift.UniformStokesDrift","text":"UniformStokesDrift{P, UZ, VZ, UT, VT} <: AbstractStokesDrift\n\nParameter struct for Stokes drift fields associated with surface waves.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.StokesDrift.UniformStokesDrift-Tuple{}","page":"Library","title":"Oceananigans.StokesDrift.UniformStokesDrift","text":"UniformStokesDrift(; âˆ‚z_uË¢=addzero, âˆ‚z_vË¢=addzero, âˆ‚t_uË¢=addzero, âˆ‚t_vË¢=addzero, parameters=nothing)\n\nConstruct a set of functions that describes the Stokes drift field beneath a horizontally-uniform surface gravity wave field.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Time-steppers","page":"Library","title":"Time steppers","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.TimeSteppers]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.TimeSteppers.Clock","page":"Library","title":"Oceananigans.TimeSteppers.Clock","text":"mutable struct Clock{T<:Number}\n\nKeeps track of the current time, iteration number, and time-stepping stage. The stage is updated only for multi-stage time-stepping methods. The time::T is either a number or a DateTime object.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TimeSteppers.Clock-Union{Tuple{}, Tuple{T}} where T","page":"Library","title":"Oceananigans.TimeSteppers.Clock","text":"Clock(; time, iteration=0, stage=1)\n\nReturns a Clock object. By default, Clock is initialized to the zeroth iteration and first time step stage.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper-Union{Tuple{IT}, Tuple{Any, Any}, Tuple{Any, Any, Any}} where IT","page":"Library","title":"Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper","text":"QuasiAdamsBashforth2TimeStepper(grid, tracers,\n                                Ï‡ = 0.1;\n                                implicit_solver = nothing,\n                                Gâ¿ = TendencyFields(grid, tracers),\n                                Gâ» = TendencyFields(grid, tracers))\n\nReturn a 2nd-order quasi Adams-Bashforth (AB2) time stepper (QuasiAdamsBashforth2TimeStepper) on grid, with tracers, and AB2 parameter Ï‡. The tendency fields Gâ¿ and Gâ» can be specified via  optional kwargs.\n\nThe 2nd-order quasi Adams-Bashforth timestepper steps forward the state Uâ¿ by Î”t via\n\nUâ¿âºÂ¹ = Uâ¿ + Î”t * [(3/2 + Ï‡) * Gâ¿ - (1/2 + Ï‡) * Gâ¿â»Â¹]\n\nwhere Uâ¿ is the state at the n-th timestep, Gâ¿ is the tendency at the n-th timestep, and Gâ¿â»Â¹ is the tendency at the previous timestep (Gâ»).\n\nnote: First timestep\nFor the first timestep, since there are no saved tendencies from the previous timestep, the QuasiAdamsBashforth2TimeStepper performs an Euler timestep:Uâ¿âºÂ¹ = Uâ¿ + Î”t * Gâ¿\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.TimeSteppers.RungeKutta3TimeStepper","page":"Library","title":"Oceananigans.TimeSteppers.RungeKutta3TimeStepper","text":"RungeKutta3TimeStepper{FT, TG} <: AbstractTimeStepper\n\nHolds parameters and tendency fields for a low storage, third-order Runge-Kutta-Wray time-stepping scheme described by Le and Moin (1991).\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TimeSteppers.RungeKutta3TimeStepper-Union{Tuple{TG}, Tuple{TI}, Tuple{Any, Any}} where {TI, TG}","page":"Library","title":"Oceananigans.TimeSteppers.RungeKutta3TimeStepper","text":"RungeKutta3TimeStepper(grid, tracers;\n                       implicit_solver = nothing,\n                       Gâ¿ = TendencyFields(grid, tracers),\n                       Gâ» = TendencyFields(grid, tracers))\n\nReturn a 3rd-order Runge0Kutta timestepper (RungeKutta3TimeStepper) on grid and with tracers. The tendency fields Gâ¿ and Gâ» can be specified via  optional kwargs.\n\nThe scheme described by Le and Moin (1991) (see H. Le, P. Moin (1991)). In a nutshel, the 3rd-order Runge Kutta timestepper steps forward the state Uâ¿ by Î”t via 3 substeps. A pressure correction step is applied after at each substep.\n\nThe state U after each substep m is\n\nUáµâºÂ¹ = Uáµ + Î”t * (Î³áµ * Gáµ + Î¶áµ * Gáµâ»Â¹)\n\nwhere Uáµ is the state at the m-th substep, Gáµ is the tendency at the m-th substep, Gáµâ»Â¹ is the tendency at the previous substep, and constants Î³Â¹ = 815, Î³Â² = 512, Î³Â³ = 34, Î¶Â¹ = 0, Î¶Â² = -1760, Î¶Â³ = -512.\n\nThe state at the first substep is taken to be the one that corresponds to the n-th timestep, UÂ¹ = Uâ¿, and the state after the third substep is then the state at the Uâ¿âºÂ¹ = Uâ´.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.TimeSteppers.time_step!-Tuple{Oceananigans.AbstractModel{<:QuasiAdamsBashforth2TimeStepper}, Any}","page":"Library","title":"Oceananigans.TimeSteppers.time_step!","text":"time_step!(model::AbstractModel{<:QuasiAdamsBashforth2TimeStepper}, Î”t; euler=false)\n\nStep forward model one time step Î”t with a 2nd-order Adams-Bashforth method and pressure-correction substep. Setting euler=true will take a forward Euler time step.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.TimeSteppers.time_step!-Tuple{Oceananigans.AbstractModel{<:RungeKutta3TimeStepper}, Any}","page":"Library","title":"Oceananigans.TimeSteppers.time_step!","text":"time_step!(model::AbstractModel{<:RungeKutta3TimeStepper}, Î”t)\n\nStep forward model one time step Î”t with a 3rd-order Runge-Kutta method. The 3rd-order Runge-Kutta method takes three intermediate substep stages to achieve a single timestep. A pressure correction step is applied at each intermediate stage.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Turbulence-closures","page":"Library","title":"Turbulence closures","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.TurbulenceClosures]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation","page":"Library","title":"Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation","text":"AnisotropicMinimumDissipation{FT} <: AbstractTurbulenceClosure\n\nParameters for the \"anisotropic minimum dissipation\" turbulence closure for large eddy simulation proposed originally by Wybe Rozema, Hyun J. Bae, Parviz Moin, Roel Verstappen (2015) and Mahdi Abkar, Hyun J. Bae, Parviz Moin (2016), then modified by Roel Verstappen (2018), and finally described and validated for by Catherine A. Vreugdenhil, John R. Taylor (2018).\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation-Union{Tuple{}, Tuple{TD}, Tuple{TD, Any}} where TD","page":"Library","title":"Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation","text":"AnisotropicMinimumDissipation([time_discretization = ExplicitTimeDiscretization, FT = Float64;]\n                              C = 1/12, CÎ½ = nothing, CÎº = nothing, Cb = nothing)\n\nReturn parameters of type FT for the AnisotropicMinimumDissipation turbulence closure.\n\nKeyword arguments\n\nC: PoincareÌ constant for both eddy viscosity and eddy diffusivities. C is overridden      for eddy viscosity or eddy diffusivity if CÎ½ or CÎº are set, respecitvely.\nCÎ½: PoincareÌ constant for momentum eddy viscosity.\nCÎº: PoincareÌ constant for tracer eddy diffusivities. If one number or function, the same       number or function is applied to all tracers. If a NamedTuple, it must possess       a field specifying the PoncareÌ constant for every tracer.\nCb: Buoyancy modification multiplier (Cb = nothing turns it off, Cb = 1 was used by Mahdi Abkar, Hyun J. Bae, Parviz Moin (2016)).       Note: that we do not subtract the horizontally-average component before computing this       buoyancy modification term. This implementation differs from Mahdi Abkar, Hyun J. Bae, Parviz Moin (2016)'s proposal       and the impact of this approximation has not been tested or validated.\ntime_discretization: Either ExplicitTimeDiscretization() or VerticallyImplicitTimeDiscretization(),                         which integrates the terms involving only z-derivatives in the                        viscous and diffusive fluxes with an implicit time discretization.\n\nBy default: C = CÎ½ = CÎº = 1/12, which is appropriate for a finite-volume method employing a second-order advection scheme, Cb = nothing, which terms off the buoyancy modification term.\n\nCÎ½ or CÎº may be constant numbers, or functions of x, y, z.\n\nExamples\n\njulia> using Oceananigans\n\njulia> pretty_diffusive_closure = AnisotropicMinimumDissipation(C=1/2)\nAnisotropicMinimumDissipation{ExplicitTimeDiscretization} turbulence closure with:\n           PoincareÌ constant for momentum eddy viscosity CÎ½: 0.5\n    PoincareÌ constant for tracer(s) eddy diffusivit(ies) CÎº: 0.5\n                        Buoyancy modification multiplier Cb: nothing\n\njulia> using Oceananigans\n\njulia> const Î”z = 0.5; # grid resolution at surface\n\njulia> surface_enhanced_tracer_C(x, y, z) = 1/12 * (1 + exp((z + Î”z/2) / 8Î”z));\n\njulia> fancy_closure = AnisotropicMinimumDissipation(CÎº=surface_enhanced_tracer_C)\nAnisotropicMinimumDissipation{ExplicitTimeDiscretization} turbulence closure with:\n           PoincareÌ constant for momentum eddy viscosity CÎ½: 0.08333333333333333\n    PoincareÌ constant for tracer(s) eddy diffusivit(ies) CÎº: surface_enhanced_tracer_C\n                        Buoyancy modification multiplier Cb: nothing\n\njulia> using Oceananigans\n\njulia> tracer_specific_closure = AnisotropicMinimumDissipation(CÎº=(câ‚=1/12, câ‚‚=1/6))\nAnisotropicMinimumDissipation{ExplicitTimeDiscretization} turbulence closure with:\n           PoincareÌ constant for momentum eddy viscosity CÎ½: 0.08333333333333333\n    PoincareÌ constant for tracer(s) eddy diffusivit(ies) CÎº: (câ‚ = 0.08333333333333333, câ‚‚ = 0.16666666666666666)\n                        Buoyancy modification multiplier Cb: nothing\n\nReferences\n\nVreugdenhil C., and Taylor J. (2018), \"Large-eddy simulations of stratified plane Couette     flow using the anisotropic minimum-dissipation model\", Physics of Fluids 30, 085104.\n\nVerstappen, R. (2018), \"How much eddy dissipation is needed to counterbalance the nonlinear     production of small, unresolved scales in a large-eddy simulation of turbulence?\",     Computers & Fluids 176, pp. 276-284.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.ConvectiveAdjustmentVerticalDiffusivity","page":"Library","title":"Oceananigans.TurbulenceClosures.ConvectiveAdjustmentVerticalDiffusivity","text":"ConvectiveAdjustmentVerticalDiffusivity([time_discretization = VerticallyImplicitTimeDiscretization(), FT=Float64;]\n                                        convective_Îºz = 0,\n                                        convective_Î½z = 0,\n                                        background_Îºz = 0,\n                                        background_Î½z = 0)\n\nReturn a convective adjustment vertical diffusivity closure that applies different values of diffusivity and/or viscosity depending whether the region is statically stable (positive or zero buoyancy gradient) or statically unstable (negative buoyancy gradient).\n\nArguments\n\ntime_discretization: Either ExplicitTimeDiscretization() or VerticallyImplicitTimeDiscretization();                        default VerticallyImplicitTimeDiscretization().\nFT: Float type; default Float64.\n\nKeyword arguments\n\nconvective_Îºz: Vertical tracer diffusivity in regions with negative (unstable) buoyancy gradients. Either                  a single number, function, array, field, or tuple of diffusivities for each tracer.\nbackground_Îºz: Vertical tracer diffusivity in regions with zero or positive (stable) buoyancy gradients.\nconvective_Î½z: Vertical viscosity in regions with negative (unstable) buoyancy gradients. Either                 a number, function, array, or field.\nbackground_Îºz: Vertical viscosity in regions with zero or positive (stable) buoyancy gradients.\n\nExample\n\njulia> using Oceananigans\n\njulia> cavd = ConvectiveAdjustmentVerticalDiffusivity(convective_Îºz = 1)\nConvectiveAdjustmentVerticalDiffusivity{VerticallyImplicitTimeDiscretization}(background_Îºz=0.0 convective_Îºz=1 background_Î½z=0.0 convective_Î½z=0.0)\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization","page":"Library","title":"Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization","text":"struct ExplicitTimeDiscretization <: AbstractTimeDiscretization\n\nA fully-explicit time-discretization of a TurbulenceClosure.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.HorizontalDivergenceScalarDiffusivity","page":"Library","title":"Oceananigans.TurbulenceClosures.HorizontalDivergenceScalarDiffusivity","text":"HorizontalDivergenceScalarDiffusivity([time_discretization=ExplicitTimeDiscretization(),\n                                      FT::DataType=Float64;]\n                                      kwargs...)\n\nShorthand for a ScalarDiffusivity with HorizontalDivergenceFormulation(). See ScalarDiffusivity.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.HorizontalScalarDiffusivity","page":"Library","title":"Oceananigans.TurbulenceClosures.HorizontalScalarDiffusivity","text":"HorizontalScalarDiffusivity([time_discretization=ExplicitTimeDiscretization(),\n                            FT::DataType=Float64;]\n                            kwargs...)\n\nShorthand for a ScalarDiffusivity with HorizontalFormulation(). See ScalarDiffusivity.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.IsopycnalSkewSymmetricDiffusivity-Union{Tuple{}, Tuple{TD}, Tuple{TD, Any}} where TD","page":"Library","title":"Oceananigans.TurbulenceClosures.IsopycnalSkewSymmetricDiffusivity","text":"IsopycnalSkewSymmetricDiffusivity([time_disc=VerticallyImplicitTimeDiscretization(), FT=Float64;]\n                                  Îº_skew = 0,\n                                  Îº_symmetric = 0,\n                                  isopycnal_tensor = SmallSlopeIsopycnalTensor(),\n                                  slope_limiter = FluxTapering(1e-2))\n\nReturn parameters for an isopycnal skew-symmetric tracer diffusivity with skew diffusivity Îº_skew and symmetric diffusivity Îº_symmetric that uses an isopycnal_tensor model for for calculating the isopycnal slopes, and (optionally) applying a slope_limiter to the calculated isopycnal slope values.\n\nBoth Îº_skew and Îº_symmetric may be constants, arrays, fields, or functions of (x, y, z, t).\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.RiBasedVerticalDiffusivity","page":"Library","title":"Oceananigans.TurbulenceClosures.RiBasedVerticalDiffusivity","text":"RiBasedVerticalDiffusivity([time_discretization = VerticallyImplicitTimeDiscretization(),\n                           FT = Float64;]\n                           Ri_dependent_tapering = HyperbolicTangentRiDependentTapering(),\n                           Î½â‚€  = 0.7,\n                           Îºâ‚€  = 0.5,\n                           Îºá¶œáµƒ = 1.7,\n                           Cáµ‰â¿ = 0.1,\n                           Cáµƒáµ› = 0.6,\n                           Riâ‚€ = 0.1,\n                           RiáµŸ = 0.4,\n                           warning = true)\n\nReturn a closure that estimates the vertical viscosity and diffusivity from \"convective adjustment\" coefficients Î½â‚€ and Îºâ‚€ multiplied by a decreasing function of the Richardson number, Ri. \n\nArguments\n\ntime_discretization: Either ExplicitTimeDiscretization() or VerticallyImplicitTimeDiscretization(),                         which integrates the terms involving only z-derivatives in the                        viscous and diffusive fluxes with an implicit time discretization.                        Default VerticallyImplicitTimeDiscretization().\nFT: Float type; default Float64.\n\nKeyword arguments\n\nRi_dependent_tapering: The Ri-dependent tapering. Options are: PiecewiseLinearRiDependentTapering(), HyperbolicTangentRiDependentTapering() (default), and ExponentialRiDependentTapering().\nÎ½â‚€: Non-convective viscosity.\nÎºâ‚€: Non-convective diffusivity for tracers.\nÎºá¶œáµƒ: Convective adjustment diffusivity for tracers.\nCáµ‰â¿: Entrainment coefficient for tracers.\nCáµƒáµ›: Time-averaging coefficient for viscosity and diffusivity.\nRiâ‚€: Ri threshold for decreasing viscosity and diffusivity.\nRiáµŸ: Ri-width over which viscosity and diffusivity decreases to 0.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.ScalarBiharmonicDiffusivity","page":"Library","title":"Oceananigans.TurbulenceClosures.ScalarBiharmonicDiffusivity","text":"ScalarBiharmonicDiffusivity([formulation=ThreeDimensionalFormulation(), FT=Float64;]\n                            Î½=0, Îº=0,\n                            discrete_form = false)\n\nReturn a scalar biharmonic diffusivity turbulence closure with viscosity coefficient Î½ and tracer diffusivities Îº for each tracer field in tracers. If a single Îº is provided, it is applied to all tracers. Otherwise Îº must be a NamedTuple with values for every tracer individually.\n\nArguments\n\nformulation:\nHorizontalFormulation() for diffusivity applied in the horizontal direction(s)\nVerticalFormulation() for diffusivity applied in the vertical direction,\nThreeDimensionalFormulation() (default) for diffusivity applied isotropically to all directions\nFT: the float datatype (default: Float64)\n\nKeyword arguments\n\nÎ½: Viscosity. Number, AbstractArray, Field, or Function.\nÎº: Diffusivity. Number, three-dimensional AbstractArray, Field, Function, or      NamedTuple of diffusivities with entries for each tracer.\ndiscrete_form: Boolean; default: False.\n\nWhen prescribing the viscosities or diffusivities as functions, depending on the value of keyword argument discrete_form, the constructor expects:\n\ndiscrete_form = false (default): functions of the grid's native coordinates and time, e.g., (x, y, z, t) for a RectilinearGrid or (Î», Ï†, z, t) for a LatitudeLongitudeGrid.\ndiscrete_form = true: functions of (i, j, k, grid, â„“x, â„“y, â„“z) with â„“x, â„“y and â„“z either Face() or Center().\n\nFor examples see ScalarDiffusivity.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.ScalarBiharmonicDiffusivity-2","page":"Library","title":"Oceananigans.TurbulenceClosures.ScalarBiharmonicDiffusivity","text":"struct ScalarBiharmonicDiffusivity{F, N, K} <: AbstractScalarBiharmonicDiffusivity{F}\n\nHolds viscosity and diffusivities for models with prescribed isotropic diffusivities.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.ScalarDiffusivity","page":"Library","title":"Oceananigans.TurbulenceClosures.ScalarDiffusivity","text":"ScalarDiffusivity([time_discretization=ExplicitTimeDiscretization(),\n                  formulation=ThreeDimensionalFormulation(), FT=Float64];\n                  Î½=0, Îº=0,\n                  discrete_form = false)\n\nReturn ScalarDiffusivity turbulence closure with viscosity Î½ and tracer diffusivities Îº for each tracer field in tracers. If a single Îº is provided, it is applied to all tracers. Otherwise Îº must be a NamedTuple with values for every tracer individually.\n\nArguments\n\ntime_discretization: either ExplicitTimeDiscretization() (default) or VerticallyImplicitTimeDiscretization().\nformulation:\nHorizontalFormulation() for diffusivity applied in the horizontal direction(s)\nVerticalFormulation() for diffusivity applied in the vertical direction,\nThreeDimensionalFormulation() (default) for diffusivity applied isotropically to all directions\nFT: the float datatype (default: Float64)\n\nKeyword arguments\n\nÎ½: Viscosity. Number, three-dimensional AbstractArray, Field, or Function.\nÎº: Diffusivity. Number, AbstractArray, Field, Function, or      NamedTuple of diffusivities with entries for each tracer.\ndiscrete_form: Boolean; default: False.\n\nWhen prescribing the viscosities or diffusivities as functions, depending on the value of keyword argument discrete_form, the constructor expects:\n\ndiscrete_form = false (default): functions of the grid's native coordinates and time, e.g., (x, y, z, t) for a RectilinearGrid or (Î», Ï†, z, t) for a LatitudeLongitudeGrid.\ndiscrete_form = true: functions of (i, j, k, grid, â„“x, â„“y, â„“z) with â„“x, â„“y and â„“z either Face() or Center().\n\nExamples\n\njulia> using Oceananigans\n\njulia> ScalarDiffusivity(Î½ = 1000, Îº=2000)\nScalarDiffusivity{ExplicitTimeDiscretization}(Î½=1000.0, Îº=2000.0)\n\njulia> const depth_scale = 100;\n\njulia> @inline Î½(x, y, z) = 1000 * exp(z / depth_scale)\nÎ½ (generic function with 1 method)\n\njulia> ScalarDiffusivity(Î½ = Î½)\nScalarDiffusivity{ExplicitTimeDiscretization}(Î½=Î½ (generic function with 1 method), Îº=0.0)\n\njulia> using Oceananigans.Grids: znode\n\njulia> @inline function Îº(i, j, k, grid, â„“x, â„“y, â„“z)\n           z = znode(i, j, k, grid, â„“x, â„“y, â„“z)\n           return 2000 * exp(z / depth_scale)\n       end\nÎº (generic function with 1 method)\n\njulia> ScalarDiffusivity(Îº = Îº)\nScalarDiffusivity{ExplicitTimeDiscretization}(Î½=0.0, Îº=Îº (generic function with 1 method))\n\njulia> ScalarDiffusivity(Îº = Îº, discrete_form = true)\nScalarDiffusivity{ExplicitTimeDiscretization}(Î½=0.0, Îº=Oceananigans.TurbulenceClosures.DiscreteDiffusionFunction{Nothing, Nothing, Nothing, Nothing, typeof(Îº)})\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.SmagorinskyLilly-Union{Tuple{}, Tuple{TD}, Tuple{TD, Any}} where TD","page":"Library","title":"Oceananigans.TurbulenceClosures.SmagorinskyLilly","text":"SmagorinskyLilly([time_discretization::TD = ExplicitTimeDiscretization(), FT=Float64;] C=0.16, Cb=1.0, Pr=1.0)\n\nReturn a SmagorinskyLilly type associated with the turbulence closure proposed by Lilly (1962) and Smagorinsky (1958, 1963), which has an eddy viscosity of the form\n\nÎ½â‚‘ = (C * Î”á¶ )Â² * âˆš(2Î£Â²) * âˆš(1 - Cb * NÂ² / Î£Â²)\n\nand an eddy diffusivity of the form\n\nÎºâ‚‘ = Î½â‚‘ / Pr\n\nwhere Î”á¶  is the filter width, Î£Â² = Î£áµ¢â±¼Î£áµ¢â±¼ is the double dot product of the strain tensor Î£áµ¢â±¼, Pr is the turbulent Prandtl number, and NÂ² is the total buoyancy gradient, and Cb is a constant the multiplies the Richardson number modification to the eddy viscosity.\n\nArguments\n\ntime_discretization: Either ExplicitTimeDiscretization() or VerticallyImplicitTimeDiscretization(),                         which integrates the terms involving only z-derivatives in the                        viscous and diffusive fluxes with an implicit time discretization.                        Default ExplicitTimeDiscretization().\nFT: Float type; default Float64.\n\nKeyword arguments\n\nC: Smagorinsky constant. Default value is 0.16 as obtained by Lilly (1966).\nCb: Buoyancy term multipler based on Lilly (1962) (Cb = 0 turns it off, Cb â‰  0 turns it on.       Typically, and according to the original work by Lilly (1962), Cb = 1 / Pr.)\nPr: Turbulent Prandtl numbers for each tracer. Either a constant applied to every       tracer, or a NamedTuple with fields for each tracer individually.\n\nReferences\n\nSmagorinsky, J. \"On the numerical integration of the primitive equations of motion for     baroclinic flow in a closed region.\" Monthly Weather Review (1958)\n\nLilly, D. K. \"On the numerical simulation of buoyant convection.\" Tellus (1962)\n\nSmagorinsky, J. \"General circulation experiments with the primitive equations: I.     The basic experiment.\" Monthly weather review (1963)\n\nLilly, D. K. \"The representation of small-scale turbulence in numerical simulation experiments.\"      NCAR Manuscript No. 281, 0, 1966.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.TwoDimensionalLeith","page":"Library","title":"Oceananigans.TurbulenceClosures.TwoDimensionalLeith","text":"TwoDimensionalLeith(FT=Float64;\n                    C=0.3, C_Redi=1, C_GM=1,\n                    isopycnal_model=SmallSlopeIsopycnalTensor())\n\nReturn a TwoDimensionalLeith type associated with the turbulence closure proposed by Leith (1965) and Fox-Kemper & Menemenlis (2008) which has an eddy viscosity of the form\n\nÎ½â‚‘ = (C * Î”á¶ )Â³ * âˆš(|âˆ‡â‚• Î¶|Â² + |âˆ‡â‚• âˆ‚w/âˆ‚z|Â²)\n\nand an eddy diffusivity of the form...\n\nwhere Î”á¶  is the filter width, Î¶ = âˆ‚v/âˆ‚x - âˆ‚u/âˆ‚y is the vertical vorticity, and C is a model constant.\n\nKeyword arguments\n\nC: Model constant\nC_Redi: Coefficient for down-gradient tracer diffusivity for each tracer.           Either a constant applied to every tracer, or a NamedTuple with fields           for each tracer individually.\nC_GM: Coefficient for down-gradient tracer diffusivity for each tracer.         Either a constant applied to every tracer, or a NamedTuple with fields         for each tracer individually.\n\nReferences\n\nLeith, C. E. (1968). \"Diffusion Approximation for Twoâ€Dimensional Turbulence\", The Physics of     Fluids 11, 671. doi: 10.1063/1.1691968\n\nFoxâ€Kemper, B., & D. Menemenlis (2008), \"Can large eddy simulation techniques improve mesoscale rich     ocean models?\", in Ocean Modeling in an Eddying Regime, Geophys. Monogr. Ser., vol. 177, pp. 319â€“337.     doi: 10.1029/177GM19\n\nPearson, B. et al. (2017) , \"Evaluation of scale-aware subgrid mesoscale eddy models in a global eddy     rich model\", Ocean Modelling 115, 42-58. doi: 10.1016/j.ocemod.2017.05.007\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.VerticalScalarDiffusivity","page":"Library","title":"Oceananigans.TurbulenceClosures.VerticalScalarDiffusivity","text":"VerticalScalarDiffusivity([time_discretization=ExplicitTimeDiscretization(),\n                          FT::DataType=Float64;]\n                          kwargs...)\n\nShorthand for a ScalarDiffusivity with VerticalFormulation(). See ScalarDiffusivity.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.VerticallyImplicitTimeDiscretization","page":"Library","title":"Oceananigans.TurbulenceClosures.VerticallyImplicitTimeDiscretization","text":"struct VerticallyImplicitTimeDiscretization <: AbstractTimeDiscretization\n\nA vertically-implicit time-discretization of a TurbulenceClosure.\n\nThis implies that a flux divergence such as   ğª at the n-th timestep is  time-discretized as\n\n[âˆ‡ â‹… q]â¿ = [explicit_flux_divergence]â¿ + [âˆ‚z (Îº âˆ‚z c)]â¿âºÂ¹\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.diffusivity","page":"Library","title":"Oceananigans.TurbulenceClosures.diffusivity","text":"diffusivity(closure, tracer_index, diffusivity_fields)\n\nReturns the scalar diffusivity associated with closure and tracer_index.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.viscosity","page":"Library","title":"Oceananigans.TurbulenceClosures.viscosity","text":"viscosity(closure, diffusivities)\n\nReturns the scalar viscosity associated with closure.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Utilities","page":"Library","title":"Utilities","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Utils]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.Utils.AndSchedule-Tuple","page":"Library","title":"Oceananigans.Utils.AndSchedule","text":"AndSchedule(schedules...)\n\nReturn a schedule that actuates when all child_schedules actuate.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Utils.IterationInterval-Tuple{Any}","page":"Library","title":"Oceananigans.Utils.IterationInterval","text":"IterationInterval(interval; offset=0)\n\nReturn a callable IterationInterval that \"actuates\" (schedules output or callback execution) whenever the model iteration (modified by offset) is a multiple of interval.\n\nFor example, \n\nIterationInterval(100) actuates at iterations [100, 200, 300, ...].\nIterationInterval(100, offset=-1) actuates at iterations [99, 199, 299, ...].\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Utils.MultiRegionObject-Tuple{Tuple}","page":"Library","title":"Oceananigans.Utils.MultiRegionObject","text":"MultiRegionObject(regional_objects::Tuple; devices)\n\nReturn a MultiRegionObject\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Utils.OrSchedule-Tuple","page":"Library","title":"Oceananigans.Utils.OrSchedule","text":"OrSchedule(schedules...)\n\nReturn a schedule that actuates when any of the child_schedules actuates.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Utils.SpecifiedTimes-Tuple{Vararg{Number}}","page":"Library","title":"Oceananigans.Utils.SpecifiedTimes","text":"SpecifiedTimes(times)\n\nReturn a callable TimeInterval that \"actuates\" (schedules output or callback execution) whenever the model's clock equals the specified values in times. For example, \n\nSpecifiedTimes([1, 15.3]) actuates when model.clock.time is 1 and 15.3.\n\ninfo: Sorting specified times\nThe specified times need not be ordered as the SpecifiedTimes constructor will check and order them in ascending order if needed.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Utils.TimeInterval","page":"Library","title":"Oceananigans.Utils.TimeInterval","text":"struct TimeInterval <: AbstractSchedule\n\nCallable TimeInterval schedule for periodic output or diagnostic evaluation according to model.clock.time.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Utils.TimeInterval-Tuple{Any}","page":"Library","title":"Oceananigans.Utils.TimeInterval","text":"TimeInterval(interval)\n\nReturn a callable TimeInterval that schedules periodic output or diagnostic evaluation on a interval of simulation time, as kept by model.clock.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Utils.WallTimeInterval-Tuple{Any}","page":"Library","title":"Oceananigans.Utils.WallTimeInterval","text":"WallTimeInterval(interval; start_time = time_ns() * 1e-9)\n\nReturn a callable WallTimeInterval that schedules periodic output or diagnostic evaluation on a interval of \"wall time\" while a simulation runs, in units of seconds.\n\nThe \"wall time\" is the actual real world time in seconds, as kept by an actual or hypothetical clock hanging on your wall.\n\nThe keyword argument start_time can be used to specify a starting wall time other than the moment WallTimeInterval is constructed.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Utils.launch!-Tuple{Any, Any, Any, Any, Vararg{Any}}","page":"Library","title":"Oceananigans.Utils.launch!","text":"launch!(arch, grid, layout, kernel!, args...; kwargs...)\n\nLaunches kernel!, with arguments args and keyword arguments kwargs, over the dims of grid on the architecture arch. kernels run on the defaul stream\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Utils.pretty_filesize","page":"Library","title":"Oceananigans.Utils.pretty_filesize","text":"pretty_filesize(s, suffix=\"B\")\n\nConvert a floating point value s representing a file size to a more human-friendly formatted string with one decimal places with a suffix defaulting to \"B\". Depending on the value of s the string will be formatted to show s using an SI prefix from bytes, kiB (1024 bytes), MiB (1024Â² bytes), and so on up to YiB (1024â¸ bytes).\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.Utils.prettytime","page":"Library","title":"Oceananigans.Utils.prettytime","text":"prettytime(t, longform=true)\n\nConvert a floating point value t representing an amount of time in SI units of seconds to a human-friendly string with three decimal places. Depending on the value of t the string will be formatted to show t in nanoseconds (ns), microseconds (Î¼s), milliseconds (ms), seconds, minutes, hours, or days.\n\nWith longform=false, we use s, m, hrs, and d in place of seconds, minutes, and hours.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.Utils.with_tracers-Tuple{Any, NamedTuple, Any}","page":"Library","title":"Oceananigans.Utils.with_tracers","text":"with_tracers(tracer_names, initial_tuple, tracer_default)\n\nCreate a tuple corresponding to the solution variables u, v, w, and tracer_names. initial_tuple is a NamedTuple that at least has fields u, v, and w, and may have some fields corresponding to the names in tracer_names. tracer_default is a function that produces a default tuple value for each tracer if not included in initial_tuple.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Utils.work_layout-Tuple{Any, Symbol}","page":"Library","title":"Oceananigans.Utils.work_layout","text":"work_layout(grid, dims; include_right_boundaries=false, location=nothing)\n\nReturns the workgroup and worksize for launching a kernel over dims on grid. The workgroup is a tuple specifying the threads per block in each dimension. The worksize specifies the range of the loop in each dimension.\n\nSpecifying include_right_boundaries=true will ensure the work layout includes the right face end points along bounded dimensions. This requires the field location to be specified.\n\nFor more information, see: https://github.com/CliMA/Oceananigans.jl/pull/308\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Utils.@apply_regionally-Tuple{Any}","page":"Library","title":"Oceananigans.Utils.@apply_regionally","text":"@apply_regionally expr\n\nUse @apply_regionally to distribute locally the function calls. Call compute_regionally in case of a returning value and apply_regionally!  in case of no return.\n\n\n\n\n\n","category":"macro"},{"location":"appendix/library/#Units","page":"Library","title":"Units","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Units]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.Units.GiB","page":"Library","title":"Oceananigans.Units.GiB","text":"GiB\n\nA Float64 constant equal to 1024MiB. Useful for increasing the clarity of scripts, e.g. max_filesize = 50GiB.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.KiB","page":"Library","title":"Oceananigans.Units.KiB","text":"KiB\n\nA Float64 constant equal to 1024.0. Useful for increasing the clarity of scripts, e.g. max_filesize = 250KiB.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.MiB","page":"Library","title":"Oceananigans.Units.MiB","text":"MiB\n\nA Float64 constant equal to 1024KiB. Useful for increasing the clarity of scripts, e.g. max_filesize = 100MiB.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.TiB","page":"Library","title":"Oceananigans.Units.TiB","text":"TiB\n\nA Float64 constant equal to 1024GiB. Useful for increasing the clarity of scripts, e.g. max_filesize = 2TiB.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.day","page":"Library","title":"Oceananigans.Units.day","text":"day\n\nA Float64 constant equal to 24hours. Useful for increasing the clarity of scripts, e.g. stop_time = 1day.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.days","page":"Library","title":"Oceananigans.Units.days","text":"days\n\nA Float64 constant equal to 24hours. Useful for increasing the clarity of scripts, e.g. stop_time = 7days.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.hour","page":"Library","title":"Oceananigans.Units.hour","text":"hour\n\nA Float64 constant equal to 60minutes. Useful for increasing the clarity of scripts, e.g. Î”t = 1hour.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.hours","page":"Library","title":"Oceananigans.Units.hours","text":"hours\n\nA Float64 constant equal to 60minutes. Useful for increasing the clarity of scripts, e.g. Î”t = 3hours.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.kilometer","page":"Library","title":"Oceananigans.Units.kilometer","text":"kilometer\n\nA Float64 constant equal to 1000meters. Useful for increasing the clarity of scripts, e.g. Lx = 1kilometer.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.kilometers","page":"Library","title":"Oceananigans.Units.kilometers","text":"kilometers\n\nA Float64 constant equal to 1000meters. Useful for increasing the clarity of scripts, e.g. Lx = 5000kilometers.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.meter","page":"Library","title":"Oceananigans.Units.meter","text":"meter\n\nA Float64 constant equal to 1.0. Useful for increasing the clarity of scripts, e.g. Lx = 1meter.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.meters","page":"Library","title":"Oceananigans.Units.meters","text":"meters\n\nA Float64 constant equal to 1.0. Useful for increasing the clarity of scripts, e.g. Lx = 50meters.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.minute","page":"Library","title":"Oceananigans.Units.minute","text":"minute\n\nA Float64 constant equal to 60seconds. Useful for increasing the clarity of scripts, e.g. Î”t = 1minute.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.minutes","page":"Library","title":"Oceananigans.Units.minutes","text":"minutes\n\nA Float64 constant equal to 60seconds. Useful for increasing the clarity of scripts, e.g. Î”t = 15minutes.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.second","page":"Library","title":"Oceananigans.Units.second","text":"second\n\nA Float64 constant equal to 1.0. Useful for increasing the clarity of scripts, e.g. Î”t = 1second.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.seconds","page":"Library","title":"Oceananigans.Units.seconds","text":"seconds\n\nA Float64 constant equal to 1.0. Useful for increasing the clarity of scripts, e.g. Î”t = 7seconds.\n\n\n\n\n\n","category":"constant"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"EditURL = \"<unknown>/examples/kelvin_helmholtz_instability.jl\"","category":"page"},{"location":"generated/kelvin_helmholtz_instability/#Stratified-Kelvin-Helmholtz-instability","page":"Kelvin-Helmholtz instability","title":"Stratified Kelvin-Helmholtz instability","text":"","category":"section"},{"location":"generated/kelvin_helmholtz_instability/#Install-dependencies","page":"Kelvin-Helmholtz instability","title":"Install dependencies","text":"","category":"section"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"using Pkg\npkg\"add Oceananigans, CairoMakie\"","category":"page"},{"location":"generated/kelvin_helmholtz_instability/#The-physical-domain","page":"Kelvin-Helmholtz instability","title":"The physical domain","text":"","category":"section"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"We simulate a Kelvin-Helmholtz instability in two-dimensions in x z and therefore assign Flat to the y direction,","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"using Oceananigans\n\ngrid = RectilinearGrid(size=(64, 64), x=(-5, 5), z=(-5, 5),\n                       topology=(Periodic, Flat, Bounded))","category":"page"},{"location":"generated/kelvin_helmholtz_instability/#The-basic-state","page":"Kelvin-Helmholtz instability","title":"The basic state","text":"","category":"section"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"We're simulating the instability of a sheared and stably-stratified basic state U(z) and B(z). Two parameters define our basic state: the Richardson number,","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Ri = frac_z B(_z U)^2 ","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"and the width of the stratification layer, h.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"shear_flow(x, y, z, t) = tanh(z)\n\nstratification(x, y, z, t, p) = p.h * p.Ri * tanh(z / p.h)\n\nU = BackgroundField(shear_flow)\n\nB = BackgroundField(stratification, parameters=(Ri=0.1, h=1/4))","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Our basic state thus has a thin layer of stratification in the center of the channel, embedded within a thicker shear layer surrounded by unstratified fluid.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"using CairoMakie\n\nzF = znodes(grid, Face())\nzC = znodes(grid, Center())\n\nRi, h = B.parameters\n\nfig = Figure(resolution = (850, 450))\n\nax = Axis(fig[1, 1], xlabel = \"U(z)\", ylabel = \"z\")\nlines!(ax, shear_flow.(0, 0, zC, 0), zC; linewidth = 3)\n\nax = Axis(fig[1, 2], xlabel = \"B(z)\")\nlines!(ax, [stratification(0, 0, z, 0, (Ri=Ri, h=h)) for z in zC], zC; linewidth = 3, color = :red)\n\nax = Axis(fig[1, 3], xlabel = \"Ri(z)\")\nlines!(ax, [Ri * sech(z / h)^2 / sech(z)^2 for z in zF], zF; linewidth = 3, color = :black) # Ri(z)= âˆ‚_z B / (âˆ‚_z U)Â²; derivatives computed by hand\n\ncurrent_figure() # hide\nfig","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"In unstable flows it is often useful to determine the dominant spatial structure of the instability and the growth rate at which the instability grows. If the simulation idealizes a physical flow, this can be used to make predictions as to what should develop and how quickly. Since these instabilities are often attributed to a linear instability, we can determine information about the structure and the growth rate of the instability by analyzing the linear operator that governs small perturbations about a base state, or by solving for the linear dynamics.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Here, we discuss first briefly linear instabilities and how one can obtain growth rates and structures of most unstable modes via eigenanalysis. Then we present an alternative method for approximating the eigenanalysis results when one does not have access to the linear dynamics or the linear operator about the base state.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/#Linear-Instabilities","page":"Kelvin-Helmholtz instability","title":"Linear Instabilities","text":"","category":"section"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"The base state U(z), B(z) is a solution of the inviscid equations of motion. Whether the base state is stable or not is determined by whether small perturbations about this base state grow or decay. To formalize this, we study the linearized dynamics satisfied by perturbations about the base state:","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"partial_t Phi = L Phi  ","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"where Phi = (u v w b) is a vector of the perturbation velocities u v w and perturbation buoyancy b and L a linear operator that depends on the base state, L = L(U(z) B(z)) (the background_fields). Eigenanalysis of the linear operator L determines the stability of the base state, such as the Kelvin-Helmholtz instability. That is, by using the ansantz","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Phi(x y z t) = phi(x y z)  exp(lambda t)  ","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"then lambda and phi are respectively eigenvalues and eigenmodes of L, i.e., they obey","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"L  phi_j = lambda_j  phi_j quad j=12dots  ","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"From hereafter we'll use the convention that the eigenvalues are ordered according to their real part, mathrmRe(lambda_1) ge mathrmRe(lambda_2) ge dotsb.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Remarks:","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"As we touched upon briefly above, Oceananigans.jl, does not include the linearized version of the equations. Furthermore, Oceananigans.jl does not give us access to the linear operator L so that we can perform eigenanalysis. Below we discuss an alternative way of approximating the eigenanalysis results. The method boils down to solving the nonlinear equations while continually renormalize the magnitude of the perturbations to ensure that nonlinear terms (terms that are quadratic or higher in perturbations) remain negligibly small, i.e.,much smaller than the background flow.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/#The-power-method-algorithm","page":"Kelvin-Helmholtz instability","title":"The power method algorithm","text":"","category":"section"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Successive application of L to a random initial state will eventually render it parallel with eigenmode phi_1:","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"lim_n to infty L^n Phi propto phi_1  ","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Of course, if phi_1 is an unstable mode (i.e., sigma_1 = mathrmRe(lambda_1)  0), then successive application of L will lead to exponential amplification. (Similarly, if sigma_1  0, successive application of L will lead to exponential decay of Phi down to machine precision.) Therefore, after each application of the linear operator L, we rescale the output L Phi back to a pre-selected amplitude.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"So, we initialize a simulation with random initial conditions with amplitude much less than those of the base state (which are O(1)). Instead of \"applying\" L on our initial state, we evolve the (approximately) linear dynamics for interval Delta tau. We measure how much the energy has grown during that interval, rescale the perturbations back to original energy amplitude and repeat. After some iterations the state will converge to the most unstable eigenmode.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"In summary, each iteration of the power method includes:","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"compute the perturbation energy, E_0,\nevolve the system for a time-interval Delta tau,\ncompute the perturbation energy, E_1,\ndetermine the exponential growth of the most unstable mode during the interval Delta tau as  log(E_1  E_0)  (2 Delta tau),\nrepeat the above until growth rate converges.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"By fiddling a bit with Delta t we can get convergence after only a few iterations.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Let's apply all these to our example.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/#The-model","page":"Kelvin-Helmholtz instability","title":"The model","text":"","category":"section"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"model = NonhydrostaticModel(timestepper = :RungeKutta3,\n                              advection = UpwindBiasedFifthOrder(),\n                                   grid = grid,\n                               coriolis = nothing,\n                      background_fields = (u=U, b=B),\n                                closure = ScalarDiffusivity(Î½=2e-4, Îº=2e-4),\n                               buoyancy = BuoyancyTracer(),\n                                tracers = :b)","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"We have included a \"pinch\" of viscosity and diffusivity in anticipation of what will follow furtherdown: viscosity and diffusivity will ensure numerical stability when we evolve the unstable mode to the point it becomes nonlinear.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Here, we take Delta tau = 15.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"simulation = Simulation(model, Î”t=0.1, stop_iteration=150)","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Now some helper functions that will be used during for the power method algorithm.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"First a function that evolves the state for Delta tau and measure the energy growth over that period.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"\"\"\"\n    grow_instability!(simulation, energy)\n\nGrow an instability by running `simulation`.\n\nEstimates the growth rate ``Ïƒ`` of the instability\nusing the fractional change in volume-mean kinetic energy,\nover the course of the `simulation`\n\n``\nenergy(tâ‚€ + Î”Ï„) / energy(tâ‚€) â‰ˆ exp(2 Ïƒ Î”Ï„)\n``\n\nwhere ``tâ‚€`` is the starting time of the simulation and ``tâ‚€ + Î”Ï„``\nthe ending time of the simulation. We thus find that the growth rate\nis measured by\n\n``\nÏƒ = log(energy(tâ‚€ + Î”Ï„) / energy(tâ‚€)) / (2 Î”Ï„) .\n``\n\"\"\"\nfunction grow_instability!(simulation, energy)\n    # Initialize\n    simulation.model.clock.iteration = 0\n    tâ‚€ = simulation.model.clock.time = 0\n    compute!(energy)\n    energyâ‚€ = energy[1, 1, 1]\n\n    # Grow\n    run!(simulation)\n\n    # Analyze\n    compute!(energy)\n    energyâ‚ = energy[1, 1, 1]\n    Î”Ï„ = simulation.model.clock.time - tâ‚€\n\n    # Â½(uÂ² + vÂ²) ~ exp(2 Ïƒ Î”Ï„)\n    Ïƒ = growth_rate = log(energyâ‚ / energyâ‚€) / 2Î”Ï„\n\n    return growth_rate\nend\nnothing # hide","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Finally, we write a function that rescales the state. The rescaling is done via computing the kinetic energy and then rescaling all flow fields so that the kinetic energy assumes a targetted value.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"(Measuring the perturbation growth via the kinetic energy works fine unless an unstable mode only has buoyancy structure. In that case, the total perturbation energy is more adequate.)","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"\"\"\"\n    rescale!(model, energy; target_kinetic_energy = 1e-3)\n\nRescales all model fields so that `energy = target_kinetic_energy`.\n\"\"\"\nfunction rescale!(model, energy; target_kinetic_energy = 1e-6)\n    compute!(energy)\n    rescale_factor = âˆš(target_kinetic_energy / energy[1, 1, 1])\n\n    for f in merge(model.velocities, model.tracers)\n        f .*= rescale_factor\n    end\n\n    return nothing\nend\n\nusing Printf","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Another helper function for the power method,","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"\"\"\"\n    convergence(Ïƒ)\n\nCheck if the growth rate has converged. If the array `Ïƒ` has at least 2 elements then returns the\nrelative difference between ``Ïƒ[end]`` and ``Ïƒ[end-1]``.\n\"\"\"\nconvergence(Ïƒ) = length(Ïƒ) > 1 ? abs((Ïƒ[end] - Ïƒ[end-1]) / Ïƒ[end]) : 9.1e18 # pretty big (not Inf tho)\nnothing # hide","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"and the main function that performs the power method iteration.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"\"\"\"\n    estimate_growth_rate(simulation, energy, Ï‰; convergence_criterion=1e-3)\n\nEstimates the growth rate iteratively until the relative change\nin the estimated growth rate ``Ïƒ`` falls below `convergence_criterion`.\n\nReturns ``Ïƒ``.\n\"\"\"\nfunction estimate_growth_rate(simulation, energy, Ï‰, b; convergence_criterion=1e-3)\n    Ïƒ = []\n    power_method_data = []\n    compute!(Ï‰)\n    push!(power_method_data, (Ï‰=collect(interior(Ï‰)[:, 1, :]), b=collect(interior(b)[:, 1, :]), Ïƒ=deepcopy(Ïƒ)))\n\n    while convergence(Ïƒ) > convergence_criterion\n        compute!(energy)\n\n        @info @sprintf(\"About to start power method iteration %d; kinetic energy: %.2e\", length(Ïƒ)+1, energy[1, 1, 1])\n        push!(Ïƒ, grow_instability!(simulation, energy))\n        compute!(energy)\n\n        @info @sprintf(\"Power method iteration %d, kinetic energy: %.2e, Ïƒâ¿: %.2e, relative Î”Ïƒ: %.2e\",\n                       length(Ïƒ), energy[1, 1, 1], Ïƒ[end], convergence(Ïƒ))\n\n        compute!(Ï‰)\n        rescale!(simulation.model, energy)\n        push!(power_method_data, (Ï‰=collect(interior(Ï‰)[:, 1, :]), b=collect(interior(b)[:, 1, :]), Ïƒ=deepcopy(Ïƒ)))\n    end\n\n    return Ïƒ, power_method_data\nend\nnothing # hide","category":"page"},{"location":"generated/kelvin_helmholtz_instability/#Eigenplotting","page":"Kelvin-Helmholtz instability","title":"Eigenplotting","text":"","category":"section"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"A good algorithm wouldn't be complete without a good visualization,","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"u, v, w = model.velocities\nb = model.tracers.b\n\nperturbation_vorticity = Field(âˆ‚z(u) - âˆ‚x(w))\n\nxÏ‰, yÏ‰, zÏ‰ = nodes(perturbation_vorticity)\nxb, yb, zb = nodes(b)","category":"page"},{"location":"generated/kelvin_helmholtz_instability/#Rev-your-engines...","page":"Kelvin-Helmholtz instability","title":"Rev your engines...","text":"","category":"section"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"We initialize the power iteration with random noise and rescale to have a target_kinetic_energy","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"using Random, Statistics\n\nmean_perturbation_kinetic_energy = Field(Average(1/2 * (u^2 + w^2)))\nnoise(x, y, z) = randn()\nset!(model, u=noise, w=noise, b=noise)\nrescale!(simulation.model, mean_perturbation_kinetic_energy, target_kinetic_energy=1e-6)\ngrowth_rates, power_method_data = estimate_growth_rate(simulation, mean_perturbation_kinetic_energy, perturbation_vorticity, b)\n\n@info \"Power iterations converged! Estimated growth rate: $(growth_rates[end])\"","category":"page"},{"location":"generated/kelvin_helmholtz_instability/#Powerful-convergence","page":"Kelvin-Helmholtz instability","title":"Powerful convergence","text":"","category":"section"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"We animate the power method steps. A scatter plot illustrates how the growth rate converges as the power method iterates.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"n = Observable(1)\n\nfig = Figure(resolution=(800, 600))\n\nkwargs = (xlabel=\"x\", ylabel=\"z\", limits = ((xÏ‰[1], xÏ‰[end]), (zÏ‰[1], zÏ‰[end])), aspect=1,)\n\nÏ‰_title(t) = t === nothing ? @sprintf(\"vorticity\") : @sprintf(\"vorticity at t = %.2f\", t)\nb_title(t) = t === nothing ? @sprintf(\"buoyancy\")  : @sprintf(\"buoyancy at t = %.2f\", t)\n\nax_Ï‰ = Axis(fig[2, 1]; title = Ï‰_title(nothing), kwargs...)\n\nax_b = Axis(fig[2, 3]; title = b_title(nothing), kwargs...)\n\nÏ‰â‚™ = @lift power_method_data[$n].Ï‰\nbâ‚™ = @lift power_method_data[$n].b\n\nÏƒâ‚™ = @lift [(i-1, i==1 ? NaN : growth_rates[i-1]) for i in 1:$n]\n\nÏ‰_lims = @lift (-maximum(abs, power_method_data[$n].Ï‰) - 1e-16, maximum(abs, power_method_data[$n].Ï‰) + 1e-16)\nb_lims = @lift (-maximum(abs, power_method_data[$n].b) - 1e-16, maximum(abs, power_method_data[$n].b) + 1e-16)\n\nhm_Ï‰ = heatmap!(ax_Ï‰, xÏ‰, zÏ‰, Ï‰â‚™; colorrange = Ï‰_lims, colormap = :balance)\nColorbar(fig[2, 2], hm_Ï‰)\n\nhm_b = heatmap!(ax_b, xb, zb, bâ‚™; colorrange = b_lims, colormap = :balance)\nColorbar(fig[2, 4], hm_b)\n\neigentitle(Ïƒ, t) = length(Ïƒ) > 0 ? @sprintf(\"Iteration #%i; growth rate %.2e\", length(Ïƒ), Ïƒ[end]) : @sprintf(\"Initial perturbation fields\")\nÏƒ_title = @lift eigentitle(power_method_data[$n].Ïƒ, nothing)\n\nax_Ïƒ = Axis(fig[1, :];\n            xlabel = \"Power iteration\",\n            ylabel = \"Growth rate\",\n            title = Ïƒ_title,\n            xticks = 1:length(power_method_data)-1,\n            limits = ((0.5, length(power_method_data)-0.5), (-0.25, 0.25)))\n\nscatter!(ax_Ïƒ, Ïƒâ‚™; color = :blue)\n\nframes = 1:length(power_method_data)\n\nrecord(fig, \"powermethod.mp4\", frames, framerate=1) do i\n       @info \"Plotting frame $i of $(frames[end])...\"\n       n[] = i\nend\n\nnothing #hide","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"(Image: )","category":"page"},{"location":"generated/kelvin_helmholtz_instability/#Now-for-the-fun-part","page":"Kelvin-Helmholtz instability","title":"Now for the fun part","text":"","category":"section"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Now we simulate the nonlinear evolution of the eigenmode we've isolated for a few e-folding times 1sigma,","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"# Reset the clock\nmodel.clock.iteration = 0\nmodel.clock.time = 0\n\nestimated_growth_rate = growth_rates[end]\n\nsimulation.stop_time = 5 / estimated_growth_rate\nsimulation.stop_iteration = 9.1e18 # pretty big (not Inf tho)\n\n# Rescale the eigenmode\ninitial_eigenmode_energy = 5e-5\nrescale!(simulation.model, mean_perturbation_kinetic_energy, target_kinetic_energy=initial_eigenmode_energy)","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Let's save and plot the perturbation vorticity and buoyancy and also the total vorticity and buoyancy (perturbation + basic state). It'll be also neat to plot the kinetic energy time-series and confirm it grows with the estimated growth rate.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"total_vorticity = Field(âˆ‚z(u) + âˆ‚z(model.background_fields.velocities.u) - âˆ‚x(w))\n\ntotal_b = Field(b + model.background_fields.tracers.b)\n\nsimulation.output_writers[:vorticity] =\n    JLD2OutputWriter(model, (Ï‰=perturbation_vorticity, Î©=total_vorticity, b=b, B=total_b, KE=mean_perturbation_kinetic_energy),\n                     schedule = TimeInterval(0.10 / estimated_growth_rate),\n                     filename = \"kelvin_helmholtz_instability.jld2\",\n                     overwrite_existing = true)","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"And now we...","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"@info \"*** Running a simulation of Kelvin-Helmholtz instability...\"\nrun!(simulation)","category":"page"},{"location":"generated/kelvin_helmholtz_instability/#Pretty-things","page":"Kelvin-Helmholtz instability","title":"Pretty things","text":"","category":"section"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"First we plot the nonlinear equilibration of the perturbation fields together with the evolution of the kinetic energy,","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"@info \"Making a neat movie of stratified shear flow...\"\n\nfilepath = simulation.output_writers[:vorticity].filepath\n\nÏ‰_timeseries = FieldTimeSeries(filepath, \"Ï‰\")\nb_timeseries = FieldTimeSeries(filepath, \"b\")\nÎ©_timeseries = FieldTimeSeries(filepath, \"Î©\")\nB_timeseries = FieldTimeSeries(filepath, \"B\")\nKE_timeseries = FieldTimeSeries(filepath, \"KE\")\n\ntimes = Ï‰_timeseries.times\n\nt_final = times[end]\n\nn = Observable(1)\n\nÏ‰â‚™ = @lift interior(Ï‰_timeseries, :, 1, :, $n)\nbâ‚™ = @lift interior(b_timeseries, :, 1, :, $n)\n\nfig = Figure(resolution=(800, 600))\n\nkwargs = (xlabel=\"x\", ylabel=\"z\", limits = ((xÏ‰[1], xÏ‰[end]), (zÏ‰[1], zÏ‰[end])), aspect=1,)\n\ntitle = @lift @sprintf(\"t = %.2f\", times[$n])\n\nax_Ï‰ = Axis(fig[2, 1]; title = \"perturbation vorticity\", kwargs...)\n\nax_b = Axis(fig[2, 3]; title = \"perturbation buoyancy\", kwargs...)\n\nax_KE = Axis(fig[3, :];\n             yscale = log10,\n             limits = ((0, t_final), (initial_eigenmode_energy, 1e-1)),\n             xlabel = \"time\")\n\nfig[1, :] = Label(fig, title, fontsize=24, tellwidth=false)\n\nÏ‰_lims = @lift (-maximum(abs, interior(Ï‰_timeseries, :, 1, :, $n)) - 1e-16, maximum(abs, interior(Ï‰_timeseries, :, 1, :, $n)) + 1e-16)\nb_lims = @lift (-maximum(abs, interior(b_timeseries, :, 1, :, $n)) - 1e-16, maximum(abs, interior(b_timeseries, :, 1, :, $n)) + 1e-16)\n\nhm_Ï‰ = heatmap!(ax_Ï‰, xÏ‰, zÏ‰, Ï‰â‚™; colorrange = Ï‰_lims, colormap = :balance)\nColorbar(fig[2, 2], hm_Ï‰)\n\nhm_b = heatmap!(ax_b, xb, zb, bâ‚™; colorrange = b_lims, colormap = :balance)\nColorbar(fig[2, 4], hm_b)\n\ntâ‚™ = @lift times[1:$n]\nKEâ‚™ = @lift KE_timeseries[1:$n]\n\nlines!(ax_KE, [0, t_final], @. initial_eigenmode_energy * exp(2 * estimated_growth_rate * [0, t_final]);\n       label = \"~ exp(2 Ïƒ t)\",\n       linewidth = 2,\n       color = :black)\n\nlines!(ax_KE, times, KE_timeseries[:];\n       label = \"perturbation kinetic energy\",\n       linewidth = 4, color = :blue, alpha = 0.4)\n\nKE_point = @lift Point2f[(times[$n], KE_timeseries[$n][1, 1, 1])]\n\nscatter!(ax_KE, KE_point;\n         marker = :circle, markersize = 16, color = :blue)\n\nframes = 1:length(times)\n\nrecord(fig, \"kelvin_helmholtz_instability_perturbations.mp4\", frames, framerate=8) do i\n    @info \"Plotting frame $i of $(frames[end])...\"\n    n[] = i\nend\nnothing #hide","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"(Image: )","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"And then the same for total vorticity & buoyancy of the fluid.","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"n = Observable(1)\n\nÎ©â‚™ = @lift interior(Î©_timeseries, :, 1, :, $n)\nBâ‚™ = @lift interior(B_timeseries, :, 1, :, $n)\n\nfig = Figure(resolution=(800, 600))\n\nkwargs = (xlabel=\"x\", ylabel=\"z\", limits = ((xÏ‰[1], xÏ‰[end]), (zÏ‰[1], zÏ‰[end])), aspect=1,)\n\ntitle = @lift @sprintf(\"t = %.2f\", times[$n])\n\nax_Î© = Axis(fig[2, 1]; title = \"total vorticity\", kwargs...)\n\nax_B = Axis(fig[2, 3]; title = \"total buoyancy\", kwargs...)\n\nax_KE = Axis(fig[3, :];\n             yscale = log10,\n             limits = ((0, t_final), (initial_eigenmode_energy, 1e-1)),\n             xlabel = \"time\")\n\nfig[1, :] = Label(fig, title, fontsize=24, tellwidth=false)\n\nhm_Î© = heatmap!(ax_Î©, xÏ‰, zÏ‰, Î©â‚™; colorrange = (-1, 1), colormap = :balance)\nColorbar(fig[2, 2], hm_Î©)\n\nhm_B = heatmap!(ax_B, xb, zb, Bâ‚™; colorrange = (-0.05, 0.05), colormap = :balance)\nColorbar(fig[2, 4], hm_B)\n\ntâ‚™ = @lift times[1:$n]\nKEâ‚™ = @lift KE_timeseries[1, 1, 1, 1:$n]\n\nlines!(ax_KE, [0, t_final], @. initial_eigenmode_energy * exp(2 * estimated_growth_rate * [0, t_final]);\n       label = \"~ exp(2 Ïƒ t)\",\n       linewidth = 2,\n       color = :black)\n\nlines!(ax_KE, times, KE_timeseries[:];\n       label = \"perturbation kinetic energy\",\n       linewidth = 4, color = :blue, alpha = 0.4)\n\nKE_point = @lift Point2f[(times[$n], KE_timeseries[$n][1, 1, 1])]\n\nscatter!(ax_KE, KE_point;\n         marker = :circle, markersize = 16, color = :blue)\n\naxislegend(ax_KE; position = :rb)\n\nrecord(fig, \"kelvin_helmholtz_instability_total.mp4\", frames, framerate=8) do i\n       @info \"Plotting frame $i of $(frames[end])...\"\n       n[] = i\nend\nnothing #hide","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"(Image: )","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"","category":"page"},{"location":"generated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"This page was generated using Literate.jl.","category":"page"},{"location":"numerical_implementation/time_stepping/#time_stepping","page":"Time stepping","title":"Time-stepping and the fractional step method","text":"","category":"section"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"With the pressure decomposition as discussed, the momentum evolves via:","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"    beginequation\n    labeleqmomentum-time-derivative\n    partial_t boldsymbolv = boldsymbolG_boldsymbolv - boldsymbolnabla p_rmnon  \n    endequation","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"where, e.g., for the non-hydrostatic model (ignoring background velocities and surface-wave effects)","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"boldsymbolG_boldsymbolv equiv - boldsymbolnabla_h p_rmhyd \n                       - left ( boldsymbolv boldsymbolcdot boldsymbolnabla right ) boldsymbolv \n                       - boldsymbolf times boldsymbolv \n                       + boldsymbolnabla boldsymbolcdot boldsymboltau \n                       + boldsymbolF_boldsymbolv","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"collects all terms on the right side of the momentum equation \\eqref{eq:momentum-time-derivative}, except the  contribution of non-hydrostatic pressure boldsymbolnabla p_rmnon.","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"The time-integral of the momentum equation \\eqref{eq:momentum-time-derivative} from time step n at t = t_n to time step n+1 at t_n+1 is:","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"    beginequation\n    labeleqmomentum-time-integral\n    boldsymbolv^n+1 - boldsymbolv^n = \n        int_t_n^t_n+1 Big  - boldsymbolnabla p_rmnon + boldsymbolG_boldsymbolv Big   mathrmd t  \n    endequation","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"where the superscript n and n+1 imply evaluation at t_n and t_n+1, such that  boldsymbolv^n equiv boldsymbolv(t=t_n). The crux of the fractional step method is  to treat the pressure term boldsymbolnabla p_rmnon implicitly using the approximation","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"    beginalign\n    labeleqpnon_implicit\n    int_t_n^t_n+1 boldsymbolnabla p_rmnon  mathrmd t approx\n        Delta t boldsymbolnabla p_rmnon^n+1  \n    endalign","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"while treating the rest of the terms on the right hand side of \\eqref{eq:momentum-time-integral}  explicitly. The implicit treatment of pressure ensures that the velocity field obtained at  time step n+1 is divergence-free.","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"To effect such a fractional step method, we define an intermediate velocity field boldsymbolv^star such that","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"    beginequation\n    labeleqintermediate-velocity-field\n    boldsymbolv^star - boldsymbolv^n = int_t_n^t_n+1 boldsymbolG_boldsymbolv  mathrmd t  \n    endequation","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"The integral on the right of the equation for boldsymbolv^star may be approximated by a variety of explicit methods. For example, a forward Euler method approximates the integral via","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"    beginequation\n    int_t_n^t_n+1 G  mathrmd t approx Delta t G^n  \n    labeleqforward-euler\n    endequation","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"for any time-dependent function G(t), while a second-order Adams-Bashforth method uses the approximation","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"    beginequation\n    labeleqadams-bashforth\n    int_t_n^t_n+1 G  mathrmd t approx\n        Delta t left  left ( tfrac32 + chi right ) G^n \n        - left ( tfrac12 + chi right ) G^n-1 right   \n    endequation","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"where chi is a parameter. U. Ascher, S. Ruuth, B. Wetton (1995) claim that chi = tfrac18 is optimal;  chi = -tfrac12 yields the forward Euler scheme.","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"Combining the equation \\eqref{eq:intermediate-velocity-field} for boldsymbolv^star and the time integral of the non-hydrostatic pressure \\eqref{eq:pnon_implicit} yields","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"    beginequation\n    labeleqfractional-step\n    boldsymbolv^n+1 - boldsymbolv^star = - Delta t boldsymbolnabla p_rmnon^n+1  \n    endequation","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"Taking the divergence of fractional step equation \\eqref{eq:fractional-step} and requiring that  boldsymbolnabla boldsymbolcdot boldsymbolv^n+1 = 0 yields a Poisson equation  for the kinematic pressure p_rmnon at time-step n+1:","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"    beginequation\n    labeleqpressure-poisson\n    nabla^2 p_rmnon^n+1 = fracboldsymbolnabla boldsymbolcdot boldsymbolv^starDelta t  \n    endequation","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"With boldsymbolv^star in hand we can invert \\eqref{eq:pressure-poisson} to get p_rmnon^n+1 and then boldsymbolv^n+1 is computed via the fractional step equation \\eqref{eq:fractional-step}.","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"Tracers are stepped forward explicitly via","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"    beginequation\n    labeleqtracer-timestep\n    c^n+1 - c^n = int_t_n^t_n+1 G_c  mathrmd t  \n    endequation","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"where ","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"    beginequation\n    G_c equiv - boldsymbolnabla boldsymbolcdot left ( boldsymbolv c right ) - boldsymbolnabla boldsymbolcdot boldsymbolq_c + F_c  \n    endequation","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"and the same forward Euler or Adams-Bashforth scheme as for the explicit evaluation of the time-integral of boldsymbolG_u is used to evaluate the integral of G_c.","category":"page"},{"location":"numerical_implementation/turbulence_closures/#numerical_closures","page":"Turbulence closures","title":"Turbulence closures","text":"","category":"section"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"To truly simulate and resolve turbulence at high Reynolds number (so basically all interesting flows) would require you resolve all motions down to the A. Kolmogorov (1941) length scale eta = (nu^3  varepsilon)^14 where nu is the kinematic viscosity and varepsilon the average rate of dissipation of turbulence kinetic energy per unit mass.","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"As pointed out way back by S. Corrsin (1961), to run a simulation on a horizontal domain about 10 times the size of an \"average eddy\" with 100 vertical levels and where the grid spacing is given by eta would require the computer to store on the order of 10^14 variables.[1] This is still impractical today, although may be within reach in less than a decade. He ends by suggesting the use of an analog rather digital computerâ€“-a tank of water.","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"[1]: And even then, eta gives the maximum allowable grid spacing. There is significant flow structure smaller than eta.","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"To have any hope of simulating high Reynolds number flows we need some way of resolving the sub-grid scale motions.[2]","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"[2]: In reality there is no need to resolve all motions down to the Kolmogorov length scale to achieve acceptable accuracy. Perhaps good results can be achieved if 80\\% of the kinetic energy is resolved (Â§13) S. B. Pope (2000).","category":"page"},{"location":"numerical_implementation/turbulence_closures/#Reynolds-averaged-Navierâ€“Stokes-equations","page":"Turbulence closures","title":"Reynolds-averaged Navierâ€“Stokes equations","text":"","category":"section"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"Following Osborne Reynolds (1895) we can decompose flow variables such as velocity boldsymbolv into the mean component overlineboldsymbolv and the fluctuating component boldsymbolv^prime so that boldsymbolv = overlineboldsymbolv + boldsymbolv^prime [see Â§4 of S. B. Pope (2000) for a modern discussion].","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"Expressing the Navier-Stokes equations in tensor notation","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"beginalign\n    partial_i v_i = 0   \n    partial_t v_i + v_j partial_j v_i = f_i - alphapartial_i p + nu partial_j partial_j v_i  \nendalign","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"where alpha = rho^-1 is the specific volume and f_i represents external forces. We can plug in the Reynolds decomposition for boldsymbolv and after some manipulation arrive at the following form for the Reynolds-averaged Navier-Stokes equations","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"beginalign\n    partial_i overlineu_i = 0   \n    partial_t overlineu_i + overlineu_j partial_j overlineu_i = overlinef_i -\n    partial_j left(-alphaoverlinepdelta_ij + 2nu overlineS_ij - overlinev_i^prime v_j^primeright)  \nendalign","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"where","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"overlineS_ij = frac12 ( partial_j overlineu_i + partial_i overlineu_j )  ","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"is the mean rate of strain tensor.","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"Thanks to the non-linearity of the Navier-Stokes equations, even when averaged we are left with pesky fluctuation terms which form the components of the Reynolds stress tensor","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"tau_ij = rho overlinev_i^prime v_j^prime  ","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"Attempting to close the equations leads to the closure problem: the time evolution of the Reynolds stresses depends on  triple covariances overlinev_i^prime v_j^prime v_k^prime and covariances with pressure, which depend on quadruple covariances and so on P. Y. Chou (1945).","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"This is kind of hopeless so we will have to find some way to model the Reynolds stresses.","category":"page"},{"location":"numerical_implementation/turbulence_closures/#Gradient-diffusion-hypothesis-and-eddy-viscosity-models","page":"Turbulence closures","title":"Gradient-diffusion hypothesis and eddy viscosity models","text":"","category":"section"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"The gradient-diffusion hypothesis, due to J. Boussinesq (1877), assumes that the transport of scalar fluxes such as overlineboldsymbolv^prime c^prime and overlinev_i^prime v_j^prime occurs down the mean scalar gradient boldsymbolnabla overlinec as if they are being diffused (Â§4.4) S. B. Pope (2000). This is in analogy with how momentum transfer by molecular motion in a gas can be described by a molecular viscosity.","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"Taking this assumption we can express the Reynolds stresses and turbulent tracer fluxes in terms of the mean variables and close the equations","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"overlineboldsymbolv^prime c^prime = -kappa_e boldsymbolnabla overlinec\nquad textand quad\noverlinev_i^prime v_j^prime = -2nu_e overlineS_ij  ","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"where nu_e = nu_e(boldsymbolx t) is the turbulent or eddy viscosity and kappa_e = kappa_e(boldsymbolx t) is the eddy diffusivity.","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"The effective diffusivity ends up being the sum of the molecular and eddy diffusivities. So just by using an elevated value for the viscosity and diffusivity, you are already using an eddy viscosity model.","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"The eddy viscosity model is simple and for that reason is very popular. It can work well even with a constant eddy diffusivity. However, it does assume that the flux is aligned down gradient, which is not true even in simple turbulent flows as the physics of turbulence is quite different from that of colliding molecules leading to the viscous stress law (Â§4.4,10.1) S. B. Pope (2000). So we might want something a little bit more sophisticated.","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"EditURL = \"<unknown>/examples/two_dimensional_turbulence.jl\"","category":"page"},{"location":"generated/two_dimensional_turbulence/#Two-dimensional-turbulence-example","page":"Two-dimensional turbulence","title":"Two dimensional turbulence example","text":"","category":"section"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"In this example, we initialize a random velocity field and observe its turbulent decay in a two-dimensional domain. This example demonstrates:","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"How to run a model with no tracers and no buoyancy model.\nHow to use computed Fields to generate output.","category":"page"},{"location":"generated/two_dimensional_turbulence/#Install-dependencies","page":"Two-dimensional turbulence","title":"Install dependencies","text":"","category":"section"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"using Pkg\npkg\"add Oceananigans, CairoMakie\"","category":"page"},{"location":"generated/two_dimensional_turbulence/#Model-setup","page":"Two-dimensional turbulence","title":"Model setup","text":"","category":"section"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"We instantiate the model with an isotropic diffusivity. We use a grid with 128Â² points, a fifth-order advection scheme, third-order Runge-Kutta time-stepping, and a small isotropic viscosity.  Note that we assign Flat to the z direction.","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"using Oceananigans\n\ngrid = RectilinearGrid(size=(128, 128), extent=(2Ï€, 2Ï€), topology=(Periodic, Periodic, Flat))\n\nmodel = NonhydrostaticModel(; grid,\n                            timestepper = :RungeKutta3,\n                            advection = UpwindBiasedFifthOrder(),\n                            closure = ScalarDiffusivity(Î½=1e-5))","category":"page"},{"location":"generated/two_dimensional_turbulence/#Random-initial-conditions","page":"Two-dimensional turbulence","title":"Random initial conditions","text":"","category":"section"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Our initial condition randomizes model.velocities.u and model.velocities.v. We ensure that both have zero mean for aesthetic reasons.","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"using Statistics\n\nu, v, w = model.velocities\n\nuáµ¢ = rand(size(u)...)\nváµ¢ = rand(size(v)...)\n\nuáµ¢ .-= mean(uáµ¢)\nváµ¢ .-= mean(váµ¢)\n\nset!(model, u=uáµ¢, v=váµ¢)\n\nsimulation = Simulation(model, Î”t=0.2, stop_time=50)","category":"page"},{"location":"generated/two_dimensional_turbulence/#Logging-simulation-progress","page":"Two-dimensional turbulence","title":"Logging simulation progress","text":"","category":"section"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"We set up a callback that logs the simulation iteration and time every 100 iterations.","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"progress(sim) = @info string(\"Iteration: \", iteration(sim), \", time: \", time(sim))\nsimulation.callbacks[:progress] = Callback(progress, IterationInterval(100))","category":"page"},{"location":"generated/two_dimensional_turbulence/#Output","page":"Two-dimensional turbulence","title":"Output","text":"","category":"section"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"We set up an output writer for the simulation that saves vorticity and speed every 20 iterations.","category":"page"},{"location":"generated/two_dimensional_turbulence/#Computing-vorticity-and-speed","page":"Two-dimensional turbulence","title":"Computing vorticity and speed","text":"","category":"section"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"To make our equations prettier, we unpack u, v, and w from the NamedTuple model.velocities:","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"u, v, w = model.velocities","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Next we create two Fields that calculate (i) vorticity that measures the rate at which the fluid rotates and is defined as","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Ï‰ = _x v - _y u  ","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Ï‰ = âˆ‚x(v) - âˆ‚y(u)","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"We also calculate (ii) the speed of the flow,","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"s = sqrtu^2 + v^2  ","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"s = sqrt(u^2 + v^2)","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"We pass these operations to an output writer below to calculate and output them during the simulation.","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"filename = \"two_dimensional_turbulence\"\n\nsimulation.output_writers[:fields] = JLD2OutputWriter(model, (; Ï‰, s),\n                                                      schedule = TimeInterval(0.6),\n                                                      filename = filename * \".jld2\",\n                                                      overwrite_existing = true)","category":"page"},{"location":"generated/two_dimensional_turbulence/#Running-the-simulation","page":"Two-dimensional turbulence","title":"Running the simulation","text":"","category":"section"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Pretty much just","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"run!(simulation)","category":"page"},{"location":"generated/two_dimensional_turbulence/#Visualizing-the-results","page":"Two-dimensional turbulence","title":"Visualizing the results","text":"","category":"section"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"We load the output.","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Ï‰_timeseries = FieldTimeSeries(filename * \".jld2\", \"Ï‰\")\ns_timeseries = FieldTimeSeries(filename * \".jld2\", \"s\")\n\ntimes = Ï‰_timeseries.times","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Construct the x y z grid for plotting purposes,","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"xÏ‰, yÏ‰, zÏ‰ = nodes(Ï‰_timeseries)\nxs, ys, zs = nodes(s_timeseries)\nnothing # hide","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"and animate the vorticity and fluid speed.","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"using CairoMakie\nset_theme!(Theme(fontsize = 24))\n\n@info \"Making a neat movie of vorticity and speed...\"\n\nfig = Figure(resolution = (800, 500))\n\naxis_kwargs = (xlabel = \"x\",\n               ylabel = \"y\",\n               limits = ((0, 2Ï€), (0, 2Ï€)),\n               aspect = AxisAspect(1))\n\nax_Ï‰ = Axis(fig[2, 1]; title = \"Vorticity\", axis_kwargs...)\nax_s = Axis(fig[2, 2]; title = \"Speed\", axis_kwargs...)\nnothing #hide","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"We use Makie's Observable to animate the data. To dive into how Observables work we refer to Makie.jl's Documentation.","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"n = Observable(1)","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Now let's plot the vorticity and speed.","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Ï‰ = @lift interior(Ï‰_timeseries[$n], :, :, 1)\ns = @lift interior(s_timeseries[$n], :, :, 1)\n\nheatmap!(ax_Ï‰, xÏ‰, yÏ‰, Ï‰; colormap = :balance, colorrange = (-2, 2))\nheatmap!(ax_s, xs, ys, s; colormap = :speed, colorrange = (0, 0.2))\n\ntitle = @lift \"t = \" * string(round(times[$n], digits=2))\nLabel(fig[1, 1:2], title, fontsize=24, tellwidth=false)\n\ncurrent_figure() # hide\nfig","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Finally, we record a movie.","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"frames = 1:length(times)\n\n@info \"Making a neat animation of vorticity and speed...\"\n\nrecord(fig, filename * \".mp4\", frames, framerate=24) do i\n    msg = string(\"Plotting frame \", i, \" of \", frames[end])\n    print(msg * \" \\r\")\n    n[] = i\nend\nnothing #hide","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"(Image: )","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"This page was generated using Literate.jl.","category":"page"},{"location":"model_setup/output_writers/#Output-writers","page":"Output writers","title":"Output writers","text":"","category":"section"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"AbstractOutputWriters save data to disk. Oceananigans provides three ways to write output:","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"NetCDFOutputWriter for output of arrays and scalars that uses NCDatasets.jl\nJLD2OutputWriter for arbitrary julia data structures that uses JLD2.jl\nCheckpointer that automatically saves as much model data as possible, using JLD2.jl","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"The Checkpointer is discussed on a separate documentation page.","category":"page"},{"location":"model_setup/output_writers/#Basic-usage","page":"Output writers","title":"Basic usage","text":"","category":"section"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"NetCDFOutputWriter and JLD2OutputWriter require four inputs:","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"The model from which output data is sourced (required to initialize the OutputWriter).\nA key-value pairing of output \"names\" and \"output\" objects. JLD2OutputWriter accepts NamedTuples and Dicts; NetCDFOutputWriter accepts Dicts with string-valued keys. Output objects are either AbstractFields or functions that return data when called via func(model).\nA schedule on which output is written. TimeInterval, IterationInterval, WallTimeInterval schedule periodic output according to the simulation time, simulation interval, or \"wall time\" (the physical time according to a clock on your wall). A fourth schedule called AveragedTimeInterval specifies periodic output that is time-averaged over a window prior to being written.\nThe filename and directory.","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"Other important keyword arguments are","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"field_slicer::FieldSlicer for outputting subregions, two- and one-dimensional slices of fields. By default a FieldSlicer is used to remove halo regions from fields so that only the physical portion of model data is saved to disk.\narray_type for specifying the type of the array that holds outputted field data. The default is Array{Float64}, or arrays of single-precision floating point numbers.","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"Once an OutputWriter is created, it can be used to write output by adding it the ordered dictionary simulation.output_writers. prior to calling run!(simulation).","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"More specific detail about the NetCDFOutputWriter and JLD2OutputWriter is given below.","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"tip: Time step alignment and output writing\nOceananigans simulations will shorten the time step as needed to align model output with each output writer's schedule.","category":"page"},{"location":"model_setup/output_writers/#NetCDF-output-writer","page":"Output writers","title":"NetCDF output writer","text":"","category":"section"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"Model data can be saved to NetCDF files along with associated metadata. The NetCDF output writer is generally used by passing it a dictionary of (label, field) pairs and any indices for slicing if you don't want to save the full 3D field.","category":"page"},{"location":"model_setup/output_writers/#Examples","page":"Output writers","title":"Examples","text":"","category":"section"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"Saving the u velocity field and temperature fields as full 3D fields, surface 2D slices, and 1D columns to separate NetCDF files:","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"using Oceananigans\n\ngrid = RectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1))\n\nmodel = NonhydrostaticModel(grid=grid, tracers=:c)\n\nsimulation = Simulation(model, Î”t=12, stop_time=3600)\n\nfields = Dict(\"u\" => model.velocities.u, \"c\" => model.tracers.c)\n\nsimulation.output_writers[:field_writer] =\n    NetCDFOutputWriter(model, fields, filename=\"more_fields.nc\", schedule=TimeInterval(60))\n\n# output\nNetCDFOutputWriter scheduled on TimeInterval(1 minute):\nâ”œâ”€â”€ filepath: ./more_fields.nc\nâ”œâ”€â”€ dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0)\nâ”œâ”€â”€ 2 outputs: (c, u)\nâ””â”€â”€ array type: Array{Float64}","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"simulation.output_writers[:surface_slice_writer] =\n    NetCDFOutputWriter(model, fields, filename=\"another_surface_xy_slice.nc\",\n                       schedule=TimeInterval(60), indices=(:, :, grid.Nz))\n\n# output\nNetCDFOutputWriter scheduled on TimeInterval(1 minute):\nâ”œâ”€â”€ filepath: ./another_surface_xy_slice.nc\nâ”œâ”€â”€ dimensions: zC(1), zF(1), xC(16), yF(16), xF(16), yC(16), time(0)\nâ”œâ”€â”€ 2 outputs: (c, u)\nâ””â”€â”€ array type: Array{Float64}","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"simulation.output_writers[:averaged_profile_writer] =\n    NetCDFOutputWriter(model, fields,\n                       filename = \"another_averaged_z_profile.nc\",\n                       schedule = AveragedTimeInterval(60, window=20),\n                       indices = (1, 1, :))\n\n# output\nNetCDFOutputWriter scheduled on TimeInterval(1 minute):\nâ”œâ”€â”€ filepath: ./another_averaged_z_profile.nc\nâ”œâ”€â”€ dimensions: zC(16), zF(17), xC(1), yF(1), xF(1), yC(1), time(0)\nâ”œâ”€â”€ 2 outputs: (c, u) averaged on AveragedTimeInterval(window=20 seconds, stride=1, interval=1 minute)\nâ””â”€â”€ array type: Array{Float64}","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"NetCDFOutputWriter also accepts output functions that write scalars and arrays to disk, provided that their dimensions are provided:","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"using Oceananigans\n\nNx, Ny, Nz = 16, 16, 16\n\ngrid = RectilinearGrid(size=(Nx, Ny, Nz), extent=(1, 2, 3))\n\nmodel = NonhydrostaticModel(grid=grid)\n\nsimulation = Simulation(model, Î”t=1.25, stop_iteration=3)\n\nf(model) = model.clock.time^2; # scalar output\n\ng(model) = model.clock.time .* exp.(znodes(Center, grid)) # single-column profile output (vector)\n\nxC, yF = xnodes(grid, Center()), ynodes(grid, Face())\n\nXC = [xC[i] for i in 1:Nx, j in 1:Ny]\nYF = [yF[j] for i in 1:Nx, j in 1:Ny]\n\nh(model) = @. model.clock.time * sin(XC) * cos(YF) # x-y slice output (2D array)\n\noutputs = Dict(\"scalar\" => f, \"profile\" => g, \"slice\" => h)\n\ndims = Dict(\"scalar\" => (), \"profile\" => (\"zC\",), \"slice\" => (\"xC\", \"yC\"))\n\noutput_attributes = Dict(\n    \"scalar\"  => Dict(\"longname\" => \"Some scalar\", \"units\" => \"bananas\"),\n    \"profile\" => Dict(\"longname\" => \"Some vertical profile\", \"units\" => \"watermelons\"),\n    \"slice\"   => Dict(\"longname\" => \"Some slice\", \"units\" => \"mushrooms\")\n)\n\nglobal_attributes = Dict(\"location\" => \"Bay of Fundy\", \"onions\" => 7)\n\nsimulation.output_writers[:things] =\n    NetCDFOutputWriter(model, outputs,\n                       schedule=IterationInterval(1), filename=\"things.nc\", dimensions=dims, verbose=true,\n                       global_attributes=global_attributes, output_attributes=output_attributes)\n\n# output\nNetCDFOutputWriter scheduled on IterationInterval(1):\nâ”œâ”€â”€ filepath: ./things.nc\nâ”œâ”€â”€ dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0)\nâ”œâ”€â”€ 3 outputs: (profile, slice, scalar)\nâ””â”€â”€ array type: Array{Float64}","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"See NetCDFOutputWriter for more information.","category":"page"},{"location":"model_setup/output_writers/#JLD2-output-writer","page":"Output writers","title":"JLD2 output writer","text":"","category":"section"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"JLD2 is a fast HDF5 compatible file format written in pure Julia. JLD2 files can be opened in Julia with the JLD2.jl package and in Python with the h5py package.","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"The JLD2OutputWriter receives either a Dictionary or NamedTuple containing name, output pairs. The name can be a symbol or string. The output must either be an AbstractField or a function called with func(model) that returns arbitrary output. Whenever output needs to be written, the functions will be called and the output of the function will be saved to the JLD2 file.","category":"page"},{"location":"model_setup/output_writers/#Examples-2","page":"Output writers","title":"Examples","text":"","category":"section"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"Write out 3D fields for u, v, w, and a tracer c, along with a horizontal average:","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"using Oceananigans\nusing Oceananigans.Utils: hour, minute\n\nmodel = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)), tracers=(:c,))\nsimulation = Simulation(model, Î”t=12, stop_time=1hour)\n\nfunction init_save_some_metadata!(file, model)\n    file[\"author\"] = \"Chim Riggles\"\n    file[\"parameters/coriolis_parameter\"] = 1e-4\n    file[\"parameters/density\"] = 1027\n    return nothing\nend\n\nc_avg = Field(Average(model.tracers.c, dims=(1, 2)))\n\n# Note that model.velocities is NamedTuple\nsimulation.output_writers[:velocities] = JLD2OutputWriter(model, model.velocities,\n                                                          filename = \"some_more_data.jld2\",\n                                                          schedule = TimeInterval(20minute),\n                                                          init = init_save_some_metadata!)\n\n# output\nJLD2OutputWriter scheduled on TimeInterval(20 minutes):\nâ”œâ”€â”€ filepath: ./some_more_data.jld2\nâ”œâ”€â”€ 3 outputs: (u, v, w)\nâ”œâ”€â”€ array type: Array{Float64}\nâ”œâ”€â”€ including: [:grid, :coriolis, :buoyancy, :closure]\nâ””â”€â”€ max filesize: Inf YiB","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"and a time- and horizontal-average of tracer c every 20 minutes of simulation time to a file called some_more_averaged_data.jld2","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"simulation.output_writers[:avg_c] = JLD2OutputWriter(model, (; c=c_avg),\n                                                     filename = \"some_more_averaged_data.jld2\",\n                                                     schedule = AveragedTimeInterval(20minute, window=5minute))\n\n# output\nJLD2OutputWriter scheduled on TimeInterval(20 minutes):\nâ”œâ”€â”€ filepath: ./some_more_averaged_data.jld2\nâ”œâ”€â”€ 1 outputs: c averaged on AveragedTimeInterval(window=5 minutes, stride=1, interval=20 minutes)\nâ”œâ”€â”€ array type: Array{Float64}\nâ”œâ”€â”€ including: [:grid, :coriolis, :buoyancy, :closure]\nâ””â”€â”€ max filesize: Inf YiB","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"See JLD2OutputWriter for more information.","category":"page"},{"location":"model_setup/output_writers/#Time-averaged-output","page":"Output writers","title":"Time-averaged output","text":"","category":"section"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"Time-averaged output is specified by setting the schedule keyword argument for either NetCDFOutputWriter or JLD2OutputWriter to AveragedTimeInterval.","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"With AveragedTimeInterval, the time-average of a is taken as a left Riemann sum corresponding to","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"langle a rangle = frac1T int_t_i-T^t_i a  mathrmd t  ","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"where langle a rangle is the time-average of a, T is the time-window for averaging specified by the window keyword argument to AveragedTimeInterval, and the t_i are discrete times separated by the time interval. The t_i specify both the end of the averaging window and the time at which output is written.","category":"page"},{"location":"model_setup/output_writers/#Example","page":"Output writers","title":"Example","text":"","category":"section"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"Building an AveragedTimeInterval that averages over a 1 day window, every 4 days,","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"using Oceananigans.OutputWriters: AveragedTimeInterval\nusing Oceananigans.Units\n\nschedule = AveragedTimeInterval(4days, window=1day)\n\n# output\nAveragedTimeInterval(window=1 day, stride=1, interval=4 days)","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"An AveragedTimeInterval schedule directs an output writer to time-average its outputs before writing them to disk:","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"using Oceananigans\nusing Oceananigans.OutputWriters: JLD2OutputWriter\nusing Oceananigans.Units\n\nmodel = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)))\n\nsimulation = Simulation(model, Î”t=10minutes, stop_time=30days)\n\nsimulation.output_writers[:velocities] = JLD2OutputWriter(model, model.velocities,\n                                                          filename = \"even_more_averaged_velocity_data.jld2\",\n                                                          schedule = AveragedTimeInterval(4days, window=1day, stride=2))\n\n# output\nJLD2OutputWriter scheduled on TimeInterval(4 days):\nâ”œâ”€â”€ filepath: ./even_more_averaged_velocity_data.jld2\nâ”œâ”€â”€ 3 outputs: (u, v, w) averaged on AveragedTimeInterval(window=1 day, stride=2, interval=4 days)\nâ”œâ”€â”€ array type: Array{Float64}\nâ”œâ”€â”€ including: [:grid, :coriolis, :buoyancy, :closure]\nâ””â”€â”€ max filesize: Inf YiB","category":"page"},{"location":"model_setup/clock/#Clock","page":"Clock","title":"Clock","text":"","category":"section"},{"location":"model_setup/clock/","page":"Clock","title":"Clock","text":"The clock holds the current simulation time, iteration number, and time step stage. The time step stage is relevant only for the multi-stage time-stepper RungeKutta3TimeStepper.","category":"page"},{"location":"model_setup/clock/","page":"Clock","title":"Clock","text":"By default, Clocks are initialized at iteration 0, and stage 1,","category":"page"},{"location":"model_setup/clock/","page":"Clock","title":"Clock","text":"DocTestSetup = quote\n    using Oceananigans\n    using TimesDates\nend","category":"page"},{"location":"model_setup/clock/","page":"Clock","title":"Clock","text":"julia> clock = Clock(time=0.0)\nClock{Float64}: time = 0 seconds, iteration = 0, stage = 1","category":"page"},{"location":"model_setup/clock/","page":"Clock","title":"Clock","text":"but can be modified to start the model clock at some other time. For example, passing","category":"page"},{"location":"model_setup/clock/","page":"Clock","title":"Clock","text":"julia> clock = Clock(time=3600.0)\nClock{Float64}: time = 1 hour, iteration = 0, stage = 1","category":"page"},{"location":"model_setup/clock/","page":"Clock","title":"Clock","text":"to the constructor for NonhydrostaticModel causes the simulation time to start at t = 3600 seconds.","category":"page"},{"location":"model_setup/clock/","page":"Clock","title":"Clock","text":"The type of the keyword argument time should be a float or date type. To use the date type TimeDate from the TimesDates.jl package, for example, pass","category":"page"},{"location":"model_setup/clock/","page":"Clock","title":"Clock","text":"julia> using TimesDates\n\njulia> clock = Clock(time=TimeDate(2020))\nClock{TimesDates.TimeDate}: time = 2020-01-01T00:00:00, iteration = 0, stage = 1","category":"page"},{"location":"model_setup/clock/","page":"Clock","title":"Clock","text":"to NonhydrostaticModel. TimesDates.TimeDate supports nanosecond resolution and is thus recommended over Base.Dates.DateTime, which is also supported but has only millisecond resolution.","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#Turbulent-diffusivity-closures-and-large-eddy-simulation-models","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and large eddy simulation models","text":"","category":"section"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"A turbulent diffusivity closure representing the effects of viscous dissipation and diffusion can be passed via the closure keyword.","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"See turbulence closures and large eddy simulation for more details on turbulent diffusivity closures.","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#Constant-isotropic-diffusivity","page":"Turbulent diffusivity closures and LES models","title":"Constant isotropic diffusivity","text":"","category":"section"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"To use constant isotropic values for the viscosity nu and diffusivity kappa you can use ScalarDiffusivity:","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"julia> using Oceananigans.TurbulenceClosures\n\njulia> closure = ScalarDiffusivity(Î½=1e-2, Îº=1e-2)\nScalarDiffusivity{ExplicitTimeDiscretization}(Î½=0.01, Îº=0.01)","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#Constant-anisotropic-diffusivity","page":"Turbulent diffusivity closures and LES models","title":"Constant anisotropic diffusivity","text":"","category":"section"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"To specify constant values for the horizontal and vertical viscosities, nu_h and nu_z, and horizontal and vertical diffusivities, kappa_h and kappa_z, you can use HorizontalScalarDiffusivity() and VerticalScalarDiffusivity(), e.g.,","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"julia> using Oceananigans.TurbulenceClosures\n\njulia> horizontal_closure = HorizontalScalarDiffusivity(Î½=1e-3, Îº=2e-3)\nHorizontalScalarDiffusivity{ExplicitTimeDiscretization}(Î½=0.001, Îº=0.002)\n\njulia> vertical_closure = VerticalScalarDiffusivity(Î½=1e-3, Îº=2e-3)\nVerticalScalarDiffusivity{ExplicitTimeDiscretization}(Î½=0.001, Îº=0.002)","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"After that you can set, e.g., closure = (horizontal_closure, vertical_closure) when constructing the model so that all components will be taken into account when calculating the diffusivity term. Note that VerticalScalarDiffusivity and HorizontalScalarDiffusivity are implemented using different schemes with different conservation properties.","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#Tracer-specific-diffusivities","page":"Turbulent diffusivity closures and LES models","title":"Tracer-specific diffusivities","text":"","category":"section"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"You can also set different diffusivities for each tracer in your simulation by passing a NamedTuple as the argument kappa:","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"julia> using Oceananigans.TurbulenceClosures\n\njulia> ScalarDiffusivity(Î½=1e-6, Îº=(S=1e-7, T=1e-10))\nScalarDiffusivity{ExplicitTimeDiscretization}(Î½=1.0e-6, Îº=(S=1.0e-7, T=1.0e-10))","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"The example above sets a viscosity of 1e-6, a diffusivity for a tracer called T of 1e-7, and a diffusivity for a tracer called S of 1e-10. Specifying diffusivities this way is also valid for HorizontalScalarDiffusivity and VerticalScalarDiffusivity. If this method is used, diffusivities for all tracers need to be specified.","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#Smagorinsky-Lilly","page":"Turbulent diffusivity closures and LES models","title":"Smagorinsky-Lilly","text":"","category":"section"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"To use the Smagorinsky-Lilly LES closure, no parameters are required","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"julia> using Oceananigans.TurbulenceClosures\n\njulia> closure = SmagorinskyLilly()\nSmagorinskyLilly: C=0.16, Cb=1.0, Pr=1.0","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"although they may be specified. By default, the background viscosity and diffusivity are assumed to be the molecular values for seawater. For more details see SmagorinskyLilly.","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#Anisotropic-minimum-dissipation","page":"Turbulent diffusivity closures and LES models","title":"Anisotropic minimum dissipation","text":"","category":"section"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"To use the constant anisotropic minimum dissipation (AMD) LES closure,","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"julia> using Oceananigans.TurbulenceClosures\n\njulia> closure = AnisotropicMinimumDissipation()\nAnisotropicMinimumDissipation{ExplicitTimeDiscretization} turbulence closure with:\n           PoincareÌ constant for momentum eddy viscosity CÎ½: 0.08333333333333333\n    PoincareÌ constant for tracer(s) eddy diffusivit(ies) CÎº: 0.08333333333333333\n                        Buoyancy modification multiplier Cb: nothing","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"no parameters are required although they may be specified. By default, the background viscosity and diffusivity are assumed to be the molecular values for seawater. For more details see AnisotropicMinimumDissipation.","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#Convective-Adjustment-Vertical-Diffusivityâ€“Viscosity","page":"Turbulent diffusivity closures and LES models","title":"Convective Adjustment Vertical Diffusivityâ€“Viscosity","text":"","category":"section"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"To use the a convective adjustment scheme that applies enhanced values for vertical diffusivity kappa_z and/or viscosity nu_z, anytime and anywhere the background stratification becomes unstable.","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"julia> using Oceananigans\n\njulia> closure = ConvectiveAdjustmentVerticalDiffusivity(convective_Îºz = 1.0, background_Îºz = 1e-3)\nConvectiveAdjustmentVerticalDiffusivity{VerticallyImplicitTimeDiscretization}(background_Îºz=0.001 convective_Îºz=1.0 background_Î½z=0.0 convective_Î½z=0.0)","category":"page"},{"location":"physics/notation/#Coordinate-system-and-notation","page":"Coordinate system and notation","title":"Coordinate system and notation","text":"","category":"section"},{"location":"physics/notation/","page":"Coordinate system and notation","title":"Coordinate system and notation","text":"Oceananigans.jl is formulated in a Cartesian coordinate system boldsymbolx = (x y z)  with unit vectors boldsymbolhat x, boldsymbolhat y, and boldsymbolhat z,  where boldsymbolhat x points east, boldsymbolhat y points north, and boldsymbolhat z  points 'upward', opposite the direction of gravitational acceleration.","category":"page"},{"location":"physics/notation/","page":"Coordinate system and notation","title":"Coordinate system and notation","text":"We denote time with t, partial derivatives with respect to time t or a coordinate x  with partial_t or partial_x, and denote the gradient operator boldsymbolnabla equiv  partial_x boldsymbolhat x + partial_y boldsymbolhat y + partial_z boldsymbolhat z.  Horizontal gradients are denoted with boldsymbolnabla_h equiv partial_x boldsymbolhat x + partial_y boldsymbolhat y.","category":"page"},{"location":"physics/notation/","page":"Coordinate system and notation","title":"Coordinate system and notation","text":"We use u, v, and w to denote the east, north, and vertical velocity components, such that boldsymbolv = u boldsymbolhat x + v boldsymbolhat y + w boldsymbolhat z. We reserve boldsymbolv for the three-dimensional velocity field and use boldsymbolu to denote the horizontal components of flow, i.e., boldsymbolu = u boldsymbolhat x +  v boldsymbolhat y.","category":"page"},{"location":"model_setup/grids/#Grids","page":"Grid","title":"Grids","text":"","category":"section"},{"location":"model_setup/grids/","page":"Grid","title":"Grid","text":"The grids currently supported are:","category":"page"},{"location":"model_setup/grids/","page":"Grid","title":"Grid","text":"RectilinearGrids with either constant or variable grid spacings and\nLatitudeLongitudeGrid on the sphere.","category":"page"},{"location":"model_setup/grids/#RectilinearGrid","page":"Grid","title":"RectilinearGrid","text":"","category":"section"},{"location":"model_setup/grids/","page":"Grid","title":"Grid","text":"A RectilinearGrid is constructed by specifying the size of the grid (a Tuple specifying the number of grid points in each direction) and either the extent (a Tuple specifying the physical extent of the grid in each direction), or by prescribing x, y, and z. Keyword arguments x, y, and z could be either (i) 2-Tuples that define the the end points in each direction, or (ii) arrays or functions of the corresponding indices i, j, or k that specify the locations of cell faces in the x-, y-, or z-direction, respectively.","category":"page"},{"location":"model_setup/grids/","page":"Grid","title":"Grid","text":"A regular rectilinear grid with N_x times N_y times N_z = 32 times 64 times 256 grid points and an extent of L_x = 128 meters, L_y = 256 meters, and L_z = 512 meters is constructed by","category":"page"},{"location":"model_setup/grids/","page":"Grid","title":"Grid","text":"DocTestSetup = quote\n    using Oceananigans\nend","category":"page"},{"location":"model_setup/grids/","page":"Grid","title":"Grid","text":"julia> grid = RectilinearGrid(size = (32, 64, 256), extent = (128, 256, 512))\n32Ã—64Ã—256 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ Periodic x âˆˆ [0.0, 128.0)  regularly spaced with Î”x=4.0\nâ”œâ”€â”€ Periodic y âˆˆ [0.0, 256.0)  regularly spaced with Î”y=4.0\nâ””â”€â”€ Bounded  z âˆˆ [-512.0, 0.0] regularly spaced with Î”z=2.0","category":"page"},{"location":"model_setup/grids/","page":"Grid","title":"Grid","text":"info: Default domain\nWhen using the extent keyword, e.g., extent = (Lx, Ly, Lz), then the x in 0 L_x, y in 0 L_y, and z in -L_z 0 â€“ a sensible choice for oceanographic applications.","category":"page"},{"location":"model_setup/grids/#Specifying-the-grid's-architecture","page":"Grid","title":"Specifying the grid's architecture","text":"","category":"section"},{"location":"model_setup/grids/","page":"Grid","title":"Grid","text":"The first positional argument in either RectilinearGrid or LatitudeLongitudeGrid is the grid's architecture. By default architecture = CPU(). By providing GPU() as the architecture argument we can construct the grid on GPU:","category":"page"},{"location":"model_setup/grids/","page":"Grid","title":"Grid","text":"julia> grid = RectilinearGrid(GPU(), size = (32, 64, 256), extent = (128, 256, 512))\n32Ã—64Ã—256 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ Periodic x âˆˆ [0.0, 128.0)  regularly spaced with Î”x=4.0\nâ”œâ”€â”€ Periodic y âˆˆ [0.0, 256.0)  regularly spaced with Î”y=4.0\nâ””â”€â”€ Bounded  z âˆˆ [-512.0, 0.0] regularly spaced with Î”z=2.0","category":"page"},{"location":"model_setup/grids/#Specifying-the-grid's-topology","page":"Grid","title":"Specifying the grid's topology","text":"","category":"section"},{"location":"model_setup/grids/","page":"Grid","title":"Grid","text":"Another crucial keyword is a 3-Tuple that specifies the grid's topology. In each direction the grid may be Periodic, Bounded or Flat. By default, both the RectilinearGrid and the RectilinearGrid constructors  assume the grid topology is horizontally-periodic and bounded in the vertical, such that topology = (Periodic, Periodic, Bounded).","category":"page"},{"location":"model_setup/grids/","page":"Grid","title":"Grid","text":"A \"channel\" model that is periodic in the x-direction and wall-bounded in the y- and z-dimensions is build with,","category":"page"},{"location":"model_setup/grids/","page":"Grid","title":"Grid","text":"julia> grid = RectilinearGrid(topology = (Periodic, Bounded, Bounded), size = (64, 64, 32), extent = (1e4, 1e4, 1e3))\n64Ã—64Ã—32 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ Periodic x âˆˆ [0.0, 10000.0) regularly spaced with Î”x=156.25\nâ”œâ”€â”€ Bounded  y âˆˆ [0.0, 10000.0] regularly spaced with Î”y=156.25\nâ””â”€â”€ Bounded  z âˆˆ [-1000.0, 0.0] regularly spaced with Î”z=31.25","category":"page"},{"location":"model_setup/grids/","page":"Grid","title":"Grid","text":"The Flat topology comes in handy when running problems with fewer than 3 dimensions. As an example, to use a two-dimensional horizontal, doubly periodic domain the topology is (Periodic, Periodic, Flat). In that case, the size and extent are 2-tuples, e.g.,","category":"page"},{"location":"model_setup/grids/","page":"Grid","title":"Grid","text":"julia> grid = RectilinearGrid(topology = (Periodic, Periodic, Flat), size = (32, 32), extent = (10, 20))\n32Ã—32Ã—1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3Ã—3Ã—0 halo\nâ”œâ”€â”€ Periodic x âˆˆ [0.0, 10.0)      regularly spaced with Î”x=0.3125\nâ”œâ”€â”€ Periodic y âˆˆ [0.0, 20.0)      regularly spaced with Î”y=0.625\nâ””â”€â”€ Flat z","category":"page"},{"location":"model_setup/grids/#Specifying-domain-end-points","page":"Grid","title":"Specifying domain end points","text":"","category":"section"},{"location":"model_setup/grids/","page":"Grid","title":"Grid","text":"To specify a domain with a different origin than the default, the x, y, and z keyword arguments must be used. For example, a grid with x in -100 100 meters, y in 0 125 meters, and z in -pi pi meters is constructed via","category":"page"},{"location":"model_setup/grids/","page":"Grid","title":"Grid","text":"julia> grid = RectilinearGrid(size = (32, 16, 256), x = (-100, 100), y = (0, 12.5), z = (-Ï€, Ï€))\n32Ã—16Ã—256 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ Periodic x âˆˆ [-100.0, 100.0)     regularly spaced with Î”x=6.25\nâ”œâ”€â”€ Periodic y âˆˆ [0.0, 12.5)         regularly spaced with Î”y=0.78125\nâ””â”€â”€ Bounded  z âˆˆ [-3.14159, 3.14159] regularly spaced with Î”z=0.0245437","category":"page"},{"location":"model_setup/grids/#Grids-with-non-regular-spacing-in-some-of-the-directions","page":"Grid","title":"Grids with non-regular spacing in some of the directions","text":"","category":"section"},{"location":"model_setup/grids/","page":"Grid","title":"Grid","text":"For a \"channel\" model, as the one we constructed above, one would probably like to have finer resolution near the channel walls. We construct a grid that has non-regular spacing in the bounded dimensions, here y and z by prescribing functions for y and z keyword arguments.","category":"page"},{"location":"model_setup/grids/","page":"Grid","title":"Grid","text":"For example, we can use the Chebychev nodes, which are more closely stacked near boundaries, to prescribe the y- and z-faces.","category":"page"},{"location":"model_setup/grids/","page":"Grid","title":"Grid","text":"julia> Nx, Ny, Nz = 64, 64, 32;\n\njulia> Lx, Ly, Lz = 1e4, 1e4, 1e3;\n\njulia> chebychev_spaced_y_faces(j) = - Ly/2 * cos(Ï€ * (j - 1) / Ny);\n\njulia> chebychev_spaced_z_faces(k) = - Lz/2 - Lz/2 * cos(Ï€ * (k - 1) / Nz);\n\njulia> grid = RectilinearGrid(size = (Nx, Ny, Nz),\n                              topology = (Periodic, Bounded, Bounded),\n                              x = (0, Lx),\n                              y = chebychev_spaced_y_faces,\n                              z = chebychev_spaced_z_faces)\n64Ã—64Ã—32 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ Periodic x âˆˆ [0.0, 10000.0)    regularly spaced with Î”x=156.25\nâ”œâ”€â”€ Bounded  y âˆˆ [-5000.0, 5000.0] variably spaced with min(Î”y)=6.02272, max(Î”y)=245.338\nâ””â”€â”€ Bounded  z âˆˆ [-1000.0, 0.0]    variably spaced with min(Î”z)=2.40764, max(Î”z)=49.0086","category":"page"},{"location":"model_setup/grids/","page":"Grid","title":"Grid","text":"using Oceananigans\nusing CairoMakie\nCairoMakie.activate!(type = \"svg\")\nNx, Ny, Nz = 64, 64, 32\nLx, Ly, Lz = 1e4, 1e4, 1e3\nchebychev_spaced_y_faces(j) = - Ly/2 * cos(Ï€ * (j - 1) / Ny);\nchebychev_spaced_z_faces(k) = - Lz/2 - Lz/2 * cos(Ï€ * (k - 1) / Nz);\ngrid = RectilinearGrid(size = (Nx, Ny, Nz),\n                              topology = (Periodic, Bounded, Bounded),\n                              x = (0, Lx),\n                              y = chebychev_spaced_y_faces,\n                              z = chebychev_spaced_z_faces)","category":"page"},{"location":"model_setup/grids/","page":"Grid","title":"Grid","text":"We can easily visualize the spacing of y and z directions.","category":"page"},{"location":"model_setup/grids/","page":"Grid","title":"Grid","text":"using CairoMakie\n\nfig = Figure(resolution=(800, 900))\n\nax1 = Axis(fig[1, 1]; xlabel = \"y (m)\", ylabel = \"y-spacing (m)\", limits = (nothing, (0, 250)))\nlines!(ax1, grid.yáµƒá¶œáµƒ[1:Ny], grid.Î”yáµƒá¶œáµƒ[1:Ny])\nscatter!(ax1, grid.yáµƒá¶œáµƒ[1:Ny], grid.Î”yáµƒá¶œáµƒ[1:Ny])\n\nax2 = Axis(fig[2, 1]; xlabel = \"z-spacing (m)\", ylabel = \"z (m)\", limits = ((0, 50), nothing))\nlines!(ax2, grid.Î”záµƒáµƒá¶œ[1:Nz], grid.záµƒáµƒá¶œ[1:Nz])\nscatter!(ax2, grid.Î”záµƒáµƒá¶œ[1:Nz], grid.záµƒáµƒá¶œ[1:Nz])\n\nsave(\"plot_stretched_grid.svg\", fig); nothing # hide","category":"page"},{"location":"model_setup/grids/","page":"Grid","title":"Grid","text":"(Image: )","category":"page"},{"location":"model_setup/grids/#LatitudeLongitudeGrid","page":"Grid","title":"LatitudeLongitudeGrid","text":"","category":"section"},{"location":"model_setup/grids/","page":"Grid","title":"Grid","text":"A simple latitude-longitude grid with Float64 type can be constructed by","category":"page"},{"location":"model_setup/grids/","page":"Grid","title":"Grid","text":"julia> grid = LatitudeLongitudeGrid(size = (36, 34, 25),\n                                    longitude = (-180, 180),\n                                    latitude = (-85, 85),\n                                    z = (-1000, 0))\n36Ã—34Ã—25 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3Ã—3Ã—3 halo and with precomputed metrics\nâ”œâ”€â”€ longitude: Periodic Î» âˆˆ [-180.0, 180.0) regularly spaced with Î”Î»=10.0\nâ”œâ”€â”€ latitude:  Bounded  Ï† âˆˆ [-85.0, 85.0]   regularly spaced with Î”Ï†=5.0\nâ””â”€â”€ z:         Bounded  z âˆˆ [-1000.0, 0.0]  regularly spaced with Î”z=40.0","category":"page"},{"location":"model_setup/grids/","page":"Grid","title":"Grid","text":"For more examples see RectilinearGrid and LatitudeLongitudeGrid.","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"EditURL = \"<unknown>/examples/langmuir_turbulence.jl\"","category":"page"},{"location":"generated/langmuir_turbulence/#Langmuir-turbulence-example","page":"Langmuir turbulence","title":"Langmuir turbulence example","text":"","category":"section"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"This example implements a Langmuir turbulence simulation reported in section 4 of","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"Wagner et al., \"Near-inertial waves and turbulence driven by the growth of swell\", Journal of Physical Oceanography (2021)","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"This example demonstrates","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"How to run large eddy simulations with surface wave effects via the Craik-Leibovich approximation.\nHow to specify time- and horizontally-averaged output.","category":"page"},{"location":"generated/langmuir_turbulence/#Install-dependencies","page":"Langmuir turbulence","title":"Install dependencies","text":"","category":"section"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"using Pkg\npkg\"add Oceananigans, CairoMakie\"","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"using Oceananigans\nusing Oceananigans.Units: minute, minutes, hours","category":"page"},{"location":"generated/langmuir_turbulence/#Model-set-up","page":"Langmuir turbulence","title":"Model set-up","text":"","category":"section"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"To build the model, we specify the grid, Stokes drift, boundary conditions, and Coriolis parameter.","category":"page"},{"location":"generated/langmuir_turbulence/#Domain-and-numerical-grid-specification","page":"Langmuir turbulence","title":"Domain and numerical grid specification","text":"","category":"section"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"We use a modest resolution and the same total extent as Wagner et al. 2021,","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"grid = RectilinearGrid(size=(32, 32, 32), extent=(128, 128, 64))","category":"page"},{"location":"generated/langmuir_turbulence/#The-Stokes-Drift-profile","page":"Langmuir turbulence","title":"The Stokes Drift profile","text":"","category":"section"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"The surface wave Stokes drift profile prescribed in Wagner et al. 2021, corresponds to a 'monochromatic' (that is, single-frequency) wave field.","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"A monochromatic wave field is characterized by its wavelength and amplitude (half the distance from wave crest to wave trough), which determine the wave frequency and the vertical scale of the Stokes drift profile.","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"using Oceananigans.BuoyancyModels: g_Earth\n\n amplitude = 0.8 # m\nwavelength = 60  # m\nwavenumber = 2Ï€ / wavelength # mâ»Â¹\n frequency = sqrt(g_Earth * wavenumber) # sâ»Â¹\n\n# The vertical scale over which the Stokes drift of a monochromatic surface wave\n# decays away from the surface is `1/2wavenumber`, or\nconst vertical_scale = wavelength / 4Ï€\n\n# Stokes drift velocity at the surface\nconst UË¢ = amplitude^2 * wavenumber * frequency # m sâ»Â¹","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"The const declarations ensure that Stokes drift functions compile on the GPU. To run this example on the GPU, include GPU() in the constructor for RectilinearGrid above.","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"The Stokes drift profile is","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"uË¢(z) = UË¢ * exp(z / vertical_scale)","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"and its z-derivative is","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"âˆ‚z_uË¢(z, t) = 1 / vertical_scale * UË¢ * exp(z / vertical_scale)","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"info: The Craik-Leibovich equations in Oceananigans\nOceananigans implements the Craik-Leibovich approximation for surface wave effects using the Lagrangian-mean velocity field as its prognostic momentum variable. In other words, model.velocities.u is the Lagrangian-mean x-velocity beneath surface waves. This differs from models that use the Eulerian-mean velocity field as a prognostic variable, but has the advantage that u accounts for the total advection of tracers and momentum, and that u = v = w = 0 is a steady solution even when Coriolis forces are present. See the physics documentation for more information.","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"Finally, we note that the time-derivative of the Stokes drift must be provided if the Stokes drift and surface wave field undergoes forced changes in time. In this example, the Stokes drift is constant and thus the time-derivative of the Stokes drift is 0.","category":"page"},{"location":"generated/langmuir_turbulence/#Boundary-conditions","page":"Langmuir turbulence","title":"Boundary conditions","text":"","category":"section"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"At the surface at z=0, Wagner et al. 2021 impose","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"Qáµ˜ = -3.72e-5 # mÂ² sâ»Â², surface kinematic momentum flux\n\nu_boundary_conditions = FieldBoundaryConditions(top = FluxBoundaryCondition(Qáµ˜))","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"Wagner et al. 2021 impose a linear buoyancy gradient NÂ² at the bottom along with a weak, destabilizing flux of buoyancy at the surface to faciliate spin-up from rest.","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"Qáµ‡ = 2.307e-8 # mÂ² sâ»Â³, surface buoyancy flux\nNÂ² = 1.936e-5 # sâ»Â², initial and bottom buoyancy gradient\n\nb_boundary_conditions = FieldBoundaryConditions(top = FluxBoundaryCondition(Qáµ‡),\n                                                bottom = GradientBoundaryCondition(NÂ²))","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"info: The flux convention in Oceananigans\nNote that Oceananigans uses \"positive upward\" conventions for all fluxes. In consequence, a negative flux at the surface drives positive velocities, and a positive flux of buoyancy drives cooling.","category":"page"},{"location":"generated/langmuir_turbulence/#Coriolis-parameter","page":"Langmuir turbulence","title":"Coriolis parameter","text":"","category":"section"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"Wagner et al. (2021) use","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"coriolis = FPlane(f=1e-4) # sâ»Â¹","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"which is typical for mid-latitudes on Earth.","category":"page"},{"location":"generated/langmuir_turbulence/#Model-instantiation","page":"Langmuir turbulence","title":"Model instantiation","text":"","category":"section"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"We are ready to build the model. We use a fifth-order Weighted Essentially Non-Oscillatory (WENO) advection scheme and the AnisotropicMinimumDissipation model for large eddy simulation. Because our Stokes drift does not vary in x y, we use UniformStokesDrift, which expects Stokes drift functions of z t only.","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"model = NonhydrostaticModel(; grid, coriolis,\n                            advection = WENO(),\n                            timestepper = :RungeKutta3,\n                            tracers = :b,\n                            buoyancy = BuoyancyTracer(),\n                            closure = AnisotropicMinimumDissipation(),\n                            stokes_drift = UniformStokesDrift(âˆ‚z_uË¢=âˆ‚z_uË¢),\n                            boundary_conditions = (u=u_boundary_conditions, b=b_boundary_conditions))","category":"page"},{"location":"generated/langmuir_turbulence/#Initial-conditions","page":"Langmuir turbulence","title":"Initial conditions","text":"","category":"section"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"We make use of random noise concentrated in the upper 4 meters for buoyancy and velocity initial conditions,","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"Î(z) = randn() * exp(z / 4)\nnothing # hide","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"Our initial condition for buoyancy consists of a surface mixed layer 33 m deep, a deep linear stratification, plus noise,","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"initial_mixed_layer_depth = 33 # m\nstratification(z) = z < - initial_mixed_layer_depth ? NÂ² * z : NÂ² * (-initial_mixed_layer_depth)\n\nbáµ¢(x, y, z) = stratification(z) + 1e-1 * Î(z) * NÂ² * model.grid.Lz","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"The simulation we reproduce from Wagner et al. (2021) is zero Lagrangian-mean velocity. This initial condition is consistent with a wavy, quiescent ocean suddenly impacted by winds. To this quiescent state we add noise scaled by the friction velocity to u and w.","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"uâ˜… = sqrt(abs(Qáµ˜))\nuáµ¢(x, y, z) = uâ˜… * 1e-1 * Î(z)\nwáµ¢(x, y, z) = uâ˜… * 1e-1 * Î(z)\n\nset!(model, u=uáµ¢, w=wáµ¢, b=báµ¢)","category":"page"},{"location":"generated/langmuir_turbulence/#Setting-up-the-simulation","page":"Langmuir turbulence","title":"Setting up the simulation","text":"","category":"section"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"simulation = Simulation(model, Î”t=45.0, stop_time=4hours)","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"We use the TimeStepWizard for adaptive time-stepping with a Courant-Freidrichs-Lewy (CFL) number of 1.0,","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"wizard = TimeStepWizard(cfl=1.0, max_change=1.1, max_Î”t=1minute)\n\nsimulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10))","category":"page"},{"location":"generated/langmuir_turbulence/#Nice-progress-messaging","page":"Langmuir turbulence","title":"Nice progress messaging","text":"","category":"section"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"We define a function that prints a helpful message with maximum absolute value of u v w and the current wall clock time.","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"using Printf\n\nfunction progress(simulation)\n    u, v, w = simulation.model.velocities\n\n    # Print a progress message\n    msg = @sprintf(\"i: %04d, t: %s, Î”t: %s, umax = (%.1e, %.1e, %.1e) msâ»Â¹, wall time: %s\\n\",\n                   iteration(simulation),\n                   prettytime(time(simulation)),\n                   prettytime(simulation.Î”t),\n                   maximum(abs, u), maximum(abs, v), maximum(abs, w),\n                   prettytime(simulation.run_wall_time))\n\n    @info msg\n\n    return nothing\nend\n\nsimulation.callbacks[:progress] = Callback(progress, IterationInterval(20))","category":"page"},{"location":"generated/langmuir_turbulence/#Output","page":"Langmuir turbulence","title":"Output","text":"","category":"section"},{"location":"generated/langmuir_turbulence/#A-field-writer","page":"Langmuir turbulence","title":"A field writer","text":"","category":"section"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"We set up an output writer for the simulation that saves all velocity fields, tracer fields, and the subgrid turbulent diffusivity.","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"output_interval = 5minutes\n\nfields_to_output = merge(model.velocities, model.tracers, (; Î½â‚‘=model.diffusivity_fields.Î½â‚‘))\n\nsimulation.output_writers[:fields] =\n    JLD2OutputWriter(model, fields_to_output,\n                     schedule = TimeInterval(output_interval),\n                     filename = \"langmuir_turbulence_fields.jld2\",\n                     overwrite_existing = true)","category":"page"},{"location":"generated/langmuir_turbulence/#An-\"averages\"-writer","page":"Langmuir turbulence","title":"An \"averages\" writer","text":"","category":"section"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"We also set up output of time- and horizontally-averaged velocity field and momentum fluxes,","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"u, v, w = model.velocities\nb = model.tracers.b\n\n U = Average(u, dims=(1, 2))\n V = Average(v, dims=(1, 2))\n B = Average(b, dims=(1, 2))\nwu = Average(w * u, dims=(1, 2))\nwv = Average(w * v, dims=(1, 2))\n\nsimulation.output_writers[:averages] =\n    JLD2OutputWriter(model, (; U, V, B, wu, wv),\n                     schedule = AveragedTimeInterval(output_interval, window=2minutes),\n                     filename = \"langmuir_turbulence_averages.jld2\",\n                     overwrite_existing = true)","category":"page"},{"location":"generated/langmuir_turbulence/#Running-the-simulation","page":"Langmuir turbulence","title":"Running the simulation","text":"","category":"section"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"This part is easy,","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"run!(simulation)","category":"page"},{"location":"generated/langmuir_turbulence/#Making-a-neat-movie","page":"Langmuir turbulence","title":"Making a neat movie","text":"","category":"section"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"We look at the results by loading data from file with FieldTimeSeries, and plotting vertical slices of u and w, and a horizontal slice of w to look for Langmuir cells.","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"using CairoMakie\n\ntime_series = (;\n     w = FieldTimeSeries(\"langmuir_turbulence_fields.jld2\", \"w\"),\n     u = FieldTimeSeries(\"langmuir_turbulence_fields.jld2\", \"u\"),\n     B = FieldTimeSeries(\"langmuir_turbulence_averages.jld2\", \"B\"),\n     U = FieldTimeSeries(\"langmuir_turbulence_averages.jld2\", \"U\"),\n     V = FieldTimeSeries(\"langmuir_turbulence_averages.jld2\", \"V\"),\n    wu = FieldTimeSeries(\"langmuir_turbulence_averages.jld2\", \"wu\"),\n    wv = FieldTimeSeries(\"langmuir_turbulence_averages.jld2\", \"wv\"))\n\ntimes = time_series.w.times\nxw, yw, zw = nodes(time_series.w)\nxu, yu, zu = nodes(time_series.u)\nnothing # hide","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"We are now ready to animate using Makie. We use Makie's Observable to animate the data. To dive into how Observables work we refer to Makie.jl's Documentation.","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"n = Observable(1)\n\nwxy_title = @lift string(\"w(x, y, t) at z=-8 m and t = \", prettytime(times[$n]))\nwxz_title = @lift string(\"w(x, z, t) at y=0 m and t = \", prettytime(times[$n]))\nuxz_title = @lift string(\"u(x, z, t) at y=0 m and t = \", prettytime(times[$n]))\n\nfig = Figure(resolution = (850, 850))\n\nax_B = Axis(fig[1, 4];\n            xlabel = \"Buoyancy (m sâ»Â²)\",\n            ylabel = \"z (m)\")\n\nax_U = Axis(fig[2, 4];\n            xlabel = \"Velocities (m sâ»Â¹)\",\n            ylabel = \"z (m)\",\n            limits = ((-0.07, 0.07), nothing))\n\nax_fluxes = Axis(fig[3, 4];\n                 xlabel = \"Momentum fluxes (mÂ² sâ»Â²)\",\n                 ylabel = \"z (m)\",\n                 limits = ((-3.5e-5, 3.5e-5), nothing))\n\nax_wxy = Axis(fig[1, 1:2];\n              xlabel = \"x (m)\",\n              ylabel = \"y (m)\",\n              aspect = DataAspect(),\n              limits = ((0, grid.Lx), (0, grid.Ly)),\n              title = wxy_title)\n\nax_wxz = Axis(fig[2, 1:2];\n              xlabel = \"x (m)\",\n              ylabel = \"z (m)\",\n              aspect = AxisAspect(2),\n              limits = ((0, grid.Lx), (-grid.Lz, 0)),\n              title = wxz_title)\n\nax_uxz = Axis(fig[3, 1:2];\n              xlabel = \"x (m)\",\n              ylabel = \"z (m)\",\n              aspect = AxisAspect(2),\n              limits = ((0, grid.Lx), (-grid.Lz, 0)),\n              title = uxz_title)\n\nnothing #hide\n\nwâ‚™ = @lift time_series.w[$n]\nuâ‚™ = @lift time_series.u[$n]\nBâ‚™ = @lift time_series.B[$n][1, 1, :]\nUâ‚™ = @lift time_series.U[$n][1, 1, :]\nVâ‚™ = @lift time_series.V[$n][1, 1, :]\nwuâ‚™ = @lift time_series.wu[$n][1, 1, :]\nwvâ‚™ = @lift time_series.wv[$n][1, 1, :]\n\nk = searchsortedfirst(grid.záµƒáµƒá¶ [:], -8)\nwxyâ‚™ = @lift interior(time_series.w[$n], :, :, k)\nwxzâ‚™ = @lift interior(time_series.w[$n], :, 1, :)\nuxzâ‚™ = @lift interior(time_series.u[$n], :, 1, :)\n\nwlims = (-0.03, 0.03)\nulims = (-0.05, 0.05)\n\nlines!(ax_B, Bâ‚™, zu)\n\nlines!(ax_U, Uâ‚™, zu; label = L\"\\bar{u}\")\nlines!(ax_U, Vâ‚™, zu; label = L\"\\bar{v}\")\naxislegend(ax_U; position = :rb)\n\nlines!(ax_fluxes, wuâ‚™, zw; label = L\"mean $wu$\")\nlines!(ax_fluxes, wvâ‚™, zw; label = L\"mean $wv$\")\naxislegend(ax_fluxes; position = :rb)\n\nhm_wxy = heatmap!(ax_wxy, xw, yw, wxyâ‚™;\n                  colorrange = wlims,\n                  colormap = :balance)\n\nColorbar(fig[1, 3], hm_wxy; label = \"m sâ»Â¹\")\n\nhm_wxz = heatmap!(ax_wxz, xw, zw, wxzâ‚™;\n                  colorrange = wlims,\n                  colormap = :balance)\n\nColorbar(fig[2, 3], hm_wxz; label = \"m sâ»Â¹\")\n\nax_uxz = heatmap!(ax_uxz, xu, zu, uxzâ‚™;\n                  colorrange = ulims,\n                  colormap = :balance)\n\nColorbar(fig[3, 3], ax_uxz; label = \"m sâ»Â¹\")\n\ncurrent_figure() # hide\nfig","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"And, finally, we record a movie.","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"frames = 1:length(times)\n\nrecord(fig, \"langmuir_turbulence.mp4\", frames, framerate=8) do i\n    msg = string(\"Plotting frame \", i, \" of \", frames[end])\n    print(msg * \" \\r\")\n    n[] = i\nend\nnothing #hide","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"(Image: )","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"","category":"page"},{"location":"generated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"EditURL = \"<unknown>/examples/ocean_wind_mixing_and_convection.jl\"","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#gpu_example","page":"Ocean wind mixing and convection","title":"Wind- and convection-driven mixing in an ocean surface boundary layer","text":"","category":"section"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"This example simulates mixing by three-dimensional turbulence in an ocean surface boundary layer driven by atmospheric winds and convection. It demonstrates:","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"How to set-up a grid with varying spacing in the vertical direction\nHow to use the SeawaterBuoyancy model for buoyancy with a linear equation of state.\nHow to use a turbulence closure for large eddy simulation.\nHow to use a function to impose a boundary condition.","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#Install-dependencies","page":"Ocean wind mixing and convection","title":"Install dependencies","text":"","category":"section"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"using Pkg\npkg\"add Oceananigans, CairoMakie\"","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We start by importing all of the packages and functions that we'll need for this example.","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"using Random\nusing Printf\nusing CairoMakie\n\nusing Oceananigans\nusing Oceananigans.Units: minute, minutes, hour","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#The-grid","page":"Ocean wind mixing and convection","title":"The grid","text":"","category":"section"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We use 32Â²Ã—24 grid points with 2 m grid spacing in the horizontal and varying spacing in the vertical, with higher resolution closer to the surface. Here we use a stretching function for the vertical nodes that maintains relatively constant vertical spacing in the mixed layer, which is desirable from a numerical standpoint:","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Nx = Ny = 32     # number of points in each of horizontal directions\nNz = 24          # number of points in the vertical direction\n\nLx = Ly = 64     # (m) domain horizontal extents\nLz = 32          # (m) domain depth\n\nrefinement = 1.2 # controls spacing near surface (higher means finer spaced)\nstretching = 12  # controls rate of stretching at bottom\n\n# Normalized height ranging from 0 to 1\nh(k) = (k - 1) / Nz\n\n# Linear near-surface generator\nÎ¶â‚€(k) = 1 + (h(k) - 1) / refinement\n\n# Bottom-intensified stretching function\nÎ£(k) = (1 - exp(-stretching * h(k))) / (1 - exp(-stretching))\n\n# Generating function\nz_faces(k) = Lz * (Î¶â‚€(k) * Î£(k) - 1)\n\ngrid = RectilinearGrid(size = (Nx, Nx, Nz),\n                          x = (0, Lx),\n                          y = (0, Ly),\n                          z = z_faces)","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We plot vertical spacing versus depth to inspect the prescribed grid stretching:","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"fig = Figure(resolution=(1200, 800))\nax = Axis(fig[1, 1], ylabel = \"Depth (m)\", xlabel = \"Vertical spacing (m)\")\n\nlines!(ax, zspacings(grid, Center()), znodes(grid, Center()))\nscatter!(ax, zspacings(grid, Center()), znodes(grid, Center()))\n\ncurrent_figure() # hide\nfig","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#Buoyancy-that-depends-on-temperature-and-salinity","page":"Ocean wind mixing and convection","title":"Buoyancy that depends on temperature and salinity","text":"","category":"section"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We use the SeawaterBuoyancy model with a linear equation of state,","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"buoyancy = SeawaterBuoyancy(equation_of_state=LinearEquationOfState(thermal_expansion = 2e-4,\n                                                                    haline_contraction = 8e-4))","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#Boundary-conditions","page":"Ocean wind mixing and convection","title":"Boundary conditions","text":"","category":"section"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We calculate the surface temperature flux associated with surface cooling of 200 W mâ»Â², reference density Ïâ‚’, and heat capacity cá´¾,","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"QÊ° = 200.0  # W mâ»Â², surface _heat_ flux\nÏâ‚’ = 1026.0 # kg mâ»Â³, average density at the surface of the world ocean\ncá´¾ = 3991.0 # J Kâ»Â¹ kgâ»Â¹, typical heat capacity for seawater\n\nQáµ€ = QÊ° / (Ïâ‚’ * cá´¾) # K m sâ»Â¹, surface _temperature_ flux","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Finally, we impose a temperature gradient dTdz both initially and at the bottom of the domain, culminating in the boundary conditions on temperature,","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"dTdz = 0.01 # K mâ»Â¹\n\nT_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qáµ€),\n                                bottom = GradientBoundaryCondition(dTdz))","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Note that a positive temperature flux at the surface of the ocean implies cooling. This is because a positive temperature flux implies that temperature is fluxed upwards, out of the ocean.","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"For the velocity field, we imagine a wind blowing over the ocean surface with an average velocity at 10 meters uâ‚â‚€, and use a drag coefficient cá´° to estimate the kinematic stress (that is, stress divided by density) exerted by the wind on the ocean:","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"uâ‚â‚€ = 10    # m sâ»Â¹, average wind velocity 10 meters above the ocean\ncá´° = 2.5e-3 # dimensionless drag coefficient\nÏâ‚ = 1.225  # kg mâ»Â³, average density of air at sea-level\n\nQáµ˜ = - Ïâ‚ / Ïâ‚’ * cá´° * uâ‚â‚€ * abs(uâ‚â‚€) # mÂ² sâ»Â²","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"The boundary conditions on u are thus","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"u_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qáµ˜))","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"For salinity, S, we impose an evaporative flux of the form","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"@inline QË¢(x, y, t, S, evaporation_rate) = - evaporation_rate * S # [salinity unit] m sâ»Â¹\nnothing # hide","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"where S is salinity. We use an evporation rate of 1 millimeter per hour,","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"evaporation_rate = 1e-3 / hour # m sâ»Â¹","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We build the Flux evaporation BoundaryCondition with the function QË¢, indicating that QË¢ depends on salinity S and passing the parameter evaporation_rate,","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"evaporation_bc = FluxBoundaryCondition(QË¢, field_dependencies=:S, parameters=evaporation_rate)","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"The full salinity boundary conditions are","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"S_bcs = FieldBoundaryConditions(top=evaporation_bc)","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#Model-instantiation","page":"Ocean wind mixing and convection","title":"Model instantiation","text":"","category":"section"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We fill in the final details of the model here: upwind-biased 5th-order advection for momentum and tracers, 3rd-order Runge-Kutta time-stepping, Coriolis forces, and the AnisotropicMinimumDissipation closure for large eddy simulation to model the effect of turbulent motions at scales smaller than the grid scale that we cannot explicitly resolve.","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"model = NonhydrostaticModel(; grid, buoyancy,\n                            advection = UpwindBiasedFifthOrder(),\n                            timestepper = :RungeKutta3,\n                            tracers = (:T, :S),\n                            coriolis = FPlane(f=1e-4),\n                            closure = AnisotropicMinimumDissipation(),\n                            boundary_conditions = (u=u_bcs, T=T_bcs, S=S_bcs))","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Notes:","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"To use the Smagorinsky-Lilly turbulence closure (with a constant model coefficient) rather than AnisotropicMinimumDissipation, use closure = SmagorinskyLilly() in the model constructor.\nTo change the architecture to GPU, replace CPU() with GPU() inside the grid constructor.","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#Initial-conditions","page":"Ocean wind mixing and convection","title":"Initial conditions","text":"","category":"section"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Our initial condition for temperature consists of a linear stratification superposed with random noise damped at the walls, while our initial condition for velocity consists only of random noise.","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"# Random noise damped at top and bottom\nÎ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz) # noise\n\n# Temperature initial condition: a stable density gradient with random noise superposed.\nTáµ¢(x, y, z) = 20 + dTdz * z + dTdz * model.grid.Lz * 1e-6 * Î(z)\n\n# Velocity initial condition: random noise scaled by the friction velocity.\nuáµ¢(x, y, z) = sqrt(abs(Qáµ˜)) * 1e-3 * Î(z)\n\n# `set!` the `model` fields using functions or constants:\nset!(model, u=uáµ¢, w=uáµ¢, T=Táµ¢, S=35)","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#Setting-up-a-simulation","page":"Ocean wind mixing and convection","title":"Setting up a simulation","text":"","category":"section"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We set-up a simulation with an initial time-step of 10 seconds that stops at 40 minutes, with adaptive time-stepping and progress printing.","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"simulation = Simulation(model, Î”t=10.0, stop_time=40minutes)","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"The TimeStepWizard helps ensure stable time-stepping with a Courant-Freidrichs-Lewy (CFL) number of 1.0.","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"wizard = TimeStepWizard(cfl=1.0, max_change=1.1, max_Î”t=1minute)\nsimulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10))","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Nice progress messaging is helpful:","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"# Print a progress message\nprogress_message(sim) = @printf(\"Iteration: %04d, time: %s, Î”t: %s, max(|w|) = %.1e msâ»Â¹, wall time: %s\\n\",\n                                iteration(sim), prettytime(sim), prettytime(sim.Î”t),\n                                maximum(abs, sim.model.velocities.w), prettytime(sim.run_wall_time))\n\nsimulation.callbacks[:progress] = Callback(progress_message, IterationInterval(20))","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We then set up the simulation:","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#Output","page":"Ocean wind mixing and convection","title":"Output","text":"","category":"section"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We use the JLD2OutputWriter to save x z slices of the velocity fields, tracer fields, and eddy diffusivities. The prefix keyword argument to JLD2OutputWriter indicates that output will be saved in ocean_wind_mixing_and_convection.jld2.","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"# Create a NamedTuple with eddy viscosity\neddy_viscosity = (; Î½â‚‘ = model.diffusivity_fields.Î½â‚‘)\n\nfilename = \"ocean_wind_mixing_and_convection\"\n\nsimulation.output_writers[:slices] =\n    JLD2OutputWriter(model, merge(model.velocities, model.tracers, eddy_viscosity),\n                     filename = filename * \".jld2\",\n                     indices = (:, grid.Ny/2, :),\n                     schedule = TimeInterval(1minute),\n                     overwrite_existing = true)","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We're ready:","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"run!(simulation)","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#Turbulence-visualization","page":"Ocean wind mixing and convection","title":"Turbulence visualization","text":"","category":"section"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We animate the data saved in ocean_wind_mixing_and_convection.jld2. We prepare for animating the flow by loading the data into FieldTimeSeries and defining functions for computing colorbar limits.","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"filepath = filename * \".jld2\"\n\ntime_series = (w = FieldTimeSeries(filepath, \"w\"),\n               T = FieldTimeSeries(filepath, \"T\"),\n               S = FieldTimeSeries(filepath, \"S\"),\n               Î½â‚‘ = FieldTimeSeries(filepath, \"Î½â‚‘\"))\n\n# Coordinate arrays\nxw, yw, zw = nodes(time_series.w)\nxT, yT, zT = nodes(time_series.T)","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We start the animation at t = 10minutes since things are pretty boring till then:","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"times = time_series.w.times\nintro = searchsortedfirst(times, 10minutes)","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We are now ready to animate using Makie. We use Makie's Observable to animate the data. To dive into how Observables work we refer to Makie.jl's Documentation.","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"n = Observable(intro)\n\n wâ‚™ = @lift interior(time_series.w[$n],  :, 1, :)\n Tâ‚™ = @lift interior(time_series.T[$n],  :, 1, :)\n Sâ‚™ = @lift interior(time_series.S[$n],  :, 1, :)\nÎ½â‚‘â‚™ = @lift interior(time_series.Î½â‚‘[$n], :, 1, :)\n\nfig = Figure(resolution = (1000, 500))\n\naxis_kwargs = (xlabel=\"x (m)\",\n               ylabel=\"z (m)\",\n               aspect = AxisAspect(grid.Lx/grid.Lz),\n               limits = ((0, grid.Lx), (-grid.Lz, 0)))\n\nax_w  = Axis(fig[2, 1]; title = \"Vertical velocity\", axis_kwargs...)\nax_T  = Axis(fig[2, 3]; title = \"Temperature\", axis_kwargs...)\nax_S  = Axis(fig[3, 1]; title = \"Salinity\", axis_kwargs...)\nax_Î½â‚‘ = Axis(fig[3, 3]; title = \"Eddy viscocity\", axis_kwargs...)\n\ntitle = @lift @sprintf(\"t = %s\", prettytime(times[$n]))\n\nwlims = (-0.05, 0.05)\nTlims = (19.7, 19.99)\nSlims = (35, 35.005)\nÎ½â‚‘lims = (1e-6, 5e-3)\n\nhm_w = heatmap!(ax_w, xw, zw, wâ‚™; colormap = :balance, colorrange = wlims)\nColorbar(fig[2, 2], hm_w; label = \"m sâ»Â¹\")\n\nhm_T = heatmap!(ax_T, xT, zT, Tâ‚™; colormap = :thermal, colorrange = Tlims)\nColorbar(fig[2, 4], hm_T; label = \"áµ’C\")\n\nhm_S = heatmap!(ax_S, xT, zT, Sâ‚™; colormap = :haline, colorrange = Slims)\nColorbar(fig[3, 2], hm_S; label = \"g / kg\")\n\nhm_Î½â‚‘ = heatmap!(ax_Î½â‚‘, xT, zT, Î½â‚‘â‚™; colormap = :thermal, colorrange = Î½â‚‘lims)\nColorbar(fig[3, 4], hm_Î½â‚‘; label = \"m sâ»Â²\")\n\nfig[1, 1:4] = Label(fig, title, fontsize=24, tellwidth=false)\n\ncurrent_figure() # hide\nfig","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"And now record a movie.","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"frames = intro:length(times)\n\n@info \"Making a motion picture of ocean wind mixing and convection...\"\n\nrecord(fig, filename * \".mp4\", frames, framerate=8) do i\n    msg = string(\"Plotting frame \", i, \" of \", frames[end])\n    print(msg * \" \\r\")\n    n[] = i\nend\nnothing #hide","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"(Image: )","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"This page was generated using Literate.jl.","category":"page"},{"location":"model_setup/checkpointing/#Checkpointing","page":"Checkpointing","title":"Checkpointing","text":"","category":"section"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"A checkpointer can be used to serialize the entire model state to a file from which the model can be restored at any time. This is useful if you'd like to periodically checkpoint when running long simulations in case of crashes or cluster time limits, but also if you'd like to restore from a checkpoint and try out multiple scenarios.","category":"page"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"For example, to periodically checkpoint the model state to disk every 1,000,000 seconds of simulation time to files of the form model_checkpoint_iteration12500.jld2 where 12500 is the iteration number (automatically filled in)","category":"page"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"DocTestSetup = quote\n    using Oceananigans\nend","category":"page"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"using Oceananigans, Oceananigans.Units\n\nmodel = NonhydrostaticModel(grid=RectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1)))\n\nsimulation = Simulation(model, Î”t=1, stop_iteration=1)\n\nsimulation.output_writers[:checkpointer] = Checkpointer(model, schedule=TimeInterval(5days), prefix=\"model_checkpoint\")\n\nrun!(simulation)","category":"page"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"The default options should provide checkpoint files that are easy to restore from in most cases. For more advanced options and features, see Checkpointer.","category":"page"},{"location":"model_setup/checkpointing/#Picking-up-a-simulation-from-a-checkpoint-file","page":"Checkpointing","title":"Picking up a simulation from a checkpoint file","text":"","category":"section"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"Picking up a simulation from a checkpoint requires the original script that was used to generate the checkpoint data. Change the first instance of run! in the script to take pickup=true:","category":"page"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"simulation.stop_iteration = 2\n\nrun!(simulation, pickup=true)","category":"page"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"which finds the latest checkpoint file in the current working directory (in this trivial case, this is the checkpoint associated with iteration 0), loads prognostic fields and their tendencies from file, resets the model clock and iteration, and updates the model auxiliary state before starting the time-stepping loop.","category":"page"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"Use pickup=iteration, where iteration is an Integer, to pick up from a specific iteration. Or, use pickup=filepath, where filepath is a string, to pickup from a specific file located at filepath.","category":"page"},{"location":"model_setup/forcing_functions/#Forcing-functions","page":"Forcing functions","title":"Forcing functions","text":"","category":"section"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"\"Forcings\" are user-defined terms appended to right-hand side of the momentum or tracer evolution equations. In Oceananigans, momentum and tracer forcings are defined via julia functions. Oceananigans includes an interface for implementing forcing functions that depend on spatial coordinates, time, model velocity and tracer fields, and external parameters.","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"DocTestSetup = quote\n    using Oceananigans\nend","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"Forcings are added to Oceananigans models by passing a NamedTuple of functions or forcing objects to the forcing keyword argument in NonhydrostaticModel's constructor. By default, momentum and tracer forcing functions are assumed to be functions of x, y, z, t. A basic example is","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"u_forcing(x, y, z, t) = exp(z) * cos(x) * sin(t)\n\ngrid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))\nmodel = NonhydrostaticModel(grid=grid, forcing=(u=u_forcing,))\n\nmodel.forcing.u\n\n# output\nContinuousForcing{Nothing} at (Face, Center, Center)\nâ”œâ”€â”€ func: u_forcing (generic function with 1 method)\nâ”œâ”€â”€ parameters: nothing\nâ””â”€â”€ field dependencies: ()","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"More general forcing functions are built via the Forcing constructor described below. Oceananigans also provides two convenience types:     * Relaxation for damping terms that restore a field to a       target distribution outside of a masked region of space. Relaxation can be       used to implement sponge layers near the boundaries of a domain.     * AdvectiveForcing for advecting individual quantities by a separate or       \"slip\" velocity relative to both the prognostic model velocity field and any       BackgroundField velocity field.","category":"page"},{"location":"model_setup/forcing_functions/#The-Forcing-constructor","page":"Forcing functions","title":"The Forcing constructor","text":"","category":"section"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"The Forcing constructor provides an interface for specifying forcing functions that","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"Depend on external parameters; and\nDepend on model fields at the x, y, z location that forcing is applied; and/or\nRequire access to discrete model data.","category":"page"},{"location":"model_setup/forcing_functions/#Forcing-functions-with-external-parameters","page":"Forcing functions","title":"Forcing functions with external parameters","text":"","category":"section"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"Most forcings involve external, changeable parameters. Here are two examples of forcing_functions that depend on  (i) a single scalar parameter s, and (ii) a NamedTuple of parameters, p:","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"# Forcing that depends on a scalar parameter `s`\nu_forcing_func(x, y, z, t, s) = s * z\n\nu_forcing = Forcing(u_forcing_func, parameters=0.1)\n\n# Forcing that depends on a `NamedTuple` of parameters `p`\nT_forcing_func(x, y, z, t, p) = - p.Î¼ * exp(z / p.Î») * cos(p.k * x) * sin(p.Ï‰ * t)\n\nT_forcing = Forcing(T_forcing_func, parameters=(Î¼=1, Î»=0.5, k=2Ï€, Ï‰=4Ï€))\n\ngrid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))\nmodel = NonhydrostaticModel(grid=grid, forcing=(u=u_forcing, T=T_forcing), buoyancy=SeawaterBuoyancy(), tracers=(:T, :S))\n\nmodel.forcing.T\n\n# output\nContinuousForcing{NamedTuple{(:Î¼, :Î», :k, :Ï‰), Tuple{Int64, Float64, Float64, Float64}}} at (Center, Center, Center)\nâ”œâ”€â”€ func: T_forcing_func (generic function with 1 method)\nâ”œâ”€â”€ parameters: (Î¼ = 1, Î» = 0.5, k = 6.283185307179586, Ï‰ = 12.566370614359172)\nâ””â”€â”€ field dependencies: ()","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"model.forcing.u\n\n# output\nContinuousForcing{Float64} at (Face, Center, Center)\nâ”œâ”€â”€ func: u_forcing_func (generic function with 1 method)\nâ”œâ”€â”€ parameters: 0.1\nâ””â”€â”€ field dependencies: ()","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"In this example, the objects passed to the parameters keyword in the construction of u_forcing and T_forcing â€“- a floating point number for u_forcing, and a NamedTuple of parameters for T_forcing â€“- are passed on to u_forcing_func and T_forcing_func when they are called during time-stepping. The object passed to parameters is in principle arbitrary. However, if using the GPU, then typeof(parameters) may be restricted by the requirements of GPU-compiliability.","category":"page"},{"location":"model_setup/forcing_functions/#Forcing-functions-that-depend-on-model-fields","page":"Forcing functions","title":"Forcing functions that depend on model fields","text":"","category":"section"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"Forcing functions may depend on model fields (velocity, tracers or auxiliary fields) evaluated at the x, y, z where forcing is applied. Here's a somewhat non-sensical example:","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"# Forcing that depends on the velocity fields `u`, `v`, and `w`\nw_forcing_func(x, y, z, t, u, v, w) = - (u^2 + v^2 + w^2) / 2\n\nw_forcing = Forcing(w_forcing_func, field_dependencies=(:u, :v, :w))\n\n# Forcing that depends on salinity `S` and a scalar parameter\nS_forcing_func(x, y, z, t, S, Î¼) = - Î¼ * S\n\nS_forcing = Forcing(S_forcing_func, parameters=0.01, field_dependencies=:S)\n\ngrid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))\nmodel = NonhydrostaticModel(grid=grid, forcing=(w=w_forcing, S=S_forcing), buoyancy=SeawaterBuoyancy(), tracers=(:T, :S))\n\nmodel.forcing.w\n\n# output\nContinuousForcing{Nothing} at (Center, Center, Face)\nâ”œâ”€â”€ func: w_forcing_func (generic function with 1 method)\nâ”œâ”€â”€ parameters: nothing\nâ””â”€â”€ field dependencies: (:u, :v, :w)","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"model.forcing.S\n\n# output\nContinuousForcing{Float64} at (Center, Center, Center)\nâ”œâ”€â”€ func: S_forcing_func (generic function with 1 method)\nâ”œâ”€â”€ parameters: 0.01\nâ””â”€â”€ field dependencies: (:S,)","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"The field_dependencies arguments follow x, y, z, t in the forcing function in the order they are specified in Forcing. If both field_dependencies and parameters are specified, then the field_dependencies arguments follow x, y, z, t, and parameters follow field_dependencies.","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"Model fields that arise in the arguments of continuous Forcing functions are automatically interpolated to the staggered grid location at which the forcing is applied.","category":"page"},{"location":"model_setup/forcing_functions/#\"Discrete-form\"-forcing-functions","page":"Forcing functions","title":"\"Discrete form\" forcing functions","text":"","category":"section"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"\"Discrete form\" forcing functions are either called with the signature","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"func(i, j, k, grid, clock, model_fields)","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"or the parameterized form","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"func(i, j, k, grid, clock, model_fields, parameters)","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"Discrete form forcing functions can access the entirety of model field data through the argument model_fields. The object model_fields is a NamedTuple whose properties include the velocity fields model_fields.u, model_fields.v, model_fields.w and all fields in model.tracers.","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"Using discrete forcing functions may require understanding the staggered arrangement of velocity fields and tracers in Oceananigans. Here's a slightly non-sensical example in which the vertical derivative of a buoyancy tracer is used as a time-scale for damping the u-velocity field:","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"# A damping term that depends on a \"local average\":\nlocal_average(i, j, k, grid, c) = @inbounds (c[i, j, k] + c[i-1, j, k] + c[i+1, j, k] +\n                                                          c[i, j-1, k] + c[i, j+1, k] +\n                                                          c[i, j, k-1] + c[i, j, k+1]) / 7\n\nb_forcing_func(i, j, k, grid, clock, model_fields) = - local_average(i, j, k, grid, model_fields.b)\n\nb_forcing = Forcing(b_forcing_func, discrete_form=true)\n\n# A term that damps the local velocity field in the presence of stratification\nusing Oceananigans.Operators: âˆ‚zá¶ á¶œá¶ , â„‘xzá¶ áµƒá¶œ\n\nfunction u_forcing_func(i, j, k, grid, clock, model_fields, Îµ)\n    # The vertical derivative of buoyancy, interpolated to the u-velocity location:\n    NÂ² = â„‘xzá¶ áµƒá¶œ(i, j, k, grid, âˆ‚zá¶ á¶œá¶ , model_fields.b)\n\n    # Set to zero in unstable stratification where NÂ² < 0:\n    NÂ² = max(NÂ², zero(typeof(NÂ²)))\n\n    return @inbounds - Îµ * sqrt(NÂ²) * model_fields.u[i, j, k]\nend\n\nu_forcing = Forcing(u_forcing_func, discrete_form=true, parameters=1e-3)\n\ngrid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))\nmodel = NonhydrostaticModel(grid=grid, tracers=:b, buoyancy=BuoyancyTracer(), forcing=(u=u_forcing, b=b_forcing))\n\nmodel.forcing.b\n\n# output\nDiscreteForcing{Nothing}\nâ”œâ”€â”€ func: b_forcing_func (generic function with 1 method)\nâ””â”€â”€ parameters: nothing","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"model.forcing.u\n\n# output\nDiscreteForcing{Float64}\nâ”œâ”€â”€ func: u_forcing_func (generic function with 1 method)\nâ””â”€â”€ parameters: 0.001","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"The annotation @inbounds is crucial for performance when accessing array indices of the fields in model_fields.","category":"page"},{"location":"model_setup/forcing_functions/#Relaxation","page":"Forcing functions","title":"Relaxation","text":"","category":"section"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"Relaxation defines a special forcing function that restores a field at a specified rate to a target distribution, within a region uncovered by a masking function. Relaxation is useful for implementing sponge layers, as shown in the second example.","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"The following code constructs a model in which all components of the velocity field are damped to zero everywhere on a time-scale of 1000 seconds, or ~17 minutes:","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"damping = Relaxation(rate = 1/1000)\n\ngrid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)) \nmodel = NonhydrostaticModel(grid=grid, forcing=(u=damping, v=damping, w=damping))\n\nmodel.forcing.w\n\n# output\nContinuousForcing{Nothing} at (Center, Center, Face)\nâ”œâ”€â”€ func: Relaxation(rate=0.001, mask=1, target=0)\nâ”œâ”€â”€ parameters: nothing\nâ””â”€â”€ field dependencies: (:w,)","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"The constructor for Relaxation accepts the keyword arguments mask, and target, which specify a mask(x, y, z) function that multiplies the forcing, and a target(x, y, z) distribution for the quantity in question. By default, mask uncovered the whole domain and target restores the field in question to 0","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"We illustrate usage of mask and target by implementing a sponge layer that relaxes velocity fields to zero and restores temperature to a linear gradient in the bottom 1/10th of the domain:","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"grid = RectilinearGrid(size=(1, 1, 1), x=(0, 1), y=(0, 1), z=(-1, 0))\n\n        damping_rate = 1/100 # relax fields on a 100 second time-scale\ntemperature_gradient = 0.001 # â°C mâ»Â¹\n surface_temperature = 20    # â°C (at z=0)\n\ntarget_temperature = LinearTarget{:z}(intercept=surface_temperature, gradient=temperature_gradient)\n       bottom_mask = GaussianMask{:z}(center=-grid.Lz, width=grid.Lz/10)\n\nuvw_sponge = Relaxation(rate=damping_rate, mask=bottom_mask)\n  T_sponge = Relaxation(rate=damping_rate, mask=bottom_mask, target=target_temperature)\n\nmodel = NonhydrostaticModel(grid=grid, forcing=(u=uvw_sponge, v=uvw_sponge, w=uvw_sponge, T=T_sponge), buoyancy=SeawaterBuoyancy(), tracers=(:T, :S))\n\nmodel.forcing.u\n\n# output\nContinuousForcing{Nothing} at (Face, Center, Center)\nâ”œâ”€â”€ func: Relaxation(rate=0.01, mask=exp(-(z + 1.0)^2 / (2 * 0.1^2)), target=0)\nâ”œâ”€â”€ parameters: nothing\nâ””â”€â”€ field dependencies: (:u,)","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"model.forcing.T\n\n# output\nContinuousForcing{Nothing} at (Center, Center, Center)\nâ”œâ”€â”€ func: Relaxation(rate=0.01, mask=exp(-(z + 1.0)^2 / (2 * 0.1^2)), target=20.0 + 0.001 * z)\nâ”œâ”€â”€ parameters: nothing\nâ””â”€â”€ field dependencies: (:T,)","category":"page"},{"location":"model_setup/forcing_functions/#AdvectiveForcing","page":"Forcing functions","title":"AdvectiveForcing","text":"","category":"section"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"AdvectiveForcing defines a forcing function that represents advection by a separate or \"slip\" velocity relative to the prognostic model velocity field. AdvectiveForcing is implemented with native Oceananigans advection operators, which means that tracers advected by the \"flux form\" advection term ğ®_rm slip c. Caution is advised when ğ®_rm slip is not divergence free.","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"As an example, consider a model for sediment settling at a constant rate:","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"using Oceananigans\n\nr_sediment = 1e-4 # [m] \"Fine sand\"\nÏ_sediment = 1200 # kg mâ»Â³\nÏ_ocean = 1026 # kg mâ»Â³\nÎ”b = 9.81 * (Ï_ocean - Ï_sediment) / Ï_ocean # m sâ»Â²\nÎ½_molecular = 1.05e-6 # mÂ² sâ»Â¹\nw_sediment = 2/9 * Î”b / Î½_molecular * r_sediment^2 # m sâ»Â¹\n\nsinking = AdvectiveForcing(UpwindBiasedFifthOrder(), w=w_sediment)\n\n# output\nAdvectiveForcing with the UpwindBiased scheme:\nâ”œâ”€â”€ u: ZeroField{Int64}\nâ”œâ”€â”€ v: ZeroField{Int64}\nâ””â”€â”€ w: ConstantField(-0.00352102)","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"The first argument to AdvectiveForcing is the advection scheme (here UpwindBiasedFifthOrder()). The three keyword arguments specify the u, v, and w components of the separate slip velocity field. The default for each u, v, w is ZeroField.","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"Next we consider a dynamically-evolving slip velocity. For this we use ZFaceField with appropriate boundary conditions as our slip velocity:","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"using Oceananigans\nusing Oceananigans.BoundaryConditions: ImpenetrableBoundaryCondition\n\ngrid = RectilinearGrid(size=(32, 32, 32), x=(-10, 10), y=(-10, 10), z=(-4, 4),\n                       topology=(Periodic, Periodic, Bounded))\n\nno_penetration = ImpenetrableBoundaryCondition()\nslip_bcs = FieldBoundaryConditions(grid, (Center, Center, Face),\n                                   top=no_penetration, bottom=no_penetration)\n\nw_slip = ZFaceField(grid, boundary_conditions=slip_bcs)\nsinking = AdvectiveForcing(WENO(; grid), w=w_slip)\n\n# output\nAdvectiveForcing with the WENO scheme:\nâ”œâ”€â”€ u: ZeroField{Int64}\nâ”œâ”€â”€ v: ZeroField{Int64}\nâ””â”€â”€ w: 32Ã—32Ã—33 Field{Center, Center, Face} on RectilinearGrid on CPU","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"To compute the slip velocity, we must add a Callbackto simulations.callback that computes w_slip ever iteration:","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"using Oceananigans.BoundaryConditions: fill_halo_regions!\n\nmodel = NonhydrostaticModel(; grid, tracers=(:b, :P), forcing=(; P=sinking))\nsimulation = Simulation(model; Î”t=1, stop_iteration=100)\n\n# Build abstract operation for slip velocity\nb_particle = - 1e-4 # relative buoyancy depends on reference density and initial buoyancy condition\nb = model.tracers.b\nR = 1e-3 # [m] mean particle radius\nÎ½ = 1.05e-6 # [mÂ² sâ»Â¹] molecular kinematic viscosity of water\nw_slip_op = 2/9 * (b - b_particle) / Î½ * R^2 # Stokes terminal velocity\n\nfunction compute_slip_velocity!(sim)\n    w_slip .= w_slip_op\n    fill_halo_regions!(w_slip)\n    return nothing\nend\n\nsimulation.callbacks[:slip] = Callback(compute_slip_velocity!)\n\n# output\nCallback of compute_slip_velocity! on IterationInterval(1)","category":"page"},{"location":"appendix/function_index/#Index","page":"Function index","title":"Index","text":"","category":"section"},{"location":"appendix/function_index/","page":"Function index","title":"Function index","text":"","category":"page"},{"location":"physics/boussinesq/#boussinesq_approximation","page":"Boussinesq approximation","title":"The Boussinesq approximation","text":"","category":"section"},{"location":"physics/boussinesq/","page":"Boussinesq approximation","title":"Boussinesq approximation","text":"Oceananigans.jl often employs the Boussinesq approximation[1]. In the Boussinesq approximation the fluid density rho is, in general, decomposed into three components:","category":"page"},{"location":"physics/boussinesq/","page":"Boussinesq approximation","title":"Boussinesq approximation","text":"    rho(boldsymbolx t) = rho_0 + rho_*(z) + rho(boldsymbolx t)  ","category":"page"},{"location":"physics/boussinesq/","page":"Boussinesq approximation","title":"Boussinesq approximation","text":"where rho_0 is a constant 'reference' density, rho_*(z) is a background density profile which, when non-zero, is typically associated with the hydrostatic compression of seawater in the deep ocean, and rho(boldsymbolx t) is the dynamic component of density corresponding to inhomogeneous distributions of a buoyant tracer such as temperature or salinity.","category":"page"},{"location":"physics/boussinesq/","page":"Boussinesq approximation","title":"Boussinesq approximation","text":"The fluid buoyancy, associated with the buoyant acceleration of fluid, is defined in terms of rho as","category":"page"},{"location":"physics/boussinesq/","page":"Boussinesq approximation","title":"Boussinesq approximation","text":"    b = - fracg rhorho_0  ","category":"page"},{"location":"physics/boussinesq/","page":"Boussinesq approximation","title":"Boussinesq approximation","text":"where g is gravitational acceleration.","category":"page"},{"location":"physics/boussinesq/","page":"Boussinesq approximation","title":"Boussinesq approximation","text":"The Boussinesq approximation is valid when rho_* + rho ll rho_0, which implies the fluid is approximately incompressible, and thus does not support acoustic waves. In this case,  the mass conservation equation reduces to the continuity equation","category":"page"},{"location":"physics/boussinesq/","page":"Boussinesq approximation","title":"Boussinesq approximation","text":"    beginequation\n    boldsymbolnabla boldsymbolcdot boldsymbolv = partial_x u + partial_y v + partial_z w = 0  \n    labeleqcontinuity\n    endequation","category":"page"},{"location":"physics/boussinesq/","page":"Boussinesq approximation","title":"Boussinesq approximation","text":"Similarly, in the the momentum equations we can divide through with rho_0 and use that rho_* + rho ll rho_0 to get:","category":"page"},{"location":"physics/boussinesq/","page":"Boussinesq approximation","title":"Boussinesq approximation","text":"    beginequation\n    partial_t boldsymbolv + boldsymbolv boldsymbolcdot boldsymbolnabla boldsymbolv + dotsb = - frac1rho_0 boldsymbolnabla p - g fracrhorho_0 hatboldsymbolz + dotsb  \n    labeleqmomentum\n    endequation","category":"page"},{"location":"physics/boussinesq/","page":"Boussinesq approximation","title":"Boussinesq approximation","text":"We refer to p  rho_0 as the \"kinematic pressure\" with dimensions of velocity squared. Hereafter, we abuse notation a bit and denote the kinematic pressure simply as p.","category":"page"},{"location":"physics/boussinesq/","page":"Boussinesq approximation","title":"Boussinesq approximation","text":"info: Convention on dynamic versus kinematic pressure\nIn Oceananigans, the pressure p refers to \"kinematic pressure\" (with dimensions velocity squared), i.e., the dynamic pressure scaled with the reference fluid density rho_0.","category":"page"},{"location":"physics/boussinesq/","page":"Boussinesq approximation","title":"Boussinesq approximation","text":"[1]: Named after Boussinesq (1903) although used earlier by Oberbeck (1879), the Boussinesq   approximation neglects density differences in the momentum equation except when associated   with the gravitational term. It is an accurate approximation for many flows, and especially   so for oceanic flows where density differences are very small. See Vallis (2017, section 2.4)   for an oceanographic introduction to the Boussinesq equations and Vallis (2017, Section 2.A)   for an asymptotic derivation. See Kundu (2015, Section 4.9) for an engineering   introduction.","category":"page"},{"location":"numerical_implementation/finite_volume/#Finite-volume-method-on-a-staggered-grid","page":"Finite volume method","title":"Finite volume method on a staggered grid","text":"","category":"section"},{"location":"numerical_implementation/finite_volume/","page":"Finite volume method","title":"Finite volume method","text":"The Oceananigans.jl staggered grid is defined by a rectilinear array of cuboids of horizontal dimensions  Delta x_i j k Delta y_i j k and vertical dimension  Delta z_i j k, where (i j k) index the location of each cell in the staggered grid. Note that the indices (i j k) increase with increasing coordinate (x y z).","category":"page"},{"location":"numerical_implementation/finite_volume/","page":"Finite volume method","title":"Finite volume method","text":"(Image: Schematic of staggered grid) A schematic of Oceananigans.jl finite volumes for a two-dimensional staggered grid in (x z). Tracers c and pressure p are defined at the center of the control volume. The u control volumes are  centered on the left and right edges of the pressure control volume while the w control volumes are centered  on the top and bottom edges of the pressure control volumes. The indexing convention places the i^rmth  u-node on cell x-faces to the left of the i tracer point at cell centers.","category":"page"},{"location":"numerical_implementation/finite_volume/","page":"Finite volume method","title":"Finite volume method","text":"Dropping explicit indexing, the areas of cell faces are given by","category":"page"},{"location":"numerical_implementation/finite_volume/","page":"Finite volume method","title":"Finite volume method","text":"    A_x = Delta y Delta z quad A_y = Delta x Delta z quad A_z = Delta x Delta y  ","category":"page"},{"location":"numerical_implementation/finite_volume/","page":"Finite volume method","title":"Finite volume method","text":"so that each cell encloses a volume V = Delta x Delta y Delta z.","category":"page"},{"location":"numerical_implementation/finite_volume/","page":"Finite volume method","title":"Finite volume method","text":"A finite volume method discretizes a continuous quantity c by considering its average over a finite volume:","category":"page"},{"location":"numerical_implementation/finite_volume/","page":"Finite volume method","title":"Finite volume method","text":"    c_i j k equiv frac1V_i j k int c(boldsymbolx)  mathrmd V_i j k  ","category":"page"},{"location":"numerical_implementation/finite_volume/","page":"Finite volume method","title":"Finite volume method","text":"The finite volumes that discretize each of u, v, and w are located on a grid which is \"staggered\"  with respect to the grid that defines tracer finite volumes.  The nodes, or central points of the velocity finite volumes are co-located with the faces of the tracer  finite volume. In particular, the u-nodes are located in the center of the \"x-face\" (east of the tracer point),  v-nodes are located on y-faces south of the tracer point, and w-nodes are located on  z-faces downwards from the tracer point.","category":"page"},{"location":"physics/hydrostatic_free_surface_model/#hydrostatic_free_surface_model","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"","category":"section"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"The HydrostaticFreeSurfaceModel solves the incompressible Navier-Stokes equations under the Boussinesq and hydrostatic approximations and with an arbitrary number of tracer conservation  equations. Physics associated with individual terms in the momentum and tracer conservation equations â€“- the background rotation rate of the equation's reference frame, gravitational effects associated with buoyant tracers under the Boussinesq approximation, generalized stresses and tracer fluxes associated with viscous and diffusive physics, and arbitrary \"forcing functions\" â€“- are determined by the whims of the user.","category":"page"},{"location":"physics/hydrostatic_free_surface_model/#Mass-conservation-and-free-surface-evolution-equation","page":"Hydrostatic model with a free surface","title":"Mass conservation and free surface evolution equation","text":"","category":"section"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"The mass conservation equation is","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"    0 = boldsymbolnabla boldsymbolcdot boldsymbolu + partial_z w    ","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"The above is integrated from the bottom of the fluid up to z = 0 to obtain w(x y z t).","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"The free surface displacement eta(x y t) satisfies the linearized kinematic boundary  condition at the surface","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"    partial_t eta = w(x y z=0 t)  ","category":"page"},{"location":"physics/hydrostatic_free_surface_model/#The-momentum-conservation-equation","page":"Hydrostatic model with a free surface","title":"The momentum conservation equation","text":"","category":"section"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"The equations governing the conservation of momentum in a rotating fluid, including buoyancy via the Boussinesq approximation are","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"    beginalign\n    partial_t boldsymbolu  = - left ( boldsymbolv boldsymbolcdot boldsymbolnabla right ) boldsymbolu\n                        - boldsymbolf times boldsymbolu \n                        - boldsymbolnabla_h (p + g eta)\n                        - boldsymbolnabla boldsymbolcdot boldsymboltau\n                        + boldsymbolF_u   labeleqmomentum\n                        0  = b - partial_z p   labeleqhydrostatic\n    endalign","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"where b the is buoyancy, boldsymboltau is the hydrostatic kinematic stress tensor,  boldsymbolF_u denotes an internal forcing of the velocity field boldsymbolu,  p is kinematic pressure, eta is the free-surface displacement, and boldsymbolf  is the Coriolis parameter, or the background vorticity associated with the specified rate of  rotation of the frame of reference.","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"Equation \\eqref{eq:hydrostatic} above is the hydrostatic approximation and comes about as the  dominant balance of terms in the Navier-Stokes vertical momentum equation under the Boussinesq  approximation.","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"The terms that appear on the right-hand side of the momentum conservation equation are (in order):","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"momentum advection: left ( boldsymbolv boldsymbolcdot boldsymbolnabla right )  boldsymbolu,\nCoriolis: boldsymbolf times boldsymbolu,\nbaroclinic kinematic pressure gradient: boldsymbolnabla p,\nbarotropic kinematic pressure gradient: boldsymbolnabla (g eta),\nmolecular or turbulence viscous stress: boldsymbolnabla boldsymbolcdot boldsymboltau, and\nan arbitrary internal source of momentum: boldsymbolF_u.","category":"page"},{"location":"physics/hydrostatic_free_surface_model/#The-tracer-conservation-equation","page":"Hydrostatic model with a free surface","title":"The tracer conservation equation","text":"","category":"section"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"The conservation law for tracers is","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"    beginalign\n    partial_t c = - boldsymbolv boldsymbolcdot boldsymbolnabla c\n                   - boldsymbolnabla boldsymbolcdot boldsymbolq_c\n                   + F_c  \n    labeleqtracer\n    endalign","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"where boldsymbolq_c is the diffusive flux of c and F_c is an arbitrary source term. An arbitrary tracers are permitted and thus an arbitrary number of tracer equations can be solved simultaneously alongside with the momentum equations.","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"From left to right, the terms that appear on the right-hand side of the tracer conservation  equation are","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"tracer advection: boldsymbolv boldsymbolcdot boldsymbolnabla c,\nmolecular or turbulent diffusion: boldsymbolnabla boldsymbolcdot boldsymbolq_c, and\nan arbitrary internal source of tracer: F_c.","category":"page"},{"location":"simulation_tips/#Simulation-tips","page":"Simulation tips","title":"Simulation tips","text":"","category":"section"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Oceananigans attempts to optimize computations as much as possible \"behind the scenes\". Yet Oceananigans' flexibility places some responsibility on users to ensure high performance simulations, especially for complex setups with user-defined forcing functions, boundary condition functions, and diagnostics. Furthermore, in case of more complex GPU runs, some details could sometimes prevent your simulation from running altogether. While Julia knowledge is obviously desirable here, a user that is unfamiliar with Julia can get away with efficient simulations by learning a few rules of thumb. It is nonetheless recommended that users go through Julia's performance tips, which contains more in-depth explanations of some of the aspects discussed here.","category":"page"},{"location":"simulation_tips/#General-(CPU/GPU)-simulation-tips","page":"Simulation tips","title":"General (CPU/GPU) simulation tips","text":"","category":"section"},{"location":"simulation_tips/#Avoid-global-variables-whenever-possible","page":"Simulation tips","title":"Avoid global variables whenever possible","text":"","category":"section"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"In general using a global variable (which can be loosely defined as a variable defined in the main script) inside functions slows down the code. One way to circumvent this is to always use local variables or pass them as arguments to functions. This helps the compiler optimize the code.","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Another way around this is to define global variables as constants whenever possible. One thing to keep in mind when doing this is that when a const is defined, its value can't be changed until you restart the Julia session. So this latter approach is good for production-ready code, but may be undesirable in the early stages of development while you still have to change the parameters of the simulation for exploration.","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"It is especially important to avoid global variables in functions that are meant to be executed in GPU kernels (such as functions defining boundary conditions and forcings). Otherwise the Julia GPU compiler can fail with obscure errors. This is explained in more detail in the GPU simulation tips section below.","category":"page"},{"location":"simulation_tips/#Consider-inlining-small-functions","page":"Simulation tips","title":"Consider inlining small functions","text":"","category":"section"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Inlining is when the compiler replaces a function call with the body of the function that is being called before compiling. The advantage of inlining (which in julia can be done with the @inline macro) is that gets rid of the time spent calling the function. The Julia compiler automatically makes some calls as to what functions it should or shouldn't inline, but you can force a function to be inlined by including the macro @inline before its definition. This is more suited for small functions that are called often. Here's an example of an implementation of the Heaviside function that forces it to be inlined:","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"@inline heaviside(X) = ifelse(X < 0, zero(X), one(X))","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"In practice it's hard to say whether inlining a function will bring runtime benefits with certainty, since Julia and KernelAbstractions.jl (needed for GPU runs) already inline some functions automatically. However, it is generally a good idea to at least investigate this aspect in your code as the benefits can potentially be significant.","category":"page"},{"location":"simulation_tips/#GPU-simulation-tips","page":"Simulation tips","title":"GPU simulation tips","text":"","category":"section"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Running on GPUs can be very different from running on CPUs. Oceananigans makes most of the necessary changes in the background, so that for very simple simulations changing between CPUs and GPUs is just a matter of changing the architecture argument in the model from CPU() to GPU(). However, for more complex simulations some care needs to be taken on the part of the user. While knowledge of GPU computing (and Julia) is again desirable, an inexperienced user can also achieve high efficiency in GPU simulations by following a few simple principles.","category":"page"},{"location":"simulation_tips/#Global-variables-that-need-to-be-used-in-GPU-computations-need-to-be-defined-as-constants-or-passed-as-parameters","page":"Simulation tips","title":"Global variables that need to be used in GPU computations need to be defined as constants or passed as parameters","text":"","category":"section"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Any global variable that needs to be accessed by the GPU needs to be a constant or the simulation will crash. This includes any variables that are referenced as global variables in functions used for forcing of boundary conditions. For example,","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Tâ‚€ = 20 # áµ’C\nsurface_temperature(x, y, t) = Tâ‚€ * sin(2Ï€ / 86400 * t)\nT_bcs = FieldBoundaryConditions(bottom = GradientBoundaryCondition(surface_temperature))","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"will throw an error if run on the GPU (and will run more slowly than it should on the CPU). Replacing the first line above with","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"const Tâ‚€ = 20 # áµ’C","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"fixes the issue by indicating to the compiler that Tâ‚€ will not change.","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Note that the literal 2Ï€ / 86400 is not an issue â€“ it's only the variable Tâ‚€ that must be declared const.","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Alternatively, passing the variable as a parameter to GradientBoundaryCondition also works:","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Tâ‚€ = 20 # áµ’C\nsurface_temperature(x, y, t, p) = p.Tâ‚€ * sin(2Ï€ / 86400 * t)\nT_bcs = FieldBoundaryConditions(bottom = GradientBoundaryCondition(surface_temperature, parameters=(Tâ‚€=Tâ‚€,)))","category":"page"},{"location":"simulation_tips/#Complex-diagnostics-using-computed-Fields-may-not-work-on-GPUs","page":"Simulation tips","title":"Complex diagnostics using computed Fields may not work on GPUs","text":"","category":"section"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Fields are the most convenient way to calculate diagnostics for your simulation. They will always work on CPUs, but when their complexity is high (in terms of number of abstract operations) the compiler can't translate them into GPU code and they fail for GPU runs. (This limitation is summarized  in this Github issue and contributions are welcome.) For example, in the example below, calculating uÂ² works in both CPUs and GPUs, but calculating  Îµ will not compile on GPUs when we call the command compute!:","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"using Oceananigans\ngrid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1))\nmodel = NonhydrostaticModel(grid=grid, closure=ScalarDiffusivity(Î½=1e-6))\nu, v, w = model.velocities\nÎ½ = model.closure.Î½\nuÂ² = Field(u^2)\nÎµ = Field(Î½*(âˆ‚x(u)^2 + âˆ‚x(v)^2 + âˆ‚x(w)^2 + âˆ‚y(u)^2 + âˆ‚y(v)^2 + âˆ‚y(w)^2 + âˆ‚z(u)^2 + âˆ‚z(v)^2 + âˆ‚z(w)^2))\ncompute!(uÂ²)\ncompute!(Îµ)","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"There are a few ways to work around this issue. One is to compute Îµ in steps by nesting computed Fields,","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"ddxÂ² = Field(âˆ‚x(u)^2 + âˆ‚x(v)^2 + âˆ‚x(w)^2)\nddyÂ² = Field(âˆ‚y(u)^2 + âˆ‚y(v)^2 + âˆ‚y(w)^2)\nddzÂ² = Field(âˆ‚z(u)^2 + âˆ‚z(v)^2 + âˆ‚z(w)^2)\nÎµ = Field(Î½ * (ddxÂ² + ddyÂ² + ddzÂ²))\ncompute!(Îµ)","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"This method increases the computational cost since it requires computing and storing 3 intermediate terms. Îµ may also be calculated via KernelFunctionOperationss, which requires explicitly building a \"kernel function\" from low-level Oceananigans operators.","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"using Oceananigans.Operators\nusing Oceananigans.AbstractOperations: KernelFunctionOperation\n\n@inline fÏˆ_plus_gÏ†Â²(i, j, k, grid, f, Ïˆ, g, Ï†) = @inbounds (f(i, j, k, grid, Ïˆ) + g(i, j, k, grid, Ï†))^2\n\nfunction isotropic_viscous_dissipation_rate_ccc(i, j, k, grid, u, v, w, Î½)\n    Î£Ë£Ë£Â² = âˆ‚xá¶œá¶œá¶œ(i, j, k, grid, u)^2\n    Î£Ê¸Ê¸Â² = âˆ‚yá¶œá¶œá¶œ(i, j, k, grid, v)^2\n    Î£á¶»á¶»Â² = âˆ‚zá¶œá¶œá¶œ(i, j, k, grid, w)^2\n\n    Î£Ë£Ê¸Â² = â„‘xyá¶œá¶œáµƒ(i, j, k, grid, fÏˆ_plus_gÏ†Â², âˆ‚yá¶ á¶ á¶œ, u, âˆ‚xá¶ á¶ á¶œ, v) / 4\n    Î£Ë£á¶»Â² = â„‘xzá¶œáµƒá¶œ(i, j, k, grid, fÏˆ_plus_gÏ†Â², âˆ‚zá¶ á¶œá¶ , u, âˆ‚xá¶ á¶œá¶ , w) / 4\n    Î£Ê¸á¶»Â² = â„‘yzáµƒá¶œá¶œ(i, j, k, grid, fÏˆ_plus_gÏ†Â², âˆ‚zá¶œá¶ á¶ , v, âˆ‚yá¶œá¶ á¶ , w) / 4\n\n    return Î½ * 2 * (Î£Ë£Ë£Â² + Î£Ê¸Ê¸Â² + Î£á¶»á¶»Â² + 2 * (Î£Ë£Ê¸Â² + Î£Ë£á¶»Â² + Î£Ê¸á¶»Â²))\nend\n\nÎµ_op = KernelFunctionOperation{Center, Center, Center}(isotropic_viscous_dissipation_rate_ccc,\n                                                       grid, u, v, w, Î½)\n\nÎµ = Field(Îµ_op)\n\ncompute!(Îµ)","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Writing kernel functions like isotropic_viscous_dissipation_rate_ccc requires understanding the C-grid, but incurs only one iteration over the domain.","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"KernelFunctionOperations for some diagnostics common to large eddy simulation are defined in Oceanostics.jl,","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"using Oceanostics: IsotropicPseudoViscousDissipationRate\nÎµ = IsotropicViscousDissipationRate(model, u, v, w, Î½)\ncompute!(Îµ)","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Start an issue on Github if more help is needed.","category":"page"},{"location":"simulation_tips/#Try-to-decrease-the-memory-use-of-your-runs","page":"Simulation tips","title":"Try to decrease the memory-use of your runs","text":"","category":"section"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"GPU runs are sometimes memory-limited. A state-of-the-art Tesla V100 GPU has 32GB of memory â€“- enough memory for simulations with about 100 million points, or grids a bit smaller than 512 Ã— 512 Ã— 512. (The maximum grid size depends on some user-specified factors, like the number of passive tracers or computed diagnostics.) For large simulations on the GPU, careful management of memory allocation may be required:","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Use the nvidia-smi command line utility to monitor the memory usage of the GPU. It should tell you how much memory there is on your GPU and how much of it you're using and you can run it from Julia via\njulia> ;\nshell> run(`nvidia-smi`)\nTry to use higher-order advection schemes. In general when you use a higher-order scheme you need fewer grid points to achieve the same accuracy that you would with a lower-order one. Oceananigans provides two high-order advection schemes: 5th-order WENO method (WENO) and 3rd-order upwind.\nManually define scratch space to be reused in diagnostics. By default, every time a user-defined diagnostic is calculated the compiler reserves a new chunk of memory for that calculation, usually called scratch space. In general, the more diagnostics, the more scratch space needed and the bigger the memory requirements. However, if you explicitly create a scratch space and pass that same scratch space for as many diagnostics as you can, you minimize the memory requirements of your calculations by reusing the same chunk of memory. Have a look at an example for how to create scratch space and how it can be used in calculations.","category":"page"},{"location":"simulation_tips/#Arrays-in-GPUs-are-usually-different-from-arrays-in-CPUs","page":"Simulation tips","title":"Arrays in GPUs are usually different from arrays in CPUs","text":"","category":"section"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Oceananigans.jl uses CUDA.CuArray to store  data for GPU computations. One limitation of CuArrays compared to the Arrays used for  CPU computations is that CuArray elements in general cannot be accessed outside kernels launched through CUDA.jl or KernelAbstractions.jl. (You can learn more about GPU kernels  here and  here.) Doing so requires individual elements to be copied from or to the GPU for processing, which is very slow and can result in huge slowdowns. To avoid such unintentional slowdowns, Oceananigans.jl disables CUDA scalar indexing by default. See the scalar indexing section of the CUDA.jl documentation for more information on scalar indexing.","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"For example, if can be difficult to just view a CuArray since Julia needs to access  its elements to do that. Consider the example below:","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"julia> using Oceananigans, Adapt\n\njulia> grid = RectilinearGrid(GPU(); size=(1, 1, 1), extent=(1, 1, 1), halo=(1, 1, 1))\n1Ã—1Ã—1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 1Ã—1Ã—1 halo\nâ”œâ”€â”€ Periodic x âˆˆ [0.0, 1.0)  regularly spaced with Î”x=1.0\nâ”œâ”€â”€ Periodic y âˆˆ [0.0, 1.0)  regularly spaced with Î”y=1.0\nâ””â”€â”€ Bounded  z âˆˆ [-1.0, 0.0] regularly spaced with Î”z=1.0\n\njulia> model = NonhydrostaticModel(; grid)\nNonhydrostaticModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 1Ã—1Ã—1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 1Ã—1Ã—1 halo\nâ”œâ”€â”€ timestepper: QuasiAdamsBashforth2TimeStepper\nâ”œâ”€â”€ tracers: ()\nâ”œâ”€â”€ closure: Nothing\nâ”œâ”€â”€ buoyancy: Nothing\nâ””â”€â”€ coriolis: Nothing\n\njulia> typeof(model.velocities.u.data)\nOffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}\n\njulia> adapt(Array, model.velocities.u.data)\n3Ã—3Ã—3 OffsetArray(::Array{Float64, 3}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2Ã—0:2Ã—0:2:\n[:, :, 0] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n[:, :, 1] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n[:, :, 2] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Notice that to view the CuArray that stores values for u we first need to transform it into a regular Array using Adapt.adapt. If we naively try to view the CuArray without that step we get an error:","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"julia> model.velocities.u.data\n3Ã—3Ã—3 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2Ã—0:2Ã—0:2:\n[:, :, 0] =\nError showing value of type OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}:\nERROR: Scalar indexing is disallowed.","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Here CUDA.jl throws an error because scalar getindex is not allowed. There are ways to overcome this limitation and allow scalar indexing (more about that  in the CUDA.jl documentation), but this option can be very slow on GPUs, so it is advised to only use this last method when using the REPL or  prototyping â€“- never in production-ready scripts.","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"You might also need to keep these differences in mind when using arrays to define initial conditions, boundary conditions or forcing functions on a GPU. To learn more about working with CuArrays, see the array programming section of the CUDA.jl documentation.","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"EditURL = \"<unknown>/examples/tilted_bottom_boundary_layer.jl\"","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/#Tilted-bottom-boundary-layer-example","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer example","text":"","category":"section"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"This example simulates a two-dimensional oceanic bottom boundary layer in a domain that's tilted with respect to gravity. We simulate the perturbation away from a constant along-slope (y-direction) velocity constant density stratification. This perturbation develops into a turbulent bottom boundary layer due to momentum loss at the bottom boundary modeled with a quadratic drag law.","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"This example illustrates","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"changing the direction of gravitational acceleration in the buoyancy model;\nchanging the axis of rotation for Coriolis forces.","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/#Install-dependencies","page":"Tilted bottom boundary layer","title":"Install dependencies","text":"","category":"section"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"using Pkg\npkg\"add Oceananigans, NCDatasets, CairoMakie\"","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/#The-domain","page":"Tilted bottom boundary layer","title":"The domain","text":"","category":"section"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"We create a grid with finer resolution near the bottom,","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"using Oceananigans\nusing Oceananigans.Units\n\nLx = 200meters\nLz = 100meters\nNx = 64\nNz = 64\n\n# Creates a grid with near-constant spacing `refinement * Lz / Nz`\n# near the bottom:\nrefinement = 1.8 # controls spacing near surface (higher means finer spaced)\nstretching = 10  # controls rate of stretching at bottom\n\n# \"Warped\" height coordinate\nh(k) = (Nz + 1 - k) / Nz\n\n# Linear near-surface generator\nÎ¶(k) = 1 + (h(k) - 1) / refinement\n\n# Bottom-intensified stretching function\nÎ£(k) = (1 - exp(-stretching * h(k))) / (1 - exp(-stretching))\n\n# Generating function\nz_faces(k) = - Lz * (Î¶(k) * Î£(k) - 1)\n\ngrid = RectilinearGrid(topology = (Periodic, Flat, Bounded),\n                       size = (Nx, Nz),\n                       x = (0, Lx),\n                       z = z_faces,\n                       halo = (3, 3))","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Let's make sure the grid spacing is both finer and near-uniform at the bottom,","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"using CairoMakie\n\nlines(zspacings(grid, Center()), znodes(grid, Center()),\n      axis = (ylabel = \"Depth (m)\",\n              xlabel = \"Vertical spacing (m)\"))\n\nscatter!(zspacings(grid, Center()), znodes(grid, Center()))\n\ncurrent_figure() # hide","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/#Tilting-the-domain","page":"Tilted bottom boundary layer","title":"Tilting the domain","text":"","category":"section"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"We use a domain that's tilted with respect to gravity by","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Î¸ = 3 # degrees","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"so that x is the along-slope direction, z is the across-sloce direction that is perpendicular to the bottom, and the unit vector anti-aligned with gravity is","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"gÌ‚ = [sind(Î¸), 0, cosd(Î¸)]","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Changing the vertical direction impacts both the gravity_unit_vector for Buoyancy as well as the rotation_axis for Coriolis forces,","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"buoyancy = Buoyancy(model = BuoyancyTracer(), gravity_unit_vector = -gÌ‚)\ncoriolis = ConstantCartesianCoriolis(f = 1e-4, rotation_axis = gÌ‚)","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"where we have used a constant Coriolis parameter f = 10â´ rmsÂ¹. The tilting also affects the kind of density stratified flows we can model. In particular, a constant density stratification in the tilted coordinate system","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"@inline constant_stratification(x, y, z, t, p) = p.NÂ² * (x * p.gÌ‚[1] + z * p.gÌ‚[3])","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"is not periodic in x. Thus we cannot explicitly model a constant stratification on an x-periodic grid such as the one used here. Instead, we simulate periodic perturbations away from the constant density stratification by imposing a constant stratification as a BackgroundField,","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"B_field = BackgroundField(constant_stratification, parameters=(; gÌ‚, NÂ² = 1e-5))","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"where NÂ² = 10âµ rmsÂ¹ is the background buoyancy gradient.","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/#Bottom-drag","page":"Tilted bottom boundary layer","title":"Bottom drag","text":"","category":"section"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"We impose bottom drag that follows Monin-Obukhov theory. We include the background flow in the drag calculation, which is the only effect the background flow enters the problem,","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Vâˆ = 0.1 # m sâ»Â¹\nzâ‚€ = 0.1 # m (roughness length)\nÎº = 0.4 # von Karman constant\nzâ‚ = znodes(grid, Center())[1] # Closest grid center to the bottom\ncá´° = (Îº / log(zâ‚ / zâ‚€))^2 # Drag coefficient\n\n@inline drag_u(x, y, t, u, v, p) = - p.cá´° * âˆš(u^2 + (v + p.Vâˆ)^2) * u\n@inline drag_v(x, y, t, u, v, p) = - p.cá´° * âˆš(u^2 + (v + p.Vâˆ)^2) * (v + p.Vâˆ)\n\ndrag_bc_u = FluxBoundaryCondition(drag_u, field_dependencies=(:u, :v), parameters=(; cá´°, Vâˆ))\ndrag_bc_v = FluxBoundaryCondition(drag_v, field_dependencies=(:u, :v), parameters=(; cá´°, Vâˆ))\n\nu_bcs = FieldBoundaryConditions(bottom = drag_bc_u)\nv_bcs = FieldBoundaryConditions(bottom = drag_bc_v)","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/#Create-the-NonhydrostaticModel","page":"Tilted bottom boundary layer","title":"Create the NonhydrostaticModel","text":"","category":"section"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"We are now ready to create the model. We create a NonhydrostaticModel with an UpwindBiasedFifthOrder advection scheme, a RungeKutta3 timestepper, and a constant viscosity and diffusivity. Here we use a smallish value of 10^-4 mÂ² sÂ¹.","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"closure = ScalarDiffusivity(Î½=1e-4, Îº=1e-4)\n\nmodel = NonhydrostaticModel(; grid, buoyancy, coriolis, closure,\n                            timestepper = :RungeKutta3,\n                            advection = UpwindBiasedFifthOrder(),\n                            tracers = :b,\n                            boundary_conditions = (u=u_bcs, v=v_bcs),\n                            background_fields = (; b=B_field))","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Let's introduce a bit of random noise in the bottom of the domain to speed up the onset of turbulence:","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"noise(x, y, z) = 1e-3 * randn() * exp(-(10z)^2/grid.Lz^2)\nset!(model, u=noise, w=noise)","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/#Create-and-run-a-simulation","page":"Tilted bottom boundary layer","title":"Create and run a simulation","text":"","category":"section"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"We are now ready to create the simulation. We begin by setting the initial time step conservatively, based on the smallest grid size of our domain and set-up a","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"using Oceananigans.Units\n\nsimulation = Simulation(model, Î”t = 0.5 * minimum_zspacing(grid) / Vâˆ, stop_time = 1days)","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"We use TimeStepWizard to adapt our time-step and print a progress message,","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"using Printf\n\nwizard = TimeStepWizard(max_change=1.1, cfl=0.7)\nsimulation.callbacks[:wizard] = Callback(wizard, IterationInterval(4))\n\nstart_time = time_ns() # so we can print the total elapsed wall time\n\nprogress_message(sim) =\n    @printf(\"Iteration: %04d, time: %s, Î”t: %s, max|w|: %.1e m sâ»Â¹, wall time: %s\\n\",\n            iteration(sim), prettytime(time(sim)),\n            prettytime(sim.Î”t), maximum(abs, sim.model.velocities.w),\n            prettytime((time_ns() - start_time) * 1e-9))\n\nsimulation.callbacks[:progress] = Callback(progress_message, IterationInterval(200))","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/#Add-outputs-to-the-simulation","page":"Tilted bottom boundary layer","title":"Add outputs to the simulation","text":"","category":"section"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"We add outputs to our model using the NetCDFOutputWriter,","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"u, v, w = model.velocities\nb = model.tracers.b\nBâˆ = model.background_fields.tracers.b\n\nB = b + Bâˆ\nV = v + Vâˆ\nÏ‰y = âˆ‚z(u) - âˆ‚x(w)\n\noutputs = (; u, V, w, B, Ï‰y)\n\nsimulation.output_writers[:fields] = NetCDFOutputWriter(model, outputs;\n                                                        filename = joinpath(@__DIR__, \"tilted_bottom_boundary_layer.nc\"),\n                                                        schedule = TimeInterval(20minutes),\n                                                        overwrite_existing = true)","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Now we just run it!","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"run!(simulation)","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/#Visualize-the-results","page":"Tilted bottom boundary layer","title":"Visualize the results","text":"","category":"section"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"First we load the required package to load NetCDF output files and define the coordinates for plotting using existing objects:","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"using NCDatasets, CairoMakie\n\nxÏ‰, yÏ‰, zÏ‰ = nodes(Ï‰y)\nxv, yv, zv = nodes(V)","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Read in the simulation's output_writer for the two-dimensional fields and then create an animation showing the y-component of vorticity.","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"ds = NCDataset(simulation.output_writers[:fields].filepath, \"r\")\n\nfig = Figure(resolution = (800, 600))\n\naxis_kwargs = (xlabel = \"Across-slope distance (x)\",\n               ylabel = \"Slope-normal\\ndistance (z)\",\n               limits = ((0, Lx), (0, Lz)),\n               )\n\nax_Ï‰ = Axis(fig[2, 1]; title = \"Along-slope vorticity\", axis_kwargs...)\nax_v = Axis(fig[3, 1]; title = \"Along-slope velocity (v)\", axis_kwargs...)\n\nn = Observable(1)\n\nÏ‰y = @lift ds[\"Ï‰y\"][:, 1, :, $n]\nhm_Ï‰ = heatmap!(ax_Ï‰, xÏ‰, zÏ‰, Ï‰y, colorrange = (-0.015, +0.015), colormap = :balance)\nColorbar(fig[2, 2], hm_Ï‰; label = \"sâ»Â¹\")\n\nV = @lift ds[\"V\"][:, 1, :, $n]\nV_max = @lift maximum(abs, ds[\"V\"][:, 1, :, $n])\n\nhm_v = heatmap!(ax_v, xv, zv, V, colorrange = (-Vâˆ, +Vâˆ), colormap = :balance)\nColorbar(fig[3, 2], hm_v; label = \"m sâ»Â¹\")\n\ntimes = collect(ds[\"time\"])\ntitle = @lift \"t = \" * string(prettytime(times[$n]))\nfig[1, :] = Label(fig, title, fontsize=20, tellwidth=false)\n\ncurrent_figure() # hide\nfig","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Finally, we record a movie.","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"frames = 1:length(times)\n\nrecord(fig, \"tilted_bottom_boundary_layer.mp4\", frames, framerate=12) do i\n    msg = string(\"Plotting frame \", i, \" of \", frames[end])\n    if i%5 == 0 print(msg * \" \\r\") end\n    n[] = i\nend\nnothing #hide","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"(Image: )","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Don't forget to close the NetCDF file!","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"close(ds)","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"This page was generated using Literate.jl.","category":"page"},{"location":"physics/surface_gravity_waves/#Surface-gravity-waves-and-the-Craik-Leibovich-approximation","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"","category":"section"},{"location":"physics/surface_gravity_waves/","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"Users can model the effects of surface waves by specifying spatial and temporal gradients of the Stokes drift velocity field. At the moment, only uniform unidirectional Stokes drift fields are supported, in which case","category":"page"},{"location":"physics/surface_gravity_waves/","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"    boldsymbolu^S = u^S(z t) hatboldsymbolx + v^S(z t) hatboldsymboly  ","category":"page"},{"location":"physics/surface_gravity_waves/","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"Surface waves are modeled in the NonhydrostaticModel by the Craik-Leibovich approximation, which governs interior motions under a surface gravity wave field that have been time- or phase-averaged over the rapid oscillations of the surface waves. The oscillatory vertical and horizontal motions associated with surface waves themselves, therefore, are not present in the resolved velocity field boldsymbolv, and only the  steady, averaged effect of surface waves that manifests over several or more wave oscillations  are modeled.","category":"page"},{"location":"physics/surface_gravity_waves/","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"When surface waves are included, the resolved velocity field boldsymbolv is the  Lagrangian-mean velocity field. The Lagrangian-mean velocity field at a particular location  (x y z) is average velocity of a fluid particle whose average position is (x y z)  at time t. The average position of a fluid particle boldsymbolxi(t) = (xi eta zeta)  is thus governed by","category":"page"},{"location":"physics/surface_gravity_waves/","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"    partial_t boldsymbolxi + boldsymbolv(boldsymbolxi t) boldsymbolcdot boldsymbolnabla boldsymbolxi = boldsymbolv(boldsymbolxi t)  ","category":"page"},{"location":"physics/surface_gravity_waves/","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"which is the same relationship that holds when surface waves are not present and boldsymbolv  ceases to be an averaged velocity field. The simplicity of the governing equations for Lagrangian-mean  momentum is the main reason we use a Lagrangian-mean formulation in Oceananigans.jl, rather  than an Eulerian-mean formulation: for example, the tracer conservation equation is unchanged  by the inclusion of surface wave effects. Moreover, because the effect of surface waves manifests  either as a bulk forcing of Lagrangian-mean momentum or as a modification to the effective background  rotation rate of the interior fluid similar to any bulk forcing or Coriolis force, we do not  explicitly include the effects of surface waves in turbulence closures that model the effects  of subgrid turbulence. More specifically, the effect of steady surface waves does not effect  the conservation of Lagrangian-mean turbulent kinetic energy.","category":"page"},{"location":"physics/surface_gravity_waves/","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"The Lagrangian-mean velocity field boldsymbolv contrasts with the Eulerian-mean velocity  field boldsymbolv^E, which is the fluid velocity averaged at the fixed Eulerian position  (x y z). The surface wave Stokes drift field supplied by the user is, in fact, defined by the difference between the Eulerian- and Lagrangian-mean velocity:","category":"page"},{"location":"physics/surface_gravity_waves/","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"    boldsymbolu^S equiv boldsymbolv - boldsymbolv^E  ","category":"page"},{"location":"physics/surface_gravity_waves/","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"The Stokes drift velocity field is typically prescribed for idealized scenarios, or determined from a wave model for the evolution of surface waves under time-dependent atmospheric winds in more realistic cases.","category":"page"},{"location":"#Oceananigans.jl","page":"Home","title":"Oceananigans.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ğŸŒŠ Fast and friendly fluid dynamics on CPUs and GPUs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Oceananigans is a fast, friendly, flexible software package for finite volume simulations of the nonhydrostatic and hydrostatic Boussinesq equations on CPUs and GPUs. It runs on GPUs (wow, fast!), though we believe Oceananigans makes the biggest waves with its ultra-flexible user interface that makes simple simulations easy, and complex, creative simulations possible.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Oceananigans is written in Julia by the Climate Modeling Alliance and heroic external collaborators.","category":"page"},{"location":"#Quick-install","page":"Home","title":"Quick install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Oceananigans is a registered Julia package. So to install it,","category":"page"},{"location":"","page":"Home","title":"Home","text":"Download Julia.\nLaunch Julia and type","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\n\njulia> Pkg.add(\"Oceananigans\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"compat: Julia 1.6 is required; Julia 1.8 or newer is suggested\nThe latest version of Oceananigans strongly suggests at least Julia 1.8 or later to run. While most scripts will run on Julia 1.6 or 1.7, Oceananigans is continuously tested only on Julia 1.8.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you're new to Julia and its wonderful Pkg manager, the Oceananigans wiki provides more detailed installation instructions.","category":"page"},{"location":"#The-Oceananigans-\"knowledge-base\"","page":"Home","title":"The Oceananigans \"knowledge base\"","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"It's deep and includes:","category":"page"},{"location":"","page":"Home","title":"Home","text":"This documentation, which provides\nexample Oceananigans scripts,\ntutorials that describe key Oceananigans objects and functions,\nexplanations of Oceananigans finite-volume-based numerical methods,\ndetails of the dynamical equations solved by Oceananigans models, and\na library documenting all user-facing Oceananigans objects and functions.\nDiscussions on the Oceananigans github, covering topics like\n\"Computational science\", or how to science and set up numerical simulations in Oceananigans, and\n\"Experimental features\", which covers new and sparsely-documented features for those who like to live dangerously.\nIf you've got a question or something to talk about, don't hesitate to start a new discussion!\nThe Oceananigans wiki, which contains practical tips for getting started with Julia, accessing and using GPUs, and productive workflows when using Oceananigans.\nIssues and pull requests also contain lots of information about problems we've found, solutions we're trying to implement, and dreams we're dreaming to make tomorrow better ğŸŒˆ.","category":"page"},{"location":"#Getting-in-touch","page":"Home","title":"Getting in touch","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Whether you need help getting started with Oceananigans, found a bug, want Oceananigans to be more awesome, or just want to chat about computational oceanography, you've got a few options for getting in touch:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Start a discussion. This is great for general questions about numerics, science, experimental or under-documented features, and for getting help setting up a neat new numerical experiment.\nOpen an issue. Issues are best if you think the Oceananigans source code needs attention: a bug, a sign error (ğŸ˜±), an important missing feature, or a typo in this documentation ğŸ‘€.\nSign up for the Julia Slack and join the #oceananigans channel because we love to chat.","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use Oceananigans as part of your research, teaching, or other activities, we would be grateful if you could cite our work and mention Oceananigans by name.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{OceananigansJOSS,\n  doi = {10.21105/joss.02018},\n  url = {https://doi.org/10.21105/joss.02018},\n  year = {2020},\n  publisher = {The Open Journal},\n  volume = {5},\n  number = {53},\n  pages = {2018},\n  author = {Ali Ramadhan and Gregory LeClaire Wagner and Chris Hill and Jean-Michel Campin and Valentin Churavy and Tim Besard and Andre Souza and Alan Edelman and Raffaele Ferrari and John Marshall},\n  title = {Oceananigans.jl: Fast and friendly geophysical fluid dynamics on GPUs},\n  journal = {Journal of Open Source Software}\n}","category":"page"},{"location":"#Papers-and-preprints-using-Oceananigans","page":"Home","title":"Papers and preprints using Oceananigans","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you have work using Oceananigans that you would like to have listed here, please open a pull request to add it or let us know!","category":"page"},{"location":"","page":"Home","title":"Home","text":"Ramadhan, A., Marshall, J. C., Souza, A. N., Lee, X. K., Piterbarg, U., Hillier, A., Wagner, G. L., Rackauckas, C., Hill, C., Campin, J.-M., and Ferrari, R. (2022). Capturing missing physics in climate model parameterizations using neural differential equations ESS Open Archive. DOI: 10.1002/essoar.10512533.1\nGupta, M., & Thompson, A. F. (2022). Regimes of sea-ice floe melt: Ice-ocean coupling at the submesoscales Journal of Geophysical Research: Oceans, 127, e2022JC018894. DOI: 10.1029/2022JC018894\nSimoes-Sousa, I. T., Tandon, A., Pereira, F., Lazaneo, C. Z., and Mahadevan, A. (2022). Mixed layer eddies supply nutrients to enhance the spring phytoplankton bloom Frontiers in Marine Sciences, 9, 825027. DOI: 10.3389/fmars.2022.825027\nChor, T., Wenegrat, J. O., and Taylor, J. (2022). Insights into the mixing efficiency of submesoscale Centrifugal-Symmetric instabilities. Journal of Physical Oceanography, 52(10), 2273-2287. DOI: 10.1175/JPO-D-21-0259.1\nBire, S., Kang, W., Ramadhan, A., Campin, J.-M., and Marshall, J. (2022). Exploring ocean circulation on icy moons heated from below. Journal of Geophysical Research: Planets, 127, e2021JE007025. DOI: 10.1029/2021JE007025\nCoakley, S., Miles, T. N., Glenn, S., and Lim, H. S. (2021). Observation-Large eddy simulation comparison of ocean mixing under Typhoon Soulik (2018), OCEANS 2021: San Diego â€“ Porto, 2021, pp. 1-7, DOI: 10.23919/OCEANS44145.2021.9705670\nArnscheidt, C. W., Marshall, J., Dutrieux, P., Rye, C. D., and Ramadhan, A. (2021). On the settling depth of meltwater escaping from beneath Antarctic ice shelves, Journal of Physical Oceanography, 51(7), 2257â€“2270. DOI: 10.1175/JPO-D-20-0178.1\nWagner, G. L., Chini, G. P., Ramadhan, A., Gallet, B., and Ferrari, R. (2021). Near-inertial waves and turbulence driven by the growth of swell, Journal of Physical Oceanography, 51(5), 1337-1351. DOI: 10.1175/JPO-D-20-0178.1\nBuffett, B. A. (2021). Conditions for turbulent Ekman layers in precessionally driven flow, Geophysical Journal International, 226(1), 56â€“65. DOI: 10.1093/gji/ggab088\nBhamidipati, N., Souza, A.N., and Flierl, G.R. (2020). Turbulent mixing of a passive scalar in the ocean mixed layer. Ocean Modelling, 149, 101615. DOI: 10.1016/j.ocemod.2020.101615\nSouza, A. N., Wagner, G. L., Ramadhan, A., Allen, B., Churavy, V., Schloss, J., Campin, J. M., Hill, C., Edelman, A., Marshall, J., Flierl, G., and Ferrari, R. (2020). Uncertainty quantification of ocean parameterizations: Application to the Kâ€Profileâ€Parameterization for penetrative convection. Journal of Advances in Modeling Earth Systems, 12, e2020MS002108. DOI: 10.1029/2020MS002108","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"numerical_implementation/spatial_operators/#Spatial-operators","page":"Spatial operators","title":"Spatial operators","text":"","category":"section"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"To calculate the various terms and perform the time-stepping, discrete difference and interpolation  operators must be designed from which all the terms, such as momentum advection and Laplacian  diffusion, may be constructed. Much of the material in this section is derived from John Marshall, Alistair Adcroft, Chris Hill, Lev Perelman, Curt Heisey (1997).","category":"page"},{"location":"numerical_implementation/spatial_operators/#Differences","page":"Spatial operators","title":"Differences","text":"","category":"section"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"Difference operators act as the discrete form of the derivative operator. Care must be taken  when calculating differences on a staggered grid. For example, the the difference of a cell-centered  variable such as temperature T lies on the faces  in the direction of the difference, and  vice versa. In principle, there are three difference operators, one for each  direction","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"  delta_x f = f_E - f_W  quad\n  delta_y f = f_N - f_S  quad\n  delta_z f = f_T - f_B ","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"where the E and W subscripts indicate that the value is evaluated the eastern or western  wall of the cell, N and S indicate the northern and southern walls, and T and B  indicate the top and bottom walls.","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"Additionally, two delta operators must be defined for each direction to account for the  staggered nature of the grid. One for taking the difference of a cell-centered variable and  projecting it onto the cell faces","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"beginalign\n    delta_x^faa f_i j k = f_i j k - f_i-1 j k   \n    delta_y^afa f_i j k = f_i j k - f_i j-1 k   \n    delta_z^aaf f_i j k = f_i j k - f_i j k-1   \nendalign","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"and another for taking the difference of a face-centered variable and projecting it onto the cell centers","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"beginalign\n    delta_x^caa f_i j k = f_i+1 j k - f_i j k   \n    delta_y^aca f_i j k = f_i j+1 k - f_i j k   \n    delta_z^aac f_i j k = f_i j k+1 - f_i j k  \nendalign","category":"page"},{"location":"numerical_implementation/spatial_operators/#Interpolation","page":"Spatial operators","title":"Interpolation","text":"","category":"section"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"In order to add or multiply variables that are defined at different points they are interpolated.  In our case, linear interpolation or averaging is employed. Once again, there are two averaging  operators, one for each direction,","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"beginequation\n  overlinef^x = fracf_E + f_W2   quad\n  overlinef^y = fracf_N + f_S2   quad\n  overlinef^z = fracf_T + f_B2  \nendequation","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"Additionally, three averaging operators must be defined for each direction. One for taking the  average of a cell-centered  variable and projecting it onto the cell faces","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"beginalign\n    overlinef_i j k^faa = fracf_i j k + f_i-1 j k2   \n    overlinef_i j k^afa = fracf_i j k + f_i j-1 k2   \n    overlinef_i j k^aaf = fracf_i j k + f_i j k-12  \nendalign","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"and another for taking the average of a face-centered variable and projecting it onto the cell centers","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"beginalign\n    overlinef_i j k^caa = fracf_i+1 j k + f_i j k2   \n    overlinef_i j k^aca = fracf_i j+1 k + f_i j k2   \n    overlinef_i j k^aac = fracf_i j k+1 + f_i j k2  \nendalign","category":"page"},{"location":"numerical_implementation/spatial_operators/#Divergence-and-flux-divergence","page":"Spatial operators","title":"Divergence and flux divergence","text":"","category":"section"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"The divergence of the flux of a cell-centered quantity over the cell can be calculated as","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"boldsymbolnabla boldsymbolcdot boldsymbolf\n= frac1V left delta_x^faa (A_x f_x)\n                   + delta_y^afa (A_y f_y)\n                   + delta_z^aaf (A_z f_z) right  ","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"where boldsymbolf = (f_x f_y f_z) is the flux with components defined normal to the  faces, and V is the volume of the cell. The presence of a solid boundary is indicated by  setting the appropriate flux normal to the boundary to zero.","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"A similar divergence operator can be defined for a face-centered quantity. The divergence of, e.g., the flux of T over a cell, boldsymbolnabla boldsymbolcdot (boldsymbolv T),  is then","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"renewcommanddiv1 boldsymbolnabla boldsymbolcdot left ( 1 right )\ndivboldsymbolv T\n= frac1V left delta_x^caa (A_x u overlineT^faa)\n                   + delta_y^aca (A_y v overlineT^afa)\n                   + delta_z^aac (A_z w overlineT^aaf) right  ","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"where T is interpolated onto the cell faces where it can be multiplied by the velocities,  which are then differenced and projected onto the cell centers where they added together.","category":"page"},{"location":"numerical_implementation/spatial_operators/#Momentum-advection","page":"Spatial operators","title":"Momentum advection","text":"","category":"section"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"The advection terms that appear in model equations can be rewritten using the incompressibility  (boldsymbolnabla boldsymbolcdot boldsymbolv = 0) as, e.g,","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"renewcommanddiv1 boldsymbolnabla boldsymbolcdot left ( 1 right )\nbeginalign\nboldsymbolv boldsymbolcdot boldsymbolnabla u  = divu boldsymbolv - u ( boldsymbolnabla boldsymbolcdot boldsymbolv ) nonumber \n     = divu boldsymbolv  \nendalign","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"which can then be discretized similarly to the flux divergence operator, however, they must  be discretized differently for each direction.","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"For example, the x-momentum advection operator is discretized as","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"boldsymbolv boldsymbolcdot boldsymbolnabla u\n= frac1overlineV^x left\n    delta_x^faa left( overlineA_x u^caa overlineu^caa right)\n  + delta_y^afa left( overlineA_y v^aca overlineu^aca right)\n  + delta_z^aaf left( overlineA_z w^aac overlineu^aac right)\nright  ","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"where overlineV^x is the average of the volumes of the cells on either side of the face  in question. Calculating partial_x (uu) can be performed by interpolating A_x u and  u onto the cell centers then multiplying them and differencing them back onto the faces.  However, in the case of the the two other terms, partial_y (vu) and partial_z (wu),  the two variables must be interpolated onto the cell edges to be multiplied then differenced  back onto the cell faces.","category":"page"},{"location":"numerical_implementation/spatial_operators/#Discretization-of-isotropic-diffusion-operators","page":"Spatial operators","title":"Discretization of isotropic diffusion operators","text":"","category":"section"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"An isotropic viscosity operator acting on vertical momentum is discretized via","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"    boldsymbolnabla boldsymbolcdot left ( nu boldsymbolnabla w right )\n    = frac1V left\n          delta_x^faa ( nu overlineA_x^caa partial_x^caa w )\n        + delta_y^afa ( nu overlineA_y^aca partial_y^aca w )\n        + delta_z^aaf ( nu overlineA_z^aac partial_z^aac w )\n    right   ","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"where nu is the kinematic viscosity.","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"An isotropic diffusion operator acting on a tracer c, on the other hand, is discretized via","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"   boldsymbolnabla boldsymbolcdot left ( kappa boldsymbolnabla c right )\n    = frac1V left vphantomoverlineA_x^caa\n        delta_x^caa ( kappa A_x partial_x^faa c )\n      + delta_y^aca ( kappa A_y partial_y^afa c )\n      + delta_z^aac ( kappa A_z partial_z^aaf c )\n    right  ","category":"page"},{"location":"numerical_implementation/spatial_operators/#Vertical-integrals","page":"Spatial operators","title":"Vertical integrals","text":"","category":"section"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"Vertical integrals are converted into sums along each column. For example, the hydrostatic pressure  anomaly is","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"    p_HY^prime = int_-L_z^0 b^prime  mathrmd z  ","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"where b^prime is the buoyancy perturbation. Converting it into a sum that we compute from  the top downwards we get","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"    beginequation\n    p_HY^prime(k) =\n        begincases\n            - overlineb_N_z^prime^aaf Delta z^F_N_z                quad k = N_z   \n            p_HY^prime(k+1) - overlineb_k+1^prime^aaf Delta z^F_k  quad 1 le k le N_z - 1  \n        endcases\n    endequation","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"where we converted the sum into a recursive definition for p_HY^prime(k) in terms of  p_HY^prime(k+1) so that the integral may be computed with mathcalO(N_z) operations  by a single thread.","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"The vertical velocity w may be computed from u and v via the continuity equation","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"    w = - int_-L_z^0 (partial_x u + partial_y v)  mathrmd z  ","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"to satisfy the incompressibility condition boldsymbolnabla boldsymbolcdot boldsymbolv = 0 to numerical precision. This also involves computing a vertical integral, in this case evaluated from the bottom up","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"    beginequation\n    w_k =\n        begincases\n            0  quad k = 1   \n            w_k-1 - left( partial_x^caa u + partial_y^aca v right) Delta z^C_k  quad 2 le k le N_z  \n        endcases\n    endequation","category":"page"},{"location":"contributing/#Contributors-Guide","page":"Contributor's guide","title":"Contributors Guide","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Thank you for considering contributions to Oceananigans! We hope this guide helps you make a contribution.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Feel free to ask us questions and chat with us at any time about any topic at all by:","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Opening a GitHub issue\nCreating a GitHub discussion\nSending a message to the #oceananigans channel on Julia Slack.","category":"page"},{"location":"contributing/#Creating-issues","page":"Contributor's guide","title":"Creating issues","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"The simplest way to contribute to Oceananigans is to create or comment on issues and discussions.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"The most useful bug reports:","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Provide an explicit code snippet â€“- not just a link â€“- that reproduces the bug in the latest tagged version of Oceananigans. This is sometimes called the \"minimal working example\". Reducing bug-producing code to a minimal example can dramatically decrease the time it takes to resolve an issue.\nPaste the entire error received when running the code snippet, even if it's unbelievably long.\nUse triple backticks (e.g., ```some_code; and_some_more_code;```) to enclose code snippets, and other markdown formatting syntax to make your issue easy and quick to read.\nReport the Oceananigans version, Julia version, machine (especially if using a GPU) and any other possibly useful details of the computational environment in which the bug was created.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Discussions are recommended for asking questions about (for example) the user interface, implementation details, science, and life in general.","category":"page"},{"location":"contributing/#But-I-want-to-*code*!","page":"Contributor's guide","title":"But I want to code!","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"New users help write Oceananigans code and documentation by forking the Oceananigans repository, using git to edit code and docs, and then creating a pull request. Pull requests are reviewed by Oceananigans collaborators.\nA pull request can be merged once it is reviewed and approved by collaborators. If the pull request author has write access, they have the responsibility of merging their pull request. Otherwise, Oceananigans.jl collaborators will execute the merge with permission from the pull request author.\nNote: for small or minor changes (such as fixing a typo in documentation), the GitHub editor is super useful for forking and opening a pull request with a single click.\nWrite your code with love and care. In particular, conform to existing Oceananigans style and formatting conventions. For example, we love verbose and explicit variable names, use TitleCase for types, snake_case for objects, and always.put.spaces.after.commas. For formatting decisions we loosely follow the YASGuide. It's worth few extra minutes of our time to leave future generations with well-written, readable code.","category":"page"},{"location":"contributing/#What-is-a-\"collaborator\"-and-how-can-I-become-one?","page":"Contributor's guide","title":"What is a \"collaborator\" and how can I become one?","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Collaborators have permissions to review pull requests and  status allows a contributor to review pull requests in addition to opening them. Collaborators can also create branches in the main Oceananigans repository.\nWe ask that new contributors try their hand at forking Oceananigans, and opening and merging a pull request before requesting collaborator status.","category":"page"},{"location":"contributing/#What's-a-good-way-to-start-developing-Oceananigans?","page":"Contributor's guide","title":"What's a good way to start developing Oceananigans?","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Tackle an existing issue. We keep a list of good first issues that are self-contained and suitable for a newcomer to try and work on.\nTry to run Oceananigans and play around with it to simulate your favorite fluids and ocean physics. If you run into any problems or find it difficult to use or understand, please open an issue!\nWrite up an example or tutorial on how to do something useful with Oceananigans, like how to set up a new physical configuration.\nImprove documentation or comments if you found something hard to use.\nImplement a new feature if you need it to use Oceananigans.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"If you're interested in working on something, let us know by commenting on existing issues or  by opening a new issue. This is to make sure no one else is working on the same issue and so  we can help and guide you in case there is anything you need to know beforehand.","category":"page"},{"location":"contributing/#Ground-Rules","page":"Contributor's guide","title":"Ground Rules","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Each pull request should consist of a logical collection of changes. You can include multiple bug fixes in a single pull request, but they should be related. For unrelated changes, please submit multiple pull requests.\nDo not commit changes to files that are irrelevant to your feature or bugfix (eg: .gitignore).\nBe willing to accept criticism and work on improving your code; we don't want to break other users' code, so care must be taken not to introduce bugs. We discuss pull requests and keep working on them until we believe we've done a good job.\nBe aware that the pull request review process is not immediate, and is generally proportional to the size of the pull request.","category":"page"},{"location":"contributing/#Reporting-a-bug","page":"Contributor's guide","title":"Reporting a bug","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"The easiest way to get involved is to report issues you encounter when using Oceananigans or by requesting something you think is missing.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Head over to the issues page.\nSearch to see if your issue already exists or has even been solved previously.\nIf you indeed have a new issue or request, click the \"New Issue\" button.\nPlease be as specific as possible. Include the version of the code you were using, as well as what operating system you are running. The output of Julia's versioninfo() and ] status is helpful to include. Try your best to include a complete, \"minimal working example\" that reproduces the issue.","category":"page"},{"location":"contributing/#Setting-up-your-development-environment","page":"Contributor's guide","title":"Setting up your development environment","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Install Julia on your system.\nInstall git on your system if it is not already there (install XCode command line tools on a Mac or git bash on Windows).\nLogin to your GitHub account and make a fork of the Oceananigans repository by clicking the \"Fork\" button.\nClone your fork of the Oceananigans repository (in terminal on Mac/Linux or git shell/ GUI on Windows) in the location you'd like to keep it.\ngit clone https://github.com/your-user-name/Oceananigans.jl.git\nNavigate to that folder in the terminal or in Anaconda Prompt if you're on Windows.\nConnect your repository to the upstream (main project).\ngit remote add oceananigans https://github.com/CLiMA/Oceananigans.jl.git\nCreate the development environment by opening Julia via julia --project then typing in ] instantiate. This will install all the dependencies in the Project.toml file.\nYou can test to make sure Oceananigans works by typing in ] test. Doing so will run all the tests (and this can take a while).","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Your development environment is now ready!","category":"page"},{"location":"contributing/#Pull-Requests","page":"Contributor's guide","title":"Pull Requests","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"We follow the ColPrac guide for collaborative practices. We ask that new contributors read that guide before submitting a pull request.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Changes and contributions should be made via GitHub pull requests against the main branch.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"When you're done making changes, commit the changes you made. Chris Beams has written a  guide on how to write good commit messages.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"When you think your changes are ready to be merged into the main repository, push to your fork and submit a pull request.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Working on your first Pull Request? You can learn how from this free video series How to Contribute to an Open Source Project on GitHub, Aaron Meurer's tutorial on the git workflow, or the guide â€œHow to Contribute to Open Source\".","category":"page"},{"location":"contributing/#Documentation","page":"Contributor's guide","title":"Documentation","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Now that you've made your awesome contribution, it's time to tell the world how to use it. Writing documentation strings is really important to make sure others use your functionality properly. Didn't write new functions? That's fine, but be sure that the documentation for the code you touched is still in great shape. It is not uncommon to find some strange wording or clarification that you can take care of while you are here.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"You can preview how the Documentation will look like after merging by building the documentation  locally. From the main directory of your local repository call","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"julia --project -e 'using Pkg; Pkg.instantiate()'\njulia --project=docs/ -e 'using Pkg; Pkg.instantiate()'\nJULIA_DEBUG=Documenter julia --project=docs/ docs/make.jl","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"and then open docs/build/index.html in your favorite browser. Providing the environment variable  JULIA_DEBUG=Documenter will provide with more information in the documentation build process and thus help figuring out a potential bug.","category":"page"},{"location":"contributing/#Credits","page":"Contributor's guide","title":"Credits","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"This contributor's guide is heavily based on the excellent MetPy contributor's guide.","category":"page"},{"location":"physics/turbulence_closures/#Turbulence-closures","page":"Turbulence closures","title":"Turbulence closures","text":"","category":"section"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"The turbulence closure selected by the user determines the form of stress divergence boldsymbolnabla boldsymbolcdot boldsymboltau and diffusive flux divergence boldsymbolnabla boldsymbolcdot boldsymbolq_c in the momentum and tracer conservation equations.","category":"page"},{"location":"physics/turbulence_closures/#Constant-isotropic-diffusivity","page":"Turbulence closures","title":"Constant isotropic diffusivity","text":"","category":"section"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"In a constant isotropic diffusivity model, the kinematic stress tensor is defined","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"tau_ij = - nu Sigma_ij  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"where nu is a constant viscosity and Sigma_ij equiv tfrac12 left ( v_i j + v_j i right ) is the strain-rate tensor. The divergence of boldsymboltau is then","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"boldsymbolnabla boldsymbolcdot boldsymboltau = -nu nabla^2 boldsymbolv  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"Similarly, the diffusive tracer flux is boldsymbolq_c = - kappa boldsymbolnabla c for tracer diffusivity kappa, and the diffusive tracer flux divergence is","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"boldsymbolnabla boldsymbolcdot boldsymbolq_c = - kappa nabla^2 c  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"Each tracer may have a unique diffusivity kappa.","category":"page"},{"location":"physics/turbulence_closures/#Constant-anisotropic-diffusivity","page":"Turbulence closures","title":"Constant anisotropic diffusivity","text":"","category":"section"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"A constant anisotropic diffusivity implies a constant tensor diffusivity nu_j k and stress boldsymboltau_ij = nu_j k u_i k with non-zero components nu_11 = nu_22 = nu_h and nu_33 = nu_z. With this form the kinematic stress divergence becomes","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"boldsymbolnabla boldsymbolcdot boldsymboltau = - left  nu_h left ( partial_x^2 + partial_y^2 right )\n                                    + nu_v partial_z^2 right  boldsymbolv  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"and diffusive flux divergence","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"boldsymbolnabla boldsymbolcdot boldsymbolq_c = - left  kappa_h left ( partial_x^2 + partial_y^2 right )\n                                    + kappa_v partial_z^2 right  c  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"in terms of the horizontal viscosities and diffusivities, nu_h and kappa_h, and the vertical viscosity and diffusivities, nu_z and kappa_z. Each tracer may have a unique diffusivity components kappa_h and kappa_v.","category":"page"},{"location":"physics/turbulence_closures/#Scalar-biharmonic-diffusivity","page":"Turbulence closures","title":"Scalar biharmonic diffusivity","text":"","category":"section"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"A constant biharmonic diffusivity implies a constant tensor diffusivity nu_j k and stressboldsymboltau_ij = nu_j k partial_k^3 u_i with non-zero components nu_11 = nu_22 = nu_h and nu_33 = nu_z.","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"With this form the kinematic stress divergence becomes","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"boldsymbolnabla boldsymbolcdot boldsymboltau = - left  nu_h left ( partial_x^2 + partial_y^2 right )^2\n                                    + nu_v partial_z^4 right  boldsymbolv  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"and diffusive flux divergence","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"boldsymbolnabla boldsymbolcdot boldsymbolq_c = - left  kappa_h left ( partial_x^2 + partial_y^2 right )^2\n                                    + kappa_v partial_z^4 right  c  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"in terms of the horizontal biharmonic viscosities and diffusivities, nu_h and kappa_h, and the vertical biharmonic viscosity and diffusivities, nu_z and kappa_z. Each tracer may have a unique diffusivity components kappa_h and kappa_z.","category":"page"},{"location":"physics/turbulence_closures/#Smagorinsky-Lilly-turbulence-closure","page":"Turbulence closures","title":"Smagorinsky-Lilly turbulence closure","text":"","category":"section"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"In the turbulence closure proposed by D K Lilly (1962) and J. Smagorinsky (1963), the subgrid stress associated with unresolved turbulent motions is modeled diffusively via","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"tau_ij = - 2 nu_e Sigma_ij  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"where Sigma_ij = tfrac12 left ( v_i j + v_j i right ) is the resolved strain rate. The eddy viscosity is given by","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"    beginalign\n    nu_e = left ( C Delta_f right )^2 sqrt Sigma^2   varsigma(N^2  Sigma^2) + nu  \n    labeleqsmagorinsky-viscosity\n    endalign","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"where Delta_f is the \"filter width\" associated with the finite volume grid spacing, C is a user-specified model constant, Sigma^2 equiv Sigma_ij Sigma_ij, and nu is a constant isotropic background viscosity. The factor varsigma(N^2  Sigma^2) reduces nu_e in regions of strong stratification via","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"    varsigma(N^2  Sigma^2) = sqrt1 - min left ( 1 C_b N^2  Sigma^2 right )  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"where N^2 = max left (0 partial_z b right ) is the squared buoyancy frequency for stable stratification with partial_z b  0 and C_b is a user-specified constant.  Lilly (1962) proposed C_b = 1Pr, where Pr is a turbulent Prandtl number. The filter width for the Smagorinsky-Lilly closure is","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"Delta_f(boldsymbolx) = left ( Delta x Delta y Delta z right)^13  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"where Delta x, Delta y, and Delta z are the grid spacing in the boldsymbolhat x, boldsymbolhat y, and boldsymbolhat z directions at location boldsymbolx = (x y z).","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"The effect of subgrid turbulence on tracer mixing is also modeled diffusively via","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"boldsymbolq_c = - kappa_e boldsymbolnabla c  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"where the eddy diffusivity kappa_e is","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"kappa_e = fracnu_e - nuPr + kappa  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"where kappa is a constant isotropic background diffusivity. Both Pr and kappa may be set independently for each tracer.","category":"page"},{"location":"physics/turbulence_closures/#Anisotropic-minimum-dissipation-(AMD)-turbulence-closure","page":"Turbulence closures","title":"Anisotropic minimum dissipation (AMD) turbulence closure","text":"","category":"section"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"The anisotropic minimum dissipation (AMD) model proposed by Roel Verstappen (2018) and was described and tested by Catherine A. Vreugdenhil, John R. Taylor (2018). The AMD model uses an eddy diffusivity hypothesis similar the Smagorinsky-Lilly model. In the AMD model, the eddy viscosity and diffusivity for each tracer are defined in terms of eddy viscosity and diffusivity predictors nu_e^dagger and kappa_e^dagger, such that","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"    nu_e = max left ( 0 nu_e^dagger right ) + nu\n    quad textand quad\n    kappa_e = max left ( 0 kappa_e^dagger right ) + kappa  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"to ensure that nu_e ge 0 and kappa_e ge 0, where nu and kappa are the constant isotropic background viscosity and diffusivities for each tracer. The eddy viscosity  predictor is","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"    beginequation\n    nu_e^dagger = C Delta_f^2\n    frac\n        (hatpartial_k hatv_i) (hatpartial_k hatv_j) hatSigma_ij\n        + C_b hatdelta_i3 (hatpartial_k hatv_i) (hatpartial_k b)\n        (hatpartial_l hatv_m) (hatpartial_l hatv_m)  \n    labeleqnu-dagger\n    endequation","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"while the eddy diffusivity predictor for tracer c is","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"    beginequation\n    labeleqkappa-dagger\n    kappa_e^dagger = C Delta_f^2\n    frac\n        (hatpartial_k hatv_i) (hatpartial_k c) (hatpartial_i c)\n        (hatpartial_l c) (hatpartial_l c)  \n    endequation","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"In the definitions of the eddy viscosity and eddy diffusivity predictor, C and C_b are user-specified model constants, Delta_f is a \"filter width\" associated with the finite volume grid spacing, and the hat decorators on partial derivatives, velocities, and the Kronecker delta hat delta_i3 are defined such that","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"    hat partial_i equiv Delta_i partial_i qquad\n    hatv_i(x t) equiv fracv_i(x t)Delta_i quad textand quad\n    hatdelta_i3 equiv fracdelta_i3Delta_3  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"A velocity gradient, for example, is therefore hatpartial_i hatv_j(x t) = fracDelta_iDelta_j partial_i v_j(x t), while the normalized strain tensor is","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"    hatSigma_ij =\n        frac12 left hatpartial_i hatv_j(x t) + hatpartial_j hatv_i(x t) right  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"The filter width Delta_f in that appears in the viscosity and diffusivity predictors is taken as the square root of the harmonic mean of the squares of the filter widths in each direction:","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"    frac1Delta_f^2 = frac13 left(   frac1Delta x^2\n                                              + frac1Delta y^2\n                                              + frac1Delta z^2 right)  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"The constant C_b permits the \"buoyancy modification\" term it multiplies to be omitted from a calculation. By default we use the model constants C = 112 and C_b = 0.","category":"page"},{"location":"physics/turbulence_closures/#Convective-adjustment-vertical-diffusivity","page":"Turbulence closures","title":"Convective adjustment vertical diffusivity","text":"","category":"section"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"This closure aims to model the enhanced mixing that occurs due to convection. At every point and for every time instance, the closure diagnoses the gravitational stability of the fluid and applies the vertical diffusivities (i) background_Î½z to u, v and background_Îºz to all tracers if the fluid is gravitationally neutral or stable with bz  0, or (ii) convective_Î½z and convective_Îºz if bz  0.","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"This closure is a plausible model for convection if convective_Îºz gg background_Îºz and convective_Î½z gg background_Î½z.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"EditURL = \"<unknown>/examples/shallow_water_Bickley_jet.jl\"","category":"page"},{"location":"generated/shallow_water_Bickley_jet/#An-unstable-Bickley-jet-in-Shallow-Water-model","page":"Shallow water Bickley jet","title":"An unstable Bickley jet in Shallow Water model","text":"","category":"section"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"This example uses Oceananigans.jl's ShallowWaterModel to simulate the evolution of an unstable, geostrophically balanced, Bickley jet The example is periodic in x with flat bathymetry and uses the conservative formulation of the shallow water equations. The initial conditions superpose the Bickley jet with small-amplitude perturbations. See \"The nonlinear evolution of barotropically unstable jets,\" J. Phys. Oceanogr. (2003) for more details on this problem.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"The mass transport (uh vh) is the prognostic momentum variable in the conservative formulation of the shallow water equations, where (u v) are the horizontal velocity components and h is the layer height.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/#Install-dependencies","page":"Shallow water Bickley jet","title":"Install dependencies","text":"","category":"section"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"First we make sure that we have all of the packages that are required to run the simulation.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"using Pkg\npkg\"add Oceananigans, NCDatasets, Polynomials, CairoMakie\"","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"using Oceananigans\nusing Oceananigans.Models: ShallowWaterModel","category":"page"},{"location":"generated/shallow_water_Bickley_jet/#Two-dimensional-domain","page":"Shallow water Bickley jet","title":"Two-dimensional domain","text":"","category":"section"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"The shallow water model is a two-dimensional model and thus the number of vertical points Nz must be set to one.  Note that L_z is the mean depth of the fluid.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Lx, Ly, Lz = 2Ï€, 20, 10\nNx, Ny = 128, 128\n\ngrid = RectilinearGrid(size = (Nx, Ny),\n                       x = (0, Lx), y = (-Ly/2, Ly/2),\n                       topology = (Periodic, Bounded, Flat))","category":"page"},{"location":"generated/shallow_water_Bickley_jet/#Building-a-ShallowWaterModel","page":"Shallow water Bickley jet","title":"Building a ShallowWaterModel","text":"","category":"section"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"We build a ShallowWaterModel with the WENO advection scheme, 3rd-order Runge-Kutta time-stepping, non-dimensional Coriolis and gravitational acceleration","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"gravitational_acceleration = 1\ncoriolis = FPlane(f=1)\n\nmodel = ShallowWaterModel(; grid, coriolis, gravitational_acceleration,\n                          timestepper = :RungeKutta3,\n                          momentum_advection = WENO())","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Use architecture = GPU() to run this problem on a GPU.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/#Background-state-and-perturbation","page":"Shallow water Bickley jet","title":"Background state and perturbation","text":"","category":"section"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"The background velocity u and free-surface Î· correspond to a geostrophically balanced Bickely jet with maximum speed of U and maximum free-surface deformation of Î”Î·,","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"U = 1 # Maximum jet velocity\nf = coriolis.f\ng = gravitational_acceleration\nÎ”Î· = f * U / g  # Maximum free-surface deformation as dictated by geostrophy\n\nhÌ„(x, y, z) = Lz - Î”Î· * tanh(y)\nuÌ„(x, y, z) = U * sech(y)^2","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"The total height of the fluid is h = L_z + eta. Linear stability theory predicts that for the parameters we consider here, the growth rate for the most unstable mode that fits our domain is approximately 0139.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"The vorticity of the background state is","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Ï‰Ì„(x, y, z) = 2 * U * sech(y)^2 * tanh(y)","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"The initial conditions include a small-amplitude perturbation that decays away from the center of the jet.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"small_amplitude = 1e-4\n\n uâ±(x, y, z) = uÌ„(x, y, z) + small_amplitude * exp(-y^2) * randn()\nuhâ±(x, y, z) = uâ±(x, y, z) * hÌ„(x, y, z)","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"We first set a \"clean\" initial condition without noise for the purpose of discretely calculating the initial 'mean' vorticity,","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"uÌ„Ì„h(x, y, z) = uÌ„(x, y, z) * hÌ„(x, y, z)\n\nset!(model, uh = uÌ„Ì„h, h = hÌ„)","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"We next compute the initial vorticity and perturbation vorticity,","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"uh, vh, h = model.solution\n\n# Build velocities\nu = uh / h\nv = vh / h\n\n# Build and compute mean vorticity discretely\nÏ‰ = Field(âˆ‚x(v) - âˆ‚y(u))\ncompute!(Ï‰)\n\n# Copy mean vorticity to a new field\nÏ‰â± = Field((Face, Face, Nothing), model.grid)\nÏ‰â± .= Ï‰\n\n# Use this new field to compute the perturbation vorticity\nÏ‰â€² = Field(Ï‰ - Ï‰â±)","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"and finally set the \"true\" initial condition with noise,","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"set!(model, uh = uhâ±)","category":"page"},{"location":"generated/shallow_water_Bickley_jet/#Running-a-Simulation","page":"Shallow water Bickley jet","title":"Running a Simulation","text":"","category":"section"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"We pick the time-step so that we make sure we resolve the surface gravity waves, which propagate with speed of the order sqrtg L_z. That is, with Î”t = 1e-2 we ensure that sqrtg L_z Î”t  Î”x  sqrtg L_z Î”t  Î”y  07.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"simulation = Simulation(model, Î”t = 1e-2, stop_time = 150)","category":"page"},{"location":"generated/shallow_water_Bickley_jet/#Prepare-output-files","page":"Shallow water Bickley jet","title":"Prepare output files","text":"","category":"section"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Define a function to compute the norm of the perturbation on the cross channel velocity. We obtain the norm function from LinearAlgebra.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"using LinearAlgebra: norm\n\nperturbation_norm(args...) = norm(v)","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Build the output_writer for the two-dimensional fields to be output. Output every t = 1.0.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"fields_filename = joinpath(@__DIR__, \"shallow_water_Bickley_jet_fields.nc\")\nsimulation.output_writers[:fields] = NetCDFOutputWriter(model, (; Ï‰, Ï‰â€²),\n                                                        filename = fields_filename,\n                                                        schedule = TimeInterval(1),\n                                                        overwrite_existing = true)","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Build the output_writer for the growth rate, which is a scalar field. Output every time step.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"growth_filename = joinpath(@__DIR__, \"shallow_water_Bickley_jet_perturbation_norm.nc\")\nsimulation.output_writers[:growth] = NetCDFOutputWriter(model, (; perturbation_norm),\n                                                        filename = growth_filename,\n                                                        schedule = IterationInterval(1),\n                                                        dimensions = (; perturbation_norm = ()),\n                                                        overwrite_existing = true)","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"And finally run the simulation.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"run!(simulation)","category":"page"},{"location":"generated/shallow_water_Bickley_jet/#Visualize-the-results","page":"Shallow water Bickley jet","title":"Visualize the results","text":"","category":"section"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Load required packages to read output and plot.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"using NCDatasets, Printf, CairoMakie\nnothing # hide","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Define the coordinates for plotting.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"x, y = xnodes(Ï‰), ynodes(Ï‰)\nnothing # hide","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Read in the output_writer for the two-dimensional fields and then create an animation showing both the total and perturbation vorticities.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"fig = Figure(resolution = (1200, 660))\n\naxis_kwargs = (xlabel = \"x\",\n               ylabel = \"y\",\n               aspect = AxisAspect(1),\n               limits = ((0, Lx), (-Ly/2, Ly/2)))\n\nax_Ï‰  = Axis(fig[2, 1]; title = \"Total vorticity, Ï‰\", axis_kwargs...)\nax_Ï‰â€² = Axis(fig[2, 3]; title = \"Perturbation vorticity, Ï‰ - Ï‰Ì„\", axis_kwargs...)\n\nn = Observable(1)\n\nds = NCDataset(simulation.output_writers[:fields].filepath, \"r\")\n\ntimes = ds[\"time\"][:]\n\nÏ‰ = @lift ds[\"Ï‰\"][:, :, 1, $n]\nhm_Ï‰ = heatmap!(ax_Ï‰, x, y, Ï‰, colorrange = (-1, 1), colormap = :balance)\nColorbar(fig[2, 2], hm_Ï‰)\n\nÏ‰â€² = @lift ds[\"Ï‰â€²\"][:, :, 1, $n]\nhm_Ï‰â€² = heatmap!(ax_Ï‰â€², x, y, Ï‰â€², colormap = :balance)\nColorbar(fig[2, 4], hm_Ï‰â€²)\n\ntitle = @lift @sprintf(\"t = %.1f\", times[$n])\nfig[1, 1:4] = Label(fig, title, fontsize=24, tellwidth=false)\n\ncurrent_figure() # hide\nfig","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Finally, we record a movie.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"frames = 1:length(times)\n\nrecord(fig, \"shallow_water_Bickley_jet.mp4\", frames, framerate=12) do i\n    msg = string(\"Plotting frame \", i, \" of \", frames[end])\n    print(msg * \" \\r\")\n    n[] = i\nend\nnothing #hide","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"(Image: )","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"It's always good practice to close the NetCDF files when we are done.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"close(ds)","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Read in the output_writer for the scalar field (the norm of v-velocity).","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"ds2 = NCDataset(simulation.output_writers[:growth].filepath, \"r\")\n\n     t = ds2[\"time\"][:]\nnorm_v = ds2[\"perturbation_norm\"][:]\n\nclose(ds2)\nnothing # hide","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"We import the fit function from Polynomials.jl to compute the best-fit slope of the perturbation norm on a logarithmic plot. This slope corresponds to the growth rate.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"using Polynomials: fit\n\nI = 6000:7000\n\ndegree = 1\nlinear_fit_polynomial = fit(t[I], log.(norm_v[I]), degree, var = :t)","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"We can get the coefficient of the n-th power from the fitted polynomial by using n as an index, e.g.,","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"constant, slope = linear_fit_polynomial[0], linear_fit_polynomial[1]","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"We then use the computed linear fit coefficients to construct the best fit and plot it together with the time-series for the perturbation norm for comparison.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"best_fit = @. exp(constant + slope * t)\n\nlines(t, norm_v;\n      linewidth = 4,\n      label = \"norm(v)\",\n      axis = (yscale = log10,\n              limits = (nothing, (1e-3, 30)),\n              xlabel = \"time\",\n              ylabel = \"norm(v)\",\n               title = \"growth of perturbation norm\"))\n\nlines!(t[I], 2 * best_fit[I]; # factor 2 offsets fit from curve for better visualization\n       linewidth = 4,\n       label = \"best fit\")\n\naxislegend(position = :rb)\n\ncurrent_figure() # hide","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"The slope of the best-fit curve on a logarithmic scale approximates the rate at which instability grows in the simulation. Let's see how this compares with the theoretical growth rate.","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"println(\"Numerical growth rate is approximated to be \", round(slope, digits=3), \",\\n\",\n        \"which is very close to the theoretical value of 0.139.\")","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"","category":"page"},{"location":"generated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"EditURL = \"<unknown>/examples/internal_wave.jl\"","category":"page"},{"location":"generated/internal_wave/#Internal-wave-example","page":"Internal wave","title":"Internal wave example","text":"","category":"section"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"In this example, we initialize an internal wave packet in two-dimensions and watch it propagate. This example illustrates how to set up a two-dimensional model, set initial conditions, and how to use BackgroundFields.","category":"page"},{"location":"generated/internal_wave/#Install-dependencies","page":"Internal wave","title":"Install dependencies","text":"","category":"section"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"using Pkg\npkg\"add Oceananigans, CairoMakie\"","category":"page"},{"location":"generated/internal_wave/#The-physical-domain","page":"Internal wave","title":"The physical domain","text":"","category":"section"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"First, we pick a resolution and domain size. We use a two-dimensional domain that's periodic in (x z) and is Flat in y:","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"using Oceananigans\n\ngrid = RectilinearGrid(size=(128, 128), x=(-Ï€, Ï€), z=(-Ï€, Ï€), topology=(Periodic, Flat, Periodic))","category":"page"},{"location":"generated/internal_wave/#Internal-wave-parameters","page":"Internal wave","title":"Internal wave parameters","text":"","category":"section"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"Inertia-gravity waves propagate in fluids that are both (i) rotating, and (ii) density-stratified. We use Oceananigans' Coriolis abstraction to implement a background rotation rate:","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"coriolis = FPlane(f=0.2)","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"On an FPlane, the domain is idealized as rotating at a constant rate with rotation period 2Ï€/f. coriolis is passed to NonhydrostaticModel below. Our units are arbitrary.","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"We use Oceananigans' background_fields abstraction to define a background buoyancy field B(z) = N^2 * z, where z is the vertical coordinate and N is the \"buoyancy frequency\". This means that the modeled buoyancy field perturbs the basic state B(z).","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"# Background fields are functions of `x, y, z, t`, and optional parameters.\n# Here we have one parameter, the buoyancy frequency\n\nN = 1 ## buoyancy frequency\nB_func(x, y, z, t, N) = N^2 * z\nB = BackgroundField(B_func, parameters=N)","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"We are now ready to instantiate our model. We pass grid, coriolis, and B to the NonhydrostaticModel constructor. We add a small amount of IsotropicDiffusivity to keep the model stable during time-stepping, and specify that we're using a single tracer called b that we identify as buoyancy by setting buoyancy=BuoyancyTracer().","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"model = NonhydrostaticModel(; grid, coriolis,\n                            advection = CenteredFourthOrder(),\n                            timestepper = :RungeKutta3,\n                            closure = ScalarDiffusivity(Î½=1e-6, Îº=1e-6),\n                            tracers = :b,\n                            buoyancy = BuoyancyTracer(),\n                            background_fields = (; b=B)) # `background_fields` is a `NamedTuple`","category":"page"},{"location":"generated/internal_wave/#A-Gaussian-wavepacket","page":"Internal wave","title":"A Gaussian wavepacket","text":"","category":"section"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"Next, we set up an initial condition that excites an internal wave that propates through our rotating, stratified fluid. This internal wave has the pressure field","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"p(x y z t) = a(x z)  cos(kx + mz - Ï‰ t)  ","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"where m is the vertical wavenumber, k is the horizontal wavenumber, Ï‰ is the wave frequncy, and a(x z) is a Gaussian envelope. The internal wave dispersion relation links the wave numbers k and m, the Coriolis parameter f, and the buoyancy frequency N:","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"# Non-dimensional internal wave parameters\nm = 16      # vertical wavenumber\nk = 8       # horizontal wavenumber\nf = coriolis.f\n\n# Dispersion relation for inertia-gravity waves\nÏ‰Â² = (N^2 * k^2 + f^2 * m^2) / (k^2 + m^2)\n\nÏ‰ = sqrt(Ï‰Â²)\nnothing # hide","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"We define a Gaussian envelope for the wave packet so that we can observe wave propagation.","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"# Some Gaussian parameters\ngaussian_amplitude = 1e-9\ngaussian_width = grid.Lx / 15\n\n# A Gaussian envelope centered at ``(x, z) = (0, 0)``.\na(x, z) = gaussian_amplitude * exp( -( x^2 + z^2 ) / 2gaussian_width^2 )\nnothing # hide","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"An inertia-gravity wave is a linear solution to the Boussinesq equations. In order that our initial condition excites an inertia-gravity wave, we initialize the velocity and buoyancy perturbation fields to be consistent with the pressure field p = a  cos(kx + mx - Ï‰t) at t=0. These relations are sometimes called the \"polarization relations\". At t=0, the polarization relations yield","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"uâ‚€(x, y, z) = a(x, z) * k * Ï‰   / (Ï‰^2 - f^2) * cos(k*x + m*z)\nvâ‚€(x, y, z) = a(x, z) * k * f   / (Ï‰^2 - f^2) * sin(k*x + m*z)\nwâ‚€(x, y, z) = a(x, z) * m * Ï‰   / (Ï‰^2 - N^2) * cos(k*x + m*z)\nbâ‚€(x, y, z) = a(x, z) * m * N^2 / (Ï‰^2 - N^2) * sin(k*x + m*z)\n\nset!(model, u=uâ‚€, v=vâ‚€, w=wâ‚€, b=bâ‚€)","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"Recall that the buoyancy b is a perturbation, so that the total buoyancy field is N^2 z + b.","category":"page"},{"location":"generated/internal_wave/#A-wave-packet-on-the-loose","page":"Internal wave","title":"A wave packet on the loose","text":"","category":"section"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"We're ready to release the packet. We build a simulation with a constant time-step,","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"simulation = Simulation(model, Î”t = 0.1 * 2Ï€/Ï‰, stop_iteration = 20)","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"and add an output writer that saves the vertical velocity field every two iterations:","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"filename = \"internal_wave.jld2\"\nsimulation.output_writers[:velocities] = JLD2OutputWriter(model, model.velocities; filename,\n                                                          schedule = IterationInterval(1),\n                                                          overwrite_existing = true)","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"With initial conditions set and an output writer at the ready, we run the simulation","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"run!(simulation)","category":"page"},{"location":"generated/internal_wave/#Animating-a-propagating-packet","page":"Internal wave","title":"Animating a propagating packet","text":"","category":"section"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"To animate a the propagating wavepacket we just simulated, we load CairoMakie and make a Figure and an Axis for the animation,","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"using CairoMakie\nset_theme!(Theme(fontsize = 24))\n\nfig = Figure(resolution = (600, 600))\n\nax = Axis(fig[2, 1]; xlabel = \"x\", ylabel = \"z\",\n          limits = ((-Ï€, Ï€), (-Ï€, Ï€)), aspect = AxisAspect(1))\n\nnothing #hide","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"Next, we load w data with FieldTimeSeries of w and make contour plots of vertical velocity. We use Makie's Observable to animate the data. To dive into how Observables work, refer to Makie.jl's Documentation.","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"n = Observable(1)\n\nw_timeseries = FieldTimeSeries(filename, \"w\")\nx, y, z = nodes(w_timeseries)\n\nw = @lift interior(w_timeseries[$n], :, 1, :)\nw_lim = 1e-8\n\ncontourf!(ax, x, z, w;\n          levels = range(-w_lim, stop=w_lim, length=10),\n          colormap = :balance,\n          colorrange = (-w_lim, w_lim),\n          extendlow = :auto,\n          extendhigh = :auto)\n\ntitle = @lift \"Ï‰t = \" * string(round(w_timeseries.times[$n] * Ï‰, digits=2))\nfig[1, 1] = Label(fig, title, fontsize=24, tellwidth=false)","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"And, finally, we record a movie.","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"using Printf\n\nframes = 1:length(w_timeseries.times)\n\n@info \"Animating a propagating internal wave...\"\n\nrecord(fig, \"internal_wave.mp4\", frames, framerate=8) do i\n    msg = string(\"Plotting frame \", i, \" of \", frames[end])\n    print(msg * \" \\r\")\n    n[] = i\nend\nnothing #hide","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"(Image: )","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"","category":"page"},{"location":"generated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"This page was generated using Literate.jl.","category":"page"},{"location":"model_setup/architecture/#Architecture","page":"Architecture","title":"Architecture","text":"","category":"section"},{"location":"model_setup/architecture/","page":"Architecture","title":"Architecture","text":"Passing architecture = CPU() or architecture = GPU() to the Model constructor will determine whether the model is time stepped on a CPU or GPU.","category":"page"},{"location":"model_setup/architecture/","page":"Architecture","title":"Architecture","text":"Ideally a set up or simulation script does not need to be modified to run on a GPU but we are still smoothing out rough edges. Generally the CPU wants Array objects while the GPU wants CuArray objects.","category":"page"},{"location":"model_setup/architecture/","page":"Architecture","title":"Architecture","text":"tip: Running on GPUs\nIf you are having issues with running Oceananigans on a GPU, please open an issue and we'll do our best to help out.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#numerical_les","page":"Large eddy simulation","title":"Large eddy simulation","text":"","category":"section"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"The idea behind large eddy simulation (LES) is to resolve the \"large eddies\" while modeling the effect of unresolved sub-grid scale motions. This is done usually be assuming eddy viscosity and eddy diffusivity models and providing an estimate for the eddy viscosity nu_e and diffusivity kappa_e.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"Much of the early work on LES was motivated by the study of atmospheric boundary layer turbulence, being developed by J. Smagorinsky (1963) and D K Lilly (1966), then first implemented by J. W. Deardorff (1970) and J. W. Deardorff (1974).","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"In the LES framework, the Navier-Stokes equations are averaged in the same way as Osborne Reynolds (1895) except that the mean field overlineboldsymbolv is obtained via convolution with a filter convolution kernel G","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"overlineboldsymbolv(boldsymbolx t) = G star boldsymbolv =\n  int_-infty^infty int_-infty^infty\n  boldsymbolv(boldsymbolx^prime t) G(boldsymbolx - boldsymbolx^prime t - tau)  mathrmdboldsymbolx^prime  mathrmd tau  ","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"as described by A. Leonard (1975) who introduced the general filtering formalism.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"The overlinev_i^prime v_j^prime terms are now components of what is called the sub-grid scale (SGS) stress tensor tau^textSGS_ij, which looks the same as the Reynolds stress tensor so we will drop the SGS superscript.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"It is probably important to note that the large eddy simulation filtering operation does not satisfy the properties of a Reynolds operator (Â§2.1)P. Sagaut, C. Meneveau (2006) and that in general, the filtered residual is not zero: overlineboldsymbolv^prime(boldsymbolx t) ne 0.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"Â§13.2 of S. B. Pope (2000) lists a number of popular choices for the filter function G. For practical reasons we simply employ the box kernel","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"  beginequation\n  labeleqbox-kernel\n  G_Delta = G(boldsymbolx t) = frac1Delta H left( frac12Delta - boldsymbolx right) delta(t - t_n)  \n  endequation","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"where H is the Heaviside function, Delta is the grid spacing, and t_n is the current time step. With \\eqref{eq:box-kernel} we get back the averaging operator originally used by J. W. Deardorff (1970)","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"overlineboldsymbolv(x y z t) =\n  frac1Delta x Delta y Delta z\n  int_x - frac12Delta x^x + frac12Delta x\n  int_y - frac12Delta y^y + frac12Delta y\n  int_z - frac12Delta z^z + frac12Delta z\n  boldsymbolv(xi eta zeta t)  mathrmd xi  mathrmd eta  mathrmd zeta  ","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"which if evaluated at the cell centers just returns the cell averages we already compute in the finite volume method.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#Smagorinsky-Lilly-model","page":"Large eddy simulation","title":"Smagorinsky-Lilly model","text":"","category":"section"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"J. Smagorinsky (1963) estimated the eddy viscosity nu_e via a characteristic length scale Delta times a velocity scale given by Delta overlineS where overlineS = sqrt2overlineS_ijoverlineS_ij. Thus the SGS stress tensor is given by","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"tau_ij = -2 nu_e overlineS_ij = -2 (C_s Delta)^2 overlineS overlineS_ij  ","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"where C_s is a dimensionless constant. The grid spacing is usually used for the characteristic length scale Delta. The eddy diffusivities are calculated via kappa_e = nu_e  textPr_t where the turbulent Prandtl number textPr_t is usually chosen to be mathcalO(1) from experimental observations.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"Assuming that the SGS energy cascade is equal to the overall dissipation rate varepsilon from the A. Kolmogorov (1941) theory, D K Lilly (1966) was able to derive a value of","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"C_s = left( frac32C_Kpi^frac43 right)^-frac34 approx 016  ","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"using an empirical value of C_K approx 16 for the Kolmogorov constant. This seems reasonable for isotropic turbulence if the grid spacing Delta falls in the inertial range. In practice, C_s is a tunable parameter.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"Due to the presence of the constant C_s, the model is sometimes referred to as the constant Smagorinsky model in contrast to dynamic Smagorinsky models that dynamically compute C_s to account for effects such as buoyant convection.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#Anisotropic-minimum-dissipation-models","page":"Large eddy simulation","title":"Anisotropic minimum dissipation models","text":"","category":"section"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"Minimum-dissipation eddy-viscosity models are a class of LES closures that use the minimum eddy dissipation required to dissipate the energy of sub-grid scale motion. Wybe Rozema, Hyun J. Bae, Parviz Moin, Roel Verstappen (2015) proposed the first minimum-dissipation model appropriate for use on anisotropic grids, termed the anisotropic minimum dissipation (AMD) model.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"It has a number of desirable properties over Smagorinsky-type closures: it is more cost-effective than dynamic Smagorinsky, it appropriately switches off in laminar and transitional flows, and it is consistent with the exact SGS stress tensor on both isotropic and anisotropic grids. Mahdi Abkar, Hyun J. Bae, Parviz Moin (2016) extended the AMD model to model SGS scalar fluxes for tracer transport. Mahdi Abkar, Parviz Moin (2017) further extended the model to include a buoyancy term that accounts for the contribution of buoyant forces to the production and suppression of turbulence.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"Catherine A. Vreugdenhil, John R. Taylor (2018) derive a modified AMD model by following the requirement suggested by Roel Verstappen (2018), which entail normalising the displacement, the velocity, and the velocity gradient by the filter width to ensure that the resulting eddy dissipation properly counteracts the spurious kinetic energy transferred by convective nonlinearity, to derive a modified AMD model.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"The eddy viscosity and diffusivity are defined in terms of eddy viscosity and diffusivity predictors nu_e^dagger and kappa_e^dagger, such that","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"nu_e = max lbrace 0 nu_e^dagger rbrace\nquad textand quad\nkappa_e = max lbrace 0 kappa_e^dagger rbrace  ","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"to ensure that nu_e ge 0 and kappa_e ge 0. Leaving out the overlines and understanding that all variables represent the resolved/filtered variables, the eddy viscosity predictor is given by","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"    beginequation\n    labeleqnu-dagger\n    nu_e^dagger = -(CDelta)^2\n      frac\n        left( hatpartial_k hatv_i right) left( hatpartial_k hatv_j right) hatS_ij\n        + C_bhatdelta_i3 alpha g left( hatpartial_k hatv_i right) hatpartial_k theta\n        left( hatpartial_l hatv_m right) left( hatpartial_l hatv_m right)  \n    endequation","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"and the eddy diffusivity predictor by","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"    beginequation\n    kappa_e^dagger = -(CDelta)^2\n    frac\n        left( hatpartial_k hatv_i right) left( hatpartial_k hattheta right) hatpartial_i theta\n        left( hatpartial_l hattheta right) left( hatpartial_l hattheta right)  \n    endequation","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"where","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"  beginequation\n  hatx_i = fracx_iDelta_i quad\n  hatv_i(hatx t) = fracv_i(x t)Delta_i quad\n  hatpartial_i hatv_j(hatx t) = fracDelta_iDelta_j partial_i v_j(x t) quad\n  hatdelta_i3 = fracdelta_i3Delta_3  \n  endequation","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"so that the normalized rate of strain tensor is","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"    beginequation\n    labeleqS-hat\n    hatS_ij =\n      frac12 left hatpartial_i hatv_j(hatx t) + hatpartial_j hatv_i(hatx t) right  \n    endequation","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"In equations \\eqref{eq:nu-dagger}â€“\\eqref{eq:S-hat}, C is a modified PoincarÃ© \"constant\" that is independent from the filter width Delta but does depend on the accuracy of the discretization method used. Mahdi Abkar, Hyun J. Bae, Parviz Moin (2016) cite C^2 = frac112 for a spectral method and C^2 = frac13 for a second-order accurate scheme. Delta_i is the filter width in the x_i-direction, and Delta is given by the square root of the harmonic mean of the squares of the filter widths in each direction","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"    frac1Delta^2 = frac13 left( frac1Delta x^2 + frac1Delta y^2 + frac1Delta z^2 right)  ","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"The term multiplying C_b is the buoyancy modification introduced by Mahdi Abkar, Parviz Moin (2017) and is small for weakly stratified flows. We have introduced the C_b constant so that the buoyancy modification term may be turned on and off.","category":"page"},{"location":"physics/boundary_conditions/#Boundary-conditions","page":"Boundary conditions","title":"Boundary conditions","text":"","category":"section"},{"location":"physics/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Users may impose no-penetration, flux, gradient (Neumann), and value (Dirichlet) boundary conditions in bounded, non-periodic directions. Note that the only boundary condition available for a velocity field normal to the bounded direction is no-penetration.","category":"page"},{"location":"physics/boundary_conditions/#Flux-boundary-conditions","page":"Boundary conditions","title":"Flux boundary conditions","text":"","category":"section"},{"location":"physics/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"A flux boundary condition prescribes flux of a quantity normal to the boundary.   For a tracer c this corresponds to prescribing","category":"page"},{"location":"physics/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"q_c  _b equiv boldsymbolq_c boldsymbolcdot hatboldsymboln  _partial Omega_b  ","category":"page"},{"location":"physics/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"where partial Omega_b is an external boundary.","category":"page"},{"location":"physics/boundary_conditions/#Gradient-(Neumann)-boundary-condition","page":"Boundary conditions","title":"Gradient (Neumann) boundary condition","text":"","category":"section"},{"location":"physics/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"A gradient boundary condition prescribes the gradient of a field normal to the boundary. For a tracer c this prescribes","category":"page"},{"location":"physics/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"gamma equiv boldsymbolnabla c boldsymbolcdot hatboldsymboln  _partial Omega_b  ","category":"page"},{"location":"physics/boundary_conditions/#Value-(Dirichlet)-boundary-condition","page":"Boundary conditions","title":"Value (Dirichlet) boundary condition","text":"","category":"section"},{"location":"physics/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"A value boundary condition prescribes the value of a field on a boundary; for a tracer this prescribes","category":"page"},{"location":"physics/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"c_b equiv c  _partial Omega_b  ","category":"page"},{"location":"physics/boundary_conditions/#No-penetration-boundary-condition","page":"Boundary conditions","title":"No penetration boundary condition","text":"","category":"section"},{"location":"physics/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"A no penetration boundary condition prescribes the velocity component normal to a boundary to be 0, so that","category":"page"},{"location":"physics/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"boldsymbolhatn boldsymbolcdot boldsymbolv  _partial Omega_b = 0  ","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"EditURL = \"<unknown>/examples/one_dimensional_diffusion.jl\"","category":"page"},{"location":"generated/one_dimensional_diffusion/#Simple-diffusion-example","page":"One-dimensional diffusion","title":"Simple diffusion example","text":"","category":"section"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"This is Oceananigans.jl's simplest example: the diffusion of a one-dimensional Gaussian. This example demonstrates","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"How to load Oceananigans.jl.\nHow to instantiate an Oceananigans.jl model.\nHow to create simple Oceananigans.jl output.\nHow to set an initial condition with a function.\nHow to time-step a model forward.\nHow to look at results.","category":"page"},{"location":"generated/one_dimensional_diffusion/#Install-dependencies","page":"One-dimensional diffusion","title":"Install dependencies","text":"","category":"section"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"using Pkg\npkg\"add Oceananigans, CairoMakie\"","category":"page"},{"location":"generated/one_dimensional_diffusion/#Using-Oceananigans.jl","page":"One-dimensional diffusion","title":"Using Oceananigans.jl","text":"","category":"section"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Write","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"using Oceananigans","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"to load Oceananigans functions and objects into our script.","category":"page"},{"location":"generated/one_dimensional_diffusion/#Instantiating-and-configuring-a-model","page":"One-dimensional diffusion","title":"Instantiating and configuring a model","text":"","category":"section"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"A core Oceananigans type is NonhydrostaticModel. We build a NonhydrostaticModel by passing it a grid, plus information about the equations we would like to solve.","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Below, we build a rectilinear grid with 128 regularly-spaced grid points in the z-direction, where z spans from z = -0.5 to z = 0.5,","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"grid = RectilinearGrid(size=128, z=(-0.5, 0.5), topology=(Flat, Flat, Bounded))","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"The default topology is (Periodic, Periodic, Bounded). In this example, we're trying to solve a one-dimensional problem, so we assign Flat to the x and y topologies. We excise halos and avoid interpolation or differencing in Flat directions, saving computation and memory.","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"We next specify a model with an ScalarDiffusivity, which models either molecular or turbulent diffusion,","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"closure = ScalarDiffusivity(Îº=1)","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"We finally pass these two ingredients to NonhydrostaticModel,","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"model = NonhydrostaticModel(; grid, closure, tracers=:T)","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"By default, NonhydrostaticModel has no-flux (insulating and stress-free) boundary conditions on all fields.","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Next, we set! an initial condition on the temperature field, model.tracers.T. Our objective is to observe the diffusion of a Gaussian.","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"width = 0.1\ninitial_temperature(x, y, z) = exp(-z^2 / (2width^2))\nset!(model, T=initial_temperature)","category":"page"},{"location":"generated/one_dimensional_diffusion/#Visualizing-model-data","page":"One-dimensional diffusion","title":"Visualizing model data","text":"","category":"section"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Calling set! above changes the data contained in model.tracers.T, which was initialized as 0's when the model was created. To see the new data in model.tracers.T, we plot it:","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"using CairoMakie\nset_theme!(Theme(fontsize = 24, linewidth=3))\n\nfig = Figure()\naxis = (xlabel = \"Temperature (áµ’C)\", ylabel = \"z\")\nlabel = \"t = 0\"\n\nz = znodes(model.tracers.T)\nT = interior(model.tracers.T, 1, 1, :)\n\nlines(T, z; label, axis)\ncurrent_figure() # hide","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"The function interior above extracts a view of model.tracers.T over the physical points (excluding halos) at (1, 1, :).","category":"page"},{"location":"generated/one_dimensional_diffusion/#Running-a-Simulation","page":"One-dimensional diffusion","title":"Running a Simulation","text":"","category":"section"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Next we set-up a Simulation that time-steps the model forward and manages output.","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"# Time-scale for diffusion across a grid cell\nmin_Î”z = minimum_zspacing(model.grid)\ndiffusion_time_scale = min_Î”z^2 / model.closure.Îº.T\n\nsimulation = Simulation(model, Î”t = 0.1 * diffusion_time_scale, stop_iteration = 1000)","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"simulation will run for 1000 iterations with a time-step that resolves the time-scale at which our temperature field diffuses. All that's left is to","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"run!(simulation)","category":"page"},{"location":"generated/one_dimensional_diffusion/#Visualizing-the-results","page":"One-dimensional diffusion","title":"Visualizing the results","text":"","category":"section"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Let's look at how model.tracers.T changed during the simulation.","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"using Printf\n\nlabel = @sprintf(\"t = %.3f\", model.clock.time)\nlines!(interior(model.tracers.T, 1, 1, :), z; label)\naxislegend()\ncurrent_figure() # hide","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Very interesting! Next, we run the simulation a bit longer and make an animation. For this, we use the JLD2OutputWriter to write data to disk as the simulation progresses.","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"simulation.output_writers[:temperature] =\n    JLD2OutputWriter(model, model.tracers,\n                     filename = \"one_dimensional_diffusion.jld2\",\n                     schedule=IterationInterval(100),\n                     overwrite_existing = true)","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"We run the simulation for 10,000 more iterations,","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"simulation.stop_iteration += 10000\nrun!(simulation)","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Finally, we animate the results by opening the JLD2 file, extract the iterations we ended up saving at, and plot the evolution of the temperature profile in a loop over the iterations.","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"T_timeseries = FieldTimeSeries(\"one_dimensional_diffusion.jld2\", \"T\")\ntimes = T_timeseries.times\n\nfig = Figure()\nax = Axis(fig[2, 1]; xlabel = \"Temperature (áµ’C)\", ylabel = \"z\")\nxlims!(ax, 0, 1)\n\nn = Observable(1)\n\nT = @lift interior(T_timeseries[$n], 1, 1, :)\nlines!(T, z)\n\nlabel = @lift \"t = \" * string(round(times[$n], digits=3))\nLabel(fig[1, 1], label, tellwidth=false)\n\ncurrent_figure() # hide\nfig","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Finally, we record a movie.","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"frames = 1:length(times)\n\n@info \"Making an animation...\"\n\nrecord(fig, \"one_dimensional_diffusion.mp4\", frames, framerate=24) do i\n    msg = string(\"Plotting frame \", i, \" of \", frames[end])\n    print(msg * \" \\r\")\n    n[] = i\nend\nnothing #hide","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"(Image: )","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"","category":"page"},{"location":"generated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"This page was generated using Literate.jl.","category":"page"},{"location":"appendix/fractional_step/#fractional_step_method","page":"Fractional step method","title":"Fractional step method","text":"","category":"section"},{"location":"appendix/fractional_step/","page":"Fractional step method","title":"Fractional step method","text":"In some models (e.g., NonhydrostaticModel or HydrostaticFreeSurfaceModel) solving the momentum  coupled with the continuity equation can be cumbersome so instead we employ a fractional step  method. To approximate the solution of the coupled system we first solve an approximation to  the discretized momentum equation for an intermediate velocity field boldsymbolv^star  without worrying about satisfying the incompressibility constraint. We then project boldsymbolv^star  onto the space of divergence-free velocity fields to obtain a value for boldsymbolv^n+1  that satisfies continuity.","category":"page"},{"location":"appendix/fractional_step/","page":"Fractional step method","title":"Fractional step method","text":"For example, for the NonhydrostaticModel, if we ignore the background velocity fields and the surface waves, we thus discretize the momentum equation as","category":"page"},{"location":"appendix/fractional_step/","page":"Fractional step method","title":"Fractional step method","text":"  fracboldsymbolv^star - boldsymbolv^nDelta t\n    = - left boldsymbolv boldsymbolcdot boldsymbolnabla boldsymbolv right^n+frac12\n      - boldsymbolf times boldsymbolv^n+frac12\n      + boldsymbolnabla boldsymbolcdot left ( nu boldsymbolnabla boldsymbolv^n+frac12 right )\n      + boldsymbolF_boldsymbolv^n+frac12  ","category":"page"},{"location":"appendix/fractional_step/","page":"Fractional step method","title":"Fractional step method","text":"where the superscript n + frac12 indicates that these terms are evaluated at time step  n + frac12, which we compute explicitly (see Time-stepping section).","category":"page"},{"location":"appendix/fractional_step/","page":"Fractional step method","title":"Fractional step method","text":"The projection is then performed","category":"page"},{"location":"appendix/fractional_step/","page":"Fractional step method","title":"Fractional step method","text":"   boldsymbolv^n+1 = boldsymbolv^star - Delta t  boldsymbolnabla p^n+1  ","category":"page"},{"location":"appendix/fractional_step/","page":"Fractional step method","title":"Fractional step method","text":"to obtain a divergence-free velocity field boldsymbolv^n+1. Here the projection is performed by solving an elliptic problem for the pressure p^n+1 with the boundary condition","category":"page"},{"location":"appendix/fractional_step/","page":"Fractional step method","title":"Fractional step method","text":"  boldsymbolhatn boldsymbolcdot boldsymbolnabla p^n+1 _partialOmega = 0  ","category":"page"},{"location":"appendix/fractional_step/","page":"Fractional step method","title":"Fractional step method","text":"Steven A. Orszag, Moshe Israeli, Michel O. Deville (1986) and David L. Brown, Ricardo Cortez, Michael L. Minion (2001) raise an important issue regarding these fractional step  methods, which is that \"while the velocity can be reliably computed to second-order accuracy  in time and space, the pressure is typically only first-order accurate in the L_infty-norm.\"  The numerical boundary conditions must be carefully accounted for to ensure the second-order  accuracy promised by the fractional step methods.","category":"page"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"EditURL = \"<unknown>/examples/baroclinic_adjustment.jl\"","category":"page"},{"location":"generated/baroclinic_adjustment/#Baroclinic-adjustment","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"","category":"section"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"In this example, we simulate the evolution and equilibration of a baroclinically unstable front.","category":"page"},{"location":"generated/baroclinic_adjustment/#Install-dependencies","page":"Baroclinic adjustment","title":"Install dependencies","text":"","category":"section"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"using Pkg\npkg\"add Oceananigans, CairoMakie\"","category":"page"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"using Oceananigans\nusing Oceananigans.Units","category":"page"},{"location":"generated/baroclinic_adjustment/#Grid","page":"Baroclinic adjustment","title":"Grid","text":"","category":"section"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"We use a three-dimensional channel that is periodic in the x direction:","category":"page"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"Lx = 1000kilometers # east-west extent [m]\nLy = 1000kilometers # north-south extent [m]\nLz = 1kilometers    # depth [m]\n\nNx = 64\nNy = 64\nNz = 40\n\ngrid = RectilinearGrid(size = (Nx, Ny, Nz),\n                       x = (0, Lx),\n                       y = (-Ly/2, Ly/2),\n                       z = (-Lz, 0),\n                       topology = (Periodic, Bounded, Bounded))","category":"page"},{"location":"generated/baroclinic_adjustment/#Model","page":"Baroclinic adjustment","title":"Model","text":"","category":"section"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"We built a HydrostaticFreeSurfaceModel with an ImplicitFreeSurface solver. Regarding Coriolis, we use a beta-plane centered at 45Â° South.","category":"page"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"model = HydrostaticFreeSurfaceModel(; grid,\n                                    coriolis = BetaPlane(latitude = -45),\n                                    buoyancy = BuoyancyTracer(),\n                                    tracers = :b,\n                                    momentum_advection = WENO(),\n                                    tracer_advection = WENO())","category":"page"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"We want to initialize our model with a baroclinically unstable front plus some small-amplitude noise.","category":"page"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"\"\"\"\n    ramp(y, Î”y)\n\nLinear ramp from 0 to 1 between -Î”y/2 and +Î”y/2.\n\nFor example:\n```\n            y < -Î”y/2 => ramp = 0\n    -Î”y/2 < y < -Î”y/2 => ramp = y / Î”y\n            y >  Î”y/2 => ramp = 1\n```\n\"\"\"\nramp(y, Î”y) = min(max(0, y/Î”y + 1/2), 1)\nnothing #hide","category":"page"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"We then use ramp(y, Î”y) to construct an initial buoyancy configuration of a baroclinically unstable front. The front has a buoyancy jump Î”b over a latitudinal width Î”y.","category":"page"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"NÂ² = 4e-6 # [sâ»Â²] buoyancy frequency / stratification\nMÂ² = 8e-8 # [sâ»Â²] horizontal buoyancy gradient\n\nÎ”y = 50kilometers # width of the region of the front\nÎ”b = Î”y * MÂ²      # buoyancy jump associated with the front\nÏµb = 1e-2 * Î”b    # noise amplitude\n\nbáµ¢(x, y, z) = NÂ² * z + Î”b * ramp(y, Î”y) + Ïµb * randn()\n\nset!(model, b=báµ¢)","category":"page"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"Let's visualize the initial buoyancy distribution.","category":"page"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"using CairoMakie\n\nx, y, z = 1e-3 .* nodes(grid, (Center(), Center(), Center())) # convert m -> km\n\nb = model.tracers.b\n\nfig, ax, hm = heatmap(y, z, interior(b)[1, :, :],\n                      colormap=:deep,\n                      axis = (xlabel = \"y [km]\",\n                              ylabel = \"z [km]\",\n                              title = \"b(x=0, y, z, t=0)\",\n                              titlesize = 24))\n\nColorbar(fig[1, 2], hm, label = \"[m sâ»Â²]\")\n\ncurrent_figure() # hide\nfig","category":"page"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"Now let's built a Simulation.","category":"page"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"Î”tâ‚€ = 5minutes\nstop_time = 40days\n\nsimulation = Simulation(model, Î”t=Î”tâ‚€, stop_time=stop_time)","category":"page"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"We add a TimeStepWizard callback to adapt the simulation's time-step,","category":"page"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"wizard = TimeStepWizard(cfl=0.2, max_change=1.1, max_Î”t=20minutes)\n\nsimulation.callbacks[:wizard] = Callback(wizard, IterationInterval(20))","category":"page"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"Also, we add a callback to print a message about how the simulation is going,","category":"page"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"using Printf\n\nwall_clock = [time_ns()]\n\nfunction print_progress(sim)\n    @printf(\"[%05.2f%%] i: %d, t: %s, wall time: %s, max(u): (%6.3e, %6.3e, %6.3e) m/s, next Î”t: %s\\n\",\n            100 * (sim.model.clock.time / sim.stop_time),\n            sim.model.clock.iteration,\n            prettytime(sim.model.clock.time),\n            prettytime(1e-9 * (time_ns() - wall_clock[1])),\n            maximum(abs, sim.model.velocities.u),\n            maximum(abs, sim.model.velocities.v),\n            maximum(abs, sim.model.velocities.w),\n            prettytime(sim.Î”t))\n\n    wall_clock[1] = time_ns()\n\n    return nothing\nend\n\nsimulation.callbacks[:print_progress] = Callback(print_progress, IterationInterval(100))","category":"page"},{"location":"generated/baroclinic_adjustment/#Diagnostics/Output","page":"Baroclinic adjustment","title":"Diagnostics/Output","text":"","category":"section"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"Add some diagnostics. Here, we save the buoyancy, b, at the edges of our domain as well as the zonal (x) average of buoyancy.","category":"page"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"u, v, w = model.velocities\n\nB = Field(Average(b, dims=1))\n\nfilename = \"baroclinic_adjustment\"\nsave_fields_interval = 0.5day\n\nslicers = (west = (1, :, :),\n           east = (grid.Nx, :, :),\n           south = (:, 1, :),\n           north = (:, grid.Ny, :),\n           bottom = (:, :, 1),\n           top = (:, :, grid.Nz))\n\nfor side in keys(slicers)\n    indices = slicers[side]\n\n    simulation.output_writers[side] = JLD2OutputWriter(model, (; b);\n                                                       filename = filename * \"_$(side)_slice\",\n                                                       schedule = TimeInterval(save_fields_interval),\n                                                       overwrite_existing = true,\n                                                       indices)\nend\n\nsimulation.output_writers[:zonal] = JLD2OutputWriter(model, (b=B,);\n                                                     filename = filename * \"_zonal_average\",\n                                                     schedule = TimeInterval(save_fields_interval),\n                                                     overwrite_existing = true)","category":"page"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"Now let's run!","category":"page"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"@info \"Running the simulation...\"\n\nrun!(simulation)\n\n@info \"Simulation completed in \" * prettytime(simulation.run_wall_time)","category":"page"},{"location":"generated/baroclinic_adjustment/#Visualization","page":"Baroclinic adjustment","title":"Visualization","text":"","category":"section"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"Now we are ready to visualize our resutls! We use CairoMakie in this example. On a system with OpenGL using GLMakie is more convenient as figures will be displayed on the screen.","category":"page"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"using CairoMakie","category":"page"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"We load the saved buoyancy output on the top, bottom, and east surface as FieldTimeSerieses.","category":"page"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"filename = \"baroclinic_adjustment\"\n\nsides = keys(slicers)\n\nslice_filenames = NamedTuple(side => filename * \"_$(side)_slice.jld2\" for side in sides)\n\nb_timeserieses = (east   = FieldTimeSeries(slice_filenames.east, \"b\"),\n                  north  = FieldTimeSeries(slice_filenames.north, \"b\"),\n                  bottom = FieldTimeSeries(slice_filenames.bottom, \"b\"),\n                  top    = FieldTimeSeries(slice_filenames.top, \"b\"))\n\navg_b_timeseries = FieldTimeSeries(filename * \"_zonal_average.jld2\", \"b\")\n\ntimes = avg_b_timeseries.times\n\nnothing #hide","category":"page"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"We build the coordinates. We rescale horizontal coordinates so that they correspond to kilometers.","category":"page"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"x, y, z = nodes(b_timeserieses.east)\n\nx = x .* 1e-3 # convert m -> km\ny = y .* 1e-3 # convert m -> km\n\nx_xz = repeat(x, 1, Nz)\ny_xz_north = y[end] * ones(Nx, Nz)\nz_xz = repeat(reshape(z, 1, Nz), Nx, 1)\n\nx_yz_east = x[end] * ones(Ny, Nz)\ny_yz = repeat(y, 1, Nz)\nz_yz = repeat(reshape(z, 1, Nz), grid.Ny, 1)\n\nx_xy = x\ny_xy = y\nz_xy_top = z[end] * ones(grid.Nx, grid.Ny)\nz_xy_bottom = z[1] * ones(grid.Nx, grid.Ny)\nnothing #hide","category":"page"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"Then we create a 3D axis. We use zonal_slice_displacement to control where the plot of the instantaneous zonal average flow is located.","category":"page"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"fig = Figure(resolution = (900, 520))\n\nzonal_slice_displacement = 1.2\n\nax = Axis3(fig[2, 1], aspect=(1, 1, 1/5),\n           xlabel=\"x (km)\", ylabel=\"y (km)\", zlabel=\"z (m)\",\n           limits = ((x[1], zonal_slice_displacement * x[end]), (y[1], y[end]), (z[1], z[end])),\n           elevation = 0.45, azimuth = 6.8,\n           xspinesvisible = false, zgridvisible=false,\n           protrusions=40,\n           perspectiveness=0.7)\n\nnothing #hide","category":"page"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"We use Makie's Observable to animate the data. To dive into how Observables work we refer to Makie.jl's Documentation.","category":"page"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"n = Observable(1)","category":"page"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"Now let's make a 3D plot of the buoyancy and in front of it we'll use the zonally-averaged output to plot the instantaneous zonal-average of the buoyancy.","category":"page"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"b_slices = (east   = @lift(interior(b_timeserieses.east[$n], 1, :, :)),\n            north  = @lift(interior(b_timeserieses.north[$n], :, 1, :)),\n            bottom = @lift(interior(b_timeserieses.bottom[$n], :, :, 1)),\n            top    = @lift(interior(b_timeserieses.top[$n], :, :, 1)))\n\navg_b = @lift interior(avg_b_timeseries[$n], 1, :, :)\n\nclims = @lift 1.1 .* extrema(b_timeserieses.top[$n][:])\n\nkwargs = (colorrange = clims, colormap = :deep)\n\nsurface!(ax, x_yz_east, y_yz, z_yz;    color = b_slices.east, kwargs...)\nsurface!(ax, x_xz, y_xz_north, z_xz;   color = b_slices.north, kwargs...)\nsurface!(ax, x_xy, y_xy, z_xy_bottom ; color = b_slices.bottom, kwargs...)\nsurface!(ax, x_xy, y_xy, z_xy_top;     color = b_slices.top, kwargs...)\n\nsf = surface!(ax, zonal_slice_displacement .* x_yz_east, y_yz, z_yz; color = avg_b, kwargs...)\n\ncontour!(ax, y, z, avg_b; transformation = (:yz, zonal_slice_displacement * x[end]),\n         levels = 15, linewidth = 2, color = :black)\n\nColorbar(fig[2, 2], sf, label = \"m sâ»Â²\", height = 200, tellheight=false)\n\ntitle = @lift \"Buoyancy at t = \" * string(round(times[$n] / day, digits=1)) * \" days\"\n\nfig[1, 1:2] = Label(fig, title; fontsize = 24, tellwidth = false, padding = (0, 0, -120, 0))\n\ncurrent_figure() # hide\nfig","category":"page"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"Finally, we add a figure title with the time of the snapshot and then record a movie.","category":"page"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"frames = 1:length(times)\n\nrecord(fig, filename * \".mp4\", frames, framerate=8) do i\n    msg = string(\"Plotting frame \", i, \" of \", frames[end])\n    print(msg * \" \\r\")\n    n[] = i\nend\nnothing #hide","category":"page"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"(Image: )","category":"page"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"","category":"page"},{"location":"generated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"This page was generated using Literate.jl.","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#Buoyancy-models-and-equations-of-state","page":"Buoyancy models and equation of state","title":"Buoyancy models and equations of state","text":"","category":"section"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"The buoyancy option selects how buoyancy is treated in NonhydrostaticModels and HydrostaticFreeSurfaceModels (ShallowWaterModels do not have that option given the physics of the model). There are currently three alternatives:","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"No buoyancy (and no gravity).\nEvolve buoyancy as a tracer.\nSeawater buoyancy: evolve temperature T and salinity S as tracers with a value for the gravitational acceleration g and an equation of state of your choosing.","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#No-buoyancy","page":"Buoyancy models and equation of state","title":"No buoyancy","text":"","category":"section"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"To turn off buoyancy (and gravity) you can simply pass buoyancy = nothing to the model constructor. For example to create a NonhydrostaticModel:","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"DocTestSetup = quote\n    using Oceananigans\nend","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> grid = RectilinearGrid(size=(8, 8, 8), extent=(1, 1, 1));\n\njulia> model = NonhydrostaticModel(; grid, buoyancy=nothing)\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 8Ã—8Ã—8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ timestepper: QuasiAdamsBashforth2TimeStepper\nâ”œâ”€â”€ tracers: ()\nâ”œâ”€â”€ closure: Nothing\nâ”œâ”€â”€ buoyancy: Nothing\nâ””â”€â”€ coriolis: Nothing","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"The option buoyancy = nothing is the default for NonhydrostaticModel, so omitting the buoyancy keyword argument from the NonhydrostaticModel constructor yields the same:","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> model = NonhydrostaticModel(; grid)\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 8Ã—8Ã—8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ timestepper: QuasiAdamsBashforth2TimeStepper\nâ”œâ”€â”€ tracers: ()\nâ”œâ”€â”€ closure: Nothing\nâ”œâ”€â”€ buoyancy: Nothing\nâ””â”€â”€ coriolis: Nothing","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"To create a HydrostaticFreeSurfaceModel without a buoyancy term we explicitly specify buoyancy = nothing. The default tracers T and S for HydrostaticFreeSurfaceModel may be eliminated when buoyancy = nothing by specifying tracers = ():","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> model = HydrostaticFreeSurfaceModel(; grid, buoyancy=nothing, tracers=())\nHydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 8Ã—8Ã—8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ timestepper: QuasiAdamsBashforth2TimeStepper\nâ”œâ”€â”€ tracers: ()\nâ”œâ”€â”€ closure: Nothing\nâ”œâ”€â”€ buoyancy: Nothing\nâ”œâ”€â”€ free surface: ImplicitFreeSurface with gravitational acceleration 9.80665 m sâ»Â²\nâ”‚   â””â”€â”€ solver: FFTImplicitFreeSurfaceSolver\nâ””â”€â”€ coriolis: Nothing","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#Buoyancy-as-a-tracer","page":"Buoyancy models and equation of state","title":"Buoyancy as a tracer","text":"","category":"section"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"Both NonhydrostaticModel and HydrostaticFreeSurfaceModel support evolving a buoyancy tracer by including :b in tracers and specifying  buoyancy = BuoyancyTracer():","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> model = NonhydrostaticModel(; grid, buoyancy=BuoyancyTracer(), tracers=:b)\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 8Ã—8Ã—8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ timestepper: QuasiAdamsBashforth2TimeStepper\nâ”œâ”€â”€ tracers: b\nâ”œâ”€â”€ closure: Nothing\nâ”œâ”€â”€ buoyancy: BuoyancyTracer with gÌ‚ = NegativeZDirection()\nâ””â”€â”€ coriolis: Nothing","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"Similarly for a HydrostaticFreeSurfaceModel with buoyancy as a tracer:","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> model = HydrostaticFreeSurfaceModel(; grid, buoyancy=BuoyancyTracer(), tracers=:b)\nHydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 8Ã—8Ã—8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ timestepper: QuasiAdamsBashforth2TimeStepper\nâ”œâ”€â”€ tracers: b\nâ”œâ”€â”€ closure: Nothing\nâ”œâ”€â”€ buoyancy: BuoyancyTracer with gÌ‚ = NegativeZDirection()\nâ”œâ”€â”€ free surface: ImplicitFreeSurface with gravitational acceleration 9.80665 m sâ»Â²\nâ”‚   â””â”€â”€ solver: FFTImplicitFreeSurfaceSolver\nâ””â”€â”€ coriolis: Nothing","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#Seawater-buoyancy","page":"Buoyancy models and equation of state","title":"Seawater buoyancy","text":"","category":"section"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"NonhydrostaticModel and HydrostaticFreeSurfaceModel support modeling the buoyancy of seawater as a function of the gravitational acceleration, the conservative temperature T, and the absolute salinity S. The relationship between T, S, the geopotential height, and the density perturbation from a reference value is called the equation_of_state.","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"Specifying buoyancy = SeawaterBuoyancy() returns a buoyancy model with a linear equation of state, Earth standard gravitational_acceleration = 9.80665 (in  S.I. units textmtexts^-2) and requires to add :T and :S as tracers:","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> model = NonhydrostaticModel(; grid, buoyancy=SeawaterBuoyancy(), tracers=(:T, :S))\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 8Ã—8Ã—8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ timestepper: QuasiAdamsBashforth2TimeStepper\nâ”œâ”€â”€ tracers: (T, S)\nâ”œâ”€â”€ closure: Nothing\nâ”œâ”€â”€ buoyancy: SeawaterBuoyancy with g=9.80665 and LinearEquationOfState(thermal_expansion=0.000167, haline_contraction=0.00078) with gÌ‚ = NegativeZDirection()\nâ””â”€â”€ coriolis: Nothing","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"With HydrostaticFreeSurfaceModel, these are the default choices for buoyancy and tracers so, either including them or not we get:","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> model = HydrostaticFreeSurfaceModel(; grid, buoyancy=SeawaterBuoyancy(), tracers=(:T, :S))\nHydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 8Ã—8Ã—8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ timestepper: QuasiAdamsBashforth2TimeStepper\nâ”œâ”€â”€ tracers: (T, S)\nâ”œâ”€â”€ closure: Nothing\nâ”œâ”€â”€ buoyancy: SeawaterBuoyancy with g=9.80665 and LinearEquationOfState(thermal_expansion=0.000167, haline_contraction=0.00078) with gÌ‚ = NegativeZDirection()\nâ”œâ”€â”€ free surface: ImplicitFreeSurface with gravitational acceleration 9.80665 m sâ»Â²\nâ”‚   â””â”€â”€ solver: FFTImplicitFreeSurfaceSolver\nâ””â”€â”€ coriolis: Nothing","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"is identical to the default,","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> model = HydrostaticFreeSurfaceModel(; grid)\nHydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 8Ã—8Ã—8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ timestepper: QuasiAdamsBashforth2TimeStepper\nâ”œâ”€â”€ tracers: (T, S)\nâ”œâ”€â”€ closure: Nothing\nâ”œâ”€â”€ buoyancy: SeawaterBuoyancy with g=9.80665 and LinearEquationOfState(thermal_expansion=0.000167, haline_contraction=0.00078) with gÌ‚ = NegativeZDirection()\nâ”œâ”€â”€ free surface: ImplicitFreeSurface with gravitational acceleration 9.80665 m sâ»Â²\nâ”‚   â””â”€â”€ solver: FFTImplicitFreeSurfaceSolver\nâ””â”€â”€ coriolis: Nothing","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"To model flows near the surface of Europa where gravitational_acceleration = 1.3 textmtexts^-2, we might alternatively specify","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> buoyancy = SeawaterBuoyancy(gravitational_acceleration=1.3)\nSeawaterBuoyancy{Float64}:\nâ”œâ”€â”€ gravitational_acceleration: 1.3\nâ””â”€â”€ equation of state: LinearEquationOfState(thermal_expansion=0.000167, haline_contraction=0.00078)\n\njulia> model = NonhydrostaticModel(; grid, buoyancy=buoyancy, tracers=(:T, :S))\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 8Ã—8Ã—8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ timestepper: QuasiAdamsBashforth2TimeStepper\nâ”œâ”€â”€ tracers: (T, S)\nâ”œâ”€â”€ closure: Nothing\nâ”œâ”€â”€ buoyancy: SeawaterBuoyancy with g=1.3 and LinearEquationOfState(thermal_expansion=0.000167, haline_contraction=0.00078) with gÌ‚ = NegativeZDirection()\nâ””â”€â”€ coriolis: Nothing","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"for example.","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#Linear-equation-of-state","page":"Buoyancy models and equation of state","title":"Linear equation of state","text":"","category":"section"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"To specify the thermal expansion and haline contraction coefficients alpha = 2 times 10^-3  textK^-1 and beta = 5 times 10^-4 textpsu^-1,","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> buoyancy = SeawaterBuoyancy(equation_of_state=LinearEquationOfState(thermal_expansion=2e-3, haline_contraction=5e-4))\nSeawaterBuoyancy{Float64}:\nâ”œâ”€â”€ gravitational_acceleration: 9.80665\nâ””â”€â”€ equation of state: LinearEquationOfState(thermal_expansion=0.002, haline_contraction=0.0005)","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#Idealized-nonlinear-equations-of-state","page":"Buoyancy models and equation of state","title":"Idealized nonlinear equations of state","text":"","category":"section"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"Instead of a linear equation of state, six idealized (second-order) nonlinear equations of state as described by Fabien Roquet, Gurvan Madec, Laurent Brodeau, J. Nycander (2015) may be used. These equations of state are provided via the SeawaterPolynomials.jl package.","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> using SeawaterPolynomials.SecondOrderSeawaterPolynomials\n\njulia> eos = RoquetEquationOfState(:Freezing)\nBoussinesqEquationOfState{Float64}:\n    â”œâ”€â”€ seawater_polynomial: SecondOrderSeawaterPolynomial{Float64}\n    â””â”€â”€ reference_density: 1024.6\n    \njulia> eos.seawater_polynomial # the density anomaly\nÏ' = 0.7718 Sá´¬ - 0.0491 Î˜ - 0.005027 Î˜Â² - 2.5681e-5 Î˜ Z + 0.0 Sá´¬Â² + 0.0 Sá´¬ Z + 0.0 Sá´¬ Î˜\n\njulia> buoyancy = SeawaterBuoyancy(equation_of_state=eos)\nSeawaterBuoyancy{Float64}:\nâ”œâ”€â”€ gravitational_acceleration: 9.80665\nâ””â”€â”€ equation of state: BoussinesqEquationOfState{Float64}","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#TEOS-10-equation-of-state","page":"Buoyancy models and equation of state","title":"TEOS-10 equation of state","text":"","category":"section"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"A high-accuracy 55-term polynomial approximation to the TEOS-10 equation of state suitable for use in Boussinesq models as described by F. Roquet, G. Madec, Trevor J. McDougall, Paul M. Barker (2015) is implemented in the SeawaterPolynomials.jl package and may be used.","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> using SeawaterPolynomials.TEOS10\n\njulia> eos = TEOS10EquationOfState()\nBoussinesqEquationOfState{Float64}:\n    â”œâ”€â”€ seawater_polynomial: TEOS10SeawaterPolynomial{Float64}\n    â””â”€â”€ reference_density: 1020.0","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#The-direction-of-gravitational-acceleration","page":"Buoyancy models and equation of state","title":"The direction of gravitational acceleration","text":"","category":"section"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"To simulate gravitational accelerations that don't align with the vertical (z) coordinate, we wrap the buoyancy model in Buoyancy() function call, which takes the keyword arguments model and gravity_unit_vector,","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> Î¸ = 45; # degrees\n\njulia> gÌƒ = (0, sind(Î¸), cosd(Î¸));\n\njulia> model = NonhydrostaticModel(; grid, \n                                   buoyancy=Buoyancy(model=BuoyancyTracer(), gravity_unit_vector=gÌƒ), \n                                   tracers=:b)\nâ”Œ Warning: The meaning of `gravity_unit_vector` changed in version 0.80.0.\nâ”‚ In versions 0.79 and earlier, `gravity_unit_vector` indicated the direction _opposite_ to gravity.\nâ”‚ In versions 0.80.0 and later, `gravity_unit_vector` indicates the direction of gravitational acceleration.\nâ”” @ Oceananigans.BuoyancyModels ~/builds/tartarus-16/clima/oceananigans/src/BuoyancyModels/buoyancy.jl:48\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 8Ã—8Ã—8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ timestepper: QuasiAdamsBashforth2TimeStepper\nâ”œâ”€â”€ tracers: b\nâ”œâ”€â”€ closure: Nothing\nâ”œâ”€â”€ buoyancy: BuoyancyTracer with gÌ‚ = Tuple{Float64, Float64, Float64}\nâ””â”€â”€ coriolis: Nothing","category":"page"},{"location":"appendix/staggered_grid/#Staggered-grid","page":"Staggered grid","title":"Staggered grid","text":"","category":"section"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"Velocities u, v, and w are defined on the faces of the cells, which are coincident with three orthogonal coordinate axes (the Cartesian axes in the case of Oceananigans). Pressure p and tracers c are stored at the cell  centers as cell averages. See schematic below of the different control volumes. Other quantities may be defined at other locations. For example, vorticity boldsymbolomega = boldsymbolnabla times boldsymbolv is defined at the cell edges.[1]","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"[1]: In 2D it would more correct to say the cell corners. In 3D, variables like vorticity lie at the same vertical levels as the cell-centered variables and so they really lie at the cell edges.","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"(Image: Schematic of control volumes) A schematic of Oceananigans.jl finite volumes for a two-dimensional staggered grid in (x z). Tracers c and pressure p are defined at the center of the control volume. The u control volumes are  centered on the left and right edges of the pressure control volume while the w control volumes are centered  on the top and bottom edges of the pressure control volumes. The indexing convention places the i^rmth  u-node on cell x-faces to the left of the i tracer point at cell centers.","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"This staggered arrangement of variables is more complicated than the collocated grid arrangement but is greatly beneficial as it avoids the odd-even decoupling between the pressure and velocity if they are stored at the same positions. Â§6.1 of Suhas Patankar (1980) discusses this problem in the presence of a zigzag pressure field: on a 1D collocated grid the velocity at the point i is influenced by the pressure at points i-1 and i+1, and a zigzag pressure field will be felt as a uniform pressure, which is obviously wrong and would reduce the accuracy of the solution. The pressure is effectively taken from a coarser grid than what is actually used. The basic problem is that the momentum equations will use the pressure difference between two alternate points when it should be using two adjacent points.","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"From the viewpoint of linear algebra, these spurious pressure modes correspond to solutions in the null space of the pressure projection operator with eigenvalue zero and are thus indistinguishable from a uniform pressure field R. L. Sani, P. M. Gresho, R. L. Lee, D. F. Griffiths (1981).","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"The staggered grid was first introduced by Francis H. Harlow, J. Eddie Welch (1965) with their marker and cell method. In meteorology and oceanography, this particular staggered grid configuration is referred to as the Arakawa C-grid after Akio Arakawa, Vivian R. Lamb (1977), who investigated four different staggered grids and the unstaggered A-grid for use in an atmospheric model.","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"Akio Arakawa, Vivian R. Lamb (1977) investigated the dispersion relation of inertia-gravity waves[2] traveling in the x-direction","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"  omega^2 = f^2 + gHk^2  ","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"in the linearized rotating shallow-water equations for five grids. Here omega is the angular frequency, H is the height of the fluid and k is the wavenumber in the x-direction. Looking at the effect of spatial discretization error on the frequency of these waves they find that the B and C-grids reproduce the dispersion relation most closely out of the five Akio Arakawa, Vivian R. Lamb (1977) (Figure 5). In particular, the dispersion relation for the C-grid is given by","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"  omega^2 = f^2 left cos^2 left( frackDelta2 right)\n             + 4 left( fraclambdaDelta right)^2 sin^2 left( frackDelta2 right) right  ","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"where lambda is the wavelength and Delta is the grid spacing. Paraphrasing p. 184 of Akio Arakawa, Vivian R. Lamb (1977): The wavelength of the shortest resolvable wave is 2Delta with corresponding wavenumber k = piDelta so it is sufficient to evaluate the dispersion relation over the range 0  k Delta  pi. The frequency is monotonically increasing for lambda  Delta  frac12 and monotonically decreasing for lambda  Delta  frac12. For the fourth smallest wave lambda  Delta = frac12 we get omega^2 = f^2 which matches the k = 0 wave. Furthermore, the group velocity is zero for all k. On the other grids, waves with k Delta = pi can behave like pure inertial oscillations or stationary waves, which is bad.","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"The B and C-grids are less oscillatory than the others and quite faithfully simulate geostrophic adjustment. However, the C-grid is the only one that faithfully reproduces the two-dimensional dispersion relation omega^2(k ell), all the other grids have false maxima, and so Akio Arakawa, Vivian R. Lamb (1977) conclude that the C-grid is best for simulating geostrophic adjustment except for abnormal situations in which lambda  Delta is less than or close to 1. This seems to have held true for most atmospheric and oceanographic simulations as the C-grid is popular and widely used.","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"[2]: Apparently also called PoincarÃ© waves, Sverdrup waves, and rotational gravity waves Â§13.9 of Pijush K. Kundu, Ira M. Cohen, David R Dowling (2015).","category":"page"},{"location":"numerical_implementation/elliptic_solvers/#Elliptic-solvers","page":"Elliptic solvers","title":"Elliptic solvers","text":"","category":"section"},{"location":"numerical_implementation/elliptic_solvers/#The-elliptic-problem-for-the-pressure","page":"Elliptic solvers","title":"The elliptic problem for the pressure","text":"","category":"section"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"The 3D non-hydrostatic pressure field is obtained by taking the divergence of the horizontal  component of the momentum equations and invoking the vertical component to yield an elliptic  Poisson equation for the non-hydrostatic kinematic pressure","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"   beginequation\n   labeleqpoisson-pressure\n   nabla^2 p_NH = fracboldsymbolnabla boldsymbolcdot boldsymbolv^nDelta t + boldsymbolnabla boldsymbolcdot boldsymbolG_boldsymbolv equiv mathscrF  \n   endequation","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"along with homogenous Neumann boundary conditions boldsymbolv cdot boldsymbolhatn = 0  (Neumann on p for wall-bounded directions and periodic otherwise) and where mathscrF  denotes the source term for the Poisson equation.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"note: Hydrostatic approximation\nFor problems in which the hydrostatic approximation is invoked, the Poisson equation for pressure above only needs to be solved for the vertically integrated flow and the pressure field is a two dimensional term p_S(x y t).","category":"page"},{"location":"numerical_implementation/elliptic_solvers/#Direct-method","page":"Elliptic solvers","title":"Direct method","text":"","category":"section"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"Discretizing elliptic problems that can be solved via a classical separation-of-variables approach, such as Poisson's equation, results in a linear system of equations M boldsymbolx = boldsymboly where M is a real symmetric matrix of block tridiagonal form. This allows for the matrix to be decomposed and solved efficiently, provided that the eigenvalues and eigenvectors of the blocks are known (Â§2) B. Buzbee, G. Golub, C. Nielson (1970). In the case of Poisson's equation on a rectangle, R. W. Hockney (1965) has taken advantage of the fact that the fast Fourier transform can be used to perform the matrix multiplication steps resulting in an even more efficient method. Ulrich Schumann, Roland A Sweet (1988) describe the implementation of such an algorithm for Poisson's equation on a staggered grid with Dirichlet, Neumann, and periodic boundary conditions.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"The method can be explained easily by taking the Fourier transform of both sides of \\eqref{eq:poisson-pressure} to yield","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"    beginequation\n    labeleqpoisson-spectral\n    -(k_x^2 + k_y^2 + k_z^2) widehatp_NH = widehatmathscrF\n    quad implies quad\n    widehatp_NH = - fracwidehatmathscrFk_x^2 + k_y^2 + k_z^2  \n    endequation","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"where widehatcdot denotes the Fourier component. Here k_x, k_y, and k_z are the wavenumbers. However, when solving the equation on a staggered grid we require a solution for p_NH that is second-order accurate such that when when its Laplacian is computed, nabla^2 p_NH matches mathscrF to machine precision. This is crucial to ensure that the projection step in the fractional time-step works (see Time-stepping section and Fractional step method appendix). To do this, the wavenumbers are replaced by eigenvalues lambda^x, lambda^y, and lambda^z satisfying the discrete form of Poisson's equation with appropriate boundary conditions. Thus, Poisson's equation is diagonalized in Fourier space and the Fourier coefficients of the solution are easily solved for","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"widehatp_NH(i j k) = - fracwidehatmathscrF(i j k)lambda^x_i + lambda^y_j + lambda^z_k  ","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"The eigenvalues are given by Ulrich Schumann, Roland A Sweet (1988) and can also be tediously derived by plugging in the definition of the discrete Fourier transform into \\eqref{eq:poisson-spectral}:","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"beginalign\n    lambda^x_i = 4fracN_x^2L_x^2 sin^2 left  frac(i-1) piN_x  right  quad i=0 1 dots N_x-1   \n    lambda^y_j = 4fracN_y^2L_y^2 sin^2 left  frac(j-1) piN_y  right  quad j=0 1 dots N_y-1   \n    lambda^z_k = 4fracN_z^2L_z^2 sin^2 left  frac(k-1) pi2N_z right  quad k=0 1 dots N_z-1  \nendalign","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"where lambda^x and lambda^y correspond to periodic boundary conditions in the horizontal and lambda^z to Neumann boundary conditions in the vertical.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"There is also an ambiguity in the solution to Poisson's equation as it's only defined up to a constant. To resolve this ambiguity we choose the solution with zero mean by setting the zeroth Fourier coefficient p_000 (corresponding to k_x = k_y = k_z = 0) to zero. This also has the added benefit of discarding the zero eigenvalue so we don't divide by it.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"The Fast Fourier transforms are computed using FFTW.jl [M. Frigo, S.G. Johnson (1998) and M. Frigo, S.G. Johnson (2005)] on the CPU and using the cuFFT library on the GPU. Along wall-bounded dimensions, the cosine transform is used. In particular, as the transforms are performed on a staggered grid, DCT-II (REDFT10) is used to perform the forward cosine transform and DCT-III (REDFT01) is used to perform the inverse cosine transform.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/#Direct-method-with-a-vertically-stretched-grid","page":"Elliptic solvers","title":"Direct method with a vertically stretched grid","text":"","category":"section"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"Using Fourier transforms for all three dimensions results in a method requiring mathcalO(N log_2 N) operations where N is the total number of grid points. This algorithm can be made even more efficient by solving a tridiagonal system along one of the dimensions and utilizing cyclic reduction. This results in the Fourier analysis cyclic reduction or textFACR(ell) algorithm (with ell cyclic reduction steps) which requires only mathcalO(N log_2log_2 N) operations provided the optimal number of cyclic reduction steps is taken, which is ell = log_2 log_2 n where n is the number of grid points in the cyclic reduction dimension. The FACR algorithm was first developed by R. W. Hockney (1969) and is well reviewed by Paul N. Swarztrauber (1977) then further benchmarked and extended by Clive Temperton (1979) and Clive Temperton (1980).","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"Furthermore, the FACR algorithm removes the restriction that the grid is uniform in one of the dimensions so it can be utilized to implement a fast Poisson solver for vertically stretched grids if the cyclic reduction is applied in the along the vertical dimension.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"Expanding p_NH and mathscrF into Fourier modes along the x and y directions","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"p_ijk = sum_m=1^N_x sum_n=1^N_y tildep_mnk  e^-mathrmi 2pi i m  N_x   e^-mathrmi 2pi j n  N_y  ","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"and recalling that Fourier transforms do partial_x rightarrow mathrmi k_x and partial_y rightarrow mathrmi k_y we can write \\eqref{eq:poisson-pressure} as","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"sum_m=1^N_x sum_n=1^N_y\nleftlbrace\n    partial_z^2 tildep_mnk - (k_x^2 + k_y^2) tildep_mnk - tildemathscrF_mnk\nrightrbrace e^-mathrmi 2 pi i m  N_x  e^-mathrmi 2 pi j n  N_y = 0  ","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"Discretizing the partial_z^2 derivative and equating the term inside the brackets to zero we arrive at N_xtimes N_y symmetric tridiagonal systems of N_z linear equations for the Fourier modes:","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"fractildep_mn k-1Delta z^C_k\n- leftlbrace frac1Delta z^C_k + frac1Delta z^C_k+1 + Delta z^F_k (k_x^2 + k_y^2) rightrbrace\n  tildep_mnk\n+ fractildep_mn k+1Delta z^C_k+1\n= Delta z^F_k tildemathscrF_mnk  ","category":"page"},{"location":"numerical_implementation/elliptic_solvers/#Cosine-transforms-on-the-GPU","page":"Elliptic solvers","title":"Cosine transforms on the GPU","text":"","category":"section"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"Unfortunately cuFFT does not provide cosine transforms and so we must write our own fast cosine  transforms for the GPU. We implemented the fast 1D and 2D cosine transforms described by J. Makhoul (1980)  which compute it by applying the regular Fourier transform to a permuted version of the array.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"In this section we will be using the DCT-II as the definition of the forward cosine transform  for a real signal of length N","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"    beginequation\n    labeleqFCT\n    textDCT(X) quad Y_k = 2 sum_j=0^N-1 cos left fracpi(j + frac12)kN right X_j  \n    endequation","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"and the DCT-III as the definition of the inverse cosine transform","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"    beginequation\n    labeleqIFCT\n    textIDCT(X) quad Y_k = X_0 + 2 sum_j=1^N-1 cos left fracpi j (k + frac12)N right X_j  \n    endequation  ","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"and will use omega_M = e^-2 pi mathrmi  M to denote the M^textth root of unity, sometimes called the twiddle factors in the context of FFT algorithms.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/#D-fast-cosine-transform","page":"Elliptic solvers","title":"1D fast cosine transform","text":"","category":"section"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"To calculate \\eqref{eq:FCT} using the fast Fourier transform, we first permute the input signal along the appropriate dimension by ordering the odd elements first followed by the even elements to produce a permuted signal","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"    X^prime_n =\n    begincases\n        displaystyle X_2N quad 0 le n le left fracN-12 right   \n        displaystyle X_2N - 2n - 1 quad left fracN+12 right le n le N-1  \n    endcases","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"where a indicates the integer part of a. This should produce, for example,","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"    beginequation\n    labeleqpermutation\n    (a b c d e f g h) quad rightarrow quad (a c e g h f d b)  \n    endequation","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"after which \\eqref{eq:FCT} is computed using","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"  Y = textDCT(X) = 2 textRe leftlbrace omega_4N^k textFFT lbrace X^prime rbrace rightrbrace  ","category":"page"},{"location":"numerical_implementation/elliptic_solvers/#D-fast-inverse-cosine-transform","page":"Elliptic solvers","title":"1D fast inverse cosine transform","text":"","category":"section"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"The inverse \\eqref{eq:IFCT} can be computed using","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"  Y = textIDCT(X) = textRe leftlbrace omega_4N^-k textIFFT lbrace X rbrace rightrbrace  ","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"after which the inverse permutation of \\eqref{eq:permutation} must be applied.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/#D-fast-cosine-transform-2","page":"Elliptic solvers","title":"2D fast cosine transform","text":"","category":"section"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"Unfortunately, the 1D algorithm cannot be applied dimension-wise so the 2D algorithm is more  complicated. Thankfully, the permutation \\eqref{eq:permutation} can be applied dimension-wise.  The forward cosine transform for a real signal of length N_1 times N_2 is then given by","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"Y_k_1 k_2 = textDCT(X_n_1 n_2) =\n2 textRe leftlbrace\n    omega_4N_1^k left( omega_4N_2^k tildeX + omega_4N_2^-k tildeX^- right)\nrightrbrace  ","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"where tildeX = textFFT(X^prime) and tildeX^- indicates that tildeX is indexed in reverse.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/#D-fast-inverse-cosine-transform-2","page":"Elliptic solvers","title":"2D fast inverse cosine transform","text":"","category":"section"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"The inverse can be computed using","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"Y_k_1 k_2 = textIDCT(X_n_1 n_2) =\nfrac14 textRe leftlbrace\n    omega_4N_1^-k omega_4N_2^-k\n    left( tildeX - M_1 M_2 tildeX^-- right)\n    - mathrmi left( M_1 tildeX^-+ + M_2 tildeX^+- right)\nrightrbrace  ","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"where tildeX = textIFFT(X) here, tildeX^-+ is indexed in reverse along the first dimension, tildeX^-+ along the second dimension, and tildeX^-- along both. M_1 and M_2 are masks of lengths N_1 and N_2 respectively, both containing ones except at the first element where M_0 = 0. Afterwards, the inverse permutation of \\eqref{eq:permutation} must be applied.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"Due to the extra steps involved in calculating the cosine transform in 2D, running with two  wall-bounded dimensions typically slows the model down by a factor of 2. Switching to the FACR  algorithm may help here as a 2D cosine transform won't be necessary anymore.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/#Iterative-Solvers","page":"Elliptic solvers","title":"Iterative Solvers","text":"","category":"section"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"For problems with irregular grids the eigenvectors of the discrete Poisson operator are no longer simple Fourier series sines and cosines. This means discrete Fast Fourier Transforms can't be used to generate the projection  of the equation right hand side onto eigenvectors. So an eigenvector based approach to solving the Poisson equation is not computationally efficient.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"For problems with grids that are non uniform in multiple directions, we use instead a pre-conditioned conjugate gradient iterative solver. Such cases include curvilinear grids on the sphere and also telescoping cartesian grids that stretch along more than one dimension. There are two forms of the pressure operator in this approach. One is rigid lid form and one is an implicit free-surface form.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/#Rigid-lid-pressure-operator","page":"Elliptic solvers","title":"Rigid lid pressure operator","text":"","category":"section"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"The rigid lid operator is based on the same continuous form as is used in the Direct Method solver.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/#Implicit-free-surface-pressure-operator","page":"Elliptic solvers","title":"Implicit free surface pressure operator","text":"","category":"section"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"The implicit free surface solver solves for the free-surface, eta(x y t), in the vertically integrated continuity equation:","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"    beginequation\n    labeleqvertically-integrated-continuity\n    partial_t eta + partial_x left ( int_-H^0 u  mathrmdz right ) + partial_y left ( int_-H^0 v  mathrmdz right ) = M  \n    endequation","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"where H(x y) is the depth of the water column (to first order with respect to the free surface elevation) and M is some surface volume flux (e.g., terms such as precipitation, evaporation and runoff); currently Oceananigans.jl assumes M = 0. Note that in deriving \\eqref{eq:vertically-integrated-continuity}, we used the bottom boundary condition w_rm bottom = boldsymbolu_rm bottom boldsymbolcdot boldsymbolnabla_h H.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"To form a linear system that can be solved implicitly we recast the vertically-integrated continuity equation \\eqref{eq:vertically-integrated-continuity} into a discrete integral form. The best way to do so is by starting from the discrete version of the continuity equation (in this case without any surface volume flux, M = 0)","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"    beginalign\n    labeleqcontinuity-discrete\n    delta_x (A_x u) + delta_y (A_y v) + delta_z (A_z w) = 0  \n    endalign","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"and summing it vertically to get:","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"    beginalign\n    labeleqvertically-integrated-continuity-discrete\n    delta_x sum_k (A_x u) + delta_y sum_k (A_y v) + A_z underbracew(k = N_z + 1)_w_rm top = 0  \n    endalign","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"In equations \\eqref{eq:continuity-discrete} and \\eqref{eq:vertically-integrated-continuity-discrete} and here after, we have abused notation and used, e.g., u and v to denote the volume averages over grid cells of the quantities u and v respectively. Using w_rm top = partial_t eta and being a bit more explicit on the locations the difference operators act on, \\eqref{eq:vertically-integrated-continuity-discrete} becomes:","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"    beginequation\n    labeleqsemi-discrete-integral-continuity\n    A_z partial_t eta + delta_x^caa sum_k (A_x u) + delta_y^aca sum_k (A_y v) = 0  \n    endequation","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"We can now apply the velocity fractional step equation (discussed in the Time-stepping section) for the hydrostatic model:","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"    beginequation\n    labeleqhydrostatic-fractional-step\n    boldsymbolu^n+1 = boldsymbolu^star - g Delta t  boldsymbolnabla eta^n+1  \n    endequation","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"We impose that the n+1-th time step velocity is consistent with \\eqref{eq:semi-discrete-integral-continuity}","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"    beginequation\n    A_z fraceta^n+1 - eta^nDelta t = - delta_x^caa sum_k (A_x u^n+1) - delta_y^aca sum_k (A_y v^n+1)  \n    endequation","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"Substituting u^n+1 and v^n+1 from the discrete form of the right-hand-side of \\eqref{eq:hydrostatic-fractional-step} then gives us an implicit equation for eta^n+1:","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"beginalign\n    delta_x^caasum_k A_x partial_x^faa eta^n+1  + delta_y^aca sum_k A_y partial_y^afa eta^n+1 - frac1g  Delta t^2 A_z eta^n+1 = nonumber \n     = frac1g  Delta t left( delta_x^caa sum_k A_x u^star + delta_y^aca sum_k A_y v^star right ) - frac1g  Delta t^2 A_z eta^n   labeleqimplicit-free-surface\nendalign","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"The left-hand-side of \\eqref{eq:implicit-free-surface} is nothing else than a linear operator acting on eta^n+1. Formulated in this way, the linear operator is symmetric and therefore \\eqref{eq:implicit-free-surface} can be solved using a preconditioned conjugate gradient algorithm.","category":"page"},{"location":"appendix/benchmarks/#performance_benchmarks","page":"Performance benchmarks","title":"Performance benchmarks","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"The performance benchmarking scripts in the benchmarks directory of the git repository can be run to benchmark Oceananigans.jl on your machine. They use BenchmarkTools.jl to collect data and PrettyTables.jl  to nicely format the benchmark results.","category":"page"},{"location":"appendix/benchmarks/#Shallow-Water-Model","page":"Performance benchmarks","title":"Shallow Water Model","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"This benchmark tests the performance of the shallow water model run in a doubly periodic domain (topology = (Periodic, Periodic, Flat)) on a CPU versus a GPU.  We find that with the WENO advection scheme we get a maximum speedup of more than 400 times on a 16384^2 grid.","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Oceananigans v0.58.1\r\nJulia Version 1.6.0\r\nCommit f9720dc2eb (2021-03-24 12:55 UTC)\r\nPlatform Info:\r\n  OS: Linux (x86_64-pc-linux-gnu)\r\n  CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz\r\n  WORD_SIZE: 64\r\n  LIBM: libopenlibm\r\n  LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake)\r\nEnvironment:\r\n  EBVERSIONJULIA = 1.6.0\r\n  JULIA_DEPOT_PATH = :\r\n  EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0\r\n  EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel\r\n  JULIA_LOAD_PATH = :\r\n  GPU: Tesla V100-SXM2-32GB\r\n\r\n                                              Shallow water model benchmarks\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚ Architectures â”‚ Float_types â”‚    Ns â”‚        min â”‚     median â”‚       mean â”‚        max â”‚    memory â”‚ allocs â”‚ samples â”‚\r\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\r\nâ”‚           CPU â”‚     Float64 â”‚    32 â”‚   2.677 ms â”‚   2.876 ms â”‚   3.047 ms â”‚   4.806 ms â”‚  1.36 MiB â”‚   2253 â”‚      10 â”‚\r\nâ”‚           CPU â”‚     Float64 â”‚    64 â”‚   5.795 ms â”‚   5.890 ms â”‚   6.073 ms â”‚   7.770 ms â”‚  1.36 MiB â”‚   2255 â”‚      10 â”‚\r\nâ”‚           CPU â”‚     Float64 â”‚   128 â”‚  16.979 ms â”‚  17.350 ms â”‚  17.578 ms â”‚  19.993 ms â”‚  1.36 MiB â”‚   2255 â”‚      10 â”‚\r\nâ”‚           CPU â”‚     Float64 â”‚   256 â”‚  62.543 ms â”‚  63.222 ms â”‚  63.544 ms â”‚  67.347 ms â”‚  1.36 MiB â”‚   2255 â”‚      10 â”‚\r\nâ”‚           CPU â”‚     Float64 â”‚   512 â”‚ 250.149 ms â”‚ 251.023 ms â”‚ 251.092 ms â”‚ 252.389 ms â”‚  1.36 MiB â”‚   2315 â”‚      10 â”‚\r\nâ”‚           CPU â”‚     Float64 â”‚  1024 â”‚ 990.901 ms â”‚ 993.115 ms â”‚ 993.360 ms â”‚ 996.091 ms â”‚  1.36 MiB â”‚   2315 â”‚       6 â”‚\r\nâ”‚           CPU â”‚     Float64 â”‚  2048 â”‚    4.002 s â”‚    4.004 s â”‚    4.004 s â”‚    4.007 s â”‚  1.36 MiB â”‚   2315 â”‚       2 â”‚\r\nâ”‚           CPU â”‚     Float64 â”‚  4096 â”‚   16.371 s â”‚   16.371 s â”‚   16.371 s â”‚   16.371 s â”‚  1.36 MiB â”‚   2315 â”‚       1 â”‚\r\nâ”‚           CPU â”‚     Float64 â”‚  8192 â”‚   64.657 s â”‚   64.657 s â”‚   64.657 s â”‚   64.657 s â”‚  1.36 MiB â”‚   2315 â”‚       1 â”‚\r\nâ”‚           CPU â”‚     Float64 â”‚ 16384 â”‚  290.423 s â”‚  290.423 s â”‚  290.423 s â”‚  290.423 s â”‚  1.36 MiB â”‚   2315 â”‚       1 â”‚\r\nâ”‚           GPU â”‚     Float64 â”‚    32 â”‚   3.468 ms â”‚   3.656 ms â”‚   3.745 ms â”‚   4.695 ms â”‚  1.82 MiB â”‚   5687 â”‚      10 â”‚\r\nâ”‚           GPU â”‚     Float64 â”‚    64 â”‚   3.722 ms â”‚   3.903 ms â”‚   4.050 ms â”‚   5.671 ms â”‚  1.82 MiB â”‚   5687 â”‚      10 â”‚\r\nâ”‚           GPU â”‚     Float64 â”‚   128 â”‚   3.519 ms â”‚   3.808 ms â”‚   4.042 ms â”‚   6.372 ms â”‚  1.82 MiB â”‚   5687 â”‚      10 â”‚\r\nâ”‚           GPU â”‚     Float64 â”‚   256 â”‚   3.822 ms â”‚   4.153 ms â”‚   4.288 ms â”‚   5.810 ms â”‚  1.82 MiB â”‚   5687 â”‚      10 â”‚\r\nâ”‚           GPU â”‚     Float64 â”‚   512 â”‚   4.637 ms â”‚   4.932 ms â”‚   4.961 ms â”‚   5.728 ms â”‚  1.82 MiB â”‚   5765 â”‚      10 â”‚\r\nâ”‚           GPU â”‚     Float64 â”‚  1024 â”‚   3.240 ms â”‚   3.424 ms â”‚   3.527 ms â”‚   4.553 ms â”‚  1.82 MiB â”‚   5799 â”‚      10 â”‚\r\nâ”‚           GPU â”‚     Float64 â”‚  2048 â”‚  10.783 ms â”‚  10.800 ms â”‚  11.498 ms â”‚  17.824 ms â”‚  1.98 MiB â”‚  16305 â”‚      10 â”‚\r\nâ”‚           GPU â”‚     Float64 â”‚  4096 â”‚  41.880 ms â”‚  41.911 ms â”‚  42.485 ms â”‚  47.627 ms â”‚  2.67 MiB â”‚  61033 â”‚      10 â”‚\r\nâ”‚           GPU â”‚     Float64 â”‚  8192 â”‚ 166.751 ms â”‚ 166.800 ms â”‚ 166.847 ms â”‚ 167.129 ms â”‚  5.21 MiB â”‚ 227593 â”‚      10 â”‚\r\nâ”‚           GPU â”‚     Float64 â”‚ 16384 â”‚ 681.129 ms â”‚ 681.249 ms â”‚ 681.301 ms â”‚ 681.583 ms â”‚ 16.59 MiB â”‚ 973627 â”‚       8 â”‚\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\r\n\r\n        Shallow water model CPU to GPU speedup\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚ Float_types â”‚    Ns â”‚  speedup â”‚  memory â”‚  allocs â”‚\r\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\r\nâ”‚     Float64 â”‚    32 â”‚ 0.786715 â”‚ 1.33777 â”‚ 2.52419 â”‚\r\nâ”‚     Float64 â”‚    64 â”‚  1.50931 â”‚ 1.33774 â”‚ 2.52195 â”‚\r\nâ”‚     Float64 â”‚   128 â”‚  4.55587 â”‚ 1.33774 â”‚ 2.52195 â”‚\r\nâ”‚     Float64 â”‚   256 â”‚  15.2238 â”‚ 1.33774 â”‚ 2.52195 â”‚\r\nâ”‚     Float64 â”‚   512 â”‚  50.8995 â”‚ 1.33771 â”‚ 2.49028 â”‚\r\nâ”‚     Float64 â”‚  1024 â”‚  290.085 â”‚ 1.33809 â”‚ 2.50497 â”‚\r\nâ”‚     Float64 â”‚  2048 â”‚  370.777 â”‚ 1.45575 â”‚  7.0432 â”‚\r\nâ”‚     Float64 â”‚  4096 â”‚  390.617 â”‚ 1.95667 â”‚ 26.3641 â”‚\r\nâ”‚     Float64 â”‚  8192 â”‚  387.632 â”‚ 3.82201 â”‚ 98.3123 â”‚\r\nâ”‚     Float64 â”‚ 16384 â”‚   426.31 â”‚  12.177 â”‚ 420.573 â”‚\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"As shown in the graph below, speedups increase sharply starting at grid size 512^2 and then plateau off at around 400 times at grid size 4096^2 and beyond.","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"(Image: shallow_water_speedup)","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"The time graph below shows that execution times on GPU are negligibly small up until grid size 1024^2 where it starts to scale similarly to times on CPU.","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"(Image: shallow_water_times)","category":"page"},{"location":"appendix/benchmarks/#Nonhydrostatic-Model","page":"Performance benchmarks","title":"Nonhydrostatic Model","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Similar to to shallow water model, the nonhydrostatic model benchmark tests for its performance on both a CPU and a GPU. It was also benchmarked with the WENO advection scheme. The nonhydrostatic model is 3-dimensional unlike the 2-dimensional shallow water model. Total number of grid points is Ns cubed.","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Oceananigans v0.58.8\r\nJulia Version 1.6.1\r\nCommit 6aaedecc44 (2021-04-23 05:59 UTC)\r\nPlatform Info:\r\n  OS: Linux (x86_64-pc-linux-gnu)\r\n  CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz\r\n  WORD_SIZE: 64\r\n  LIBM: libopenlibm\r\n  LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake)\r\nEnvironment:\r\n  EBVERSIONJULIA = 1.6.1\r\n  JULIA_DEPOT_PATH = :\r\n  EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1\r\n  EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1/easybuild/avx2-Core-julia-1.6.1-easybuild-devel\r\n  JULIA_LOAD_PATH = :\r\n  GPU: Tesla V100-SXM2-32GB\r\n\r\n                                            Nonhydrostatic model benchmarks\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚ Architectures â”‚ Float_types â”‚  Ns â”‚        min â”‚     median â”‚       mean â”‚        max â”‚   memory â”‚ allocs â”‚ samples â”‚\r\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\r\nâ”‚           CPU â”‚     Float32 â”‚  32 â”‚  34.822 ms â”‚  34.872 ms â”‚  35.278 ms â”‚  38.143 ms â”‚ 1.38 MiB â”‚   2302 â”‚      10 â”‚\r\nâ”‚           CPU â”‚     Float32 â”‚  64 â”‚ 265.408 ms â”‚ 265.571 ms â”‚ 265.768 ms â”‚ 267.765 ms â”‚ 1.38 MiB â”‚   2302 â”‚      10 â”‚\r\nâ”‚           CPU â”‚     Float32 â”‚ 128 â”‚    2.135 s â”‚    2.135 s â”‚    2.136 s â”‚    2.138 s â”‚ 1.38 MiB â”‚   2302 â”‚       3 â”‚\r\nâ”‚           CPU â”‚     Float32 â”‚ 256 â”‚   17.405 s â”‚   17.405 s â”‚   17.405 s â”‚   17.405 s â”‚ 1.38 MiB â”‚   2302 â”‚       1 â”‚\r\nâ”‚           CPU â”‚     Float64 â”‚  32 â”‚  37.022 ms â”‚  37.179 ms â”‚  37.335 ms â”‚  39.017 ms â”‚ 1.77 MiB â”‚   2302 â”‚      10 â”‚\r\nâ”‚           CPU â”‚     Float64 â”‚  64 â”‚ 287.944 ms â”‚ 288.154 ms â”‚ 288.469 ms â”‚ 290.838 ms â”‚ 1.77 MiB â”‚   2302 â”‚      10 â”‚\r\nâ”‚           CPU â”‚     Float64 â”‚ 128 â”‚    2.326 s â”‚    2.326 s â”‚    2.326 s â”‚    2.327 s â”‚ 1.77 MiB â”‚   2302 â”‚       3 â”‚\r\nâ”‚           CPU â”‚     Float64 â”‚ 256 â”‚   19.561 s â”‚   19.561 s â”‚   19.561 s â”‚   19.561 s â”‚ 1.77 MiB â”‚   2302 â”‚       1 â”‚\r\nâ”‚           GPU â”‚     Float32 â”‚  32 â”‚   4.154 ms â”‚   4.250 ms â”‚   4.361 ms â”‚   5.557 ms â”‚ 2.13 MiB â”‚   6033 â”‚      10 â”‚\r\nâ”‚           GPU â”‚     Float32 â”‚  64 â”‚   3.383 ms â”‚   3.425 ms â”‚   3.889 ms â”‚   8.028 ms â”‚ 2.13 MiB â”‚   6077 â”‚      10 â”‚\r\nâ”‚           GPU â”‚     Float32 â”‚ 128 â”‚   5.564 ms â”‚   5.580 ms â”‚   6.095 ms â”‚  10.725 ms â”‚ 2.15 MiB â”‚   7477 â”‚      10 â”‚\r\nâ”‚           GPU â”‚     Float32 â”‚ 256 â”‚  38.685 ms â”‚  38.797 ms â”‚  39.548 ms â”‚  46.442 ms â”‚ 2.46 MiB â”‚  27721 â”‚      10 â”‚\r\nâ”‚           GPU â”‚     Float64 â”‚  32 â”‚   3.309 ms â”‚   3.634 ms â”‚   3.802 ms â”‚   5.844 ms â”‚ 2.68 MiB â”‚   6033 â”‚      10 â”‚\r\nâ”‚           GPU â”‚     Float64 â”‚  64 â”‚   3.330 ms â”‚   3.648 ms â”‚   4.008 ms â”‚   7.808 ms â”‚ 2.68 MiB â”‚   6071 â”‚      10 â”‚\r\nâ”‚           GPU â”‚     Float64 â”‚ 128 â”‚   7.209 ms â”‚   7.323 ms â”‚   8.313 ms â”‚  17.259 ms â”‚ 2.71 MiB â”‚   8515 â”‚      10 â”‚\r\nâ”‚           GPU â”‚     Float64 â”‚ 256 â”‚  46.614 ms â”‚  56.444 ms â”‚  55.461 ms â”‚  56.563 ms â”‚ 3.17 MiB â”‚  38253 â”‚      10 â”‚\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\r\n\r\n      Nonhydrostatic model CPU to GPU speedup\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚ Float_types â”‚  Ns â”‚ speedup â”‚  memory â”‚  allocs â”‚\r\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\r\nâ”‚     Float32 â”‚  32 â”‚ 8.20434 â”‚ 1.53786 â”‚ 2.62076 â”‚\r\nâ”‚     Float32 â”‚  64 â”‚ 77.5308 â”‚ 1.53835 â”‚ 2.63988 â”‚\r\nâ”‚     Float32 â”‚ 128 â”‚ 382.591 â”‚ 1.55378 â”‚ 3.24805 â”‚\r\nâ”‚     Float32 â”‚ 256 â”‚ 448.619 â”‚ 1.77688 â”‚ 12.0421 â”‚\r\nâ”‚     Float64 â”‚  32 â”‚ 10.2308 â”‚ 1.51613 â”‚ 2.62076 â”‚\r\nâ”‚     Float64 â”‚  64 â”‚ 78.9952 â”‚ 1.51646 â”‚ 2.63727 â”‚\r\nâ”‚     Float64 â”‚ 128 â”‚ 317.663 â”‚ 1.53759 â”‚ 3.69896 â”‚\r\nâ”‚     Float64 â”‚ 256 â”‚ 346.554 â”‚ 1.79466 â”‚ 16.6173 â”‚\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Like the shallow water model, it can be seen at grid size 64^3 that the GPU is beginning to be saturated as speedups rapidly increase. At grid sizes 128^3 and 256^3 we see the speedup stabilize to around 400 times.","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"(Image: incompressible_speedup)","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"For both float types, the benchmarked GPU times of the nonhydrostatic model starts to scale like its CPU times when grid size reaches 128^3.","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"(Image: incompressible_times)","category":"page"},{"location":"appendix/benchmarks/#Distributed-Shallow-Water-Model","page":"Performance benchmarks","title":"Distributed Shallow Water Model","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"By using MPI.jl the shallow water model can be run on multiple CPUs and multiple GPUs. For the benchmark results shown below, each rank is run on one CPU core and each uses a distinct GPU if applicable. ","category":"page"},{"location":"appendix/benchmarks/#Weak-Scaling-Shallow-Water-Model","page":"Performance benchmarks","title":"Weak Scaling Shallow Water Model","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Oceananigans v0.58.2\r\nJulia Version 1.6.0\r\nCommit f9720dc2eb (2021-03-24 12:55 UTC)\r\nPlatform Info:\r\n  OS: Linux (x86_64-pc-linux-gnu)\r\n  CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz\r\n  WORD_SIZE: 64\r\n  LIBM: libopenlibm\r\n  LLVM: libLLVM-11.0.1 (ORCJIT, broadwell)\r\nEnvironment:\r\n  EBVERSIONJULIA = 1.6.0\r\n  JULIA_DEPOT_PATH = :\r\n  EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0\r\n  EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel\r\n  JULIA_LOAD_PATH = :\r\n\r\n                                  Shallow water model weak scaling benchmark\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚          size â”‚    ranks â”‚        min â”‚     median â”‚       mean â”‚        max â”‚   memory â”‚ allocs â”‚ samples â”‚\r\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\r\nâ”‚   (4096, 256) â”‚   (1, 1) â”‚ 363.885 ms â”‚ 364.185 ms â”‚ 364.911 ms â”‚ 370.414 ms â”‚ 1.60 MiB â”‚   2774 â”‚      10 â”‚\r\nâ”‚   (4096, 512) â”‚   (1, 2) â”‚ 370.782 ms â”‚ 375.032 ms â”‚ 375.801 ms â”‚ 394.781 ms â”‚ 1.49 MiB â”‚   3116 â”‚      20 â”‚\r\nâ”‚  (4096, 1024) â”‚   (1, 4) â”‚ 369.648 ms â”‚ 369.973 ms â”‚ 371.613 ms â”‚ 399.526 ms â”‚ 1.49 MiB â”‚   3116 â”‚      40 â”‚\r\nâ”‚  (4096, 2048) â”‚   (1, 8) â”‚ 377.386 ms â”‚ 379.982 ms â”‚ 382.732 ms â”‚ 432.787 ms â”‚ 1.49 MiB â”‚   3116 â”‚      80 â”‚\r\nâ”‚  (4096, 4096) â”‚  (1, 16) â”‚ 388.336 ms â”‚ 395.473 ms â”‚ 400.079 ms â”‚ 496.598 ms â”‚ 1.49 MiB â”‚   3116 â”‚     160 â”‚\r\nâ”‚  (4096, 8192) â”‚  (1, 32) â”‚ 403.565 ms â”‚ 447.136 ms â”‚ 449.138 ms â”‚ 545.945 ms â”‚ 1.49 MiB â”‚   3116 â”‚     320 â”‚\r\nâ”‚ (4096, 16384) â”‚  (1, 64) â”‚ 397.965 ms â”‚ 441.627 ms â”‚ 453.465 ms â”‚ 619.493 ms â”‚ 1.49 MiB â”‚   3125 â”‚     640 â”‚\r\nâ”‚ (4096, 32768) â”‚ (1, 128) â”‚ 400.481 ms â”‚ 447.789 ms â”‚ 448.692 ms â”‚ 590.028 ms â”‚ 1.49 MiB â”‚   3125 â”‚    1280 â”‚\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\r\n\r\n                Shallow water model weak scaling speedup\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚          size â”‚    ranks â”‚ slowdown â”‚ efficiency â”‚   memory â”‚  allocs â”‚\r\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\r\nâ”‚   (4096, 256) â”‚   (1, 1) â”‚      1.0 â”‚        1.0 â”‚      1.0 â”‚     1.0 â”‚\r\nâ”‚   (4096, 512) â”‚   (1, 2) â”‚  1.02978 â”‚   0.971077 â”‚ 0.930602 â”‚ 1.12329 â”‚\r\nâ”‚  (4096, 1024) â”‚   (1, 4) â”‚  1.01589 â”‚   0.984355 â”‚ 0.930602 â”‚ 1.12329 â”‚\r\nâ”‚  (4096, 2048) â”‚   (1, 8) â”‚  1.04338 â”‚   0.958427 â”‚ 0.930602 â”‚ 1.12329 â”‚\r\nâ”‚  (4096, 4096) â”‚  (1, 16) â”‚  1.08591 â”‚   0.920886 â”‚ 0.930602 â”‚ 1.12329 â”‚\r\nâ”‚  (4096, 8192) â”‚  (1, 32) â”‚  1.22777 â”‚   0.814484 â”‚ 0.930602 â”‚ 1.12329 â”‚\r\nâ”‚ (4096, 16384) â”‚  (1, 64) â”‚  1.21264 â”‚   0.824644 â”‚ 0.930687 â”‚ 1.12653 â”‚\r\nâ”‚ (4096, 32768) â”‚ (1, 128) â”‚  1.22957 â”‚   0.813296 â”‚ 0.930687 â”‚ 1.12653 â”‚\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"As seen in the tables above and in the graph below, efficiency drops off to around 80% and remains as such from 16 to 128 ranks. GPUs are not used in this or the next benchmark setup. ","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"(Image: ws_shallow_water_efficiency)","category":"page"},{"location":"appendix/benchmarks/#Strong-Scaling-Shallow-Water-Model","page":"Performance benchmarks","title":"Strong Scaling Shallow Water Model","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Oceananigans v0.58.2\r\nJulia Version 1.6.0\r\nCommit f9720dc2eb (2021-03-24 12:55 UTC)\r\nPlatform Info:\r\n  OS: Linux (x86_64-pc-linux-gnu)\r\n  CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz\r\n  WORD_SIZE: 64\r\n  LIBM: libopenlibm\r\n  LLVM: libLLVM-11.0.1 (ORCJIT, broadwell)\r\nEnvironment:\r\n  EBVERSIONJULIA = 1.6.0\r\n  JULIA_DEPOT_PATH = :\r\n  EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0\r\n  EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel\r\n  JULIA_LOAD_PATH = :\r\n\r\n                                Shallow water model strong scaling benchmark\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚         size â”‚    ranks â”‚        min â”‚     median â”‚       mean â”‚        max â”‚   memory â”‚ allocs â”‚ samples â”‚\r\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\r\nâ”‚ (4096, 4096) â”‚   (1, 1) â”‚    5.694 s â”‚    5.694 s â”‚    5.694 s â”‚    5.694 s â”‚ 1.60 MiB â”‚   2804 â”‚       1 â”‚\r\nâ”‚ (4096, 4096) â”‚   (1, 2) â”‚    2.865 s â”‚    2.865 s â”‚    2.866 s â”‚    2.869 s â”‚ 1.49 MiB â”‚   3146 â”‚       4 â”‚\r\nâ”‚ (4096, 4096) â”‚   (1, 4) â”‚    1.435 s â”‚    1.437 s â”‚    1.441 s â”‚    1.475 s â”‚ 1.49 MiB â”‚   3146 â”‚      16 â”‚\r\nâ”‚ (4096, 4096) â”‚   (1, 8) â”‚ 732.711 ms â”‚ 736.394 ms â”‚ 738.930 ms â”‚ 776.773 ms â”‚ 1.49 MiB â”‚   3146 â”‚      56 â”‚\r\nâ”‚ (4096, 4096) â”‚  (1, 16) â”‚ 389.211 ms â”‚ 395.749 ms â”‚ 396.813 ms â”‚ 433.332 ms â”‚ 1.49 MiB â”‚   3116 â”‚     160 â”‚\r\nâ”‚ (4096, 4096) â”‚  (1, 32) â”‚ 197.894 ms â”‚ 219.211 ms â”‚ 236.780 ms â”‚ 367.188 ms â”‚ 1.49 MiB â”‚   3116 â”‚     320 â”‚\r\nâ”‚ (4096, 4096) â”‚  (1, 64) â”‚ 101.520 ms â”‚ 112.606 ms â”‚ 116.809 ms â”‚ 221.497 ms â”‚ 1.49 MiB â”‚   3125 â”‚     640 â”‚\r\nâ”‚ (4096, 4096) â”‚ (1, 128) â”‚  51.452 ms â”‚  60.256 ms â”‚  70.959 ms â”‚ 232.309 ms â”‚ 1.49 MiB â”‚   3125 â”‚    1280 â”‚\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\r\n\r\n              Shallow water model strong scaling speedup\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚         size â”‚    ranks â”‚ speedup â”‚ efficiency â”‚   memory â”‚  allocs â”‚\r\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\r\nâ”‚ (4096, 4096) â”‚   (1, 1) â”‚     1.0 â”‚        1.0 â”‚      1.0 â”‚     1.0 â”‚\r\nâ”‚ (4096, 4096) â”‚   (1, 2) â”‚ 1.98728 â”‚   0.993641 â”‚ 0.930621 â”‚ 1.12197 â”‚\r\nâ”‚ (4096, 4096) â”‚   (1, 4) â”‚ 3.96338 â”‚   0.990845 â”‚ 0.930621 â”‚ 1.12197 â”‚\r\nâ”‚ (4096, 4096) â”‚   (1, 8) â”‚ 7.73237 â”‚   0.966547 â”‚ 0.930621 â”‚ 1.12197 â”‚\r\nâ”‚ (4096, 4096) â”‚  (1, 16) â”‚ 14.3881 â”‚   0.899255 â”‚ 0.930336 â”‚ 1.11127 â”‚\r\nâ”‚ (4096, 4096) â”‚  (1, 32) â”‚ 25.9754 â”‚   0.811731 â”‚ 0.930336 â”‚ 1.11127 â”‚\r\nâ”‚ (4096, 4096) â”‚  (1, 64) â”‚ 50.5666 â”‚   0.790102 â”‚ 0.930421 â”‚ 1.11448 â”‚\r\nâ”‚ (4096, 4096) â”‚ (1, 128) â”‚ 94.4984 â”‚   0.738269 â”‚ 0.930421 â”‚ 1.11448 â”‚\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Slightly differing from the weak scaling results, efficiencies drop below 80% to around 74% at 128 ranks for the strong scaling distributed shallow water model benchmark. This is likely caused by the 128 CPU cores not being sufficiently saturated anymore by the constant 4096^2 grid size thus losing some efficiency overheads.","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"(Image: ss_shallow_water_efficiency)","category":"page"},{"location":"appendix/benchmarks/#Multi-GPU-Shallow-Water-Model","page":"Performance benchmarks","title":"Multi-GPU Shallow Water Model","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"While still a work in progress, it is possible to use CUDA-aware MPI to run the shallow water model on multiple GPUs. Though efficiencies may not be as high as multi-CPU, the multi-GPU architecture is still worthwhile when keeping in mind the baseline speedups generated by using a single GPU. Note that though it is possible for multiple ranks to share the use of a single GPU, efficiencies would significantly decrease and memory may be insufficient. The results below show up to three ranks each using a separate GPU.","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Julia Version 1.6.2\r\nCommit 1b93d53fc4 (2021-07-14 15:36 UTC)\r\nPlatform Info:\r\n  OS: Linux (powerpc64le-unknown-linux-gnu)\r\n  CPU: unknown\r\n  WORD_SIZE: 64\r\n  LIBM: libopenlibm\r\n  LLVM: libLLVM-11.0.1 (ORCJIT, pwr9)\r\nEnvironment:\r\n  JULIA_MPI_PATH = /home/software/spack/openmpi/3.1.4-nhjzelonyovxks5ydtrxehceqxsbf7ik\r\n  JULIA_CUDA_USE_BINARYBUILDER = false\r\n  JULIA_DEPOT_PATH = /nobackup/users/henryguo/projects/henry-test/Oceananigans.jl/benchmark/.julia\r\n  GPU: Tesla V100-SXM2-32GB\r\n  \r\n                              Shallow water model weak scaling benchmark\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚          size â”‚    ranks â”‚     min â”‚  median â”‚    mean â”‚     max â”‚   memory â”‚ allocs â”‚ samples â”‚\r\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\r\nâ”‚   (4096, 256) â”‚   (1, 1) â”‚ 2.702 msâ”‚ 2.728 msâ”‚ 2.801 msâ”‚ 3.446 msâ”‚ 2.03 MiB â”‚   5535 â”‚      10 â”‚\r\nâ”‚   (4096, 512) â”‚   (1, 2) â”‚ 3.510 msâ”‚ 3.612 msâ”‚ 4.287 msâ”‚16.546 msâ”‚ 2.03 MiB â”‚   5859 â”‚      20 â”‚\r\nâ”‚   (4096, 768) â”‚   (1, 3) â”‚ 3.553 msâ”‚ 3.653 msâ”‚ 5.195 msâ”‚39.152 msâ”‚ 2.03 MiB â”‚   5859 â”‚      30 â”‚\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\r\n\r\n                Shallow water model weak scaling speedup\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚          size â”‚    ranks â”‚ slowdown â”‚ efficiency â”‚   memory â”‚  allocs â”‚\r\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\r\nâ”‚   (4096, 256) â”‚   (1, 1) â”‚      1.0 â”‚        1.0 â”‚      1.0 â”‚     1.0 â”‚\r\nâ”‚   (4096, 512) â”‚   (1, 2) â”‚  1.32399 â”‚   0.755293 â”‚  1.00271 â”‚ 1.05854 â”‚\r\nâ”‚   (4096, 768) â”‚   (1, 3) â”‚  1.33901 â”‚   0.746818 â”‚  1.00271 â”‚ 1.05854 â”‚\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜","category":"page"},{"location":"appendix/benchmarks/#Distributed-Nonhydrostatic-Model","page":"Performance benchmarks","title":"Distributed Nonhydrostatic Model","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Similar to the distributed shallow water model benchmark results shown above, the distributed nonhydrostatic model was also benchmarked with the strong and weak scaling methods.","category":"page"},{"location":"appendix/benchmarks/#Weak-Scaling-Nonhydrostatic-Model","page":"Performance benchmarks","title":"Weak Scaling Nonhydrostatic Model","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Weak scaling efficiencies can be improved for the nonhydrostatic model.","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Oceananigans v0.60.1\r\nJulia Version 1.6.1\r\nCommit 6aaedecc44 (2021-04-23 05:59 UTC)\r\nPlatform Info:\r\n  OS: Linux (x86_64-pc-linux-gnu)\r\n  CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz\r\n  WORD_SIZE: 64\r\n  LIBM: libopenlibm\r\n  LLVM: libLLVM-11.0.1 (ORCJIT, broadwell)\r\nEnvironment:\r\n  JULIA_MPI_PATH = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Compiler/intel2020/openmpi/4.0.3\r\n  EBVERSIONJULIA = 1.6.1\r\n  JULIA_DEPOT_PATH = :\r\n  JULIA_MPI_BINARY = system\r\n  JULIA_MPI_LIBRARY = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Compiler/intel2020/openmpi/4.0.3/lib64/libmpi.so\r\n  EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1\r\n  JULIA_MPI_ABI = OpenMPI\r\n  EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1/easybuild/avx2-Core-julia-1.6.1-easybuild-devel\r\n  JULIA_LOAD_PATH = :\r\n  JULIA_MPIEXEC = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Compiler/intel2020/openmpi/4.0.3/bin/mpiexec\r\n\r\n                                    Nonhydrostatic model weak scaling benchmark\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚             size â”‚       ranks â”‚        min â”‚     median â”‚       mean â”‚        max â”‚   memory â”‚ allocs â”‚ samples â”‚\r\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\r\nâ”‚   (128, 128, 16) â”‚   (1, 1, 1) â”‚  33.568 ms â”‚  34.087 ms â”‚  34.173 ms â”‚  34.894 ms â”‚ 2.05 MiB â”‚   2762 â”‚      10 â”‚\r\nâ”‚   (128, 128, 32) â”‚   (1, 2, 1) â”‚  36.650 ms â”‚  37.161 ms â”‚  37.393 ms â”‚  42.411 ms â”‚ 1.99 MiB â”‚   3096 â”‚      20 â”‚\r\nâ”‚   (128, 128, 64) â”‚   (1, 4, 1) â”‚  41.861 ms â”‚  43.440 ms â”‚  46.176 ms â”‚  97.578 ms â”‚ 1.99 MiB â”‚   3136 â”‚      40 â”‚\r\nâ”‚  (128, 128, 128) â”‚   (1, 8, 1) â”‚  59.995 ms â”‚  64.110 ms â”‚  68.021 ms â”‚ 138.422 ms â”‚ 1.99 MiB â”‚   3216 â”‚      80 â”‚\r\nâ”‚  (128, 128, 256) â”‚  (1, 16, 1) â”‚  62.633 ms â”‚  71.266 ms â”‚  74.775 ms â”‚ 164.206 ms â”‚ 2.01 MiB â”‚   3376 â”‚     160 â”‚\r\nâ”‚  (128, 128, 512) â”‚  (1, 32, 1) â”‚ 108.253 ms â”‚ 135.611 ms â”‚ 139.384 ms â”‚ 225.336 ms â”‚ 2.04 MiB â”‚   3722 â”‚     320 â”‚\r\nâ”‚ (128, 128, 1024) â”‚  (1, 64, 1) â”‚ 138.504 ms â”‚ 181.043 ms â”‚ 186.386 ms â”‚ 335.170 ms â”‚ 2.12 MiB â”‚   4372 â”‚     640 â”‚\r\nâ”‚ (128, 128, 2048) â”‚ (1, 128, 1) â”‚ 218.592 ms â”‚ 285.293 ms â”‚ 290.989 ms â”‚ 434.878 ms â”‚ 2.39 MiB â”‚   5652 â”‚    1280 â”‚\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\r\n\r\n                   Nonhydrostatic model weak scaling speedup\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚             size â”‚       ranks â”‚  speedup â”‚ efficiency â”‚   memory â”‚  allocs â”‚\r\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\r\nâ”‚   (128, 128, 16) â”‚   (1, 1, 1) â”‚      1.0 â”‚        1.0 â”‚      1.0 â”‚     1.0 â”‚\r\nâ”‚   (128, 128, 32) â”‚   (1, 2, 1) â”‚ 0.917292 â”‚   0.917292 â”‚ 0.968543 â”‚ 1.12093 â”‚\r\nâ”‚   (128, 128, 64) â”‚   (1, 4, 1) â”‚ 0.784698 â”‚   0.784698 â”‚ 0.969719 â”‚ 1.13541 â”‚\r\nâ”‚  (128, 128, 128) â”‚   (1, 8, 1) â”‚ 0.531697 â”‚   0.531697 â”‚ 0.972279 â”‚ 1.16437 â”‚\r\nâ”‚  (128, 128, 256) â”‚  (1, 16, 1) â”‚ 0.478315 â”‚   0.478315 â”‚ 0.978143 â”‚  1.2223 â”‚\r\nâ”‚  (128, 128, 512) â”‚  (1, 32, 1) â”‚ 0.251361 â”‚   0.251361 â”‚ 0.992878 â”‚ 1.34757 â”‚\r\nâ”‚ (128, 128, 1024) â”‚  (1, 64, 1) â”‚ 0.188283 â”‚   0.188283 â”‚  1.03539 â”‚ 1.58291 â”‚\r\nâ”‚ (128, 128, 2048) â”‚ (1, 128, 1) â”‚ 0.119482 â”‚   0.119482 â”‚  1.16791 â”‚ 2.04634 â”‚\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"(Image: ws_nonhydrostatic_efficiency)","category":"page"},{"location":"appendix/benchmarks/#Strong-Scaling-Nonhydrostatic-Model","page":"Performance benchmarks","title":"Strong Scaling Nonhydrostatic Model","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Strong scaling efficiencies can also be improved for the nonhydrostatic model.","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Oceananigans v0.60.1\r\nJulia Version 1.6.1\r\nCommit 6aaedecc44 (2021-04-23 05:59 UTC)\r\nPlatform Info:\r\n  OS: Linux (x86_64-pc-linux-gnu)\r\n  CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz\r\n  WORD_SIZE: 64\r\n  LIBM: libopenlibm\r\n  LLVM: libLLVM-11.0.1 (ORCJIT, broadwell)\r\nEnvironment:\r\n  JULIA_MPI_PATH = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Compiler/intel2020/openmpi/4.0.3\r\n  EBVERSIONJULIA = 1.6.1\r\n  JULIA_DEPOT_PATH = :\r\n  JULIA_MPI_BINARY = system\r\n  JULIA_MPI_LIBRARY = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Compiler/intel2020/openmpi/4.0.3/lib64/libmpi.so\r\n  EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1\r\n  JULIA_MPI_ABI = OpenMPI\r\n  EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1/easybuild/avx2-Core-julia-1.6.1-easybuild-devel\r\n  JULIA_LOAD_PATH = :\r\n  JULIA_MPIEXEC = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Compiler/intel2020/openmpi/4.0.3/bin/mpiexec\r\n\r\n                                   Nonhydrostatic model strong scaling benchmark\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚            size â”‚       ranks â”‚        min â”‚     median â”‚       mean â”‚        max â”‚   memory â”‚ allocs â”‚ samples â”‚\r\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\r\nâ”‚ (256, 256, 256) â”‚   (1, 1, 1) â”‚    3.049 s â”‚    3.053 s â”‚    3.053 s â”‚    3.057 s â”‚ 2.05 MiB â”‚   2762 â”‚       2 â”‚\r\nâ”‚ (256, 256, 256) â”‚   (1, 2, 1) â”‚    1.609 s â”‚    1.610 s â”‚    1.611 s â”‚    1.620 s â”‚ 1.99 MiB â”‚   3096 â”‚       8 â”‚\r\nâ”‚ (256, 256, 256) â”‚   (1, 4, 1) â”‚ 814.290 ms â”‚ 817.305 ms â”‚ 818.685 ms â”‚ 833.792 ms â”‚ 1.99 MiB â”‚   3136 â”‚      28 â”‚\r\nâ”‚ (256, 256, 256) â”‚   (1, 8, 1) â”‚ 434.521 ms â”‚ 439.352 ms â”‚ 443.049 ms â”‚ 508.913 ms â”‚ 1.99 MiB â”‚   3216 â”‚      80 â”‚\r\nâ”‚ (256, 256, 256) â”‚  (1, 16, 1) â”‚ 251.632 ms â”‚ 272.364 ms â”‚ 277.555 ms â”‚ 370.059 ms â”‚ 2.01 MiB â”‚   3376 â”‚     160 â”‚\r\nâ”‚ (256, 256, 256) â”‚  (1, 32, 1) â”‚ 182.380 ms â”‚ 233.322 ms â”‚ 247.325 ms â”‚ 441.971 ms â”‚ 2.04 MiB â”‚   3696 â”‚     320 â”‚\r\nâ”‚ (256, 256, 256) â”‚  (1, 64, 1) â”‚ 119.546 ms â”‚ 178.933 ms â”‚ 204.036 ms â”‚ 564.097 ms â”‚ 2.12 MiB â”‚   4346 â”‚     640 â”‚\r\nâ”‚ (256, 256, 256) â”‚ (1, 128, 1) â”‚  73.802 ms â”‚ 120.147 ms â”‚ 136.395 ms â”‚ 378.697 ms â”‚ 2.39 MiB â”‚   5626 â”‚    1280 â”‚\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\r\n\r\n                 Nonhydrostatic model strong scaling speedup\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚            size â”‚       ranks â”‚ speedup â”‚ efficiency â”‚   memory â”‚  allocs â”‚\r\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\r\nâ”‚ (256, 256, 256) â”‚   (1, 1, 1) â”‚     1.0 â”‚        1.0 â”‚      1.0 â”‚     1.0 â”‚\r\nâ”‚ (256, 256, 256) â”‚   (1, 2, 1) â”‚ 1.89655 â”‚   0.948276 â”‚ 0.968543 â”‚ 1.12093 â”‚\r\nâ”‚ (256, 256, 256) â”‚   (1, 4, 1) â”‚ 3.73522 â”‚   0.933804 â”‚ 0.969719 â”‚ 1.13541 â”‚\r\nâ”‚ (256, 256, 256) â”‚   (1, 8, 1) â”‚ 6.94845 â”‚   0.868556 â”‚ 0.972279 â”‚ 1.16437 â”‚\r\nâ”‚ (256, 256, 256) â”‚  (1, 16, 1) â”‚ 11.2086 â”‚   0.700536 â”‚ 0.978143 â”‚  1.2223 â”‚\r\nâ”‚ (256, 256, 256) â”‚  (1, 32, 1) â”‚ 13.0841 â”‚   0.408879 â”‚ 0.992685 â”‚ 1.33816 â”‚\r\nâ”‚ (256, 256, 256) â”‚  (1, 64, 1) â”‚ 17.0612 â”‚   0.266582 â”‚  1.03519 â”‚  1.5735 â”‚\r\nâ”‚ (256, 256, 256) â”‚ (1, 128, 1) â”‚  25.409 â”‚   0.198508 â”‚  1.16772 â”‚ 2.03693 â”‚\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"(Image: ss_nonhydrostatic_efficiency)","category":"page"},{"location":"appendix/benchmarks/#Multithreading","page":"Performance benchmarks","title":"Multithreading","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Oceananigans can also achieve parallelism via multithreading. Though its efficiencies are less than that of the MPI distributed architectures, its simple setup still makes it a viable option for achieving speedups on simple systems.","category":"page"},{"location":"appendix/benchmarks/#Weak-Scaling-Multithreaded-Shallow-Water-Model","page":"Performance benchmarks","title":"Weak Scaling Multithreaded Shallow Water Model","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"The initial drop and then rise in efficiencies going from 1 to 2 to 4 threads is likely caused by the 2 threads being automatically allocated onto only one physical CPU core. Though one physical CPU core may contain 2 logical cores each capable of running a separate thread, having 2 threads run on one core will still reduce efficiencies as many resources such as caches and buses must be shared by both threads. Note that there are as many CPU cores allocated as the maximum number of threads.","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Oceananigans v0.58.9\r\nJulia Version 1.6.0\r\nCommit f9720dc2eb (2021-03-24 12:55 UTC)\r\nPlatform Info:\r\n  OS: Linux (x86_64-pc-linux-gnu)\r\n  CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz\r\n  WORD_SIZE: 64\r\n  LIBM: libopenlibm\r\n  LLVM: libLLVM-11.0.1 (ORCJIT, broadwell)\r\nEnvironment:\r\n  EBVERSIONJULIA = 1.6.0\r\n  JULIA_DEPOT_PATH = :\r\n  EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0\r\n  EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel\r\n  JULIA_LOAD_PATH = :\r\n\r\n                  Shallow water model weak scaling with multithreading benchmark\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚          size â”‚ threads â”‚     min â”‚  median â”‚    mean â”‚     max â”‚    memory â”‚  allocs â”‚ samples â”‚\r\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\r\nâ”‚   (8192, 512) â”‚       1 â”‚ 1.458 s â”‚ 1.458 s â”‚ 1.458 s â”‚ 1.458 s â”‚  1.37 MiB â”‚    2318 â”‚       4 â”‚\r\nâ”‚  (8192, 1024) â”‚       2 â”‚ 2.925 s â”‚ 2.989 s â”‚ 2.989 s â”‚ 3.052 s â”‚ 18.06 MiB â”‚ 1076944 â”‚       2 â”‚\r\nâ”‚  (8192, 2048) â”‚       4 â”‚ 2.296 s â”‚ 2.381 s â”‚ 2.397 s â”‚ 2.515 s â”‚ 13.60 MiB â”‚  760190 â”‚       3 â”‚\r\nâ”‚  (8192, 4096) â”‚       8 â”‚ 2.347 s â”‚ 2.369 s â”‚ 2.377 s â”‚ 2.415 s â”‚ 16.36 MiB â”‚  891860 â”‚       3 â”‚\r\nâ”‚  (8192, 8192) â”‚      16 â”‚ 2.407 s â”‚ 2.548 s â”‚ 2.517 s â”‚ 2.595 s â”‚ 17.44 MiB â”‚  863941 â”‚       3 â”‚\r\nâ”‚ (8192, 16384) â”‚      32 â”‚ 3.023 s â”‚ 3.069 s â”‚ 3.069 s â”‚ 3.115 s â”‚ 23.03 MiB â”‚ 1034063 â”‚       2 â”‚\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\r\n\r\n        Shallow water model weak multithreading scaling speedup\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚          size â”‚ threads â”‚ slowdown â”‚ efficiency â”‚  memory â”‚  allocs â”‚\r\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\r\nâ”‚   (8192, 512) â”‚       1 â”‚      1.0 â”‚        1.0 â”‚     1.0 â”‚     1.0 â”‚\r\nâ”‚  (8192, 1024) â”‚       2 â”‚  2.04972 â”‚   0.487872 â”‚ 13.2156 â”‚ 464.601 â”‚\r\nâ”‚  (8192, 2048) â”‚       4 â”‚  1.63302 â”‚   0.612363 â”‚ 9.95278 â”‚ 327.951 â”‚\r\nâ”‚  (8192, 4096) â”‚       8 â”‚  1.62507 â”‚   0.615359 â”‚ 11.9706 â”‚ 384.754 â”‚\r\nâ”‚  (8192, 8192) â”‚      16 â”‚  1.74747 â”‚   0.572257 â”‚  12.755 â”‚  372.71 â”‚\r\nâ”‚ (8192, 16384) â”‚      32 â”‚  2.10486 â”‚    0.47509 â”‚  16.846 â”‚ 446.101 â”‚\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜","category":"page"},{"location":"appendix/benchmarks/#Strong-Scaling-Multithreaded-Nonhydrostatic-Model","page":"Performance benchmarks","title":"Strong Scaling Multithreaded Nonhydrostatic Model","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"The notable and continuous decrease in efficiencies for the strong scaling nonhydrostatic model is likely caused by the 256^3 grid not sufficiently saturating 32 threads running on 32 CPUs. At the time this benchmark was produced, multithreading for both nonhydrostatic and shallow water models is still an active area of improvement. Please use the appropriate scripts found in benchmarks to obtain more recent and hopefully ameliorated benchmark results.","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Oceananigans v0.58.9\r\nJulia Version 1.6.1\r\nCommit 6aaedecc44 (2021-04-23 05:59 UTC)\r\nPlatform Info:\r\n  OS: Linux (x86_64-pc-linux-gnu)\r\n  CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz\r\n  WORD_SIZE: 64\r\n  LIBM: libopenlibm\r\n  LLVM: libLLVM-11.0.1 (ORCJIT, broadwell)\r\nEnvironment:\r\n  EBVERSIONJULIA = 1.6.1\r\n  JULIA_DEPOT_PATH = :\r\n  EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1\r\n  EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1/easybuild/avx2-Core-julia-1.6.1-easybuild-devel\r\n  JULIA_LOAD_PATH = :\r\n\r\n                                     Multithreading benchmarks\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚ size â”‚ threads â”‚        min â”‚     median â”‚       mean â”‚        max â”‚   memory â”‚ allocs â”‚ samples â”‚\r\nâ”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\r\nâ”‚  256 â”‚       1 â”‚    2.496 s â”‚    2.637 s â”‚    2.637 s â”‚    2.777 s â”‚ 1.70 MiB â”‚   2251 â”‚       2 â”‚\r\nâ”‚  256 â”‚       2 â”‚    2.385 s â”‚    2.618 s â”‚    2.618 s â”‚    2.851 s â”‚ 7.03 MiB â”‚ 342397 â”‚       2 â”‚\r\nâ”‚  256 â”‚       4 â”‚    1.320 s â”‚    1.321 s â”‚    1.333 s â”‚    1.371 s â”‚ 3.69 MiB â”‚ 113120 â”‚       4 â”‚\r\nâ”‚  256 â”‚       8 â”‚ 850.438 ms â”‚ 855.292 ms â”‚ 855.952 ms â”‚ 861.966 ms â”‚ 3.31 MiB â”‚  65709 â”‚       6 â”‚\r\nâ”‚  256 â”‚      16 â”‚ 642.225 ms â”‚ 645.458 ms â”‚ 648.685 ms â”‚ 674.259 ms â”‚ 3.60 MiB â”‚  40992 â”‚       8 â”‚\r\nâ”‚  256 â”‚      32 â”‚ 680.938 ms â”‚ 694.376 ms â”‚ 701.272 ms â”‚ 746.599 ms â”‚ 4.88 MiB â”‚  36729 â”‚       8 â”‚\r\nâ””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\r\n\r\n     Nonhydrostatic Strong Scaling Multithreading speedup\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚ size â”‚ threads â”‚ slowdown â”‚ efficiency â”‚  memory â”‚  allocs â”‚\r\nâ”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\r\nâ”‚  256 â”‚       1 â”‚      1.0 â”‚        1.0 â”‚     1.0 â”‚     1.0 â”‚\r\nâ”‚  256 â”‚       2 â”‚ 0.992966 â”‚   0.503542 â”‚ 4.14014 â”‚ 152.109 â”‚\r\nâ”‚  256 â”‚       4 â”‚ 0.501089 â”‚   0.498913 â”‚ 2.17724 â”‚ 50.2532 â”‚\r\nâ”‚  256 â”‚       8 â”‚ 0.324366 â”‚   0.385367 â”‚ 1.94899 â”‚  29.191 â”‚\r\nâ”‚  256 â”‚      16 â”‚ 0.244788 â”‚   0.255323 â”‚ 2.12262 â”‚ 18.2106 â”‚\r\nâ”‚  256 â”‚      32 â”‚ 0.263339 â”‚   0.118668 â”‚ 2.87624 â”‚ 16.3167 â”‚\r\nâ””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜","category":"page"},{"location":"appendix/benchmarks/#Tracers","page":"Performance benchmarks","title":"Tracers","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"This benchmark tests the performance impacts of running with various amounts of active and passive tracers and compares the difference in speedup going from CPU to GPU. Number of tracers are listed in the tracers column as (active, passive). ","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Oceananigans v0.58.1\r\nJulia Version 1.6.0\r\nCommit f9720dc2eb (2021-03-24 12:55 UTC)\r\nPlatform Info:\r\n  OS: Linux (x86_64-pc-linux-gnu)\r\n  CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz\r\n  WORD_SIZE: 64\r\n  LIBM: libopenlibm\r\n  LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake)\r\nEnvironment:\r\n  EBVERSIONJULIA = 1.6.0\r\n  JULIA_DEPOT_PATH = :\r\n  EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0\r\n  EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel\r\n  JULIA_LOAD_PATH = :\r\n  GPU: Tesla V100-SXM2-32GB\r\n\r\n                                       Arbitrary tracers benchmarks\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚ Architectures â”‚ tracers â”‚       min â”‚    median â”‚      mean â”‚       max â”‚     memory â”‚ allocs â”‚ samples â”‚\r\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\r\nâ”‚           CPU â”‚  (0, 0) â”‚   1.439 s â”‚   1.440 s â”‚   1.440 s â”‚   1.441 s â”‚ 908.03 KiB â”‚   1656 â”‚       4 â”‚\r\nâ”‚           CPU â”‚  (0, 1) â”‚   1.539 s â”‚   1.574 s â”‚   1.575 s â”‚   1.613 s â”‚   1.24 MiB â”‚   1942 â”‚       4 â”‚\r\nâ”‚           CPU â”‚  (0, 2) â”‚   1.668 s â”‚   1.669 s â”‚   1.670 s â”‚   1.671 s â”‚   1.76 MiB â”‚   2291 â”‚       3 â”‚\r\nâ”‚           CPU â”‚  (1, 0) â”‚   1.527 s â”‚   1.532 s â”‚   1.532 s â”‚   1.536 s â”‚   1.24 MiB â”‚   1942 â”‚       4 â”‚\r\nâ”‚           CPU â”‚  (2, 0) â”‚   1.690 s â”‚   1.697 s â”‚   1.695 s â”‚   1.698 s â”‚   1.77 MiB â”‚   2301 â”‚       3 â”‚\r\nâ”‚           CPU â”‚  (2, 3) â”‚   2.234 s â”‚   2.239 s â”‚   2.241 s â”‚   2.251 s â”‚   3.59 MiB â”‚   3928 â”‚       3 â”‚\r\nâ”‚           CPU â”‚  (2, 5) â”‚   2.755 s â”‚   2.838 s â”‚   2.838 s â”‚   2.921 s â”‚   5.18 MiB â”‚   4908 â”‚       2 â”‚\r\nâ”‚           CPU â”‚ (2, 10) â”‚   3.588 s â”‚   3.748 s â”‚   3.748 s â”‚   3.908 s â”‚  10.39 MiB â”‚   7682 â”‚       2 â”‚\r\nâ”‚           GPU â”‚  (0, 0) â”‚  9.702 ms â”‚ 12.755 ms â”‚ 12.458 ms â”‚ 12.894 ms â”‚   1.59 MiB â”‚  12321 â”‚      10 â”‚\r\nâ”‚           GPU â”‚  (0, 1) â”‚ 13.863 ms â”‚ 13.956 ms â”‚ 14.184 ms â”‚ 16.297 ms â”‚   2.20 MiB â”‚  14294 â”‚      10 â”‚\r\nâ”‚           GPU â”‚  (0, 2) â”‚ 15.166 ms â”‚ 15.230 ms â”‚ 15.700 ms â”‚ 19.893 ms â”‚   2.93 MiB â”‚  15967 â”‚      10 â”‚\r\nâ”‚           GPU â”‚  (1, 0) â”‚ 13.740 ms â”‚ 13.838 ms â”‚ 14.740 ms â”‚ 22.940 ms â”‚   2.20 MiB â”‚  14278 â”‚      10 â”‚\r\nâ”‚           GPU â”‚  (2, 0) â”‚ 15.103 ms â”‚ 15.199 ms â”‚ 16.265 ms â”‚ 25.906 ms â”‚   2.93 MiB â”‚  15913 â”‚      10 â”‚\r\nâ”‚           GPU â”‚  (2, 3) â”‚ 13.981 ms â”‚ 18.856 ms â”‚ 18.520 ms â”‚ 20.519 ms â”‚   5.56 MiB â”‚  17974 â”‚      10 â”‚\r\nâ”‚           GPU â”‚  (2, 5) â”‚ 15.824 ms â”‚ 21.211 ms â”‚ 21.064 ms â”‚ 24.897 ms â”‚   7.86 MiB â”‚  23938 â”‚      10 â”‚\r\nâ”‚           GPU â”‚ (2, 10) â”‚ 22.085 ms â”‚ 27.236 ms â”‚ 28.231 ms â”‚ 38.295 ms â”‚  15.02 MiB â”‚  31086 â”‚      10 â”‚\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\r\n\r\n  Arbitrary tracers CPU to GPU speedup\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚ tracers â”‚ speedup â”‚  memory â”‚  allocs â”‚\r\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\r\nâ”‚  (0, 0) â”‚ 112.881 â”‚ 1.78792 â”‚ 7.44022 â”‚\r\nâ”‚  (0, 1) â”‚ 112.761 â”‚ 1.77743 â”‚ 7.36045 â”‚\r\nâ”‚  (0, 2) â”‚ 109.618 â”‚  1.6627 â”‚ 6.96945 â”‚\r\nâ”‚  (1, 0) â”‚ 110.717 â”‚ 1.77723 â”‚ 7.35221 â”‚\r\nâ”‚  (2, 0) â”‚ 111.678 â”‚ 1.66267 â”‚ 6.91569 â”‚\r\nâ”‚  (2, 3) â”‚ 118.737 â”‚ 1.55043 â”‚ 4.57587 â”‚\r\nâ”‚  (2, 5) â”‚ 133.803 â”‚  1.5155 â”‚ 4.87734 â”‚\r\nâ”‚ (2, 10) â”‚ 137.615 â”‚ 1.44535 â”‚  4.0466 â”‚\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\r\n\r\n       Arbitrary tracers relative performance (CPU)\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚ Architectures â”‚ tracers â”‚ slowdown â”‚  memory â”‚  allocs â”‚\r\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\r\nâ”‚           CPU â”‚  (0, 0) â”‚      1.0 â”‚     1.0 â”‚     1.0 â”‚\r\nâ”‚           CPU â”‚  (0, 1) â”‚  1.09293 â”‚ 1.39873 â”‚ 1.17271 â”‚\r\nâ”‚           CPU â”‚  (0, 2) â”‚  1.15948 â”‚ 1.99019 â”‚ 1.38345 â”‚\r\nâ”‚           CPU â”‚  (1, 0) â”‚  1.06409 â”‚ 1.39873 â”‚ 1.17271 â”‚\r\nâ”‚           CPU â”‚  (2, 0) â”‚  1.17887 â”‚ 1.99054 â”‚ 1.38949 â”‚\r\nâ”‚           CPU â”‚  (2, 3) â”‚  1.55493 â”‚ 4.04677 â”‚ 2.37198 â”‚\r\nâ”‚           CPU â”‚  (2, 5) â”‚  1.97115 â”‚ 5.84537 â”‚ 2.96377 â”‚\r\nâ”‚           CPU â”‚ (2, 10) â”‚   2.6031 â”‚ 11.7179 â”‚ 4.63889 â”‚\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\r\n\r\n       Arbitrary tracers relative performance (GPU)\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚ Architectures â”‚ tracers â”‚ slowdown â”‚  memory â”‚  allocs â”‚\r\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\r\nâ”‚           GPU â”‚  (0, 0) â”‚      1.0 â”‚     1.0 â”‚     1.0 â”‚\r\nâ”‚           GPU â”‚  (0, 1) â”‚   1.0941 â”‚ 1.39053 â”‚ 1.16013 â”‚\r\nâ”‚           GPU â”‚  (0, 2) â”‚  1.19399 â”‚ 1.85081 â”‚ 1.29592 â”‚\r\nâ”‚           GPU â”‚  (1, 0) â”‚  1.08489 â”‚ 1.39037 â”‚ 1.15883 â”‚\r\nâ”‚           GPU â”‚  (2, 0) â”‚  1.19157 â”‚ 1.85109 â”‚ 1.29153 â”‚\r\nâ”‚           GPU â”‚  (2, 3) â”‚  1.47824 â”‚ 3.50924 â”‚ 1.45881 â”‚\r\nâ”‚           GPU â”‚  (2, 5) â”‚  1.66293 â”‚ 4.95474 â”‚ 1.94286 â”‚\r\nâ”‚           GPU â”‚ (2, 10) â”‚  2.13524 â”‚ 9.47276 â”‚ 2.52301 â”‚\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜","category":"page"},{"location":"appendix/benchmarks/#Turbulence-closures","page":"Performance benchmarks","title":"Turbulence closures","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"This benchmark tests the performance impacts of various turbulent diffusivity closures and large eddy simulation (LES) models as well as how much speedup they experience going from CPU to GPU.","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Oceananigans v0.58.1\r\nJulia Version 1.6.0\r\nCommit f9720dc2eb (2021-03-24 12:55 UTC)\r\nPlatform Info:\r\n  OS: Linux (x86_64-pc-linux-gnu)\r\n  CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz\r\n  WORD_SIZE: 64\r\n  LIBM: libopenlibm\r\n  LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake)\r\nEnvironment:\r\n  EBVERSIONJULIA = 1.6.0\r\n  JULIA_DEPOT_PATH = :\r\n  EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0\r\n  EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel\r\n  JULIA_LOAD_PATH = :\r\n  GPU: Tesla V100-SXM2-32GB\r\n\r\n                                                  Turbulence closure benchmarks\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚ Architectures â”‚                         Closures â”‚       min â”‚    median â”‚      mean â”‚       max â”‚   memory â”‚ allocs â”‚ samples â”‚\r\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\r\nâ”‚           CPU â”‚ AnisotropicBiharmonicDiffusivity â”‚   3.634 s â”‚   3.637 s â”‚   3.637 s â”‚   3.639 s â”‚ 1.77 MiB â”‚   2316 â”‚       2 â”‚\r\nâ”‚           CPU â”‚           AnisotropicDiffusivity â”‚   2.045 s â”‚   2.052 s â”‚   2.059 s â”‚   2.079 s â”‚ 1.77 MiB â”‚   2316 â”‚       3 â”‚\r\nâ”‚           CPU â”‚    AnisotropicMinimumDissipation â”‚   3.240 s â”‚   3.240 s â”‚   3.240 s â”‚   3.241 s â”‚ 2.09 MiB â”‚   2763 â”‚       2 â”‚\r\nâ”‚           CPU â”‚             IsotropicDiffusivity â”‚   2.342 s â”‚   2.344 s â”‚   2.344 s â”‚   2.345 s â”‚ 1.77 MiB â”‚   2316 â”‚       3 â”‚\r\nâ”‚           CPU â”‚                 SmagorinskyLilly â”‚   3.501 s â”‚   3.504 s â”‚   3.504 s â”‚   3.507 s â”‚ 2.03 MiB â”‚   2486 â”‚       2 â”‚\r\nâ”‚           CPU â”‚              TwoDimensionalLeith â”‚   4.813 s â”‚   4.820 s â”‚   4.820 s â”‚   4.828 s â”‚ 1.88 MiB â”‚   2481 â”‚       2 â”‚\r\nâ”‚           GPU â”‚ AnisotropicBiharmonicDiffusivity â”‚ 24.699 ms â”‚ 24.837 ms â”‚ 26.946 ms â”‚ 46.029 ms â”‚ 3.16 MiB â”‚  29911 â”‚      10 â”‚\r\nâ”‚           GPU â”‚           AnisotropicDiffusivity â”‚ 16.115 ms â”‚ 16.184 ms â”‚ 16.454 ms â”‚ 18.978 ms â”‚ 2.97 MiB â”‚  17169 â”‚      10 â”‚\r\nâ”‚           GPU â”‚    AnisotropicMinimumDissipation â”‚ 15.858 ms â”‚ 25.856 ms â”‚ 24.874 ms â”‚ 26.014 ms â”‚ 3.57 MiB â”‚  24574 â”‚      10 â”‚\r\nâ”‚           GPU â”‚             IsotropicDiffusivity â”‚ 14.442 ms â”‚ 17.415 ms â”‚ 17.134 ms â”‚ 17.513 ms â”‚ 2.99 MiB â”‚  19135 â”‚      10 â”‚\r\nâ”‚           GPU â”‚                 SmagorinskyLilly â”‚ 16.315 ms â”‚ 23.969 ms â”‚ 23.213 ms â”‚ 24.059 ms â”‚ 3.86 MiB â”‚  24514 â”‚      10 â”‚\r\nâ”‚           GPU â”‚              TwoDimensionalLeith â”‚ 34.470 ms â”‚ 34.628 ms â”‚ 35.535 ms â”‚ 43.798 ms â”‚ 3.56 MiB â”‚  45291 â”‚      10 â”‚\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\r\n\r\n              Turbulence closure CPU to GPU speedup\r\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\nâ”‚                         Closures â”‚ speedup â”‚  memory â”‚  allocs â”‚\r\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\r\nâ”‚ AnisotropicBiharmonicDiffusivity â”‚ 146.428 â”‚ 1.78781 â”‚ 12.9149 â”‚\r\nâ”‚           AnisotropicDiffusivity â”‚ 126.804 â”‚ 1.67787 â”‚ 7.41321 â”‚\r\nâ”‚    AnisotropicMinimumDissipation â”‚ 125.324 â”‚ 1.70856 â”‚ 8.89396 â”‚\r\nâ”‚             IsotropicDiffusivity â”‚ 134.607 â”‚ 1.69269 â”‚ 8.26209 â”‚\r\nâ”‚                 SmagorinskyLilly â”‚ 146.187 â”‚ 1.89602 â”‚ 9.86082 â”‚\r\nâ”‚              TwoDimensionalLeith â”‚ 139.196 â”‚ 1.89218 â”‚ 18.2551 â”‚\r\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\r\n","category":"page"},{"location":"model_setup/setting_initial_conditions/#Setting-initial-conditions","page":"Setting initial conditions","title":"Setting initial conditions","text":"","category":"section"},{"location":"model_setup/setting_initial_conditions/","page":"Setting initial conditions","title":"Setting initial conditions","text":"Initial conditions are imposed after model construction. This can be easily done using the the set! function, which allows the setting of initial conditions using constant values, arrays, or functions.","category":"page"},{"location":"model_setup/setting_initial_conditions/","page":"Setting initial conditions","title":"Setting initial conditions","text":"DocTestSetup = quote\n    using Oceananigans\nend","category":"page"},{"location":"model_setup/setting_initial_conditions/","page":"Setting initial conditions","title":"Setting initial conditions","text":"julia> grid = RectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1));\n\njulia> model = NonhydrostaticModel(grid=grid);\n\njulia> set!(model, u=0.1, v=1.5)","category":"page"},{"location":"model_setup/setting_initial_conditions/","page":"Setting initial conditions","title":"Setting initial conditions","text":"julia> grid = RectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1));\n\njulia> model = NonhydrostaticModel(grid=grid, buoyancy=SeawaterBuoyancy(), tracers=(:T, :S));\n\njulia> âˆ‚Tâˆ‚z = 0.01;\n\njulia> Ïµ(Ïƒ) = Ïƒ * randn();\n\njulia> Tâ‚€(x, y, z) = âˆ‚Tâˆ‚z * z + Ïµ(1e-8);\n\njulia> set!(model, T=Tâ‚€)","category":"page"},{"location":"model_setup/setting_initial_conditions/","page":"Setting initial conditions","title":"Setting initial conditions","text":"tip: Divergence-free velocity fields\nNote that as part of the time-stepping algorithm, the velocity field is made divergence-free at every time step. So if a model is not initialized with a divergence-free velocity field, it may change on the first time step. As a result tracers may not be conserved up to machine precision at the first time step.","category":"page"},{"location":"model_setup/tracers/#Tracers","page":"Tracers","title":"Tracers","text":"","category":"section"},{"location":"model_setup/tracers/","page":"Tracers","title":"Tracers","text":"The tracers to be advected around can be specified via a list of symbols. By default the model doesn't evolve any tracers.","category":"page"},{"location":"model_setup/tracers/","page":"Tracers","title":"Tracers","text":"DocTestSetup = quote\n    using Oceananigans\nend","category":"page"},{"location":"model_setup/tracers/","page":"Tracers","title":"Tracers","text":"julia> grid = RectilinearGrid(size=(64, 64, 64), extent=(1, 1, 1));\n\njulia> model = NonhydrostaticModel(; grid)\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 64Ã—64Ã—64 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ timestepper: QuasiAdamsBashforth2TimeStepper\nâ”œâ”€â”€ tracers: ()\nâ”œâ”€â”€ closure: Nothing\nâ”œâ”€â”€ buoyancy: Nothing\nâ””â”€â”€ coriolis: Nothing","category":"page"},{"location":"model_setup/tracers/","page":"Tracers","title":"Tracers","text":"But tracers can be added with the tracers keyword. For example, to add conservative temperature T and absolute salinity S:","category":"page"},{"location":"model_setup/tracers/","page":"Tracers","title":"Tracers","text":"julia> grid = RectilinearGrid(size=(64, 64, 64), extent=(1, 1, 1));\n\njulia> model = NonhydrostaticModel(; grid, tracers=(:T, :S))\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 64Ã—64Ã—64 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ timestepper: QuasiAdamsBashforth2TimeStepper\nâ”œâ”€â”€ tracers: (T, S)\nâ”œâ”€â”€ closure: Nothing\nâ”œâ”€â”€ buoyancy: Nothing\nâ””â”€â”€ coriolis: Nothing","category":"page"},{"location":"model_setup/tracers/","page":"Tracers","title":"Tracers","text":"whose fields can be accessed via model.tracers.T and model.tracers.S.","category":"page"},{"location":"model_setup/tracers/","page":"Tracers","title":"Tracers","text":"julia> model.tracers.T\n64Ã—64Ã—64 Field{Center, Center, Center} on RectilinearGrid on CPU\nâ”œâ”€â”€ grid: 64Ã—64Ã—64 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ boundary conditions: FieldBoundaryConditions\nâ”‚   â””â”€â”€ west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux\nâ””â”€â”€ data: 70Ã—70Ã—70 OffsetArray(::Array{Float64, 3}, -2:67, -2:67, -2:67) with eltype Float64 with indices -2:67Ã—-2:67Ã—-2:67\n    â””â”€â”€ max=0.0, min=0.0, mean=0.0\n\njulia> model.tracers.S\n64Ã—64Ã—64 Field{Center, Center, Center} on RectilinearGrid on CPU\nâ”œâ”€â”€ grid: 64Ã—64Ã—64 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ boundary conditions: FieldBoundaryConditions\nâ”‚   â””â”€â”€ west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux\nâ””â”€â”€ data: 70Ã—70Ã—70 OffsetArray(::Array{Float64, 3}, -2:67, -2:67, -2:67) with eltype Float64 with indices -2:67Ã—-2:67Ã—-2:67\n    â””â”€â”€ max=0.0, min=0.0, mean=0.0","category":"page"},{"location":"model_setup/tracers/","page":"Tracers","title":"Tracers","text":"An arbitrary number of tracers may be simulated. For example, to simulate C_1, COâ‚‚, and nitrogen as additional passive tracers,","category":"page"},{"location":"model_setup/tracers/","page":"Tracers","title":"Tracers","text":"julia> model = NonhydrostaticModel(; grid, tracers=(:T, :S, :Câ‚, :COâ‚‚, :nitrogen))\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 64Ã—64Ã—64 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ timestepper: QuasiAdamsBashforth2TimeStepper\nâ”œâ”€â”€ tracers: (T, S, Câ‚, COâ‚‚, nitrogen)\nâ”œâ”€â”€ closure: Nothing\nâ”œâ”€â”€ buoyancy: Nothing\nâ””â”€â”€ coriolis: Nothing","category":"page"},{"location":"model_setup/tracers/","page":"Tracers","title":"Tracers","text":"info: Active versus passive tracers\nAn active tracer is a tracer whose distribution affects the evolution of momentum and other tracers. Typical ocean models evolve conservative temperature and absolute salinity as active tracers, which effect momentum through buoyancy forces. Passive tracers are \"passive\" in the sense that their distribution does not affect the evolution of other tracers or flow quantities.","category":"page"},{"location":"model_setup/lagrangian_particles/#Lagrangian-particle-tracking","page":"Lagrangian particles","title":"Lagrangian particle tracking","text":"","category":"section"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"Models can keep track of the location and properties of neutrally buoyant particles. Particles are advected with the flow field using forward Euler time-stepping at every model iteration.","category":"page"},{"location":"model_setup/lagrangian_particles/#Simple-particles","page":"Lagrangian particles","title":"Simple particles","text":"","category":"section"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"If you just need to keep of particle locations (x y z) then you can construct some Lagrangian particles using the regular LagrangianParticles constructor","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"DocTestSetup = quote\n    using Oceananigans\nend","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"grid = RectilinearGrid(size=(10, 10, 10), extent=(1, 1, 1));\n\nn_particles = 10;\n\nxâ‚€ = zeros(n_particles);\n\nyâ‚€ = rand(n_particles);\n\nzâ‚€ = -0.5 * ones(n_particles);\n\nlagrangian_particles = LagrangianParticles(x=xâ‚€, y=yâ‚€, z=zâ‚€)\n\n# output\n10 LagrangianParticles with eltype Particle:\nâ”œâ”€â”€ 3 properties: (:x, :y, :z)\nâ”œâ”€â”€ particle-wall restitution coefficient: 1.0\nâ”œâ”€â”€ 0 tracked fields: ()\nâ””â”€â”€ dynamics: no_dynamics","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"then pass it to a model constructor","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"model = NonhydrostaticModel(grid=grid, particles=lagrangian_particles)\n\n# output\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 10Ã—10Ã—10 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ timestepper: QuasiAdamsBashforth2TimeStepper\nâ”œâ”€â”€ tracers: ()\nâ”œâ”€â”€ closure: Nothing\nâ”œâ”€â”€ buoyancy: Nothing\nâ”œâ”€â”€ coriolis: Nothing\nâ””â”€â”€ particles: 10 LagrangianParticles with eltype Particle and properties (:x, :y, :z)","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"warn: Lagrangian particles on GPUs\nRemember to use CuArray instead of regular Array when storing particle locations and properties on the GPU.","category":"page"},{"location":"model_setup/lagrangian_particles/#Custom-particles","page":"Lagrangian particles","title":"Custom particles","text":"","category":"section"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"If you want to keep track of custom properties, such as the species or DNA of a Lagrangian particle representing a microbe in an agent-based model, then you can create your own custom particle type and pass a StructArray to the LagrangianParticles constructor.","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"using Oceananigans\nusing StructArrays\n\nstruct LagrangianMicrobe{T, S, D}\n    x :: T\n    y :: T\n    z :: T\n    species :: S\n    dna :: D\nend\n\nn_particles = 3;\n\nxâ‚€ = zeros(n_particles);\n\nyâ‚€ = rand(n_particles);\n\nzâ‚€ = -0.5 * ones(n_particles);\n\nspecies = [:rock, :paper, :scissors]\n\ndna = [\"TATACCCC\", \"CCTAGGAC\", \"CGATTTAA\"]\n\nparticles = StructArray{LagrangianMicrobe}((xâ‚€, yâ‚€, zâ‚€, species, dna));\n\nlagrangian_particles = LagrangianParticles(particles)\n\n# output\n3 LagrangianParticles with eltype LagrangianMicrobe:\nâ”œâ”€â”€ 5 properties: (:x, :y, :z, :species, :dna)\nâ”œâ”€â”€ particle-wall restitution coefficient: 1.0\nâ”œâ”€â”€ 0 tracked fields: ()\nâ””â”€â”€ dynamics: no_dynamics","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"warn: Custom properties on GPUs\nNot all data types can be passed to GPU kernels. If you intend to advect particles on the GPU make sure particle properties consist of only simple data types. The symbols and strings in this example won't work on the GPU.","category":"page"},{"location":"model_setup/lagrangian_particles/#Writing-particle-properties-to-disk","page":"Lagrangian particles","title":"Writing particle properties to disk","text":"","category":"section"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"Particle properties can be written to disk using JLD2 or NetCDF.","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"When writing to JLD2 you can pass model.particles as part of the named tuple of outputs.","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"JLD2OutputWriter(model, (particles=model.particles,), prefix=\"particles\", schedule=TimeInterval(15))","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"When writing to NetCDF you should write particles to a separate file as the NetCDF dimensions differ for particle trajectories. You can just pass model.particles straight to NetCDFOutputWriter:","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"NetCDFOutputWriter(model, model.particles, filepath=\"particles.nc\", schedule=TimeInterval(15))","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"warn: Outputting custom particle properties to NetCDF\nNetCDF does not support arbitrary data types. If you need to write custom particle properties to disk that are not supported by NetCDF then you should use JLD2 (which should support almost any Julia data type).","category":"page"},{"location":"model_setup/diagnostics/#Diagnostics","page":"Diagnostics","title":"Diagnostics","text":"","category":"section"},{"location":"model_setup/diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"Diagnostics are a set of general utilities that can be called on-demand during time-stepping to compute quantities of interest you may want to save to disk, such as the horizontal average of the temperature, the maximum velocity, or to produce a time series of salinity. They also include utilities for diagnosing model health, such as the CFL number or to check for NaNs.","category":"page"},{"location":"model_setup/diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"Diagnostics are stored as a list of diagnostics in simulation.diagnostics. Diagnostics can be specified at model creation time or be specified at any later time and appended (or assigned with a key value pair) to simulation.diagnostics.","category":"page"},{"location":"model_setup/diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"Most diagnostics can be run at specified frequencies (e.g. every 25 time steps) or specified intervals (e.g. every 15 minutes of simulation time). If you'd like to run a diagnostic on demand then do not specify any intervals (and do not add it to simulation.diagnostics).","category":"page"},{"location":"model_setup/number_type/#Number-type","page":"Number type","title":"Number type","text":"","category":"section"},{"location":"model_setup/number_type/","page":"Number type","title":"Number type","text":"Passing float_type=Float64 or float_type=Float32 to the Model constructor causes the model to store all numbers with 64-bit or 32-bit floating point precision.","category":"page"},{"location":"model_setup/number_type/","page":"Number type","title":"Number type","text":"note: Avoiding mixed-precision operations\nWhen not using Float64 be careful to not mix different precisions as it could introduce implicit type conversions which can negatively effect performance. You can pass the number type desires to many constructors to enforce the type you want: e.g. RectilinearGrid(CPU(), Float32; size=(16, 16, 16), extent=(1, 1, 1)) and scalarDiffusivity(Float16; Îº=1//7, Î½=2//7).","category":"page"},{"location":"model_setup/number_type/","page":"Number type","title":"Number type","text":"warning: Effect of floating point precision on simulation accuracy\nWhile we run many tests with both Float32 and Float64 it is not clear whether Float32 is precise enough to provide similar accuracy in all use cases. If accuracy is a concern, stick to Float64.We will be actively investigating the possibility of using lower precision floating point numbers such as Float32 and Float16 for fluid dynamics as well as the use of alternative number types such as Posits and Sonums.","category":"page"},{"location":"quick_start/#Quick-start","page":"Quick start","title":"Quick start","text":"","category":"section"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"This code:","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"using Oceananigans\n\ngrid = RectilinearGrid(size=(128, 128), x=(0, 2Ï€), y=(0, 2Ï€), topology=(Periodic, Periodic, Flat))\nmodel = NonhydrostaticModel(; grid, advection=WENO())\n\nÏµ(x, y, z) = 2rand() - 1\nset!(model, u=Ïµ, v=Ïµ)\n\nsimulation = Simulation(model; Î”t=0.01, stop_iteration=100)\nrun!(simulation)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"runs 100 time steps of a two-dimensional turbulence simulation with 128Â² finite volume cells and a fifth-order upwinded WENO advection scheme. It's quite similar to the two-dimensional turbulence example.","category":"page"},{"location":"quick_start/#Visualization","page":"Quick start","title":"Visualization","text":"","category":"section"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"They say that a Makie visualization is worth a thousand Unicode characters, so let's plot vorticity,","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"using CairoMakie\n\nu, v, w = model.velocities\nÎ¶ = Field(âˆ‚x(v) - âˆ‚y(u))\ncompute!(Î¶)\n\nheatmap(interior(Î¶, :, :, 1))","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"A few more time-steps, and it's starting to get a little diffuse!","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"simulation.stop_iteration += 400\nrun!(simulation)\n\ncompute!(Î¶)\nheatmap(interior(Î¶, :, :, 1))","category":"page"},{"location":"quick_start/#They-always-cheat-with-too-simple-\"quick\"-starts","page":"Quick start","title":"They always cheat with too-simple \"quick\" starts","text":"","category":"section"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"Fine, we'll re-run this code on the GPU then:","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"using Oceananigans\n\ngrid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2Ï€), y=(0, 2Ï€), topology=(Periodic, Periodic, Flat))\nmodel = NonhydrostaticModel(; grid, advection=WENO())\n\nÏµ(x, y, z) = 2rand() - 1\nset!(model, u=Ïµ, v=Ïµ)\n\nsimulation = Simulation(model; Î”t=0.01, stop_iteration=100)\nrun!(simulation)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"Notice the difference? We passed the positional argument GPU() to RectilinearGrid.","category":"page"},{"location":"quick_start/#Well,-that-was-tantalizing","page":"Quick start","title":"Well, that was tantalizing","text":"","category":"section"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"But you'll need to know a lot more to become a productive, Oceananigans-wielding computational scientist (spherical grids, forcing, boundary conditions, turbulence closures, output writing, actually labeling your axes... ğŸ¤¯). It'd be best to move on to the one-dimensional diffusion example.","category":"page"},{"location":"physics/nonhydrostatic_model/#Nonhydrostatic-model","page":"Nonhydrostatic model","title":"Nonhydrostatic model","text":"","category":"section"},{"location":"physics/nonhydrostatic_model/","page":"Nonhydrostatic model","title":"Nonhydrostatic model","text":"The NonhydrostaticModel solves the incompressible Navier-Stokes equations under the Boussinesq approximation and an arbitrary number of tracer conservation equations. Physics associated with individual terms in the momentum and tracer conservation equations â€“- the background rotation rate of the equation's reference frame, gravitational effects associated with buoyant tracers under the Boussinesq approximation, generalized stresses and tracer fluxes associated with viscous and diffusive physics, and arbitrary \"forcing functions\" â€“- are determined by the whims of the user.","category":"page"},{"location":"physics/nonhydrostatic_model/#The-momentum-conservation-equation","page":"Nonhydrostatic model","title":"The momentum conservation equation","text":"","category":"section"},{"location":"physics/nonhydrostatic_model/","page":"Nonhydrostatic model","title":"Nonhydrostatic model","text":"The equations governing the conservation of momentum in a rotating fluid, including buoyancy via the Boussinesq approximation and including the averaged effects of surface gravity waves at the top of the domain via the Craik-Leibovich approximation are","category":"page"},{"location":"physics/nonhydrostatic_model/","page":"Nonhydrostatic model","title":"Nonhydrostatic model","text":"    beginalign\n    partial_t boldsymbolv  = - left ( boldsymbolv boldsymbolcdot boldsymbolnabla right ) boldsymbolv\n                        - left ( boldsymbolV boldsymbolcdot boldsymbolnabla right ) boldsymbolv\n                        - left ( boldsymbolv boldsymbolcdot boldsymbolnabla right ) boldsymbolV nonumber \n                         qquad\n                        - left ( boldsymbolf - boldsymbolnabla times boldsymbolu^S right ) times boldsymbolv \n                        - boldsymbolnabla p\n                        + b boldsymbolhat g\n                        - boldsymbolnabla boldsymbolcdot boldsymboltau\n                        + partial_t boldsymbolu^S\n                        + boldsymbolF_v  \n    labeleqmomentum\n    endalign","category":"page"},{"location":"physics/nonhydrostatic_model/","page":"Nonhydrostatic model","title":"Nonhydrostatic model","text":"where b boldsymbolhat g the is the buoyancy (a vector whose default direction is upward),  boldsymboltau is the kinematic stress tensor, boldsymbolF_v denotes an internal forcing of the velocity field boldsymbolv, p is the kinematic  pressure, boldsymbolu^S is the horizontal, two-dimensional 'Stokes drift' velocity field associated with surface gravity  waves, and boldsymbolf is the Coriolis parameter, or the background vorticity associated  with the specified rate of rotation of the frame of reference.","category":"page"},{"location":"physics/nonhydrostatic_model/","page":"Nonhydrostatic model","title":"Nonhydrostatic model","text":"The terms that appear on the right-hand side of the momentum conservation equation are (in order):","category":"page"},{"location":"physics/nonhydrostatic_model/","page":"Nonhydrostatic model","title":"Nonhydrostatic model","text":"momentum advection: left ( boldsymbolv boldsymbolcdot boldsymbolnabla right )  boldsymbolv,\nadvection of resolved momentum by the background velocity field boldsymbolV:  left ( boldsymbolV boldsymbolcdot boldsymbolnabla right ) boldsymbolv,\nadvection of background momentum by resolved velocity: left ( boldsymbolv boldsymbolcdot  boldsymbolnabla right ) boldsymbolV,\nCoriolis: boldsymbolf times boldsymbolv,\nthe effective background rotation rate due to surface waves: left ( boldsymbolnabla times  boldsymbolu^S right ) times boldsymbolv,\nkinematic pressure gradient: boldsymbolnabla p,\nbuoyant acceleration: b,\nvertical unit vector (pointing to the direction opposite to gravity): boldsymbolhat g,\nmolecular or turbulence viscous stress: boldsymbolnabla boldsymbolcdot boldsymboltau,\na source of momentum due to forcing or damping of surface waves: partial_t boldsymbolu^S, and\nan arbitrary internal source of momentum: boldsymbolF_v.","category":"page"},{"location":"physics/nonhydrostatic_model/#The-tracer-conservation-equation","page":"Nonhydrostatic model","title":"The tracer conservation equation","text":"","category":"section"},{"location":"physics/nonhydrostatic_model/","page":"Nonhydrostatic model","title":"Nonhydrostatic model","text":"The conservation law for tracers is","category":"page"},{"location":"physics/nonhydrostatic_model/","page":"Nonhydrostatic model","title":"Nonhydrostatic model","text":"    beginalign\n    partial_t c = - boldsymbolv boldsymbolcdot boldsymbolnabla c\n                   - boldsymbolV boldsymbolcdot boldsymbolnabla c\n                   - boldsymbolv boldsymbolcdot boldsymbolnabla C\n                   - boldsymbolnabla boldsymbolcdot boldsymbolq_c\n                   + F_c  \n    labeleqtracer\n    endalign","category":"page"},{"location":"physics/nonhydrostatic_model/","page":"Nonhydrostatic model","title":"Nonhydrostatic model","text":"where boldsymbolq_c is the diffusive flux of c and F_c is an arbitrary source term. An arbitrary tracers are permitted and thus an arbitrary number of tracer equations can be solved simultaneously alongside with the momentum equations.","category":"page"},{"location":"physics/nonhydrostatic_model/","page":"Nonhydrostatic model","title":"Nonhydrostatic model","text":"From left to right, the terms that appear on the right-hand side of the tracer conservation equation are","category":"page"},{"location":"physics/nonhydrostatic_model/","page":"Nonhydrostatic model","title":"Nonhydrostatic model","text":"tracer advection: boldsymbolv boldsymbolcdot boldsymbolnabla c,\ntracer advection by the background velocity field, boldsymbolV: boldsymbolV boldsymbolcdot boldsymbolnabla c,\nadvection of the background tracer field, C, by the resolved velocity field: boldsymbolv boldsymbolcdot boldsymbolnabla C,\nmolecular or turbulent diffusion: boldsymbolnabla boldsymbolcdot boldsymbolq_c, and\nan arbitrary internal source of tracer: F_c.","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"EditURL = \"<unknown>/examples/horizontal_convection.jl\"","category":"page"},{"location":"generated/horizontal_convection/#Horizontal-convection-example","page":"Horizontal convection","title":"Horizontal convection example","text":"","category":"section"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"In \"horizontal convection\", a non-uniform buoyancy is imposed on top of an initially resting fluid.","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"This example demonstrates:","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"How to use computed Fields for output.\nHow to post-process saved output using FieldTimeSeries.","category":"page"},{"location":"generated/horizontal_convection/#Install-dependencies","page":"Horizontal convection","title":"Install dependencies","text":"","category":"section"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"using Pkg\npkg\"add Oceananigans, CairoMakie\"","category":"page"},{"location":"generated/horizontal_convection/#Horizontal-convection","page":"Horizontal convection","title":"Horizontal convection","text":"","category":"section"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"We consider two-dimensional horizontal convection of an incompressible flow boldsymbolu = (u w) on the (x z)-plane (-L_x2 le x le L_x2 and -H le z le 0). The flow evolves under the effect of gravity. The only forcing on the fluid comes from a prescribed, non-uniform buoyancy at the top-surface of the domain.","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"We start by importing Oceananigans and Printf.","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"using Oceananigans\nusing Printf","category":"page"},{"location":"generated/horizontal_convection/#The-grid","page":"Horizontal convection","title":"The grid","text":"","category":"section"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"H = 1.0          # vertical domain extent\nLx = 2H          # horizontal domain extent\nNx, Nz = 128, 64 # horizontal, vertical resolution\n\ngrid = RectilinearGrid(size = (Nx, Nz),\n                          x = (-Lx/2, Lx/2),\n                          z = (-H, 0),\n                   topology = (Bounded, Flat, Bounded))","category":"page"},{"location":"generated/horizontal_convection/#Boundary-conditions","page":"Horizontal convection","title":"Boundary conditions","text":"","category":"section"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"At the surface, the imposed buoyancy is","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"b(x z = 0 t) = - b_* cos (2 pi x  L_x)  ","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"while zero-flux boundary conditions are imposed on all other boundaries. We use free-slip boundary conditions on u and w everywhere.","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"bâ˜… = 1.0\n\n@inline bË¢(x, y, t, p) = - p.bâ˜… * cos(2Ï€ * x / p.Lx)\n\nb_bcs = FieldBoundaryConditions(top = ValueBoundaryCondition(bË¢, parameters=(; bâ˜…, Lx)))","category":"page"},{"location":"generated/horizontal_convection/#Non-dimensional-control-parameters-and-Turbulence-closure","page":"Horizontal convection","title":"Non-dimensional control parameters and Turbulence closure","text":"","category":"section"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"The problem is characterized by three non-dimensional parameters. The first is the domain's aspect ratio, L_x  H and the other two are the Rayleigh (Ra) and Prandtl (Pr) numbers:","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"Ra = fracb_* L_x^3nu kappa   quad textand quad Pr = fracnukappa  ","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"The Prandtl number expresses the ratio of momentum over heat diffusion; the Rayleigh number is a measure of the relative importance of gravity over viscosity in the momentum equation.","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"For a domain with a given extent, the nondimensional values of Ra and Pr uniquely determine the viscosity and diffusivity, i.e.,","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"nu = sqrtfracPr b_* L_x^3Ra quad textand quad kappa = sqrtfracb_* L_x^3Pr Ra  ","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"We use isotropic viscosity and diffusivities, Î½ and Îº whose values are obtain from the prescribed Ra and Pr numbers. Here, we use Pr = 1 and Ra = 10^8:","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"Pr = 1.0    # Prandtl number\nRa = 1e8    # Rayleigh number\n\nÎ½ = sqrt(Pr * bâ˜… * Lx^3 / Ra)  # Laplacian viscosity\nÎº = Î½ * Pr                     # Laplacian diffusivity\nnothing # hide","category":"page"},{"location":"generated/horizontal_convection/#Model-instantiation","page":"Horizontal convection","title":"Model instantiation","text":"","category":"section"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"We instantiate the model with the fifth-order WENO advection scheme, a 3rd order Runge-Kutta time-stepping scheme, and a BuoyancyTracer.","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"model = NonhydrostaticModel(; grid,\n                            advection = WENO(),\n                            timestepper = :RungeKutta3,\n                            tracers = :b,\n                            buoyancy = BuoyancyTracer(),\n                            closure = ScalarDiffusivity(; Î½, Îº),\n                            boundary_conditions = (; b=b_bcs))","category":"page"},{"location":"generated/horizontal_convection/#Simulation-set-up","page":"Horizontal convection","title":"Simulation set-up","text":"","category":"section"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"We set up a simulation that runs up to t = 40 with a JLD2OutputWriter that saves the flow speed, sqrtu^2 + w^2, the buoyancy, b, and the vorticity, partial_z u - partial_x w.","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"simulation = Simulation(model, Î”t=1e-2, stop_time=40.0)","category":"page"},{"location":"generated/horizontal_convection/#The-TimeStepWizard","page":"Horizontal convection","title":"The TimeStepWizard","text":"","category":"section"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"The TimeStepWizard manages the time-step adaptively, keeping the Courant-Freidrichs-Lewy (CFL) number close to 0.75 while ensuring the time-step does not increase beyond the maximum allowable value for numerical stability.","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"wizard = TimeStepWizard(cfl=0.75, max_change=1.2, max_Î”t=1e-1)\n\nsimulation.callbacks[:wizard] = Callback(wizard, IterationInterval(50))","category":"page"},{"location":"generated/horizontal_convection/#A-progress-messenger","page":"Horizontal convection","title":"A progress messenger","text":"","category":"section"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"We write a function that prints out a helpful progress message while the simulation runs.","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"progress(sim) = @printf(\"i: % 6d, sim time: % 1.3f, wall time: % 10s, Î”t: % 1.4f, advective CFL: %.2e, diffusive CFL: %.2e\\n\",\n                        iteration(sim), time(sim), prettytime(sim.run_wall_time),\n                        sim.Î”t, AdvectiveCFL(sim.Î”t)(sim.model), DiffusiveCFL(sim.Î”t)(sim.model))\n\nsimulation.callbacks[:progress] = Callback(progress, IterationInterval(50))","category":"page"},{"location":"generated/horizontal_convection/#Output","page":"Horizontal convection","title":"Output","text":"","category":"section"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"We use computed Fields to diagnose and output the total flow speed, the vorticity, zeta, and the buoyancy, b. Note that computed Fields take \"AbstractOperations\" on Fields as input:","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"u, v, w = model.velocities # unpack velocity `Field`s\nb = model.tracers.b        # unpack buoyancy `Field`\n\n# total flow speed\ns = @at (Center, Center, Center) sqrt(u^2 + w^2)\n\n# y-component of vorticity\nÎ¶ = âˆ‚z(u) - âˆ‚x(w)\nnothing # hide","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"We create a JLD2OutputWriter that saves the speed, and the vorticity. Because we want to post-process buoyancy and compute the buoyancy variance dissipation (which is proportional to boldsymbolnabla b^2) we use the with_halos = true. This way, the halos for the fields are saved and thus when we load them as fields they will come with the proper boundary conditions.","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"We then add the JLD2OutputWriter to the simulation.","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"saved_output_filename = \"horizontal_convection.jld2\"\n\nsimulation.output_writers[:fields] = JLD2OutputWriter(model, (; s, b, Î¶),\n                                                      schedule = TimeInterval(0.5),\n                                                      filename = saved_output_filename,\n                                                      with_halos = true,\n                                                      overwrite_existing = true)\nnothing # hide","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"Ready to press the big red button:","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"run!(simulation)","category":"page"},{"location":"generated/horizontal_convection/#Load-saved-output,-process,-visualize","page":"Horizontal convection","title":"Load saved output, process, visualize","text":"","category":"section"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"We animate the results by loading the saved output, extracting data for the iterations we ended up saving at, and ploting the saved fields. From the saved buoyancy field we compute the buoyancy dissipation, chi = kappa boldsymbolnabla b^2, and plot that also.","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"To start we load the saved fields are FieldTimeSeries and prepare for animating the flow by creating coordinate arrays that each field lives on.","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"using CairoMakie\nusing Oceananigans\nusing Oceananigans.Fields\nusing Oceananigans.AbstractOperations: volume\n\nsaved_output_filename = \"horizontal_convection.jld2\"\n\n# Open the file with our data\ns_timeseries = FieldTimeSeries(saved_output_filename, \"s\")\nb_timeseries = FieldTimeSeries(saved_output_filename, \"b\")\nÎ¶_timeseries = FieldTimeSeries(saved_output_filename, \"Î¶\")\n\ntimes = b_timeseries.times\n\n# Coordinate arrays\nxc, yc, zc = nodes(b_timeseries[1])\nxÎ¶, yÎ¶, zÎ¶ = nodes(Î¶_timeseries[1])\nnothing # hide\n\nÏ‡_timeseries = deepcopy(b_timeseries)\n\nfor i in 1:length(times)\n  báµ¢ = b_timeseries[i]\n  Ï‡_timeseries[i] .= @at (Center, Center, Center) Îº * (âˆ‚x(báµ¢)^2 + âˆ‚z(báµ¢)^2)\nend","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"Now we're ready to animate using Makie.","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"@info \"Making an animation from saved data...\"\n\nn = Observable(1)\n\ntitle = @lift @sprintf(\"t=%1.2f\", times[$n])\n\nsâ‚™ = @lift interior(s_timeseries[$n], :, 1, :)\nÎ¶â‚™ = @lift interior(Î¶_timeseries[$n], :, 1, :)\nbâ‚™ = @lift interior(b_timeseries[$n], :, 1, :)\nÏ‡â‚™ = @lift interior(Ï‡_timeseries[$n], :, 1, :)\n\nslim = 0.6\nblim = 0.6\nÎ¶lim = 9\nÏ‡lim = 0.025\n\naxis_kwargs = (xlabel = L\"x / H\",\n               ylabel = L\"z / H\",\n               limits = ((-Lx/2, Lx/2), (-H, 0)),\n               aspect = Lx / H,\n               titlesize = 20)\n\nfig = Figure(resolution = (600, 1100))\n\nax_s = Axis(fig[2, 1];\n            title = L\"speed, $(u^2+w^2)^{1/2} / (L_x b_*) ^{1/2}\", axis_kwargs...)\n\nax_b = Axis(fig[3, 1];\n            title = L\"buoyancy, $b / b_*$\", axis_kwargs...)\n\nax_Î¶ = Axis(fig[4, 1];\n            title = L\"vorticity, $(âˆ‚u/âˆ‚z - âˆ‚w/âˆ‚x) \\, (L_x / b_*)^{1/2}$\", axis_kwargs...)\n\nax_Ï‡ = Axis(fig[5, 1];\n            title = L\"buoyancy dissipation, $Îº |\\mathbf{\\nabla}b|^2 \\, (L_x / {b_*}^5)^{1/2}$\", axis_kwargs...)\n\nfig[1, :] = Label(fig, title, fontsize=24, tellwidth=false)\n\nhm_s = heatmap!(ax_s, xc, zc, sâ‚™;\n                colorrange = (0, slim),\n                colormap = :speed)\nColorbar(fig[2, 2], hm_s)\n\nhm_b = heatmap!(ax_b, xc, zc, bâ‚™;\n                colorrange = (-blim, blim),\n                colormap = :thermal)\nColorbar(fig[3, 2], hm_b)\n\nhm_Î¶ = heatmap!(ax_Î¶, xÎ¶, zÎ¶, Î¶â‚™;\n                colorrange = (-Î¶lim, Î¶lim),\n                colormap = :balance)\nColorbar(fig[4, 2], hm_Î¶)\n\nhm_Ï‡ = heatmap!(ax_Ï‡, xc, zc, Ï‡â‚™;\n                colorrange = (0, Ï‡lim),\n                colormap = :dense)\nColorbar(fig[5, 2], hm_Ï‡)","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"And, finally, we record a movie.","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"frames = 1:length(times)\n\nrecord(fig, \"horizontal_convection.mp4\", frames, framerate=8) do i\n    msg = string(\"Plotting frame \", i, \" of \", frames[end])\n    print(msg * \" \\r\")\n    n[] = i\nend\nnothing #hide","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"(Image: )","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"At higher Rayleigh numbers the flow becomes much more vigorous. See, for example, an animation of the voricity of the fluid at Ra = 10^12 on vimeo.","category":"page"},{"location":"generated/horizontal_convection/#The-Nusselt-number","page":"Horizontal convection","title":"The Nusselt number","text":"","category":"section"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"Often we are interested on how much the flow enhances mixing. This is quantified by the Nusselt number, which measures how much the flow enhances mixing compared if only diffusion was in operation. The Nusselt number is given by","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"Nu = fraclangle chi ranglelangle chi_rm diff rangle  ","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"where angle brackets above denote both a volume and time average and chi_rm diff is the buoyancy dissipation that we get without any flow, i.e., the buoyancy dissipation associated with the buoyancy distribution that satisfies","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"kappa nabla^2 b_rm diff = 0  ","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"with the same boundary conditions same as our setup. In this case, we can readily find that","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"b_rm diff(x z) = b_s(x) fraccosh left 2 pi (H + z)  L_x right cosh(2 pi H  L_x)  ","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"where b_s(x) is the surface boundary condition. The diffusive solution implies langle chi_rm diff rangle = kappa b_*^2 pi tanh(2 pi Î— Lx)  (L_x H).","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"We use the loaded FieldTimeSeries to compute the Nusselt number from buoyancy and the volume average kinetic energy of the fluid.","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"First we compute the diffusive buoyancy dissipation, chi_rm diff (which is just a scalar):","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"Ï‡_diff = Îº * bâ˜…^2 * Ï€ * tanh(2Ï€ * H / Lx) / (Lx * H)\nnothing # hide","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"We recover the time from the saved FieldTimeSeries and construct two empty arrays to store the volume-averaged kinetic energy and the instantaneous Nusselt number,","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"t = b_timeseries.times\n\nkinetic_energy, Nu = zeros(length(t)), zeros(length(t))\nnothing # hide","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"Now we can loop over the fields in the FieldTimeSeries, compute kinetic energy and Nu, and plot. We make use of Integral to compute the volume integral of fields over our domain.","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"for i = 1:length(t)\n    ke = Field(Integral(1/2 * s_timeseries[i]^2 / (Lx * H)))\n    compute!(ke)\n    kinetic_energy[i] = ke[1, 1, 1]\n\n    Ï‡ = Field(Integral(Ï‡_timeseries[i] / (Lx * H)))\n    compute!(Ï‡)\n\n    Nu[i] = Ï‡[1, 1, 1] / Ï‡_diff\nend\n\nfig = Figure(resolution = (850, 450))\n\nax_KE = Axis(fig[1, 1], xlabel = L\"t \\, (b_* / L_x)^{1/2}\", ylabel = L\"KE $ / (L_x b_*)$\")\nlines!(ax_KE, t, kinetic_energy; linewidth = 3)\n\nax_Nu = Axis(fig[2, 1], xlabel = L\"t \\, (b_* / L_x)^{1/2}\", ylabel = L\"Nu\")\nlines!(ax_Nu, t, Nu; linewidth = 3)\n\ncurrent_figure() # hide\nfig","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"","category":"page"},{"location":"generated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"This page was generated using Literate.jl.","category":"page"},{"location":"model_setup/overview/#Model-setup","page":"Overview","title":"Model setup","text":"","category":"section"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"This section describes all the options and features that can be used to set up a model. For  more detailed information consult the API documentation.","category":"page"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"Each structure covered in this section can be constructed and passed to the models' constructors.  For examples of model construction, see the examples. The validation experiments provide more  advanced examples.","category":"page"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"For reference, here are all the option or keyword arguments that can be passed to the models currently implemented in Oceananigans.jl. See the different sections on the sidebar for more  details and examples for each keyword argument.","category":"page"},{"location":"model_setup/overview/#NonhydrostaticModel","page":"Overview","title":"NonhydrostaticModel","text":"","category":"section"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"NonhydrostaticModel","category":"page"},{"location":"model_setup/overview/#Oceananigans.Models.NonhydrostaticModels.NonhydrostaticModel","page":"Overview","title":"Oceananigans.Models.NonhydrostaticModels.NonhydrostaticModel","text":"NonhydrostaticModel(;          grid,\n                              clock = Clock{eltype(grid)}(0, 0, 1),\n                          advection = CenteredSecondOrder(),\n                           buoyancy = nothing,\n                           coriolis = nothing,\n                       stokes_drift = nothing,\n                forcing::NamedTuple = NamedTuple(),\n                            closure = nothing,\n    boundary_conditions::NamedTuple = NamedTuple(),\n                            tracers = (),\n                        timestepper = :QuasiAdamsBashforth2,\n      background_fields::NamedTuple = NamedTuple(),\n      particles::ParticlesOrNothing = nothing,\n\nbiogeochemistry::AbstractBGCOrNothing = nothing,                              velocities = nothing,                               pressures = nothing,                      diffusivityfields = nothing,                         pressuresolver = nothing,                       immersedboundary = nothing,                        auxiliaryfields = NamedTuple())\n\nConstruct a model for a non-hydrostatic, incompressible fluid on grid, using the Boussinesq approximation when buoyancy != nothing. By default, all Bounded directions are rigid and impenetrable.\n\nKeyword arguments\n\ngrid: (required) The resolution and discrete geometry on which the model is solved. The         architecture (CPU/GPU) that the model is solved on is inferred from the architecture         of the grid. Note that the grid needs to be regularly spaced in the horizontal         dimensions, x and y.\nadvection: The scheme that advects velocities and tracers. See Oceananigans.Advection.\nbuoyancy: The buoyancy model. See Oceananigans.BuoyancyModels.\ncoriolis: Parameters for the background rotation rate of the model.\nstokes_drift: Parameters for Stokes drift fields associated with surface waves. Default: nothing.\nforcing: NamedTuple of user-defined forcing functions that contribute to solution tendencies.\nclosure: The turbulence closure for model. See Oceananigans.TurbulenceClosures.\nboundary_conditions: NamedTuple containing field boundary conditions.\ntracers: A tuple of symbols defining the names of the modeled tracers, or a NamedTuple of            preallocated CenterFields.\ntimestepper: A symbol that specifies the time-stepping method. Either :QuasiAdamsBashforth2 or                :RungeKutta3.\nbackground_fields: NamedTuple with background fields (e.g., background flow). Default: nothing.\nparticles: Lagrangian particles to be advected with the flow. Default: nothing.\nbiogeochemistry: Biogeochemical model for tracers.\nvelocities: The model velocities. Default: nothing.\npressures: Hydrostatic and non-hydrostatic pressure fields. Default: nothing.\ndiffusivity_fields: Diffusivity fields. Default: nothing.\npressure_solver: Pressure solver to be used in the model. If nothing (default), the model constructor chooses the default based on the grid provide.\nimmersed_boundary: The immersed boundary. Default: nothing.\nauxiliary_fields: NamedTuple of auxiliary fields. Default: nothing         \n\n\n\n\n\n","category":"type"},{"location":"model_setup/overview/#HydrostaticFreeSurfaceModel","page":"Overview","title":"HydrostaticFreeSurfaceModel","text":"","category":"section"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"HydrostaticFreeSurfaceModel","category":"page"},{"location":"model_setup/overview/#Oceananigans.Models.HydrostaticFreeSurfaceModels.HydrostaticFreeSurfaceModel","page":"Overview","title":"Oceananigans.Models.HydrostaticFreeSurfaceModels.HydrostaticFreeSurfaceModel","text":"HydrostaticFreeSurfaceModel(; grid,\n                                         clock = Clock{eltype(grid)}(0, 0, 1),\n                            momentum_advection = CenteredSecondOrder(),\n                              tracer_advection = CenteredSecondOrder(),\n                                      buoyancy = SeawaterBuoyancy(eltype(grid)),\n                                      coriolis = nothing,\n                                  free_surface = ImplicitFreeSurface(gravitational_acceleration=g_Earth),\n                           forcing::NamedTuple = NamedTuple(),\n                                       closure = nothing,\n               boundary_conditions::NamedTuple = NamedTuple(),\n                                       tracers = (:T, :S),\n                 particles::ParticlesOrNothing = nothing,\n         biogeochemistry::AbstractBGCOrNothing = nothing,\n                                    velocities = nothing,\n                                      pressure = nothing,\n                            diffusivity_fields = nothing,\n                              auxiliary_fields = NamedTuple(),\n        calculate_only_active_cells_tendencies = false\n)\n\nConstruct a hydrostatic model with a free surface on grid.\n\nKeyword arguments\n\ngrid: (required) The resolution and discrete geometry on which model is solved. The architecture (CPU/GPU) that the model is solve is inferred from the architecture of the grid.\nmomentum_advection: The scheme that advects velocities. See Oceananigans.Advection.\ntracer_advection: The scheme that advects tracers. See Oceananigans.Advection.\nbuoyancy: The buoyancy model. See Oceananigans.BuoyancyModels.\ncoriolis: Parameters for the background rotation rate of the model.\nforcing: NamedTuple of user-defined forcing functions that contribute to solution tendencies.\nfree_surface: The free surface model.\nclosure: The turbulence closure for model. See Oceananigans.TurbulenceClosures.\nboundary_conditions: NamedTuple containing field boundary conditions.\ntracers: A tuple of symbols defining the names of the modeled tracers, or a NamedTuple of            preallocated CenterFields.\nparticles: Lagrangian particles to be advected with the flow. Default: nothing.\nbiogeochemistry: Biogeochemical model for tracers.\nvelocities: The model velocities. Default: nothing.\npressure: Hydrostatic pressure field. Default: nothing.\ndiffusivity_fields: Diffusivity fields. Default: nothing.\nauxiliary_fields: NamedTuple of auxiliary fields. Default: nothing\n\n\n\n\n\n","category":"type"},{"location":"model_setup/overview/#ShallowWaterModel","page":"Overview","title":"ShallowWaterModel","text":"","category":"section"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"ShallowWaterModel","category":"page"},{"location":"model_setup/overview/#Oceananigans.Models.ShallowWaterModels.ShallowWaterModel","page":"Overview","title":"Oceananigans.Models.ShallowWaterModels.ShallowWaterModel","text":"ShallowWaterModel(; grid,\n                    gravitational_acceleration,\n                          clock = Clock{eltype(grid)}(0, 0, 1),\n             momentum_advection = UpwindBiasedFifthOrder(),\n               tracer_advection = WENO(),\n                 mass_advection = WENO(),\n                       coriolis = nothing,\n            forcing::NamedTuple = NamedTuple(),\n                        closure = nothing,\n                     bathymetry = nothing,\n                        tracers = (),\n             diffusivity_fields = nothing,\nboundary_conditions::NamedTuple = NamedTuple(),\n            timestepper::Symbol = :RungeKutta3,\n                    formulation = ConservativeFormulation())\n\nConstruct a shallow water model on grid with gravitational_acceleration constant.\n\nKeyword arguments\n\ngrid: (required) The resolution and discrete geometry on which model is solved. The         architecture (CPU/GPU) that the model is solve is inferred from the architecture         of the grid.\ngravitational_acceleration: (required) The gravitational acceleration constant.\nclock: The clock for the model.\nmomentum_advection: The scheme that advects velocities. See Oceananigans.Advection. Default: UpwindBiasedFifthOrder().\ntracer_advection: The scheme that advects tracers. See Oceananigans.Advection. Default: WENO().\nmass_advection: The scheme that advects the mass equation. See Oceananigans.Advection. Default: WENO().\ncoriolis: Parameters for the background rotation rate of the model.\nforcing: NamedTuple of user-defined forcing functions that contribute to solution tendencies.\nclosure: The turbulence closure for model. See Oceananigans.TurbulenceClosures.\nbathymetry: The bottom bathymetry.\ntracers: A tuple of symbols defining the names of the modeled tracers, or a NamedTuple of            preallocated CenterFields.\ndiffusivity_fields: Stores diffusivity fields when the closures require a diffusivity to be                       calculated at each timestep.\nboundary_conditions: NamedTuple containing field boundary conditions.\ntimestepper: A symbol that specifies the time-stepping method. Either :QuasiAdamsBashforth2 or                :RungeKutta3 (default).\nformulation: Whether the dynamics are expressed in conservative form (ConservativeFormulation();                default) or in non-conservative form with a vector-invariant formulation for the                non-linear terms (VectorInvariantFormulation()).\n\nwarning: Formulation-grid compatibility requirements\nThe ConservativeFormulation() requires RectilinearGrid. Use VectorInvariantFormulation() with LatitudeLongitudeGrid.\n\n\n\n\n\n","category":"type"},{"location":"physics/buoyancy_and_equations_of_state/#Buoyancy-model-and-equations-of-state","page":"Buoyancy models and equations of state","title":"Buoyancy model and equations of state","text":"","category":"section"},{"location":"physics/buoyancy_and_equations_of_state/","page":"Buoyancy models and equations of state","title":"Buoyancy models and equations of state","text":"The buoyancy model determines the relationship between tracers and the buoyancy b in the momentum equation.","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/#Buoyancy-tracer","page":"Buoyancy models and equations of state","title":"Buoyancy tracer","text":"","category":"section"},{"location":"physics/buoyancy_and_equations_of_state/","page":"Buoyancy models and equations of state","title":"Buoyancy models and equations of state","text":"The simplest buoyancy model uses buoyancy b itself as a tracer: b obeys the tracer conservation equation and is used directly in the momentum equations.","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/#Seawater-buoyancy","page":"Buoyancy models and equations of state","title":"Seawater buoyancy","text":"","category":"section"},{"location":"physics/buoyancy_and_equations_of_state/","page":"Buoyancy models and equations of state","title":"Buoyancy models and equations of state","text":"For seawater buoyancy is, in general, modeled as a function of conservative temperature T, absolute salinity S, and depth below the ocean surface d via","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/","page":"Buoyancy models and equations of state","title":"Buoyancy models and equations of state","text":"    beginequation\n    b = - fracgrho_0 rho left (T S d right )  \n    labeleqseawater-buoyancy\n    endequation","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/","page":"Buoyancy models and equations of state","title":"Buoyancy models and equations of state","text":"where g is gravitational acceleration, rho_0 is the reference density. The function rho(T S d) in the seawater buoyancy relationship that links conservative temperature, salinity, and depth to the density perturbation is called the equation of state. Both T and S obey the tracer conservation equation.","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/#Linear-equation-of-state","page":"Buoyancy models and equations of state","title":"Linear equation of state","text":"","category":"section"},{"location":"physics/buoyancy_and_equations_of_state/","page":"Buoyancy models and equations of state","title":"Buoyancy models and equations of state","text":"Buoyancy is determined from a linear equation of state via","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/","page":"Buoyancy models and equations of state","title":"Buoyancy models and equations of state","text":"    b = g left ( alpha T - beta S right )  ","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/","page":"Buoyancy models and equations of state","title":"Buoyancy models and equations of state","text":"where g is gravitational acceleration, alpha is the thermal expansion coefficient, and beta is the haline contraction coefficient.","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/#Nonlinear-equation-of-state","page":"Buoyancy models and equations of state","title":"Nonlinear equation of state","text":"","category":"section"},{"location":"physics/buoyancy_and_equations_of_state/","page":"Buoyancy models and equations of state","title":"Buoyancy models and equations of state","text":"Buoyancy is determined by the simplified equations of state introduced by F. Roquet, G. Madec, Trevor J. McDougall, Paul M. Barker (2015).","category":"page"},{"location":"model_setup/boundary_conditions/#model_step_bcs","page":"Boundary conditions","title":"Boundary conditions","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Boundary conditions are intimately related to the grid topology, and only need to be considered in directions with Bounded topology or across immersed boundaries. In Bounded directions, tracer and momentum fluxes are conservative or \"zero flux\" by default. Non-default boundary conditions are therefore required to specify non-zero fluxes of tracers and momentum across Bounded directions, and across immersed boundaries when using ImmersedBoundaryGrid.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"See Numerical implementation of boundary conditions for more details.","category":"page"},{"location":"model_setup/boundary_conditions/#Example:-no-slip-conditions-on-every-boundary","page":"Boundary conditions","title":"Example: no-slip conditions on every boundary","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"DocTestSetup = quote\n   using Oceananigans\n\n   using Random\n   Random.seed!(1234)\nend","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> using Oceananigans\n\njulia> grid = RectilinearGrid(size=(16, 16, 16), x=(0, 2Ï€), y=(0, 1), z=(0, 1), topology=(Periodic, Bounded, Bounded))\n16Ã—16Ã—16 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ Periodic x âˆˆ [0.0, 6.28319) regularly spaced with Î”x=0.392699\nâ”œâ”€â”€ Bounded  y âˆˆ [0.0, 1.0]     regularly spaced with Î”y=0.0625\nâ””â”€â”€ Bounded  z âˆˆ [0.0, 1.0]     regularly spaced with Î”z=0.0625\n\njulia> no_slip_bc = ValueBoundaryCondition(0.0)\nValueBoundaryCondition: 0.0","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"A \"no-slip\" BoundaryCondition specifies that velocity components tangential to Bounded directions decay to 0 at the boundary, leading to a viscous loss of momentum.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> no_slip_field_bcs = FieldBoundaryConditions(no_slip_bc);\n\njulia> model = NonhydrostaticModel(; grid, boundary_conditions=(u=no_slip_field_bcs, v=no_slip_field_bcs, w=no_slip_field_bcs))\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 16Ã—16Ã—16 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ timestepper: QuasiAdamsBashforth2TimeStepper\nâ”œâ”€â”€ tracers: ()\nâ”œâ”€â”€ closure: Nothing\nâ”œâ”€â”€ buoyancy: Nothing\nâ””â”€â”€ coriolis: Nothing\n\njulia> model.velocities.u.boundary_conditions\nOceananigans.FieldBoundaryConditions, with boundary conditions\nâ”œâ”€â”€ west: PeriodicBoundaryCondition\nâ”œâ”€â”€ east: PeriodicBoundaryCondition\nâ”œâ”€â”€ south: ValueBoundaryCondition: 0.0\nâ”œâ”€â”€ north: ValueBoundaryCondition: 0.0\nâ”œâ”€â”€ bottom: ValueBoundaryCondition: 0.0\nâ”œâ”€â”€ top: ValueBoundaryCondition: 0.0\nâ””â”€â”€ immersed: FluxBoundaryCondition: Nothing","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Boundary conditions are passed to FieldBoundaryCondition to build boundary conditions for each field individually, and then onto the model constructor (here NonhydrotaticModel) via the  keyword argument boundary_conditions. The model constructor then \"interprets\" the input and builds appropriate boundary conditions for the grid topology, given the user-specified no_slip default boundary condition for Bounded directions. In the above example, note that the west and east boundary conditions are PeriodicBoundaryCondition because the x-topology of the grid is Periodic.","category":"page"},{"location":"model_setup/boundary_conditions/#Example:-specifying-boundary-conditions-on-individual-boundaries","page":"Boundary conditions","title":"Example: specifying boundary conditions on individual boundaries","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"To specify no-slip boundary conditions on every Bounded direction except the surface, we write","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> free_slip_surface_bcs = FieldBoundaryConditions(no_slip_bc, top=FluxBoundaryCondition(nothing));\n\njulia> model = NonhydrostaticModel(; grid, boundary_conditions=(u=free_slip_surface_bcs, v=free_slip_surface_bcs, w=no_slip_field_bcs));\n\njulia> model.velocities.u.boundary_conditions\nOceananigans.FieldBoundaryConditions, with boundary conditions\nâ”œâ”€â”€ west: PeriodicBoundaryCondition\nâ”œâ”€â”€ east: PeriodicBoundaryCondition\nâ”œâ”€â”€ south: ValueBoundaryCondition: 0.0\nâ”œâ”€â”€ north: ValueBoundaryCondition: 0.0\nâ”œâ”€â”€ bottom: ValueBoundaryCondition: 0.0\nâ”œâ”€â”€ top: FluxBoundaryCondition: Nothing\nâ””â”€â”€ immersed: FluxBoundaryCondition: Nothing\n\njulia> model.velocities.v.boundary_conditions\nOceananigans.FieldBoundaryConditions, with boundary conditions\nâ”œâ”€â”€ west: PeriodicBoundaryCondition\nâ”œâ”€â”€ east: PeriodicBoundaryCondition\nâ”œâ”€â”€ south: OpenBoundaryCondition: Nothing\nâ”œâ”€â”€ north: OpenBoundaryCondition: Nothing\nâ”œâ”€â”€ bottom: ValueBoundaryCondition: 0.0\nâ”œâ”€â”€ top: FluxBoundaryCondition: Nothing\nâ””â”€â”€ immersed: FluxBoundaryCondition: Nothing","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Now both u and v have FluxBoundaryCondition(nothing) at the top boundary, which is Oceananigans lingo for \"no-flux boundary condition\".","category":"page"},{"location":"model_setup/boundary_conditions/#Boundary-condition-classifications","page":"Boundary conditions","title":"Boundary condition classifications","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"There are three primary boundary condition classifications:","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"FluxBoundaryCondition specifies fluxes directly.\nSome applications of FluxBoundaryCondition are:\nsurface momentum fluxes due to wind, or \"wind stress\";\nlinear or quadratic bottom drag;\nsurface temperature fluxes due to heating or cooling;\nsurface salinity fluxes due to precipitation and evaporation;\nrelaxation boundary conditions that restores a field to some boundary distribution over a given time-scale.\nValueBoundaryCondition (Dirichlet) specifies the value of a field on the given boundary, which when used in combination with a turbulence closure results in a flux across the boundary.\nNote: Do not use ValueBoundaryCondition on a wall-normal velocity component (see the note below about ImpenetrableBoundaryCondition).\nSome applications of ValueBoundaryCondition are:\nno-slip boundary condition for wall-tangential velocity components via ValueBoundaryCondition(0);\nsurface temperature distribution, where heat fluxes in and out of the domain at a rate controlled by the near-surface temperature gradient and the temperature diffusivity;\nconstant velocity tangential to a boundary as in a driven-cavity flow (for example),  where the top boundary is moving. Momentum will flux into the domain do the difference between the top boundary velocity and the interior velocity, and the prescribed viscosity.\nGradientBoundaryCondition (Neumann) specifies the gradient of a field on a boundary. For example, if there is a known diffusivity, we can express FluxBoundaryCondition(flux) using GradientBoundaryCondition(-flux / diffusivity) (aka \"Neumann\" boundary condition).","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"In addition to these primary boundary conditions, ImpenetrableBoundaryCondition applies to velocity components in wall-normal directions.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"warn: `ImpenetrableBoundaryCondition`\nImpenetrableBoundaryCondition is internally enforced for fields created inside the model constructor. As a result, ImpenetrableBoundaryCondition is only used for additional velocity components that are not evolved by a model, such as a velocity component used for (AdvectiveForcing)[@ref].","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Finally, note that Periodic boundary conditions are internally enforced for Periodic directions, and DefaultBoundaryConditions may exist before boundary conditions are \"materialized\" by a model.","category":"page"},{"location":"model_setup/boundary_conditions/#Default-boundary-conditions","page":"Boundary conditions","title":"Default boundary conditions","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"The default boundary condition in Bounded directions is no-flux, or FluxBoundaryCondition(nothing). The default boundary condition can be changed by passing a positional argument to FieldBoundaryConditions, as in","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> no_slip_bc = ValueBoundaryCondition(0.0)\nValueBoundaryCondition: 0.0\n\njulia> free_slip_surface_bcs = FieldBoundaryConditions(no_slip_bc, top=FluxBoundaryCondition(nothing))\nOceananigans.FieldBoundaryConditions, with boundary conditions\nâ”œâ”€â”€ west: DefaultBoundaryCondition (ValueBoundaryCondition: 0.0)\nâ”œâ”€â”€ east: DefaultBoundaryCondition (ValueBoundaryCondition: 0.0)\nâ”œâ”€â”€ south: DefaultBoundaryCondition (ValueBoundaryCondition: 0.0)\nâ”œâ”€â”€ north: DefaultBoundaryCondition (ValueBoundaryCondition: 0.0)\nâ”œâ”€â”€ bottom: DefaultBoundaryCondition (ValueBoundaryCondition: 0.0)\nâ”œâ”€â”€ top: FluxBoundaryCondition: Nothing\nâ””â”€â”€ immersed: DefaultBoundaryCondition (ValueBoundaryCondition: 0.0)","category":"page"},{"location":"model_setup/boundary_conditions/#Boundary-condition-structures","page":"Boundary conditions","title":"Boundary condition structures","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Oceananigans uses a hierarchical structure to express boundary conditions:","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Each boundary of each field has one BoundaryCondition\nEach field has seven BoundaryCondition (west, east, south, north, bottom, top and immersed)\nA set of FieldBoundaryConditions, up to one for each field, are grouped into a NamedTuple and passed to the model constructor.","category":"page"},{"location":"model_setup/boundary_conditions/#Specifying-boundary-conditions-for-a-model","page":"Boundary conditions","title":"Specifying boundary conditions for a model","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Boundary conditions are defined at model construction time by passing a NamedTuple of FieldBoundaryConditions specifying non-default boundary conditions for fields such as velocities and tracers.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Fields for which boundary conditions are not specified are assigned a default boundary conditions.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"A few illustrations are provided below. See the examples for further illustrations of boundary condition specification.","category":"page"},{"location":"model_setup/boundary_conditions/#Creating-individual-boundary-conditions-with-BoundaryCondition","page":"Boundary conditions","title":"Creating individual boundary conditions with BoundaryCondition","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Boundary conditions may be specified with constants, functions, or arrays. In this section we illustrate usage of the different BoundaryCondition constructors.","category":"page"},{"location":"model_setup/boundary_conditions/#.-Constant-Value-(Dirchlet)-boundary-condition","page":"Boundary conditions","title":"1. Constant Value (Dirchlet) boundary condition","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> constant_T_bc = ValueBoundaryCondition(20.0)\nValueBoundaryCondition: 20.0","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"A constant Value boundary condition can be used to specify constant tracer (such as temperature), or a constant tangential velocity component at a boundary. Note that boundary conditions on the normal velocity component must use the Open boundary condition type.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Finally, note that ValueBoundaryCondition(condition) is an alias for BoundaryCondition(Value, condition).","category":"page"},{"location":"model_setup/boundary_conditions/#.-Constant-Flux-boundary-condition","page":"Boundary conditions","title":"2. Constant Flux boundary condition","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> Ïâ‚€ = 1027;  # Reference density [kg/mÂ³]\n\njulia> Ï„â‚“ = 0.08;  # Wind stress [N/mÂ²]\n\njulia> wind_stress_bc = FluxBoundaryCondition(-Ï„â‚“/Ïâ‚€)\nFluxBoundaryCondition: -7.78968e-5","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"A constant Flux boundary condition can be imposed on tracers and tangential velocity components that can be used, for example, to specify cooling, heating, evaporation, or wind stress at the ocean surface.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"info: The flux convention in Oceananigans\nOceananigans uses the convention that positive fluxes produce transport in the positive direction (east, north, and up for x, y, z). This means, for example, that a negative flux of momentum or velocity at a top boundary, such as in the above example, produces currents in the positive direction, because it prescribes a downwards flux of momentum into the domain from the top. Likewise, a positive temperature flux at the top boundary causes cooling, because it transports heat upwards, out of the domain. Conversely, a positive flux at a bottom boundary acts to increase the interior values of a quantity.","category":"page"},{"location":"model_setup/boundary_conditions/#.-Spatially-and-temporally-varying-flux","page":"Boundary conditions","title":"3. Spatially- and temporally-varying flux","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Boundary conditions may be specified by functions,","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> @inline surface_flux(x, y, t) = cos(2Ï€ * x) * cos(t);\n\njulia> top_tracer_bc = FluxBoundaryCondition(surface_flux)\nFluxBoundaryCondition: ContinuousBoundaryFunction surface_flux at (Nothing, Nothing, Nothing)","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"info: Boundary condition functions\nBy default, a function boundary condition is called with the signaturef(Î¾, Î·, t)where t is time and Î¾, Î· are spatial coordinates that vary along the boundary:f(y, z, t) on x-boundaries;\nf(x, z, t) on y-boundaries;\nf(x, y, t) on z-boundaries.Alternative function signatures are specified by keyword arguments to BoundaryCondition, as illustrated in subsequent examples.","category":"page"},{"location":"model_setup/boundary_conditions/#.-Spatially-and-temporally-varying-flux-with-parameters","page":"Boundary conditions","title":"4. Spatially- and temporally-varying flux with parameters","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Boundary condition functions may be 'parameterized',","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> @inline wind_stress(x, y, t, p) = - p.Ï„ * cos(p.k * x) * cos(p.Ï‰ * t); # function with parameters\n\njulia> top_u_bc = FluxBoundaryCondition(wind_stress, parameters=(k=4Ï€, Ï‰=3.0, Ï„=1e-4))\nFluxBoundaryCondition: ContinuousBoundaryFunction wind_stress at (Nothing, Nothing, Nothing)","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"info: Boundary condition functions with parameters\nThe keyword argument parameters above specifies that wind_stress is called with the signature wind_stress(x, y, t, parameters). In principle, parameters is arbitrary. However, relatively simple objects such as floating point numbers or NamedTuples must be used when running on the GPU.","category":"page"},{"location":"model_setup/boundary_conditions/#.-'Field-dependent'-boundary-conditions","page":"Boundary conditions","title":"5. 'Field-dependent' boundary conditions","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Boundary conditions may also depend on model fields. For example, a linear drag boundary condition is implemented with","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> @inline linear_drag(x, y, t, u) = - 0.2 * u\nlinear_drag (generic function with 1 method)\n\njulia> u_bottom_bc = FluxBoundaryCondition(linear_drag, field_dependencies=:u)\nFluxBoundaryCondition: ContinuousBoundaryFunction linear_drag at (Nothing, Nothing, Nothing)","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"field_dependencies specifies the name of the dependent fields either with a Symbol or Tuple of Symbols.","category":"page"},{"location":"model_setup/boundary_conditions/#.-'Field-dependent'-boundary-conditions-with-parameters","page":"Boundary conditions","title":"6. 'Field-dependent' boundary conditions with parameters","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"When boundary conditions depends on fields and parameters, their functions take the form","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> @inline quadratic_drag(x, y, t, u, v, drag_coeff) = - drag_coeff * u * sqrt(u^2 + v^2)\nquadratic_drag (generic function with 1 method)\n\njulia> u_bottom_bc = FluxBoundaryCondition(quadratic_drag, field_dependencies=(:u, :v), parameters=1e-3)\nFluxBoundaryCondition: ContinuousBoundaryFunction quadratic_drag at (Nothing, Nothing, Nothing)","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Put differently, Î¾, Î·, t come first in the function signature, followed by field dependencies, followed by parameters is !isnothing(parameters).","category":"page"},{"location":"model_setup/boundary_conditions/#.-Discrete-form-boundary-condition-with-parameters","page":"Boundary conditions","title":"7. Discrete-form boundary condition with parameters","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Discrete field data may also be accessed directly from boundary condition functions using the discrete_form. For example:","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"@inline filtered_drag(i, j, grid, clock, model_fields) =\n   @inbounds - 0.05 * (model_fields.u[i-1, j, 1] + 2 * model_fields.u[i, j, 1] + model_fields.u[i-1, j, 1])\n\nu_bottom_bc = FluxBoundaryCondition(filtered_drag, discrete_form=true)\n\n# output\nFluxBoundaryCondition: DiscreteBoundaryFunction with filtered_drag","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"info: The 'discrete form' for boundary condition functions\nThe argument discrete_form=true indicates to BoundaryCondition that filtered_drag uses the 'discrete form'. Boundary condition functions that use the 'discrete form' are called with the signaturef(i, j, grid, clock, model_fields)where i, j are grid indices that vary along the boundary, grid is model.grid, clock is the model.clock, and model_fields is a NamedTuple containing u, v, w and the fields in model.tracers. The signature is similar for x and y boundary conditions expect that i, j is replaced with j, k and i, k respectively.","category":"page"},{"location":"model_setup/boundary_conditions/#.-Discrete-form-boundary-condition-with-parameters-2","page":"Boundary conditions","title":"8. Discrete-form boundary condition with parameters","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> Cd = 0.2;  # drag coefficient\n\njulia> @inline linear_drag(i, j, grid, clock, model_fields, Cd) = @inbounds - Cd * model_fields.u[i, j, 1];\n\njulia> u_bottom_bc = FluxBoundaryCondition(linear_drag, discrete_form=true, parameters=Cd)\nFluxBoundaryCondition: DiscreteBoundaryFunction linear_drag with parameters 0.2","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"info: Inlining and avoiding bounds-checking in boundary condition functions\nBoundary condition functions should be decorated with @inline when running on CPUs for performance reasons. On the GPU, all functions are force-inlined by default. In addition, the annotation @inbounds should be used when accessing the elements of an array in a boundary condition function (such as model_fields.u[i, j, 1] in the above example). Using @inbounds will avoid a relatively expensive check that the index i, j, 1 is 'in bounds'.","category":"page"},{"location":"model_setup/boundary_conditions/#.-A-random,-spatially-varying,-constant-in-time-temperature-flux-specified-by-an-array","page":"Boundary conditions","title":"9. A random, spatially-varying, constant-in-time temperature flux specified by an array","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> Nx = Ny = 16;  # Number of grid points.\n\njulia> Q = randn(Nx, Ny); # temperature flux\n\njulia> white_noise_T_bc = FluxBoundaryCondition(Q)\nFluxBoundaryCondition: 16Ã—16 Matrix{Float64}","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"When running on the GPU, Q must be converted to a CuArray.","category":"page"},{"location":"model_setup/boundary_conditions/#Building-boundary-conditions-on-a-field","page":"Boundary conditions","title":"Building boundary conditions on a field","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"To create a set of FieldBoundaryConditions for a temperature field, we write","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> T_bcs = FieldBoundaryConditions(top = ValueBoundaryCondition(20.0),\n                                       bottom = GradientBoundaryCondition(0.01))\nOceananigans.FieldBoundaryConditions, with boundary conditions\nâ”œâ”€â”€ west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ bottom: GradientBoundaryCondition: 0.01\nâ”œâ”€â”€ top: ValueBoundaryCondition: 20.0\nâ””â”€â”€ immersed: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"If the grid is, e.g., horizontally-periodic, then each horizontal DefaultBoundaryCondition is converted to PeriodicBoundaryCondition inside the model's constructor, before assigning the boundary conditions to temperature T.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"In general, boundary condition defaults are inferred from the field location and topology(grid).","category":"page"},{"location":"model_setup/boundary_conditions/#Specifying-model-boundary-conditions","page":"Boundary conditions","title":"Specifying model boundary conditions","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"To specify non-default boundary conditions, a named tuple of FieldBoundaryConditions objects is passed to the keyword argument boundary_conditions in the NonhydrostaticModel constructor. The keys of boundary_conditions indicate the field to which the boundary condition is applied. Below, non-default boundary conditions are imposed on the u-velocity and tracer c.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> topology = (Periodic, Periodic, Bounded);\n\njulia> grid = RectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1), topology=topology);\n\njulia> u_bcs = FieldBoundaryConditions(top = ValueBoundaryCondition(+0.1),\n                                       bottom = ValueBoundaryCondition(-0.1));\n\njulia> c_bcs = FieldBoundaryConditions(top = ValueBoundaryCondition(20.0),\n                                       bottom = GradientBoundaryCondition(0.01));\n\njulia> model = NonhydrostaticModel(grid=grid, boundary_conditions=(u=u_bcs, c=c_bcs), tracers=:c)\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 16Ã—16Ã—16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ timestepper: QuasiAdamsBashforth2TimeStepper\nâ”œâ”€â”€ tracers: c\nâ”œâ”€â”€ closure: Nothing\nâ”œâ”€â”€ buoyancy: Nothing\nâ””â”€â”€ coriolis: Nothing\n\njulia> model.velocities.u\n16Ã—16Ã—16 Field{Face, Center, Center} on RectilinearGrid on CPU\nâ”œâ”€â”€ grid: 16Ã—16Ã—16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ boundary conditions: FieldBoundaryConditions\nâ”‚   â””â”€â”€ west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Value, top: Value, immersed: ZeroFlux\nâ””â”€â”€ data: 22Ã—22Ã—22 OffsetArray(::Array{Float64, 3}, -2:19, -2:19, -2:19) with eltype Float64 with indices -2:19Ã—-2:19Ã—-2:19\n    â””â”€â”€ max=0.0, min=0.0, mean=0.0\n\njulia> model.tracers.c\n16Ã—16Ã—16 Field{Center, Center, Center} on RectilinearGrid on CPU\nâ”œâ”€â”€ grid: 16Ã—16Ã—16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ boundary conditions: FieldBoundaryConditions\nâ”‚   â””â”€â”€ west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Gradient, top: Value, immersed: ZeroFlux\nâ””â”€â”€ data: 22Ã—22Ã—22 OffsetArray(::Array{Float64, 3}, -2:19, -2:19, -2:19) with eltype Float64 with indices -2:19Ã—-2:19Ã—-2:19\n    â””â”€â”€ max=0.0, min=0.0, mean=0.0","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Notice that the specified non-default boundary conditions have been applied at top and bottom of both model.velocities.u and model.tracers.c.","category":"page"},{"location":"model_setup/boundary_conditions/#Immersed-boundary-conditions","page":"Boundary conditions","title":"Immersed boundary conditions","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Immersed boundary conditions are supported experimentally. A no-slip boundary condition is specified with","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> underlying_grid = RectilinearGrid(size=(32, 32, 16), x=(-3, 3), y=(-3, 3), z=(0, 1), topology=(Periodic, Periodic, Bounded));\n\njulia> hill(x, y) = 0.1 + 0.1 * exp(-x^2 - y^2)\nhill (generic function with 1 method)\n\njulia> grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(hill))\n32Ã—32Ã—16 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo:\nâ”œâ”€â”€ immersed_boundary: GridFittedBottom(min(h)=1.00e-01, max(h)=1.98e-01)\nâ”œâ”€â”€ underlying_grid: 32Ã—32Ã—16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ Periodic x âˆˆ [-3.0, 3.0) regularly spaced with Î”x=0.1875\nâ”œâ”€â”€ Periodic y âˆˆ [-3.0, 3.0) regularly spaced with Î”y=0.1875\nâ””â”€â”€ Bounded  z âˆˆ [0.0, 1.0]  regularly spaced with Î”z=0.0625\n\njulia> velocity_bcs = FieldBoundaryConditions(immersed=ValueBoundaryCondition(0.0));\n\njulia> model = NonhydrostaticModel(; grid, boundary_conditions=(u=velocity_bcs, v=velocity_bcs, w=velocity_bcs));\n\njulia> model.velocities.w.boundary_conditions.immersed\nImmersedBoundaryCondition:\nâ”œâ”€â”€ west: ValueBoundaryCondition: 0.0\nâ”œâ”€â”€ east: ValueBoundaryCondition: 0.0\nâ”œâ”€â”€ south: ValueBoundaryCondition: 0.0\nâ”œâ”€â”€ north: ValueBoundaryCondition: 0.0\nâ”œâ”€â”€ bottom: Nothing\nâ””â”€â”€ top: Nothing","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"An ImmersedBoundaryCondition encapsulates boundary conditions on each potential boundary-facet of a boundary-adjacent cell. Boundary conditions on specific faces of immersed-boundary-adjacent cells may also be specified by manually building an ImmersedBoundaryCondition:","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> bottom_drag_bc = ImmersedBoundaryCondition(bottom=ValueBoundaryCondition(0.0))\nImmersedBoundaryCondition:\nâ”œâ”€â”€ west: Nothing\nâ”œâ”€â”€ east: Nothing\nâ”œâ”€â”€ south: Nothing\nâ”œâ”€â”€ north: Nothing\nâ”œâ”€â”€ bottom: ValueBoundaryCondition: 0.0\nâ””â”€â”€ top: Nothing\n\njulia> velocity_bcs = FieldBoundaryConditions(immersed=bottom_drag_bc)\nOceananigans.FieldBoundaryConditions, with boundary conditions\nâ”œâ”€â”€ west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ bottom: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ top: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ””â”€â”€ immersed: ImmersedBoundaryCondition with west=Nothing, east=Nothing, south=Nothing, north=Nothing, bottom=Value, top=Nothing","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"A boundary condition that depends on the fields may be prescribed using the immersed keyword argument in FieldBoundaryConditions. We illustrate field-dependent boundary conditions with an example that imposes linear bottom drag on u on both immersed facets and the bottom boundary of the underlying grid.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"First we create the boundary condition for the grid's bottom:","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> @inline linear_drag(x, y, t, u) = - 0.2 * u\nlinear_drag (generic function with 1 method)\n\njulia> drag_u = FluxBoundaryCondition(linear_drag, field_dependencies=:u)\nFluxBoundaryCondition: ContinuousBoundaryFunction linear_drag at (Nothing, Nothing, Nothing)","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Next, we create the immersed boundary condition by adding the argument z to linear_drag and imposing drag only on \"bottom\" facets of the immersed boundary:","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> @inline immersed_linear_drag(x, y, z, t, u) = - 0.2 * u\nimmersed_linear_drag (generic function with 1 method)\n\njulia> immersed_drag_u = FluxBoundaryCondition(immersed_linear_drag, field_dependencies=:u)\nFluxBoundaryCondition: ContinuousBoundaryFunction immersed_linear_drag at (Nothing, Nothing, Nothing)\n\njulia> u_immersed_bc = ImmersedBoundaryCondition(bottom = immersed_drag_u)\nImmersedBoundaryCondition:\nâ”œâ”€â”€ west: Nothing\nâ”œâ”€â”€ east: Nothing\nâ”œâ”€â”€ south: Nothing\nâ”œâ”€â”€ north: Nothing\nâ”œâ”€â”€ bottom: FluxBoundaryCondition: ContinuousBoundaryFunction immersed_linear_drag at (Nothing, Nothing, Nothing)\nâ””â”€â”€ top: Nothing","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Finally, we combine the two:","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> u_bcs = FieldBoundaryConditions(bottom = drag_u, immersed = u_immersed_bc)\nOceananigans.FieldBoundaryConditions, with boundary conditions\nâ”œâ”€â”€ west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ bottom: FluxBoundaryCondition: ContinuousBoundaryFunction linear_drag at (Nothing, Nothing, Nothing)\nâ”œâ”€â”€ top: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ””â”€â”€ immersed: ImmersedBoundaryCondition with west=Nothing, east=Nothing, south=Nothing, north=Nothing, bottom=Flux, top=Nothing","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"warning: Positional argument requirements\nNote the difference between the arguments required for the function within the bottom boundary condition versus the arguments for the function within the immersed boundary condition. E.g., x, y, t in linear_drag() versus x, y, z, t in immersed_linear_drag().","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"EditURL = \"<unknown>/examples/convecting_plankton.jl\"","category":"page"},{"location":"generated/convecting_plankton/#Plankton-mixing-and-blooming","page":"Convecting plankton","title":"Plankton mixing and blooming","text":"","category":"section"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"In this example, we simulate the mixing of phytoplankton by convection that decreases in time and eventually shuts off, thereby precipitating a phytoplankton bloom. A similar scenario was simulated by Taylor and Ferrari (2011), providing evidence that the \"critical turbulence hypothesis\" explains the explosive bloom of oceanic phytoplankton observed in spring.","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"The phytoplankton in our model are advected, diffuse, grow, and die according to","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"_t P + boldsymbolv   P - Îº Â²P = (Î¼â‚€ exp(z  Î») - m)  P  ","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"where boldsymbolv is the turbulent velocity field, Îº is an isotropic diffusivity,  Î¼â‚€ is the phytoplankton growth rate at the surface, Î» is the scale over which sunlight attenuates away from the surface, and m is the mortality rate of phytoplankton due to viruses and grazing by zooplankton. We use Oceananigans' Forcing abstraction to implement the phytoplankton dynamics described by the right side of the phytoplankton equation above.","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"This example demonstrates","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"How to use a user-defined forcing function to simulate the dynamics of phytoplankton growth in sunlight and grazing by zooplankton.\nHow to set time-dependent boundary conditions.\nHow to use the TimeStepWizard to adapt the simulation time-step.\nHow to use Average to diagnose spatial averages of model fields.","category":"page"},{"location":"generated/convecting_plankton/#Install-dependencies","page":"Convecting plankton","title":"Install dependencies","text":"","category":"section"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"using Pkg\npkg\"add Oceananigans, CairoMakie\"","category":"page"},{"location":"generated/convecting_plankton/#The-grid","page":"Convecting plankton","title":"The grid","text":"","category":"section"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"We use a two-dimensional grid with 64Â² points, 3Â² halo points for high-order advection, 1 m grid spacing, and a Flat y-direction:","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"using Oceananigans\nusing Oceananigans.Units: minutes, hour, hours, day\n\ngrid = RectilinearGrid(size=(64, 64), extent=(64, 64), halo=(3, 3), topology=(Periodic, Flat, Bounded))","category":"page"},{"location":"generated/convecting_plankton/#Boundary-conditions","page":"Convecting plankton","title":"Boundary conditions","text":"","category":"section"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"We impose a surface buoyancy flux that's initially constant and then decays to zero,","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"buoyancy_flux(x, y, t, params) = params.initial_buoyancy_flux * exp(-t^4 / (24 * params.shut_off_time^4))\n\nbuoyancy_flux_parameters = (initial_buoyancy_flux = 1e-8, # mÂ² sâ»Â³\n                                    shut_off_time = 2hours)\n\nbuoyancy_flux_bc = FluxBoundaryCondition(buoyancy_flux, parameters = buoyancy_flux_parameters)","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"The fourth power in the argument of exp above helps keep the buoyancy flux relatively constant during the first phase of the simulation. We produce a plot of this time-dependent buoyancy flux for the visually-oriented,","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"using CairoMakie\nset_theme!(Theme(fontsize = 24, linewidth=2))\n\ntimes = range(0, 12hours, length=100)\n\nfig = Figure(resolution = (800, 300))\nax = Axis(fig[1, 1]; xlabel = \"Time (hours)\", ylabel = \"Surface buoyancy flux (mÂ² sâ»Â³)\")\n\nflux_time_series = [buoyancy_flux(0, 0, t, buoyancy_flux_parameters) for t in times]\nlines!(ax, times ./ hour, flux_time_series)\n\ncurrent_figure() # hide\nfig","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"The buoyancy flux effectively shuts off after 6 hours of simulation time.","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"info: The flux convention in Oceananigans.jl\nFluxes are defined by the direction a quantity is carried: positive velocities produce positive fluxes, while negative velocities produce negative fluxes. Diffusive fluxes are defined with the same convention. A positive flux at the top boundary transports buoyancy upwards, out of the domain. This means that a positive flux of buoyancy at the top boundary reduces the buoyancy of near-surface fluid, causing convection.","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"The initial condition and bottom boundary condition impose the constant buoyancy gradient","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"NÂ² = 1e-4 # sâ»Â²\n\nbuoyancy_gradient_bc = GradientBoundaryCondition(NÂ²)","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"In summary, the buoyancy boundary conditions impose a destabilizing flux at the top and a stable buoyancy gradient at the bottom:","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"buoyancy_bcs = FieldBoundaryConditions(top = buoyancy_flux_bc, bottom = buoyancy_gradient_bc)","category":"page"},{"location":"generated/convecting_plankton/#Phytoplankton-dynamics:-light-dependent-growth-and-uniform-mortality","page":"Convecting plankton","title":"Phytoplankton dynamics: light-dependent growth and uniform mortality","text":"","category":"section"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"We use a simple model for the growth of phytoplankton in sunlight and decay due to viruses and grazing by zooplankton,","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"growing_and_grazing(x, y, z, t, P, params) = (params.Î¼â‚€ * exp(z / params.Î») - params.m) * P\nnothing # hide","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"with parameters","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"plankton_dynamics_parameters = (Î¼â‚€ = 1/day,   # surface growth rate\n                                 Î» = 5,       # sunlight attenuation length scale (m)\n                                 m = 0.1/day) # mortality rate due to virus and zooplankton grazing","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"We tell Forcing that our plankton model depends on the plankton concentration P and the chosen parameters,","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"plankton_dynamics = Forcing(growing_and_grazing, field_dependencies = :P,\n                            parameters = plankton_dynamics_parameters)","category":"page"},{"location":"generated/convecting_plankton/#The-model","page":"Convecting plankton","title":"The model","text":"","category":"section"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"The name \"P\" for phytoplankton is specified in the constructor for NonhydrostaticModel. We additionally specify a fifth-order advection scheme, third-order Runge-Kutta time-stepping, isotropic viscosity and diffusivities, and Coriolis forces appropriate for planktonic convection at mid-latitudes on Earth.","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"model = NonhydrostaticModel(; grid,\n                            advection = UpwindBiasedFifthOrder(),\n                            timestepper = :RungeKutta3,\n                            closure = ScalarDiffusivity(Î½=1e-4, Îº=1e-4),\n                            coriolis = FPlane(f=1e-4),\n                            tracers = (:b, :P), # P for Plankton\n                            buoyancy = BuoyancyTracer(),\n                            forcing = (; P=plankton_dynamics),\n                            boundary_conditions = (; b=buoyancy_bcs))","category":"page"},{"location":"generated/convecting_plankton/#Initial-condition","page":"Convecting plankton","title":"Initial condition","text":"","category":"section"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"We set the initial phytoplankton at P = 1  rmÎ¼M. For buoyancy, we use a stratification that's mixed near the surface and linearly stratified below, superposed with surface-concentrated random noise.","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"mixed_layer_depth = 32 # m\n\nstratification(z) = z < -mixed_layer_depth ? NÂ² * z : - NÂ² * mixed_layer_depth\nnoise(z) = 1e-4 * NÂ² * grid.Lz * randn() * exp(z / 4)\ninitial_buoyancy(x, y, z) = stratification(z) + noise(z)\n\nset!(model, b=initial_buoyancy, P=1)","category":"page"},{"location":"generated/convecting_plankton/#Simulation-with-adaptive-time-stepping,-logging,-and-output","page":"Convecting plankton","title":"Simulation with adaptive time-stepping, logging, and output","text":"","category":"section"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"We build a simulation","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"simulation = Simulation(model, Î”t=2minutes, stop_time=24hours)","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"with a TimeStepWizard that limits the time-step to 2 minutes, and adapts the time-step such that CFL (Courant-Freidrichs-Lewy) number hovers around 1.0,","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"wizard = TimeStepWizard(cfl=1.0, max_change=1.1, max_Î”t=2minutes)\n\nsimulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10))","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"We also add a callback that prints the progress of the simulation,","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"using Printf\n\nprogress(sim) = @printf(\"Iteration: %d, time: %s, Î”t: %s\\n\",\n                        iteration(sim), prettytime(sim), prettytime(sim.Î”t))\n\nsimulation.callbacks[:progress] = Callback(progress, IterationInterval(100))","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"and a basic JLD2OutputWriter that writes velocities and both the two-dimensional and horizontally-averaged plankton concentration,","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"outputs = (w = model.velocities.w,\n           P = model.tracers.P,\n           avg_P = Average(model.tracers.P, dims=(1, 2)))\n\nsimulation.output_writers[:simple_output] =\n    JLD2OutputWriter(model, outputs,\n                     schedule = TimeInterval(20minutes),\n                     filename = \"convecting_plankton.jld2\",\n                     overwrite_existing = true)","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"info: Using multiple output writers\nBecause each output writer is associated with a single output schedule, it often makes sense to use different output writers for different types of output. For example, smaller outputs that consume less disk space may be written more frequently without threatening the capacity of your hard drive. An arbitrary number of output writers may be added to simulation.output_writers.","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"The simulation is set up. Let there be plankton:","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"run!(simulation)","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"Notice how the time-step is reduced at early times, when turbulence is strong, and increases again towards the end of the simulation when turbulence fades.","category":"page"},{"location":"generated/convecting_plankton/#Visualizing-the-solution","page":"Convecting plankton","title":"Visualizing the solution","text":"","category":"section"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"We'd like to a make a plankton movie. First we load the output file and build a time-series of the buoyancy flux,","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"filepath = simulation.output_writers[:simple_output].filepath\n\nw_timeseries = FieldTimeSeries(filepath, \"w\")\nP_timeseries = FieldTimeSeries(filepath, \"P\")\navg_P_timeseries = FieldTimeSeries(filepath, \"avg_P\")\n\ntimes = w_timeseries.times\nbuoyancy_flux_time_series = [buoyancy_flux(0, 0, t, buoyancy_flux_parameters) for t in times]\nnothing # hide","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"and then we construct the x z grid,","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"xw, yw, zw = nodes(w_timeseries)\nxp, yp, zp = nodes(P_timeseries)\nnothing # hide","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"Finally, we animate plankton mixing and blooming,","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"using CairoMakie\n\n@info \"Making a movie about plankton...\"\n\nn = Observable(1)\n\ntitle = @lift @sprintf(\"t = %s\", prettytime(times[$n]))\n\nwâ‚™ = @lift interior(w_timeseries[$n], :, 1, :)\nPâ‚™ = @lift interior(P_timeseries[$n], :, 1, :)\navg_Pâ‚™ = @lift interior(avg_P_timeseries[$n], 1, 1, :)\n\nw_lim = maximum(abs, interior(w_timeseries))\nw_lims = (-w_lim, w_lim)\n\nP_lims = (0.95, 1.1)\n\nfig = Figure(resolution = (1200, 1000))\n\nax_w = Axis(fig[2, 2]; xlabel = \"x (m)\", ylabel = \"z (m)\", aspect = 1)\nax_P = Axis(fig[3, 2]; xlabel = \"x (m)\", ylabel = \"z (m)\", aspect = 1)\nax_b = Axis(fig[2, 3]; xlabel = \"Time (hours)\", ylabel = \"Buoyancy flux (mÂ² sâ»Â³)\", yaxisposition = :right)\n\nax_avg_P = Axis(fig[3, 3]; xlabel = \"Plankton concentration (Î¼M)\", ylabel = \"z (m)\", yaxisposition = :right)\nxlims!(ax_avg_P, 0.85, 1.3)\n\nfig[1, 1:3] = Label(fig, title, tellwidth=false)\n\nhm_w = heatmap!(ax_w, xw, zw, wâ‚™; colormap = :balance, colorrange = w_lims)\nColorbar(fig[2, 1], hm_w; label = \"Vertical velocity (m sâ»Â¹)\", flipaxis = false)\n\nhm_P = heatmap!(ax_P, xp, zp, Pâ‚™; colormap = :matter, colorrange = P_lims)\nColorbar(fig[3, 1], hm_P; label = \"Plankton 'concentration'\", flipaxis = false)\n\nlines!(ax_b, times ./ hour, buoyancy_flux_time_series; linewidth = 1, color = :black, alpha = 0.4)\n\nb_flux_point = @lift Point2(times[$n] / hour, buoyancy_flux_time_series[$n])\nscatter!(ax_b, b_flux_point; marker = :circle, markersize = 16, color = :black)\nlines!(ax_avg_P, avg_Pâ‚™, zp)\n\ncurrent_figure() # hide\nfig","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"And, finally, we record a movie.","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"frames = 1:length(times)\n\n@info \"Making an animation of convecting plankton...\"\n\nrecord(fig, \"convecting_plankton.mp4\", frames, framerate=8) do i\n    msg = string(\"Plotting frame \", i, \" of \", frames[end])\n    print(msg * \" \\r\")\n    n[] = i\nend\nnothing #hide","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"(Image: )","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"","category":"page"},{"location":"generated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"This page was generated using Literate.jl.","category":"page"},{"location":"gallery/#Gallery","page":"Gallery","title":"Gallery","text":"","category":"section"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"Collection of cool movies!","category":"page"},{"location":"gallery/#[Deep-convection](https://www.youtube.com/watch?vkpUrxnKKMjI)","page":"Gallery","title":"Deep convection","text":"","category":"section"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"An idealized simulation of deep convection in the ocean. The simulation employs a resolution of 256x256x128 volumes in a 2x2x1 km horizontally periodic domain. Heat is sucked out of the ocean surface within a cooling disk of radius 600 m at a rate of 800 W/mÂ² which cools the surface water and making it denser. This cold dense water then sinks into the ocean interior, initiating a convective process that penetrates deep into the ocean.","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"This deep convection process can happen when a cold storm passes through warmer waters, which happens for example in the Labrador Sea.","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"The video shows the temperature field and the domain is sliced in half so the convection happening under the cooling disk is clear.","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"(Image: Watch deep convection in action)","category":"page"},{"location":"gallery/#[Free-convection](https://www.youtube.com/watch?vyq4op9h3xcU)","page":"Gallery","title":"Free convection","text":"","category":"section"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"An idealized simulation of free convection in the ocean. The simulation employs a resolution of 256x256x256 volumes in a 100x100x100 m horizontally periodic domain. Heat is sucked out of the ocean surface at a rate of 75 W/mÂ² which cools the surface water and making it denser. This cold dense water then sinks into the ocean interior, initiating a convective process that keeps mixing the upper layer of the ocean. This \"mixed layer\" has a relatively constant temperature and keeps deepening as the surface is cooled.","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"The video shows the temperature field and the domain is sliced in half.","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"(Image: Watch free convection in action)","category":"page"},{"location":"gallery/#[Winds-blowing-over-the-ocean](https://www.youtube.com/watch?vIRncfbvuiy8)","page":"Gallery","title":"Winds blowing over the ocean","text":"","category":"section"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"An idealized simulation of a strong wind stress acting on the surface of a stratified ocean. The simulation employs a resolution of 256x256x256 volumes in a 100x100x100 m horizontally periodic domain. A pretty strong wind stress of 0.1 N/mÂ² is applied in the x direction which mechanically mixes the upper layer of the ocean. This leads to a \"mixed layer\" of constant temperature near the surface of the ocean. You can also see the onset of Kelvin-Helmholtz instabilities as the mechanical mixing sets in.","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"The video shows the temperature field in the top 25 meters and the domain is sliced in half for visualization. The line plots show the horizontally averaged temperature profile (top right), horizontally averaged turbulent kinetic energy (middle right), and the horizontally averaged buoyancy flux (or temperature flux).","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"(Image: Watch winds blowing over the ocean)","category":"page"},{"location":"gallery/#[Free-convection-with-wind-stress](https://www.youtube.com/watch?vob6OMQgPfI4)","page":"Gallery","title":"Free convection with wind stress","text":"","category":"section"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"An idealized simulation of a strong wind stress acting on the surface of a stratified ocean along with a cooling flux that sucks heat out of the surface. The simulation employs a resolution of 256x256x256 volumes in a 100x100x100 m horizontally periodic domain. A pretty strong wind stress of 0.1 N/mÂ² is applied in the x direction which mechanically mixes the upper layer of the ocean. Also, heat is sucked out of the ocean surface at a rate of 75 W/mÂ² which cools the surface water and making it denser. This cold dense water then sinks into the ocean interior, initiating a convective process that keeps mixing the upper layer of the ocean. This leads to a \"mixed layer\" of constant temperature near the surface of the ocean. You can also see the onset of Kelvin-Helmholtz instabilities as the mechanical mixing sets in.","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"The video shows the temperature field and the domain is sliced in half for visualization. The line plots show the horizontally averaged temperature profile (top right), horizontally averaged turbulent kinetic energy (middle right), and the horizontally averaged buoyancy flux (or temperature flux). The unusual periodic prism colormap is used to show the fine details at the surface as it cools and the layers of different temperatures (the isopycnals) being perturbed by internal waves.","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"(Image: Watch free convection with wind stress in action)","category":"page"},{"location":"physics/shallow_water_model/#Shallow-water-model","page":"Shallow water model","title":"Shallow water model","text":"","category":"section"},{"location":"physics/shallow_water_model/","page":"Shallow water model","title":"Shallow water model","text":"The ShallowWaterModel simulates the shallow water dynamics for a fluid of constant density but with varying fluid depth h(x y t) and whose velocity only varies in the horizontal, boldsymbolu(x y t) = u(x y t) boldsymbolhat x + v(x y t) boldsymbolhat y.","category":"page"},{"location":"physics/shallow_water_model/","page":"Shallow water model","title":"Shallow water model","text":"ShallowWaterModel allows users to prescribe the shallow water dynamics using two different formulations: VectorInvariantFormulation() and ConservativeFormulation().","category":"page"},{"location":"physics/shallow_water_model/","page":"Shallow water model","title":"Shallow water model","text":"The VectorInvariantFormulation uses the horizontal velocity boldsymbolu and the total depth of the fluid, h, as the dynamical variables. Furthermore, the advective terms are rewritten via the vector identity:","category":"page"},{"location":"physics/shallow_water_model/","page":"Shallow water model","title":"Shallow water model","text":"boldsymbolu boldsymbolcdot boldsymbolnabla boldsymbolu = (boldsymbolnabla times boldsymbolu) times boldsymbolu + boldsymbolnabla left( frac12 boldsymbolu boldsymbolcdot boldsymbolu right )  ","category":"page"},{"location":"physics/shallow_water_model/","page":"Shallow water model","title":"Shallow water model","text":"Thus, the shallow water dynamics in vector-invariant form become:","category":"page"},{"location":"physics/shallow_water_model/","page":"Shallow water model","title":"Shallow water model","text":"beginalign\n  partial_t boldsymbolu + (zeta boldsymbolhat z + boldsymbolf)  timesboldsymbolu  = \n  - boldsymbolnabla left  g (h +b) + frac12 boldsymbolu cdot boldsymbolu right    \n  partial_t h + boldsymbolnabla boldsymbolcdot (boldsymbolu h)  = 0  \nendalign","category":"page"},{"location":"physics/shallow_water_model/","page":"Shallow water model","title":"Shallow water model","text":"where zeta(x y t) =  partial_x v - partial_y u is the vertical component of the relative vorticity.","category":"page"},{"location":"physics/shallow_water_model/","page":"Shallow water model","title":"Shallow water model","text":"The elevation of the bottom bathymetry, measured with respect to the free-surface at rest, is b(x y). The free-surface elevation eta is then:","category":"page"},{"location":"physics/shallow_water_model/","page":"Shallow water model","title":"Shallow water model","text":"eta(x y t) = h(x y t) + b(x y)  ","category":"page"},{"location":"physics/shallow_water_model/","page":"Shallow water model","title":"Shallow water model","text":"The ConservativeFormulation() uses the volume transport along each direction boldsymbolu h = (u h v h) and the total depth of the fluid h as the dynamical variables.  The shallow water dynamics in conservative form is:","category":"page"},{"location":"physics/shallow_water_model/","page":"Shallow water model","title":"Shallow water model","text":"beginalign\n  partial_t (boldsymbolu h) + boldsymbolnabla boldsymbolcdot left ( boldsymbolu boldsymbolu h right ) + boldsymbolf times (boldsymbolu h)  = - g h boldsymbolnabla left ( h + b right )  \n  partial_t h + boldsymbolnabla boldsymbolcdot (boldsymbolu h)  = 0  \nendalign","category":"page"},{"location":"physics/shallow_water_model/","page":"Shallow water model","title":"Shallow water model","text":"where boldsymbolnabla boldsymbolcdot left ( boldsymbolu boldsymbolu h right ) denotes a vector whose components are boldsymbolnabla boldsymbolcdot (boldsymbolu boldsymbolu h)_i = boldsymbolnabla boldsymbolcdot (u_i boldsymbolu h). We can retrieve the flow velocities by dividing the corresponding transport by the fluid's height, e.g., v = vh / h.","category":"page"},{"location":"model_setup/background_fields/#Background-fields","page":"Background fields","title":"Background fields","text":"","category":"section"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"BackgroundFields are velocity and tracer fields around which the resolved velocity and tracer fields evolve. In Oceananigans, only the advective terms associated with the interaction between background and resolved fields are included. For example, tracer advection is described by","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"boldsymbolnabla boldsymbolcdot left ( boldsymbolv c right )  ","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"where boldsymbolv is the resolved velocity field and c is the resolved tracer field corresponding to model.tracers.c. ","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"When a background field C is provided, the tracer advection term becomes","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"boldsymbolnabla boldsymbolcdot left ( boldsymbolv c right ) \n    + boldsymbolnabla boldsymbolcdot left ( boldsymbolv C right )  ","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"When both a background field velocity field boldsymbolU and a background tracer field C are provided, then the tracer advection term becomes","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"boldsymbolnabla boldsymbolcdot left ( boldsymbolv c right ) \n    + boldsymbolnabla boldsymbolcdot left ( boldsymbolv C right )\n    + boldsymbolnabla boldsymbolcdot left ( boldsymbolU c right )  ","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"Notice that the term boldsymbolnabla boldsymbolcdot left ( boldsymbolU C right )  is neglected: only the terms describing the advection of resolved tracer by the background  velocity field and the advection of background tracer by the resolved velocity field are included. An analogous statement holds for the advection of background momentum by the resolved velocity field. Other possible terms associated with the Coriolis force, buoyancy, turbulence closures, and surface waves acting on background fields are neglected.","category":"page"},{"location":"model_setup/background_fields/#Specifying-background-fields","page":"Background fields","title":"Specifying background fields","text":"","category":"section"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"BackgroundFields are defined by functions of (x y z t) and optional parameters. A  simple example is","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"using Oceananigans\n\nU(x, y, z, t) = 0.2 * z\n\ngrid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))\n\nmodel = NonhydrostaticModel(grid = grid, background_fields = (u=U,))\n\nmodel.background_fields.velocities.u\n\n# output\nFunctionField located at (Face, Center, Center)\nâ”œâ”€â”€ func: U (generic function with 1 method)\nâ”œâ”€â”€ grid: 1Ã—1Ã—1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ clock: Clock(time=0 seconds, iteration=0)\nâ””â”€â”€ parameters: nothing","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"BackgroundFields are specified by passing them to the kwarg background_fields in the NonhydrostaticModel constructor. The kwarg background_fields expects a NamedTuple of fields, which are internally sorted into velocities and tracers, wrapped in FunctionFields, and assigned their appropriate locations.","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"BackgroundFields with parameters require using the BackgroundField wrapper:","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"using Oceananigans\n\nparameters = (Î±=3.14, N=1.0, f=0.1)\n\n# Background fields are defined via function of x, y, z, t, and optional parameters\nU(x, y, z, t, Î±) = Î± * z\nB(x, y, z, t, p) = - p.Î± * p.f * y + p.N^2 * z \n\nU_field = BackgroundField(U, parameters=parameters.Î±)\nB_field = BackgroundField(B, parameters=parameters)\n\n# output\nBackgroundField{typeof(B), NamedTuple{(:Î±, :N, :f), Tuple{Float64, Float64, Float64}}}\nâ”œâ”€â”€ func: B (generic function with 1 method)\nâ””â”€â”€ parameters: (Î± = 3.14, N = 1.0, f = 0.1)","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"When inserted into NonhydrostaticModel, we get","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))\n\nmodel = NonhydrostaticModel(grid = grid, background_fields = (u=U_field, b=B_field),\n                            tracers=:b, buoyancy=BuoyancyTracer())\n\nmodel.background_fields.tracers.b\n\n# output\nFunctionField located at (Center, Center, Center)\nâ”œâ”€â”€ func: B (generic function with 1 method)\nâ”œâ”€â”€ grid: 1Ã—1Ã—1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ clock: Clock(time=0 seconds, iteration=0)\nâ””â”€â”€ parameters: (Î± = 3.14, N = 1.0, f = 0.1)","category":"page"},{"location":"model_setup/callbacks/#Callbacks","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"Callbacks can be used to execute an arbitrary user defined function on the simulation at user  defined times, or between every time stepper sub-step for state_callbacks.","category":"page"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"For example, we can specify a callback which displays the run time every 2 iterations:","category":"page"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"DocTestSetup = quote\n    using Oceananigans\nend","category":"page"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"using Oceananigans\n\nmodel = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)))\n\nsimulation = Simulation(model, Î”t=1, stop_iteration=10)\n\nshow_time(sim) = @info \"Time is $(prettytime(sim.model.clock.time))\"\n\nsimulation.callbacks[:total_A] = Callback(show_time, IterationInterval(2))\n\nrun!(simulation)","category":"page"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"State callbacks are useful for inter step modification of the model state (for example if you wanted to manually modify the tendency fields). Irrespective of the specified scheduling state callbacks are executed at every sub-step. As an example we can manually add to the tendency field of one of the velocity components, here I've chosen the :u field using parameters:","category":"page"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"using Oceananigans\n\nmodel = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)))\n\nfunction modify_tracer(model, params)\n    model.timestepper.Gâ¿[params.c] .+= params.Î´\nend\n\nmodel.state_callbacks[:modify_u] = Callback(modify_tracer, IterationInterval(1), (c = :u, Î´ = 1))\n\nsimulation = Simulation(model, Î”t=1, stop_iteration=10)\n\nrun!(simulation)\n\n@info model.velocities.u","category":"page"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"Here there is no forcing, but due to the callback the velocity is increased. ","category":"page"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"This is a redundant example and here for illustration only, it could be implemented better with a simple forcing function.","category":"page"},{"location":"model_setup/callbacks/#Functions","page":"Callbacks","title":"Functions","text":"","category":"section"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"Callback functions can only take one or two parameters sim - a simulation, or model for state callbacks, and optionally may also accept a NamedTuple of parameters.","category":"page"},{"location":"model_setup/callbacks/#Scheduling","page":"Callbacks","title":"Scheduling","text":"","category":"section"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"The time that callbacks are called at are specified by schedule functions which can be:","category":"page"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"IterationInterval : runs every n iterations\nTimeInterval : runs every ns of model run time\nSpecifiedTimes : runs at the specified times\nWallTimeInterval : runs every ns of wall time","category":"page"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"DocTestSetup = quote\n    using Oceananigans\nend","category":"page"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"using Oceananigans, Oceananigans.Units\n\nmodel = NonhydrostaticModel(grid=RectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1)))\n\nsimulation = Simulation(model, Î”t=1, stop_iteration=1)\n\nsimulation.output_writers[:checkpointer] = Checkpointer(model, schedule=TimeInterval(5days), prefix=\"model_checkpoint\")\n\nrun!(simulation)","category":"page"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"The default options should provide checkpoint files that are easy to restore from in most cases. For more advanced options and features, see Checkpointer.","category":"page"},{"location":"model_setup/callbacks/#Picking-up-a-simulation-from-a-checkpoint-file","page":"Callbacks","title":"Picking up a simulation from a checkpoint file","text":"","category":"section"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"Picking up a simulation from a checkpoint requires the original script that was used to generate the checkpoint data. Change the first instance of run! in the script to take pickup=true:","category":"page"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"simulation.stop_iteration = 2\n\nrun!(simulation, pickup=true)","category":"page"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"which finds the latest checkpoint file in the current working directory (in this trivial case, this is the checkpoint associated with iteration 0), loads prognostic fields and their tendencies from file, resets the model clock and iteration, and updates the model auxiliary state before starting the time-stepping loop.","category":"page"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"Use pickup=iteration, where iteration is an Integer, to pick up from a specific iteration. Or, use pickup=filepath, where filepath is a string, to pickup from a specific file located at filepath.","category":"page"},{"location":"physics/coriolis_forces/#Coriolis-forces","page":"Coriolis forces","title":"Coriolis forces","text":"","category":"section"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"The Coriolis model controls the manifestation of the term boldsymbolf times boldsymbolv in the momentum equation.","category":"page"},{"location":"physics/coriolis_forces/#f-plane-approximation","page":"Coriolis forces","title":"f-plane approximation","text":"","category":"section"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"Under an f-plane approximation[3] the reference frame in which the momentum and tracer equations are solved rotates at a constant rate.","category":"page"},{"location":"physics/coriolis_forces/#The-traditional-f-plane-approximation","page":"Coriolis forces","title":"The traditional f-plane approximation","text":"","category":"section"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"In the traditional f-plane approximation, the coordinate system rotates around a vertical axis such that","category":"page"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"    boldsymbolf = f boldsymbolhat z  ","category":"page"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"where f is constant and determined by the user.","category":"page"},{"location":"physics/coriolis_forces/#The-arbitrary-axis-constant-Coriolis-approximation","page":"Coriolis forces","title":"The arbitrary-axis constant-Coriolis approximation","text":"","category":"section"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"In this approximation, the coordinate system rotates around an axis in the xyz-plane, such that","category":"page"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"    boldsymbolf = f_x boldsymbolhat x + f_y boldsymbolhat y + f_z boldsymbolhat z  ","category":"page"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"where f_x, f_y, and f_z are constants determined by the user.","category":"page"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"[3]: The f-plane approximation is used to model the effects of Earth's rotation on anisotropic    fluid motion in a plane tangent to the Earth's surface. In this case, the projection of    the Earth's rotation vector at latitude varphi and onto a coordinate system in which    x y z correspond to the directions east, north, and up is   boldsymbolf approx frac4 pitextday left ( cos varphi boldsymbolhat y + sin varphi boldsymbolhat z right )     where the Earth's rotation rate is approximately 2 pi  textday. The traditional    f-plane approximation neglects the y-component of this projection, which is appropriate    for fluid motions with large horizontal-to-vertical aspect ratios.","category":"page"},{"location":"physics/coriolis_forces/#\\beta-plane-approximation","page":"Coriolis forces","title":"beta-plane approximation","text":"","category":"section"},{"location":"physics/coriolis_forces/#The-traditional-\\beta-plane-approximation","page":"Coriolis forces","title":"The traditional beta-plane approximation","text":"","category":"section"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"Under the traditional beta-plane approximation, the rotation axis is vertical as for the f-plane approximation, but f is expanded in a Taylor series around a central latitude  such that","category":"page"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"    boldsymbolf = left ( f_0 + beta y right ) boldsymbolhat z  ","category":"page"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"where f_0 is the planetary vorticity at some central latitude, and beta is the planetary vorticity gradient. The beta-plane model is not periodic in y and thus can be used only in domains that are bounded in the y-direction.","category":"page"},{"location":"physics/coriolis_forces/#The-non-traditional-\\beta-plane-approximation","page":"Coriolis forces","title":"The non-traditional beta-plane approximation","text":"","category":"section"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"The non-traditional beta-plane approximation accounts for the latitudinal variation of both the locally vertical and the locally horizontal components of the rotation vector","category":"page"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"    boldsymbolf = left 2Omegacosvarphi_0 left( 1 -  fraczR right) + gamma y right boldsymbolhat y\n           + left 2Omegasinvarphi_0 left( 1 + 2fraczR right) + beta  y right boldsymbolhat z  ","category":"page"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"as can be found in the paper by Paul J Dellar (2011) where  beta = 2 Omega cos varphi_0  R and gamma = -4 Omega sin varphi_0  R.","category":"page"},{"location":"model_setup/coriolis/#Coriolis","page":"Coriolis (rotation)","title":"Coriolis","text":"","category":"section"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"The Coriolis option determines whether the fluid experiences the effect of the Coriolis force, or rotation. Currently three options are available: no rotation, f-plane, and beta-plane.","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"info: Coriolis vs. rotation\nIf you are wondering why this option is called \"Coriolis\" it is because rotational effects could include the Coriolis and centripetal forces, both of which arise in non-inertial reference frames. But here the model only considers the Coriolis force.","category":"page"},{"location":"model_setup/coriolis/#No-rotation","page":"Coriolis (rotation)","title":"No rotation","text":"","category":"section"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"By default there is no rotation. This can be made explicit by passing coriolis = nothing to a model constructor.","category":"page"},{"location":"model_setup/coriolis/#Traditional-f-plane","page":"Coriolis (rotation)","title":"Traditional f-plane","text":"","category":"section"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"To set up an f-plane with, for example, Coriolis parameter f = 10^-4 texts^-1","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"DocTestSetup = quote\n    using Oceananigans\nend","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"julia> coriolis = FPlane(f=1e-4)\nFPlane{Float64}(f=0.0001)","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"An f-plane can also be specified at some latitude on a spherical planet with a planetary rotation rate. For example, to specify an f-plane at a latitude of varphi = 45textN on Earth which has a rotation rate of Omega = 7292115 times 10^-5 texts^-1","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"julia> coriolis = FPlane(rotation_rate=7.292115e-5, latitude=45)\nFPlane{Float64}(f=0.000103126)","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"in which case the value of f is given by 2Omegasinvarphi.","category":"page"},{"location":"model_setup/coriolis/#Coriolis-term-for-constant-rotation-in-a-Cartesian-coordinate-system","page":"Coriolis (rotation)","title":"Coriolis term for constant rotation in a Cartesian coordinate system","text":"","category":"section"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"One can use ConstantCartesianCoriolis to set up a Coriolis acceleration term where the Coriolis parameter is constant and the rotation axis is arbitrary. For example, with boldsymbolf = (0 f_y f_z) = (0 2 1) times 10^-4 texts^-1,","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"julia> coriolis = ConstantCartesianCoriolis(fx=0, fy=2e-4, fz=1e-4)\nConstantCartesianCoriolis{Float64}: fx = 0.00e+00, fy = 2.00e-04, fz = 1.00e-04","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"Or alternatively, the same result can be achieved by specifying the magnitude of the Coriolis frequency f and the rotation_axis. So another way to get a Coriolis acceleration with the same values is:","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"julia> rotation_axis = (0, 2e-4, 1e-4)./âˆš(2e-4^2 + 1e-4^2) # rotation_axis has to be a unit vector\n(0.0, 0.8944271909999159, 0.4472135954999579)\n\njulia> coriolis = ConstantCartesianCoriolis(f=âˆš(2e-4^2+1e-4^2), rotation_axis=rotation_axis)\nConstantCartesianCoriolis{Float64}: fx = 0.00e+00, fy = 2.00e-04, fz = 1.00e-04","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"An f-plane with non-traditional Coriolis terms can also be specified at some latitude on a spherical planet with a planetary rotation rate. For example, to specify an f-plane at a latitude of varphi = 45textN on Earth which has a rotation rate of Omega = 7292115 times 10^-5 texts^-1","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"julia> coriolis = ConstantCartesianCoriolis(rotation_rate=7.292115e-5, latitude=45)\nConstantCartesianCoriolis{Float64}: fx = 0.00e+00, fy = 1.03e-04, fz = 1.03e-04","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"in which case f_z = 2Omegasinvarphi and f_y = 2Omegacosvarphi.","category":"page"},{"location":"model_setup/coriolis/#Traditional-\\beta-plane","page":"Coriolis (rotation)","title":"Traditional beta-plane","text":"","category":"section"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"To set up a beta-plane the background rotation rate f_0 and the beta parameter must be specified. For example, a beta-plane with f_0 = 10^-4 texts^-1 and beta = 15 times 10^-11 texts^-1textm^-1 can be set up with","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"julia> coriolis = BetaPlane(fâ‚€=1e-4, Î²=1.5e-11)\nBetaPlane{Float64}(fâ‚€=0.0001, Î²=1.5e-11)","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"Alternatively, a beta-plane can also be set up at some latitude on a spherical planet with a planetary rotation rate and planetary radius. For example, to specify a beta-plane at a latitude of varphi = 10^circS on Earth which has a rotation rate of Omega = 7292115 times 10^-5 texts^-1 and a radius of R = 6371 textkm","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"julia> coriolis = BetaPlane(rotation_rate=7.292115e-5, latitude=-10, radius=6371e3)\nBetaPlane{Float64}(fâ‚€=-2.53252e-5, Î²=2.25438e-11)","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"in which case f_0 = 2Omegasinvarphi and beta = 2Omegacosvarphi  R.","category":"page"},{"location":"model_setup/coriolis/#Non-traditional-\\beta-plane","page":"Coriolis (rotation)","title":"Non-traditional beta-plane","text":"","category":"section"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"A non-traditional beta-plane requires either 5 parameters (by default Earth's radius and rotation rate are used):","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"julia> NonTraditionalBetaPlane(fz=1e-4, fy=2e-4, Î²=4e-11, Î³=-8e-11)\nNonTraditionalBetaPlane{Float64}(fz = 1.00e-04, fy = 2.00e-04, Î² = 4.00e-11, Î³ = -8.00e-11, R = 6.37e+06)","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"or the rotation rate, radius, and latitude:","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"julia> NonTraditionalBetaPlane(rotation_rate=5.31e-5, radius=252.1e3, latitude=10)\nNonTraditionalBetaPlane{Float64}(fz = 1.84e-05, fy = 1.05e-04, Î² = 4.15e-10, Î³ = -1.46e-10, R = 2.52e+05)","category":"page"},{"location":"numerical_implementation/boundary_conditions/#numerical_bcs","page":"Boundary conditions","title":"Numerical implementation of boundary conditions","text":"","category":"section"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"We adopt a mixed approach for implementing boundary conditions that uses both halo regions and \"direct\" imposition of boundary conditions, depending on the condition prescribed.","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"We illustrate how boundary conditions are implemented by considering the tracer equation","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"    beginalign\n    partial_t c = - boldsymbolv boldsymbolcdot boldsymbolnabla c\n                   - boldsymbolnabla boldsymbolcdot boldsymbolq_c\n                   + F_c  \n    labeleqtracer\n    endalign","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"where boldsymbolq_c is the diffusive flux of c and F_c is an arbitrary source term.","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"See Model setup: boundary conditions for how to create and use these boundary conditions in Oceananigans.","category":"page"},{"location":"numerical_implementation/boundary_conditions/#Gradient-boundary-conditions","page":"Boundary conditions","title":"Gradient boundary conditions","text":"","category":"section"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Users impose gradient boundary conditions by prescribing the gradient gamma of a field  c across an external boundary partial Omega_b. The prescribed gradient gamma  may be a constant, discrete array of values, or an arbitrary function. The gradient boundary  condition is enforced setting the value of halo points located outside the domain interior  such that","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"    beginequation\n    labeleqgradient-bc\n    hatboldsymboln boldsymbolcdot boldsymbolnabla c _partial Omega_b = gamma  \n    endequation","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"where hatboldsymboln is the vector normal to partial Omega_b.","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Across the bottom boundary in z, for example, this requires that","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"    beginequation\n    labeleqlinear-extrapolation\n    c_i j 0 = c_i j 1 + gamma_i j 1 tfrac12 left ( Delta z_i j 1 + Delta z_i j 0 right )  \n    endequation","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"where Delta z_i j 1 = Delta z_i j 0 are the heights of the finite volume at i j and k=1 and k=0. This prescription implies that the z-derivative of c across the boundary at k=1 is","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"    beginequation\n    partial_z c  _i j 1 equiv\n        fracc_i j 1 - c_i j 0tfrac12 left ( Delta z_i j 1 + Delta z_i j 0 right )\n            = gamma_i j 1  \n    endequation","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"as prescribed by the user.","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Gradient boundary conditions are represented by the Gradient type.","category":"page"},{"location":"numerical_implementation/boundary_conditions/#Value-boundary-conditions","page":"Boundary conditions","title":"Value boundary conditions","text":"","category":"section"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Users impose value boundary conditions by prescribing c^b, the value of c on the external boundary partial Omega_b. The value c^b may be a constant, array of discrete values, or an arbitrary function. To enforce a value boundary condition, the gradient associated with the difference between c^b and c at boundary-adjacent nodes is diagnosed and used to set the value of the c halo point located outside the boundary.","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"At the bottom boundary in z, for example, this means that the gradient of c is determined by","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"    beginequation\n    gamma = fracc_i j 1 - c^b_i j 1tfrac12 Delta z_i j 1  \n    endequation","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"which is then used to set the halo point c_i j 0 via linear extrapolation.","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Value boundary conditions are represented by the Value type.","category":"page"},{"location":"numerical_implementation/boundary_conditions/#Flux-boundary-conditions","page":"Boundary conditions","title":"Flux boundary conditions","text":"","category":"section"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Users impose flux boundary conditions by prescribing the flux q_c  _b of c across the external boundary partial Omega_b. The flux q_c  _b may be a constant, array  of discrete values, or arbitrary function. To explain how flux boundary conditions are imposed  in Oceananigans.jl, we note that the average of the tracer conservation equation over a finite  volume yields","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"    beginequation\n    labeleqdcdt\n    partial_t c_i j k = - frac1V_i j k oint_partial Omega_i j k (boldsymbolv c + boldsymbolq_c) \n                                                     boldsymbolcdot hatboldsymboln   mathrmd S\n                             + frac1V_i j k int_V_i j k F_c  mathrmd V  \n    endequation","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"where the surface integral over partial Omega_i j k averages the flux of c across  the six faces of the finite volume. The right-hand-side of \\eqref{eq:dc/dt} above is denoted as  G_c _i j k.","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"An external boundary of a finite volume is associated with a no-penetration condition such that hatboldsymboln boldsymbolcdot boldsymbolv  _partial Omega_b = 0, where  hatboldsymboln is the vector normal to partial Omega_b. Furthermore, the closures  currently available in Oceananigans.jl have the property that boldsymbolq_c propto boldsymbolnabla c. Thus setting hatboldsymboln boldsymbolcdot boldsymbolnabla c  _partial Omega_b = 0  on the external boundary implies that the total flux of c across the external boundary is","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"    beginequation\n    hatboldsymboln boldsymbolcdot left ( boldsymbolv c + boldsymbolq_c right ) _partial Omega_b = 0  \n    endequation","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Oceananigans.jl exploits this fact to define algorithm that prescribe fluxes across external  boundaries partial Omega_b:","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Impose a constant gradient hatboldsymboln boldsymbolcdot boldsymbolnabla c   _partial Omega_b = 0 across external boundaries via using halo points (similar  to \\eqref{eq:gradient-bc}), which ensures that the evaluation of G_c in boundary-adjacent cells does not include fluxes across the external boundary, and;\nAdd the prescribed flux to the boundary-adjacent volumes prior to calculating G_c:  G_c  _b = G_c  _b - fracA_bV_b q_c  _b  textsign(hatboldsymboln),  where G_c  _b denotes values of G_c in boundary-adjacent volumes, q_c  _b  is the flux prescribed along the boundary, V_b is the volume of the boundary-adjacent  cell, and A_b is the area of the external boundary of the boundary-adjacent cell.\nThe factor textsign(hatboldsymboln) is -1 and +1 on \"left\" and \"right\"  boundaries, and accounts for the fact that a positive flux on a left boundary where  textsign(hatboldsymboln) = -1 implies an \"inward\" flux of c that increases  interior values of c, whereas a positive flux on a right boundary where  textsign(hatboldsymboln) = 1 implies an \"outward\" flux that decreases interior values of c.","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Flux boundary conditions are represented by the Flux type.","category":"page"},{"location":"numerical_implementation/pressure_decomposition/#pressure_decomposition","page":"Pressure decomposition","title":"Pressure decomposition","text":"","category":"section"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"In the numerical implementation of the momentum equations, the kinematic pressure p is split into \"hydrostatic\" and \"non-hydrostatic\" parts via","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"    beginequation\n    labeleqpressure\n    p(boldsymbolx t) = p_texttotal hydrostatic(boldsymbolx t) + p_rmnon(boldsymbolx t)  \n    endequation","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"The hydrostatic pressure component in \\eqref{eq:pressure} is defined so that the vertical component of its gradient balances gravity:","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"    beginalign\n    partial_z p_texttotal hydrostatic  = - g left ( 1 + fracrho_*rho_0 + fracrhorho_0 right )  \n    endalign","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"Above, we use the notation introduced in the Boussinesq approximation section.","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"We can further split the hydrostatic pressure component into","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"    beginalign\n    p_texttotal hydrostatic(boldsymbolx t) = p_*(z) + p_rmhyd(boldsymbolx t)  \n    endalign","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"i.e., a component that only varies in z (p_*) and a \"hydrostatic anomaly\" (p_rmhyd) defined so that","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"    beginalign\n    partial_z p_*  = - g left ( 1 + fracrho_*rho_0 right )  \n    partial_z p_rmhyd  = underbrace- g fracrhorho_0_= b  \n    endalign","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"Doing so, the gradient of the kinematic pressure becomes:","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"    beginalign\n    boldsymbolnabla p  = boldsymbolnabla p_rmnon + boldsymbolnabla_h p_rmhyd + ( partial_z p_* + partial_z p_rmhyd ) boldsymbolhat z \n    endalign","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"where boldsymbolnabla_h equiv boldsymbolhat x partial_x +  boldsymbolhat y partial_y is the horizontal gradient.","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"Under this pressure decomposition, the kinematic pressure gradient that appears in the momentum equations (after we've employed the the Boussinesq approximation) combines with the gravity force to give:","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"    beginalign\n    boldsymbolnabla p + g fracrhorho_0 hat boldsymbolz = boldsymbolnabla p_rmnon + boldsymbolnabla_h p_rmhyd  \n    endalign","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"Mathematically, the non-hydrostatic pressure p_rmnon enforces the incompressibility constraint.","category":"page"}]
}

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · Oceananigans.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://clima.github.io/OceananigansDocumentation/stable/appendix/library/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><script src="../../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Oceananigans.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../installation_instructions/">Installation instructions</a></li><li><a class="tocitem" href="../../using_gpus/">Using GPUs</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/one_dimensional_diffusion/">One-dimensional diffusion</a></li><li><a class="tocitem" href="../../generated/geostrophic_adjustment/">Geostrophic adjustment</a></li><li><a class="tocitem" href="../../generated/two_dimensional_turbulence/">Two-dimensional turbulence</a></li><li><a class="tocitem" href="../../generated/internal_wave/">Internal wave</a></li><li><a class="tocitem" href="../../generated/convecting_plankton/">Convecting plankton</a></li><li><a class="tocitem" href="../../generated/ocean_wind_mixing_and_convection/">Ocean wind mixing and convection</a></li><li><a class="tocitem" href="../../generated/langmuir_turbulence/">Langmuir turbulence</a></li><li><a class="tocitem" href="../../generated/eady_turbulence/">Eady turbulence</a></li><li><a class="tocitem" href="../../generated/kelvin_helmholtz_instability/">Kelvin-Helmholtz instability</a></li><li><a class="tocitem" href="../../generated/shallow_water_Bickley_jet/">Shallow water Bickley jet</a></li><li><a class="tocitem" href="../../generated/horizontal_convection/">Horizontal convection</a></li><li><a class="tocitem" href="../../generated/tilted_bottom_boundary_layer/">Tilted bottom boundary layer</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Physics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../physics/notation/">Coordinate system and notation</a></li><li><a class="tocitem" href="../../physics/boussinesq/">Boussinesq approximation</a></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label"><code>NonhydrostaticModel</code></span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../physics/nonhydrostatic_model/">Nonhydrostatic model</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-4" type="checkbox"/><label class="tocitem" for="menuitem-5-4"><span class="docs-label"><code>HydrostaticFreeSurfaceModel</code></span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../physics/hydrostatic_free_surface_model/">Hydrostatic model with a free surface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-5" type="checkbox"/><label class="tocitem" for="menuitem-5-5"><span class="docs-label"><code>ShallowWaterModel</code></span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../physics/shallow_water_model/">Shallow water model</a></li></ul></li><li><a class="tocitem" href="../../physics/buoyancy_and_equations_of_state/">Buoyancy models and equations of state</a></li><li><a class="tocitem" href="../../physics/coriolis_forces/">Coriolis forces</a></li><li><a class="tocitem" href="../../physics/turbulence_closures/">Turbulence closures</a></li><li><a class="tocitem" href="../../physics/surface_gravity_waves/">Surface gravity waves and the Craik-Leibovich approximation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Numerical implementation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../numerical_implementation/finite_volume/">Finite volume method</a></li><li><a class="tocitem" href="../../numerical_implementation/spatial_operators/">Spatial operators</a></li><li><a class="tocitem" href="../../numerical_implementation/pressure_decomposition/">Pressure decomposition</a></li><li><a class="tocitem" href="../../numerical_implementation/time_stepping/">Time stepping</a></li><li><a class="tocitem" href="../../numerical_implementation/boundary_conditions/">Boundary conditions</a></li><li><a class="tocitem" href="../../numerical_implementation/poisson_solvers/">Poisson solvers</a></li><li><a class="tocitem" href="../../numerical_implementation/large_eddy_simulation/">Large eddy simulation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Model setup</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_setup/overview/">Overview</a></li><li><a class="tocitem" href="../../model_setup/architecture/">Architecture</a></li><li><a class="tocitem" href="../../model_setup/number_type/">Number type</a></li><li><a class="tocitem" href="../../model_setup/grids/">Grid</a></li><li><a class="tocitem" href="../../model_setup/clock/">Clock</a></li><li><a class="tocitem" href="../../model_setup/coriolis/">Coriolis (rotation)</a></li><li><a class="tocitem" href="../../model_setup/tracers/">Tracers</a></li><li><a class="tocitem" href="../../model_setup/buoyancy_and_equation_of_state/">Buoyancy models and equation of state</a></li><li><a class="tocitem" href="../../model_setup/boundary_conditions/">Boundary conditions</a></li><li><a class="tocitem" href="../../model_setup/forcing_functions/">Forcing functions</a></li><li><a class="tocitem" href="../../model_setup/background_fields/">Background fields</a></li><li><a class="tocitem" href="../../model_setup/turbulent_diffusivity_closures_and_les_models/">Turbulent diffusivity closures and LES models</a></li><li><a class="tocitem" href="../../model_setup/lagrangian_particles/">Lagrangian particles</a></li><li><a class="tocitem" href="../../model_setup/diagnostics/">Diagnostics</a></li><li><a class="tocitem" href="../../model_setup/output_writers/">Output writers</a></li><li><a class="tocitem" href="../../model_setup/checkpointing/">Checkpointing</a></li><li><a class="tocitem" href="../../model_setup/setting_initial_conditions/">Setting initial conditions</a></li></ul></li><li><a class="tocitem" href="../../simulation_tips/">Simulation tips</a></li><li><a class="tocitem" href="../../contributing/">Contributor&#39;s guide</a></li><li><a class="tocitem" href="../../gallery/">Gallery</a></li><li><a class="tocitem" href="../../references/">References</a></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox" checked/><label class="tocitem" for="menuitem-12"><span class="docs-label">Appendix</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../staggered_grid/">Staggered grid</a></li><li><a class="tocitem" href="../fractional_step/">Fractional step method</a></li><li><a class="tocitem" href="../convergence_tests/">Convergence tests</a></li><li><a class="tocitem" href="../benchmarks/">Performance benchmarks</a></li><li class="is-active"><a class="tocitem" href>Library</a><ul class="internal"><li><a class="tocitem" href="#Oceananigans.jl"><span>Oceananigans.jl</span></a></li><li><a class="tocitem" href="#Abstract-operations"><span>Abstract operations</span></a></li><li><a class="tocitem" href="#Advection"><span>Advection</span></a></li><li><a class="tocitem" href="#Architectures"><span>Architectures</span></a></li><li><a class="tocitem" href="#Boundary-conditions"><span>Boundary conditions</span></a></li><li><a class="tocitem" href="#BuoyancyModels"><span>BuoyancyModels</span></a></li><li><a class="tocitem" href="#Coriolis"><span>Coriolis</span></a></li><li><a class="tocitem" href="#Diagnostics"><span>Diagnostics</span></a></li><li><a class="tocitem" href="#Fields"><span>Fields</span></a></li><li><a class="tocitem" href="#Forcings"><span>Forcings</span></a></li><li><a class="tocitem" href="#Grids"><span>Grids</span></a></li><li><a class="tocitem" href="#Immersed-boundaries"><span>Immersed boundaries</span></a></li><li><a class="tocitem" href="#Lagrangian-particle-tracking"><span>Lagrangian particle tracking</span></a></li><li><a class="tocitem" href="#Logger"><span>Logger</span></a></li><li><a class="tocitem" href="#Models"><span>Models</span></a></li><li><a class="tocitem" href="#Output-readers"><span>Output readers</span></a></li><li><a class="tocitem" href="#Output-writers"><span>Output writers</span></a></li><li><a class="tocitem" href="#Simulations"><span>Simulations</span></a></li><li><a class="tocitem" href="#Solvers"><span>Solvers</span></a></li><li><a class="tocitem" href="#Stokes-drift"><span>Stokes drift</span></a></li><li><a class="tocitem" href="#Time-steppers"><span>Time steppers</span></a></li><li><a class="tocitem" href="#Turbulence-closures"><span>Turbulence closures</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li></ul></li><li><a class="tocitem" href="../function_index/">Function index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Appendix</a></li><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/CliMA/Oceananigans.jl/blob/master/docs/src/appendix/library.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><p>Documenting the public user interface.</p><h2 id="Oceananigans.jl"><a class="docs-heading-anchor" href="#Oceananigans.jl">Oceananigans.jl</a><a id="Oceananigans.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Oceananigans.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Oceananigans" href="#Oceananigans.Oceananigans"><code>Oceananigans.Oceananigans</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Main module for <code>Oceananigans.jl</code> – a Julia software for fast, friendly, flexible, data-driven, ocean-flavored fluid dynamics on CPUs and GPUs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Oceananigans.jl#L1-L4">source</a></section></article><h2 id="Abstract-operations"><a class="docs-heading-anchor" href="#Abstract-operations">Abstract operations</a><a id="Abstract-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-operations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.volume" href="#Oceananigans.AbstractOperations.volume"><code>Oceananigans.AbstractOperations.volume</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">volume = VolumeMetric()</code></pre><p>Instance of <code>VolumeMetric</code> that generates <code>BinaryOperation</code>s between <code>AbstractField</code>s and their cell volumes. Summing this <code>BinaryOperation</code> yields an integral of <code>AbstractField</code> over the domain.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; using Oceananigans.AbstractOperations: volume

julia&gt; grid = RectilinearGrid(size=(2, 2, 2), extent=(1, 2, 3)); c = CenterField(grid);

julia&gt; c .= 1;

julia&gt; c_dV = c * volume
BinaryOperation at (Center, Center, Center)
├── grid: 2×2×2 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo
└── tree:
    * at (Center, Center, Center)
    ├── 2×2×2 Field{Center, Center, Center} on RectilinearGrid on CPU
    └── Vᶜᶜᶜ at (Center, Center, Center)

julia&gt; c_dV[1, 1, 1]
0.75

julia&gt; sum(c_dV)
6.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/AbstractOperations/grid_metrics.jl#L69-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.Δz" href="#Oceananigans.AbstractOperations.Δz"><code>Oceananigans.AbstractOperations.Δz</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">Δz = ZSpacingMetric()</code></pre><p>Instance of <code>ZSpacingMetric</code> that generates <code>BinaryOperation</code>s between <code>AbstractField</code>s and the vertical grid spacing evaluated at the same location as the <code>AbstractField</code>. </p><p><code>Δx</code> and <code>Δy</code> play a similar role for horizontal grid spacings.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; using Oceananigans.AbstractOperations: Δz

julia&gt; grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 2, 3)); c = CenterField(grid);

julia&gt; c_dz = c * Δz # returns BinaryOperation between Field and GridMetricOperation
BinaryOperation at (Center, Center, Center)
├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo
└── tree:
    * at (Center, Center, Center)
    ├── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU
    └── Δzᶜᶜᶜ at (Center, Center, Center)

julia&gt; c .= 1;

julia&gt; c_dz[1, 1, 1]
3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/AbstractOperations/grid_metrics.jl#L30-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.Average-Tuple{Oceananigans.Fields.AbstractField}" href="#Oceananigans.AbstractOperations.Average-Tuple{Oceananigans.Fields.AbstractField}"><code>Oceananigans.AbstractOperations.Average</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Average(field; dims=:)</code></pre><p>Return <code>Reduction</code> representing a spatial average of <code>field</code> over <code>dims</code>.</p><p>Over regularly-spaced dimensions this is equivalent to a numerical <code>mean!</code>.</p><p>Over dimensions of variable spacing, <code>field</code> is multipled by the appropriate grid length, area or volume, and divided by the total spatial extent of the interval.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/AbstractOperations/metric_field_reductions.jl#L48-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.BinaryOperation-Union{Tuple{G}, Tuple{IB}, Tuple{IA}, Tuple{B}, Tuple{A}, Tuple{O}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{O, A, B, IA, IB, G}} where {LX, LY, LZ, O, A, B, IA, IB, G}" href="#Oceananigans.AbstractOperations.BinaryOperation-Union{Tuple{G}, Tuple{IB}, Tuple{IA}, Tuple{B}, Tuple{A}, Tuple{O}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{O, A, B, IA, IB, G}} where {LX, LY, LZ, O, A, B, IA, IB, G}"><code>Oceananigans.AbstractOperations.BinaryOperation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BinaryOperation{LX, LY, LZ}(op, a, b, ▶a, ▶b, grid)</code></pre><p>Returns an abstract representation of the binary operation <code>op(▶a(a), ▶b(b))</code>. on <code>grid</code>, where <code>▶a</code> and <code>▶b</code> interpolate <code>a</code> and <code>b</code> to locations <code>(LX, LY, LZ)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/AbstractOperations/binary_operations.jl#L11-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.ConditionalOperation-Tuple{Oceananigans.Fields.AbstractField}" href="#Oceananigans.AbstractOperations.ConditionalOperation-Tuple{Oceananigans.Fields.AbstractField}"><code>Oceananigans.AbstractOperations.ConditionalOperation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ConditionalOperation{LX, LY, LZ}(operand, func, grid, condition, mask)</code></pre><p>Returns an abstract representation of a masking procedure applied when <code>condition</code> is satisfied on a field  described by <code>func(operand)</code>.</p><p><strong>Positional arguments</strong></p><ul><li><code>operand</code>: The <code>AbstractField</code> to be masked (it must have a <code>grid</code> property!)</li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>func</code>: A unary transformation applied element-wise to the field <code>operand</code> at locations where <code>condition == true</code>. Default is <code>identity</code></p></li><li><p><code>condition</code>: either a function of <code>(i, j, k, grid, operand)</code> returning a Boolean,              or a 3-dimensional Boolean <code>AbstractArray</code>. At locations where <code>condition == false</code>,              operand will be masked by <code>mask</code></p></li><li><p><code>mask</code>: the scalar mask</p></li></ul><p><code>condition_operand</code> is a conveniece function used to construct a <code>ConditionalOperation</code></p><p><code>condition_operand(func::Function, operand::AbstractField, condition, mask) = ConditionalOperation(operand; func, condition, mask)</code></p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; using Oceananigans.Fields: condition_operand

julia&gt; c = CenterField(RectilinearGrid(size=(2, 1, 1), extent=(1, 1, 1)));

julia&gt; f(i, j, k, grid, c) = i &lt; 2; d = condition_operand(cos, c, f, 10)
ConditionalOperation at (Center, Center, Center)
├── operand: 2×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU
├── grid: 2×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo
├── func: typeof(cos)
├── condition: typeof(f)
└── mask: 10

julia&gt; d[1, 1, 1]
1.0

julia&gt; d[2, 1, 1]
10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/AbstractOperations/conditional_operations.jl#L21-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.Derivative-Union{Tuple{G}, Tuple{AD}, Tuple{I}, Tuple{A}, Tuple{D}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{D, A, I, AD, G}} where {LX, LY, LZ, D, A, I, AD, G}" href="#Oceananigans.AbstractOperations.Derivative-Union{Tuple{G}, Tuple{AD}, Tuple{I}, Tuple{A}, Tuple{D}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{D, A, I, AD, G}} where {LX, LY, LZ, D, A, I, AD, G}"><code>Oceananigans.AbstractOperations.Derivative</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Derivative{LX, LY, LZ}(∂, arg, ▶, grid)</code></pre><p>Returns an abstract representation of the derivative <code>∂</code> on <code>arg</code>, and subsequent interpolation by <code>▶</code> on <code>grid</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/AbstractOperations/derivatives.jl#L10-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.Integral-Tuple{Oceananigans.Fields.AbstractField}" href="#Oceananigans.AbstractOperations.Integral-Tuple{Oceananigans.Fields.AbstractField}"><code>Oceananigans.AbstractOperations.Integral</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Integral(field; dims=:)</code></pre><p>Return a <code>Reduction</code> representing a spatial integral of <code>field</code> over <code>dims</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/AbstractOperations/metric_field_reductions.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.KernelFunctionOperation-Union{Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Any, Any}} where {LX, LY, LZ}" href="#Oceananigans.AbstractOperations.KernelFunctionOperation-Union{Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Any, Any}} where {LX, LY, LZ}"><code>Oceananigans.AbstractOperations.KernelFunctionOperation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">KernelFunctionOperation{LX, LY, LZ}(kernel_function, grid;
                                    computed_dependencies=(), parameters=nothing)</code></pre><p>Constructs a <code>KernelFunctionOperation</code> at location <code>(LX, LY, LZ)</code> on <code>grid</code> an with an optional iterable of <code>computed_dependencies</code> and arbitrary <code>parameters</code>.</p><p>With <code>isnothing(parameters)</code> (the default), <code>kernel_function</code> is called with</p><pre><code class="language-julia hljs">kernel_function(i, j, k, grid, computed_dependencies...)</code></pre><p>Otherwise <code>kernel_function</code> is called with</p><pre><code class="language-julia hljs">kernel_function(i, j, k, grid, computed_dependencies..., parameters)</code></pre><p><strong>Examples</strong></p><p>Construct a kernel function operation that returns random numbers:</p><pre><code class="language-julia hljs">random_kernel_function(i, j, k, grid) = rand() # use CUDA.rand on the GPU

kernel_op = KernelFunctionOperation{Center, Center, Center}(random_kernel_function, grid)</code></pre><p>Construct a kernel function operation using the vertical vorticity operator valid on curvilinear and cubed sphere grids:</p><pre><code class="language-julia hljs">using Oceananigans.Operators: ζ₃ᶠᶠᶜ # called with signature ζ₃ᶠᶠᶜ(i, j, k, grid, u, v)

grid = model.grid
u, v, w = model.velocities

ζ_op = KernelFunctionOperation{Face, Face, Center}(ζ₃ᶠᶠᶜ, grid, computed_dependencies=(u, v))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/AbstractOperations/kernel_function_operation.jl#L16-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.UnaryOperation-Union{Tuple{G}, Tuple{I}, Tuple{A}, Tuple{O}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{O, A, I, G}} where {LX, LY, LZ, O, A, I, G}" href="#Oceananigans.AbstractOperations.UnaryOperation-Union{Tuple{G}, Tuple{I}, Tuple{A}, Tuple{O}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{O, A, I, G}} where {LX, LY, LZ, O, A, I, G}"><code>Oceananigans.AbstractOperations.UnaryOperation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">UnaryOperation{LX, LY, LZ}(op, arg, ▶, grid)</code></pre><p>Returns an abstract <code>UnaryOperation</code> representing the action of <code>op</code> on <code>arg</code>, and subsequent interpolation by <code>▶</code> on <code>grid</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/AbstractOperations/unary_operations.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.∂x-Tuple{Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}}" href="#Oceananigans.AbstractOperations.∂x-Tuple{Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}}"><code>Oceananigans.AbstractOperations.∂x</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the <span>$x$</span>-derivative function acting at (<code>X</code>, <code>Y</code>, <code>Any</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/AbstractOperations/derivatives.jl#L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.∂x-Union{Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Tuple, Oceananigans.Fields.AbstractField{LX, LY, LZ, G, T, N} where {G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}} where {LX, LY, LZ}" href="#Oceananigans.AbstractOperations.∂x-Union{Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Tuple, Oceananigans.Fields.AbstractField{LX, LY, LZ, G, T, N} where {G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}} where {LX, LY, LZ}"><code>Oceananigans.AbstractOperations.∂x</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∂x(L::Tuple, arg::AbstractField)</code></pre><p>Return an abstract representation of an <span>$x$</span>-derivative acting on field <code>a</code> followed by interpolation to <code>L</code>, where <code>L</code> is a 3-tuple of <code>Face</code>s and <code>Center</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/AbstractOperations/derivatives.jl#L57-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.∂x-Union{Tuple{Oceananigans.Fields.AbstractField{LX, LY, LZ, G, T, N} where {G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}, Tuple{LZ}, Tuple{LY}, Tuple{LX}} where {LX, LY, LZ}" href="#Oceananigans.AbstractOperations.∂x-Union{Tuple{Oceananigans.Fields.AbstractField{LX, LY, LZ, G, T, N} where {G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}, Tuple{LZ}, Tuple{LY}, Tuple{LX}} where {LX, LY, LZ}"><code>Oceananigans.AbstractOperations.∂x</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∂x(arg::AbstractField)</code></pre><p>Return an abstract representation of a <span>$x$</span>-derivative acting on field <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/AbstractOperations/derivatives.jl#L85-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.∂y-Tuple{Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}}" href="#Oceananigans.AbstractOperations.∂y-Tuple{Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}}"><code>Oceananigans.AbstractOperations.∂y</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the <span>$y$</span>-derivative function acting at (<code>X</code>, <code>Y</code>, <code>Any</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/AbstractOperations/derivatives.jl#L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.∂y-Union{Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Tuple, Oceananigans.Fields.AbstractField{LX, LY, LZ, G, T, N} where {G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}} where {LX, LY, LZ}" href="#Oceananigans.AbstractOperations.∂y-Union{Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Tuple, Oceananigans.Fields.AbstractField{LX, LY, LZ, G, T, N} where {G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}} where {LX, LY, LZ}"><code>Oceananigans.AbstractOperations.∂y</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∂y(L::Tuple, arg::AbstractField)</code></pre><p>Return an abstract representation of a <span>$y$</span>-derivative acting on field <code>a</code> followed by interpolation to <code>L</code>, where <code>L</code> is a 3-tuple of <code>Face</code>s and <code>Center</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/AbstractOperations/derivatives.jl#L66-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.∂y-Union{Tuple{Oceananigans.Fields.AbstractField{LX, LY, LZ, G, T, N} where {G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}, Tuple{LZ}, Tuple{LY}, Tuple{LX}} where {LX, LY, LZ}" href="#Oceananigans.AbstractOperations.∂y-Union{Tuple{Oceananigans.Fields.AbstractField{LX, LY, LZ, G, T, N} where {G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}, Tuple{LZ}, Tuple{LY}, Tuple{LX}} where {LX, LY, LZ}"><code>Oceananigans.AbstractOperations.∂y</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∂y(arg::AbstractField)</code></pre><p>Return an abstract representation of a <span>$y$</span>-derivative acting on field <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/AbstractOperations/derivatives.jl#L92-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.∂z-Tuple{Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}}" href="#Oceananigans.AbstractOperations.∂z-Tuple{Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}}"><code>Oceananigans.AbstractOperations.∂z</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the <span>$z$</span>-derivative function acting at (<code>Any</code>, <code>Any</code>, <code>Z</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/AbstractOperations/derivatives.jl#L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.∂z-Union{Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Tuple, Oceananigans.Fields.AbstractField{LX, LY, LZ, G, T, N} where {G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}} where {LX, LY, LZ}" href="#Oceananigans.AbstractOperations.∂z-Union{Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Tuple, Oceananigans.Fields.AbstractField{LX, LY, LZ, G, T, N} where {G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}} where {LX, LY, LZ}"><code>Oceananigans.AbstractOperations.∂z</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∂z(L::Tuple, arg::AbstractField)</code></pre><p>Return an abstract representation of a <span>$z$</span>-derivative acting on field <code>a</code> followed by  interpolation to <code>L</code>, where <code>L</code> is a 3-tuple of <code>Face</code>s and <code>Center</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/AbstractOperations/derivatives.jl#L75-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.∂z-Union{Tuple{Oceananigans.Fields.AbstractField{LX, LY, LZ, G, T, N} where {G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}, Tuple{LZ}, Tuple{LY}, Tuple{LX}} where {LX, LY, LZ}" href="#Oceananigans.AbstractOperations.∂z-Union{Tuple{Oceananigans.Fields.AbstractField{LX, LY, LZ, G, T, N} where {G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}, Tuple{LZ}, Tuple{LY}, Tuple{LX}} where {LX, LY, LZ}"><code>Oceananigans.AbstractOperations.∂z</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∂z(arg::AbstractField)</code></pre><p>Return an abstract representation of a <span>$z$</span>-derivative acting on field <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/AbstractOperations/derivatives.jl#L98-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.@at-Tuple{Any, Any}" href="#Oceananigans.AbstractOperations.@at-Tuple{Any, Any}"><code>Oceananigans.AbstractOperations.@at</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@at location abstract_operation</code></pre><p>Modify the <code>abstract_operation</code> so that it returns values at <code>location</code>, where <code>location</code> is a 3-tuple of <code>Face</code>s and <code>Center</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/AbstractOperations/at.jl#L36-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.@binary-Tuple" href="#Oceananigans.AbstractOperations.@binary-Tuple"><code>Oceananigans.AbstractOperations.@binary</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@binary op1 op2 op3...</code></pre><p>Turn each binary function in the list <code>(op1, op2, op3...)</code> into a binary operator on <code>Oceananigans.Fields</code> for use in <code>AbstractOperations</code>.</p><p>Note: a binary function is a function with two arguments: for example, <code>+(x, y)</code> is a binary function.</p><p>Also note: a binary function in <code>Base</code> must be imported to be extended: use <code>import Base: op; @binary op</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans, Oceananigans.AbstractOperations

julia&gt; using Oceananigans.AbstractOperations: BinaryOperation, AbstractGridMetric, choose_location

julia&gt; plus_or_times(x, y) = x &lt; 0 ? x + y : x * y
plus_or_times (generic function with 1 method)

julia&gt; @binary plus_or_times
Set{Any} with 6 elements:
  :+
  :/
  :^
  :-
  :*
  :plus_or_times

julia&gt; c, d = (CenterField(RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))) for i = 1:2);

julia&gt; plus_or_times(c, d)
BinaryOperation at (Center, Center, Center)
├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo
└── tree:
    plus_or_times at (Center, Center, Center)
    ├── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU
    └── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/AbstractOperations/binary_operations.jl#L128-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.@multiary-Tuple" href="#Oceananigans.AbstractOperations.@multiary-Tuple"><code>Oceananigans.AbstractOperations.@multiary</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@multiary op1 op2 op3...</code></pre><p>Turn each multiary operator in the list <code>(op1, op2, op3...)</code> into a multiary operator on <code>Oceananigans.Fields</code> for use in <code>AbstractOperations</code>.</p><p>Note that a multiary operator:</p><ul><li>is a function with two or more arguments: for example, <code>+(x, y, z)</code> is a multiary function;</li><li>must be imported to be extended if part of <code>Base</code>: use <code>import Base: op; @multiary op</code>;</li><li>can only be called on <code>Oceananigans.Field</code>s if the &quot;location&quot; is noted explicitly; see example.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans, Oceananigans.AbstractOperations

julia&gt; harmonic_plus(a, b, c) = 1/3 * (1/a + 1/b + 1/c)
harmonic_plus (generic function with 1 method)

julia&gt; c, d, e = Tuple(CenterField(RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))) for i = 1:3);

julia&gt; harmonic_plus(c, d, e) # before magic @multiary transformation
BinaryOperation at (Center, Center, Center)
├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo
└── tree:
    * at (Center, Center, Center)
    ├── 0.3333333333333333
    └── + at (Center, Center, Center)
        ├── / at (Center, Center, Center)
        │   ├── 1
        │   └── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU
        ├── / at (Center, Center, Center)
        │   ├── 1
        │   └── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU
        └── / at (Center, Center, Center)
            ├── 1
            └── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU

julia&gt; @multiary harmonic_plus
Set{Any} with 3 elements:
  :+
  :harmonic_plus
  :*

julia&gt; harmonic_plus(c, d, e)
MultiaryOperation at (Center, Center, Center)
├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo
└── tree:
    harmonic_plus at (Center, Center, Center)
    ├── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU
    ├── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU
    └── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/AbstractOperations/multiary_operations.jl#L57-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.@unary-Tuple" href="#Oceananigans.AbstractOperations.@unary-Tuple"><code>Oceananigans.AbstractOperations.@unary</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@unary op1 op2 op3...</code></pre><p>Turn each unary function in the list <code>(op1, op2, op3...)</code> into a unary operator on <code>Oceananigans.Fields</code> for use in <code>AbstractOperations</code>.</p><p>Note: a unary function is a function with one argument: for example, <code>sin(x)</code> is a unary function.</p><p>Also note: a unary function in <code>Base</code> must be imported to be extended: use <code>import Base: op; @unary op</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans, Oceananigans.Grids, Oceananigans.AbstractOperations

julia&gt; square_it(x) = x^2
square_it (generic function with 1 method)

julia&gt; @unary square_it
Set{Any} with 8 elements:
  :sqrt
  :square_it
  :cos
  :exp
  :interpolate_identity
  :-
  :tanh
  :sin

julia&gt; c = CenterField(RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)));

julia&gt; square_it(c)
UnaryOperation at (Center, Center, Center)
├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo
└── tree:
    square_it at (Center, Center, Center) via identity
    └── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/AbstractOperations/unary_operations.jl#L37-L76">source</a></section></article><h2 id="Advection"><a class="docs-heading-anchor" href="#Advection">Advection</a><a id="Advection-1"></a><a class="docs-heading-anchor-permalink" href="#Advection" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.CenteredFourthOrder" href="#Oceananigans.Advection.CenteredFourthOrder"><code>Oceananigans.Advection.CenteredFourthOrder</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CenteredFourthOrder &lt;: AbstractCenteredAdvectionScheme{1}</code></pre><p>Centered fourth-order advection scheme.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Advection/centered_fourth_order.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.CenteredSecondOrder" href="#Oceananigans.Advection.CenteredSecondOrder"><code>Oceananigans.Advection.CenteredSecondOrder</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CenteredSecondOrder &lt;: AbstractAdvectionScheme{0}</code></pre><p>Centered second-order advection scheme.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Advection/centered_second_order.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.UpwindBiasedFifthOrder" href="#Oceananigans.Advection.UpwindBiasedFifthOrder"><code>Oceananigans.Advection.UpwindBiasedFifthOrder</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct UpwindBiasedFifthOrder &lt;: AbstractUpwindBiasedAdvectionScheme{2}</code></pre><p>Upwind-biased fifth-order advection scheme.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Advection/upwind_biased_fifth_order.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.UpwindBiasedFirstOrder" href="#Oceananigans.Advection.UpwindBiasedFirstOrder"><code>Oceananigans.Advection.UpwindBiasedFirstOrder</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct UpwindBiasedFirstOrder &lt;: AbstractUpwindBiasedAdvectionScheme{1}</code></pre><p>Upwind-biased first-order advection scheme.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Advection/upwind_biased_first_order.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.UpwindBiasedThirdOrder" href="#Oceananigans.Advection.UpwindBiasedThirdOrder"><code>Oceananigans.Advection.UpwindBiasedThirdOrder</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct UpwindBiasedThirdOrder &lt;: AbstractUpwindBiasedAdvectionScheme{1}</code></pre><p>Upwind-biased third-order advection scheme.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Advection/upwind_biased_third_order.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.WENO5" href="#Oceananigans.Advection.WENO5"><code>Oceananigans.Advection.WENO5</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct WENO5{FT, XT, YT, ZT, XS, YS, ZS, W} &lt;: AbstractUpwindBiasedAdvectionScheme{2}</code></pre><p>Weighted Essentially Non-Oscillatory (WENO) fifth-order advection scheme.</p><ul><li><p><code>coeff_xᶠᵃᵃ::Any</code></p><p>coefficient for ENO reconstruction on x-faces</p></li><li><p><code>coeff_xᶜᵃᵃ::Any</code></p><p>coefficient for ENO reconstruction on x-centers</p></li><li><p><code>coeff_yᵃᶠᵃ::Any</code></p><p>coefficient for ENO reconstruction on y-faces</p></li><li><p><code>coeff_yᵃᶜᵃ::Any</code></p><p>coefficient for ENO reconstruction on y-centers</p></li><li><p><code>coeff_zᵃᵃᶠ::Any</code></p><p>coefficient for ENO reconstruction on z-faces</p></li><li><p><code>coeff_zᵃᵃᶜ::Any</code></p><p>coefficient for ENO reconstruction on z-centers</p></li><li><p><code>smooth_xᶠᵃᵃ::Any</code></p><p>coefficient for WENO smoothness indicators on x-faces</p></li><li><p><code>smooth_xᶜᵃᵃ::Any</code></p><p>coefficient for WENO smoothness indicators on x-centers</p></li><li><p><code>smooth_yᵃᶠᵃ::Any</code></p><p>coefficient for WENO smoothness indicators on y-faces</p></li><li><p><code>smooth_yᵃᶜᵃ::Any</code></p><p>coefficient for WENO smoothness indicators on y-centers</p></li><li><p><code>smooth_zᵃᵃᶠ::Any</code></p><p>coefficient for WENO smoothness indicators on z-faces</p></li><li><p><code>smooth_zᵃᵃᶜ::Any</code></p><p>coefficient for WENO smoothness indicators on z-centers</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Advection/weno_fifth_order.jl#L20-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.WENO5" href="#Oceananigans.Advection.WENO5"><code>Oceananigans.Advection.WENO5</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WENO5([FT = Float64;] grid = nothing, stretched_smoothness = false, zweno = false)</code></pre><p>Construct a fifth-order weigthed essentially non-oscillatory advection scheme. The constructor allows construction of WENO schemes on either uniform or stretched grids.</p><p><strong>Keyword arguments</strong></p><ul><li><code>grid</code>: (defaults to <code>nothing</code>)</li><li><code>stretched_smoothness</code>: When <code>true</code> it results in computing the coefficients for the smoothness indicators β₀, β₁ and β₂ so that they account for the stretched <code>grid</code>. (defaults to <code>false</code>)</li><li><code>zweno</code>: When <code>true</code> implement a Z-WENO formulation for the WENO weights calculation. (defaults to <code>false</code>)</li></ul><div class="admonition is-category-warn"><header class="admonition-header">No support for WENO5 on curvilinear grids</header><div class="admonition-body"><p>Currently, WENO 5th-order advection schemes don&#39;t work for for curvilinear grids. Providing <code>WENO5(::AbstractCurvilinearGrid)</code> defaults to uniform setting, i.e. <code>WENO5(::AbstractCurvilinearGrid) = WENO5()</code>.</p></div></div><p>Not providing any keyword argument, <code>WENO5()</code> defaults to the uniform 5th-order coefficients (&quot;uniform setting) in all directions, using a JS-WENO formulation.</p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; WENO5()
┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended
└ @ Oceananigans.Advection .../src/Advection/weno_fifth_order.jl:90
WENO5 advection scheme with:
    ├── X regular
    ├── Y regular
    └── Z regular</code></pre><p><code>WENO5(grid = grid)</code> defaults to uniform interpolation coefficient for each of the grid directions that is uniform (<code>typeof(Δc) &lt;: Number</code>) while it precomputes the ENO coefficients for reconstruction for all grid directions that are stretched. (After testing &quot;on-the-fly&quot; calculation of coefficients for stretched directions ended up being way too expensive and, therefore, is not supported.)</p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = RectilinearGrid(size = (3, 4, 5), x = (0, 1), y = (0, 1), z = [-10, -9, -7, -4, -1.5, 0]);

julia&gt; WENO5(grid = grid)
WENO5 advection scheme with:
    ├── X regular
    ├── Y regular
    └── Z stretched</code></pre><p><code>WENO5(grid = grid, stretched_smoothness = true)</code> behaves similarly to <code>WENO5(grid = grid)</code> but, additionally, it also computes the smoothness indicators coefficients, <span>$β₀$</span>, <span>$β₁$</span>, and <span>$β₂$</span>, taking into account the stretched dimensions.</p><p><code>WENO5(zweno = true)</code> implements a Z-WENO formulation for the WENO weights calculation</p><p><strong>Comments</strong></p><p>All methods have the roughly the same execution speed except for <code>stretched_smoothness = true</code> that requires more memory and is less computationally efficient, especially on GPUs. In addition, it has not been found to be much impactful on the tested cases. As such, most of the times we urge users to use <code>WENO5(grid = grid)</code>, as this increases accuracy on a stretched mesh  but does decreases memory utilization (and also results in a slight speed-up).</p><p>(The above claims were made after some preliminary tests. Thus, we still users to perform some benchmarks/checks before performing, e.g., a large simulation on a &quot;weirdly&quot; stretched grid.)</p><p>On the other hand, a Z-WENO formulation is <em>most of the times</em> beneficial (also in case of a uniform mesh) with roughly the same performances (just a slight slowdown). The same can be said for the stretched <code>WENO5(grid = grid)</code> formulation in case of stretched grids.</p><p><strong>References</strong></p><p>Shu, Essentially Non-Oscillatory and Weighted Essentially Non-Oscillatory Schemes for Hyperbolic     Conservation Laws, 1997, NASA/CR-97-206253, ICASE Report No. 97-65</p><p>Castro et al, High order weighted essentially non-oscillatory WENO-Z schemes for hyperbolic conservation     laws, 2011, Journal of Computational Physics, 230(5), 1766-1792</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Advection/weno_fifth_order.jl#L56-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.div_Uc-NTuple{7, Any}" href="#Oceananigans.Advection.div_Uc-NTuple{7, Any}"><code>Oceananigans.Advection.div_Uc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">div_uc(i, j, k, grid, advection, U, c)</code></pre><p>Calculates the divergence of the flux of a tracer quantity <span>$c$</span> being advected by a velocity field, <span>$𝛁⋅(𝐯 c)$</span>,</p><pre><code class="nohighlight hljs">1/V * [δxᶜᵃᵃ(Ax * u * ℑxᶠᵃᵃ(c)) + δyᵃᶜᵃ(Ay * v * ℑyᵃᶠᵃ(c)) + δzᵃᵃᶜ(Az * w * ℑzᵃᵃᶠ(c))]</code></pre><p>which ends up at the location <code>ccc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Advection/tracer_advection_operators.jl#L17-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.div_𝐯u-NTuple{7, Any}" href="#Oceananigans.Advection.div_𝐯u-NTuple{7, Any}"><code>Oceananigans.Advection.div_𝐯u</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">div_𝐯u(i, j, k, grid, advection, U, u)</code></pre><p>Calculate the advection of momentum in the <span>$x$</span>-direction using the conservative form, <span>$𝛁⋅(𝐯 u)$</span>,</p><pre><code class="nohighlight hljs">1/Vᵘ * [δxᶠᵃᵃ(ℑxᶜᵃᵃ(Ax * u) * ℑxᶜᵃᵃ(u)) + δy_fca(ℑxᶠᵃᵃ(Ay * v) * ℑyᵃᶠᵃ(u)) + δz_fac(ℑxᶠᵃᵃ(Az * w) * ℑzᵃᵃᶠ(u))]</code></pre><p>which ends up at the location <code>fcc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Advection/momentum_advection_operators.jl#L47-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.div_𝐯v-NTuple{7, Any}" href="#Oceananigans.Advection.div_𝐯v-NTuple{7, Any}"><code>Oceananigans.Advection.div_𝐯v</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">div_𝐯v(i, j, k, grid, advection, U, v)</code></pre><p>Calculate the advection of momentum in the <span>$y$</span>-direction using the conservative form, <span>$𝛁⋅(𝐯 v)$</span>,</p><pre><code class="nohighlight hljs">1/Vʸ * [δx_cfa(ℑyᵃᶠᵃ(Ax * u) * ℑxᶠᵃᵃ(v)) + δyᵃᶠᵃ(ℑyᵃᶜᵃ(Ay * v) * ℑyᵃᶜᵃ(v)) + δz_afc(ℑxᶠᵃᵃ(Az * w) * ℑzᵃᵃᶠ(w))]</code></pre><p>which ends up at the location <code>cfc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Advection/momentum_advection_operators.jl#L62-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.div_𝐯w-NTuple{7, Any}" href="#Oceananigans.Advection.div_𝐯w-NTuple{7, Any}"><code>Oceananigans.Advection.div_𝐯w</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">div_𝐯w(i, j, k, grid, advection, U, w)</code></pre><p>Calculate the advection of momentum in the <span>$z$</span>-direction using the conservative form, <span>$𝛁⋅(𝐯 w)$</span>,</p><pre><code class="nohighlight hljs">1/Vʷ * [δx_caf(ℑzᵃᵃᶠ(Ax * u) * ℑxᶠᵃᵃ(w)) + δy_acf(ℑzᵃᵃᶠ(Ay * v) * ℑyᵃᶠᵃ(w)) + δzᵃᵃᶠ(ℑzᵃᵃᶜ(Az * w) * ℑzᵃᵃᶜ(w))]</code></pre><p>which ends up at the location <code>ccf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Advection/momentum_advection_operators.jl#L77-L85">source</a></section></article><h2 id="Architectures"><a class="docs-heading-anchor" href="#Architectures">Architectures</a><a id="Architectures-1"></a><a class="docs-heading-anchor-permalink" href="#Architectures" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Architectures.AbstractArchitecture" href="#Oceananigans.Architectures.AbstractArchitecture"><code>Oceananigans.Architectures.AbstractArchitecture</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractArchitecture</code></pre><p>Abstract supertype for architectures supported by Oceananigans.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Architectures.jl#L13-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Architectures.AbstractMultiArchitecture" href="#Oceananigans.Architectures.AbstractMultiArchitecture"><code>Oceananigans.Architectures.AbstractMultiArchitecture</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractMultiArchitecture</code></pre><p>Abstract supertype for Distributed architectures supported by Oceananigans.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Architectures.jl#L20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Architectures.CPU" href="#Oceananigans.Architectures.CPU"><code>Oceananigans.Architectures.CPU</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CPU &lt;: AbstractArchitecture</code></pre><p>Run Oceananigans on one CPU node. Uses multiple threads if the environment variable <code>JULIA_NUM_THREADS</code> is set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Architectures.jl#L27-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Architectures.GPU" href="#Oceananigans.Architectures.GPU"><code>Oceananigans.Architectures.GPU</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GPU &lt;: AbstractArchitecture</code></pre><p>Run Oceananigans on a single NVIDIA CUDA GPU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Architectures.jl#L35-L39">source</a></section></article><h2 id="Boundary-conditions"><a class="docs-heading-anchor" href="#Boundary-conditions">Boundary conditions</a><a id="Boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-conditions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.BoundaryCondition" href="#Oceananigans.BoundaryConditions.BoundaryCondition"><code>Oceananigans.BoundaryConditions.BoundaryCondition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct BoundaryCondition{C&lt;:AbstractBoundaryConditionClassification, T}</code></pre><p>Container for boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/BoundaryConditions/boundary_condition.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.BoundaryCondition-Tuple{DataType, Any}" href="#Oceananigans.BoundaryConditions.BoundaryCondition-Tuple{DataType, Any}"><code>Oceananigans.BoundaryConditions.BoundaryCondition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoundaryCondition(Classification::DataType, condition)</code></pre><p>Construct a boundary condition of type <code>BC</code> with a number or array as a <code>condition</code>.</p><p>Boundary condition types include <code>Periodic</code>, <code>Flux</code>, <code>Value</code>, <code>Gradient</code>, and <code>Open</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/BoundaryConditions/boundary_condition.jl#L13-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.BoundaryCondition-Tuple{DataType, Function}" href="#Oceananigans.BoundaryConditions.BoundaryCondition-Tuple{DataType, Function}"><code>Oceananigans.BoundaryConditions.BoundaryCondition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoundaryCondition(Classification::DataType, condition::Function;
                  parameters = nothing,
                  discrete_form = false,
                  field_dependencies=())</code></pre><p>Construct a boundary condition of type <code>Classification</code> with a function boundary <code>condition</code>.</p><p>By default, the function boudnary <code>condition</code> is assumed to have the &#39;continuous form&#39; <code>condition(ξ, η, t)</code>, where <code>t</code> is time and <code>ξ</code> and <code>η</code> vary along the boundary. In particular:</p><ul><li>On <code>x</code>-boundaries, <code>condition(y, z, t)</code>.</li><li>On <code>y</code>-boundaries, <code>condition(x, z, t)</code>.</li><li>On <code>z</code>-boundaries, <code>condition(x, y, t)</code>.</li></ul><p>If <code>parameters</code> is not <code>nothing</code>, then function boundary conditions have the form <code>func(ξ, η, t, parameters)</code>, where <code>ξ</code> and <code>η</code> are spatial coordinates varying along the boundary as explained above.</p><p>If <code>discrete_form = true</code>, the function <code>condition</code> is assumed to have the &quot;discrete form&quot;,</p><pre><code class="nohighlight hljs">condition(i, j, grid, clock, model_fields)</code></pre><p>where <code>i</code>, and <code>j</code> are indices that vary along the boundary. If <code>discrete_form = true</code> and <code>parameters</code> is not <code>nothing</code>, the function <code>condition</code> is called with</p><pre><code class="nohighlight hljs">condition(i, j, grid, clock, model_fields, parameters)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/BoundaryConditions/boundary_condition.jl#L22-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.FieldBoundaryConditions" href="#Oceananigans.BoundaryConditions.FieldBoundaryConditions"><code>Oceananigans.BoundaryConditions.FieldBoundaryConditions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FieldBoundaryConditions(grid, location; kwargs...)</code></pre><p>Return boundary conditions for auxiliary fields (fields whose values are derived from a model&#39;s prognostic fields) on <code>grid</code> and at <code>location</code>.</p><p><strong>Keyword arguments</strong></p><p>Keyword arguments specify boundary conditions on the 6 possible boundaries:</p><ul><li><code>west</code>, left end point in the <code>x</code>-direction where <code>i=1</code></li><li><code>east</code>, right end point in the <code>x</code>-direction where <code>i=grid.Nx</code></li><li><code>south</code>, left end point in the <code>y</code>-direction where <code>j=1</code></li><li><code>north</code>, right end point in the <code>y</code>-direction where <code>j=grid.Ny</code></li><li><code>bottom</code>, right end point in the <code>z</code>-direction where <code>k=1</code></li><li><code>top</code>, right end point in the <code>z</code>-direction where <code>k=grid.Nz</code></li></ul><p>If a boundary condition is unspecified, the default for auxiliary fields and the topology in the boundary-normal direction is used:</p><ul><li><code>PeriodicBoundaryCondition</code> for <code>Periodic</code> directions</li><li><code>GradientBoundaryCondition(0)</code> for <code>Bounded</code> directions and <code>Centered</code>-located fields</li><li><code>nothing</code> for <code>Bounded</code> directions and <code>Face</code>-located fields</li><li><code>nothing</code> for <code>Flat</code> directions and/or <code>Nothing</code>-located fields)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/BoundaryConditions/field_boundary_conditions.jl#L86-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.FieldBoundaryConditions-Tuple{}" href="#Oceananigans.BoundaryConditions.FieldBoundaryConditions-Tuple{}"><code>Oceananigans.BoundaryConditions.FieldBoundaryConditions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FieldBoundaryConditions(; kwargs...)</code></pre><p>Return a template for boundary conditions on prognostic fields.</p><p><strong>Keyword arguments</strong></p><p>Keyword arguments specify boundary conditions on the 7 possible boundaries:</p><ul><li><code>west</code>, left end point in the <code>x</code>-direction where <code>i=1</code></li><li><code>east</code>, right end point in the <code>x</code>-direction where <code>i=grid.Nx</code></li><li><code>south</code>, left end point in the <code>y</code>-direction where <code>j=1</code></li><li><code>north</code>, right end point in the <code>y</code>-direction where <code>j=grid.Ny</code></li><li><code>bottom</code>, right end point in the <code>z</code>-direction where <code>k=1</code></li><li><code>top</code>, right end point in the <code>z</code>-direction where <code>k=grid.Nz</code></li><li><code>immersed</code>, boundary between solid and fluid for immersed boundaries (experimental support only)</li></ul><p>If a boundary condition is unspecified, the default for prognostic fields and the topology in the boundary-normal direction is used:</p><ul><li><code>PeriodicBoundaryCondition</code> for <code>Periodic</code> directions</li><li><code>NoFluxBoundaryCondition</code> for <code>Bounded</code> directions and <code>Centered</code>-located fields</li><li><code>ImpenetrableBoundaryCondition</code> for <code>Bounded</code> directions and <code>Face</code>-located fields</li><li><code>nothing</code> for <code>Flat</code> directions and/or <code>Nothing</code>-located fields</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/BoundaryConditions/field_boundary_conditions.jl#L49-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.Flux" href="#Oceananigans.BoundaryConditions.Flux"><code>Oceananigans.BoundaryConditions.Flux</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Flux &lt;: AbstractBoundaryConditionClassification</code></pre><p>A classification specifying a boundary condition on the flux of a field.</p><p>The sign convention is such that a positive flux represents the flux of a quantity in the positive direction. For example, a positive vertical flux implies a quantity is fluxed upwards, in the <span>$+z$</span> direction.</p><p>Due to this convention, a positive flux applied to the top boundary specifies that a quantity is fluxed upwards across the top boundary and thus out of the domain. As a result, a positive flux applied to a top boundary leads to a reduction of that quantity in the interior of the domain; for example, a positive, upwards flux of heat at the top of the domain acts to cool the interior of the domain. Conversely, a positive flux applied to the bottom boundary leads to an increase of the quantity in the interior of the domain. The same logic holds for east, west, north, and south boundaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/BoundaryConditions/boundary_condition_classifications.jl#L17-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.Gradient" href="#Oceananigans.BoundaryConditions.Gradient"><code>Oceananigans.BoundaryConditions.Gradient</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Gradient &lt;: AbstractBoundaryConditionClassification</code></pre><p>A classification specifying a boundary condition on the derivative or gradient of a field. Also called a Neumann boundary condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/BoundaryConditions/boundary_condition_classifications.jl#L36-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.Open" href="#Oceananigans.BoundaryConditions.Open"><code>Oceananigans.BoundaryConditions.Open</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Open &lt;: AbstractBoundaryConditionClassification</code></pre><p>A classification that specifies the halo regions of a field directly.</p><p>For fields located at Faces, Open also specifies field value <em>on</em> the boundary.</p><p>Open boundary conditions are used to specify the component of a velocity field normal to a boundary and can also be used to describe nested or linked simulation domains.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/BoundaryConditions/boundary_condition_classifications.jl#L52-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.Value" href="#Oceananigans.BoundaryConditions.Value"><code>Oceananigans.BoundaryConditions.Value</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Value &lt;: AbstractBoundaryConditionClassification</code></pre><p>A classification specifying a boundary condition on the value of a field. Also called a Dirchlet boundary condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/BoundaryConditions/boundary_condition_classifications.jl#L44-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.apply_x_bcs!-Tuple{Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any, Oceananigans.Architectures.AbstractArchitecture, Any, Vararg{Any, N} where N}" href="#Oceananigans.BoundaryConditions.apply_x_bcs!-Tuple{Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any, Oceananigans.Architectures.AbstractArchitecture, Any, Vararg{Any, N} where N}"><code>Oceananigans.BoundaryConditions.apply_x_bcs!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Apply flux boundary conditions to a field <code>c</code> by adding the associated flux divergence to the source term <code>Gc</code> at the left and right.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/BoundaryConditions/apply_flux_bcs.jl#L31-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.apply_y_bcs!-Tuple{Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any, Oceananigans.Architectures.AbstractArchitecture, Any, Vararg{Any, N} where N}" href="#Oceananigans.BoundaryConditions.apply_y_bcs!-Tuple{Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any, Oceananigans.Architectures.AbstractArchitecture, Any, Vararg{Any, N} where N}"><code>Oceananigans.BoundaryConditions.apply_y_bcs!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Apply flux boundary conditions to a field <code>c</code> by adding the associated flux divergence to the source term <code>Gc</code> at the left and right.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/BoundaryConditions/apply_flux_bcs.jl#L38-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.apply_z_bcs!-Tuple{Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any, Oceananigans.Architectures.AbstractArchitecture, Any, Vararg{Any, N} where N}" href="#Oceananigans.BoundaryConditions.apply_z_bcs!-Tuple{Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any, Oceananigans.Architectures.AbstractArchitecture, Any, Vararg{Any, N} where N}"><code>Oceananigans.BoundaryConditions.apply_z_bcs!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Apply flux boundary conditions to a field <code>c</code> by adding the associated flux divergence to the source term <code>Gc</code> at the top and bottom.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/BoundaryConditions/apply_flux_bcs.jl#L45-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.fill_halo_regions!-Tuple{OffsetArrays.OffsetArray, Any, Any, Any, Vararg{Any, N} where N}" href="#Oceananigans.BoundaryConditions.fill_halo_regions!-Tuple{OffsetArrays.OffsetArray, Any, Any, Any, Vararg{Any, N} where N}"><code>Oceananigans.BoundaryConditions.fill_halo_regions!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Fill halo regions in <span>$x$</span>, <span>$y$</span>, and <span>$z$</span> for a given field&#39;s data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/BoundaryConditions/fill_halo_regions.jl#L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.fill_halo_regions!-Tuple{Union{Tuple, NamedTuple}, Any, Vararg{Any, N} where N}" href="#Oceananigans.BoundaryConditions.fill_halo_regions!-Tuple{Union{Tuple, NamedTuple}, Any, Vararg{Any, N} where N}"><code>Oceananigans.BoundaryConditions.fill_halo_regions!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fill_halo_regions!(fields::Union{Tuple, NamedTuple}, arch, args...)</code></pre><p>Fill halo regions for each field in the tuple <code>fields</code> according to their boundary conditions, possibly recursing into <code>fields</code> if it is a nested tuple-of-tuples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/BoundaryConditions/fill_halo_regions.jl#L10-L15">source</a></section></article><h2 id="BuoyancyModels"><a class="docs-heading-anchor" href="#BuoyancyModels">BuoyancyModels</a><a id="BuoyancyModels-1"></a><a class="docs-heading-anchor-permalink" href="#BuoyancyModels" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BuoyancyModels.Buoyancy-Tuple{}" href="#Oceananigans.BuoyancyModels.Buoyancy-Tuple{}"><code>Oceananigans.BuoyancyModels.Buoyancy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Buoyancy(; model, gravity_unit_vector=ZDirection())</code></pre><p>Uses a given buoyancy <code>model</code> to create buoyancy in a model. The optional keyword argument  <code>gravity_unit_vector</code> can be used to specify the direction opposite to the gravitational acceleration (which we take here to mean the &quot;vertical&quot; direction).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Oceananigans

grid = RectilinearGrid(size=(1, 8, 8), extent=(1, 1000, 100))
θ = 45 # degrees
g̃ = (0, sind(θ), cosd(θ))

buoyancy = Buoyancy(model=BuoyancyTracer(), gravity_unit_vector=g̃)

model = NonhydrostaticModel(grid=grid, buoyancy=buoyancy, tracers=:b)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/BuoyancyModels/buoyancy.jl#L8-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BuoyancyModels.BuoyancyTracer" href="#Oceananigans.BuoyancyModels.BuoyancyTracer"><code>Oceananigans.BuoyancyModels.BuoyancyTracer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BuoyancyTracer &lt;: AbstractBuoyancyModel{Nothing}</code></pre><p>Type indicating that the tracer <code>b</code> represents buoyancy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/BuoyancyModels/buoyancy_tracer.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BuoyancyModels.LinearEquationOfState" href="#Oceananigans.BuoyancyModels.LinearEquationOfState"><code>Oceananigans.BuoyancyModels.LinearEquationOfState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinearEquationOfState{FT} &lt;: AbstractEquationOfState</code></pre><p>Linear equation of state for seawater.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/BuoyancyModels/linear_equation_of_state.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BuoyancyModels.LinearEquationOfState" href="#Oceananigans.BuoyancyModels.LinearEquationOfState"><code>Oceananigans.BuoyancyModels.LinearEquationOfState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinearEquationOfState([FT=Float64;] thermal_expansion=1.67e-4, haline_contraction=7.80e-4)</code></pre><p>Return <code>LinearEquationOfState</code> for <code>SeawaterBuoyancy</code> with <code>thermal_expansion</code> coefficient and <code>haline_contraction</code> coefficient. The buoyancy perturbation <span>$b$</span> for <code>LinearEquationOfState</code> is</p><p class="math-container">\[    b = g (α T - β S),\]</p><p>where <span>$g$</span> is gravitational acceleration, <span>$α$</span> is <code>thermal_expansion</code>, <span>$β$</span> is <code>haline_contraction</code>, <span>$T$</span> is temperature, and <span>$S$</span> is practical salinity units.</p><p>Default constants in units inverse Kelvin and practical salinity units for <code>thermal_expansion</code> and <code>haline_contraction</code>, respectively, are taken from Table 1.2 (page 33) of Vallis, &quot;Atmospheric and Oceanic Fluid Dynamics: Fundamentals and Large-Scale Circulation&quot; (2nd ed, 2017).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/BuoyancyModels/linear_equation_of_state.jl#L17-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BuoyancyModels.SeawaterBuoyancy" href="#Oceananigans.BuoyancyModels.SeawaterBuoyancy"><code>Oceananigans.BuoyancyModels.SeawaterBuoyancy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SeawaterBuoyancy{FT, EOS, T, S} &lt;: AbstractBuoyancyModel{EOS}</code></pre><p>BuoyancyModels model for seawater. <code>T</code> and <code>S</code> are either <code>nothing</code> if both temperature and salinity are active, or of type <code>FT</code> if temperature or salinity are constant, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/BuoyancyModels/seawater_buoyancy.jl#L4-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BuoyancyModels.SeawaterBuoyancy" href="#Oceananigans.BuoyancyModels.SeawaterBuoyancy"><code>Oceananigans.BuoyancyModels.SeawaterBuoyancy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SeawaterBuoyancy([FT = Float64;]
                 gravitational_acceleration = g_Earth,
                 equation_of_state = LinearEquationOfState(FT),
                 constant_temperature = false,
                 constant_salinity = false)</code></pre><p>Returns parameters for a temperature- and salt-stratified seawater buoyancy model with a <code>gravitational_acceleration</code> constant (typically called <span>$g$</span>), and an <code>equation_of_state</code> that related temperature and salinity (or conservative temperature and absolute salinity) to density anomalies and buoyancy.</p><p><code>constant_temperature</code> indicates that buoyancy depends only on salinity. For a nonlinear equation of state, <code>constant_temperature</code> is used as the temperature of the system. The same logic, with the roles of salinity and temperature reversed, holds when <code>constant_salinity</code> is provided.</p><p>For a linear equation of state, the values of <code>constant_temperature</code> or <code>constant_salinity</code> are irrelevant; in this case, <code>constant_temperature=true</code> (and similar for <code>constant_salinity</code>) is valid input.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/BuoyancyModels/seawater_buoyancy.jl#L42-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BuoyancyModels.∂x_b-Tuple{Any, Any, Any, Any, SeawaterBuoyancy, Any}" href="#Oceananigans.BuoyancyModels.∂x_b-Tuple{Any, Any, Any, Any, SeawaterBuoyancy, Any}"><code>Oceananigans.BuoyancyModels.∂x_b</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∂x_b(i, j, k, grid, b::SeawaterBuoyancy, C)</code></pre><p>Returns the <span>$x$</span>-derivative of buoyancy for temperature and salt-stratified water,</p><p class="math-container">\[∂_x b = g ( α ∂_x T - β ∂_x S ) ,\]</p><p>where <span>$g$</span> is gravitational acceleration, <span>$α$</span> is the thermal expansion coefficient, <span>$β$</span> is the haline contraction coefficient, <span>$T$</span> is conservative temperature, and <span>$S$</span> is absolute salinity.</p><p>Note: In Oceananigans, <code>model.tracers.T</code> is conservative temperature and <code>model.tracers.S</code> is absolute salinity.</p><p>Note that <span>$∂_x T$</span> (<code>∂x_T</code>), <span>$∂_x S$</span> (<code>∂x_S</code>), <span>$α$</span>, and <span>$β$</span> are all evaluated at cell interfaces in <code>x</code> and cell centers in <code>y</code> and <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/BuoyancyModels/seawater_buoyancy.jl#L100-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BuoyancyModels.∂y_b-Tuple{Any, Any, Any, Any, SeawaterBuoyancy, Any}" href="#Oceananigans.BuoyancyModels.∂y_b-Tuple{Any, Any, Any, Any, SeawaterBuoyancy, Any}"><code>Oceananigans.BuoyancyModels.∂y_b</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∂y_b(i, j, k, grid, b::SeawaterBuoyancy, C)</code></pre><p>Returns the <span>$y$</span>-derivative of buoyancy for temperature and salt-stratified water,</p><p class="math-container">\[∂_y b = g ( α ∂_y T - β ∂_y S ) ,\]</p><p>where <span>$g$</span> is gravitational acceleration, <span>$α$</span> is the thermal expansion coefficient, <span>$β$</span> is the haline contraction coefficient, <span>$T$</span> is conservative temperature, and <span>$S$</span> is absolute salinity.</p><p>Note: In Oceananigans, <code>model.tracers.T</code> is conservative temperature and <code>model.tracers.S</code> is absolute salinity.</p><p>Note that <span>$∂_y T$</span> (<code>∂y_T</code>), <span>$∂_y S$</span> (<code>∂y_S</code>), <span>$α$</span>, and <span>$β$</span> are all evaluated at cell interfaces in <code>y</code> and cell centers in <code>x</code> and <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/BuoyancyModels/seawater_buoyancy.jl#L126-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BuoyancyModels.∂z_b-Tuple{Any, Any, Any, Any, SeawaterBuoyancy, Any}" href="#Oceananigans.BuoyancyModels.∂z_b-Tuple{Any, Any, Any, Any, SeawaterBuoyancy, Any}"><code>Oceananigans.BuoyancyModels.∂z_b</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∂z_b(i, j, k, grid, b::SeawaterBuoyancy, C)</code></pre><p>Returns the vertical derivative of buoyancy for temperature and salt-stratified water,</p><p class="math-container">\[∂_z b = N^2 = g ( α ∂_z T - β ∂_z S ) ,\]</p><p>where <span>$g$</span> is gravitational acceleration, <span>$α$</span> is the thermal expansion coefficient, <span>$β$</span> is the haline contraction coefficient, <span>$T$</span> is conservative temperature, and <span>$S$</span> is absolute salinity.</p><p>Note: In Oceananigans, <code>model.tracers.T</code> is conservative temperature and <code>model.tracers.S</code> is absolute salinity.</p><p>Note that <span>$∂_z T$</span> (<code>∂z_T</code>), <span>$∂_z S$</span> (<code>∂z_S</code>), <span>$α$</span>, and <span>$β$</span> are all evaluated at cell interfaces in <code>z</code> and cell centers in <code>x</code> and <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/BuoyancyModels/seawater_buoyancy.jl#L152-L170">source</a></section></article><h2 id="Coriolis"><a class="docs-heading-anchor" href="#Coriolis">Coriolis</a><a id="Coriolis-1"></a><a class="docs-heading-anchor-permalink" href="#Coriolis" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.BetaPlane" href="#Oceananigans.Coriolis.BetaPlane"><code>Oceananigans.Coriolis.BetaPlane</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BetaPlane{T} &lt;: AbstractRotation</code></pre><p>A parameter object for meridionally increasing Coriolis parameter (<code>f = f₀ + β y</code>) that accounts for the variation of the locally vertical component of the rotation vector with latitude.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Coriolis/beta_plane.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.BetaPlane" href="#Oceananigans.Coriolis.BetaPlane"><code>Oceananigans.Coriolis.BetaPlane</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BetaPlane([T=Float64;] f₀=nothing, β=nothing,
                       rotation_rate=Ω_Earth, latitude=nothing, radius=R_Earth)</code></pre><p>The user may specify both <code>f₀</code> and <code>β</code>, or the three parameters <code>rotation_rate</code>, <code>latitude</code> (in degrees), and <code>radius</code> that specify the rotation rate and radius of a planet, and the central latitude (where <span>$y = 0$</span>) at which the <code>β</code>-plane approximation is to be made.</p><p>If <code>f₀</code> and <code>β</code> are not specified, they are calculated from <code>rotation_rate</code>, <code>latitude</code>, and <code>radius</code> according to the relations <code>f₀ = 2 * rotation_rate * sind(latitude)</code> and <code>β = 2 * rotation_rate * cosd(latitude) / radius</code>.</p><p>By default, the <code>rotation_rate</code> and planet <code>radius</code> is assumed to be Earth&#39;s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Coriolis/beta_plane.jl#L13-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.ConstantCartesianCoriolis" href="#Oceananigans.Coriolis.ConstantCartesianCoriolis"><code>Oceananigans.Coriolis.ConstantCartesianCoriolis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConstantCartesianCoriolis{FT} &lt;: AbstractRotation</code></pre><p>A Coriolis implementation that accounts for the locally vertical and possibly both local horizontal components of a constant rotation vector. A more general implementation of <a href="#Oceananigans.Coriolis.FPlane"><code>FPlane</code></a>, which only accounts for the locally vertical component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Coriolis/constant_cartesian_coriolis.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.ConstantCartesianCoriolis" href="#Oceananigans.Coriolis.ConstantCartesianCoriolis"><code>Oceananigans.Coriolis.ConstantCartesianCoriolis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConstantCartesianCoriolis([FT=Float64;] fx=nothing, fy=nothing, fz=nothing,
                                        f=nothing, rotation_axis=ZDirection(), 
                                        rotation_rate=Ω_Earth, latitude=nothing)</code></pre><p>Returns a parameter object for a constant rotation decomposed into the <code>x</code>, <code>y</code> and <code>z</code> directions. In oceanography the components <code>x</code>, <code>y</code>, <code>z</code> correspond to the directions east, north, and up. This rotation can be specified in three different ways:</p><ul><li>Specifying all components <code>fx</code>, <code>fy</code> and <code>fz</code> directly.</li><li>Specifying the Coriolis parameter <code>f</code> and (optionally) a <code>rotation_axis</code> (which defaults to the <code>z</code> direction if not specified).</li><li>Specifying <code>latitude</code> (in degrees) and (optionally) a <code>rotation_rate</code> in radians per second (which defaults to Earth&#39;s rotation rate).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Coriolis/constant_cartesian_coriolis.jl#L16-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.FPlane" href="#Oceananigans.Coriolis.FPlane"><code>Oceananigans.Coriolis.FPlane</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FPlane{FT} &lt;: AbstractRotation</code></pre><p>A parameter object for constant rotation around a vertical axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Coriolis/f_plane.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.FPlane" href="#Oceananigans.Coriolis.FPlane"><code>Oceananigans.Coriolis.FPlane</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FPlane([FT=Float64;] f=nothing, rotation_rate=Ω_Earth, latitude=nothing)</code></pre><p>Returns a parameter object for constant rotation at the angular frequency <code>f/2</code>, and therefore with background vorticity <code>f</code>, around a vertical axis. If <code>f</code> is not specified, it is calculated from <code>rotation_rate</code> and <code>latitude</code> (in degrees) according to the relation <code>f = 2 * rotation_rate * sind(latitude)</code>.</p><p>By default, <code>rotation_rate</code> is assumed to be Earth&#39;s.</p><p>Also called <code>FPlane</code>, after the &quot;f-plane&quot; approximation for the local effect of a planet&#39;s rotation in a planar coordinate system tangent to the planet&#39;s surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Coriolis/f_plane.jl#L12-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.HydrostaticSphericalCoriolis" href="#Oceananigans.Coriolis.HydrostaticSphericalCoriolis"><code>Oceananigans.Coriolis.HydrostaticSphericalCoriolis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HydrostaticSphericalCoriolis{FT} &lt;: AbstractRotation</code></pre><p>A parameter object for constant rotation around a vertical axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Coriolis/hydrostatic_spherical_coriolis.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.HydrostaticSphericalCoriolis-Union{Tuple{}, Tuple{DataType}, Tuple{S}} where S" href="#Oceananigans.Coriolis.HydrostaticSphericalCoriolis-Union{Tuple{}, Tuple{DataType}, Tuple{S}} where S"><code>Oceananigans.Coriolis.HydrostaticSphericalCoriolis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HydrostaticSphericalCoriolis([FT=Float64;] rotation_rate=Ω_Earth, scheme=VectorInvariantEnergyConserving()))</code></pre><p>Returns a parameter object for Coriolis forces on a sphere rotating at <code>rotation_rate</code>. By default, <code>rotation_rate</code> is assumed to be Earth&#39;s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Coriolis/hydrostatic_spherical_coriolis.jl#L21-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.NonTraditionalBetaPlane" href="#Oceananigans.Coriolis.NonTraditionalBetaPlane"><code>Oceananigans.Coriolis.NonTraditionalBetaPlane</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NonTraditionalBetaPlane{FT} &lt;: AbstractRotation</code></pre><p>A Coriolis implementation that accounts for the latitudinal variation of both the locally vertical and the locally horizontal components of the rotation vector. The &quot;traditional&quot; approximation in ocean models accounts for only the locally vertical component of the rotation vector (see <a href="#Oceananigans.Coriolis.BetaPlane"><code>BetaPlane</code></a>).</p><p>This implementation is based off of section 5 of Dellar (2011). It conserve energy, angular momentum, and potential vorticity.</p><p><strong>References</strong></p><p>Dellar, P. (2011). Variations on a beta-plane: Derivation of non-traditional     beta-plane equations from Hamilton&#39;s principle on a sphere. Journal of     Fluid Mechanics, 674, 174-195. doi:10.1017/S0022112010006464</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Coriolis/non_traditional_beta_plane.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.NonTraditionalBetaPlane" href="#Oceananigans.Coriolis.NonTraditionalBetaPlane"><code>Oceananigans.Coriolis.NonTraditionalBetaPlane</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NonTraditionalBetaPlane(FT=Float64;
                        fz=nothing, fy=nothing, β=nothing, γ=nothing,
                        rotation_rate=Ω_Earth, latitude=nothing, radius=R_Earth)</code></pre><p>The user may directly specify <code>fz</code>, <code>fy</code>, <code>β</code>, <code>γ</code>, and <code>radius</code> or the three parameters <code>rotation_rate</code>, <code>latitude</code> (in degrees), and <code>radius</code> that specify the rotation rate and radius of a planet, and the central latitude (where <span>$y = 0$</span>) at which the non-traditional <code>β</code>-plane approximation is to be made.</p><p>If <code>fz</code>, <code>fy</code>, <code>β</code>, and <code>γ</code> are not specified, they are calculated from <code>rotation_rate</code>,  <code>latitude</code>, and <code>radius</code> according to the relations <code>fz = 2 * rotation_rate * sind(latitude)</code>, <code>fy = 2 * rotation_rate * cosd(latitude)</code>, <code>β = 2 * rotation_rate * cosd(latitude) / radius</code>, and <code>γ = - 4 * rotation_rate * sind(latitude) / radius</code>.</p><p>By default, the <code>rotation_rate</code> and planet <code>radius</code> is assumed to be Earth&#39;s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Coriolis/non_traditional_beta_plane.jl#L26-L42">source</a></section></article><h2 id="Diagnostics"><a class="docs-heading-anchor" href="#Diagnostics">Diagnostics</a><a id="Diagnostics-1"></a><a class="docs-heading-anchor-permalink" href="#Diagnostics" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.CFL" href="#Oceananigans.Diagnostics.CFL"><code>Oceananigans.Diagnostics.CFL</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CFL{D, S}</code></pre><p>An object for computing the Courant-Freidrichs-Lewy (CFL) number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Diagnostics/cfl.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.CFL-Tuple{Any}" href="#Oceananigans.Diagnostics.CFL-Tuple{Any}"><code>Oceananigans.Diagnostics.CFL</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CFL(Δt [, timescale=Oceananigans.cell_advection_timescale])</code></pre><p>Returns an object for computing the Courant-Freidrichs-Lewy (CFL) number associated with time step or <code>TimeStepWizard</code> <code>Δt</code> and <code>timescale</code>.</p><p>See also <code>AdvectiveCFL</code> and <code>DiffusiveCFL</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Diagnostics/cfl.jl#L14-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.StateChecker-Tuple{Any}" href="#Oceananigans.Diagnostics.StateChecker-Tuple{Any}"><code>Oceananigans.Diagnostics.StateChecker</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">StateChecker(; schedule, fields)</code></pre><p>Returns a <code>StateChecker</code> that logs field information (minimum, maximum, mean) for each field in a named tuple of <code>fields</code> when <code>schedule</code> actuates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Diagnostics/state_checker.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.AdvectiveCFL-Tuple{Any}" href="#Oceananigans.Diagnostics.AdvectiveCFL-Tuple{Any}"><code>Oceananigans.Diagnostics.AdvectiveCFL</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AdvectiveCFL(Δt)</code></pre><p>Returns an object for computing the Courant-Freidrichs-Lewy (CFL) number associated with time step or <code>TimeStepWizard</code> <code>Δt</code> and the time scale for advection across a cell.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; model = NonhydrostaticModel(grid=RectilinearGrid(size=(16, 16, 16), length=(8, 8, 8)));

julia&gt; cfl = AdvectiveCFL(1.0);

julia&gt; data(model.velocities.u) .= π;

julia&gt; cfl(model)
6.283185307179586</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Diagnostics/cfl.jl#L26-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.DiffusiveCFL-Tuple{Any}" href="#Oceananigans.Diagnostics.DiffusiveCFL-Tuple{Any}"><code>Oceananigans.Diagnostics.DiffusiveCFL</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DiffusiveCFL(Δt)</code></pre><p>Returns an object for computing the diffusive Courant-Freidrichs-Lewy (CFL) number associated with time step or <code>TimeStepWizard</code> <code>Δt</code> and the time scale for diffusion across a cell associated with <code>model.closure</code>.</p><p>The maximum diffusive CFL number among viscosity and all tracer diffusivities is returned.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; model = NonhydrostaticModel(grid=RectilinearGrid(size=(16, 16, 16), length=(1, 1, 1)));

julia&gt; dcfl = DiffusiveCFL(0.1);

julia&gt; dcfl(model)
2.688e-5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Diagnostics/cfl.jl#L48-L68">source</a></section></article><h2 id="Fields"><a class="docs-heading-anchor" href="#Fields">Fields</a><a id="Fields-1"></a><a class="docs-heading-anchor-permalink" href="#Fields" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.AbstractField" href="#Oceananigans.Fields.AbstractField"><code>Oceananigans.Fields.AbstractField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractField{LX, LY, LZ, G, T, N}</code></pre><p>Abstract supertype for fields located at <code>(LX, LY, LZ)</code> and defined on a grid <code>G</code> with eltype <code>T</code> and <code>N</code> dimensions.</p><p>Note: we need the parameter <code>T</code> to subtype AbstractArray.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Fields/abstract_field.jl#L21-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.BackgroundField" href="#Oceananigans.Fields.BackgroundField"><code>Oceananigans.Fields.BackgroundField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BackgroundField{F, P}</code></pre><p>Temporary container for storing information about <code>BackgroundFields</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Fields/background_fields.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.BackgroundField-Tuple{Any}" href="#Oceananigans.Fields.BackgroundField-Tuple{Any}"><code>Oceananigans.Fields.BackgroundField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BackgroundField(func; parameters=nothing)</code></pre><p>Returns a <code>BackgroundField</code> to be passed to <code>NonhydrostaticModel</code> for use as a background velocity or tracer field.</p><p>If <code>parameters</code> is not provided, <code>func</code> must be callable with the signature</p><pre><code class="language-julia hljs">func(x, y, z, t)</code></pre><p>If <code>parameters</code> is provided, <code>func</code> must be callable with the signature</p><pre><code class="language-julia hljs">func(x, y, z, t, parameters)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Fields/background_fields.jl#L43-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.Field-Union{Tuple{Oceananigans.Grids.AbstractGrid}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Oceananigans.Grids.AbstractGrid, DataType}} where {LX, LY, LZ}" href="#Oceananigans.Fields.Field-Union{Tuple{Oceananigans.Grids.AbstractGrid}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Oceananigans.Grids.AbstractGrid, DataType}} where {LX, LY, LZ}"><code>Oceananigans.Fields.Field</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Field{LX, LY, LZ}(grid::AbstractGrid,
                  T::DataType=eltype(grid); kw...) where {LX, LY, LZ}</code></pre><p>Construct a <code>Field</code> on <code>grid</code> with data type <code>T</code> at the location <code>(LX, LY, LZ)</code>. Each of <code>(LX, LY, LZ)</code> is either <code>Center</code> or <code>Face</code> and determines the field&#39;s location in <code>(x, y, z)</code> respectively.</p><p><strong>Keyword arguments</strong></p><ul><li><code>data :: OffsetArray</code>: An offset array with the fields data. If nothing is providet the field is filled with zeros.</li><li><code>boundary_conditions</code>: If nothing is provided, then field is created using the default boundary conditions via <a href="#Oceananigans.BoundaryConditions.FieldBoundaryConditions"><code>FieldBoundaryConditions</code></a>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; ω = Field{Face, Face, Center}(RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)))
1×1×1 Field{Face, Face, Center} on RectilinearGrid on CPU
├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo
├── boundary conditions: FieldBoundaryConditions
│   └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux
└── data: 3×3×3 OffsetArray(::Array{Float64, 3}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2×0:2×0:2
    └── max=0.0, min=0.0, mean=0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Fields/field.jl#L111-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.Reduction-Tuple{Any, Any}" href="#Oceananigans.Fields.Reduction-Tuple{Any, Any}"><code>Oceananigans.Fields.Reduction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Reduction(reduce!, operand; dims)</code></pre><p>Return a <code>Reduction</code> of <code>operand</code> with <code>reduce!</code>, along <code>dims</code>. Note that <code>Reduction</code> expects a <code>reduce!</code> operation that works in-place.</p><p>Field elements for which <code>condition(i ,j ,k) == true</code> are masked with a <code>mask</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Oceananigans

Nx, Ny, Nz = 3, 3, 3

grid = RectilinearGrid(size=(Nx, Ny, Nz), x=(0, 1), y=(0, 1), z=(0, 1),
                       topology=(Periodic, Periodic, Periodic))

c = CenterField(grid)

set!(c, (x, y, z) -&gt; x + y + z)

max_c² = Field(Reduction(maximum!, c^2, dims=3))

compute!(max_c²)

max_c²[1:Nx, 1:Ny]

# output
3×3 Matrix{Float64}:
 1.36111  2.25     3.36111
 2.25     3.36111  4.69444
 3.36111  4.69444  6.25</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Fields/field_reductions.jl#L11-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.CenterField" href="#Oceananigans.Fields.CenterField"><code>Oceananigans.Fields.CenterField</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">CenterField(grid; kw...)</code></pre><p>Returns <code>Field{Center, Center, Center}</code> on <code>arch</code>itecture and <code>grid</code>. Additional keyword arguments are passed to the <code>Field</code> constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Fields/field.jl#L162-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.PressureFields" href="#Oceananigans.Fields.PressureFields"><code>Oceananigans.Fields.PressureFields</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">PressureFields(grid, bcs::NamedTuple)</code></pre><p>Return a <code>NamedTuple</code> with pressure fields <code>pHY′</code> and <code>pNHS</code> initialized as <code>CenterField</code>s on <code>grid</code>.  Boundary conditions <code>bcs</code> may be specified via a named tuple of <code>FieldBoundaryCondition</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Fields/field_tuples.jl#L116-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.PressureFields-Tuple{NamedTuple{(:pHY′, :pNHS), T} where T&lt;:Tuple, Any, Any}" href="#Oceananigans.Fields.PressureFields-Tuple{NamedTuple{(:pHY′, :pNHS), T} where T&lt;:Tuple, Any, Any}"><code>Oceananigans.Fields.PressureFields</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PressureFields(proposed_pressures::NamedTuple{(:pHY′, :pNHS)}, grid, bcs)</code></pre><p>Return a <code>NamedTuple</code> of pressure fields with, overwriting boundary conditions in <code>proposed_tracer_fields</code> with corresponding fields in the <code>NamedTuple</code> <code>bcs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Fields/field_tuples.jl#L212-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.TendencyFields-Tuple{Any, Any}" href="#Oceananigans.Fields.TendencyFields-Tuple{Any, Any}"><code>Oceananigans.Fields.TendencyFields</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TendencyFields(grid, tracer_names;
               u = XFaceField(grid),
               v = YFaceField(grid),
               w = ZFaceField(grid),
               kwargs...)</code></pre><p>Return a <code>NamedTuple</code> with tendencies for all solution fields (velocity fields and tracer fields), initialized on <code>grid</code>. Optional <code>kwargs</code> can be specified to assign data arrays to each tendency field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Fields/field_tuples.jl#L148-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.TracerFields-Tuple{Any, Any, Any}" href="#Oceananigans.Fields.TracerFields-Tuple{Any, Any, Any}"><code>Oceananigans.Fields.TracerFields</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TracerFields(tracer_names, grid, user_bcs)</code></pre><p>Return a <code>NamedTuple</code> with tracer fields specified by <code>tracer_names</code> initialized as <code>CenterField</code>s on <code>grid</code>. Boundary conditions <code>user_bcs</code> may be specified via a named tuple of <code>FieldBoundaryCondition</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Fields/field_tuples.jl#L80-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.TracerFields-Tuple{Any, Any}" href="#Oceananigans.Fields.TracerFields-Tuple{Any, Any}"><code>Oceananigans.Fields.TracerFields</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TracerFields(tracer_names, grid; kwargs...)</code></pre><p>Return a <code>NamedTuple</code> with tracer fields specified by <code>tracer_names</code> initialized as <code>CenterField</code>s on <code>grid</code>. Fields may be passed via optional keyword arguments <code>kwargs</code> for each field.</p><p>This function is used by <code>OutputWriters.Checkpointer</code> and <code>TendencyFields</code>. ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Fields/field_tuples.jl#L93-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.TracerFields-Tuple{NamedTuple, Any, Any}" href="#Oceananigans.Fields.TracerFields-Tuple{NamedTuple, Any, Any}"><code>Oceananigans.Fields.TracerFields</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TracerFields(proposed_tracers::NamedTuple, grid, bcs)</code></pre><p>Return a <code>NamedTuple</code> of tracers, overwriting boundary conditions in <code>proposed_tracers</code> with corresponding fields in the <code>NamedTuple</code> <code>bcs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Fields/field_tuples.jl#L196-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.TracerFields-Tuple{NamedTuple{(), Tuple{}}, Any, Any}" href="#Oceananigans.Fields.TracerFields-Tuple{NamedTuple{(), Tuple{}}, Any, Any}"><code>Oceananigans.Fields.TracerFields</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Shortcut constructor for empty tracer fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Fields/field_tuples.jl#L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.VelocityFields" href="#Oceananigans.Fields.VelocityFields"><code>Oceananigans.Fields.VelocityFields</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">VelocityFields(grid, user_bcs = NamedTuple())</code></pre><p>Return a <code>NamedTuple</code> with fields <code>u</code>, <code>v</code>, <code>w</code> initialized on <code>grid</code>. Boundary conditions <code>bcs</code> may be specified via a named tuple of <code>FieldBoundaryCondition</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Fields/field_tuples.jl#L50-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.VelocityFields-Tuple{NamedTuple{(:u, :v, :w), T} where T&lt;:Tuple, Any, Any}" href="#Oceananigans.Fields.VelocityFields-Tuple{NamedTuple{(:u, :v, :w), T} where T&lt;:Tuple, Any, Any}"><code>Oceananigans.Fields.VelocityFields</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">VelocityFields(proposed_velocities::NamedTuple{(:u, :v, :w)}, grid, bcs)</code></pre><p>Return a <code>NamedTuple</code> of velocity fields, overwriting boundary conditions in <code>proposed_velocities</code> with corresponding fields in the <code>NamedTuple</code> <code>bcs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Fields/field_tuples.jl#L179-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.XFaceField" href="#Oceananigans.Fields.XFaceField"><code>Oceananigans.Fields.XFaceField</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">XFaceField(grid; kw...)</code></pre><p>Returns <code>Field{Face, Center, Center}</code> on <code>grid</code>. Additional keyword arguments are passed to the <code>Field</code> constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Fields/field.jl#L170-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.YFaceField" href="#Oceananigans.Fields.YFaceField"><code>Oceananigans.Fields.YFaceField</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">YFaceField(grid; kw...)</code></pre><p>Returns <code>Field{Center, Face, Center}</code> on <code>grid</code>. Additional keyword arguments are passed to the <code>Field</code> constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Fields/field.jl#L178-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.ZFaceField" href="#Oceananigans.Fields.ZFaceField"><code>Oceananigans.Fields.ZFaceField</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ZFaceField(grid; kw...)</code></pre><p>Returns <code>Field{Center, Center, Face}</code> on <code>grid</code>. Additional keyword arguments are passed to the <code>Field</code> constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Fields/field.jl#L186-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.compute!" href="#Oceananigans.Fields.compute!"><code>Oceananigans.Fields.compute!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute!(field)</code></pre><p>Computes <code>field.data</code> from <code>field.operand</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Fields/field.jl#L364-L368">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.field-Tuple{Any, AbstractArray, Any}" href="#Oceananigans.Fields.field-Tuple{Any, AbstractArray, Any}"><code>Oceananigans.Fields.field</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">field(loc, a, grid)</code></pre><p>Build a field from <code>a</code> at <code>loc</code> and on <code>grid</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Fields/Fields.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.interior-Tuple{Field}" href="#Oceananigans.Fields.interior-Tuple{Field}"><code>Oceananigans.Fields.interior</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">interior(f::Field)</code></pre><p>Returns a view of <code>f</code> that excludes halo points.&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Fields/field.jl#L324-L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.interpolate-NTuple{4, Any}" href="#Oceananigans.Fields.interpolate-NTuple{4, Any}"><code>Oceananigans.Fields.interpolate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">interpolate(field, x, y, z)</code></pre><p>Interpolate <code>field</code> to the physical point <code>(x, y, z)</code> using trilinear interpolation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Fields/interpolate.jl#L83-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.regrid!-Tuple{Any, Any}" href="#Oceananigans.Fields.regrid!-Tuple{Any, Any}"><code>Oceananigans.Fields.regrid!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">regrid!(a, b)</code></pre><p>Regrid field <code>b</code> onto the grid of field <code>a</code>. </p><div class="admonition is-warning"><header class="admonition-header">Functionality limitation</header><div class="admonition-body"><p>Currently <code>regrid!</code> only regrids in the vertical <span>$z$</span> direction and works only on fields that have data only in <span>$z$</span> direction.</p></div></div><p><strong>Example</strong></p><p>Generate a tracer field on a vertically stretched grid and regrid it on a regular grid.</p><pre><code class="language-julia hljs">using Oceananigans

Nz, Lz = 2, 1.0
topology = (Flat, Flat, Bounded)

input_grid = RectilinearGrid(size=Nz, z = [0, Lz/3, Lz], topology=topology)
input_field = CenterField(input_grid)
input_field[1, 1, 1:Nz] = [2, 3]

output_grid = RectilinearGrid(size=Nz, z=(0, Lz), topology=topology)
output_field = CenterField(output_grid)

regrid!(output_field, input_field)

output_field[1, 1, :]

# output
4-element OffsetArray(::Vector{Float64}, 0:3) with eltype Float64 with indices 0:3:
 0.0
 2.333333333333334
 3.0
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Fields/regridding_fields.jl#L9-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.location-Tuple{Any}" href="#Oceananigans.location-Tuple{Any}"><code>Oceananigans.location</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns the location <code>(LX, LY, LZ)</code> of an <code>AbstractField{LX, LY, LZ}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Fields/abstract_field.jl#L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.@compute-Tuple{Any}" href="#Oceananigans.Fields.@compute-Tuple{Any}"><code>Oceananigans.Fields.@compute</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@compute(exprs...)</code></pre><p>Call <code>compute!</code> on fields after defining them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Fields/field.jl#L371-L375">source</a></section></article><h2 id="Forcings"><a class="docs-heading-anchor" href="#Forcings">Forcings</a><a id="Forcings-1"></a><a class="docs-heading-anchor-permalink" href="#Forcings" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.ContinuousForcing" href="#Oceananigans.Forcings.ContinuousForcing"><code>Oceananigans.Forcings.ContinuousForcing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ContinuousForcing{LX, LY, LZ, P, F, D, I, ℑ}</code></pre><p>A callable object that implements a &quot;continuous form&quot; forcing function on a field at the location <code>LX, LY, LZ</code> with optional parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Forcings/continuous_forcing.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.ContinuousForcing-Tuple{Any}" href="#Oceananigans.Forcings.ContinuousForcing-Tuple{Any}"><code>Oceananigans.Forcings.ContinuousForcing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ContinuousForcing(func; parameters=nothing, field_dependencies=())</code></pre><p>Construct a &quot;continuous form&quot; forcing with optional <code>parameters</code> and optional <code>field_dependencies</code> on other fields in a model.</p><p>If neither <code>parameters</code> nor <code>field_dependencies</code> are provided, then <code>func</code> must be callable with the signature</p><pre><code class="language-julia hljs">func(x, y, z, t)</code></pre><p>where <code>x, y, z</code> are the east-west, north-south, and vertical spatial coordinates, and <code>t</code> is time.</p><p>If <code>field_dependencies</code> are provided, the signature of <code>func</code> must include them. For example, if <code>field_dependencies=(:u, :S)</code> (and <code>parameters</code> are <em>not</em> provided), then <code>func</code> must be callable with the signature</p><pre><code class="language-julia hljs">func(x, y, z, t, u, S)</code></pre><p>where <code>u</code> is assumed to be the <code>u</code>-velocity component, and <code>S</code> is a tracer. Note that any field which does not have the name <code>u</code>, <code>v</code>, or <code>w</code> is assumed to be a tracer and must be present in <code>model.tracers</code>.</p><p>If <code>parameters</code> are provided, then the <em>last</em> argument to <code>func</code> must be <code>parameters</code>. For example, if <code>func</code> has no <code>field_dependencies</code> but does depend on <code>parameters</code>, then it must be callable with the signature</p><pre><code class="language-julia hljs">func(x, y, z, t, parameters)</code></pre><p>With <code>field_dependencies=(:u, :v, :w, :c)</code> and <code>parameters</code>, then <code>func</code> must be callable with the signature</p><pre><code class="language-julia hljs">func(x, y, z, t, u, v, w, c, parameters)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Forcings/continuous_forcing.jl#L47-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.DiscreteForcing" href="#Oceananigans.Forcings.DiscreteForcing"><code>Oceananigans.Forcings.DiscreteForcing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DiscreteForcing{P, F}</code></pre><p>Wrapper for &quot;discrete form&quot; forcing functions with optional <code>parameters</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Forcings/discrete_forcing.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.DiscreteForcing-Tuple{Any}" href="#Oceananigans.Forcings.DiscreteForcing-Tuple{Any}"><code>Oceananigans.Forcings.DiscreteForcing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DiscreteForcing(func; parameters=nothing)</code></pre><p>Construct a &quot;discrete form&quot; forcing function with optional parameters. The forcing function is applied at grid point <code>i, j, k</code>.</p><p>When <code>parameters</code> are not specified, <code>func</code> must be callable with the signature</p><pre><code class="nohighlight hljs">func(i, j, k, grid, clock, model_fields)</code></pre><p>where <code>grid</code> is <code>model.grid</code>, <code>clock.time</code> is the current simulation time and <code>clock.iteration</code> is the current model iteration, and <code>model_fields</code> is a <code>NamedTuple</code> with <code>u, v, w</code> and the fields in <code>model.tracers</code>.</p><p><em>Note</em> that the index <code>end</code> does <em>not</em> access the final physical grid point of a model field in any direction. The final grid point must be explicitly specified, as in <code>model_fields.u[i, j, grid.Nz]</code>.</p><p>When <code>parameters</code> <em>is</em> specified, <code>func</code> must be callable with the signature.</p><pre><code class="nohighlight hljs">func(i, j, k, grid, clock, model_fields, parameters)</code></pre><p>Above, <code>parameters</code> is, in principle, arbitrary. Note, however, that GPU compilation can place constraints on <code>typeof(parameters)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Forcings/discrete_forcing.jl#L15-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.GaussianMask" href="#Oceananigans.Forcings.GaussianMask"><code>Oceananigans.Forcings.GaussianMask</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GaussianMask{D}(center, width)</code></pre><p>Callable object that returns a Gaussian masking function centered on <code>center</code>, with <code>width</code>, and varying along direction <code>D</code>, i.e.,</p><pre><code class="nohighlight hljs">exp(-(D - center)^2 / (2 * width^2))</code></pre><p><strong>Examples</strong></p><ul><li>Create a Gaussian mask centered on <code>z=0</code> with width <code>1</code> meter.</li></ul><pre><code class="language-julia hljs">julia&gt; mask = GaussianMask{:z}(center=0, width=1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Forcings/relaxation.jl#L100-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.LinearTarget" href="#Oceananigans.Forcings.LinearTarget"><code>Oceananigans.Forcings.LinearTarget</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinearTarget{D}(intercept, gradient)</code></pre><p>Callable object that returns a Linear target function with <code>intercept</code> and <code>gradient</code>, and varying along direction <code>D</code>, i.e.,</p><pre><code class="nohighlight hljs">intercept + D * gradient</code></pre><p><strong>Examples</strong></p><ul><li><p>Create a linear target function varying in <code>z</code>, equal to <code>0</code> at <code>z=0</code> and with gradient 10⁻⁶:</p><pre><code class="language-julia hljs">julia&gt; target = LinearTarget{:z}(intercept=0, gradient=1e-6)</code></pre></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Forcings/relaxation.jl#L144-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.Relaxation" href="#Oceananigans.Forcings.Relaxation"><code>Oceananigans.Forcings.Relaxation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Relaxation{R, M, T}</code></pre><p>Callable object for restoring fields to a <code>target</code> at some <code>rate</code> and within a <code>mask</code>ed region in <code>x, y, z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Forcings/relaxation.jl#L11-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.Relaxation-Tuple{}" href="#Oceananigans.Forcings.Relaxation-Tuple{}"><code>Oceananigans.Forcings.Relaxation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Relaxation(; rate, mask=onefunction, target=zerofunction)</code></pre><p>Returns a <code>Forcing</code> that restores a field to <code>target(x, y, z, t)</code> at the specified <code>rate</code>, in the region <code>mask(x, y, z)</code>.</p><p>The functions <code>onefunction</code> and <code>zerofunction</code> always return 1 and 0, respectively. Thus the default <code>mask</code> leaves the whole domain uncovered, and the default <code>target</code> is zero.</p><p><strong>Example</strong></p><ul><li>Restore a field to zero on a timescale of &quot;3600&quot; (equal to one hour if the time units of the simulation are seconds).</li></ul><pre><code class="language-julia hljs">using Oceananigans

damping = Relaxation(rate = 1/3600)

# output
Relaxation{Float64, typeof(Oceananigans.Forcings.onefunction), typeof(Oceananigans.Forcings.zerofunction)}
├── rate: 0.0002777777777777778
├── mask: 1
└── target: 0</code></pre><ul><li>Restore a field to a linear z-gradient within the bottom 1/4 of a domain on a timescale of &quot;60&quot; (equal to one minute if the time units of the simulation are seconds).</li></ul><pre><code class="language-julia hljs">dTdz = 0.001 # ⁰C m⁻¹, temperature gradient

T₀ = 20 # ⁰C, surface temperature at z=0

Lz = 100 # m, depth of domain

bottom_sponge_layer = Relaxation(; rate = 1/60,
                                   target = LinearTarget{:z}(intercept=T₀, gradient=dTdz),
                                   mask = GaussianMask{:z}(center=-Lz, width=Lz/4))

# output
Relaxation{Float64, GaussianMask{:z, Float64}, LinearTarget{:z, Float64}}
├── rate: 0.016666666666666666
├── mask: exp(-(z + 100.0)^2 / (2 * 25.0^2))
└── target: 20.0 + 0.001 * z</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Forcings/relaxation.jl#L23-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.Forcing-Tuple{Any}" href="#Oceananigans.Forcings.Forcing-Tuple{Any}"><code>Oceananigans.Forcings.Forcing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Forcing(func; parameters=nothing, field_dependencies=(), discrete_form=false)</code></pre><p>Returns a forcing function added to the tendency of an Oceananigans model field.</p><p>If <code>discrete_form=false</code> (the default), and neither <code>parameters</code> nor <code>field_dependencies</code> are provided, then <code>func</code> must be callable with the signature</p><pre><code class="nohighlight hljs">func(x, y, z, t)</code></pre><p>where <code>x, y, z</code> are the east-west, north-south, and vertical spatial coordinates, and <code>t</code> is time. Note that this form is also default in the constructor for <code>NonhydrostaticModel</code>, so that <code>Forcing</code> is not needed.</p><p>If <code>discrete_form=false</code> (the default), and <code>field_dependencies</code> are provided, the signature of <code>func</code> must include them. For example, if <code>field_dependencies=(:u, :S)</code> (and <code>parameters</code> are <em>not</em> provided), then <code>func</code> must be callable with the signature</p><pre><code class="nohighlight hljs">func(x, y, z, t, u, S)`</code></pre><p>where <code>u</code> is assumed to be the <code>u</code>-velocity component, and <code>S</code> is a tracer. Note that any field which does not have the name <code>u</code>, <code>v</code>, or <code>w</code> is assumed to be a tracer and must be present in <code>model.tracers</code>.</p><p>If <code>discrete_form=false</code> (the default) and <code>parameters</code> are provided, then the <em>last</em> argument to <code>func</code> must be <code>parameters</code>. For example, if <code>func</code> has no <code>field_dependencies</code> but does depend on <code>parameters</code>, then it must be callable with the signature</p><pre><code class="nohighlight hljs">func(x, y, z, t, parameters)</code></pre><p>The object <code>parameters</code> is arbitrary in principle, however GPU compilation can place constraints on <code>typeof(parameters)</code>.</p><p>With <code>field_dependencies=(:u, :v, :w, :c)</code> and <code>parameters</code>, then <code>func</code> must be callable with the signature</p><pre><code class="nohighlight hljs">func(x, y, z, t, u, v, w, c, parameters)</code></pre><p>If <code>discrete_form=true</code> then <code>func</code> must be callable with the &quot;discrete form&quot;</p><pre><code class="nohighlight hljs">func(i, j, k, grid, clock, model_fields)</code></pre><p>where <code>i, j, k</code> is the grid point at which the forcing is applied, <code>grid</code> is <code>model.grid</code>, <code>clock.time</code> is the current simulation time and <code>clock.iteration</code> is the current model iteration, and <code>model_fields</code> is a <code>NamedTuple</code> with <code>u, v, w</code>, the fields in <code>model.tracers</code>, and the fields in <code>model.diffusivity_fields</code>, each of which is an <code>OffsetArray</code>s (or <code>NamedTuple</code>s of <code>OffsetArray</code>s depending on the turbulence closure) of field data.</p><p>When <code>discrete_form=true</code> and <code>parameters</code> <em>is</em> specified, <code>func</code> must be callable with the signature</p><pre><code class="nohighlight hljs">func(i, j, k, grid, clock, model_fields, parameters)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Oceananigans

# Parameterized forcing
parameterized_func(x, y, z, t, p) = p.μ * exp(z / p.λ) * cos(p.ω * t)

v_forcing = Forcing(parameterized_func, parameters = (μ=42, λ=0.1, ω=π))

# output
ContinuousForcing{NamedTuple{(:μ, :λ, :ω), Tuple{Int64, Float64, Irrational{:π}}}}
├── func: parameterized_func (generic function with 1 method)
├── parameters: (μ = 42, λ = 0.1, ω = π)
└── field dependencies: ()</code></pre><p>Note that because forcing locations are regularized within the <code>NonhydrostaticModel</code> constructor:</p><pre><code class="language-julia hljs">grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))
model = NonhydrostaticModel(grid=grid, forcing=(v=v_forcing,))

model.forcing.v

# output
ContinuousForcing{NamedTuple{(:μ, :λ, :ω), Tuple{Int64, Float64, Irrational{:π}}}} at (Center, Face, Center)
├── func: parameterized_func (generic function with 1 method)
├── parameters: (μ = 42, λ = 0.1, ω = π)
└── field dependencies: ()</code></pre><p>After passing through the constructor for <code>NonhydrostaticModel</code>, the <code>v</code>-forcing location information is available and set to <code>Center, Face, Center</code>.</p><pre><code class="language-julia hljs"># Field-dependent forcing
growth_in_sunlight(x, y, z, t, P) = exp(z) * P

plankton_forcing = Forcing(growth_in_sunlight, field_dependencies=:P)

# output
ContinuousForcing{Nothing}
├── func: growth_in_sunlight (generic function with 1 method)
├── parameters: nothing
└── field dependencies: (:P,)</code></pre><pre><code class="language-julia hljs"># Parameterized, field-dependent forcing
tracer_relaxation(x, y, z, t, c, p) = p.μ * exp((z + p.H) / p.λ) * (p.dCdz * z - c) 

c_forcing = Forcing(tracer_relaxation,
                    field_dependencies = :c,
                            parameters = (μ=1/60, λ=10, H=1000, dCdz=1))

# output
ContinuousForcing{NamedTuple{(:μ, :λ, :H, :dCdz), Tuple{Float64, Int64, Int64, Int64}}}
├── func: tracer_relaxation (generic function with 1 method)
├── parameters: (μ = 0.016666666666666666, λ = 10, H = 1000, dCdz = 1)
└── field dependencies: (:c,)</code></pre><pre><code class="language-julia hljs"># Unparameterized discrete-form forcing function
filtered_relaxation(i, j, k, grid, clock, model_fields) =
    @inbounds - (model_fields.c[i-1, j, k] + model_fields.c[i, j, k] + model_fields.c[i+1, j, k]) / 3

filtered_forcing = Forcing(filtered_relaxation, discrete_form=true)

# output
DiscreteForcing{Nothing}
├── func: filtered_relaxation (generic function with 1 method)
└── parameters: nothing</code></pre><pre><code class="language-julia hljs"># Discrete-form forcing function with parameters
masked_damping(i, j, k, grid, clock, model_fields, parameters) = 
    @inbounds - parameters.μ * exp(grid.zᵃᵃᶜ[k] / parameters.λ) * model_fields.u[i, j, k]

masked_damping_forcing = Forcing(masked_damping, parameters=(μ=42, λ=π), discrete_form=true)

# output
DiscreteForcing{NamedTuple{(:μ, :λ), Tuple{Int64, Irrational{:π}}}}
├── func: masked_damping (generic function with 1 method)
└── parameters: (μ = 42, λ = π)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Forcings/forcing.jl#L1-L155">source</a></section></article><h2 id="Grids"><a class="docs-heading-anchor" href="#Grids">Grids</a><a id="Grids-1"></a><a class="docs-heading-anchor-permalink" href="#Grids" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.AbstractCurvilinearGrid" href="#Oceananigans.Grids.AbstractCurvilinearGrid"><code>Oceananigans.Grids.AbstractCurvilinearGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractCurvilinearGrid{FT, TX, TY, TZ}</code></pre><p>Abstract supertype for curvilinear grids with elements of type <code>FT</code> and topology <code>{TX, TY, TZ}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Grids/Grids.jl#L102-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.AbstractGrid" href="#Oceananigans.Grids.AbstractGrid"><code>Oceananigans.Grids.AbstractGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractGrid{FT, TX, TY, TZ}</code></pre><p>Abstract supertype for grids with elements of type <code>FT</code> and topology <code>{TX, TY, TZ}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Grids/Grids.jl#L80-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.AbstractHorizontallyCurvilinearGrid" href="#Oceananigans.Grids.AbstractHorizontallyCurvilinearGrid"><code>Oceananigans.Grids.AbstractHorizontallyCurvilinearGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractHorizontallyCurvilinearGrid{FT, TX, TY, TZ}</code></pre><p>Abstract supertype for horizontally-curvilinear grids with elements of type <code>FT</code> and topology <code>{TX, TY, TZ}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Grids/Grids.jl#L109-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.AbstractRectilinearGrid" href="#Oceananigans.Grids.AbstractRectilinearGrid"><code>Oceananigans.Grids.AbstractRectilinearGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractRectilinearGrid{FT, TX, TY, TZ}</code></pre><p>Abstract supertype for rectilinear grids with elements of type <code>FT</code> and topology <code>{TX, TY, TZ}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Grids/Grids.jl#L95-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.AbstractTopology" href="#Oceananigans.Grids.AbstractTopology"><code>Oceananigans.Grids.AbstractTopology</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractTopology</code></pre><p>Abstract supertype for grid topologies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Grids/Grids.jl#L44-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.AbstractUnderlyingGrid" href="#Oceananigans.Grids.AbstractUnderlyingGrid"><code>Oceananigans.Grids.AbstractUnderlyingGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractUnderlyingGrid{FT, TX, TY, TZ}</code></pre><p>Abstract supertype for &quot;primary&quot; grids (as opposed to grids with immersed boundaries) with elements of type <code>FT</code> and topology <code>{TX, TY, TZ}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Grids/Grids.jl#L87-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.Bounded" href="#Oceananigans.Grids.Bounded"><code>Oceananigans.Grids.Bounded</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Bounded</code></pre><p>Grid topology for bounded dimensions, e.g., wall-bounded dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Grids/Grids.jl#L58-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.Center" href="#Oceananigans.Grids.Center"><code>Oceananigans.Grids.Center</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Center</code></pre><p>A type describing the location at the center of a grid cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Grids/Grids.jl#L30-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.Connected" href="#Oceananigans.Grids.Connected"><code>Oceananigans.Grids.Connected</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Connected</code></pre><p>Grid topology for dimensions that are connected to other models or domains on both sides.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Grids/Grids.jl#L73-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.Face" href="#Oceananigans.Grids.Face"><code>Oceananigans.Grids.Face</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Face</code></pre><p>A type describing the location at the face of a grid cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Grids/Grids.jl#L37-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.Flat" href="#Oceananigans.Grids.Flat"><code>Oceananigans.Grids.Flat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Flat</code></pre><p>Grid topology for flat dimensions, generally with one grid point, along which the solution is uniform and does not vary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Grids/Grids.jl#L65-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.LatitudeLongitudeGrid" href="#Oceananigans.Grids.LatitudeLongitudeGrid"><code>Oceananigans.Grids.LatitudeLongitudeGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LatitudeLongitudeGrid([architecture = CPU(), FT = Float64];
                      size,
                      latitude,
                      longitude,
                      z,
                      radius = R_Earth,
                      precompute_metrics = false,
                      halo = (1, 1, 1))</code></pre><p>Creates a <code>LatitudeLongitudeGrid</code> with <code>size = (Nx, Ny, Nz)</code> grid points.</p><p><strong>Positional arguments</strong></p><ul><li><p><code>architecture</code>: Specifies whether arrays of coordinates and spacings are stored                 on the CPU or GPU. Default: <code>architecture = CPU()</code>.</p></li><li><p><code>FT</code> : Floating point data type. Default: <code>FT = Float64</code>.</p></li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>size</code> (required): A 3-tuple prescribing the number of grid points each direction.</p></li><li><p><code>latitude</code>, <code>longitude</code>, <code>z</code>: Each is either a                               (i) 2-tuple that specify the end points of the domain,                               (ii) one-dimensional array specifying the cell interface locations or                               (iii) a single-argument function that takes an index and returns                                     cell interface location.</p></li><li><p><code>precompute_metrics</code>: Boolean specifying whether to precompute horizontal spacings and areas.                       If <code>!precompute_metrics</code> (the default), horizontal spacings and areas                       are computed on-the-fly during a simulation.</p></li><li><p><code>topology</code>: Tuple of topologies (<code>Flat</code>, <code>Bounded</code>, Periodic<code>) for each direction. The vertical</code>topology[3]<code>must be</code>Bounded<code>, while the latitude-longitude topology can be</code>Bounded<code>,</code>Periodic<code>, or</code>Flat<code>. The default latitudinal</code>topology[2]<code>is</code>Bounded<code>.             The default longitudinal</code>topology[1]<code>is</code>Periodic<code>if</code>diff(longitude) == 360<code>and</code>Bounded` otherwise.</p></li><li><p><code>halo</code>: A 3-tuple of integers specifying the size of the halo region of cells surrounding         the physical interior.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Grids/latitude_longitude_grid.jl#L84-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.Periodic" href="#Oceananigans.Grids.Periodic"><code>Oceananigans.Grids.Periodic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Periodic</code></pre><p>Grid topology for periodic dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Grids/Grids.jl#L51-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.RectilinearGrid" href="#Oceananigans.Grids.RectilinearGrid"><code>Oceananigans.Grids.RectilinearGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RectilinearGrid([architecture = CPU(), FT = Float64];
                size,
                x = nothing,
                y = nothing,
                z = nothing,
                halo = nothing,
                extent = nothing,
                topology = (Periodic, Periodic, Bounded))</code></pre><p>Creates a <code>RectilinearGrid</code> with <code>size = (Nx, Ny, Nz)</code> grid points.</p><p><strong>Positional arguments</strong></p><ul><li><p><code>architecture</code>: Specifies whether arrays of coordinates and spacings are stored                 on the CPU or GPU. Default: <code>architecture = CPU()</code>.</p></li><li><p><code>FT</code> : Floating point data type. Default: <code>FT = Float64</code>.</p></li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>size</code> (required): A tuple prescribing the number of grid points in non-<code>Flat</code> directions.                    <code>size</code> is a 3-tuple for 3D models, a 2-tuple for 2D models, and either a                    scalar or 1-tuple for 1D models.</p></li><li><p><code>topology</code>: A 3-tuple <code>(TX, TY, TZ)</code> specifying the topology of the domain.             <code>TX</code>, <code>TY</code>, and <code>TZ</code> specify whether the <code>x</code>-, <code>y</code>-, and <code>z</code> directions are             <code>Periodic</code>, <code>Bounded</code>, or <code>Flat</code>. The topology <code>Flat</code> indicates that a model does             not vary in those directions so that derivatives and interpolation are zero.             The default is <code>topology = (Periodic, Periodic, Bounded)</code>.</p></li><li><p><code>extent</code>: A tuple prescribing the physical extent of the grid in non-<code>Flat</code> directions.           All directions are contructed with regular grid spacing and the domain (in the           case that no direction is <code>Flat</code>) is x ∈ (0, Lx), y ∈ (0, Ly), and z ∈ (-Lz, 0),            which is most appropriate for oceanic applications with z = 0 usually being the           ocean&#39;s surface.</p></li><li><p><code>x</code>, <code>y</code>, and <code>z</code>: Each of <code>x, y, z</code> are either (i) 2-tuples that specify the end points of the domain                    in their respect directions (in which case scalar values may be used in <code>Flat</code>                    directions), or (ii) arrays or functions of the corresponding indices <code>i</code>, <code>j</code>, or <code>k</code>                    that specify the locations of cell faces in the <code>x</code>-, <code>y</code>-, or <code>z</code>-direction, respectively.                    For example, to prescribe the cell faces in <code>z</code> we need to provide a function that takes                    <code>k</code> as argument and retuns the location of the faces for indices <code>k = 1</code> through <code>k = Nz + 1</code>,                    where <code>Nz</code> is the <code>size</code> of the stretched <code>z</code> dimension.</p></li></ul><p><em>Note</em>: <em>Either</em> <code>extent</code>, or all of <code>x</code>, <code>y</code>, and <code>z</code> must be specified.</p><ul><li><code>halo</code>: A tuple of integers that specifies the size of the halo region of cells surrounding         the physical interior for each non-<code>Flat</code> direction.</li></ul><p>The physical extent of the domain can be specified via <code>x</code>, <code>y</code>, and <code>z</code> keyword arguments indicating the left and right endpoints of each dimensions, e.g. <code>x = (-π, π)</code> or via the <code>extent</code> argument, e.g. <code>extent = (Lx, Ly, Lz)</code>, which specifies the extent of each dimension in which case 0 ≤ x ≤ Lx, 0 ≤ y ≤ Ly, and -Lz ≤ z ≤ 0.</p><p>A grid topology may be specified via a tuple assigning one of <code>Periodic</code>, <code>Bounded</code>, and <code>Flat</code> to each dimension. By default, a horizontally periodic grid topology <code>(Periodic, Periodic, Bounded)</code> is assumed.</p><p>Constants are stored using floating point values of type <code>FT</code>. By default this is <code>Float64</code>. Make sure to specify the desired <code>FT</code> if not using <code>Float64</code>.</p><p><strong>Grid properties</strong></p><ul><li><p><code>(Nx, Ny, Nz) :: Int</code>: Number of physical points in the <span>$(x, y, z)$</span>-direction.</p></li><li><p><code>(Hx, Hy, Hz) :: Int</code>: Number of halo points in the <span>$(x, y, z)$</span>-direction.</p></li><li><p><code>(Lx, Ly, Lz) :: FT</code>: Physical extent of the grid in the <span>$(x, y, z)$</span>-direction.</p></li><li><p><code>(Δxᶜᵃᵃ, Δyᵃᶜᵃ, Δzᵃᵃᶜ)</code>: Grid spacing in the <span>$(x, y, z)$</span>-direction between cell centers.                          Defined at cell centers in <span>$x$</span>, <span>$y$</span>, and <span>$z$</span>.</p></li><li><p><code>(Δxᶠᵃᵃ, Δyᵃᶠᵃ, Δzᵃᵃᶠ)</code>: Grid spacing in the <span>$(x, y, z)$</span>-direction between cell faces.                          Defined at cell faces in <span>$x$</span>, <span>$y$</span>, and <span>$z$</span>.</p></li><li><p><code>(xᶜᵃᵃ, yᵃᶜᵃ, zᵃᵃᶜ)</code>: <span>$(x, y, z)$</span> coordinates of cell centers.</p></li><li><p><code>(xᶠᵃᵃ, yᵃᶠᵃ, zᵃᵃᶠ)</code>: <span>$(x, y, z)$</span> coordinates of cell faces.</p></li></ul><p><strong>Examples</strong></p><ul><li>A default grid with <code>Float64</code> type:</li></ul><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = RectilinearGrid(size=(32, 32, 32), extent=(1, 2, 3))
32×32×32 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo
├── Periodic x ∈ [0.0, 1.0)  regularly spaced with Δx=0.03125
├── Periodic y ∈ [0.0, 2.0)  regularly spaced with Δy=0.0625
└── Bounded  z ∈ [-3.0, 0.0] regularly spaced with Δz=0.09375</code></pre><ul><li>A default grid with <code>Float32</code> type:</li></ul><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = RectilinearGrid(Float32; size=(32, 32, 16), x=(0, 8), y=(-10, 10), z=(-π, π))
32×32×16 RectilinearGrid{Float32, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo
├── Periodic x ∈ [0.0, 8.0)          regularly spaced with Δx=0.25
├── Periodic y ∈ [-10.0, 10.0)       regularly spaced with Δy=0.625
└── Bounded  z ∈ [-3.14159, 3.14159] regularly spaced with Δz=0.392699</code></pre><ul><li>A two-dimenisional, horizontally-periodic grid:</li></ul><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = RectilinearGrid(size=(32, 32), extent=(2π, 4π), topology=(Periodic, Periodic, Flat))
32×32×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 1×1×0 halo
├── Periodic x ∈ [0.0, 6.28319) regularly spaced with Δx=0.19635
├── Periodic y ∈ [0.0, 12.5664) regularly spaced with Δy=0.392699
└── Flat z</code></pre><ul><li>A one-dimensional &quot;column&quot; grid:</li></ul><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = RectilinearGrid(size=256, z=(-128, 0), topology=(Flat, Flat, Bounded))
1×1×256 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×1 halo
├── Flat x
├── Flat y
└── Bounded  z ∈ [-128.0, 0.0] regularly spaced with Δz=0.5</code></pre><ul><li>A horizontally-periodic regular grid with cell interfaces stretched hyperbolically near the top:</li></ul><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; σ = 1.1; # stretching factor

julia&gt; Nz = 24; # vertical resolution

julia&gt; Lz = 32; # depth (m)

julia&gt; hyperbolically_spaced_faces(k) = - Lz * (1 - tanh(σ * (k - 1) / Nz) / tanh(σ));

julia&gt; grid = RectilinearGrid(size = (32, 32, Nz), x = (0, 64),
                              y = (0, 64), z = hyperbolically_spaced_faces)
32×32×24 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo
├── Periodic x ∈ [0.0, 64.0)   regularly spaced with Δx=2.0
├── Periodic y ∈ [0.0, 64.0)   regularly spaced with Δy=2.0
└── Bounded  z ∈ [-32.0, -0.0] variably spaced with min(Δz)=0.682695, max(Δz)=1.83091</code></pre><ul><li>A three-dimensional grid with regular spacing in x, cell interfaces at Chebyshev nodes in y, and cell interfaces stretched in z hyperbolically near the top:</li></ul><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; Nx, Ny, Nz = 32, 30, 24;

julia&gt; Lx, Ly, Lz = 200, 100, 32; # (m)

julia&gt; chebychev_nodes(j) = - Ly/2 * cos(π * (j - 1) / Ny);

julia&gt; σ = 1.1; # stretching factor

julia&gt; hyperbolically_spaced_faces(k) = - Lz * (1 - tanh(σ * (k - 1) / Nz) / tanh(σ));

julia&gt; grid = RectilinearGrid(size = (Nx, Ny, Nz),
                              topology=(Periodic, Bounded, Bounded),
                              x = (0, Lx),
                              y = chebychev_nodes,
                              z = hyperbolically_spaced_faces)
32×30×24 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 1×1×1 halo
├── Periodic x ∈ [0.0, 200.0)  regularly spaced with Δx=6.25
├── Bounded  y ∈ [-50.0, 50.0] variably spaced with min(Δy)=0.273905, max(Δy)=5.22642
└── Bounded  z ∈ [-32.0, -0.0] variably spaced with min(Δz)=0.682695, max(Δz)=1.83091</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Grids/rectilinear_grid.jl#L66-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.halo_size-Tuple{Any}" href="#Oceananigans.Grids.halo_size-Tuple{Any}"><code>Oceananigans.Grids.halo_size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">halo_size(grid)</code></pre><p>Return a tuple with the size of the halo in each dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Grids/grid_utils.jl#L98-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.new_data" href="#Oceananigans.Grids.new_data"><code>Oceananigans.Grids.new_data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">new_data(FT, grid, loc, indices)</code></pre><p>Returns an <code>OffsetArray</code> of zeros of float type <code>FT</code> on <code>arch</code>itecture, with indices corresponding to a field on a <code>grid</code> of <code>size(grid)</code> and located at <code>loc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Grids/new_data.jl#L50-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.nodes-Tuple{Any, Oceananigans.Grids.AbstractGrid}" href="#Oceananigans.Grids.nodes-Tuple{Any, Oceananigans.Grids.AbstractGrid}"><code>Oceananigans.Grids.nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nodes(loc, grid; reshape=false)</code></pre><p>Return a 3-tuple of views over the interior nodes at the locations in <code>loc</code> in <code>x, y, z</code>.</p><p>If <code>reshape=true</code>, the views are reshaped to 3D arrays with non-singleton dimensions 1, 2, 3 for <code>x, y, z</code>, respectively. These reshaped arrays can then be used in broadcast operations with 3D fields or arrays.</p><p>See <a href="#Oceananigans.Grids.xnodes-Tuple{Any, Any}"><code>xnodes</code></a>, <a href="#Oceananigans.Grids.ynodes-Tuple{Any, Any}"><code>ynodes</code></a>, and <a href="#Oceananigans.Grids.znodes-Tuple{Any, Any}"><code>znodes</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Grids/grid_utils.jl#L331-L343">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.offset_data" href="#Oceananigans.Grids.offset_data"><code>Oceananigans.Grids.offset_data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">offset_data(underlying_data, grid::AbstractGrid, loc)</code></pre><p>Returns an <code>OffsetArray</code> that maps to <code>underlying_data</code> in memory, with offset indices appropriate for the <code>data</code> of a field on a <code>grid</code> of <code>size(grid)</code> and located at <code>loc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Grids/new_data.jl#L40-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.topology-Tuple{Any, Any}" href="#Oceananigans.Grids.topology-Tuple{Any, Any}"><code>Oceananigans.Grids.topology</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">topology(grid, dim)</code></pre><p>Return the topology of the <code>grid</code> for the <code>dim</code>-th dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Grids/grid_utils.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.topology-Union{Tuple{Oceananigans.Grids.AbstractGrid{FT, TX, TY, TZ, Arch} where Arch}, Tuple{TZ}, Tuple{TY}, Tuple{TX}, Tuple{FT}} where {FT, TX, TY, TZ}" href="#Oceananigans.Grids.topology-Union{Tuple{Oceananigans.Grids.AbstractGrid{FT, TX, TY, TZ, Arch} where Arch}, Tuple{TZ}, Tuple{TY}, Tuple{TX}, Tuple{FT}} where {FT, TX, TY, TZ}"><code>Oceananigans.Grids.topology</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">topology(grid)</code></pre><p>Return a tuple with the topology of the <code>grid</code> for each dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Grids/grid_utils.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.total_size-Tuple{Any, Any}" href="#Oceananigans.Grids.total_size-Tuple{Any, Any}"><code>Oceananigans.Grids.total_size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">total_size(loc, grid)</code></pre><p>Return the &quot;total&quot; size of a <code>grid</code> at <code>loc</code>. This is a 3-tuple of integers corresponding to the number of grid points along <code>x, y, z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Grids/grid_utils.jl#L75-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.xnodes-Tuple{Any, Any}" href="#Oceananigans.Grids.xnodes-Tuple{Any, Any}"><code>Oceananigans.Grids.xnodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">xnodes(loc, grid, reshape=false)</code></pre><p>Return a view over the interior <code>loc=Center</code> or <code>loc=Face</code> nodes on <code>grid</code> in the x-direction. For <code>Bounded</code> directions, <code>Face</code> nodes include the boundary points. <code>reshape=false</code> will return a 1D array while <code>reshape=true</code> will return a 3D array with size Nx×1×1.</p><p>See <code>znodes</code> for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Grids/grid_utils.jl#L249-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.ynodes-Tuple{Any, Any}" href="#Oceananigans.Grids.ynodes-Tuple{Any, Any}"><code>Oceananigans.Grids.ynodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ynodes(loc, grid, reshape=false)</code></pre><p>Return a view over the interior <code>loc=Center</code> or <code>loc=Face</code> nodes on <code>grid</code> in the y-direction. For <code>Bounded</code> directions, <code>Face</code> nodes include the boundary points. <code>reshape=false</code> will return a 1D array while <code>reshape=true</code> will return a 3D array with size 1×Ny×1.</p><p>See <a href="#Oceananigans.Grids.znodes-Tuple{Any, Any}"><code>znodes</code></a> for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Grids/grid_utils.jl#L268-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.znodes-Tuple{Any, Any}" href="#Oceananigans.Grids.znodes-Tuple{Any, Any}"><code>Oceananigans.Grids.znodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">znodes(loc, grid, reshape=false)</code></pre><p>Return a view over the interior <code>loc=Center</code> or <code>loc=Face</code> nodes on <code>grid</code> in the z-direction. For <code>Bounded</code> directions, <code>Face</code> nodes include the boundary points. <code>reshape=false</code> will return a 1D array while <code>reshape=true</code> will return a 3D array with size 1×1×Nz.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; horz_periodic_grid = RectilinearGrid(size=(3, 3, 3), extent=(2π, 2π, 1),
                                                 topology=(Periodic, Periodic, Bounded));

julia&gt; zC = znodes(Center, horz_periodic_grid)
3-element view(OffsetArray(::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, 0:4), 1:3) with eltype Float64:
 -0.8333333333333331
 -0.4999999999999999
 -0.16666666666666652</code></pre><pre><code class="language-julia-repl hljs">julia&gt; zF = znodes(Face, horz_periodic_grid)
4-element view(OffsetArray(::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, 0:5), 1:4) with eltype Float64:
 -1.0
 -0.6666666666666666
 -0.33333333333333337
 -4.44089209850063e-17</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Grids/grid_utils.jl#L288-L322">source</a></section></article><h2 id="Immersed-boundaries"><a class="docs-heading-anchor" href="#Immersed-boundaries">Immersed boundaries</a><a id="Immersed-boundaries-1"></a><a class="docs-heading-anchor-permalink" href="#Immersed-boundaries" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.ImmersedBoundaries.AbstractImmersedBoundary" href="#Oceananigans.ImmersedBoundaries.AbstractImmersedBoundary"><code>Oceananigans.ImmersedBoundaries.AbstractImmersedBoundary</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractImmersedBoundary</code></pre><p>Abstract supertype for immersed boundary grids.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/ImmersedBoundaries/ImmersedBoundaries.jl#L85-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.ImmersedBoundaries.GridFittedBottom" href="#Oceananigans.ImmersedBoundaries.GridFittedBottom"><code>Oceananigans.ImmersedBoundaries.GridFittedBottom</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GridFittedBottom(bottom)</code></pre><p>Return an immersed boundary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/ImmersedBoundaries/grid_fitted_immersed_boundaries.jl#L27-L31">source</a></section></article><h2 id="Lagrangian-particle-tracking"><a class="docs-heading-anchor" href="#Lagrangian-particle-tracking">Lagrangian particle tracking</a><a id="Lagrangian-particle-tracking-1"></a><a class="docs-heading-anchor-permalink" href="#Lagrangian-particle-tracking" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.LagrangianParticleTracking.LagrangianParticles-Tuple{StructArrays.StructArray}" href="#Oceananigans.LagrangianParticleTracking.LagrangianParticles-Tuple{StructArrays.StructArray}"><code>Oceananigans.LagrangianParticleTracking.LagrangianParticles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LagrangianParticles(particles::StructArray; restitution=1.0, tracked_fields::NamedTuple=NamedTuple(), dynamics=no_dynamics)</code></pre><p>Construct some <code>LagrangianParticles</code> that can be passed to a model. The <code>particles</code> should be a <code>StructArray</code> and can contain custom fields. The coefficient of restitution for particle-wall collisions is specified by <code>restitution</code>.</p><p>A number of <code>tracked_fields</code> may be passed in as a <code>NamedTuple</code> of fields. Each particle will track the value of each field. Each tracked field must have a corresponding particle property. So if <code>T</code> is a tracked field, then <code>T</code> must also be a custom particle property.</p><p><code>dynamics</code> is a function of <code>(lagrangian_particles, model, Δt)</code> that is called prior to advecting particles. <code>parameters</code> can be accessed inside the <code>dynamics</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/LagrangianParticleTracking/LagrangianParticleTracking.jl#L54-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.LagrangianParticleTracking.LagrangianParticles-Tuple{}" href="#Oceananigans.LagrangianParticleTracking.LagrangianParticles-Tuple{}"><code>Oceananigans.LagrangianParticleTracking.LagrangianParticles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LagrangianParticles(; x, y, z, restitution=1.0, dynamics=no_dynamics, parameters=nothing)</code></pre><p>Construct some <code>LagrangianParticles</code> that can be passed to a model. The particles will have initial locations <code>x</code>, <code>y</code>, and <code>z</code>. The coefficient of restitution for particle-wall collisions is specified by <code>restitution</code>.</p><p><code>dynamics</code> is a function of <code>(lagrangian_particles, model, Δt)</code> that is called prior to advecting particles. <code>parameters</code> can be accessed inside the <code>dynamics</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/LagrangianParticleTracking/LagrangianParticleTracking.jl#L33-L41">source</a></section></article><h2 id="Logger"><a class="docs-heading-anchor" href="#Logger">Logger</a><a id="Logger-1"></a><a class="docs-heading-anchor-permalink" href="#Logger" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Logger.OceananigansLogger" href="#Oceananigans.Logger.OceananigansLogger"><code>Oceananigans.Logger.OceananigansLogger</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OceananigansLogger(stream::IO=stdout, level=Logging.Info; show_info_source=false)</code></pre><p>Based on Logging.SimpleLogger, it tries to log all messages in the following format:</p><pre><code class="nohighlight hljs">[yyyy/mm/dd HH:MM:SS.sss] log_level message [-@-&gt; source_file:line_number]</code></pre><p>where the source of the message between the square brackets is included only if <code>show_info_source=true</code> or if the message is not an info level message.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Logger.jl#L26-L35">source</a></section></article><h2 id="Models"><a class="docs-heading-anchor" href="#Models">Models</a><a id="Models-1"></a><a class="docs-heading-anchor-permalink" href="#Models" title="Permalink"></a></h2><h3 id="Non-hydrostatic-models"><a class="docs-heading-anchor" href="#Non-hydrostatic-models">Non-hydrostatic models</a><a id="Non-hydrostatic-models-1"></a><a class="docs-heading-anchor-permalink" href="#Non-hydrostatic-models" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Models.NonhydrostaticModels.NonhydrostaticModel-Tuple{}" href="#Oceananigans.Models.NonhydrostaticModels.NonhydrostaticModel-Tuple{}"><code>Oceananigans.Models.NonhydrostaticModels.NonhydrostaticModel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NonhydrostaticModel(;     grid,
                          clock = Clock{eltype(grid)}(0, 0, 1),
                      advection = CenteredSecondOrder(),
                       buoyancy = nothing,
                       coriolis = nothing,
                   stokes_drift = nothing,
            forcing::NamedTuple = NamedTuple(),
                        closure = nothing,
boundary_conditions::NamedTuple = NamedTuple(),
                        tracers = (),
                    timestepper = :QuasiAdamsBashforth2,
  background_fields::NamedTuple = NamedTuple(),
  particles::ParticlesOrNothing = nothing,
                     velocities = nothing,
                      pressures = nothing,
             diffusivity_fields = nothing,
                pressure_solver = nothing,
              immersed_boundary = nothing,
               auxiliary_fields = NamedTuple(),
)</code></pre><p>Construct a model for a non-hydrostatic, incompressible fluid, using the Boussinesq approximation when <code>buoyancy != nothing</code>. By default, all Bounded directions are rigid and impenetrable.</p><p><strong>Keyword arguments</strong></p><ul><li><code>grid</code>: (required) The resolution and discrete geometry on which <code>model</code> is solved. The         architecture (CPU/GPU) that the model is solve is inferred from the architecture         of the grid.</li><li><code>advection</code>: The scheme that advects velocities and tracers. See <code>Oceananigans.Advection</code>.</li><li><code>buoyancy</code>: The buoyancy model. See <code>Oceananigans.BuoyancyModels</code>.</li><li><code>coriolis</code>: Parameters for the background rotation rate of the model.</li><li><code>stokes_drift</code>: Parameters for Stokes drift fields associated with surface waves. Default: <code>nothing</code>.</li><li><code>forcing</code>: <code>NamedTuple</code> of user-defined forcing functions that contribute to solution tendencies.</li><li><code>closure</code>: The turbulence closure for <code>model</code>. See <code>Oceananigans.TurbulenceClosures</code>.</li><li><code>boundary_conditions</code>: <code>NamedTuple</code> containing field boundary conditions.</li><li><code>tracers</code>: A tuple of symbols defining the names of the modeled tracers, or a <code>NamedTuple</code> of            preallocated <code>CenterField</code>s.</li><li><code>timestepper</code>: A symbol that specifies the time-stepping method. Either <code>:QuasiAdamsBashforth2</code> or                <code>:RungeKutta3</code>.</li><li><code>background_fields</code>: <code>NamedTuple</code> with background fields (e.g., background flow). Default: <code>nothing</code>.</li><li><code>particles</code>: Lagrangian particles to be advected with the flow. Default: <code>nothing</code>.</li><li><code>velocities</code>: The model velocities. Default: <code>nothing</code>.</li><li><code>pressures</code>: Hydrostatic and non-hydrostatic pressure fields. Default: <code>nothing</code>.</li><li><code>diffusivity_fields</code>: Diffusivity fields. Default: <code>nothing</code>.</li><li><code>pressure_solver</code>: Pressure solver to be used in the model. If <code>nothing</code> (default), the model constructor chooses the default based on the <code>grid</code> provide.</li><li><code>immersed_boundary</code>: The immersed boundary. Default: <code>nothing</code>.</li><li><code>auxiliary_fields</code>: <code>NamedTuple</code> of auxiliary fields. Default: <code>nothing</code>.               </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L50-L101">source</a></section></article><h3 id="Hydrostatic-free-surface-models"><a class="docs-heading-anchor" href="#Hydrostatic-free-surface-models">Hydrostatic free-surface models</a><a id="Hydrostatic-free-surface-models-1"></a><a class="docs-heading-anchor-permalink" href="#Hydrostatic-free-surface-models" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Models.HydrostaticFreeSurfaceModels.ExplicitFreeSurface" href="#Oceananigans.Models.HydrostaticFreeSurfaceModels.ExplicitFreeSurface"><code>Oceananigans.Models.HydrostaticFreeSurfaceModels.ExplicitFreeSurface</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ExplicitFreeSurface{E, T}</code></pre><p>The explicit free surface solver.</p><ul><li><p><code>η::Any</code></p><p>free surface elevation</p></li><li><p><code>gravitational_acceleration::Any</code></p><p>gravitational accelerations</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Models/HydrostaticFreeSurfaceModels/explicit_free_surface.jl#L8-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Models.HydrostaticFreeSurfaceModels.HydrostaticFreeSurfaceModel-Tuple{}" href="#Oceananigans.Models.HydrostaticFreeSurfaceModels.HydrostaticFreeSurfaceModel-Tuple{}"><code>Oceananigans.Models.HydrostaticFreeSurfaceModels.HydrostaticFreeSurfaceModel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HydrostaticFreeSurfaceModel(; grid,
                                         clock = Clock{eltype(grid)}(0, 0, 1),
                            momentum_advection = CenteredSecondOrder(),
                              tracer_advection = CenteredSecondOrder(),
                                      buoyancy = SeawaterBuoyancy(eltype(grid)),
                                      coriolis = nothing,
                                  free_surface = ExplicitFreeSurface(gravitational_acceleration=g_Earth),
                           forcing::NamedTuple = NamedTuple(),
                                       closure = nothing,
               boundary_conditions::NamedTuple = NamedTuple(),
                                       tracers = (:T, :S),
particles::Union{Nothing, LagrangianParticles} = nothing,
                                    velocities = nothing,
                                      pressure = nothing,
                            diffusivity_fields = nothing,
                              auxiliary_fields = NamedTuple(),
)</code></pre><p>Construct an hydrostatic model with a free surface on <code>grid</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>grid</code>: (required) The resolution and discrete geometry on which <code>model</code> is solved. The architecture (CPU/GPU) that the model is solve is inferred from the architecture of the grid.</li><li><code>momentum_advection</code>: The scheme that advects velocities. See <code>Oceananigans.Advection</code>.</li><li><code>tracer_advection</code>: The scheme that advects tracers. See <code>Oceananigans.Advection</code>.</li><li><code>buoyancy</code>: The buoyancy model. See <code>Oceananigans.BuoyancyModels</code>.</li><li><code>coriolis</code>: Parameters for the background rotation rate of the model.</li><li><code>forcing</code>: <code>NamedTuple</code> of user-defined forcing functions that contribute to solution tendencies.</li><li><code>free_surface</code>: The free surface model.</li><li><code>closure</code>: The turbulence closure for <code>model</code>. See <code>Oceananigans.TurbulenceClosures</code>.</li><li><code>boundary_conditions</code>: <code>NamedTuple</code> containing field boundary conditions.</li><li><code>tracers</code>: A tuple of symbols defining the names of the modeled tracers, or a <code>NamedTuple</code> of            preallocated <code>CenterField</code>s.</li><li><code>particles</code>: Lagrangian particles to be advected with the flow. Default: <code>nothing</code>.</li><li><code>velocities</code>: The model velocities. Default: <code>nothing</code>.</li><li><code>pressure</code>: Hydrostatic pressure field. Default: <code>nothing</code>.</li><li><code>diffusivity_fields</code>: Diffusivity fields. Default: <code>nothing</code>.</li><li><code>auxiliary_fields</code>: <code>NamedTuple</code> of auxiliary fields. Default: <code>nothing</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl#L51-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Models.HydrostaticFreeSurfaceModels.ImplicitFreeSurface-Tuple{}" href="#Oceananigans.Models.HydrostaticFreeSurfaceModels.ImplicitFreeSurface-Tuple{}"><code>Oceananigans.Models.HydrostaticFreeSurfaceModels.ImplicitFreeSurface</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ImplicitFreeSurface(; solver_method=:Default, gravitational_acceleration=g_Earth, solver_settings...)</code></pre><p>The implicit free-surface equation is</p><p class="math-container">\[\left [ 𝛁_h ⋅ (H 𝛁_h) - \frac{1}{g Δt^2} \right ] η^{n+1} = \frac{𝛁_h ⋅ 𝐐_⋆}{g Δt} - \frac{η^{n}}{g Δt^2} ,\]</p><p>where <span>$η^n$</span> is the free-surface elevation at the <span>$n$</span>-th time step, <span>$H$</span> is depth, <span>$g$</span> is the gravitational acceleration, <span>$Δt$</span> is the time step, <span>$𝐐_⋆$</span> is the barotropic volume flux associated with the predictor velocity field, and <span>$𝛁_h$</span> is the horizontal gradient operator.</p><p>This equation can be solved in general using the <a href="#Oceananigans.Solvers.PreconditionedConjugateGradientSolver-Tuple{Any}"><code>PreconditionedConjugateGradientSolver</code></a>.</p><p>In the case that <span>$H$</span> is constant, we divide through to obtain</p><p class="math-container">\[\left ( ∇^2_h - \frac{1}{g H Δt^2} \right ) η^{n+1}  = \frac{1}{g H Δt} \left ( 𝛁_h ⋅ 𝐐_⋆ - \frac{η^{n}}{Δt} \right ) .\]</p><p>Thus, for constant <span>$H$</span> and on grids with regular spacing in <span>$x$</span> and <span>$y$</span> directions, the free surface can be obtained using the <code>FFTImplicitFreeSurfaceSolver</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl#L21-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Models.HydrostaticFreeSurfaceModels.PrescribedVelocityFields-Tuple{}" href="#Oceananigans.Models.HydrostaticFreeSurfaceModels.PrescribedVelocityFields-Tuple{}"><code>Oceananigans.Models.HydrostaticFreeSurfaceModels.PrescribedVelocityFields</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PrescribedVelocityFields(; u=zerofunc, v=zerofunc, w=zerofunc, parameters=nothing)</code></pre><p>Builds <code>PrescribedVelocityFields</code> with prescribed functions <code>u</code>, <code>v</code>, and <code>w</code>.</p><p>If <code>isnothing(parameters)</code>, then <code>u, v, w</code> are called with the signature</p><pre><code class="nohighlight hljs">u(x, y, z, t) = # something interesting</code></pre><p>If <code>!isnothing(parameters)</code>, then <code>u, v, w</code> are called with the signature</p><pre><code class="nohighlight hljs">u(x, y, z, t, parameters) = # something parameterized and interesting</code></pre><p>In the constructor for <code>HydrostaticFreeSurfaceModel</code>, the functions <code>u, v, w</code> are wrapped in <code>FunctionField</code> and associated with the model&#39;s <code>grid</code> and <code>clock</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Models/HydrostaticFreeSurfaceModels/prescribed_hydrostatic_velocity_fields.jl#L24-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurface" href="#Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurface"><code>Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurface</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SplitExplicitFreeSurface{𝒩, 𝒮, ℱ, 𝒫 ,ℰ}</code></pre><p>The split-explicit free surface solver.</p><ul><li><p><code>η::Any</code></p><p>The instantaneous free surface (<code>ReducedField</code>)</p></li><li><p><code>state::Any</code></p><p>The entire state for the split-explicit (<code>SplitExplicitState</code>)</p></li><li><p><code>auxiliary::Any</code></p><p>Parameters for timestepping split-explicit (<code>NamedTuple</code>)</p></li><li><p><code>gravitational_acceleration::Any</code></p><p>Gravitational acceleration</p></li><li><p><code>settings::Any</code></p><p>Settings for the split-explicit scheme (<code>NamedTuple</code>)</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl#L11-L17">source</a></section></article><h3 id="Shallow-water-models"><a class="docs-heading-anchor" href="#Shallow-water-models">Shallow-water models</a><a id="Shallow-water-models-1"></a><a class="docs-heading-anchor-permalink" href="#Shallow-water-models" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Models.ShallowWaterModels.ShallowWaterModel-Tuple{}" href="#Oceananigans.Models.ShallowWaterModels.ShallowWaterModel-Tuple{}"><code>Oceananigans.Models.ShallowWaterModels.ShallowWaterModel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ShallowWaterModel(; grid,
                    gravitational_acceleration,
                          clock = Clock{eltype(grid)}(0, 0, 1),
                      advection = UpwindBiasedFifthOrder(),
                       coriolis = nothing,
            forcing::NamedTuple = NamedTuple(),
                        closure = nothing,
                     bathymetry = nothing,
                        tracers = (),
             diffusivity_fields = nothing,
boundary_conditions::NamedTuple = NamedTuple(),
            timestepper::Symbol = :RungeKutta3)</code></pre><p>Construct a shallow water model on <code>grid</code> with <code>gravitational_acceleration</code> constant.</p><p><strong>Keyword arguments</strong></p><ul><li><code>grid</code>: (required) The resolution and discrete geometry on which <code>model</code> is solved. The         architecture (CPU/GPU) that the model is solve is inferred from the architecture         of the grid.</li><li><code>gravitational_acceleration</code>: (required) The gravitational acceleration constant.</li><li><code>clock</code>: The <code>clock</code> for the model.</li><li><code>advection</code>: The scheme that advects velocities and tracers. See <code>Oceananigans.Advection</code>.</li><li><code>coriolis</code>: Parameters for the background rotation rate of the model.</li><li><code>forcing</code>: <code>NamedTuple</code> of user-defined forcing functions that contribute to solution tendencies.</li><li><code>closure</code>: The turbulence closure for <code>model</code>. See <code>Oceananigans.TurbulenceClosures</code>.</li><li><code>bathymetry</code>: The bottom bathymetry.</li><li><code>tracers</code>: A tuple of symbols defining the names of the modeled tracers, or a <code>NamedTuple</code> of            preallocated <code>CenterField</code>s.</li><li><code>diffusivity_fields</code>: Stores diffusivity fields when the closures require a diffusivity to be                       calculated at each timestep.</li><li><code>boundary_conditions</code>: <code>NamedTuple</code> containing field boundary conditions.</li><li><code>timestepper</code>: A symbol that specifies the time-stepping method. Either <code>:QuasiAdamsBashforth2</code>,                <code>:RungeKutta3</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Models/ShallowWaterModels/shallow_water_model.jl#L54-L90">source</a></section></article><h2 id="Output-readers"><a class="docs-heading-anchor" href="#Output-readers">Output readers</a><a id="Output-readers-1"></a><a class="docs-heading-anchor-permalink" href="#Output-readers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputReaders.FieldDataset-Tuple{Any}" href="#Oceananigans.OutputReaders.FieldDataset-Tuple{Any}"><code>Oceananigans.OutputReaders.FieldDataset</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FieldDataset(filepath; architecture=CPU(), grid=nothing, backend=InMemory(), metadata_paths=[&quot;metadata&quot;])</code></pre><p>Returns a <code>Dict</code> containing a <code>FieldTimeSeries</code> for each field in the JLD2 file located at <code>filepath</code>. Note that model output must have been saved with halos. The <code>InMemory</code> backend will store the data fully in memory as a 4D multi-dimensional array while the <code>OnDisk</code> backend will lazily load field time snapshots when the <code>FieldTimeSeries</code> is indexed linearly.</p><p><code>metadata_paths</code> is a list of JLD2 paths to look for metadata. By default it looks in <code>file[&quot;metadata&quot;]</code>.</p><p>A <code>grid</code> and <code>ArrayType</code> may be specified to override the grid and array type used in the JLD file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/OutputReaders/field_dataset.jl#L7-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputReaders.FieldTimeSeries-Tuple{Any, Any}" href="#Oceananigans.OutputReaders.FieldTimeSeries-Tuple{Any, Any}"><code>Oceananigans.OutputReaders.FieldTimeSeries</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FieldTimeSeries(path, name;
                backend = InMemory(),
                grid = nothing,
                iterations = nothing,
                times = nothing)</code></pre><p>Returns a <code>FieldTimeSeries</code> for the field <code>name</code> describing a field&#39;s time history from a JLD2 file located at <code>path</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>backend</code>: <code>InMemory()</code> to load data into a 4D array or <code>OnDisk()</code> to lazily load data from disk            when indexing into <code>FieldTimeSeries</code>.</p></li><li><p><code>grid</code>: A grid to associated with data, in the case that the native grid         was not serialized properly.</p></li><li><p><code>iterations</code>: Iterations to load. Defaults to all iterations found in the file.</p></li><li><p><code>times</code>: Save times to load, as determined through an approximate floating point          comparison to recorded save times. Defaults to times associated with <code>iterations</code>.          Takes precedence over <code>iterations</code> if <code>times</code> is specified.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/OutputReaders/field_time_series.jl#L56-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputReaders.FieldTimeSeries-Union{Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Any, Any}, Tuple{Any, Any, Any}} where {LX, LY, LZ}" href="#Oceananigans.OutputReaders.FieldTimeSeries-Union{Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Any, Any}, Tuple{Any, Any, Any}} where {LX, LY, LZ}"><code>Oceananigans.OutputReaders.FieldTimeSeries</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FieldTimeSeries{LX, LY, LZ}(grid, times, boundary_conditions=nothing)</code></pre><p>Return <code>FieldTimeSeries</code> at location <code>(LX, LY, LZ)</code>, on <code>grid</code>, at <code>times</code>, with <code>boundary_conditions</code>, and initialized with zeros of <code>eltype(grid)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/OutputReaders/field_time_series.jl#L36-L41">source</a></section></article><h2 id="Output-writers"><a class="docs-heading-anchor" href="#Output-writers">Output writers</a><a id="Output-writers-1"></a><a class="docs-heading-anchor-permalink" href="#Output-writers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.AveragedTimeInterval" href="#Oceananigans.OutputWriters.AveragedTimeInterval"><code>Oceananigans.OutputWriters.AveragedTimeInterval</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct AveragedTimeInterval &lt;: AbstractSchedule</code></pre><p>Container for parameters that configure and handle time-averaged output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/OutputWriters/windowed_time_average.jl#L9-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.AveragedTimeInterval-Tuple{Any}" href="#Oceananigans.OutputWriters.AveragedTimeInterval-Tuple{Any}"><code>Oceananigans.OutputWriters.AveragedTimeInterval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AveragedTimeInterval(interval; window=interval, stride=1)</code></pre><p>Returns a <code>schedule</code> that specifies periodic time-averaging of output. The time <code>window</code> specifies the extent of the time-average, which reoccurs every <code>interval</code>.</p><p><code>output</code> is computed and accumulated into the average every <code>stride</code> iterations during the averaging window. For example, <code>stride=1</code> computs output every iteration, whereas <code>stride=2</code> computes output every other iteration. Time-averages with longer <code>stride</code>s are faster to compute, but less accurate.</p><p>The time-average of <span>$a$</span> is a left Riemann sum corresponding to</p><p><span>$⟨a⟩ = 1/T \int_{tᵢ-T}^T a \mathrm{d} t ,$</span></p><p>where <span>$⟨a⟩$</span> is the time-average of <span>$a$</span>, <span>$T$</span> is the time-window for averaging, and the <span>$tᵢ$</span> are discrete times separated by the time <code>interval</code>. The <span>$tᵢ$</span> specify both the end of the averaging window and the time at which output is written.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Oceananigans.OutputWriters: AveragedTimeInterval
using Oceananigans.Utils: year, years

schedule = AveragedTimeInterval(4years, window=1year)

# output
AveragedTimeInterval(window=1 year, stride=1, interval=4 years)</code></pre><p>An <code>AveragedTimeInterval</code> schedule directs an output writer to time-average its outputs before writing them to disk:</p><pre><code class="language-julia hljs">using Oceananigans
using Oceananigans.OutputWriters: JLD2OutputWriter
using Oceananigans.Utils: minutes

model = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)))

simulation = Simulation(model, Δt=10minutes, stop_time=30years)

simulation.output_writers[:velocities] = JLD2OutputWriter(model, model.velocities,
                                                          prefix = &quot;averaged_velocity_data&quot;,
                                                          schedule = AveragedTimeInterval(4years, window=1year, stride=2))

# output
JLD2OutputWriter scheduled on TimeInterval(4 years):
├── filepath: ./averaged_velocity_data.jld2
├── 3 outputs: (u, v, w) averaged on AveragedTimeInterval(window=1 year, stride=2, interval=4 years)
├── array type: Array{Float32}
├── including: [:grid, :coriolis, :buoyancy, :closure]
└── max filesize: Inf YiB</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/OutputWriters/windowed_time_average.jl#L22-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.Checkpointer-Tuple{Any}" href="#Oceananigans.OutputWriters.Checkpointer-Tuple{Any}"><code>Oceananigans.OutputWriters.Checkpointer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Checkpointer(model; schedule,
                    dir = &quot;.&quot;,
                 prefix = &quot;checkpoint&quot;,
                  force = false,
                verbose = false,
                cleanup = false,
             properties = [:architecture, :grid, :clock, :coriolis,
                           :buoyancy, :closure, :velocities, :tracers,
                           :timestepper, :particles]
            )</code></pre><p>Construct a <code>Checkpointer</code> that checkpoints the model to a JLD2 file on <code>schedule.</code> The <code>model.clock.iteration</code> is included in the filename to distinguish between multiple checkpoint files.</p><p>To restart or &quot;pickup&quot; a model from a checkpoint, specify <code>pickup=true</code> when calling <code>run!</code>, ensuring that the checkpoint file is the current working directory. See </p><pre><code class="language-julia hljs">help&gt; run!</code></pre><p>for more details.</p><p>Note that extra model <code>properties</code> can be safely specified, but removing crucial properties such as <code>:velocities</code> will make restoring from the checkpoint impossible.</p><p>The checkpointer attempts to serialize as much of the model to disk as possible, but functions or objects containing functions cannot be serialized at this time.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>schedule</code> (required): Schedule that determines when to checkpoint.</p></li><li><p><code>dir</code>: Directory to save output to. Default: &quot;.&quot; (current working directory).</p></li><li><p><code>prefix</code>: Descriptive filename prefixed to all output files. Default: &quot;checkpoint&quot;.</p></li><li><p><code>force</code>: Remove existing files if their filenames conflict. Default: <code>false</code>.</p></li><li><p><code>verbose</code>: Log what the output writer is doing with statistics on compute/write times            and file sizes. Default: <code>false</code>.</p></li><li><p><code>cleanup</code>: Previous checkpoint files will be deleted once a new checkpoint file is written.            Default: <code>false</code>.</p></li><li><p><code>properties</code>: List of model properties to checkpoint. Some are required.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/OutputWriters/checkpointer.jl#L18-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.JLD2OutputWriter" href="#Oceananigans.OutputWriters.JLD2OutputWriter"><code>Oceananigans.OutputWriters.JLD2OutputWriter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">JLD2OutputWriter{I, T, O, IF, IN, KW} &lt;: AbstractOutputWriter</code></pre><p>An output writer for writing to JLD2 files.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/OutputWriters/jld2_output_writer.jl#L12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.JLD2OutputWriter-Tuple{Any, Any}" href="#Oceananigans.OutputWriters.JLD2OutputWriter-Tuple{Any, Any}"><code>Oceananigans.OutputWriters.JLD2OutputWriter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">JLD2OutputWriter(model, outputs; prefix, schedule,
                          dir = &quot;.&quot;,
                      indices = (:, :, :),
                   with_halos = false,
                   array_type = Array{Float32},
                 max_filesize = Inf,
                        force = false,
                         init = noinit,
                    including = [:grid, :coriolis, :buoyancy, :closure],
                      verbose = false,
                         part = 1,
                      jld2_kw = Dict{Symbol, Any}())</code></pre><p>Construct a <code>JLD2OutputWriter</code> for an Oceananigans <code>model</code> that writes <code>label, output</code> pairs in <code>outputs</code> to a JLD2 file.</p><p>The argument <code>outputs</code> may be a <code>Dict</code> or <code>NamedTuple</code>. The keys of <code>outputs</code> are symbols or strings that &quot;name&quot; output data. The values of <code>outputs</code> are either <code>AbstractField</code>s, objects that are called with the signature <code>output(model)</code>, or <code>WindowedTimeAverage</code>s of <code>AbstractFields</code>s, functions, or callable objects.</p><p><strong>Keyword arguments</strong></p><p><strong>Filenaming</strong></p><ul><li><p><code>prefix</code> (required): Descriptive filename prefixed to all output files.</p></li><li><p><code>dir</code>: Directory to save output to.        Default: &quot;.&quot; (current working directory).</p></li></ul><p><strong>Output frequency and time-averaging</strong></p><ul><li><code>schedule</code> (required): <code>AbstractSchedule</code> that determines when output is saved.</li></ul><p><strong>Slicing and type conversion prior to output</strong></p><ul><li><p><code>indices</code>: Specifies the indices to write to disk with a <code>Tuple</code> of <code>Colon</code>, <code>UnitRange</code>,            or <code>Int</code> elements. Defaults <code>(:, :, :)</code> or &quot;all indices&quot;. If <code>!with_halos</code>,            halo regions are removed from <code>indices</code>. For example, <code>indices = (:, :, 1)</code>            will save xy-slices of the bottom-most index.</p></li><li><p><code>with_halos</code> (Bool): Whether or not to slice halo regions from fields before writing output.</p></li><li><p><code>array_type</code>: The array type to which output arrays are converted to prior to saving.               Default: <code>Array{Float32}</code>.</p></li></ul><p><strong>File management</strong></p><ul><li><p><code>max_filesize</code>: The writer will stop writing to the output file once the file size exceeds <code>max_filesize</code>,                 and write to a new one with a consistent naming scheme ending in <code>part1</code>, <code>part2</code>, etc.                 Defaults to <code>Inf</code>.</p></li><li><p><code>force</code>: Remove existing files if their filenames conflict.          Default: <code>false</code>.</p></li></ul><p><strong>Output file metadata management</strong></p><ul><li><p><code>init</code>: A function of the form <code>init(file, model)</code> that runs when a JLD2 output file is initialized.         Default: <code>noinit(args...) = nothing</code>.</p></li><li><p><code>including</code>: List of model properties to save with every file.              Default: <code>[:grid, :coriolis, :buoyancy, :closure]</code></p></li></ul><p><strong>Miscellaneous keywords</strong></p><ul><li><p><code>verbose</code>: Log what the output writer is doing with statistics on compute/write times and file sizes.            Default: <code>false</code>.</p></li><li><p><code>part</code>: The starting part number used if <code>max_filesize</code> is finite.         Default: 1.</p></li><li><p><code>jld2_kw</code>: Dict of kwargs to be passed to <code>jldopen</code> when data is written.</p></li></ul><p><strong>Example</strong></p><p>Write out 3D fields for u, v, w, and a tracer c, along with a horizontal average:</p><pre><code class="language-julia hljs">using Oceananigans
using Oceananigans.Utils: hour, minute

model = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)), tracers=(:c,))
simulation = Simulation(model, Δt=12, stop_time=1hour)

function init_save_some_metadata!(file, model)
    file[&quot;author&quot;] = &quot;Chim Riggles&quot;
    file[&quot;parameters/coriolis_parameter&quot;] = 1e-4
    file[&quot;parameters/density&quot;] = 1027
    return nothing
end

c_avg =  Field(Average(model.tracers.c, dims=(1, 2)))

# Note that model.velocities is NamedTuple
simulation.output_writers[:velocities] = JLD2OutputWriter(model, model.velocities,
                                                          prefix = &quot;some_data&quot;,
                                                          schedule = TimeInterval(20minute),
                                                          init = init_save_some_metadata!)

# output
JLD2OutputWriter scheduled on TimeInterval(20 minutes):
├── filepath: ./some_data.jld2
├── 3 outputs: (u, v, w)
├── array type: Array{Float32}
├── including: [:grid, :coriolis, :buoyancy, :closure]
└── max filesize: Inf YiB</code></pre><p>and a time- and horizontal-average of tracer <code>c</code> every 20 minutes of simulation time to a file called <code>some_averaged_data.jld2</code></p><pre><code class="language-julia hljs">simulation.output_writers[:avg_c] = JLD2OutputWriter(model, (; c=c_avg),
                                                     prefix = &quot;some_averaged_data&quot;,
                                                     schedule = AveragedTimeInterval(20minute, window=5minute))

# output
JLD2OutputWriter scheduled on TimeInterval(20 minutes):
├── filepath: ./some_averaged_data.jld2
├── 1 outputs: c averaged on AveragedTimeInterval(window=5 minutes, stride=1, interval=20 minutes)
├── array type: Array{Float32}
├── including: [:grid, :coriolis, :buoyancy, :closure]
└── max filesize: Inf YiB</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/OutputWriters/jld2_output_writer.jl#L33-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.NetCDFOutputWriter" href="#Oceananigans.OutputWriters.NetCDFOutputWriter"><code>Oceananigans.OutputWriters.NetCDFOutputWriter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NetCDFOutputWriter{D, O, I, T, A} &lt;: AbstractOutputWriter</code></pre><p>An output writer for writing to NetCDF files.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/OutputWriters/netcdf_output_writer.jl#L124-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.NetCDFOutputWriter-Tuple{Any, Any}" href="#Oceananigans.OutputWriters.NetCDFOutputWriter-Tuple{Any, Any}"><code>Oceananigans.OutputWriters.NetCDFOutputWriter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NetCDFOutputWriter(model, outputs; filepath, schedule
                               array_type = Array{Float32},
                                  indices = nothing,
                        global_attributes = Dict(),
                        output_attributes = Dict(),
                               dimensions = Dict(),
                                     mode = nothing,
                              compression = 0,
                                  verbose = false)</code></pre><p>Construct a <code>NetCDFOutputWriter</code> that writes <code>(label, output)</code> pairs in <code>outputs</code> (which should be a <code>Dict</code>) to a NetCDF file, where <code>label</code> is a string that labels the output and <code>output</code> is either a <code>Field</code> (e.g. <code>model.velocities.u</code>) or a function <code>f(model)</code> that returns something to be written to disk. Custom output requires the spatial <code>dimensions</code> (a <code>Dict</code>) to be manually specified (see examples).</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>filepath</code> (required): Filepath to save output to.</p></li><li><p><code>schedule</code> (required): <code>AbstractSchedule</code> that determines when output is saved.</p></li><li><p><code>array_type</code>: The array type to which output arrays are converted to prior to saving.               Default: Array{Float32}.</p></li><li><p><code>indices</code>: TODO</p></li><li><p><code>with_halos</code>: TODO</p></li><li><p><code>global_attributes</code>: Dict of model properties to save with every file (deafult: <code>Dict()</code>)</p></li><li><p><code>output_attributes</code>: Dict of attributes to be saved with each field variable (reasonable                      defaults are provided for velocities, buoyancy, temperature, and salinity;                      otherwise <code>output_attributes</code> <em>must</em> be user-provided).</p></li><li><p><code>dimensions</code>: A <code>Dict</code> of dimension tuples to apply to outputs (required for function outputs)</p></li><li><p><code>mode</code>: &quot;a&quot; (for append) and &quot;c&quot; (for clobber or create). Default: &quot;c&quot;. See NCDatasets.jl         documentation for more information on the <code>mode</code> option.</p></li><li><p><code>compression</code>: Determines the compression level of data (0-9, default 0)</p></li></ul><p><strong>Examples</strong></p><p>Saving the u velocity field and temperature fields, the full 3D fields and surface 2D slices to separate NetCDF files:</p><pre><code class="language-julia hljs">using Oceananigans

grid = RectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1))

model = NonhydrostaticModel(grid=grid, tracers=:c)

simulation = Simulation(model, Δt=12, stop_time=3600)

fields = Dict(&quot;u&quot; =&gt; model.velocities.u, &quot;c&quot; =&gt; model.tracers.c)

simulation.output_writers[:field_writer] =
    NetCDFOutputWriter(model, fields, filepath=&quot;fields.nc&quot;, schedule=TimeInterval(60))

# output
NetCDFOutputWriter scheduled on TimeInterval(1 minute):
├── filepath: fields.nc
├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0)
├── 2 outputs: (c, u)
└── array type: Array{Float32}</code></pre><pre><code class="language-julia hljs">simulation.output_writers[:surface_slice_writer] =
    NetCDFOutputWriter(model, fields, filepath=&quot;surface_xy_slice.nc&quot;,
                       schedule=TimeInterval(60), indices=(:, :, grid.Nz))

# output
NetCDFOutputWriter scheduled on TimeInterval(1 minute):
├── filepath: surface_xy_slice.nc
├── dimensions: zC(1), zF(1), xC(16), yF(16), xF(16), yC(16), time(0)
├── 2 outputs: (c, u)
└── array type: Array{Float32}</code></pre><pre><code class="language-julia hljs">simulation.output_writers[:averaged_profile_writer] =
    NetCDFOutputWriter(model, fields,
                       filepath = &quot;averaged_z_profile.nc&quot;,
                       schedule = AveragedTimeInterval(60, window=20),
                       indices = (1, 1, :))

# output
NetCDFOutputWriter scheduled on TimeInterval(1 minute):
├── filepath: averaged_z_profile.nc
├── dimensions: zC(16), zF(17), xC(1), yF(1), xF(1), yC(1), time(0)
├── 2 outputs: (c, u) averaged on AveragedTimeInterval(window=20 seconds, stride=1, interval=1 minute)
└── array type: Array{Float32}</code></pre><p><code>NetCDFOutputWriter</code> also accepts output functions that write scalars and arrays to disk, provided that their <code>dimensions</code> are provided:</p><pre><code class="language-julia hljs">using Oceananigans

grid = RectilinearGrid(size=(16, 16, 16), extent=(1, 2, 3))

model = NonhydrostaticModel(grid=grid)

simulation = Simulation(model, Δt=1.25, stop_iteration=3)

f(model) = model.clock.time^2; # scalar output

g(model) = model.clock.time .* exp.(znodes(Center, grid)) # vector/profile output

h(model) = model.clock.time .* (   sin.(xnodes(Center, grid, reshape=true)[:, :, 1])
                            .*     cos.(ynodes(Face, grid, reshape=true)[:, :, 1])) # xy slice output

outputs = Dict(&quot;scalar&quot; =&gt; f, &quot;profile&quot; =&gt; g, &quot;slice&quot; =&gt; h)

dims = Dict(&quot;scalar&quot; =&gt; (), &quot;profile&quot; =&gt; (&quot;zC&quot;,), &quot;slice&quot; =&gt; (&quot;xC&quot;, &quot;yC&quot;))

output_attributes = Dict(
    &quot;scalar&quot;  =&gt; Dict(&quot;longname&quot; =&gt; &quot;Some scalar&quot;, &quot;units&quot; =&gt; &quot;bananas&quot;),
    &quot;profile&quot; =&gt; Dict(&quot;longname&quot; =&gt; &quot;Some vertical profile&quot;, &quot;units&quot; =&gt; &quot;watermelons&quot;),
    &quot;slice&quot;   =&gt; Dict(&quot;longname&quot; =&gt; &quot;Some slice&quot;, &quot;units&quot; =&gt; &quot;mushrooms&quot;)
);

global_attributes = Dict(&quot;location&quot; =&gt; &quot;Bay of Fundy&quot;, &quot;onions&quot; =&gt; 7)

simulation.output_writers[:things] =
    NetCDFOutputWriter(model, outputs,
                       schedule=IterationInterval(1), filepath=&quot;things.nc&quot;, dimensions=dims, verbose=true,
                       global_attributes=global_attributes, output_attributes=output_attributes)

# output
NetCDFOutputWriter scheduled on IterationInterval(1):
├── filepath: things.nc
├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0)
├── 3 outputs: (profile, slice, scalar)
└── array type: Array{Float32}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/OutputWriters/netcdf_output_writer.jl#L140-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.WindowedTimeAverage" href="#Oceananigans.OutputWriters.WindowedTimeAverage"><code>Oceananigans.OutputWriters.WindowedTimeAverage</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WindowedTimeAverage{OP, R, FS} &lt;: AbstractDiagnostic</code></pre><p>An object for computing &#39;windowed&#39; time averages, or moving time-averages of a <code>operand</code> over a specified <code>window</code>, collected on <code>interval</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/OutputWriters/windowed_time_average.jl#L93-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.WindowedTimeAverage" href="#Oceananigans.OutputWriters.WindowedTimeAverage"><code>Oceananigans.OutputWriters.WindowedTimeAverage</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WindowedTimeAverage(operand, model=nothing; schedule)</code></pre><p>Returns an object for computing running averages of <code>operand</code> over <code>schedule.window</code> and recurring on <code>schedule.interval</code>, where <code>schedule</code> is an <code>AveragedTimeInterval</code>. During the collection period, averages are computed every <code>schedule.stride</code> iteration.</p><p><code>operand</code> may be a <code>Oceananigans.Field</code> or a function that returns an array or scalar.</p><p>Calling <code>wta(model)</code> for <code>wta::WindowedTimeAverage</code> object returns <code>wta.result</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/OutputWriters/windowed_time_average.jl#L108-L118">source</a></section></article><h2 id="Simulations"><a class="docs-heading-anchor" href="#Simulations">Simulations</a><a id="Simulations-1"></a><a class="docs-heading-anchor-permalink" href="#Simulations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Simulations.Callback" href="#Oceananigans.Simulations.Callback"><code>Oceananigans.Simulations.Callback</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Callback(func, schedule=IterationInterval(1); parameters=nothing)</code></pre><p>Return <code>Callback</code> that executes <code>func</code> on <code>schedule</code> with optional <code>parameters</code>. <code>schedule = IterationInterval(1)</code> by default.</p><p>If <code>isnothing(parameters)</code>, <code>func(sim::Simulation)</code> is called. Otherwise, <code>func</code> is called via <code>func(sim::Simulation, parameteres)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Simulations/callback.jl#L12-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Simulations.Simulation-Tuple{Any}" href="#Oceananigans.Simulations.Simulation-Tuple{Any}"><code>Oceananigans.Simulations.Simulation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Simulation(model; Δt,
           stop_iteration = Inf,
           stop_time = Inf,
           wall_time_limit = Inf)</code></pre><p>Construct a <code>Simulation</code> for a <code>model</code> with time step <code>Δt</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>Δt</code>: Required keyword argument specifying the simulation time step. Can be a <code>Number</code>       for constant time steps or a <code>TimeStepWizard</code> for adaptive time-stepping.</p></li><li><p><code>stop_iteration</code>: Stop the simulation after this many iterations.</p></li><li><p><code>stop_time</code>: Stop the simulation once this much model clock time has passed.</p></li><li><p><code>wall_time_limit</code>: Stop the simulation if it&#39;s been running for longer than this many                    seconds of wall clock time.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Simulations/simulation.jl#L23-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Simulations.TimeStepWizard" href="#Oceananigans.Simulations.TimeStepWizard"><code>Oceananigans.Simulations.TimeStepWizard</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TimeStepWizard(cfl=0.2, diffusive_cfl=Inf, max_change=1.1, min_change=0.5, max_Δt=Inf, min_Δt=0.0)</code></pre><p>Callback for adapting simulation time-steps <code>Δt</code> to maintain the advective Courant-Freidrichs-Lewy (<code>cfl</code>) number, the <code>diffusive_cfl</code>, while maintaining <code>max_Δt</code>, <code>min_Δt</code>, and satisfying <code>max_change</code> and <code>min_change</code> criteria so <code>Δt</code> is not adapted &quot;too quickly&quot;.</p><p>For more information on the <code>cfl</code> number, see its <a href="https://en.wikipedia.org/wiki/Courant%E2%80%93Friedrichs%E2%80%93Lewy_condition">wikipedia entry</a>.</p><p><strong>Example</strong></p><p>To use <code>TimeStepWizard</code>, adapt in a <a href="#Oceananigans.Simulations.Callback"><code>Callback</code></a> and add it to a <code>Simulation</code>:</p><pre><code class="language-julia hljs">julia&gt; simulation = Simulation(model, Δt=0.9, stop_iteration=100)

julia&gt; wizard = TimeStepWizard(cfl=0.2)

julia&gt; simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(4))</code></pre><p>Then when <code>run!(simulation)</code> is invoked, the time-step <code>simulation.Δt</code> will be updated every 4 iterations. Note that the name <code>:wizard</code> is unimportant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Simulations/time_step_wizard.jl#L22-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Simulations.erroring_NaNChecker!-Tuple{Any}" href="#Oceananigans.Simulations.erroring_NaNChecker!-Tuple{Any}"><code>Oceananigans.Simulations.erroring_NaNChecker!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">erroring_NaNChecker!(simulation)</code></pre><p>Toggles <code>simulation</code>&#39;s <code>NaNChecker</code> to throw an error when a <code>NaN</code> is detected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Simulations/nan_checker.jl#L52-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Simulations.iteration-Tuple{Simulation}" href="#Oceananigans.Simulations.iteration-Tuple{Simulation}"><code>Oceananigans.Simulations.iteration</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iteration(sim::Simulation)</code></pre><p>Return the current simulation iteration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Simulations/simulation.jl#L111-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Simulations.run!-Tuple{Any}" href="#Oceananigans.Simulations.run!-Tuple{Any}"><code>Oceananigans.Simulations.run!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">run!(simulation; pickup=false)</code></pre><p>Run a <code>simulation</code> until one of <code>simulation.stop_criteria</code> evaluates <code>true</code>. The simulation will then stop.</p><p><strong>Picking simulations up from a checkpoint</strong></p><p>Simulations are &quot;picked up&quot; from a checkpoint if <code>pickup</code> is either <code>true</code>, a <code>String</code>, or an <code>Integer</code> greater than 0.</p><p>Picking up a simulation sets field and tendency data to the specified checkpoint, leaving all other model properties unchanged.</p><p>Possible values for <code>pickup</code> are:</p><ul><li><p><code>pickup=true</code> picks a simulation up from the latest checkpoint associated with the <code>Checkpointer</code> in <code>simulation.output_writers</code>.</p></li><li><p><code>pickup=iteration::Int</code> picks a simulation up from the checkpointed file associated  with <code>iteration</code> and the <code>Checkpointer</code> in <code>simulation.output_writers</code>.</p></li><li><p><code>pickup=filepath::String</code> picks a simulation up from checkpointer data in <code>filepath</code>.</p></li></ul><p>Note that <code>pickup=true</code> and <code>pickup=iteration</code> fails if <code>simulation.output_writers</code> contains more than one checkpointer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Simulations/run.jl#L60-L86">source</a></section></article><h2 id="Solvers"><a class="docs-heading-anchor" href="#Solvers">Solvers</a><a id="Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Solvers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Solvers.BatchedTridiagonalSolver" href="#Oceananigans.Solvers.BatchedTridiagonalSolver"><code>Oceananigans.Solvers.BatchedTridiagonalSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BatchedTridiagonalSolver</code></pre><p>A batched solver for large numbers of triadiagonal systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Solvers/batched_tridiagonal_solver.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Solvers.BatchedTridiagonalSolver-Tuple{Any}" href="#Oceananigans.Solvers.BatchedTridiagonalSolver-Tuple{Any}"><code>Oceananigans.Solvers.BatchedTridiagonalSolver</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BatchedTridiagonalSolver(grid; lower_diagonal, diagonal, upper_diagonal, parameters=nothing)</code></pre><p>Construct a solver for batched tridiagonal systems on <code>grid</code> of the form</p><pre><code class="nohighlight hljs">                       bⁱʲ¹ ϕⁱʲ¹ + cⁱʲ¹ ϕⁱʲ²   = fⁱʲ¹,  k = 1
       aⁱʲᵏ⁻¹ ϕⁱʲᵏ⁻¹ + bⁱʲᵏ ϕⁱʲᵏ + cⁱʲᵏ ϕⁱʲᵏ⁺¹ = fⁱʲᵏ,  k = 2, ..., N-1
       aⁱʲᴺ⁻¹ ϕⁱʲᴺ⁻¹ + bⁱʲᴺ ϕⁱʲᴺ               = fⁱʲᴺ,  k = N</code></pre><p>where <code>a</code> is the <code>lower_diagonal</code>, <code>b</code> is the <code>diagonal</code>, and <code>c</code> is the <code>upper_diagonal</code>. <code>ϕ</code> is the solution and <code>f</code> is the right hand side source term passed to <code>solve!(ϕ, tridiagonal_solver, f)</code></p><p><code>a</code>, <code>b</code>, <code>c</code>, and <code>f</code> can be specified in three ways:</p><ol><li><p>A 1D array means that <code>aⁱʲᵏ = a[k]</code>.</p></li><li><p>A 3D array means that <code>aⁱʲᵏ = a[i, j, k]</code>.</p></li><li><p>Otherwise, <code>a</code> is assumed to be callable:</p><ul><li>If <code>isnothing(parameters)</code> then <code>aⁱʲᵏ = a(i, j, k, grid, args...)</code>.</li><li>If <code>!isnothing(parameters)</code> then <code>aⁱʲᵏ = a(i, j, k, grid, parameters, args...)</code>.</li></ul><p>where <code>args...</code> are <code>Varargs</code> passed to <code>solve_batched_tridiagonal_system!(ϕ, solver, args...)</code>.</p></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Solvers/batched_tridiagonal_solver.jl#L22-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Solvers.HeptadiagonalIterativeSolver-Tuple{Any}" href="#Oceananigans.Solvers.HeptadiagonalIterativeSolver-Tuple{Any}"><code>Oceananigans.Solvers.HeptadiagonalIterativeSolver</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HeptadiagonalIterativeSolver(coeffs;
                             grid,
                             iterative_solver = cg,
                             maximum_iterations = prod(size(grid)),
                             tolerance = 1e-13,
                             reduced_dim = (false, false, false), 
                             placeholder_timestep = -1.0, 
                             preconditioner_method = :Default, 
                             preconditioner_settings = nothing)</code></pre><p><code>HeptadiagonalIterativeSolver</code> is a framework to solve the problem <code>A * x = b</code> (provided that <code>A</code> is a symmetric matrix).</p><p>The solver relies on sparse version of the matrix <code>A</code> which are defined by the field matrix_constructors.</p><p>In particular, given coefficients <code>Ax</code>, <code>Ay</code>, <code>Az</code>, <code>C</code>, <code>D</code>, the solved problem will be</p><p>To have the equation solved on Center, Center, Center, the coefficients should be specified as follows:</p><ul><li><code>Ax</code> -&gt; Face, Center, Center</li><li><code>Ay</code> -&gt; Center, Face, Center</li><li><code>Az</code> -&gt; Center, Center, Face</li><li><code>C</code>  -&gt; Center, Center, Center</li><li><code>D</code>  -&gt; Center, Center, Center</li></ul><pre><code class="language-julia hljs">Axᵢ₊₁ ηᵢ₊₁ + Axᵢ ηᵢ₋₁ + Ayⱼ₊₁ ηⱼ₊₁ + Ayⱼ ηⱼ₋₁ + Azₖ₊₁ ηₖ₊₁ + Azₖ ηⱼ₋₁ 
- 2 ( Axᵢ₊₁ + Axᵢ + Ayⱼ₊₁ + Ayⱼ + Azₖ₊₁ + Azₖ ) ηᵢⱼₖ 
+   ( Cᵢⱼₖ + Dᵢⱼₖ/Δt^2 ) ηᵢⱼₖ = b</code></pre><p><code>solver.matrix</code> is precomputed with a value of <code>Δt = -1.0</code></p><p>The sparse matrix <code>A</code> can be constructed with</p><ul><li><code>SparseMatrixCSC(constructors...)</code> for CPU</li><li><code>CuSparseMatrixCSC(constructors...)</code> for GPU</li></ul><p>The constructors are calculated based on the pentadiagonal coeffients passed as an input (<code>matrix_from_coefficients</code>).</p><p>The diagonal term <code>- Az / (g * Δt²)</code> is added later on during the time stepping to allow for variable time step. It is updated only when the previous time step  is different (<code>Δt_previous != Δt</code>).</p><p>Preconditioning is done through the incomplete LU factorization. </p><p>It works for GPU, but it relies on serial backward and forward substitution which are very heavy and destroy all the computational advantage, therefore it is switched off until a parallel backward/forward substitution is implemented. It is also updated based on the matrix when <code>Δt != Δt_previous</code></p><p>The iterative_solver used can is to be chosen from the IterativeSolvers.jl package.  The default solver is a Conjugate Gradient (cg)</p><pre><code class="language-julia hljs">solver = HeptadiagonalIterativeSolver((Ax, Ay, Az, C, D), grid = grid)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Solvers/heptadiagonal_iterative_solver.jl#L24-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Solvers.PreconditionedConjugateGradientSolver-Tuple{Any}" href="#Oceananigans.Solvers.PreconditionedConjugateGradientSolver-Tuple{Any}"><code>Oceananigans.Solvers.PreconditionedConjugateGradientSolver</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PreconditionedConjugateGradientSolver(linear_operation;
                                      template_field,
                                      maximum_iterations = size(template_field.grid),
                                      tolerance = 1e-13,
                                      precondition = nothing)</code></pre><p>Returns a PreconditionedConjugateGradientSolver that solves the linear equation <span>$A x = b$</span> using a iterative conjugate gradient method with optional preconditioning. The solver is used by calling</p><pre><code class="nohighlight hljs">solve!(x, solver::PreconditionedConjugateGradientOperator, b, args...)</code></pre><p>for <code>solver</code>, right-hand side <code>b</code>, solution <code>x</code>, and optional arguments <code>args...</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>template_field</code>: Dummy field that is the same type and size as <code>x</code> and <code>b</code>, which                   is used to infer the <code>architecture</code>, <code>grid</code>, and to create work arrays                   that are used internally by the solver.</p></li><li><p><code>linear_operation</code>: Function with signature <code>linear_operation!(p, y, args...)</code> that calculates                    <code>A*y</code> and stores the result in <code>p</code> for a &quot;candidate solution <code>y</code>. <code>args...</code>                    are optional positional arguments passed from <code>solve!(x, solver, b, args...)</code>.</p></li><li><p><code>maximum_iterations</code>: Maximum number of iterations the solver may perform before exiting.</p></li><li><p><code>tolerance</code>: Tolerance for convergence of the algorithm. The algorithm quits when              <code>norm(A * x - b) &lt; tolerance</code>.</p></li><li><p><code>precondition</code>: Function with signature <code>preconditioner!(z, y, args...)</code> that calculates                 <code>P * y</code> and stores the result in <code>z</code> for linear operator <code>P</code>.                 Note that some precondition algorithms describe the step                 &quot;solve <code>M * x = b</code>&quot; for precondition <code>M</code>&quot;; in this context,                 <code>P = M⁻¹</code>.</p></li></ul><p>See <a href="#Oceananigans.Solvers.solve!"><code>solve!</code></a> for more information about the preconditioned conjugate-gradient algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Solvers/preconditioned_conjugate_gradient_solver.jl#L37-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Solvers.solve!" href="#Oceananigans.Solvers.solve!"><code>Oceananigans.Solvers.solve!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">solve!(ϕ, solver::FFTBasedPoissonSolver, b, m=0)</code></pre><p>Solves the &quot;generalized&quot; Poisson equation,</p><p class="math-container">\[(∇² + m) ϕ = b,\]</p><p>where <span>$m$</span> is a number, using a eigenfunction expansion of the discrete Poisson operator on a staggered grid and for periodic or Neumann boundary conditions.</p><p>In-place transforms are applied to <span>$b$</span>, which means <span>$b$</span> must have complex-valued elements (typically the same type as <code>solver.storage</code>).</p><p>Note: <span>$(∇² + m) ϕ = b$</span> is sometimes called the &quot;screened Poisson&quot; equation when <span>$m &lt; 0$</span>, or the Helmholtz equation when <span>$m &gt; 0$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Solvers/fft_based_poisson_solver.jl#L59-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Solvers.solve!-Tuple{Any, Oceananigans.Solvers.BatchedTridiagonalSolver, Any, Vararg{Any, N} where N}" href="#Oceananigans.Solvers.solve!-Tuple{Any, Oceananigans.Solvers.BatchedTridiagonalSolver, Any, Vararg{Any, N} where N}"><code>Oceananigans.Solvers.solve!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve!(ϕ, solver::BatchedTridiagonalSolver, rhs, args...; dependencies = device_event(solver.architecture))</code></pre><p>Solve the batched tridiagonal system of linear equations with right hand side <code>rhs</code> and lower diagonal, diagonal, and upper diagonal coefficients described by the <code>BatchedTridiagonalSolver</code> <code>solver</code>. <code>BatchedTridiagonalSolver</code> uses a modified TriDiagonal Matrix Algorithm (TDMA).</p><p>The result is stored in <code>ϕ</code> which must have size <code>(grid.Nx, grid.Ny, grid.Nz)</code>.</p><p>Reference implementation per Numerical Recipes, Press et. al 1992 (§ 2.4).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Solvers/batched_tridiagonal_solver.jl#L61-L73">source</a></section></article><h2 id="Stokes-drift"><a class="docs-heading-anchor" href="#Stokes-drift">Stokes drift</a><a id="Stokes-drift-1"></a><a class="docs-heading-anchor-permalink" href="#Stokes-drift" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.StokesDrift.UniformStokesDrift" href="#Oceananigans.StokesDrift.UniformStokesDrift"><code>Oceananigans.StokesDrift.UniformStokesDrift</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UniformStokesDrift{UZ, VZ, UT, VT} &lt;: AbstractStokesDrift</code></pre><p>Parameter struct for Stokes drift fields associated with surface waves.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/StokesDrift.jl#L41-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.StokesDrift.UniformStokesDrift-Tuple{}" href="#Oceananigans.StokesDrift.UniformStokesDrift-Tuple{}"><code>Oceananigans.StokesDrift.UniformStokesDrift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">UniformStokesDrift(; ∂z_uˢ=addzero, ∂z_vˢ=addzero, ∂t_uˢ=addzero, ∂t_vˢ=addzero)</code></pre><p>Construct a set of functions that describes the Stokes drift field beneath a uniform surface gravity wave field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/StokesDrift.jl#L55-L60">source</a></section></article><h2 id="Time-steppers"><a class="docs-heading-anchor" href="#Time-steppers">Time steppers</a><a id="Time-steppers-1"></a><a class="docs-heading-anchor-permalink" href="#Time-steppers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TimeSteppers.Clock" href="#Oceananigans.TimeSteppers.Clock"><code>Oceananigans.TimeSteppers.Clock</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Clock{T&lt;:Number}</code></pre><p>Keeps track of the current <code>time</code>, <code>iteration</code> number, and time-stepping <code>stage</code>. The <code>stage</code> is updated only for multi-stage time-stepping methods. The <code>time::T</code> is either a number or a <code>DateTime</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/TimeSteppers/clock.jl#L7-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TimeSteppers.Clock-Union{Tuple{}, Tuple{T}} where T" href="#Oceananigans.TimeSteppers.Clock-Union{Tuple{}, Tuple{T}} where T"><code>Oceananigans.TimeSteppers.Clock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Clock(; time, iteration=0, stage=1)</code></pre><p>Returns a <code>Clock</code> object. By default, <code>Clock</code> is initialized to the zeroth <code>iteration</code> and first time step <code>stage</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/TimeSteppers/clock.jl#L20-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper-Union{Tuple{IT}, Tuple{Any, Any}, Tuple{Any, Any, Any}} where IT" href="#Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper-Union{Tuple{IT}, Tuple{Any, Any}, Tuple{Any, Any, Any}} where IT"><code>Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">QuasiAdamsBashforth2TimeStepper(grid, tracers,
                                χ = 0.1;
                                implicit_solver = nothing,
                                Gⁿ = TendencyFields(grid, tracers),
                                G⁻ = TendencyFields(grid, tracers))</code></pre><p>Return a 2nd-order quasi Adams-Bashforth (AB2) time stepper (<code>QuasiAdamsBashforth2TimeStepper</code>) on <code>grid</code>, with <code>tracers</code>, and AB2 parameter <code>χ</code>. The tendency fields <code>Gⁿ</code> and <code>G⁻</code> can be specified via  optional <code>kwargs</code>.</p><p>The 2nd-order quasi Adams-Bashforth timestepper steps forward the state <code>Uⁿ</code> by <code>Δt</code> via</p><pre><code class="language-julia hljs">Uⁿ⁺¹ = Uⁿ + Δt * [(3/2 + χ) * Gⁿ - (1/2 + χ) * Gⁿ⁻¹]</code></pre><p>where <code>Uⁿ</code> is the state at the <span>$n$</span>-th timestep, <code>Gⁿ</code> is the tendency at the <span>$n$</span>-th timestep, and <code>Gⁿ⁻¹</code> is the tendency at the previous timestep (<code>G⁻</code>).</p><div class="admonition is-info"><header class="admonition-header">First timestep</header><div class="admonition-body"><p>For the first timestep, since there are no saved tendencies from the previous timestep, the <code>QuasiAdamsBashforth2TimeStepper</code> performs an Euler timestep:</p><pre><code class="language-julia hljs">Uⁿ⁺¹ = Uⁿ + Δt * Gⁿ</code></pre></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/TimeSteppers/quasi_adams_bashforth_2.jl#L13-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TimeSteppers.RungeKutta3TimeStepper" href="#Oceananigans.TimeSteppers.RungeKutta3TimeStepper"><code>Oceananigans.TimeSteppers.RungeKutta3TimeStepper</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RungeKutta3TimeStepper{FT, TG} &lt;: AbstractTimeStepper</code></pre><p>Holds parameters and tendency fields for a low storage, third-order Runge-Kutta-Wray time-stepping scheme described by Le and Moin (1991).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/TimeSteppers/runge_kutta_3.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TimeSteppers.RungeKutta3TimeStepper-Union{Tuple{TG}, Tuple{TI}, Tuple{Any, Any}} where {TI, TG}" href="#Oceananigans.TimeSteppers.RungeKutta3TimeStepper-Union{Tuple{TG}, Tuple{TI}, Tuple{Any, Any}} where {TI, TG}"><code>Oceananigans.TimeSteppers.RungeKutta3TimeStepper</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RungeKutta3TimeStepper(grid, tracers;
                       implicit_solver = nothing,
                       Gⁿ = TendencyFields(grid, tracers),
                       G⁻ = TendencyFields(grid, tracers))</code></pre><p>Return a 3rd-order Runge0Kutta timestepper (<code>RungeKutta3TimeStepper</code>) on <code>grid</code> and with <code>tracers</code>. The tendency fields <code>Gⁿ</code> and <code>G⁻</code> can be specified via  optional <code>kwargs</code>.</p><p>The scheme described by Le and Moin (1991) (see <a href="../../references/#LeMoin1991">H. Le, P. Moin (1991)</a>). In a nutshel, the 3rd-order Runge Kutta timestepper steps forward the state <code>U^n</code> by <code>Δt</code> via 3 substeps. A pressure correction step is applied after at each substep.</p><p>The state <code>U</code> after each substep <code>m</code> is</p><pre><code class="language-julia hljs">Uᵐ⁺¹ = Uᵐ + Δt * (γᵐ * Gᵐ + ζᵐ * Gᵐ⁻¹)`,</code></pre><p>where <code>Uᵐ</code> is the state at the <span>$m$</span>-th substep, <code>Gᵐ</code> is the tendency at the <span>$n$</span>-th substep, and <code>Gᵐ⁻¹</code> is the tendency at the previous substep, and constants <span>$γ¹ = 8/15$</span>, <span>$γ² = 5/12$</span>, <span>$γ³ = 3/4$</span>, <span>$ζ¹ = 0$</span>, <span>$ζ² = -17/60$</span>, <span>$ζ³ = -5/12$</span>.</p><p>The state at the first substep is taken to be the one that corresponds to the <span>$n$</span>-th timestep, <code>U¹ = Uⁿ</code>, and the state after the third substep is then the state at the <code>Uⁿ⁺¹ = U⁴</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/TimeSteppers/runge_kutta_3.jl#L21-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TimeSteppers.time_step!-Tuple{Oceananigans.AbstractModel{var&quot;#s1435&quot;} where var&quot;#s1435&quot;&lt;:QuasiAdamsBashforth2TimeStepper, Any}" href="#Oceananigans.TimeSteppers.time_step!-Tuple{Oceananigans.AbstractModel{var&quot;#s1435&quot;} where var&quot;#s1435&quot;&lt;:QuasiAdamsBashforth2TimeStepper, Any}"><code>Oceananigans.TimeSteppers.time_step!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">time_step!(model::AbstractModel{&lt;:QuasiAdamsBashforth2TimeStepper}, Δt; euler=false)</code></pre><p>Step forward <code>model</code> one time step <code>Δt</code> with a 2nd-order Adams-Bashforth method and pressure-correction substep. Setting <code>euler=true</code> will take a forward Euler time step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/TimeSteppers/quasi_adams_bashforth_2.jl#L63-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TimeSteppers.time_step!-Tuple{Oceananigans.AbstractModel{var&quot;#s1439&quot;} where var&quot;#s1439&quot;&lt;:RungeKutta3TimeStepper, Any}" href="#Oceananigans.TimeSteppers.time_step!-Tuple{Oceananigans.AbstractModel{var&quot;#s1439&quot;} where var&quot;#s1439&quot;&lt;:RungeKutta3TimeStepper, Any}"><code>Oceananigans.TimeSteppers.time_step!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">time_step!(model::AbstractModel{&lt;:RungeKutta3TimeStepper}, Δt)</code></pre><p>Step forward <code>model</code> one time step <code>Δt</code> with a 3rd-order Runge-Kutta method. The 3rd-order Runge-Kutta method takes three intermediate substep stages to achieve a single timestep. A pressure correction step is applied at each intermediate stage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/TimeSteppers/runge_kutta_3.jl#L73-L80">source</a></section></article><h2 id="Turbulence-closures"><a class="docs-heading-anchor" href="#Turbulence-closures">Turbulence closures</a><a id="Turbulence-closures-1"></a><a class="docs-heading-anchor-permalink" href="#Turbulence-closures" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.AbstractEddyViscosityClosure" href="#Oceananigans.TurbulenceClosures.AbstractEddyViscosityClosure"><code>Oceananigans.TurbulenceClosures.AbstractEddyViscosityClosure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractEddyViscosityClosure{TD, Iso} &lt;: AbstractScalarDiffusivity{TD, Iso}</code></pre><p>Abstract supertype for turbulence closures that are defined by an isotropic viscosity and isotropic diffusivities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/TurbulenceClosures/abstract_eddy_viscosity_closure.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation" href="#Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation"><code>Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AnisotropicMinimumDissipation{FT} &lt;: AbstractTurbulenceClosure</code></pre><p>Parameters for the &quot;anisotropic minimum dissipation&quot; turbulence closure for large eddy simulation proposed originally by <a href="../../references/#Rozema15">Wybe Rozema, Hyun J. Bae, Parviz Moin, Roel Verstappen (2015)</a> and <a href="../../references/#Abkar16">Mahdi Abkar, Hyun J. Bae, Parviz Moin (2016)</a>, and then modified by <a href="../../references/#Verstappen18">Roel Verstappen (2018)</a>, and finally described and validated for by <a href="../../references/#Vreugdenhil18">Catherine A. Vreugdenhil, John R. Taylor (2018)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.ConvectiveAdjustmentVerticalDiffusivity" href="#Oceananigans.TurbulenceClosures.ConvectiveAdjustmentVerticalDiffusivity"><code>Oceananigans.TurbulenceClosures.ConvectiveAdjustmentVerticalDiffusivity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConvectiveAdjustmentVerticalDiffusivity([time_discretization = VerticallyImplicitTimeDiscretization(), FT=Float64;]
                                        convective_κz = 0,
                                        convective_νz = 0,
                                        background_κz = 0,
                                        background_νz = 0)</code></pre><p>Return a convective adjustment vertical diffusivity closure that applies different values of diffusivity and/or viscosity depending whether the region is statically stable (positive or zero buoyancy gradient) or statically unstable (negative buoyancy gradient).</p><p><strong>Arguments</strong></p><ul><li><p><code>time_discretization</code>: Either <code>ExplicitTimeDiscretization()</code> or <code>VerticallyImplicitTimeDiscretization()</code>;                        default <code>VerticallyImplicitTimeDiscretization()</code>.</p></li><li><p><code>FT</code>: Float type; default <code>Float64</code>.</p></li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>convective_κz</code>: Vertical tracer diffusivity in regions with negative (unstable) buoyancy gradients. Either                  a single number, function, array, field, or tuple of diffusivities for each tracer.</p></li><li><p><code>background_κz</code>: Vertical tracer diffusivity in regions with zero or positive (stable) buoyancy gradients.</p></li><li><p><code>convective_νz</code>: Vertical viscosity in regions with negative (unstable) buoyancy gradients. Either                 a number, function, array, or field.</p></li><li><p><code>background_κz</code>: Vertical viscosity in regions with zero or positive (stable) buoyancy gradients.</p></li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; cavd = ConvectiveAdjustmentVerticalDiffusivity(convective_κz = 1)
ConvectiveAdjustmentVerticalDiffusivity{VerticallyImplicitTimeDiscretization}(background_κz=0.0 convective_κz=1 background_νz=0.0 convective_νz=0.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/TurbulenceClosures/turbulence_closure_implementations/convective_adjustment_vertical_diffusivity.jl#L21-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization" href="#Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization"><code>Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ExplicitTimeDiscretization &lt;: AbstractTimeDiscretization</code></pre><p>Represents fully-explicit time-discretization of a <code>TurbulenceClosure</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/TurbulenceClosures/implicit_explicit_time_discretization.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.HorizontalScalarDiffusivity" href="#Oceananigans.TurbulenceClosures.HorizontalScalarDiffusivity"><code>Oceananigans.TurbulenceClosures.HorizontalScalarDiffusivity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HorizontalScalarDiffusivity([time_discretization=ExplicitTimeDiscretization(),
                            FT::DataType=Float64;]
                            kwargs...)</code></pre><p>Shorthand for a <code>ScalarDiffusivity</code> with <code>HorizontalFormulation()</code>. See <a href="#Oceananigans.TurbulenceClosures.ScalarDiffusivity"><code>ScalarDiffusivity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L71-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.IsopycnalSkewSymmetricDiffusivity" href="#Oceananigans.TurbulenceClosures.IsopycnalSkewSymmetricDiffusivity"><code>Oceananigans.TurbulenceClosures.IsopycnalSkewSymmetricDiffusivity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IsopycnalSkewSymmetricDiffusivity([FT=Float64;]
                                  κ_skew = 0,
                                  κ_symmetric = 0,
                                  isopycnal_tensor = SmallSlopeIsopycnalTensor(),
                                  slope_limiter = nothing)</code></pre><p>Return parameters for an isopycnal skew-symmetric tracer diffusivity with skew diffusivity <code>κ_skew</code> and symmetric diffusivity <code>κ_symmetric</code> that uses an <code>isopycnal_tensor</code> model for for calculating the isopycnal slopes, and (optionally) applying a <code>slope_limiter</code> to the calculated isopycnal slope values.</p><p>Both <code>κ_skew</code> and <code>κ_symmetric</code> may be constants, arrays, fields, or functions of <code>(x, y, z, t)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/TurbulenceClosures/turbulence_closure_implementations/isopycnal_skew_symmetric_diffusivity.jl#L20-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.ScalarBiharmonicDiffusivity" href="#Oceananigans.TurbulenceClosures.ScalarBiharmonicDiffusivity"><code>Oceananigans.TurbulenceClosures.ScalarBiharmonicDiffusivity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ScalarBiharmonicDiffusivity{F, N, K} &lt;: AbstractScalarBiharmonicDiffusivity{F}</code></pre><p>Holds viscosity and diffusivities for models with prescribed isotropic diffusivities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/TurbulenceClosures/turbulence_closure_implementations/scalar_biharmonic_diffusivity.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.ScalarBiharmonicDiffusivity" href="#Oceananigans.TurbulenceClosures.ScalarBiharmonicDiffusivity"><code>Oceananigans.TurbulenceClosures.ScalarBiharmonicDiffusivity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ScalarBiharmonicDiffusivity([formulation=ThreeDimensionalFormulation(), FT=Float64;]
                            ν=0, κ=0,
                            discrete_form = false)</code></pre><p>Return a scalar biharmonic diffusivity turbulence closure with viscosity coefficient <code>ν</code> and tracer diffusivities <code>κ</code> for each tracer field in <code>tracers</code>. If a single <code>κ</code> is provided, it is applied to all tracers. Otherwise <code>κ</code> must be a <code>NamedTuple</code> with values for every tracer individually.</p><p><strong>Arguments</strong></p><ul><li><p><code>formulation</code>:</p><ul><li><code>HorizontalFormulation()</code> for diffusivity applied in the horizontal direction(s)</li><li><code>VerticalFormulation()</code> for diffusivity applied in the vertical direction,</li><li><code>ThreeDimensionalFormulation()</code> (default) for diffusivity applied isotropically to all directions</li></ul></li><li><p><code>FT</code>: the float datatype (default: <code>Float64</code>)</p></li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>ν</code>: Viscosity. <code>Number</code>, <code>AbstractArray</code>, or <code>Function(x, y, z, t)</code>.</p></li><li><p><code>κ</code>: Diffusivity. <code>Number</code>, <code>AbstractArray</code>, or <code>Function(x, y, z, t)</code>, or      <code>NamedTuple</code> of diffusivities with entries for each tracer.</p></li><li><p><code>discrete_form</code>: <code>Boolean</code>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/TurbulenceClosures/turbulence_closure_implementations/scalar_biharmonic_diffusivity.jl#L26-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.ScalarDiffusivity" href="#Oceananigans.TurbulenceClosures.ScalarDiffusivity"><code>Oceananigans.TurbulenceClosures.ScalarDiffusivity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ScalarDiffusivity([time_discretization=ExplicitTimeDiscretization(),
                  formulation=ThreeDimensionalFormulation(), FT=Float64];
                  ν=0, κ=0,
                  discrete_form = false)</code></pre><p>Return <code>ScalarDiffusivity</code> turbulence closure with viscosity <code>ν</code> and tracer diffusivities <code>κ</code> for each tracer field in <code>tracers</code>. If a single <code>κ</code> is provided, it is applied to all tracers. Otherwise <code>κ</code> must be a <code>NamedTuple</code> with values for every tracer individually.</p><p><strong>Arguments</strong></p><ul><li><p><code>time_discretization</code>: either <code>ExplicitTimeDiscretization()</code> (default) or <code>VerticallyImplicitTimeDiscretization()</code>.</p></li><li><p><code>formulation</code>:</p><ul><li><code>HorizontalFormulation()</code> for diffusivity applied in the horizontal direction(s)</li><li><code>VerticalFormulation()</code> for diffusivity applied in the vertical direction,</li><li><code>ThreeDimensionalFormulation()</code> (default) for diffusivity applied isotropically to all directions</li></ul></li><li><p><code>FT</code>: the float datatype (default: <code>Float64</code>)</p></li></ul><p><strong>Keyword arguments</strong></p><p><code>ν</code> and the fields of <code>κ</code> may be constants (converted to <code>FT</code>), arrays, fields or</p><ul><li>functions of <code>(x, y, z, t)</code> if <code>discrete_form = false</code></li><li>functions of <code>(i, j, k, grid, LX, LY, LZ)</code> with <code>LX</code>, <code>LY</code> and <code>LZ</code> are either <code>Face()</code> or <code>Center()</code> if <code>discrete_form = true</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L13-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.SmagorinskyLilly-Tuple{DataType}" href="#Oceananigans.TurbulenceClosures.SmagorinskyLilly-Tuple{DataType}"><code>Oceananigans.TurbulenceClosures.SmagorinskyLilly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SmagorinskyLilly(time_discretization = ExplicitTimeDiscretization, [FT=Float64;] C=0.16, Pr=1, ν=0, κ=0)</code></pre><p>Return a <code>SmagorinskyLilly</code> type associated with the turbulence closure proposed by Lilly (1962) and Smagorinsky (1958, 1963), which has an eddy viscosity of the form</p><pre><code class="nohighlight hljs">νₑ = (C * Δᶠ)² * √(2Σ²) * √(1 - Cb * N² / Σ²) + ν</code></pre><p>and an eddy diffusivity of the form</p><pre><code class="nohighlight hljs">κₑ = (νₑ - ν) / Pr + κ</code></pre><p>where <code>Δᶠ</code> is the filter width, <code>Σ² = ΣᵢⱼΣᵢⱼ</code> is the double dot product of the strain tensor <code>Σᵢⱼ</code>, <code>Pr</code> is the turbulent Prandtl number, and <code>N²</code> is the total buoyancy gradient, and <code>Cb</code> is a constant the multiplies the Richardson number modification to the eddy viscosity.</p><p><strong>Keyword arguments</strong></p><ul><li><code>C</code>: Smagorinsky constant. Default value is 0.16 as obtained by Lilly (1966).</li><li><code>Cb</code>: Buoyancy term multipler based on Lilly (1962) (<code>Cb = 0</code> turns it off, <code>Cb ≠ 0</code> turns it on.       Typically, and according to the original work by Lilly (1962), <code>Cb=1/Pr</code>.)</li><li><code>Pr</code>: Turbulent Prandtl numbers for each tracer. Either a constant applied to every       tracer, or a <code>NamedTuple</code> with fields for each tracer individually.</li><li><code>ν</code>: Constant background viscosity for momentum.</li><li><code>κ</code>: Constant background diffusivity for tracer. Can either be a single number      applied to all tracers, or <code>NamedTuple</code> of diffusivities corresponding to each      tracer.</li><li><code>time_discretization</code>: Either <code>ExplicitTimeDiscretization()</code> or <code>VerticallyImplicitTimeDiscretization()</code>,                         which integrates the terms involving only <span>$z$</span>-derivatives in the                        viscous and diffusive fluxes with an implicit time discretization.</li></ul><p><strong>References</strong></p><p>Smagorinsky, J. &quot;On the numerical integration of the primitive equations of motion for     baroclinic flow in a closed region.&quot; Monthly Weather Review (1958)</p><p>Lilly, D. K. &quot;On the numerical simulation of buoyant convection.&quot; Tellus (1962)</p><p>Smagorinsky, J. &quot;General circulation experiments with the primitive equations: I.     The basic experiment.&quot; Monthly weather review (1963)</p><p>Lilly, D. K. &quot;The representation of small-scale turbulence in numerical simulation experiments.&quot;      NCAR Manuscript No. 281, 0, 1966.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl#L20-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.TwoDimensionalLeith" href="#Oceananigans.TurbulenceClosures.TwoDimensionalLeith"><code>Oceananigans.TurbulenceClosures.TwoDimensionalLeith</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TwoDimensionalLeith(FT=Float64;
                    C=0.3, C_Redi=1, C_GM=1,
                    isopycnal_model=SmallSlopeIsopycnalTensor())</code></pre><p>Return a <code>TwoDimensionalLeith</code> type associated with the turbulence closure proposed by Leith (1965) and Fox-Kemper &amp; Menemenlis (2008) which has an eddy viscosity of the form</p><pre><code class="language-julia hljs">νₑ = (C * Δᶠ)³ * √(|∇ₕ ζ|² + |∇ₕ ∂w/∂z|²)</code></pre><p>and an eddy diffusivity of the form...</p><p>where <code>Δᶠ</code> is the filter width, <code>ζ = ∂v/∂x - ∂u/∂y</code> is the vertical vorticity, and <code>C</code> is a model constant.</p><p><strong>Keyword arguments</strong></p><ul><li><code>C</code>: Model constant</li><li><code>C_Redi</code>: Coefficient for down-gradient tracer diffusivity for each tracer.           Either a constant applied to every tracer, or a <code>NamedTuple</code> with fields           for each tracer individually.</li><li><code>C_GM</code>: Coefficient for down-gradient tracer diffusivity for each tracer.         Either a constant applied to every tracer, or a <code>NamedTuple</code> with fields         for each tracer individually.</li></ul><p><strong>References</strong></p><p>Leith, C. E. (1968). &quot;Diffusion Approximation for Two‐Dimensional Turbulence&quot;, The Physics of     Fluids 11, 671. doi: 10.1063/1.1691968</p><p>Fox‐Kemper, B., &amp; D. Menemenlis (2008), &quot;Can large eddy simulation techniques improve mesoscale rich     ocean models?&quot;, in Ocean Modeling in an Eddying Regime, Geophys. Monogr. Ser., vol. 177, pp. 319–337.     doi: 10.1029/177GM19</p><p>Pearson, B. et al. (2017) , &quot;Evaluation of scale-aware subgrid mesoscale eddy models in a global eddy     rich model&quot;, Ocean Modelling 115, 42-58. doi: 10.1016/j.ocemod.2017.05.007</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl#L20-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.VerticalScalarDiffusivity" href="#Oceananigans.TurbulenceClosures.VerticalScalarDiffusivity"><code>Oceananigans.TurbulenceClosures.VerticalScalarDiffusivity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VerticalScalarDiffusivity([time_discretization=ExplicitTimeDiscretization(),
                          FT::DataType=Float64;]
                          kwargs...)</code></pre><p>Shorthand for a <code>ScalarDiffusivity</code> with <code>VerticalFormulation()</code>. See <a href="#Oceananigans.TurbulenceClosures.ScalarDiffusivity"><code>ScalarDiffusivity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L61-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.VerticallyImplicitTimeDiscretization" href="#Oceananigans.TurbulenceClosures.VerticallyImplicitTimeDiscretization"><code>Oceananigans.TurbulenceClosures.VerticallyImplicitTimeDiscretization</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct VerticallyImplicitTimeDiscretization &lt;: AbstractTimeDiscretization</code></pre><p>Represents vertically-implicit time-discretization of a <code>TurbulenceClosure</code>.</p><p>This imples that a flux divergence such as <span>$∇ ⋅ q$</span> at the n-th timestep is  time-discretized as</p><pre><code class="language-julia hljs">[∇ ⋅ q]ⁿ = [explicit_flux_divergence]ⁿ + [∂z (κ ∂z c)]ⁿ⁺¹</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/TurbulenceClosures/implicit_explicit_time_discretization.jl#L17-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.∇_dot_qᶜ-Tuple{Any, Any, Any, Any, Oceananigans.TurbulenceClosures.AbstractTurbulenceClosure, Any, Any, Vararg{Any, N} where N}" href="#Oceananigans.TurbulenceClosures.∇_dot_qᶜ-Tuple{Any, Any, Any, Any, Oceananigans.TurbulenceClosures.AbstractTurbulenceClosure, Any, Any, Vararg{Any, N} where N}"><code>Oceananigans.TurbulenceClosures.∇_dot_qᶜ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∇_dot_qᶜ(i, j, k, grid, clock, closure::AbstractTurbulenceClosure, c, tracer_index, args...)</code></pre><p>Calculates the divergence of the diffusive flux <code>qᶜ</code> for a tracer <code>c</code> via</p><pre><code class="nohighlight hljs">1/V * [δxᶜᵃᵃ(Ax * diffusive_flux_x) + δyᵃᶜᵃ(Ay * diffusive_flux_y) + δzᵃᵃᶜ(Az * diffusive_flux_z)]</code></pre><p>which will end up at the location <code>ccc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/TurbulenceClosures/diffusion_operators.jl#L43-L51">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.AndSchedule-Tuple" href="#Oceananigans.Utils.AndSchedule-Tuple"><code>Oceananigans.Utils.AndSchedule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AndSchedule(child_schedule_1, child_schedule_2, other_child_schedules...)</code></pre><p>Return a schedule that actuates when all <code>child_schedule</code>s actuate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Utils/schedules.jl#L203-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.IterationInterval-Tuple{Any}" href="#Oceananigans.Utils.IterationInterval-Tuple{Any}"><code>Oceananigans.Utils.IterationInterval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">IterationInterval(interval; offset=0)</code></pre><p>Returns a callable <code>IterationInterval</code> that &quot;actuates&quot; (schedules output or callback execution) whenever the model iteration (modified by <code>offset</code>) is a multiple of <code>interval</code>.</p><p>For example, </p><ul><li><code>IterationInterval(100)</code> actuates at iterations <code>[100, 200, 300, ...]</code>.</li><li><code>IterationInterval(100, offset=-1)</code> actuates at iterations <code>[99, 199, 299, ...]</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Utils/schedules.jl#L65-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.OrSchedule-Tuple" href="#Oceananigans.Utils.OrSchedule-Tuple"><code>Oceananigans.Utils.OrSchedule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">OrSchedule(child_schedule_1, child_schedule_2, other_child_schedules...)</code></pre><p>Return a schedule that actuates when any of the <code>child_schedule</code>s actuates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Utils/schedules.jl#L219-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.SpecifiedTimes" href="#Oceananigans.Utils.SpecifiedTimes"><code>Oceananigans.Utils.SpecifiedTimes</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SpecifiedTimes &lt;: AbstractSchedule</code></pre><p>Callable <code>TimeInterval</code> schedule for periodic output or diagnostic evaluation according to <code>model.clock.time</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Utils/schedules.jl#L119-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.TimeInterval" href="#Oceananigans.Utils.TimeInterval"><code>Oceananigans.Utils.TimeInterval</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct TimeInterval &lt;: AbstractSchedule</code></pre><p>Callable <code>TimeInterval</code> schedule for periodic output or diagnostic evaluation according to <code>model.clock.time</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Utils/schedules.jl#L17-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.TimeInterval-Tuple{Any}" href="#Oceananigans.Utils.TimeInterval-Tuple{Any}"><code>Oceananigans.Utils.TimeInterval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TimeInterval(interval)</code></pre><p>Returns a callable <code>TimeInterval</code> that schedules periodic output or diagnostic evaluation on a <code>interval</code> of simulation time, as kept by <code>model.clock</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Utils/schedules.jl#L28-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.WallTimeInterval-Tuple{Any}" href="#Oceananigans.Utils.WallTimeInterval-Tuple{Any}"><code>Oceananigans.Utils.WallTimeInterval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">WallTimeInterval(interval; start_time = time_ns() * 1e-9)</code></pre><p>Returns a callable <code>WallTimeInterval</code> that schedules periodic output or diagnostic evaluation on a <code>interval</code> of &quot;wall time&quot; while a simulation runs, in units of seconds.</p><p>The &quot;wall time&quot; is the actual real world time in seconds, as kept by an actual or hypothetical clock hanging on your wall.</p><p>The keyword argument <code>start_time</code> can be used to specify a starting wall time other than the moment <code>WallTimeInterval</code> is constructed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Utils/schedules.jl#L89-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.cell_advection_timescale-NTuple{4, Any}" href="#Oceananigans.Utils.cell_advection_timescale-NTuple{4, Any}"><code>Oceananigans.Utils.cell_advection_timescale</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns the time-scale for advection on a regular grid across a single grid cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Utils/cell_advection_timescale.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.launch!-Tuple{Any, Any, Any, Any, Vararg{Any, N} where N}" href="#Oceananigans.Utils.launch!-Tuple{Any, Any, Any, Any, Vararg{Any, N} where N}"><code>Oceananigans.Utils.launch!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">launch!(arch, grid, layout, kernel!, args...; dependencies=nothing, kwargs...)</code></pre><p>Launches <code>kernel!</code>, with arguments <code>args</code> and keyword arguments <code>kwargs</code>, over the <code>dims</code> of <code>grid</code> on the architecture <code>arch</code>.</p><p>Returns an <code>event</code> token associated with the <code>kernel!</code> launch.</p><p>The keyword argument <code>dependencies</code> is an <code>Event</code> or <code>MultiEvent</code> specifying prior kernels that must complete before <code>kernel!</code> is launched.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Utils/kernel_launching.jl#L68-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.pretty_filesize" href="#Oceananigans.Utils.pretty_filesize"><code>Oceananigans.Utils.pretty_filesize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pretty_filesize(s, suffix=&quot;B&quot;)</code></pre><p>Convert a floating point value <code>s</code> representing a file size to a more human-friendly formatted string with one decimal places with a <code>suffix</code> defaulting to &quot;B&quot;. Depending on the value of <code>s</code> the string will be formatted to show <code>s</code> using an SI prefix from bytes, kiB (1024 bytes), MiB (1024² bytes), and so on up to YiB (1024⁸ bytes).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Utils/pretty_filesize.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.prettytime" href="#Oceananigans.Utils.prettytime"><code>Oceananigans.Utils.prettytime</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">prettytime(t, longform=true)</code></pre><p>Convert a floating point value <code>t</code> representing an amount of time in SI units of seconds to a human-friendly string with three decimal places. Depending on the value of <code>t</code> the string will be formatted to show <code>t</code> in nanoseconds (ns), microseconds (μs), milliseconds (ms), seconds, minutes, hours, days, or years.</p><p>With <code>longform=false</code>, we use s, m, hrs, d, and yrs in place of seconds, minutes, hours, and years.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Utils/prettytime.jl#L8-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.with_tracers-Tuple{Any, NamedTuple, Any}" href="#Oceananigans.Utils.with_tracers-Tuple{Any, NamedTuple, Any}"><code>Oceananigans.Utils.with_tracers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">with_tracers(tracer_names, initial_tuple, tracer_default)</code></pre><p>Create a tuple corresponding to the solution variables <code>u</code>, <code>v</code>, <code>w</code>, and <code>tracer_names</code>. <code>initial_tuple</code> is a <code>NamedTuple</code> that at least has fields <code>u</code>, <code>v</code>, and <code>w</code>, and may have some fields corresponding to the names in <code>tracer_names</code>. <code>tracer_default</code> is a function that produces a default tuple value for each tracer if not included in <code>initial_tuple</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Utils/with_tracers.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.work_layout-Tuple{Any, Symbol}" href="#Oceananigans.Utils.work_layout-Tuple{Any, Symbol}"><code>Oceananigans.Utils.work_layout</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">work_layout(grid, dims; include_right_boundaries=false, location=nothing)</code></pre><p>Returns the <code>workgroup</code> and <code>worksize</code> for launching a kernel over <code>dims</code> on <code>grid</code>. The <code>workgroup</code> is a tuple specifying the threads per block in each dimension. The <code>worksize</code> specifies the range of the loop in each dimension.</p><p>Specifying <code>include_right_boundaries=true</code> will ensure the work layout includes the right face end points along bounded dimensions. This requires the field <code>location</code> to be specified.</p><p>For more information, see: https://github.com/CliMA/Oceananigans.jl/pull/308</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3bb204768ab0f0b54ee962e52deac4f74c1127aa/src/Utils/kernel_launching.jl#L39-L51">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../benchmarks/">« Performance benchmarks</a><a class="docs-footer-nextpage" href="../function_index/">Function index »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Tuesday 15 March 2022 02:33">Tuesday 15 March 2022</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

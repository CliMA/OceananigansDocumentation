<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library ¬∑ Oceananigans.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://clima.github.io/OceananigansDocumentation/stable/appendix/library/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Oceananigans.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../installation_instructions/">Installation instructions</a></li><li><a class="tocitem" href="../../using_gpus/">Using GPUs</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/one_dimensional_diffusion/">One-dimensional diffusion</a></li><li><a class="tocitem" href="../../generated/geostrophic_adjustment/">Geostrophic adjustment</a></li><li><a class="tocitem" href="../../generated/two_dimensional_turbulence/">Two-dimensional turbulence</a></li><li><a class="tocitem" href="../../generated/internal_wave/">Internal wave</a></li><li><a class="tocitem" href="../../generated/convecting_plankton/">Convecting plankton</a></li><li><a class="tocitem" href="../../generated/ocean_wind_mixing_and_convection/">Ocean wind mixing and convection</a></li><li><a class="tocitem" href="../../generated/langmuir_turbulence/">Langmuir turbulence</a></li><li><a class="tocitem" href="../../generated/eady_turbulence/">Eady turbulence</a></li><li><a class="tocitem" href="../../generated/kelvin_helmholtz_instability/">Kelvin-Helmholtz instability</a></li><li><a class="tocitem" href="../../generated/shallow_water_Bickley_jet/">Shallow water Bickley jet</a></li><li><a class="tocitem" href="../../generated/horizontal_convection/">Horizontal convection</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Physics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../physics/notation/">Coordinate system and notation</a></li><li><a class="tocitem" href="../../physics/boussinesq/">Boussinesq approximation</a></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label"><code>NonhydrostaticModel</code></span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../physics/nonhydrostatic_model/">Nonhydrostatic model</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-4" type="checkbox"/><label class="tocitem" for="menuitem-5-4"><span class="docs-label"><code>HydrostaticFreeSurfaceModel</code></span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../physics/hydrostatic_free_surface_model/">Hydrostatic model with a free surface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-5" type="checkbox"/><label class="tocitem" for="menuitem-5-5"><span class="docs-label"><code>ShallowWaterModel</code></span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../physics/shallow_water_model/">Shallow water model</a></li></ul></li><li><a class="tocitem" href="../../physics/buoyancy_and_equations_of_state/">Buoyancy models and equations of state</a></li><li><a class="tocitem" href="../../physics/coriolis_forces/">Coriolis forces</a></li><li><a class="tocitem" href="../../physics/turbulence_closures/">Turbulence closures</a></li><li><a class="tocitem" href="../../physics/surface_gravity_waves/">Surface gravity waves and the Craik-Leibovich approximation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Numerical implementation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../numerical_implementation/finite_volume/">Finite volume method</a></li><li><a class="tocitem" href="../../numerical_implementation/spatial_operators/">Spatial operators</a></li><li><a class="tocitem" href="../../numerical_implementation/pressure_decomposition/">Pressure decomposition</a></li><li><a class="tocitem" href="../../numerical_implementation/time_stepping/">Time stepping</a></li><li><a class="tocitem" href="../../numerical_implementation/boundary_conditions/">Boundary conditions</a></li><li><a class="tocitem" href="../../numerical_implementation/poisson_solvers/">Poisson solvers</a></li><li><a class="tocitem" href="../../numerical_implementation/large_eddy_simulation/">Large eddy simulation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Model setup</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_setup/overview/">Overview</a></li><li><a class="tocitem" href="../../model_setup/architecture/">Architecture</a></li><li><a class="tocitem" href="../../model_setup/number_type/">Number type</a></li><li><a class="tocitem" href="../../model_setup/grids/">Grid</a></li><li><a class="tocitem" href="../../model_setup/clock/">Clock</a></li><li><a class="tocitem" href="../../model_setup/coriolis/">Coriolis (rotation)</a></li><li><a class="tocitem" href="../../model_setup/tracers/">Tracers</a></li><li><a class="tocitem" href="../../model_setup/buoyancy_and_equation_of_state/">Buoyancy models and equation of state</a></li><li><a class="tocitem" href="../../model_setup/boundary_conditions/">Boundary conditions</a></li><li><a class="tocitem" href="../../model_setup/forcing_functions/">Forcing functions</a></li><li><a class="tocitem" href="../../model_setup/background_fields/">Background fields</a></li><li><a class="tocitem" href="../../model_setup/turbulent_diffusivity_closures_and_les_models/">Turbulent diffusivity closures and LES models</a></li><li><a class="tocitem" href="../../model_setup/lagrangian_particles/">Lagrangian particles</a></li><li><a class="tocitem" href="../../model_setup/diagnostics/">Diagnostics</a></li><li><a class="tocitem" href="../../model_setup/output_writers/">Output writers</a></li><li><a class="tocitem" href="../../model_setup/checkpointing/">Checkpointing</a></li><li><a class="tocitem" href="../../model_setup/setting_initial_conditions/">Setting initial conditions</a></li></ul></li><li><a class="tocitem" href="../../simulation_tips/">Simulation tips</a></li><li><a class="tocitem" href="../../contributing/">Contributor&#39;s guide</a></li><li><a class="tocitem" href="../../gallery/">Gallery</a></li><li><a class="tocitem" href="../../references/">References</a></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox" checked/><label class="tocitem" for="menuitem-12"><span class="docs-label">Appendix</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../staggered_grid/">Staggered grid</a></li><li><a class="tocitem" href="../fractional_step/">Fractional step method</a></li><li><a class="tocitem" href="../convergence_tests/">Convergence tests</a></li><li><a class="tocitem" href="../benchmarks/">Performance benchmarks</a></li><li class="is-active"><a class="tocitem" href>Library</a><ul class="internal"><li><a class="tocitem" href="#Advection"><span>Advection</span></a></li><li><a class="tocitem" href="#Architectures"><span>Architectures</span></a></li><li><a class="tocitem" href="#Boundary-conditions"><span>Boundary conditions</span></a></li><li><a class="tocitem" href="#BuoyancyModels"><span>BuoyancyModels</span></a></li><li><a class="tocitem" href="#Coriolis"><span>Coriolis</span></a></li><li><a class="tocitem" href="#Diagnostics"><span>Diagnostics</span></a></li><li><a class="tocitem" href="#Fields"><span>Fields</span></a></li><li><a class="tocitem" href="#Forcings"><span>Forcings</span></a></li><li><a class="tocitem" href="#Grids"><span>Grids</span></a></li><li><a class="tocitem" href="#Lagrangian-particle-tracking"><span>Lagrangian particle tracking</span></a></li><li><a class="tocitem" href="#Logger"><span>Logger</span></a></li><li><a class="tocitem" href="#Models"><span>Models</span></a></li><li><a class="tocitem" href="#Output-writers"><span>Output writers</span></a></li><li><a class="tocitem" href="#Time-steppers"><span>Time steppers</span></a></li><li><a class="tocitem" href="#Simulations"><span>Simulations</span></a></li><li><a class="tocitem" href="#Tubrulence-closures"><span>Tubrulence closures</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li><li><a class="tocitem" href="#Abstract-operations"><span>Abstract operations</span></a></li></ul></li><li><a class="tocitem" href="../function_index/">Function index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Appendix</a></li><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/CliMA/Oceananigans.jl/blob/master/docs/src/appendix/library.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><p>Documenting the public user interface.</p><h2 id="Advection"><a class="docs-heading-anchor" href="#Advection">Advection</a><a id="Advection-1"></a><a class="docs-heading-anchor-permalink" href="#Advection" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.div_Uc-NTuple{7, Any}" href="#Oceananigans.Advection.div_Uc-NTuple{7, Any}"><code>Oceananigans.Advection.div_Uc</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">div_uc(i, j, k, grid, advection, U, c)</code></pre><p>Calculates the divergence of the flux of a tracer quantity <span>$c$</span> being advected by a velocity field, <span>$ùõÅ‚ãÖ(ùêØ c)$</span>,</p><pre><code class="nohighlight hljs">1/V * [Œ¥x·∂ú·µÉ·µÉ(Ax * u * ‚Ñëx·∂†·µÉ·µÉ(c)) + Œ¥y·µÉ·∂ú·µÉ(Ay * v * ‚Ñëy·µÉ·∂†·µÉ(c)) + Œ¥z·µÉ·µÉ·∂ú(Az * w * ‚Ñëz·µÉ·µÉ·∂†(c))]</code></pre><p>which ends up at the location <code>ccc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Advection/tracer_advection_operators.jl#L17-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.div_ùêØu-NTuple{7, Any}" href="#Oceananigans.Advection.div_ùêØu-NTuple{7, Any}"><code>Oceananigans.Advection.div_ùêØu</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">div_ùêØu(i, j, k, grid, advection, U, u)</code></pre><p>Calculate the advection of momentum in the <span>$x$</span>-direction using the conservative form, <span>$ùõÅ‚ãÖ(ùêØ u)$</span>,</p><pre><code class="nohighlight hljs">1/V·µò * [Œ¥x·∂†·µÉ·µÉ(‚Ñëx·∂ú·µÉ·µÉ(Ax * u) * ‚Ñëx·∂ú·µÉ·µÉ(u)) + Œ¥y_fca(‚Ñëx·∂†·µÉ·µÉ(Ay * v) * ‚Ñëy·µÉ·∂†·µÉ(u)) + Œ¥z_fac(‚Ñëx·∂†·µÉ·µÉ(Az * w) * ‚Ñëz·µÉ·µÉ·∂†(u))]</code></pre><p>which ends up at the location <code>fcc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Advection/momentum_advection_operators.jl#L47-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.div_ùêØv-NTuple{7, Any}" href="#Oceananigans.Advection.div_ùêØv-NTuple{7, Any}"><code>Oceananigans.Advection.div_ùêØv</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">div_ùêØv(i, j, k, grid, advection, U, v)</code></pre><p>Calculate the advection of momentum in the <span>$y$</span>-direction using the conservative form, <span>$ùõÅ‚ãÖ(ùêØ v)$</span>,</p><pre><code class="nohighlight hljs">1/V ∏ * [Œ¥x_cfa(‚Ñëy·µÉ·∂†·µÉ(Ax * u) * ‚Ñëx·∂†·µÉ·µÉ(v)) + Œ¥y·µÉ·∂†·µÉ(‚Ñëy·µÉ·∂ú·µÉ(Ay * v) * ‚Ñëy·µÉ·∂ú·µÉ(v)) + Œ¥z_afc(‚Ñëx·∂†·µÉ·µÉ(Az * w) * ‚Ñëz·µÉ·µÉ·∂†(w))]</code></pre><p>which ends up at the location <code>cfc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Advection/momentum_advection_operators.jl#L62-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.div_ùêØw-NTuple{7, Any}" href="#Oceananigans.Advection.div_ùêØw-NTuple{7, Any}"><code>Oceananigans.Advection.div_ùêØw</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">div_ùêØw(i, j, k, grid, advection, U, w)</code></pre><p>Calculate the advection of momentum in the <span>$z$</span>-direction using the conservative form, <span>$ùõÅ‚ãÖ(ùêØ w)$</span>,</p><pre><code class="nohighlight hljs">1/V ∑ * [Œ¥x_caf(‚Ñëz·µÉ·µÉ·∂†(Ax * u) * ‚Ñëx·∂†·µÉ·µÉ(w)) + Œ¥y_acf(‚Ñëz·µÉ·µÉ·∂†(Ay * v) * ‚Ñëy·µÉ·∂†·µÉ(w)) + Œ¥z·µÉ·µÉ·∂†(‚Ñëz·µÉ·µÉ·∂ú(Az * w) * ‚Ñëz·µÉ·µÉ·∂ú(w))]</code></pre><p>which ends up at the location <code>ccf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Advection/momentum_advection_operators.jl#L77-L85">source</a></section></article><h2 id="Architectures"><a class="docs-heading-anchor" href="#Architectures">Architectures</a><a id="Architectures-1"></a><a class="docs-heading-anchor-permalink" href="#Architectures" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Architectures.AbstractArchitecture" href="#Oceananigans.Architectures.AbstractArchitecture"><code>Oceananigans.Architectures.AbstractArchitecture</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractArchitecture</code></pre><p>Abstract supertype for architectures supported by Oceananigans.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Architectures.jl#L13-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Architectures.AbstractCPUArchitecture" href="#Oceananigans.Architectures.AbstractCPUArchitecture"><code>Oceananigans.Architectures.AbstractCPUArchitecture</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractCPUArchitecture</code></pre><p>Abstract supertype for CPU architectures supported by Oceananigans.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Architectures.jl#L21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Architectures.AbstractGPUArchitecture" href="#Oceananigans.Architectures.AbstractGPUArchitecture"><code>Oceananigans.Architectures.AbstractGPUArchitecture</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractGPUArchitecture</code></pre><p>Abstract supertype for GPU architectures supported by Oceananigans.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Architectures.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Architectures.CPU" href="#Oceananigans.Architectures.CPU"><code>Oceananigans.Architectures.CPU</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CPU &lt;: AbstractArchitecture</code></pre><p>Run Oceananigans on one CPU node. Uses multiple threads if the environment variable <code>JULIA_NUM_THREADS</code> is set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Architectures.jl#L35-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Architectures.GPU" href="#Oceananigans.Architectures.GPU"><code>Oceananigans.Architectures.GPU</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GPU &lt;: AbstractArchitecture</code></pre><p>Run Oceananigans on a single NVIDIA CUDA GPU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Architectures.jl#L43-L47">source</a></section></article><h2 id="Boundary-conditions"><a class="docs-heading-anchor" href="#Boundary-conditions">Boundary conditions</a><a id="Boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-conditions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.Flux" href="#Oceananigans.BoundaryConditions.Flux"><code>Oceananigans.BoundaryConditions.Flux</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Flux</code></pre><p>A classification specifying a boundary condition on the flux of a field.</p><p>The sign convention is such that a positive flux represents the flux of a quantity in the positive direction. For example, a positive vertical flux implies a quantity is fluxed upwards, in the +z direction.</p><p>Due to this convention, a positive flux applied to the top boundary specifies that a quantity is fluxed upwards across the top boundary and thus out of the domain. As a result, a positive flux applied to a top boundary leads to a reduction of that quantity in the interior of the domain; for example, a positive, upwards flux of heat at the top of the domain acts to cool the interior of the domain. Conversely, a positive flux applied to the bottom boundary leads to an increase of the quantity in the interior of the domain. The same logic holds for east, west, north, and south boundaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/BoundaryConditions/boundary_condition_classifications.jl#L17-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.Gradient" href="#Oceananigans.BoundaryConditions.Gradient"><code>Oceananigans.BoundaryConditions.Gradient</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Gradient</code></pre><p>A classification specifying a boundary condition on the derivative or gradient of a field. Also called a Neumann boundary condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/BoundaryConditions/boundary_condition_classifications.jl#L36-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.Open" href="#Oceananigans.BoundaryConditions.Open"><code>Oceananigans.BoundaryConditions.Open</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Open</code></pre><p>A classification that specifies the halo regions of a field directly.</p><p>For fields located at Faces, Open also specifies field value <em>on</em> the boundary.</p><p>Open boundary conditions are used to specify the component of a velocity field normal to a boundary and can also be used to describe nested or linked simulation domains.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/BoundaryConditions/boundary_condition_classifications.jl#L52-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.Value" href="#Oceananigans.BoundaryConditions.Value"><code>Oceananigans.BoundaryConditions.Value</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Value</code></pre><p>A classification specifying a boundary condition on the value of a field. Also called a Dirchlet boundary condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/BoundaryConditions/boundary_condition_classifications.jl#L44-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.BoundaryCondition" href="#Oceananigans.BoundaryConditions.BoundaryCondition"><code>Oceananigans.BoundaryConditions.BoundaryCondition</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct BoundaryCondition{C&lt;:AbstractBoundaryConditionClassification, T}</code></pre><p>Container for boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/BoundaryConditions/boundary_condition.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.BoundaryCondition-Tuple{DataType, Any}" href="#Oceananigans.BoundaryConditions.BoundaryCondition-Tuple{DataType, Any}"><code>Oceananigans.BoundaryConditions.BoundaryCondition</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoundaryCondition(Classification::DataType, condition)</code></pre><p>Construct a boundary condition of type <code>BC</code> with a number or array as a <code>condition</code>.</p><p>Boundary condition types include <code>Periodic</code>, <code>Flux</code>, <code>Value</code>, <code>Gradient</code>, and <code>Open</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/BoundaryConditions/boundary_condition.jl#L13-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.BoundaryCondition-Tuple{DataType, Function}" href="#Oceananigans.BoundaryConditions.BoundaryCondition-Tuple{DataType, Function}"><code>Oceananigans.BoundaryConditions.BoundaryCondition</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoundaryCondition(Classification::DataType, condition::Function;
                  parameters = nothing,
                  discrete_form = false,
                  field_dependencies=())</code></pre><p>Construct a boundary condition of type <code>Classification</code> with a function boundary <code>condition</code>.</p><p>By default, the function boudnary <code>condition</code> is assumed to have the &#39;continuous form&#39; <code>condition(Œæ, Œ∑, t)</code>, where <code>t</code> is time and <code>Œæ</code> and <code>Œ∑</code> vary along the boundary. In particular:</p><ul><li>On <code>x</code>-boundaries, <code>condition(y, z, t)</code>.</li><li>On <code>y</code>-boundaries, <code>condition(x, z, t)</code>.</li><li>On <code>z</code>-boundaries, <code>condition(x, y, t)</code>.</li></ul><p>If <code>parameters</code> is not <code>nothing</code>, then function boundary conditions have the form <code>func(Œæ, Œ∑, t, parameters)</code>, where <code>Œæ</code> and <code>Œ∑</code> are spatial coordinates varying along the boundary as explained above.</p><p>If <code>discrete_form = true</code>, the function <code>condition</code> is assumed to have the &quot;discrete form&quot;,</p><pre><code class="nohighlight hljs">condition(i, j, grid, clock, model_fields)</code></pre><p>where <code>i</code>, and <code>j</code> are indices that vary along the boundary. If <code>discrete_form = true</code> and <code>parameters</code> is not <code>nothing</code>, the function <code>condition</code> is called with</p><pre><code class="nohighlight hljs">condition(i, j, grid, clock, model_fields, parameters)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/BoundaryConditions/boundary_condition.jl#L22-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.FieldBoundaryConditions-Tuple{Any, Any}" href="#Oceananigans.BoundaryConditions.FieldBoundaryConditions-Tuple{Any, Any}"><code>Oceananigans.BoundaryConditions.FieldBoundaryConditions</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FieldBoundaryConditions(grid, location; kwargs...)</code></pre><p>Returns boundary conditions for auxiliary fields (fields whose values are derived from a model&#39;s prognostic fields) on <code>grid</code> and at <code>location</code>.</p><p>Keyword arguments specify boundary conditions on the 6 possible boundaries:</p><pre><code class="nohighlight hljs">* `west`, left end point in the `x`-direction where `i=1`
* `east`, right end point in the `x`-direction where `i=grid.Nx`
* `south`, left end point in the `y`-direction where `j=1`
* `north`, right end point in the `y`-direction where `j=grid.Ny`
* `bottom`, right end point in the `z`-direction where `k=1`
* `top`, right end point in the `z`-direction where `k=grid.Nz`</code></pre><p>If a boundary condition is unspecified, the default for auxiliary fields and the topology in the boundary-normal direction is used:</p><pre><code class="nohighlight hljs">* `PeriodicBoundaryCondition` for `Periodic` directions
* `GradientBoundaryCondition(0)` for `Bounded` directions and `Centered`-located fields
* `nothing` for `Bounded` directions and `Face`-located fields
* `nothing` for `Flat` directions and/or `Nothing`-located fields)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/BoundaryConditions/field_boundary_conditions.jl#L69-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.FieldBoundaryConditions-Tuple{}" href="#Oceananigans.BoundaryConditions.FieldBoundaryConditions-Tuple{}"><code>Oceananigans.BoundaryConditions.FieldBoundaryConditions</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FieldBoundaryConditions(; kwargs...)</code></pre><p>Returns a template for boundary conditions on prognostic fields.</p><p>Keyword arguments specify boundary conditions on the 7 possible boundaries:</p><pre><code class="nohighlight hljs">* `west`, left end point in the `x`-direction where `i=1`
* `east`, right end point in the `x`-direction where `i=grid.Nx`
* `south`, left end point in the `y`-direction where `j=1`
* `north`, right end point in the `y`-direction where `j=grid.Ny`
* `bottom`, right end point in the `z`-direction where `k=1`
* `top`, right end point in the `z`-direction where `k=grid.Nz`
* `immersed`, boundary between solid and fluid for immersed boundaries (experimental support only)</code></pre><p>If a boundary condition is unspecified, the default for prognostic fields and the topology in the boundary-normal direction is used:</p><pre><code class="nohighlight hljs">* `PeriodicBoundaryCondition` for `Periodic` directions
* `NoFluxBoundaryCondition` for `Bounded` directions and `Centered`-located fields
* `ImpenetrableBoundaryCondition` for `Bounded` directions and `Face`-located fields
* `nothing` for `Flat` directions and/or `Nothing`-located fields</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/BoundaryConditions/field_boundary_conditions.jl#L35-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.fill_halo_regions!-Tuple{OffsetArrays.OffsetArray, Any, Any, Any, Vararg{Any, N} where N}" href="#Oceananigans.BoundaryConditions.fill_halo_regions!-Tuple{OffsetArrays.OffsetArray, Any, Any, Any, Vararg{Any, N} where N}"><code>Oceananigans.BoundaryConditions.fill_halo_regions!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Fill halo regions in x, y, and z for a given field&#39;s data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/BoundaryConditions/fill_halo_regions.jl#L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.fill_halo_regions!-Tuple{Union{Tuple, NamedTuple}, Any, Vararg{Any, N} where N}" href="#Oceananigans.BoundaryConditions.fill_halo_regions!-Tuple{Union{Tuple, NamedTuple}, Any, Vararg{Any, N} where N}"><code>Oceananigans.BoundaryConditions.fill_halo_regions!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fill_halo_regions!(fields::Union{Tuple, NamedTuple}, arch, args...)</code></pre><p>Fill halo regions for each field in the tuple <code>fields</code> according to their boundary conditions, possibly recursing into <code>fields</code> if it is a nested tuple-of-tuples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/BoundaryConditions/fill_halo_regions.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.apply_x_bcs!-Tuple{Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any, Oceananigans.Architectures.AbstractArchitecture, Any, Vararg{Any, N} where N}" href="#Oceananigans.BoundaryConditions.apply_x_bcs!-Tuple{Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any, Oceananigans.Architectures.AbstractArchitecture, Any, Vararg{Any, N} where N}"><code>Oceananigans.BoundaryConditions.apply_x_bcs!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Apply flux boundary conditions to a field <code>c</code> by adding the associated flux divergence to the source term <code>Gc</code> at the left and right.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/BoundaryConditions/apply_flux_bcs.jl#L31-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.apply_y_bcs!-Tuple{Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any, Oceananigans.Architectures.AbstractArchitecture, Any, Vararg{Any, N} where N}" href="#Oceananigans.BoundaryConditions.apply_y_bcs!-Tuple{Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any, Oceananigans.Architectures.AbstractArchitecture, Any, Vararg{Any, N} where N}"><code>Oceananigans.BoundaryConditions.apply_y_bcs!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Apply flux boundary conditions to a field <code>c</code> by adding the associated flux divergence to the source term <code>Gc</code> at the left and right.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/BoundaryConditions/apply_flux_bcs.jl#L38-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.apply_z_bcs!-Tuple{Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any, Oceananigans.Architectures.AbstractArchitecture, Any, Vararg{Any, N} where N}" href="#Oceananigans.BoundaryConditions.apply_z_bcs!-Tuple{Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any, Oceananigans.Architectures.AbstractArchitecture, Any, Vararg{Any, N} where N}"><code>Oceananigans.BoundaryConditions.apply_z_bcs!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Apply flux boundary conditions to a field <code>c</code> by adding the associated flux divergence to the source term <code>Gc</code> at the top and bottom.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/BoundaryConditions/apply_flux_bcs.jl#L45-L48">source</a></section></article><h2 id="BuoyancyModels"><a class="docs-heading-anchor" href="#BuoyancyModels">BuoyancyModels</a><a id="BuoyancyModels-1"></a><a class="docs-heading-anchor-permalink" href="#BuoyancyModels" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BuoyancyModels.BuoyancyTracer" href="#Oceananigans.BuoyancyModels.BuoyancyTracer"><code>Oceananigans.BuoyancyModels.BuoyancyTracer</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BuoyancyTracer &lt;: AbstractBuoyancyModel{Nothing}</code></pre><p>Type indicating that the tracer <code>b</code> represents buoyancy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/BuoyancyModels/buoyancy_tracer.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BuoyancyModels.SeawaterBuoyancy" href="#Oceananigans.BuoyancyModels.SeawaterBuoyancy"><code>Oceananigans.BuoyancyModels.SeawaterBuoyancy</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SeawaterBuoyancy{FT, EOS, T, S} &lt;: AbstractBuoyancyModel{EOS}</code></pre><p>BuoyancyModels model for seawater. <code>T</code> and <code>S</code> are either <code>nothing</code> if both temperature and salinity are active, or of type <code>FT</code> if temperature or salinity are constant, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/BuoyancyModels/seawater_buoyancy.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BuoyancyModels.SeawaterBuoyancy" href="#Oceananigans.BuoyancyModels.SeawaterBuoyancy"><code>Oceananigans.BuoyancyModels.SeawaterBuoyancy</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SeawaterBuoyancy([FT=Float64;] gravitational_acceleration = g_Earth,
                              equation_of_state = LinearEquationOfState(FT),
                              constant_temperature = false, constant_salinity = false)</code></pre><p>Returns parameters for a temperature- and salt-stratified seawater buoyancy model with a <code>gravitational_acceleration</code> constant (typically called &#39;g&#39;), and an <code>equation_of_state</code> that related temperature and salinity (or conservative temperature and absolute salinity) to density anomalies and buoyancy.</p><p><code>constant_temperature</code> indicates that buoyancy depends only on salinity. For a nonlinear equation of state, <code>constant_temperature</code> is used as the temperature of the system. <code>true</code>. The same logic with the role of salinity and temperature reversed holds when <code>constant_salinity</code> is provided.</p><p>For a linear equation of state, the values of <code>constant_temperature</code> or <code>constant_salinity</code> are irrelevant; in this case, <code>constant_temperature=true</code> (and similar for <code>constant_salinity</code>) is valid input.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/BuoyancyModels/seawater_buoyancy.jl#L21-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BuoyancyModels.‚àÇx_b-Tuple{Any, Any, Any, Any, SeawaterBuoyancy, Any}" href="#Oceananigans.BuoyancyModels.‚àÇx_b-Tuple{Any, Any, Any, Any, SeawaterBuoyancy, Any}"><code>Oceananigans.BuoyancyModels.‚àÇx_b</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">‚àÇx_b(i, j, k, grid, b::SeawaterBuoyancy, C)</code></pre><p>Returns the x-derivative of buoyancy for temperature and salt-stratified water,</p><p class="math-container">\[‚àÇ_x b = g ( Œ± ‚àÇ_x T - Œ≤ ‚àÇ_x S ) ,\]</p><p>where <code>g</code> is gravitational acceleration, <code>Œ±</code> is the thermal expansion coefficient, <code>Œ≤</code> is the haline contraction coefficient, <code>T</code> is conservative temperature, and <code>S</code> is absolute salinity.</p><p>Note: In Oceananigans, <code>model.tracers.T</code> is conservative temperature and <code>model.tracers.S</code> is absolute salinity.</p><p>Note that <code>‚àÇx_T</code>, <code>‚àÇx_S</code>, <code>Œ±</code>, and <code>Œ≤</code> are all evaluated at cell interfaces in <code>x</code> and cell centers in <code>y</code> and <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/BuoyancyModels/seawater_buoyancy.jl#L73-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BuoyancyModels.‚àÇy_b-Tuple{Any, Any, Any, Any, SeawaterBuoyancy, Any}" href="#Oceananigans.BuoyancyModels.‚àÇy_b-Tuple{Any, Any, Any, Any, SeawaterBuoyancy, Any}"><code>Oceananigans.BuoyancyModels.‚àÇy_b</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">‚àÇy_b(i, j, k, grid, b::SeawaterBuoyancy, C)</code></pre><p>Returns the y-derivative of buoyancy for temperature and salt-stratified water,</p><p class="math-container">\[‚àÇ_y b = g ( Œ± ‚àÇ_y T - Œ≤ ‚àÇ_y S ) ,\]</p><p>where <code>g</code> is gravitational acceleration, <code>Œ±</code> is the thermal expansion coefficient, <code>Œ≤</code> is the haline contraction coefficient, <code>T</code> is conservative temperature, and <code>S</code> is absolute salinity.</p><p>Note: In Oceananigans, <code>model.tracers.T</code> is conservative temperature and <code>model.tracers.S</code> is absolute salinity.</p><p>Note that <code>‚àÇy_T</code>, <code>‚àÇy_S</code>, <code>Œ±</code>, and <code>Œ≤</code> are all evaluated at cell interfaces in <code>y</code> and cell centers in <code>x</code> and <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/BuoyancyModels/seawater_buoyancy.jl#L99-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BuoyancyModels.‚àÇz_b-Tuple{Any, Any, Any, Any, SeawaterBuoyancy, Any}" href="#Oceananigans.BuoyancyModels.‚àÇz_b-Tuple{Any, Any, Any, Any, SeawaterBuoyancy, Any}"><code>Oceananigans.BuoyancyModels.‚àÇz_b</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">‚àÇz_b(i, j, k, grid, b::SeawaterBuoyancy, C)</code></pre><p>Returns the vertical derivative of buoyancy for temperature and salt-stratified water,</p><p class="math-container">\[‚àÇ_z b = N^2 = g ( Œ± ‚àÇ_z T - Œ≤ ‚àÇ_z S ) ,\]</p><p>where <code>g</code> is gravitational acceleration, <code>Œ±</code> is the thermal expansion coefficient, <code>Œ≤</code> is the haline contraction coefficient, <code>T</code> is conservative temperature, and <code>S</code> is absolute salinity.</p><p>Note: In Oceananigans, <code>model.tracers.T</code> is conservative temperature and <code>model.tracers.S</code> is absolute salinity.</p><p>Note that <code>‚àÇz_T</code>, <code>‚àÇz_S</code>, <code>Œ±</code>, and <code>Œ≤</code> are all evaluated at cell interfaces in <code>z</code> and cell centers in <code>x</code> and <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/BuoyancyModels/seawater_buoyancy.jl#L125-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BuoyancyModels.LinearEquationOfState" href="#Oceananigans.BuoyancyModels.LinearEquationOfState"><code>Oceananigans.BuoyancyModels.LinearEquationOfState</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinearEquationOfState{FT} &lt;: AbstractEquationOfState</code></pre><p>Linear equation of state for seawater.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/BuoyancyModels/linear_equation_of_state.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BuoyancyModels.LinearEquationOfState" href="#Oceananigans.BuoyancyModels.LinearEquationOfState"><code>Oceananigans.BuoyancyModels.LinearEquationOfState</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinearEquationOfState([FT=Float64;] Œ±=1.67e-4, Œ≤=7.80e-4)</code></pre><p>Returns parameters for a linear equation of state for seawater with thermal expansion coefficient <code>Œ±</code> [K‚Åª¬π] and haline contraction coefficient <code>Œ≤</code> [psu‚Åª¬π]. The buoyancy perturbation associated with a linear equation of state is</p><p class="math-container">\[    b = g (Œ± T - Œ≤ S)\]</p><p>Default constants are taken from Table 1.2 (page 33) of Vallis, &quot;Atmospheric and Oceanic Fluid Dynamics: Fundamentals and Large-Scale Circulation&quot; (2ed, 2017).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/BuoyancyModels/linear_equation_of_state.jl#L11-L24">source</a></section></article><h2 id="Coriolis"><a class="docs-heading-anchor" href="#Coriolis">Coriolis</a><a id="Coriolis-1"></a><a class="docs-heading-anchor-permalink" href="#Coriolis" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.FPlane" href="#Oceananigans.Coriolis.FPlane"><code>Oceananigans.Coriolis.FPlane</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FPlane{FT} &lt;: AbstractRotation</code></pre><p>A parameter object for constant rotation around a vertical axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Coriolis/f_plane.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.FPlane" href="#Oceananigans.Coriolis.FPlane"><code>Oceananigans.Coriolis.FPlane</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FPlane([FT=Float64;] f=nothing, rotation_rate=Œ©_Earth, latitude=nothing)</code></pre><p>Returns a parameter object for constant rotation at the angular frequency <code>f/2</code>, and therefore with background vorticity <code>f</code>, around a vertical axis. If <code>f</code> is not specified, it is calculated from <code>rotation_rate</code> and <code>latitude</code> (in degrees) according to the relation <code>f = 2 * rotation_rate * sind(latitude)</code>.</p><p>By default, <code>rotation_rate</code> is assumed to be Earth&#39;s.</p><p>Also called <code>FPlane</code>, after the &quot;f-plane&quot; approximation for the local effect of a planet&#39;s rotation in a planar coordinate system tangent to the planet&#39;s surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Coriolis/f_plane.jl#L10-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.BetaPlane" href="#Oceananigans.Coriolis.BetaPlane"><code>Oceananigans.Coriolis.BetaPlane</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BetaPlane{T} &lt;: AbstractRotation</code></pre><p>A parameter object for meridionally increasing Coriolis parameter (<code>f = f‚ÇÄ + Œ≤ y</code>) that accounts for the variation of the locally vertical component of the rotation vector with latitude.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Coriolis/beta_plane.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.BetaPlane" href="#Oceananigans.Coriolis.BetaPlane"><code>Oceananigans.Coriolis.BetaPlane</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BetaPlane([T=Float64;] f‚ÇÄ=nothing, Œ≤=nothing,
                       rotation_rate=Œ©_Earth, latitude=nothing, radius=R_Earth)</code></pre><p>The user may specify both <code>f‚ÇÄ</code> and <code>Œ≤</code>, or the three parameters <code>rotation_rate</code>, <code>latitude</code> (in degrees), and <code>radius</code> that specify the rotation rate and radius of a planet, and the central latitude (where <span>$y = 0$</span>) at which the <code>Œ≤</code>-plane approximation is to be made.</p><p>If <code>f‚ÇÄ</code> and <code>Œ≤</code> are not specified, they are calculated from <code>rotation_rate</code>, <code>latitude</code>, and <code>radius</code> according to the relations <code>f‚ÇÄ = 2 * rotation_rate * sind(latitude)</code> and <code>Œ≤ = 2 * rotation_rate * cosd(latitude) / radius</code>.</p><p>By default, the <code>rotation_rate</code> and planet <code>radius</code> is assumed to be Earth&#39;s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Coriolis/beta_plane.jl#L13-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.NonTraditionalBetaPlane" href="#Oceananigans.Coriolis.NonTraditionalBetaPlane"><code>Oceananigans.Coriolis.NonTraditionalBetaPlane</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NonTraditionalBetaPlane{FT} &lt;: AbstractRotation</code></pre><p>A Coriolis implementation that accounts for the latitudinal variation of both the locally vertical and the locally horizontal components of the rotation vector. The &quot;traditional&quot; approximation in ocean models accounts for only the locally vertical component of the rotation vector (see <a href="#Oceananigans.Coriolis.BetaPlane"><code>BetaPlane</code></a>).</p><p>This implementation is based off of section 5 of Dellar (2011). It conserve energy, angular momentum, and potential vorticity.</p><p><strong>References</strong></p><p>Dellar, P. (2011). Variations on a beta-plane: Derivation of non-traditional     beta-plane equations from Hamilton&#39;s principle on a sphere. Journal of     Fluid Mechanics, 674, 174-195. doi:10.1017/S0022112010006464</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Coriolis/non_traditional_beta_plane.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.NonTraditionalBetaPlane" href="#Oceananigans.Coriolis.NonTraditionalBetaPlane"><code>Oceananigans.Coriolis.NonTraditionalBetaPlane</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NonTraditionalBetaPlane(FT=Float64;
    fz=nothing, fy=nothing, Œ≤=nothing, Œ≥=nothing,
    rotation_rate=Œ©_Earth, latitude=nothing, radius=R_Earth)</code></pre><p>The user may directly specify <code>fz</code>, <code>fy</code>, <code>Œ≤</code>, <code>Œ≥</code>, and <code>radius</code> or the three parameters <code>rotation_rate</code>, <code>latitude</code> (in degrees), and <code>radius</code> that specify the rotation rate and radius of a planet, and the central latitude (where <span>$y = 0$</span>) at which the non-traditional <code>Œ≤</code>-plane approximation is to be made.</p><p>If <code>fz</code>, <code>fy</code>, <code>Œ≤</code>, and <code>Œ≥</code> are not specified, they are calculated from <code>rotation_rate</code>,  <code>latitude</code>, and <code>radius</code> according to the relations <code>fz = 2 * rotation_rate * sind(latitude)</code>, <code>fy = 2 * rotation_rate * cosd(latitude)</code>, <code>Œ≤ = 2 * rotation_rate * cosd(latitude) / radius</code>, and <code>Œ≥ = - 4 * rotation_rate * sind(latitude) / radius</code>.</p><p>By default, the <code>rotation_rate</code> and planet <code>radius</code> is assumed to be Earth&#39;s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Coriolis/non_traditional_beta_plane.jl#L26-L42">source</a></section></article><h2 id="Diagnostics"><a class="docs-heading-anchor" href="#Diagnostics">Diagnostics</a><a id="Diagnostics-1"></a><a class="docs-heading-anchor-permalink" href="#Diagnostics" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.CFL" href="#Oceananigans.Diagnostics.CFL"><code>Oceananigans.Diagnostics.CFL</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CFL{D, S}</code></pre><p>An object for computing the Courant-Freidrichs-Lewy (CFL) number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Diagnostics/cfl.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.CFL-Tuple{Any}" href="#Oceananigans.Diagnostics.CFL-Tuple{Any}"><code>Oceananigans.Diagnostics.CFL</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CFL(Œît [, timescale=Oceananigans.cell_advection_timescale])</code></pre><p>Returns an object for computing the Courant-Freidrichs-Lewy (CFL) number associated with time step or <code>TimeStepWizard</code> <code>Œît</code> and <code>timescale</code>.</p><p>See also <code>AdvectiveCFL</code> and <code>DiffusiveCFL</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Diagnostics/cfl.jl#L14-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.AdvectiveCFL-Tuple{Any}" href="#Oceananigans.Diagnostics.AdvectiveCFL-Tuple{Any}"><code>Oceananigans.Diagnostics.AdvectiveCFL</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AdvectiveCFL(Œît)</code></pre><p>Returns an object for computing the Courant-Freidrichs-Lewy (CFL) number associated with time step or <code>TimeStepWizard</code> <code>Œît</code> and the time scale for advection across a cell.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; model = NonhydrostaticModel(grid=RegularRectilinearGrid(size=(16, 16, 16), length=(8, 8, 8)));

julia&gt; cfl = AdvectiveCFL(1.0);

julia&gt; data(model.velocities.u) .= œÄ;

julia&gt; cfl(model)
6.283185307179586</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Diagnostics/cfl.jl#L26-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.DiffusiveCFL-Tuple{Any}" href="#Oceananigans.Diagnostics.DiffusiveCFL-Tuple{Any}"><code>Oceananigans.Diagnostics.DiffusiveCFL</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DiffusiveCFL(Œît)</code></pre><p>Returns an object for computing the diffusive Courant-Freidrichs-Lewy (CFL) number associated with time step or <code>TimeStepWizard</code> <code>Œît</code> and the time scale for diffusion across a cell associated with <code>model.closure</code>.</p><p>The maximum diffusive CFL number among viscosity and all tracer diffusivities is returned.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; model = NonhydrostaticModel(grid=RegularRectilinearGrid(size=(16, 16, 16), length=(1, 1, 1)));

julia&gt; dcfl = DiffusiveCFL(0.1);

julia&gt; dcfl(model)
2.688e-5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Diagnostics/cfl.jl#L48-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.NaNChecker" href="#Oceananigans.Diagnostics.NaNChecker"><code>Oceananigans.Diagnostics.NaNChecker</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NaNChecker(; schedule, fields)</code></pre><p>Returns a <code>NaNChecker</code> that checks for a <code>NaN</code> anywhere in <code>fields</code> when <code>schedule</code> actuates. <code>fields</code> should be a named tuple. The simulation is aborted if a <code>NaN</code> is found.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Diagnostics/nan_checker.jl#L6-L11">source</a></section></article><h2 id="Fields"><a class="docs-heading-anchor" href="#Fields">Fields</a><a id="Fields-1"></a><a class="docs-heading-anchor-permalink" href="#Fields" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.Field" href="#Oceananigans.Fields.Field"><code>Oceananigans.Fields.Field</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Field(LX, LY, LZ, [arch = CPU()], grid,
      [ bcs = FieldBoundaryConditions(grid, (LX, LY, LZ)),
       data = new_data(eltype(grid), arch, grid, (LX, LY, LZ))])</code></pre><p>Construct a <code>Field</code> on <code>grid</code> with <code>data</code> on architecture <code>arch</code> with boundary conditions <code>bcs</code>. Each of <code>(LX, LY, LZ)</code> is either <code>Center</code> or <code>Face</code> and determines the field&#39;s location in <code>(x, y, z)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; œâ = Field(Face, Face, Center, CPU(), RegularRectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)))
Field located at (Face, Face, Center)
‚îú‚îÄ‚îÄ data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 1, 1)
‚îú‚îÄ‚îÄ grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1)
‚îî‚îÄ‚îÄ boundary conditions: west=Periodic, east=Periodic, south=Periodic, north=Periodic, bottom=ZeroFlux, top=ZeroFlux, immersed=ZeroFlux</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Fields/field.jl#L15-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.Field-Tuple{Tuple, Vararg{Any, N} where N}" href="#Oceananigans.Fields.Field-Tuple{Tuple, Vararg{Any, N} where N}"><code>Oceananigans.Fields.Field</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Field(L::Tuple, arch, grid, data, bcs)</code></pre><p>Construct a <code>Field</code> at the location defined by the 3-tuple <code>L</code>, whose elements are <code>Center</code> or <code>Face</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Fields/field.jl#L58-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.CenterField-Tuple{Oceananigans.Architectures.AbstractArchitecture, Any, Vararg{Any, N} where N}" href="#Oceananigans.Fields.CenterField-Tuple{Oceananigans.Architectures.AbstractArchitecture, Any, Vararg{Any, N} where N}"><code>Oceananigans.Fields.CenterField</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CenterField([arch=CPU()], grid, args...)</code></pre><p>Returns <code>Field{Center, Center, Center}</code> on <code>arch</code>itecture and <code>grid</code>. Additional arguments are passed to the <code>Field</code> constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Fields/field.jl#L70-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.XFaceField-Tuple{Oceananigans.Architectures.AbstractArchitecture, Vararg{Any, N} where N}" href="#Oceananigans.Fields.XFaceField-Tuple{Oceananigans.Architectures.AbstractArchitecture, Vararg{Any, N} where N}"><code>Oceananigans.Fields.XFaceField</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">XFaceField([arch=CPU()], grid, args...)</code></pre><p>Returns <code>Field{Face, Center, Center}</code> on <code>arch</code>itecture and <code>grid</code>. Additional arguments are passed to the <code>Field</code> constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Fields/field.jl#L78-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.YFaceField-Tuple{Oceananigans.Architectures.AbstractArchitecture, Vararg{Any, N} where N}" href="#Oceananigans.Fields.YFaceField-Tuple{Oceananigans.Architectures.AbstractArchitecture, Vararg{Any, N} where N}"><code>Oceananigans.Fields.YFaceField</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">YFaceField([arch=CPU()], grid, args...)</code></pre><p>Returns <code>Field{Center, Face, Center}</code> on <code>arch</code>itecture and <code>grid</code>. Additional arguments are passed to the <code>Field</code> constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Fields/field.jl#L86-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.ZFaceField-Tuple{Oceananigans.Architectures.AbstractArchitecture, Vararg{Any, N} where N}" href="#Oceananigans.Fields.ZFaceField-Tuple{Oceananigans.Architectures.AbstractArchitecture, Vararg{Any, N} where N}"><code>Oceananigans.Fields.ZFaceField</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ZFaceField([arch=CPU()], grid, args...)</code></pre><p>Returns <code>Field{Center, Center, Face}</code> on <code>arch</code>itecture and <code>grid</code>. Additional arguments are passed to the <code>Field</code> constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Fields/field.jl#L94-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.AveragedField-Tuple{Oceananigans.Fields.AbstractField}" href="#Oceananigans.Fields.AveragedField-Tuple{Oceananigans.Fields.AbstractField}"><code>Oceananigans.Fields.AveragedField</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AveragedField(operand::AbstractField; dims, data=nothing, recompute_safely=false)</code></pre><p>Returns an AveragedField averaged over <code>dims</code>. <code>dims</code> is a tuple of integers indicating spatial dimensions; in a Cartesian coordinate system, <code>1=x,</code>2=y<code>, and</code>3=z`.</p><p><strong>Arguments</strong></p><ul><li><p><code>dims</code>: Tuple of integers specifying the dimensions to average <code>operand</code>.         A single integer is also accepted for averaging over a single dimension.  </p></li><li><p><code>data</code>: An <code>OffsetArray</code> for storing averaged data.         Useful if carefully managing memory allocation.         If unspecified, <code>data</code> is created by <code>Oceananigans.Grids.new_data</code>.</p></li><li><p><code>recompute_safely</code>: A boolean that&#39;s relevant only if the <code>AveragedField</code> is used                     within another computation. If <code>recompute_safely=false</code>,                     <code>AveragedField</code> will <em>not</em> be recomputed before computing any dependent                     computations if <code>AveragedField.status</code> is consistent with the current state of the simulation.                     If <code>recompute_safely=true</code>, <code>AveragedField</code> is always recomputed                     before performing a dependent computation.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; using Oceananigans

julia&gt; grid = RegularRectilinearGrid(size=(2, 2, 2), x=(0, 1), y=(0, 1), z=(0, 1));

julia&gt; c = CenterField(CPU(), grid);

julia&gt; C_xy = AveragedField(c, dims=(1, 2)) # average over x, y
AveragedField over dims=(1, 2) located at (‚ãÖ, ‚ãÖ, Center) of Field located at (Center, Center, Center)
‚îú‚îÄ‚îÄ data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 1, 2)
‚îú‚îÄ‚îÄ grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=2, Ny=2, Nz=2)
‚îú‚îÄ‚îÄ dims: (1, 2)
‚îú‚îÄ‚îÄ operand: Field located at (Center, Center, Center)
‚îî‚îÄ‚îÄ status: time=0.0

julia&gt; C_z = AveragedField(c, dims=3) # averaged over z
AveragedField over dims=(3,) located at (Center, Center, ‚ãÖ) of Field located at (Center, Center, Center)
‚îú‚îÄ‚îÄ data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (2, 2, 1)
‚îú‚îÄ‚îÄ grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=2, Ny=2, Nz=2)
‚îú‚îÄ‚îÄ dims: (3,)
‚îú‚îÄ‚îÄ operand: Field located at (Center, Center, Center)
‚îî‚îÄ‚îÄ status: time=0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Fields/averaged_field.jl#L35-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.compute!" href="#Oceananigans.Fields.compute!"><code>Oceananigans.Fields.compute!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute!(avg::AveragedField, time=nothing)</code></pre><p>Compute the average of <code>avg.operand</code> and store the result in <code>avg.data</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Fields/averaged_field.jl#L100-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.set!-Tuple{Oceananigans.Fields.AbstractField{X, Y, Z, var&quot;#s183&quot;, G, T, N} where {X, Y, Z, var&quot;#s183&quot;&lt;:Oceananigans.Architectures.AbstractCPUArchitecture, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}, Function}" href="#Oceananigans.Fields.set!-Tuple{Oceananigans.Fields.AbstractField{X, Y, Z, var&quot;#s183&quot;, G, T, N} where {X, Y, Z, var&quot;#s183&quot;&lt;:Oceananigans.Architectures.AbstractCPUArchitecture, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}, Function}"><code>Oceananigans.Fields.set!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Set the CPU field <code>u</code> data to the function <code>f(x, y, z)</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Fields/set!.jl#L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.set!-Tuple{Oceananigans.Fields.AbstractField{X, Y, Z, var&quot;#s183&quot;, G, T, N} where {X, Y, Z, var&quot;#s183&quot;&lt;:Oceananigans.Architectures.AbstractCPUArchitecture, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}, Oceananigans.Fields.AbstractField{X, Y, Z, var&quot;#s183&quot;, G, T, N} where {X, Y, Z, var&quot;#s183&quot;&lt;:Oceananigans.Architectures.AbstractGPUArchitecture, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}" href="#Oceananigans.Fields.set!-Tuple{Oceananigans.Fields.AbstractField{X, Y, Z, var&quot;#s183&quot;, G, T, N} where {X, Y, Z, var&quot;#s183&quot;&lt;:Oceananigans.Architectures.AbstractCPUArchitecture, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}, Oceananigans.Fields.AbstractField{X, Y, Z, var&quot;#s183&quot;, G, T, N} where {X, Y, Z, var&quot;#s183&quot;&lt;:Oceananigans.Architectures.AbstractGPUArchitecture, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}"><code>Oceananigans.Fields.set!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Set the CPU field <code>u</code> data to the GPU field data of <code>v</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Fields/set!.jl#L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.set!-Tuple{Oceananigans.Fields.AbstractField{X, Y, Z, var&quot;#s183&quot;, G, T, N} where {X, Y, Z, var&quot;#s183&quot;&lt;:Oceananigans.Architectures.AbstractGPUArchitecture, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}, Oceananigans.Fields.AbstractField{X, Y, Z, var&quot;#s183&quot;, G, T, N} where {X, Y, Z, var&quot;#s183&quot;&lt;:Oceananigans.Architectures.AbstractCPUArchitecture, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}" href="#Oceananigans.Fields.set!-Tuple{Oceananigans.Fields.AbstractField{X, Y, Z, var&quot;#s183&quot;, G, T, N} where {X, Y, Z, var&quot;#s183&quot;&lt;:Oceananigans.Architectures.AbstractGPUArchitecture, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}, Oceananigans.Fields.AbstractField{X, Y, Z, var&quot;#s183&quot;, G, T, N} where {X, Y, Z, var&quot;#s183&quot;&lt;:Oceananigans.Architectures.AbstractCPUArchitecture, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}"><code>Oceananigans.Fields.set!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Set the GPU field <code>u</code> data to the CPU field data of <code>v</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Fields/set!.jl#L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.set!-Tuple{Oceananigans.Fields.AbstractField{X, Y, Z, var&quot;#s183&quot;, G, T, N} where {X, Y, Z, var&quot;#s183&quot;&lt;:Oceananigans.Architectures.AbstractGPUArchitecture, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}, Union{Function, Array}}" href="#Oceananigans.Fields.set!-Tuple{Oceananigans.Fields.AbstractField{X, Y, Z, var&quot;#s183&quot;, G, T, N} where {X, Y, Z, var&quot;#s183&quot;&lt;:Oceananigans.Architectures.AbstractGPUArchitecture, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}, Union{Function, Array}}"><code>Oceananigans.Fields.set!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Set the GPU field <code>u</code> to the array or function <code>v</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Fields/set!.jl#L49">source</a></section></article><h2 id="Forcings"><a class="docs-heading-anchor" href="#Forcings">Forcings</a><a id="Forcings-1"></a><a class="docs-heading-anchor-permalink" href="#Forcings" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.ContinuousForcing" href="#Oceananigans.Forcings.ContinuousForcing"><code>Oceananigans.Forcings.ContinuousForcing</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ContinuousForcing{LX, LY, LZ, P, F, D, I, ‚Ñë}</code></pre><p>A callable object that implements a &quot;continuous form&quot; forcing function on a field at the location <code>LX, LY, LZ</code> with optional parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Forcings/continuous_forcing.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.ContinuousForcing-Tuple{Any}" href="#Oceananigans.Forcings.ContinuousForcing-Tuple{Any}"><code>Oceananigans.Forcings.ContinuousForcing</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ContinuousForcing(func; parameters=nothing, field_dependencies=())</code></pre><p>Construct a &quot;continuous form&quot; forcing with optional <code>parameters</code> and optional <code>field_dependencies</code> on other fields in a model.</p><p>If neither <code>parameters</code> nor <code>field_dependencies</code> are provided, then <code>func</code> must be callable with the signature</p><pre><code class="nohighlight hljs">`func(x, y, z, t)`</code></pre><p>where <code>x, y, z</code> are the east-west, north-south, and vertical spatial coordinates, and <code>t</code> is time.</p><p>If <code>field_dependencies</code> are provided, the signature of <code>func</code> must include them. For example, if <code>field_dependencies=(:u, :S)</code> (and <code>parameters</code> are <em>not</em> provided), then <code>func</code> must be callable with the signature</p><pre><code class="nohighlight hljs">`func(x, y, z, t, u, S)`</code></pre><p>where <code>u</code> is assumed to be the <code>u</code>-velocity component, and <code>S</code> is a tracer. Note that any field which does not have the name <code>u</code>, <code>v</code>, or <code>w</code> is assumed to be a tracer and must be present in <code>model.tracers</code>.</p><p>If <code>parameters</code> are provided, then the <em>last</em> argument to <code>func</code> must be <code>parameters</code>. For example, if <code>func</code> has no <code>field_dependencies</code> but does depend on <code>parameters</code>, then it must be callable with the signature</p><pre><code class="nohighlight hljs">`func(x, y, z, t, parameters)`</code></pre><p>With <code>field_dependencies=(:u, :v, :w, :c)</code> and <code>parameters</code>, then <code>func</code> must be callable with the signature</p><pre><code class="nohighlight hljs">`func(x, y, z, t, u, v, w, c, parameters)`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Forcings/continuous_forcing.jl#L48-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.DiscreteForcing" href="#Oceananigans.Forcings.DiscreteForcing"><code>Oceananigans.Forcings.DiscreteForcing</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DiscreteForcing{P, F}</code></pre><p>Wrapper for &quot;discrete form&quot; forcing functions with optional <code>parameters</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Forcings/discrete_forcing.jl#L5-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.DiscreteForcing-Tuple{Any}" href="#Oceananigans.Forcings.DiscreteForcing-Tuple{Any}"><code>Oceananigans.Forcings.DiscreteForcing</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DiscreteForcing(func; parameters=nothing)</code></pre><p>Construct a &quot;discrete form&quot; forcing function with optional parameters. The forcing function is applied at grid point <code>i, j, k</code>.</p><p>When <code>parameters</code> are not specified, <code>func</code> must be callable with the signature</p><pre><code class="nohighlight hljs">`func(i, j, k, grid, clock, model_fields)`</code></pre><p>where <code>grid</code> is <code>model.grid</code>, <code>clock.time</code> is the current simulation time and <code>clock.iteration</code> is the current model iteration, and <code>model_fields</code> is a <code>NamedTuple</code> with <code>u, v, w</code> and the fields in <code>model.tracers</code>.</p><p><em>Note</em> that the index <code>end</code> does <em>not</em> access the final physical grid point of a model field in any direction. The final grid point must be explicitly specified, as in <code>model_fields.u[i, j, grid.Nz]</code>.</p><p>When <code>parameters</code> <em>is</em> specified, <code>func</code> must be callable with the signature.</p><pre><code class="nohighlight hljs">`func(i, j, k, grid, clock, model_fields, parameters)`</code></pre><p><code>parameters</code> is arbitrary in principle, however GPU compilation can place constraints on <code>typeof(parameters)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Forcings/discrete_forcing.jl#L16-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.Forcing-Tuple{Any}" href="#Oceananigans.Forcings.Forcing-Tuple{Any}"><code>Oceananigans.Forcings.Forcing</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Forcing(func; parameters=nothing, field_dependencies=(), discrete_form=false)</code></pre><p>Returns a forcing function added to the tendency of an Oceananigans model field.</p><p>If <code>discrete_form=false</code> (the default), and neither <code>parameters</code> nor <code>field_dependencies</code> are provided, then <code>func</code> must be callable with the signature</p><pre><code class="nohighlight hljs">`func(x, y, z, t)`</code></pre><p>where <code>x, y, z</code> are the east-west, north-south, and vertical spatial coordinates, and <code>t</code> is time. Note that this form is also default in the constructor for <code>NonhydrostaticModel</code>, so that <code>Forcing</code> is not needed.</p><p>If <code>discrete_form=false</code> (the default), and <code>field_dependencies</code> are provided, the signature of <code>func</code> must include them. For example, if <code>field_dependencies=(:u, :S)</code> (and <code>parameters</code> are <em>not</em> provided), then <code>func</code> must be callable with the signature</p><pre><code class="nohighlight hljs">`func(x, y, z, t, u, S)`</code></pre><p>where <code>u</code> is assumed to be the <code>u</code>-velocity component, and <code>S</code> is a tracer. Note that any field which does not have the name <code>u</code>, <code>v</code>, or <code>w</code> is assumed to be a tracer and must be present in <code>model.tracers</code>.</p><p>If <code>discrete_form=false</code> (the default) and <code>parameters</code> are provided, then the <em>last</em> argument to <code>func</code> must be <code>parameters</code>. For example, if <code>func</code> has no <code>field_dependencies</code> but does depend on <code>parameters</code>, then it must be callable with the signature</p><pre><code class="nohighlight hljs">`func(x, y, z, t, parameters)`</code></pre><p>The object <code>parameters</code> is arbitrary in principle, however GPU compilation can place constraints on <code>typeof(parameters)</code>.</p><p>With <code>field_dependencies=(:u, :v, :w, :c)</code> and <code>parameters</code>, then <code>func</code> must be callable with the signature</p><pre><code class="nohighlight hljs">`func(x, y, z, t, u, v, w, c, parameters)`</code></pre><p>If <code>discrete_form=true</code> then <code>func</code> must be callable with the &quot;discrete form&quot;</p><pre><code class="nohighlight hljs">`func(i, j, k, grid, clock, model_fields)`</code></pre><p>where <code>i, j, k</code> is the grid point at which the forcing is applied, <code>grid</code> is <code>model.grid</code>, <code>clock.time</code> is the current simulation time and <code>clock.iteration</code> is the current model iteration, and <code>model_fields</code> is a <code>NamedTuple</code> with <code>u, v, w</code>, the fields in <code>model.tracers</code>, and the fields in <code>model.diffusivity_fields</code>, each of which is an <code>OffsetArray</code>s (or <code>NamedTuple</code>s of <code>OffsetArray</code>s depending on the turbulence closure) of field data.</p><p>When <code>discrete_form=true</code> and <code>parameters</code> <em>is</em> specified, <code>func</code> must be callable with the signature</p><pre><code class="nohighlight hljs">`func(i, j, k, grid, clock, model_fields, parameters)`</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Oceananigans

# Parameterized forcing
parameterized_func(x, y, z, t, p) = p.Œº * exp(z / p.Œª) * cos(p.œâ * t)

v_forcing = Forcing(parameterized_func, parameters = (Œº=42, Œª=0.1, œâ=œÄ))

# output
ContinuousForcing{NamedTuple{(:Œº, :Œª, :œâ), Tuple{Int64, Float64, Irrational{:œÄ}}}}
‚îú‚îÄ‚îÄ func: parameterized_func
‚îú‚îÄ‚îÄ parameters: (Œº = 42, Œª = 0.1, œâ = œÄ)
‚îî‚îÄ‚îÄ field dependencies: ()</code></pre><p>Note that because forcing locations are regularized within the <code>NonhydrostaticModel</code> constructor:</p><pre><code class="language-julia hljs">grid = RegularRectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))
model = NonhydrostaticModel(grid=grid, forcing=(v=v_forcing,))

model.forcing.v

# output
ContinuousForcing{NamedTuple{(:Œº, :Œª, :œâ), Tuple{Int64, Float64, Irrational{:œÄ}}}} at (Center, Face, Center)
‚îú‚îÄ‚îÄ func: parameterized_func
‚îú‚îÄ‚îÄ parameters: (Œº = 42, Œª = 0.1, œâ = œÄ)
‚îî‚îÄ‚îÄ field dependencies: ()</code></pre><p>After passing through the constructor for <code>NonhydrostaticModel</code>, the <code>v</code>-forcing location information is available and set to <code>Center, Face, Center</code>.</p><pre><code class="language-julia hljs"># Field-dependent forcing
growth_in_sunlight(x, y, z, t, P) = exp(z) * P

plankton_forcing = Forcing(growth_in_sunlight, field_dependencies=:P)

# output
ContinuousForcing{Nothing}
‚îú‚îÄ‚îÄ func: growth_in_sunlight
‚îú‚îÄ‚îÄ parameters: nothing
‚îî‚îÄ‚îÄ field dependencies: (:P,)</code></pre><pre><code class="language-julia hljs"># Parameterized, field-dependent forcing
tracer_relaxation(x, y, z, t, c, p) = p.Œº * exp((z + p.H) / p.Œª) * (p.dCdz * z - c) 

c_forcing = Forcing(tracer_relaxation,
                    field_dependencies = :c,
                            parameters = (Œº=1/60, Œª=10, H=1000, dCdz=1))

# output
ContinuousForcing{NamedTuple{(:Œº, :Œª, :H, :dCdz), Tuple{Float64, Int64, Int64, Int64}}}
‚îú‚îÄ‚îÄ func: tracer_relaxation
‚îú‚îÄ‚îÄ parameters: (Œº = 0.016666666666666666, Œª = 10, H = 1000, dCdz = 1)
‚îî‚îÄ‚îÄ field dependencies: (:c,)</code></pre><pre><code class="language-julia hljs"># Unparameterized discrete-form forcing function
filtered_relaxation(i, j, k, grid, clock, model_fields) =
    @inbounds - (model_fields.c[i-1, j, k] + model_fields.c[i, j, k] + model_fields.c[i+1, j, k]) / 3

filtered_forcing = Forcing(filtered_relaxation, discrete_form=true)

# output
DiscreteForcing{Nothing}
‚îú‚îÄ‚îÄ func: filtered_relaxation
‚îî‚îÄ‚îÄ parameters: nothing</code></pre><pre><code class="language-julia hljs"># Discrete-form forcing function with parameters
masked_damping(i, j, k, grid, clock, model_fields, parameters) = 
    @inbounds - parameters.Œº * exp(grid.zC[k] / parameters.Œª) * model_fields.u[i, j, k]

masked_damping_forcing = Forcing(masked_damping, parameters=(Œº=42, Œª=œÄ), discrete_form=true)

# output
DiscreteForcing{NamedTuple{(:Œº, :Œª), Tuple{Int64, Irrational{:œÄ}}}}
‚îú‚îÄ‚îÄ func: masked_damping
‚îî‚îÄ‚îÄ parameters: (Œº = 42, Œª = œÄ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Forcings/forcing.jl#L1-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.GaussianMask" href="#Oceananigans.Forcings.GaussianMask"><code>Oceananigans.Forcings.GaussianMask</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GaussianMask{D}(center, width)</code></pre><p>Callable object that returns a Gaussian masking function centered on <code>center</code>, with <code>width</code>, and varying along direction <code>D</code>.</p><p><strong>Examples</strong></p><ul><li>Create a Gaussian mask centered on <code>z=0</code> with width <code>1</code> meter.</li></ul><pre><code class="language-julia hljs">julia&gt; mask = GaussianMask{:z}(center=0, width=1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Forcings/relaxation.jl#L101-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.LinearTarget" href="#Oceananigans.Forcings.LinearTarget"><code>Oceananigans.Forcings.LinearTarget</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinearTarget{D}(intercept, gradient)</code></pre><p>Callable object that returns a Linear target function with <code>intercept</code> and <code>gradient</code>, and varying along direction <code>D</code>.</p><p><strong>Examples</strong></p><ul><li>Create a linear target function varying in <code>z</code>, equal to <code>0</code> at <code>z=0</code> and with gradient 10‚Åª‚Å∂:</li></ul><pre><code class="language-julia hljs">julia&gt; target = LinearTarget{:z}(intercept=0, gradient=1e-6)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Forcings/relaxation.jl#L141-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.Relaxation" href="#Oceananigans.Forcings.Relaxation"><code>Oceananigans.Forcings.Relaxation</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Relaxation{R, M, T}</code></pre><p>Callable object for restoring fields to a <code>target</code> at some <code>rate</code> and within a <code>mask</code>ed region in <code>x, y, z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Forcings/relaxation.jl#L12-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.Relaxation-Tuple{}" href="#Oceananigans.Forcings.Relaxation-Tuple{}"><code>Oceananigans.Forcings.Relaxation</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Relaxation(; rate, mask=onefunction, target=zerofunction)</code></pre><p>Returns a <code>Forcing</code> that restores a field to <code>target(x, y, z, t)</code> at the specified <code>rate</code>, in the region <code>mask(x, y, z)</code>.</p><p>The functions <code>onefunction</code> and <code>zerofunction</code> always return 1 and 0, respectively. Thus the default <code>mask</code> leaves the whole domain uncovered, and the default <code>target</code> is zero.</p><p><strong>Example</strong></p><ul><li>Restore a field to zero on a timescale of &quot;3600&quot; (equal to one hour if the time units of the simulation are seconds).</li></ul><pre><code class="language-julia hljs">using Oceananigans

damping = Relaxation(rate = 1/3600)

# output
Relaxation{Float64, typeof(Oceananigans.Forcings.onefunction), typeof(Oceananigans.Forcings.zerofunction)}
‚îú‚îÄ‚îÄ rate: 0.0002777777777777778
‚îú‚îÄ‚îÄ mask: 1
‚îî‚îÄ‚îÄ target: 0</code></pre><ul><li>Restore a field to a linear z-gradient within the bottom 1/4 of a domain on a timescale of &quot;60&quot; (equal to one minute if the time units of the simulation are seconds).</li></ul><pre><code class="language-julia hljs">dTdz = 0.001 # ‚Å∞C m‚Åª¬π, temperature gradient

T‚ÇÄ = 20 # ‚Å∞C, surface temperature at z=0

Lz = 100 # m, depth of domain

bottom_sponge_layer = Relaxation(; rate = 1/60,
                                   target = LinearTarget{:z}(intercept=T‚ÇÄ, gradient=dTdz),
                                   mask = GaussianMask{:z}(center=-Lz, width=Lz/4))

# output
Relaxation{Float64, GaussianMask{:z, Float64}, LinearTarget{:z, Float64}}
‚îú‚îÄ‚îÄ rate: 0.016666666666666666
‚îú‚îÄ‚îÄ mask: exp(-(z + 100.0)^2 / (2 * 25.0^2))
‚îî‚îÄ‚îÄ target: 20.0 + 0.001 * z</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Forcings/relaxation.jl#L24-L72">source</a></section></article><h2 id="Grids"><a class="docs-heading-anchor" href="#Grids">Grids</a><a id="Grids-1"></a><a class="docs-heading-anchor-permalink" href="#Grids" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.AbstractCurvilinearGrid" href="#Oceananigans.Grids.AbstractCurvilinearGrid"><code>Oceananigans.Grids.AbstractCurvilinearGrid</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractCurvilinearGrid{FT, TX, TY, TZ}</code></pre><p>Abstract supertype for curvilinear grids with elements of type <code>FT</code> and topology <code>{TX, TY, TZ}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Grids/Grids.jl#L98-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.AbstractGrid" href="#Oceananigans.Grids.AbstractGrid"><code>Oceananigans.Grids.AbstractGrid</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractGrid{FT, TX, TY, TZ}</code></pre><p>Abstract supertype for grids with elements of type <code>FT</code> and topology <code>{TX, TY, TZ}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Grids/Grids.jl#L76-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.AbstractHorizontallyCurvilinearGrid" href="#Oceananigans.Grids.AbstractHorizontallyCurvilinearGrid"><code>Oceananigans.Grids.AbstractHorizontallyCurvilinearGrid</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractHorizontallyCurvilinearGrid{FT, TX, TY, TZ}</code></pre><p>Abstract supertype for horizontally-curvilinear grids with elements of type <code>FT</code> and topology <code>{TX, TY, TZ}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Grids/Grids.jl#L105-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.AbstractRectilinearGrid" href="#Oceananigans.Grids.AbstractRectilinearGrid"><code>Oceananigans.Grids.AbstractRectilinearGrid</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractRectilinearGrid{FT, TX, TY, TZ}</code></pre><p>Abstract supertype for rectilinear grids with elements of type <code>FT</code> and topology <code>{TX, TY, TZ}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Grids/Grids.jl#L91-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.AbstractTopology" href="#Oceananigans.Grids.AbstractTopology"><code>Oceananigans.Grids.AbstractTopology</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractTopology</code></pre><p>Abstract supertype for grid topologies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Grids/Grids.jl#L40-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.AbstractUnderlyingGrid" href="#Oceananigans.Grids.AbstractUnderlyingGrid"><code>Oceananigans.Grids.AbstractUnderlyingGrid</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractUnderlyingGrid{FT, TX, TY, TZ}</code></pre><p>Abstract supertype for &quot;primary&quot; grids (as opposed to grids with immersed boundaries) with elements of type <code>FT</code> and topology <code>{TX, TY, TZ}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Grids/Grids.jl#L83-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.Bounded" href="#Oceananigans.Grids.Bounded"><code>Oceananigans.Grids.Bounded</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Bounded</code></pre><p>Grid topology for bounded dimensions, e.g., wall-bounded dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Grids/Grids.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.Center" href="#Oceananigans.Grids.Center"><code>Oceananigans.Grids.Center</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Center</code></pre><p>A type describing the location at the center of a grid cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Grids/Grids.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.Connected" href="#Oceananigans.Grids.Connected"><code>Oceananigans.Grids.Connected</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Connected</code></pre><p>Grid topology for dimensions that are connected to other models or domains on both sides.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Grids/Grids.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.Face" href="#Oceananigans.Grids.Face"><code>Oceananigans.Grids.Face</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Face</code></pre><p>A type describing the location at the face of a grid cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Grids/Grids.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.Flat" href="#Oceananigans.Grids.Flat"><code>Oceananigans.Grids.Flat</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Flat</code></pre><p>Grid topology for flat dimensions, generally with one grid point, along which the solution is uniform and does not vary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Grids/Grids.jl#L61-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.Periodic" href="#Oceananigans.Grids.Periodic"><code>Oceananigans.Grids.Periodic</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Periodic</code></pre><p>Grid topology for periodic dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Grids/Grids.jl#L47-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.nodes-Tuple{Any, Oceananigans.Grids.AbstractGrid}" href="#Oceananigans.Grids.nodes-Tuple{Any, Oceananigans.Grids.AbstractGrid}"><code>Oceananigans.Grids.nodes</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nodes(loc, grid; reshape=false)</code></pre><p>Returns a 3-tuple of views over the interior nodes at the locations in <code>loc</code> in <code>x, y, z</code>.</p><p>If <code>reshape=true</code>, the views are reshaped to 3D arrays with non-singleton dimensions 1, 2, 3 for <code>x, y, z</code>, respectively. These reshaped arrays can then be used in broadcast operations with 3D fields or arrays.</p><p>See <code>xnodes</code>, <code>ynodes</code>, and <code>znodes</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Grids/grid_utils.jl#L246-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.xnodes-Tuple{Any, Any}" href="#Oceananigans.Grids.xnodes-Tuple{Any, Any}"><code>Oceananigans.Grids.xnodes</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">xnodes(loc, grid, reshape=false)</code></pre><p>Returns a view over the interior <code>loc=Center</code> or <code>loc=Face</code> nodes on <code>grid</code> in the x-direction. For <code>Bounded</code> directions, <code>Face</code> nodes include the boundary points. <code>reshape=false</code> will return a 1D array while <code>reshape=true</code> will return a 3D array with size Nx√ó1√ó1.</p><p>See <code>znodes</code> for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Grids/grid_utils.jl#L164-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.ynodes-Tuple{Any, Any}" href="#Oceananigans.Grids.ynodes-Tuple{Any, Any}"><code>Oceananigans.Grids.ynodes</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ynodes(loc, grid, reshape=false)</code></pre><p>Returns a view over the interior <code>loc=Center</code> or <code>loc=Face</code> nodes on <code>grid</code> in the y-direction. For <code>Bounded</code> directions, <code>Face</code> nodes include the boundary points. <code>reshape=false</code> will return a 1D array while <code>reshape=true</code> will return a 3D array with size 1√óNy√ó1.</p><p>See <code>znodes</code> for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Grids/grid_utils.jl#L183-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.znodes-Tuple{Any, Any}" href="#Oceananigans.Grids.znodes-Tuple{Any, Any}"><code>Oceananigans.Grids.znodes</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">znodes(loc, grid, reshape=false)</code></pre><p>Returns a view over the interior <code>loc=Center</code> or <code>loc=Face</code> nodes on <code>grid</code> in the z-direction. For <code>Bounded</code> directions, <code>Face</code> nodes include the boundary points. <code>reshape=false</code> will return a 1D array while <code>reshape=true</code> will return a 3D array with size 1√ó1√óNz.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; horz_periodic_grid = RegularRectilinearGrid(size=(3, 3, 3), extent=(2œÄ, 2œÄ, 1),
                                                 topology=(Periodic, Periodic, Bounded));

julia&gt; zC = znodes(Center, horz_periodic_grid)
3-element view(OffsetArray(::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, 0:4), 1:3) with eltype Float64:
 -0.8333333333333331
 -0.4999999999999999
 -0.16666666666666652</code></pre><pre><code class="language-julia-repl hljs">julia&gt; zF = znodes(Face, horz_periodic_grid)
4-element view(OffsetArray(::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, 0:5), 1:4) with eltype Float64:
 -1.0
 -0.6666666666666666
 -0.33333333333333337
 -4.44089209850063e-17</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Grids/grid_utils.jl#L203-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.RegularRectilinearGrid" href="#Oceananigans.Grids.RegularRectilinearGrid"><code>Oceananigans.Grids.RegularRectilinearGrid</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RegularRectilinearGrid{FT, TX, TY, TZ, R} &lt;: AbstractRectilinearGrid{FT, TX, TY, TZ}</code></pre><p>A rectilinear grid with with constant grid spacings <code>Œîx</code>, <code>Œîy</code>, and <code>Œîz</code> between cell centers and cell faces, elements of type <code>FT</code>, topology <code>{TX, TY, TZ}</code>, and coordinate ranges of type <code>R</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Grids/regular_rectilinear_grid.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.RegularRectilinearGrid" href="#Oceananigans.Grids.RegularRectilinearGrid"><code>Oceananigans.Grids.RegularRectilinearGrid</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RegularRectilinearGrid([FT=Float64]; size,
                       extent = nothing, x = nothing, y = nothing, z = nothing,
                       topology = (Periodic, Periodic, Bounded), halo = (1, 1, 1))</code></pre><p>Creates a <code>RegularRectilinearGrid</code> with <code>size = (Nx, Ny, Nz)</code> grid points.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>size</code> (required): A tuple prescribing the number of grid points in non-<code>Flat</code> directions.                    <code>size</code> is a 3-tuple for 3D models, a 2-tuple for 2D models, and either a                    scalar or 1-tuple for 1D models.</p></li><li><p><code>topology</code>: A 3-tuple <code>(Tx, Ty, Tz)</code> specifying the topology of the domain.             <code>Tx</code>, <code>Ty</code>, and <code>Tz</code> specify whether the <code>x</code>-, <code>y</code>-, and <code>z</code> directions are             <code>Periodic</code>, <code>Bounded</code>, or <code>Flat</code>. The topology <code>Flat</code> indicates that a model does             not vary in those directions so that derivatives and interpolation are zero.             The default is <code>topology=(Periodic, Periodic, Bounded)</code>.</p></li><li><p><code>extent</code>: A tuple prescribing the physical extent of the grid in non-<code>Flat</code> directions.           The origin for three-dimensional domains is the oceanic default <code>(0, 0, -Lz)</code>.</p></li><li><p><code>x</code>, <code>y</code>, and <code>z</code>: Each of <code>x, y, z</code> are 2-tuples that specify the end points of the domain                    in their respect directions. Scalar values may be used in <code>Flat</code> directions.</p></li></ul><p><em>Note</em>: <em>Either</em> <code>extent</code>, or all of <code>x</code>, <code>y</code>, and <code>z</code> must be specified.</p><ul><li><code>halo</code>: A tuple of integers that specifies the size of the halo region of cells surrounding         the physical interior for each non-<code>Flat</code> direction.</li></ul><p>The physical extent of the domain can be specified via <code>x</code>, <code>y</code>, and <code>z</code> keyword arguments indicating the left and right endpoints of each dimensions, e.g. <code>x=(-œÄ, œÄ)</code> or via the <code>extent</code> argument, e.g. <code>extent=(Lx, Ly, Lz)</code> which specifies the extent of each dimension in which case 0 ‚â§ x ‚â§ Lx, 0 ‚â§ y ‚â§ Ly, and -Lz ‚â§ z ‚â§ 0.</p><p>A grid topology may be specified via a tuple assigning one of <code>Periodic</code>, <code>Bounded</code>, and <code>Flat</code> to each dimension. By default, a horizontally periodic grid topology <code>(Periodic, Periodic, Bounded)</code> is assumed.</p><p>Constants are stored using floating point values of type <code>FT</code>. By default this is <code>Float64</code>. Make sure to specify the desired <code>FT</code> if not using <code>Float64</code>.</p><p><strong>Grid properties</strong></p><ul><li><p><code>(Nx, Ny, Nz)::Int</code>: Number of physical points in the (x, y, z)-direction</p></li><li><p><code>(Hx, Hy, Hz)::Int</code>: Number of halo points in the (x, y, z)-direction</p></li><li><p><code>(Lx, Ly, Lz)::FT</code>: Physical extent of the grid in the (x, y, z)-direction</p></li><li><p><code>(Œîx, Œîy, Œîz)::FT</code>: Grid spacing (distance between grid nodes) in the (x, y, z)-direction</p></li><li><p><code>(xC, yC, zC)</code>: (x, y, z) coordinates of cell centers.</p></li><li><p><code>(xF, yF, zF)</code>: (x, y, z) coordinates of cell faces.</p></li></ul><p><strong>Examples</strong></p><ul><li>A default grid with Float64 type:</li></ul><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = RegularRectilinearGrid(size=(32, 32, 32), extent=(1, 2, 3))
RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}
                   domain: x ‚àà [0.0, 1.0], y ‚àà [0.0, 2.0], z ‚àà [-3.0, 0.0]
                 topology: (Periodic, Periodic, Bounded)
        size (Nx, Ny, Nz): (32, 32, 32)
        halo (Hx, Hy, Hz): (1, 1, 1)
grid spacing (Œîx, Œîy, Œîz): (0.03125, 0.0625, 0.09375)</code></pre><ul><li>A default grid with Float32 type:</li></ul><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = RegularRectilinearGrid(Float32; size=(32, 32, 16), x=(0, 8), y=(-10, 10), z=(-œÄ, œÄ))
RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded}
                   domain: x ‚àà [0.0, 8.0], y ‚àà [-10.0, 10.0], z ‚àà [-3.1415927, 3.1415927]
                 topology: (Periodic, Periodic, Bounded)
        size (Nx, Ny, Nz): (32, 32, 16)
        halo (Hx, Hy, Hz): (1, 1, 1)
grid spacing (Œîx, Œîy, Œîz): (0.25f0, 0.625f0, 0.3926991f0)</code></pre><ul><li>A two-dimenisional, horizontally-periodic grid:</li></ul><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = RegularRectilinearGrid(size=(32, 32), extent=(2œÄ, 4œÄ), topology=(Periodic, Periodic, Flat))
RegularRectilinearGrid{Float64, Periodic, Periodic, Flat}
                   domain: x ‚àà [0.0, 6.283185307179586], y ‚àà [0.0, 12.566370614359172], z ‚àà [0.0, 0.0]
                 topology: (Periodic, Periodic, Flat)
        size (Nx, Ny, Nz): (32, 32, 1)
        halo (Hx, Hy, Hz): (1, 1, 0)
grid spacing (Œîx, Œîy, Œîz): (0.19634954084936207, 0.39269908169872414, 0.0)</code></pre><ul><li>A one-dimensional &quot;column&quot; grid:</li></ul><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = RegularRectilinearGrid(size=256, z=(-128, 0), topology=(Flat, Flat, Bounded))
RegularRectilinearGrid{Float64, Flat, Flat, Bounded}
                   domain: x ‚àà [0.0, 0.0], y ‚àà [0.0, 0.0], z ‚àà [-128.0, 0.0]
                 topology: (Flat, Flat, Bounded)
        size (Nx, Ny, Nz): (1, 1, 256)
        halo (Hx, Hy, Hz): (0, 0, 1)
grid spacing (Œîx, Œîy, Œîz): (0.0, 0.0, 0.5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Grids/regular_rectilinear_grid.jl#L37-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.VerticallyStretchedRectilinearGrid" href="#Oceananigans.Grids.VerticallyStretchedRectilinearGrid"><code>Oceananigans.Grids.VerticallyStretchedRectilinearGrid</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VerticallyStretchedRectilinearGrid([FT=Float64]; architecture=CPU(), size, z_faces,
                                    x = nothing, y = nothing,
                                    topology = (Periodic, Periodic, Bounded), halo = nothing)</code></pre><p>Create a horizontally-regular, <code>VerticallyStretchedRectilinearGrid</code> with <code>size = (Nx, Ny, Nz)</code> grid points and vertical cell interfaces <code>z_faces</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>size</code> (required): A tuple prescribing the number of grid points in non-<code>Flat</code> directions.                    <code>size</code> is a 3-tuple for 3D models, a 2-tuple for 2D models, and either a                    scalar or 1-tuple for 1D models.</p></li><li><p><code>topology</code>: A 3-tuple <code>(Tx, Ty, Tz)</code> specifying the topology of the domain.             <code>Tz</code> must be <code>Bounded</code> for <code>VerticallyStretchedRectilinearGrid</code>.             <code>Tx</code> and <code>Ty</code> specify whether the <code>x</code>- and <code>y</code>- directions are             <code>Periodic</code>, <code>Bounded</code>, or <code>Flat</code>. The topology <code>Flat</code> indicates that a model does             not vary in that directions so that derivatives and interpolation are zero.             The default is <code>topology=(Periodic, Periodic, Bounded)</code>.</p></li><li><p><code>architecture</code>: Specifies whether the array of vertical coordinates, interfaces, and spacings                 are stored on the CPU or GPU. Default: <code>architecture = CPU()</code>.</p></li><li><p><code>z_faces</code>: An array or function of vertical index <code>k</code> that specifies the location of cell faces       in the <code>z-</code>direction for indices <code>k=1</code> through <code>k=Nz+1</code>, where <code>Nz</code> is the       <code>size</code> of the stretched dimension.</p></li><li><p><code>x</code>, <code>y</code>: Each of <code>x, y</code> are 2-tuples that specify the end points of the domain           in their respect directions. Scalar values may be used in <code>Flat</code> directions.</p></li><li><p><code>halo</code>: A tuple of integers that specifies the size of the halo region of cells surrounding         the physical interior for each non-<code>Flat</code> direction.</p></li></ul><p>The physical extent of the domain can be specified via <code>x</code> and <code>y</code> keyword arguments indicating the left and right endpoints of each dimensions, e.g. <code>x=(-œÄ, œÄ)</code>.</p><p>A grid topology may be specified via a tuple assigning one of <code>Periodic</code>, <code>Bounded</code>, and <code>Flat</code> to each dimension. By default, a horizontally periodic grid topology <code>(Periodic, Periodic, Bounded)</code> is assumed.</p><p>Constants are stored using floating point values of type <code>FT</code>. By default this is <code>Float64</code>. Make sure to specify the desired <code>FT</code> if not using <code>Float64</code>.</p><p><strong>Grid properties</strong></p><ul><li><p><code>(Nx, Ny, Nz)::Int</code>: Number of physical points in the (x, y, z)-direction</p></li><li><p><code>(Hx, Hy, Hz)::Int</code>: Number of halo points in the (x, y, z)-direction</p></li><li><p><code>(Lx, Ly, Lz)::FT</code>: Physical extent of the grid in the (x, y, z)-direction</p></li><li><p><code>(Œîx, Œîy)::FT</code>: Grid spacing (distance between grid nodes) in the (x, y)-direction</p></li><li><p><code>Œîz·µÉ·µÉ·∂ú</code>: Grid spacing in the z-direction between cell faces.          Defined at cell centers in <code>z</code> and independent of cell location in (x, y).</p></li><li><p><code>Œîz·µÉ·µÉ·∂†</code>: Grid spacing in the z-direction between cell centers, and defined at cell faces in z.          Defined at cell faces in <code>z</code> and independent of cell location in (x, y).</p></li><li><p><code>(x·∂ú·µÉ·µÉ, y·µÉ·∂ú·µÉ, z·µÉ·µÉ·∂ú)</code>: (x, y, z) coordinates of cell centers.</p></li><li><p><code>(x·∂†·µÉ·µÉ, y·µÉ·∂†·µÉ, z·µÉ·µÉ·∂†)</code>: (x, y, z) coordinates of cell faces.</p></li></ul><p><strong>Example</strong></p><p>Generate a horizontally-periodic grid with cell interfaces stretched hyperbolically near the top:</p><pre><code class="language-julia hljs">using Oceananigans

œÉ = 1.1 # stretching factor
Nz = 24 # vertical resolution
Lz = 32 # depth (m)

hyperbolically_spaced_faces(k) = - Lz * (1 - tanh(œÉ * (k - 1) / Nz) / tanh(œÉ))

grid = VerticallyStretchedRectilinearGrid(size = (32, 32, Nz),
                                          x = (0, 64),
                                          y = (0, 64),
                                          z_faces = hyperbolically_spaced_faces)

# output
VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded}
                   domain: x ‚àà [0.0, 64.0], y ‚àà [0.0, 64.0], z ‚àà [-32.0, -0.0]
                 topology: (Periodic, Periodic, Bounded)
        size (Nx, Ny, Nz): (32, 32, 24)
        halo (Hx, Hy, Hz): (1, 1, 1)
grid spacing (Œîx, Œîy, Œîz): (2.0, 2.0, [min=0.6826950100338962, max=1.8309085743885056])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Grids/vertically_stretched_rectilinear_grid.jl#L38-L132">source</a></section></article><h2 id="Lagrangian-particle-tracking"><a class="docs-heading-anchor" href="#Lagrangian-particle-tracking">Lagrangian particle tracking</a><a id="Lagrangian-particle-tracking-1"></a><a class="docs-heading-anchor-permalink" href="#Lagrangian-particle-tracking" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.LagrangianParticleTracking.LagrangianParticles-Tuple{StructArrays.StructArray}" href="#Oceananigans.LagrangianParticleTracking.LagrangianParticles-Tuple{StructArrays.StructArray}"><code>Oceananigans.LagrangianParticleTracking.LagrangianParticles</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LagrangianParticles(particles::StructArray; restitution=1.0, tracked_fields::NamedTuple=NamedTuple(), dynamics=no_dynamics)</code></pre><p>Construct some <code>LagrangianParticles</code> that can be passed to a model. The <code>particles</code> should be a <code>StructArray</code> and can contain custom fields. The coefficient of restitution for particle-wall collisions is specified by <code>restitution</code>.</p><p>A number of <code>tracked_fields</code> may be passed in as a <code>NamedTuple</code> of fields. Each particle will track the value of each field. Each tracked field must have a corresponding particle property. So if <code>T</code> is a tracked field, then <code>T</code> must also be a custom particle property.</p><p><code>dynamics</code> is a function of <code>(lagrangian_particles, model, Œît)</code> that is called prior to advecting particles. <code>parameters</code> can be accessed inside the <code>dynamics</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/LagrangianParticleTracking/LagrangianParticleTracking.jl#L55-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.LagrangianParticleTracking.LagrangianParticles-Tuple{}" href="#Oceananigans.LagrangianParticleTracking.LagrangianParticles-Tuple{}"><code>Oceananigans.LagrangianParticleTracking.LagrangianParticles</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LagrangianParticles(; x, y, z, restitution=1.0, dynamics=no_dynamics, parameters=nothing)</code></pre><p>Construct some <code>LagrangianParticles</code> that can be passed to a model. The particles will have initial locations <code>x</code>, <code>y</code>, and <code>z</code>. The coefficient of restitution for particle-wall collisions is specified by <code>restitution</code>.</p><p><code>dynamics</code> is a function of <code>(lagrangian_particles, model, Œît)</code> that is called prior to advecting particles. <code>parameters</code> can be accessed inside the <code>dynamics</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/LagrangianParticleTracking/LagrangianParticleTracking.jl#L34-L42">source</a></section></article><h2 id="Logger"><a class="docs-heading-anchor" href="#Logger">Logger</a><a id="Logger-1"></a><a class="docs-heading-anchor-permalink" href="#Logger" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Logger.OceananigansLogger" href="#Oceananigans.Logger.OceananigansLogger"><code>Oceananigans.Logger.OceananigansLogger</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OceananigansLogger(stream::IO=stdout, level=Logging.Info; show_info_source=false)</code></pre><p>Based on Logging.SimpleLogger, it tries to log all messages in the following format:</p><pre><code class="nohighlight hljs">[yyyy/mm/dd HH:MM:SS.sss] log_level message [-@-&gt; source_file:line_number]</code></pre><p>where the source of the message between the square brackets is included only if <code>show_info_source=true</code> or if the message is not an info level message.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Logger.jl#L26-L35">source</a></section></article><h2 id="Models"><a class="docs-heading-anchor" href="#Models">Models</a><a id="Models-1"></a><a class="docs-heading-anchor-permalink" href="#Models" title="Permalink"></a></h2><h2 id="Output-writers"><a class="docs-heading-anchor" href="#Output-writers">Output writers</a><a id="Output-writers-1"></a><a class="docs-heading-anchor-permalink" href="#Output-writers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.JLD2OutputWriter" href="#Oceananigans.OutputWriters.JLD2OutputWriter"><code>Oceananigans.OutputWriters.JLD2OutputWriter</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">JLD2OutputWriter{I, T, O, IF, IN, KW} &lt;: AbstractOutputWriter</code></pre><p>An output writer for writing to JLD2 files.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/OutputWriters/jld2_output_writer.jl#L13-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.JLD2OutputWriter-Tuple{Any, Any}" href="#Oceananigans.OutputWriters.JLD2OutputWriter-Tuple{Any, Any}"><code>Oceananigans.OutputWriters.JLD2OutputWriter</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">JLD2OutputWriter(model, outputs; prefix, schedule,
                          dir = &quot;.&quot;,
                 field_slicer = FieldSlicer(),
                   array_type = Array{Float32},
                 max_filesize = Inf,
                        force = false,
                         init = noinit,
                    including = [:grid, :coriolis, :buoyancy, :closure],
                      verbose = false,
                         part = 1,
                      jld2_kw = Dict{Symbol, Any}())</code></pre><p>Construct a <code>JLD2OutputWriter</code> for an Oceananigans <code>model</code> that writes <code>label, output</code> pairs in <code>outputs</code> to a JLD2 file.</p><p>The argument <code>outputs</code> may be a <code>Dict</code> or <code>NamedTuple</code>. The keys of <code>outputs</code> are symbols or strings that &quot;name&quot; output data. The values of <code>outputs</code> are either <code>AbstractField</code>s, objects that are called with the signature <code>output(model)</code>, or <code>WindowedTimeAverage</code>s of <code>AbstractFields</code>s, functions, or callable objects.</p><p><strong>Keyword arguments</strong></p><pre><code class="nohighlight hljs">## Filenaming

- `prefix` (required): Descriptive filename prefixed to all output files.

- `dir`: Directory to save output to.
         Default: &quot;.&quot; (current working directory).

## Output frequency and time-averaging

- `schedule` (required): `AbstractSchedule` that determines when output is saved.

## Slicing and type conversion prior to output

- `field_slicer`: An object for slicing field output in ``(x, y, z)``, including omitting halos.
                  Has no effect on output that is not a field. `field_slicer = nothing` means
                  no slicing occurs, so that all field data, including halo regions, is saved.
                  Default: FieldSlicer(), which slices halo regions.

- `array_type`: The array type to which output arrays are converted to prior to saving.
                Default: Array{Float32}.

## File management

- `max_filesize`: The writer will stop writing to the output file once the file size exceeds `max_filesize`,
                  and write to a new one with a consistent naming scheme ending in `part1`, `part2`, etc.
                  Defaults to `Inf`.

- `force`: Remove existing files if their filenames conflict.
           Default: `false`.

## Output file metadata management

- `init`: A function of the form `init(file, model)` that runs when a JLD2 output file is initialized.
          Default: `noinit(args...) = nothing`.

- `including`: List of model properties to save with every file.
               Default: `[:grid, :coriolis, :buoyancy, :closure]`

## Miscellaneous keywords

- `verbose`: Log what the output writer is doing with statistics on compute/write times and file sizes.
             Default: `false`.

- `part`: The starting part number used if `max_filesize` is finite.
          Default: 1.

- `jld2_kw`: Dict of kwargs to be passed to `jldopen` when data is written.</code></pre><p><strong>Example</strong></p><p>Write out 3D fields for w and T and a horizontal average:</p><pre><code class="language-julia hljs">using Oceananigans, Oceananigans.OutputWriters, Oceananigans.Fields
using Oceananigans.Utils: hour, minute

model = NonhydrostaticModel(grid=RegularRectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)))
simulation = Simulation(model, Œît=12, stop_time=1hour)

function init_save_some_metadata!(file, model)
    file[&quot;author&quot;] = &quot;Chim Riggles&quot;
    file[&quot;parameters/coriolis_parameter&quot;] = 1e-4
    file[&quot;parameters/density&quot;] = 1027
    return nothing
end

T_avg =  AveragedField(model.tracers.T, dims=(1, 2))

# Note that model.velocities is NamedTuple
simulation.output_writers[:velocities] = JLD2OutputWriter(model, model.velocities,
                                                          prefix = &quot;some_data&quot;,
                                                          schedule = TimeInterval(20minute),
                                                          init = init_save_some_metadata!)

# output
JLD2OutputWriter scheduled on TimeInterval(20 minutes):
‚îú‚îÄ‚îÄ filepath: ./some_data.jld2
‚îú‚îÄ‚îÄ 3 outputs: (:u, :v, :w)
‚îú‚îÄ‚îÄ field slicer: FieldSlicer(:, :, :, with_halos=false)
‚îú‚îÄ‚îÄ array type: Array{Float32}
‚îú‚îÄ‚îÄ including: [:grid, :coriolis, :buoyancy, :closure]
‚îî‚îÄ‚îÄ max filesize: Inf YiB</code></pre><p>and a time- and horizontal-average of temperature <code>T</code> every 1 hour of simulation time to a file called <code>some_averaged_data.jld2</code></p><pre><code class="language-julia hljs">simulation.output_writers[:avg_T] = JLD2OutputWriter(model, (T=T_avg,),
                                                     prefix = &quot;some_averaged_data&quot;,
                                                     schedule = AveragedTimeInterval(20minute, window=5minute))

# output
JLD2OutputWriter scheduled on TimeInterval(20 minutes):
‚îú‚îÄ‚îÄ filepath: ./some_averaged_data.jld2
‚îú‚îÄ‚îÄ 1 outputs: (:T,) averaged on AveragedTimeInterval(window=5 minutes, stride=1, interval=20 minutes)
‚îú‚îÄ‚îÄ field slicer: FieldSlicer(:, :, :, with_halos=false)
‚îú‚îÄ‚îÄ array type: Array{Float32}
‚îú‚îÄ‚îÄ including: [:grid, :coriolis, :buoyancy, :closure]
‚îî‚îÄ‚îÄ max filesize: Inf YiB</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/OutputWriters/jld2_output_writer.jl#L35-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.NetCDFOutputWriter" href="#Oceananigans.OutputWriters.NetCDFOutputWriter"><code>Oceananigans.OutputWriters.NetCDFOutputWriter</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NetCDFOutputWriter{D, O, I, T, S} &lt;: AbstractOutputWriter</code></pre><p>An output writer for writing to NetCDF files.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/OutputWriters/netcdf_output_writer.jl#L114-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.NetCDFOutputWriter-Tuple{Any, Any}" href="#Oceananigans.OutputWriters.NetCDFOutputWriter-Tuple{Any, Any}"><code>Oceananigans.OutputWriters.NetCDFOutputWriter</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NetCDFOutputWriter(model, outputs; filepath, schedule
                               array_type = Array{Float32},
                             field_slicer = FieldSlicer(),
                        global_attributes = Dict(),
                        output_attributes = Dict(),
                               dimensions = Dict(),
                                     mode = nothing,
                              compression = 0,
                                  verbose = false)</code></pre><p>Construct a <code>NetCDFOutputWriter</code> that writes <code>(label, output)</code> pairs in <code>outputs</code> (which should be a <code>Dict</code>) to a NetCDF file, where <code>label</code> is a string that labels the output and <code>output</code> is either a <code>Field</code> (e.g. <code>model.velocities.u</code> or an <code>AveragedField</code>) or a function <code>f(model)</code> that returns something to be written to disk. Custom output requires the spatial <code>dimensions</code> (a <code>Dict</code>) to be manually specified (see examples).</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>filepath</code> (required): Filepath to save output to.</p></li><li><p><code>schedule</code> (required): <code>AbstractSchedule</code> that determines when output is saved.</p></li><li><p><code>array_type</code>: The array type to which output arrays are converted to prior to saving.               Default: Array{Float32}.</p></li><li><p><code>field_slicer</code>: An object for slicing field output in <span>$(x, y, z)$</span>, including omitting halos,                 which can be done with the keyword <code>with_halos</code>.                 Has no effect on output that is not a field. <code>field_slicer = nothing</code> means                 no slicing occurs, so that all field data, including halo regions, is saved.                 Default: <code>FieldSlicer()</code>, which slices halo regions.</p></li><li><p><code>global_attributes</code>: Dict of model properties to save with every file (deafult: <code>Dict()</code>)</p></li><li><p><code>output_attributes</code>: Dict of attributes to be saved with each field variable (reasonable                      defaults are provided for velocities, buoyancy, temperature, and salinity;                      otherwise <code>output_attributes</code> <em>must</em> be user-provided).</p></li><li><p><code>dimensions</code>: A <code>Dict</code> of dimension tuples to apply to outputs (required for function outputs)</p></li><li><p><code>mode</code>: &quot;a&quot; (for append) and &quot;c&quot; (for clobber or create). Default: &quot;c&quot;. See NCDatasets.jl         documentation for more information on the <code>mode</code> option.</p></li><li><p><code>compression</code>: Determines the compression level of data (0-9, default 0)</p></li></ul><p><strong>Examples</strong></p><p>Saving the u velocity field and temperature fields, the full 3D fields and surface 2D slices to separate NetCDF files:</p><pre><code class="language-julia hljs">using Oceananigans, Oceananigans.OutputWriters

grid = RegularRectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1));

model = NonhydrostaticModel(grid=grid);

simulation = Simulation(model, Œît=12, stop_time=3600);

fields = Dict(&quot;u&quot; =&gt; model.velocities.u, &quot;T&quot; =&gt; model.tracers.T);

simulation.output_writers[:field_writer] =
    NetCDFOutputWriter(model, fields, filepath=&quot;fields.nc&quot;, schedule=TimeInterval(60))

# output
NetCDFOutputWriter scheduled on TimeInterval(1 minute):
‚îú‚îÄ‚îÄ filepath: fields.nc
‚îú‚îÄ‚îÄ dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0)
‚îú‚îÄ‚îÄ 2 outputs: [&quot;T&quot;, &quot;u&quot;]
‚îú‚îÄ‚îÄ field slicer: FieldSlicer(:, :, :, with_halos=false)
‚îî‚îÄ‚îÄ array type: Array{Float32}</code></pre><pre><code class="language-julia hljs">simulation.output_writers[:surface_slice_writer] =
    NetCDFOutputWriter(model, fields, filepath=&quot;surface_xy_slice.nc&quot;,
                       schedule=TimeInterval(60), field_slicer=FieldSlicer(k=grid.Nz))

# output
NetCDFOutputWriter scheduled on TimeInterval(1 minute):
‚îú‚îÄ‚îÄ filepath: surface_xy_slice.nc
‚îú‚îÄ‚îÄ dimensions: zC(1), zF(1), xC(16), yF(16), xF(16), yC(16), time(0)
‚îú‚îÄ‚îÄ 2 outputs: [&quot;T&quot;, &quot;u&quot;]
‚îú‚îÄ‚îÄ field slicer: FieldSlicer(:, :, 16, with_halos=false)
‚îî‚îÄ‚îÄ array type: Array{Float32}</code></pre><pre><code class="language-julia hljs">simulation.output_writers[:averaged_profile_writer] =
    NetCDFOutputWriter(model, fields,
                       filepath = &quot;averaged_z_profile.nc&quot;,
                       schedule = AveragedTimeInterval(60, window=20),
                       field_slicer = FieldSlicer(i=1, j=1))

# output
NetCDFOutputWriter scheduled on TimeInterval(1 minute):
‚îú‚îÄ‚îÄ filepath: averaged_z_profile.nc
‚îú‚îÄ‚îÄ dimensions: zC(16), zF(17), xC(1), yF(1), xF(1), yC(1), time(0)
‚îú‚îÄ‚îÄ 2 outputs: [&quot;T&quot;, &quot;u&quot;] averaged on AveragedTimeInterval(window=20 seconds, stride=1, interval=1 minute)
‚îú‚îÄ‚îÄ field slicer: FieldSlicer(1, 1, :, with_halos=false)
‚îî‚îÄ‚îÄ array type: Array{Float32}</code></pre><p><code>NetCDFOutputWriter</code> also accepts output functions that write scalars and arrays to disk, provided that their <code>dimensions</code> are provided:</p><pre><code class="language-julia hljs">using Oceananigans, Oceananigans.OutputWriters

grid = RegularRectilinearGrid(size=(16, 16, 16), extent=(1, 2, 3));

model = NonhydrostaticModel(grid=grid);

simulation = Simulation(model, Œît=1.25, stop_iteration=3);

f(model) = model.clock.time^2; # scalar output

g(model) = model.clock.time .* exp.(znodes(Center, grid)); # vector/profile output

h(model) = model.clock.time .* (   sin.(xnodes(Center, grid, reshape=true)[:, :, 1])
                            .*     cos.(ynodes(Face, grid, reshape=true)[:, :, 1])); # xy slice output

outputs = Dict(&quot;scalar&quot; =&gt; f, &quot;profile&quot; =&gt; g, &quot;slice&quot; =&gt; h);

dims = Dict(&quot;scalar&quot; =&gt; (), &quot;profile&quot; =&gt; (&quot;zC&quot;,), &quot;slice&quot; =&gt; (&quot;xC&quot;, &quot;yC&quot;));

output_attributes = Dict(
    &quot;scalar&quot;  =&gt; Dict(&quot;longname&quot; =&gt; &quot;Some scalar&quot;, &quot;units&quot; =&gt; &quot;bananas&quot;),
    &quot;profile&quot; =&gt; Dict(&quot;longname&quot; =&gt; &quot;Some vertical profile&quot;, &quot;units&quot; =&gt; &quot;watermelons&quot;),
    &quot;slice&quot;   =&gt; Dict(&quot;longname&quot; =&gt; &quot;Some slice&quot;, &quot;units&quot; =&gt; &quot;mushrooms&quot;)
);

global_attributes = Dict(&quot;location&quot; =&gt; &quot;Bay of Fundy&quot;, &quot;onions&quot; =&gt; 7);

simulation.output_writers[:things] =
    NetCDFOutputWriter(model, outputs,
                       schedule=IterationInterval(1), filepath=&quot;things.nc&quot;, dimensions=dims, verbose=true,
                       global_attributes=global_attributes, output_attributes=output_attributes)

# output
NetCDFOutputWriter scheduled on IterationInterval(1):
‚îú‚îÄ‚îÄ filepath: things.nc
‚îú‚îÄ‚îÄ dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0)
‚îú‚îÄ‚îÄ 3 outputs: [&quot;profile&quot;, &quot;slice&quot;, &quot;scalar&quot;]
‚îú‚îÄ‚îÄ field slicer: FieldSlicer(:, :, :, with_halos=false)
‚îî‚îÄ‚îÄ array type: Array{Float32}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/OutputWriters/netcdf_output_writer.jl#L131-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.AveragedTimeInterval" href="#Oceananigans.OutputWriters.AveragedTimeInterval"><code>Oceananigans.OutputWriters.AveragedTimeInterval</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct AveragedTimeInterval &lt;: AbstractSchedule</code></pre><p>Container for parameters that configure and handle time-averaged output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/OutputWriters/windowed_time_average.jl#L9-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.AveragedTimeInterval-Tuple{Any}" href="#Oceananigans.OutputWriters.AveragedTimeInterval-Tuple{Any}"><code>Oceananigans.OutputWriters.AveragedTimeInterval</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AveragedTimeInterval(interval; window=interval, stride=1)</code></pre><p>Returns a <code>schedule</code> that specifies periodic time-averaging of output. The time <code>window</code> specifies the extent of the time-average, which reoccurs every <code>interval</code>.</p><p><code>output</code> is computed and accumulated into the average every <code>stride</code> iterations during the averaging window. For example, <code>stride=1</code> computs output every iteration, whereas <code>stride=2</code> computes output every other iteration. Time-averages with longer <code>stride</code>s are faster to compute, but less accurate.</p><p>The time-average of <span>$a$</span> is a left Riemann sum corresponding to</p><p><span>$‚ü®a‚ü© = 1/T \int_{t·µ¢-T}^T a \mathrm{d} t ,$</span></p><p>where <span>$‚ü®a‚ü©$</span> is the time-average of <span>$a$</span>, <span>$T$</span> is the time-window for averaging, and the <span>$t·µ¢$</span> are discrete times separated by the time <code>interval</code>. The <span>$t·µ¢$</span> specify both the end of the averaging window and the time at which output is written.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Oceananigans.OutputWriters: AveragedTimeInterval
using Oceananigans.Utils: year, years

schedule = AveragedTimeInterval(4years, window=1year)

# output
AveragedTimeInterval(window=1 year, stride=1, interval=4 years)</code></pre><p>An <code>AveragedTimeInterval</code> schedule directs an output writer to time-average its outputs before writing them to disk:</p><pre><code class="language-julia hljs">using Oceananigans
using Oceananigans.OutputWriters: JLD2OutputWriter
using Oceananigans.Utils: minutes

model = NonhydrostaticModel(grid=RegularRectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)))

simulation = Simulation(model, Œît=10minutes, stop_time=30years)

simulation.output_writers[:velocities] = JLD2OutputWriter(model, model.velocities,
                                                          prefix = &quot;averaged_velocity_data&quot;,
                                                          schedule = AveragedTimeInterval(4years, window=1year, stride=2))

# output
JLD2OutputWriter scheduled on TimeInterval(4 years):
‚îú‚îÄ‚îÄ filepath: ./averaged_velocity_data.jld2
‚îú‚îÄ‚îÄ 3 outputs: (:u, :v, :w) averaged on AveragedTimeInterval(window=1 year, stride=2, interval=4 years)
‚îú‚îÄ‚îÄ field slicer: FieldSlicer(:, :, :, with_halos=false)
‚îú‚îÄ‚îÄ array type: Array{Float32}
‚îú‚îÄ‚îÄ including: [:grid, :coriolis, :buoyancy, :closure]
‚îî‚îÄ‚îÄ max filesize: Inf YiB</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/OutputWriters/windowed_time_average.jl#L22-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.WindowedTimeAverage" href="#Oceananigans.OutputWriters.WindowedTimeAverage"><code>Oceananigans.OutputWriters.WindowedTimeAverage</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WindowedTimeAverage{OP, R, FS} &lt;: AbstractDiagnostic</code></pre><p>An object for computing &#39;windowed&#39; time averages, or moving time-averages of a <code>operand</code> over a specified <code>window</code>, collected on <code>interval</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/OutputWriters/windowed_time_average.jl#L96-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.WindowedTimeAverage" href="#Oceananigans.OutputWriters.WindowedTimeAverage"><code>Oceananigans.OutputWriters.WindowedTimeAverage</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WindowedTimeAverage(operand, model=nothing; schedule, field_slicer=FieldSlicer())</code></pre><p>Returns an object for computing running averages of <code>operand</code> over <code>schedule.window</code> and recurring on <code>schedule.interval</code>, where <code>schedule</code> is an <code>AveragedTimeInterval</code>. During the collection period, averages are computed every <code>schedule.stride</code> iteration.</p><p><code>operand</code> may be a <code>Oceananigans.Field</code> or a function that returns an array or scalar.</p><p>Calling <code>wta(model)</code> for <code>wta::WindowedTimeAverage</code> object returns <code>wta.result</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/OutputWriters/windowed_time_average.jl#L112-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.Checkpointer-Tuple{Any}" href="#Oceananigans.OutputWriters.Checkpointer-Tuple{Any}"><code>Oceananigans.OutputWriters.Checkpointer</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Checkpointer(model; schedule,
                    dir = &quot;.&quot;,
                 prefix = &quot;checkpoint&quot;,
                  force = false,
                verbose = false,
                cleanup = false,
             properties = [:architecture, :grid, :clock, :coriolis,
                           :buoyancy, :closure, :velocities, :tracers,
                           :timestepper, :particles]
            )</code></pre><p>Construct a <code>Checkpointer</code> that checkpoints the model to a JLD2 file on <code>schedule.</code> The <code>model.clock.iteration</code> is included in the filename to distinguish between multiple checkpoint files.</p><p>To restart or &quot;pickup&quot; a model from a checkpoint, specify <code>pickup=true</code> when calling <code>run!</code>, ensuring that the checkpoint file is the current working directory. See </p><pre><code class="language-julia hljs">help&gt; run!</code></pre><p>for more details.</p><p>Note that extra model <code>properties</code> can be safely specified, but removing crucial properties such as <code>:velocities</code> will make restoring from the checkpoint impossible.</p><p>The checkpointer attempts to serialize as much of the model to disk as possible, but functions or objects containing functions cannot be serialized at this time.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>schedule</code> (required): Schedule that determines when to checkpoint.</p></li><li><p><code>dir</code>: Directory to save output to. Default: &quot;.&quot; (current working directory).</p></li><li><p><code>prefix</code>: Descriptive filename prefixed to all output files. Default: &quot;checkpoint&quot;.</p></li><li><p><code>force</code>: Remove existing files if their filenames conflict. Default: <code>false</code>.</p></li><li><p><code>verbose</code>: Log what the output writer is doing with statistics on compute/write times            and file sizes. Default: <code>false</code>.</p></li><li><p><code>cleanup</code>: Previous checkpoint files will be deleted once a new checkpoint file is written.            Default: <code>false</code>.</p></li><li><p><code>properties</code>: List of model properties to checkpoint. Some are required.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/OutputWriters/checkpointer.jl#L16-L62">source</a></section></article><h2 id="Time-steppers"><a class="docs-heading-anchor" href="#Time-steppers">Time steppers</a><a id="Time-steppers-1"></a><a class="docs-heading-anchor-permalink" href="#Time-steppers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TimeSteppers.Clock" href="#Oceananigans.TimeSteppers.Clock"><code>Oceananigans.TimeSteppers.Clock</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Clock{T&lt;:Number}</code></pre><p>Keeps track of the current <code>time</code>, <code>iteration</code> number, and time-stepping <code>stage</code>. <code>stage</code> is updated only for multi-stage time-stepping methods. The <code>time::T</code> can be either a number or a <code>DateTime</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/TimeSteppers/clock.jl#L8-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TimeSteppers.Clock-Tuple{}" href="#Oceananigans.TimeSteppers.Clock-Tuple{}"><code>Oceananigans.TimeSteppers.Clock</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Clock(; time, iteration=0, stage=1)</code></pre><p>Returns a <code>Clock</code> initialized to the zeroth iteration and first time step stage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/TimeSteppers/clock.jl#L30-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper-Union{Tuple{IT}, Tuple{Any, Any, Any}, NTuple{4, Any}} where IT" href="#Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper-Union{Tuple{IT}, Tuple{Any, Any, Any}, NTuple{4, Any}} where IT"><code>Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">QuasiAdamsBashforth2TimeStepper(arch, grid, tracers, œá=0.1;
                                implicit_solver = nothing,
                                G‚Åø = TendencyFields(arch, grid, tracers),
                                G‚Åª = TendencyFields(arch, grid, tracers))</code></pre><p>Return an QuasiAdamsBashforth2TimeStepper object with tendency fields on <code>arch</code> and <code>grid</code> with AB2 parameter <code>œá</code>. The tendency fields can be specified via optional kwargs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/TimeSteppers/quasi_adams_bashforth_2.jl#L12-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TimeSteppers.RungeKutta3TimeStepper" href="#Oceananigans.TimeSteppers.RungeKutta3TimeStepper"><code>Oceananigans.TimeSteppers.RungeKutta3TimeStepper</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RungeKutta3TimeStepper{FT, TG} &lt;: AbstractTimeStepper</code></pre><p>Holds parameters and tendency fields for a low storage, third-order Runge-Kutta-Wray time-stepping scheme described by Le and Moin (1991).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/TimeSteppers/runge_kutta_3.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TimeSteppers.RungeKutta3TimeStepper-Union{Tuple{TG}, Tuple{TI}, Tuple{Any, Any, Any}} where {TI, TG}" href="#Oceananigans.TimeSteppers.RungeKutta3TimeStepper-Union{Tuple{TG}, Tuple{TI}, Tuple{Any, Any, Any}} where {TI, TG}"><code>Oceananigans.TimeSteppers.RungeKutta3TimeStepper</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RungeKutta3TimeStepper(arch, grid, tracers,
                       G‚Åø = TendencyFields(arch, grid, tracers),
                       G‚Åª = TendencyFields(arch, grid, tracers))</code></pre><p>Return an <code>RungeKutta3TimeStepper</code> object with tendency fields on <code>arch</code> and <code>grid</code>. The tendency fields can be specified via optional kwargs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/TimeSteppers/runge_kutta_3.jl#L20-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TimeSteppers.time_step!-Tuple{Oceananigans.AbstractModel{var&quot;#s993&quot;} where var&quot;#s993&quot;&lt;:QuasiAdamsBashforth2TimeStepper, Any}" href="#Oceananigans.TimeSteppers.time_step!-Tuple{Oceananigans.AbstractModel{var&quot;#s993&quot;} where var&quot;#s993&quot;&lt;:QuasiAdamsBashforth2TimeStepper, Any}"><code>Oceananigans.TimeSteppers.time_step!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">time_step!(model::AbstractModel{&lt;:QuasiAdamsBashforth2TimeStepper}, Œît; euler=false)</code></pre><p>Step forward <code>model</code> one time step <code>Œît</code> with a 2nd-order Adams-Bashforth method and pressure-correction substep. Setting <code>euler=true</code> will take a forward Euler time step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/TimeSteppers/quasi_adams_bashforth_2.jl#L38-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TimeSteppers.time_step!-Tuple{Oceananigans.AbstractModel{var&quot;#s996&quot;} where var&quot;#s996&quot;&lt;:RungeKutta3TimeStepper, Any}" href="#Oceananigans.TimeSteppers.time_step!-Tuple{Oceananigans.AbstractModel{var&quot;#s996&quot;} where var&quot;#s996&quot;&lt;:RungeKutta3TimeStepper, Any}"><code>Oceananigans.TimeSteppers.time_step!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">time_step!(model::AbstractModel{&lt;:RungeKutta3TimeStepper}, Œît; euler=false)</code></pre><p>Step forward <code>model</code> one time step <code>Œît</code> with a 3rd-order Runge-Kutta method. The 3rd-order Runge-Kutta method takes three intermediate substep stages to achieve a single timestep. A pressure correction step is applied at each intermediate stage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/TimeSteppers/runge_kutta_3.jl#L53-L60">source</a></section></article><h2 id="Simulations"><a class="docs-heading-anchor" href="#Simulations">Simulations</a><a id="Simulations-1"></a><a class="docs-heading-anchor-permalink" href="#Simulations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Simulations.TimeStepWizard" href="#Oceananigans.Simulations.TimeStepWizard"><code>Oceananigans.Simulations.TimeStepWizard</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TimeStepWizard(cfl=0.1, max_change=2.0, min_change=0.5, max_Œît=Inf, min_Œît=0.0, Œît=0.01)</code></pre><p>A type for calculating adaptive time steps based on capping the CFL number at <code>cfl</code>.</p><p>On calling <code>update_Œît!(wizard, model)</code>, the <code>TimeStepWizard</code> computes a time-step such that <span>$cfl = max(u/Œîx, v/Œîy, w/Œîz) Œît$</span>, where <span>$max(u/Œîx, v/Œîy, w/Œîz)$</span> is the maximum ratio between model velocity and along-velocity grid spacing anywhere on the model grid. The new <code>Œît</code> is constrained to change by a multiplicative factor no more than <code>max_change</code> or no less than <code>min_change</code> from the previous <code>Œît</code>, and to be no greater in absolute magnitude than <code>max_Œît</code> and no less than <code>min_Œît</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Simulations/time_step_wizard.jl#L15-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Simulations.Simulation-Tuple{Any}" href="#Oceananigans.Simulations.Simulation-Tuple{Any}"><code>Oceananigans.Simulations.Simulation</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Simulation(model; Œît,
           stop_criteria = Function[iteration_limit_exceeded, stop_time_exceeded, wall_time_limit_exceeded],
           stop_iteration = Inf,
           stop_time = Inf,
           wall_time_limit = Inf,
           diagnostics = OrderedDict{Symbol, AbstractDiagnostic}(),
           output_writers = OrderedDict{Symbol, AbstractOutputWriter}(),
           callback = OrderedDict{Symbol, Callback}(),
           progress = default_progress,
           iteration_interval = 1,
           parameters = nothing)</code></pre><p>Construct a <code>Simulation</code> for a <code>model</code> with time step <code>Œît</code>. Keyword arguments =================     - <code>Œît</code>: Required keyword argument specifying the simulation time step. Can be a <code>Number</code>       for constant time steps or a <code>TimeStepWizard</code> for adaptive time-stepping.     - <code>stop_criteria</code>: A list of functions or callable objects (each taking a single argument,       the <code>simulation</code>). If any of the functions return <code>true</code> when the stop criteria is       evaluated the simulation will stop.     - <code>stop_iteration</code>: Stop the simulation after this many iterations.     - <code>stop_time</code>: Stop the simulation once this much model clock time has passed.     - <code>wall_time_limit</code>: Stop the simulation if it&#39;s been running for longer than this many        seconds of wall clock time.     - <code>progress</code>: A function with a single argument, the <code>simulation</code>. Will be called every       <code>iteration_interval</code> iterations. Useful for logging simulation health.     - <code>iteration_interval</code>: How often to update the time step, check stop criteria, and call       <code>progress</code> function (in number of iterations).     - <code>parameters</code>: Parameters that can be accessed in the <code>progress</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Simulations/simulation.jl#L21-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Simulations.run!-Tuple{Any}" href="#Oceananigans.Simulations.run!-Tuple{Any}"><code>Oceananigans.Simulations.run!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">run!(simulation; pickup=false)</code></pre><p>Run a <code>simulation</code> until one of <code>simulation.stop_criteria</code> evaluates <code>true</code>. The simulation will then stop.</p><p><strong>Picking simulations up from a checkpoint</strong></p><p>Simulations are &quot;picked up&quot; from a checkpoint if <code>pickup</code> is either <code>true</code>, a <code>String</code>, or an <code>Integer</code> greater than 0.</p><p>Picking up a simulation sets field and tendency data to the specified checkpoint, leaving all other model properties unchanged.</p><p>Possible values for <code>pickup</code> are:</p><pre><code class="nohighlight hljs">* `pickup=true` picks a simulation up from the latest checkpoint associated with
  the `Checkpointer` in `simulation.output_writers`.

* `pickup=iteration::Int` picks a simulation up from the checkpointed file associated
   with `iteration` and the `Checkpointer` in `simulation.output_writers`.

* `pickup=filepath::String` picks a simulation up from checkpointer data in `filepath`.</code></pre><p>Note that <code>pickup=true</code> and <code>pickup=iteration</code> fails if <code>simulation.output_writers</code> contains more than one checkpointer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Simulations/run.jl#L98-L124">source</a></section></article><h2 id="Tubrulence-closures"><a class="docs-heading-anchor" href="#Tubrulence-closures">Tubrulence closures</a><a id="Tubrulence-closures-1"></a><a class="docs-heading-anchor-permalink" href="#Tubrulence-closures" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.‚àá_dot_q·∂ú-Tuple{Any, Any, Any, Any, Oceananigans.TurbulenceClosures.AbstractTurbulenceClosure, Any, Any, Vararg{Any, N} where N}" href="#Oceananigans.TurbulenceClosures.‚àá_dot_q·∂ú-Tuple{Any, Any, Any, Any, Oceananigans.TurbulenceClosures.AbstractTurbulenceClosure, Any, Any, Vararg{Any, N} where N}"><code>Oceananigans.TurbulenceClosures.‚àá_dot_q·∂ú</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">‚àá_dot_q·∂ú(i, j, k, grid, clock, closure::AbstractTurbulenceClosure, c, ::Val{tracer_index}, args...)</code></pre><p>Calculates the divergence of the diffusive flux <code>q·∂ú</code> for a tracer <code>c</code> via</p><pre><code class="nohighlight hljs">1/V * [Œ¥x·∂ú·µÉ·µÉ(Ax * diffusive_flux_x) + Œ¥y·µÉ·∂ú·µÉ(Ay * diffusive_flux_y) + Œ¥z·µÉ·µÉ·∂ú(Az * diffusive_flux_z)]</code></pre><p>which will end up at the location <code>ccc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/TurbulenceClosures/diffusion_operators.jl#L36-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.AnisotropicBiharmonicDiffusivity" href="#Oceananigans.TurbulenceClosures.AnisotropicBiharmonicDiffusivity"><code>Oceananigans.TurbulenceClosures.AnisotropicBiharmonicDiffusivity</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AnisotropicBiharmonicDiffusivity{FT, KH, KZ}</code></pre><p>Parameters for anisotropic biharmonic diffusivity models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_biharmonic_diffusivity.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.AnisotropicBiharmonicDiffusivity" href="#Oceananigans.TurbulenceClosures.AnisotropicBiharmonicDiffusivity"><code>Oceananigans.TurbulenceClosures.AnisotropicBiharmonicDiffusivity</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AnisotropicBiharmonicDiffusivity([FT=Float64;] ŒΩx=0, ŒΩy=0, ŒΩz=0, Œ∫x=0, Œ∫y=0, Œ∫z=0, ŒΩh=nothing, Œ∫h=nothing)</code></pre><p>Returns parameters for a fourth-order, anisotropic biharmonic diffusivity closure with constant x-, y, and z-direction biharmonic viscosities <code>ŒΩx</code>, <code>ŒΩy</code>, and <code>ŒΩz</code>, and constant x-, y, and z-direction biharmonic diffusivities <code>Œ∫x</code>, <code>Œ∫y</code>, and <code>Œ∫z</code>, <code>Œ∫x</code>, <code>Œ∫y</code>, and <code>Œ∫z</code> may be <code>NamedTuple</code>s with fields corresponding to each tracer, or a single number to be a applied to all tracers.</p><p>If <code>ŒΩh</code> or <code>Œ∫h</code> are provided, then <code>ŒΩx = ŒΩy = ŒΩh</code> or <code>Œ∫x = Œ∫y = Œ∫h</code>.</p><p>The tracer flux divergence associated with an anisotropic biharmonic diffusivity is, for example</p><p class="math-container">\[    ‚àÇ·µ¢ Œ∫·µ¢‚±º ‚àÇ‚±ºc = - [Œ∫x ‚àÇ‚Å¥x + Œ∫y ‚àÇ‚Å¥y + Œ∫z ‚àÇ‚Å¥z] c\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_biharmonic_diffusivity.jl#L17-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.SmagorinskyLilly-Union{Tuple{}, Tuple{Any}, Tuple{TD}} where TD" href="#Oceananigans.TurbulenceClosures.SmagorinskyLilly-Union{Tuple{}, Tuple{Any}, Tuple{TD}} where TD"><code>Oceananigans.TurbulenceClosures.SmagorinskyLilly</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SmagorinskyLilly([FT=Float64;] C=0.16, Pr=1, ŒΩ=0, Œ∫=0,
                               time_discretization=ExplicitTimeDiscretization())</code></pre><p>Return a <code>SmagorinskyLilly</code> type associated with the turbulence closure proposed by Lilly (1962) and Smagorinsky (1958, 1963), which has an eddy viscosity of the form</p><pre><code class="nohighlight hljs">`ŒΩ‚Çë = (C * Œî·∂†)¬≤ * ‚àö(2Œ£¬≤) * ‚àö(1 - Cb * N¬≤ / Œ£¬≤) + ŒΩ`,</code></pre><p>and an eddy diffusivity of the form</p><pre><code class="nohighlight hljs">`Œ∫‚Çë = (ŒΩ‚Çë - ŒΩ) / Pr + Œ∫`</code></pre><p>where <code>Œî·∂†</code> is the filter width, <code>Œ£¬≤ = Œ£·µ¢‚±ºŒ£·µ¢‚±º</code> is the double dot product of the strain tensor <code>Œ£·µ¢‚±º</code>, <code>Pr</code> is the turbulent Prandtl number, and <code>N¬≤</code> is the total buoyancy gradient, and <code>Cb</code> is a constant the multiplies the Richardson number modification to the eddy viscosity.</p><p><strong>Keyword arguments</strong></p><pre><code class="nohighlight hljs">- `C`  : Smagorinsky constant. Default value is 0.16 as obtained by Lilly (1966).
- `Cb` : Buoyancy term multipler based on Lilly (1962) (`Cb = 0` turns it off, `Cb ‚â† 0` turns it on.
         Typically, and according to the original work by Lilly (1962), `Cb=1/Pr`.)
- `Pr` : Turbulent Prandtl numbers for each tracer. Either a constant applied to every
         tracer, or a `NamedTuple` with fields for each tracer individually.
- `ŒΩ`  : Constant background viscosity for momentum
- `Œ∫`  : Constant background diffusivity for tracer. Can either be a single number
         applied to all tracers, or `NamedTuple` of diffusivities corresponding to each
         tracer.
- `time_discretization` : Either `ExplicitTimeDiscretization()` or `VerticallyImplicitTimeDiscretization()`, 
                          which integrates the terms involving only z-derivatives in the
                          viscous and diffusive fluxes with an implicit time discretization.</code></pre><p><strong>References</strong></p><p>Smagorinsky, J. &quot;On the numerical integration of the primitive equations of motion for     baroclinic flow in a closed region.&quot; Monthly Weather Review (1958)</p><p>Lilly, D. K. &quot;On the numerical simulation of buoyant convection.&quot; Tellus (1962)</p><p>Smagorinsky, J. &quot;General circulation experiments with the primitive equations: I.     The basic experiment.&quot; Monthly weather review (1963)</p><p>Lilly, D. K. &quot;The representation of small-scale turbulence in numerical simulation experiments.&quot;      NCAR Manuscript No. 281, 0, 1966.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl#L20-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.IsotropicDiffusivity-Union{Tuple{}, Tuple{Any}, Tuple{TD}} where TD" href="#Oceananigans.TurbulenceClosures.IsotropicDiffusivity-Union{Tuple{}, Tuple{Any}, Tuple{TD}} where TD"><code>Oceananigans.TurbulenceClosures.IsotropicDiffusivity</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">IsotropicDiffusivity([FT=Float64;] ŒΩ=0, Œ∫=0, time_discretization = ExplicitTimeDiscretization())</code></pre><p>Returns parameters for an isotropic diffusivity model with viscosity <code>ŒΩ</code> and thermal diffusivities <code>Œ∫</code> for each tracer field in <code>tracers</code> <code>ŒΩ</code> and the fields of <code>Œ∫</code> may be constants, arrays, fields, or functions of <code>(x, y, z, t)</code>.</p><p><code>Œ∫</code> may be a <code>NamedTuple</code> with fields corresponding to each tracer, or a single number to be a applied to all tracers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/TurbulenceClosures/turbulence_closure_implementations/isotropic_diffusivity.jl#L12-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.AnisotropicDiffusivity" href="#Oceananigans.TurbulenceClosures.AnisotropicDiffusivity"><code>Oceananigans.TurbulenceClosures.AnisotropicDiffusivity</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AnisotropicDiffusivity{NX, NY, NZ, KX, KY, KZ}</code></pre><p>Parameters for anisotropic diffusivity models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_diffusivity.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.AnisotropicDiffusivity-Union{Tuple{}, Tuple{Any}, Tuple{TD}} where TD" href="#Oceananigans.TurbulenceClosures.AnisotropicDiffusivity-Union{Tuple{}, Tuple{Any}, Tuple{TD}} where TD"><code>Oceananigans.TurbulenceClosures.AnisotropicDiffusivity</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AnisotropicDiffusivity(([FT=Float64;] ŒΩx=0, ŒΩy=0, ŒΩz=0, Œ∫x=0, Œ∫y=0, Œ∫z=0, ŒΩh=nothing, Œ∫h=nothing,
                                time_discretization = ExplicitTimeDiscretization())</code></pre><p>Returns parameters for a closure with a diagonal diffusivity tensor with heterogeneous &#39;anisotropic&#39; components labeled by <code>x</code>, <code>y</code>, <code>z</code>. Each component may be a number or function. The tracer diffusivities <code>Œ∫x</code>, <code>Œ∫y</code>, and <code>Œ∫z</code> may be <code>NamedTuple</code>s with fields corresponding to each tracer, or a single number or function to be a applied to all tracers.</p><p>If <code>ŒΩh</code> or <code>Œ∫h</code> are provided, then <code>ŒΩx = ŒΩy = ŒΩh</code>, and <code>Œ∫x = Œ∫y = Œ∫h</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_diffusivity.jl#L23-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation" href="#Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation"><code>Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AnisotropicMinimumDissipation{FT} &lt;: AbstractTurbulenceClosure</code></pre><p>Parameters for the &quot;anisotropic minimum dissipation&quot; turbulence closure for large eddy simulation proposed originally by <a href="../../references/#Rozema15">Wybe Rozema, Hyun J. Bae, Parviz Moin, Roel Verstappen (2015)</a> and <a href="../../references/#Abkar16">Mahdi Abkar, Hyun J. Bae, Parviz Moin (2016)</a>, and then modified by <a href="../../references/#Verstappen18">Roel Verstappen (2018)</a>, and finally described and validated for by <a href="../../references/#Vreugdenhil18">Catherine A. Vreugdenhil, John R. Taylor (2018)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation-Union{Tuple{}, Tuple{Any}, Tuple{TD}} where TD" href="#Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation-Union{Tuple{}, Tuple{Any}, Tuple{TD}} where TD"><code>Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AnisotropicMinimumDissipation([FT=Float64;] C=1/12, CŒΩ=nothing, CŒ∫=nothing,
                                            Cb=nothing, ŒΩ=0, Œ∫=0,
                                            time_discretization=ExplicitTimeDiscretization())</code></pre><p>Returns parameters of type <code>FT</code> for the <code>AnisotropicMinimumDissipation</code> turbulence closure.</p><p><strong>Keyword arguments</strong></p><pre><code class="nohighlight hljs">- `C` : PoincareÃÅ constant for both eddy viscosity and eddy diffusivities. `C` is overridden
        for eddy viscosity or eddy diffusivity if `CŒΩ` or `CŒ∫` are set, respecitvely.

- `CŒΩ` : PoincareÃÅ constant for momentum eddy viscosity.

- `CŒ∫` : PoincareÃÅ constant for tracer eddy diffusivities. If one number or function, the same
         number or function is applied to all tracers. If a `NamedTuple`, it must possess
         a field specifying the PoncareÃÅ constant for every tracer.

- `Cb` : Buoyancy modification multiplier (`Cb = nothing` turns it off, `Cb = 1` was used by [Abkar16](@cite)).
         *Note*: that we _do not_ subtract the horizontally-average component before computing this
         buoyancy modification term. This implementation differs from [Abkar16](@cite)&#39;s proposal
         and the impact of this approximation has not been tested or validated.

- `ŒΩ` : Constant background viscosity for momentum.

- `Œ∫` : Constant background diffusivity for tracer. If a single number, the same background
        diffusivity is applied to all tracers. If a `NamedTuple`, it must possess a field
        specifying a background diffusivity for every tracer.

- `time_discretization` : Either `ExplicitTimeDiscretization()` or `VerticallyImplicitTimeDiscretization()`, 
                          which integrates the terms involving only z-derivatives in the
                          viscous and diffusive fluxes with an implicit time discretization.</code></pre><p>By default: <code>C = CŒΩ = CŒ∫</code> = 1/12, which is appropriate for a finite-volume method employing a second-order advection scheme, <code>Cb = nothing</code>, which terms off the buoyancy modification term.</p><p><code>CŒΩ</code> or <code>CŒ∫</code> may be constant numbers, or functions of <code>x, y, z</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; pretty_diffusive_closure = AnisotropicMinimumDissipation(C=1/2)
AnisotropicMinimumDissipation{Float64} turbulence closure with:
           PoincareÃÅ constant for momentum eddy viscosity CŒΩ: 0.5
    PoincareÃÅ constant for tracer(s) eddy diffusivit(ies) CŒ∫: 0.5
                        Buoyancy modification multiplier Cb: nothing
                Background diffusivit(ies) for tracer(s), Œ∫: 0.0
             Background kinematic viscosity for momentum, ŒΩ: 0.0

julia&gt; const Œîz = 0.5; # grid resolution at surface

julia&gt; surface_enhanced_tracer_C(x, y, z) = 1/12 * (1 + exp((z + Œîz/2) / 8Œîz))
surface_enhanced_tracer_C (generic function with 1 method)

julia&gt; fancy_closure = AnisotropicMinimumDissipation(CŒ∫=surface_enhanced_tracer_C)
AnisotropicMinimumDissipation{Float64} turbulence closure with:
           PoincareÃÅ constant for momentum eddy viscosity CŒΩ: 0.08333333333333333
    PoincareÃÅ constant for tracer(s) eddy diffusivit(ies) CŒ∫: surface_enhanced_tracer_C
                        Buoyancy modification multiplier Cb: nothing
                Background diffusivit(ies) for tracer(s), Œ∫: 0.0
             Background kinematic viscosity for momentum, ŒΩ: 0.0

julia&gt; tracer_specific_closure = AnisotropicMinimumDissipation(CŒ∫=(c‚ÇÅ=1/12, c‚ÇÇ=1/6))
AnisotropicMinimumDissipation{Float64} turbulence closure with:
           PoincareÃÅ constant for momentum eddy viscosity CŒΩ: 0.08333333333333333
    PoincareÃÅ constant for tracer(s) eddy diffusivit(ies) CŒ∫: (c‚ÇÅ = 0.08333333333333333, c‚ÇÇ = 0.16666666666666666)
                        Buoyancy modification multiplier Cb: nothing
                Background diffusivit(ies) for tracer(s), Œ∫: 0.0
             Background kinematic viscosity for momentum, ŒΩ: 0.0</code></pre><p><strong>References</strong></p><p>Vreugdenhil C., and Taylor J. (2018), &quot;Large-eddy simulations of stratified plane Couette     flow using the anisotropic minimum-dissipation model&quot;, Physics of Fluids 30, 085104.</p><p>Verstappen, R. (2018), &quot;How much eddy dissipation is needed to counterbalance the nonlinear     production of small, unresolved scales in a large-eddy simulation of turbulence?&quot;,     Computers &amp; Fluids 176, pp. 276-284.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L34-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.TwoDimensionalLeith" href="#Oceananigans.TurbulenceClosures.TwoDimensionalLeith"><code>Oceananigans.TurbulenceClosures.TwoDimensionalLeith</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TwoDimensionalLeith([FT=Float64;] C=0.3, C_Redi=1, C_GM=1)</code></pre><p>Return a <code>TwoDimensionalLeith</code> type associated with the turbulence closure proposed by Leith (1965) and Fox-Kemper &amp; Menemenlis (2008) which has an eddy viscosity of the form</p><pre><code class="nohighlight hljs">`ŒΩ‚Çë = (C * Œî·∂†)¬≥ * ‚àö(|‚àáh Œ∂|¬≤ + |‚àáh ‚àÇz w|¬≤)`</code></pre><p>and an eddy diffusivity of the form...</p><p>where <code>Œî·∂†</code> is the filter width, <code>Œ∂ = ‚àÇx v - ‚àÇy u</code> is the vertical vorticity, and <code>C</code> is a model constant.</p><p><strong>Keyword arguments</strong></p><pre><code class="nohighlight hljs">- `C`      : Model constant
- `C_Redi` : Coefficient for down-gradient tracer diffusivity for each tracer.
             Either a constant applied to every tracer, or a `NamedTuple` with fields
             for each tracer individually.
- `C_GM`   : Coefficient for down-gradient tracer diffusivity for each tracer.
             Either a constant applied to every tracer, or a `NamedTuple` with fields
             for each tracer individually.</code></pre><p><strong>References</strong></p><p>Leith, C. E. (1968). &quot;Diffusion Approximation for Two‚ÄêDimensional Turbulence&quot;, The Physics of     Fluids 11, 671. doi: 10.1063/1.1691968</p><p>Fox‚ÄêKemper, B., &amp; D. Menemenlis (2008), &quot;Can large eddy simulation techniques improve mesoscale rich     ocean models?&quot;, in Ocean Modeling in an Eddying Regime, Geophys. Monogr. Ser., vol. 177, pp. 319‚Äì337.     doi: 10.1029/177GM19</p><p>Pearson, B. et al. (2017) , &quot;Evaluation of scale-aware subgrid mesoscale eddy models in a global eddy     rich model&quot;, Ocean Modelling 115, 42-58. doi: 10.1016/j.ocemod.2017.05.007</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl#L19-L53">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.prettytime-Tuple{Any}" href="#Oceananigans.Utils.prettytime-Tuple{Any}"><code>Oceananigans.Utils.prettytime</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prettytime(t)</code></pre><p>Convert a floating point value <code>t</code> representing an amount of time in seconds to a more human-friendly formatted string with three decimal places. Depending on the value of <code>t</code> the string will be formatted to show <code>t</code> in nanoseconds (ns), microseconds (Œºs), milliseconds (ms), seconds, minutes, hours, days, or years.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Utils/pretty_time.jl#L8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.pretty_filesize" href="#Oceananigans.Utils.pretty_filesize"><code>Oceananigans.Utils.pretty_filesize</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pretty_filesize(s, suffix=&quot;B&quot;)</code></pre><p>Convert a floating point value <code>s</code> representing a file size to a more human-friendly formatted string with one decimal places with a <code>suffix</code> defaulting to &quot;B&quot;. Depending on the value of <code>s</code> the string will be formatted to show <code>s</code> using an SI prefix from bytes, kiB (1024 bytes), MiB (1024¬≤ bytes), and so on up to YiB (1024‚Å∏ bytes).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Utils/pretty_filesize.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.cell_advection_timescale-NTuple{4, Any}" href="#Oceananigans.Utils.cell_advection_timescale-NTuple{4, Any}"><code>Oceananigans.Utils.cell_advection_timescale</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Returns the time-scale for advection on a regular grid across a single grid cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Utils/cell_advection_timescale.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.with_tracers-Tuple{Any, NamedTuple, Any}" href="#Oceananigans.Utils.with_tracers-Tuple{Any, NamedTuple, Any}"><code>Oceananigans.Utils.with_tracers</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">with_tracers(tracer_names, initial_tuple, tracer_default)</code></pre><p>Create a tuple corresponding to the solution variables <code>u</code>, <code>v</code>, <code>w</code>, and <code>tracer_names</code>. <code>initial_tuple</code> is a <code>NamedTuple</code> that at least has fields <code>u</code>, <code>v</code>, and <code>w</code>, and may have some fields corresponding to the names in <code>tracer_names</code>. <code>tracer_default</code> is a function that produces a default tuple value for each tracer if not included in <code>initial_tuple</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/Utils/with_tracers.jl#L1-L9">source</a></section></article><h2 id="Abstract-operations"><a class="docs-heading-anchor" href="#Abstract-operations">Abstract operations</a><a id="Abstract-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-operations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.@at-Tuple{Any, Any}" href="#Oceananigans.AbstractOperations.@at-Tuple{Any, Any}"><code>Oceananigans.AbstractOperations.@at</code></a> ‚Äî <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@at location abstract_operation</code></pre><p>Modify the <code>abstract_operation</code> so that it returns values at <code>location</code>, where <code>location</code> is a 3-tuple of <code>Face</code>s and <code>Center</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/AbstractOperations/at.jl#L36-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.@binary-Tuple" href="#Oceananigans.AbstractOperations.@binary-Tuple"><code>Oceananigans.AbstractOperations.@binary</code></a> ‚Äî <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@binary op1 op2 op3...</code></pre><p>Turn each binary function in the list <code>(op1, op2, op3...)</code> into a binary operator on <code>Oceananigans.Fields</code> for use in <code>AbstractOperations</code>.</p><p>Note: a binary function is a function with two arguments: for example, <code>+(x, y)</code> is a binary function.</p><p>Also note: a binary function in <code>Base</code> must be imported to be extended: use <code>import Base: op; @binary op</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans, Oceananigans.AbstractOperations

julia&gt; using Oceananigans.AbstractOperations: BinaryOperation, AbstractGridMetric, choose_location

julia&gt; plus_or_times(x, y) = x &lt; 0 ? x + y : x * y
plus_or_times (generic function with 1 method)

julia&gt; @binary plus_or_times
Set{Any} with 6 elements:
  :+
  :/
  :^
  :-
  :*
  :plus_or_times

julia&gt; c, d = (Field(Center, Center, Center, CPU(), RegularRectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))) for i = 1:2);

julia&gt; plus_or_times(c, d)
BinaryOperation at (Center, Center, Center)
‚îú‚îÄ‚îÄ grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1)
‚îÇ   ‚îî‚îÄ‚îÄ domain: x ‚àà [0.0, 1.0], y ‚àà [0.0, 1.0], z ‚àà [-1.0, 0.0]
‚îî‚îÄ‚îÄ tree:
    plus_or_times at (Center, Center, Center)
 ¬†¬† ‚îú‚îÄ‚îÄ Field located at (Center, Center, Center)
 ¬†¬† ‚îî‚îÄ‚îÄ Field located at (Center, Center, Center)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/AbstractOperations/binary_operations.jl#L130-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.‚àÇx-Tuple{Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}}" href="#Oceananigans.AbstractOperations.‚àÇx-Tuple{Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}}"><code>Oceananigans.AbstractOperations.‚àÇx</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Return the x-derivative function acting at (<code>X</code>, <code>Y</code>, <code>Any</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/AbstractOperations/derivatives.jl#L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.‚àÇx-Union{Tuple{Oceananigans.Fields.AbstractField{X, Y, Z, A, G, T, N} where {A&lt;:Union{Nothing, Oceananigans.Architectures.AbstractArchitecture}, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}, Tuple{Z}, Tuple{Y}, Tuple{X}} where {X, Y, Z}" href="#Oceananigans.AbstractOperations.‚àÇx-Union{Tuple{Oceananigans.Fields.AbstractField{X, Y, Z, A, G, T, N} where {A&lt;:Union{Nothing, Oceananigans.Architectures.AbstractArchitecture}, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}, Tuple{Z}, Tuple{Y}, Tuple{X}} where {X, Y, Z}"><code>Oceananigans.AbstractOperations.‚àÇx</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">‚àÇx(a::AbstractField)</code></pre><p>Return an abstract representation of a x-derivative acting on <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/AbstractOperations/derivatives.jl#L87-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.‚àÇx-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{Tuple, Oceananigans.Fields.AbstractField{X, Y, Z, A, G, T, N} where {A&lt;:Union{Nothing, Oceananigans.Architectures.AbstractArchitecture}, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}} where {X, Y, Z}" href="#Oceananigans.AbstractOperations.‚àÇx-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{Tuple, Oceananigans.Fields.AbstractField{X, Y, Z, A, G, T, N} where {A&lt;:Union{Nothing, Oceananigans.Architectures.AbstractArchitecture}, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}} where {X, Y, Z}"><code>Oceananigans.AbstractOperations.‚àÇx</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">‚àÇx(L::Tuple, a::AbstractField)</code></pre><p>Return an abstract representation of an x-derivative acting on <code>a</code> followed by interpolation to <code>L</code>, where <code>L</code> is a 3-tuple of <code>Face</code>s and <code>Center</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/AbstractOperations/derivatives.jl#L59-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.‚àÇy-Tuple{Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}}" href="#Oceananigans.AbstractOperations.‚àÇy-Tuple{Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}}"><code>Oceananigans.AbstractOperations.‚àÇy</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Return the y-derivative function acting at (<code>X</code>, <code>Y</code>, <code>Any</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/AbstractOperations/derivatives.jl#L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.‚àÇy-Union{Tuple{Oceananigans.Fields.AbstractField{X, Y, Z, A, G, T, N} where {A&lt;:Union{Nothing, Oceananigans.Architectures.AbstractArchitecture}, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}, Tuple{Z}, Tuple{Y}, Tuple{X}} where {X, Y, Z}" href="#Oceananigans.AbstractOperations.‚àÇy-Union{Tuple{Oceananigans.Fields.AbstractField{X, Y, Z, A, G, T, N} where {A&lt;:Union{Nothing, Oceananigans.Architectures.AbstractArchitecture}, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}, Tuple{Z}, Tuple{Y}, Tuple{X}} where {X, Y, Z}"><code>Oceananigans.AbstractOperations.‚àÇy</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">‚àÇy(a::AbstractField)</code></pre><p>Return an abstract representation of a y-derivative acting on <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/AbstractOperations/derivatives.jl#L94-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.‚àÇy-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{Tuple, Oceananigans.Fields.AbstractField{X, Y, Z, A, G, T, N} where {A&lt;:Union{Nothing, Oceananigans.Architectures.AbstractArchitecture}, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}} where {X, Y, Z}" href="#Oceananigans.AbstractOperations.‚àÇy-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{Tuple, Oceananigans.Fields.AbstractField{X, Y, Z, A, G, T, N} where {A&lt;:Union{Nothing, Oceananigans.Architectures.AbstractArchitecture}, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}} where {X, Y, Z}"><code>Oceananigans.AbstractOperations.‚àÇy</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">‚àÇy(L::Tuple, a::AbstractField)</code></pre><p>Return an abstract representation of a y-derivative acting on <code>a</code> followed by interpolation to <code>L</code>, where <code>L</code> is a 3-tuple of <code>Face</code>s and <code>Center</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/AbstractOperations/derivatives.jl#L68-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.‚àÇz-Tuple{Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}}" href="#Oceananigans.AbstractOperations.‚àÇz-Tuple{Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}}"><code>Oceananigans.AbstractOperations.‚àÇz</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Return the z-derivative function acting at (<code>Any</code>, <code>Any</code>, <code>Z</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/AbstractOperations/derivatives.jl#L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.‚àÇz-Union{Tuple{Oceananigans.Fields.AbstractField{X, Y, Z, A, G, T, N} where {A&lt;:Union{Nothing, Oceananigans.Architectures.AbstractArchitecture}, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}, Tuple{Z}, Tuple{Y}, Tuple{X}} where {X, Y, Z}" href="#Oceananigans.AbstractOperations.‚àÇz-Union{Tuple{Oceananigans.Fields.AbstractField{X, Y, Z, A, G, T, N} where {A&lt;:Union{Nothing, Oceananigans.Architectures.AbstractArchitecture}, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}, Tuple{Z}, Tuple{Y}, Tuple{X}} where {X, Y, Z}"><code>Oceananigans.AbstractOperations.‚àÇz</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">‚àÇz(a::AbstractField)</code></pre><p>Return an abstract representation of a z-derivative acting on <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/AbstractOperations/derivatives.jl#L100-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.‚àÇz-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{Tuple, Oceananigans.Fields.AbstractField{X, Y, Z, A, G, T, N} where {A&lt;:Union{Nothing, Oceananigans.Architectures.AbstractArchitecture}, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}} where {X, Y, Z}" href="#Oceananigans.AbstractOperations.‚àÇz-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{Tuple, Oceananigans.Fields.AbstractField{X, Y, Z, A, G, T, N} where {A&lt;:Union{Nothing, Oceananigans.Architectures.AbstractArchitecture}, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}} where {X, Y, Z}"><code>Oceananigans.AbstractOperations.‚àÇz</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">‚àÇz(L::Tuple, a::AbstractField)</code></pre><p>Return an abstract representation of a z-derivative acting on <code>a</code> followed by interpolation to <code>L</code>, where <code>L</code> is a 3-tuple of <code>Face</code>s and <code>Center</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/AbstractOperations/derivatives.jl#L77-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.@multiary-Tuple" href="#Oceananigans.AbstractOperations.@multiary-Tuple"><code>Oceananigans.AbstractOperations.@multiary</code></a> ‚Äî <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@multiary op1 op2 op3...</code></pre><p>Turn each multiary operator in the list <code>(op1, op2, op3...)</code> into a multiary operator on <code>Oceananigans.Fields</code> for use in <code>AbstractOperations</code>.</p><p>Note that a multiary operator:     * is a function with two or more arguments: for example, <code>+(x, y, z)</code> is a multiary function;     * must be imported to be extended if part of <code>Base</code>: use <code>import Base: op; @multiary op</code>;     * can only be called on <code>Oceananigans.Field</code>s if the &quot;location&quot; is noted explicitly; see example.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans, Oceananigans.AbstractOperations

julia&gt; harmonic_plus(a, b, c) = 1/3 * (1/a + 1/b + 1/c)
harmonic_plus (generic function with 1 method)

julia&gt; c, d, e = Tuple(Field(Center, Center, Center, CPU(), RegularRectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))) for i = 1:3);

julia&gt; harmonic_plus(c, d, e) # before magic @multiary transformation
BinaryOperation at (Center, Center, Center)
‚îú‚îÄ‚îÄ grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1)
‚îÇ   ‚îî‚îÄ‚îÄ domain: x ‚àà [0.0, 1.0], y ‚àà [0.0, 1.0], z ‚àà [-1.0, 0.0]
‚îî‚îÄ‚îÄ tree:
    * at (Center, Center, Center)
 ¬†¬† ‚îú‚îÄ‚îÄ 0.3333333333333333
 ¬†¬† ‚îî‚îÄ‚îÄ + at (Center, Center, Center)
 ¬†¬†  ¬†¬† ‚îú‚îÄ‚îÄ / at (Center, Center, Center)
 ¬†¬†  ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 1
 ¬†¬†  ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ Field located at (Center, Center, Center)
 ¬†¬†  ¬†¬† ‚îú‚îÄ‚îÄ / at (Center, Center, Center)
 ¬†¬†  ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 1
 ¬†¬†  ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ Field located at (Center, Center, Center)
 ¬†¬†  ¬†¬† ‚îî‚îÄ‚îÄ / at (Center, Center, Center)
 ¬†¬†  ¬†¬†  ¬†¬† ‚îú‚îÄ‚îÄ 1
 ¬†¬†  ¬†¬†  ¬†¬† ‚îî‚îÄ‚îÄ Field located at (Center, Center, Center)

julia&gt; @multiary harmonic_plus
Set{Any} with 3 elements:
  :+
  :harmonic_plus
  :*

julia&gt; harmonic_plus(c, d, e)
MultiaryOperation at (Center, Center, Center)
‚îú‚îÄ‚îÄ grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1)
‚îÇ   ‚îî‚îÄ‚îÄ domain: x ‚àà [0.0, 1.0], y ‚àà [0.0, 1.0], z ‚àà [-1.0, 0.0]
‚îî‚îÄ‚îÄ tree:
    harmonic_plus at (Center, Center, Center)
 ¬†¬† ‚îú‚îÄ‚îÄ Field located at (Center, Center, Center)
 ¬†¬† ‚îú‚îÄ‚îÄ Field located at (Center, Center, Center)
 ¬†¬† ‚îî‚îÄ‚îÄ Field located at (Center, Center, Center)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/AbstractOperations/multiary_operations.jl#L59-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.@unary-Tuple" href="#Oceananigans.AbstractOperations.@unary-Tuple"><code>Oceananigans.AbstractOperations.@unary</code></a> ‚Äî <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@unary op1 op2 op3...</code></pre><p>Turn each unary function in the list <code>(op1, op2, op3...)</code> into a unary operator on <code>Oceananigans.Fields</code> for use in <code>AbstractOperations</code>.</p><p>Note: a unary function is a function with one argument: for example, <code>sin(x)</code> is a unary function.</p><p>Also note: a unary function in <code>Base</code> must be imported to be extended: use <code>import Base: op; @unary op</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans, Oceananigans.Grids, Oceananigans.AbstractOperations

julia&gt; square_it(x) = x^2
square_it (generic function with 1 method)

julia&gt; @unary square_it
Set{Any} with 8 elements:
  :sqrt
  :square_it
  :cos
  :exp
  :interpolate_identity
  :-
  :tanh
  :sin

julia&gt; c = Field(Center, Center, Center, CPU(), RegularRectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)));

julia&gt; square_it(c)
UnaryOperation at (Center, Center, Center)
‚îú‚îÄ‚îÄ grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1)
‚îÇ   ‚îî‚îÄ‚îÄ domain: x ‚àà [0.0, 1.0], y ‚àà [0.0, 1.0], z ‚àà [-1.0, 0.0]
‚îî‚îÄ‚îÄ tree:
    square_it at (Center, Center, Center) via identity
 ¬†¬† ‚îî‚îÄ‚îÄ Field located at (Center, Center, Center)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/8da06a2169015c0bddbf01a530a8dc574eeb1500/src/AbstractOperations/unary_operations.jl#L39-L79">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../benchmarks/">¬´ Performance benchmarks</a><a class="docs-footer-nextpage" href="../function_index/">Function index ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Monday 1 November 2021 12:10">Monday 1 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

var documenterSearchIndex = {"docs":
[{"location":"appendix/convergence_tests/#Convergence-Tests","page":"Convergence tests","title":"Convergence Tests","text":"","category":"section"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"Convergence tests are implemented in /validation/convergence_tests and range from zero-dimensional time-stepper tests to two-dimensional integration tests that involve non-trivial pressure fields, advection, and diffusion.","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"For all tests except point exponential decay, we use the L_1 norm,","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    L_1 equiv fracmathrmmean  phi_mathrmsim - phi_mathrmexact mathrmmean  phi_mathrmexact ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"and L_infty norm,","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    L_infty equiv fracmax  phi_mathrmsim - phi_mathrmexact max  phi_mathrmexact   ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"to compare simulated fields, phi_mathrmsim, with exact, analytically-derived solutions phi_mathrmexact. The field phi may be a tracer field or a velocity field.","category":"page"},{"location":"appendix/convergence_tests/#Point-Exponential-Decay","page":"Convergence tests","title":"Point Exponential Decay","text":"","category":"section"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"This test analyzes time-stepper convergence by simulating the zero-dimensional, or spatially-uniform equation","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    partial_t c = - c  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"with the initial condition c = 1, which has the analytical solution c = mathrme^-t.","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"We find the expected first-order convergence with decreasing time-step Delta t using our first-order accurate, \"modified second-order\" Adams-Bashforth time-stepping method:","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"(Image: Point exponential decay)","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"This result validates the correctness of the Oceananigans implementation of Adams-Bashforth time-stepping.","category":"page"},{"location":"appendix/convergence_tests/#One-dimensional-advection-and-diffusion-of-a-Gaussian","page":"Convergence tests","title":"One-dimensional advection and diffusion of a Gaussian","text":"","category":"section"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"This and the following tests focus on convergence with grid spacing, Delta x.","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"In one dimension with constant diffusivity kappa and in the presence of a constant velocity U, a Gaussian evolves according to","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    c = fracmathrme^- (x - U t)^2  4 kappa tsqrt4 pi kappa t  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"For this test we take the initial time as t=t_0. We simulate this problem with advection and diffusion, as well as with U=0 and thus diffusion only, as well as with kappa approx 0 and thus \"advection only\". The solutions are","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"(Image: Gaussian advection diffusion solutions)","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"which exhibit the expected second-order convergence with Delta x^2 propto 1  N_x^2:","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"(Image: Gaussian advection diffusion convergence)","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"These results validate the correctness of time-stepping, constant diffusivity operators, and advection operators.","category":"page"},{"location":"appendix/convergence_tests/#One-dimensional-advection-and-diffusion-of-a-cosine","page":"Convergence tests","title":"One-dimensional advection and diffusion of a cosine","text":"","category":"section"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"In one dimension with constant diffusivity kappa and in the presence of a constant velocity U, a cosine evolves according to","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    c = mathrme^-kappa t cos (x - U t)  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"The solutions are","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"(Image: Cosine advection diffusion solutions)","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"which exhibit the expected second-order convergence with Delta x^2 propto 1  N_x^2:","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"(Image: Cosine advection diffusion convergence)","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"These results validate the correctness of time-stepping, constant diffusivity operators, and advection operators.","category":"page"},{"location":"appendix/convergence_tests/#Two-dimensional-diffusion","page":"Convergence tests","title":"Two-dimensional diffusion","text":"","category":"section"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"With zero velocity field and constant diffusivity kappa, the tracer field","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    c(x y t=0) = cos(x) cos(y)  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"decays according to","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    c(x y t) = mathrme^-2 kappa t cos(x) cos(y)  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"with either periodic boundary conditions, or insulating boundary conditions in either x or y.","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"The expected convergence with Delta x^2 propto 1  N_x^2 is observed:","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"(Image: Two dimensional diffusion convergence)","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"This validates the correctness of multi-dimensional diffusion operators.","category":"page"},{"location":"appendix/convergence_tests/#Decaying,-advected-Taylor-Green-vortex","page":"Convergence tests","title":"Decaying, advected Taylor-Green vortex","text":"","category":"section"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"The velocity field","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"beginalign\n    u(x y t)  = U + mathrme^-t cos(x - U t) sin(y)   \n    v(x y t)  =   - mathrme^-t sin(x - U t) cos(y)  \nendalign","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"is a solution to the Navier-Stokes equations with viscosity nu = 1.","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"The expected convergence with spatial resolution is observed:","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"(Image: Decaying advected Taylor Green)","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"This validates the correctness of the advection and diffusion of a velocity field.","category":"page"},{"location":"appendix/convergence_tests/#Forced-two-dimensional-flows","page":"Convergence tests","title":"Forced two-dimensional flows","text":"","category":"section"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"We introduce two convergence tests associated with forced flows in domains that are bounded in y, and periodic in x with no tracers.","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"Note: in this section, subscripts are used to denote derivatives to make reading and typing equations easier.","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"In a two-dimensional flow in (x y), the velocity field (u v) can be expressed in terms of a streamfunction psi(x y t) such that","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    u equiv - psi_y   quad textand quad v equiv psi_x  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"where subscript denote derivatives such that psi_y equiv partial_y psi, for example. With an isotropic Laplacian viscosity nu = 1, the momentum and continuity equations are","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    beginalign\n    boldsymbolv_t + left ( boldsymbolv boldsymbolcdot boldsymbolnabla right ) boldsymbolv + boldsymbolnabla p  = nabla^2 boldsymbolv + boldsymbolF_v   \n    boldsymbolnabla boldsymbolcdot boldsymbolv  = 0  \n    endalign","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"while the equation for vorticity, omega = v_x - u_y = nabla^2 psi, is","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    omega_t + mathrmJ left ( psi omega right ) = nabla^2 omega + F_omega  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"Finally, taking the divergence of the momentum equation, we find a Poisson equation for pressure,","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    nabla^2 p = - u_x^2 - v_y^2 - 2 u_y v_x + partial_x F_v + partial_y F_v  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"To pose the problem, we first pick a streamfunction psi. This choice then yields the vorticity forcing F_omega that satisfies the vorticity equation. We then determine F_u by solving partial_y F_v = - F_omega, and pick F_v so that we can solve the Poisson equation for pressure.","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"We restrict ourselves to a class of problems in which","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"psi(x y t) = - f(x t) g(y)   quad textwith quad f equiv cos x - xi(t)   quad\nxi(t) equiv 1 + sin(t^2)  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"Grinding through the algebra, this particular form implies that F_omega is given by","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    F_omega = -xi^prime f_x (g - g^primeprime) + f f_x (g g^primeprimeprime - g^prime g^primeprime) + f (g - 2 g^primeprime + g^primeprimeprimeprime)  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"where primes denote derivatives of functions of a single argument. Setting partial_y F_v = F_omega, we find that if F_v satisfies","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    partial_y F_v = (g^prime)^2 + g g^primeprime  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"then the pressure Poisson equation becomes","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    nabla^2 p = cos 2 (x - xi) (g^prime)^2 - g g^primeprime + partial_x F_v  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"This completes the specification of the problem.","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"We set up the problem by imposing the time-dependent forcing functions F_u and F_v on u and v, initializing the flow at t=0, and integrating the problem forwards in time using Oceananigans. We find the expected convergence of the numerical solution to the analytical solution: the error between the numerical and analytical solutions decreases with 1N_x^2 sim Delta x^2, where N_x is the number of grid points and Delta x is the spatial resolution:","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"(Image: Forced free slip convergence)","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"The convergence tests are performed using both y and z as the bounded direction.","category":"page"},{"location":"appendix/convergence_tests/#Forced,-free-slip-flow","page":"Convergence tests","title":"Forced, free-slip flow","text":"","category":"section"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"A forced flow satisfying free-slip conditions at y = 0 and y = pi has the streamfunction","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    psi(x y t) = - cos x - xi(t) sin (y)  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"and thus g(y) = sin y. The velocity field (u v) is","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    u = cos (x - xi) cos y   quad textand quad v = sin (x - xi) sin y  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"which satisfies the boundary conditions u_y _y=0 = u_y _y=pi = 0 and v _y=0 = v _y=pi = 0. The vorticity forcing is","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    F_omega = - 2 xi^prime f_x sin y + 4 f sin y  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"which implies that","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    F_v = - 2 xi^prime f_x cos y + 4 f cos y  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"and F_v = tfrac12 sin 2 y.","category":"page"},{"location":"appendix/convergence_tests/#Forced,-fixed-slip-flow","page":"Convergence tests","title":"Forced, fixed-slip flow","text":"","category":"section"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"A forced flow satisfying \"fixed-slip\" boundary conditions at y=0 and y=1 has the streamfunction","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    psi(x y t) = - cos x - xi(t) (y^3 - y^2)  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"and thus g(y) = y^3 - y^2. The velocity field (u v) is","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    u = f (3y^2 - 2 y)   quad textand quad v = - f_x (y^3 - y^2)  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"which satisfies the boundary conditions","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    u _y=0 = 0   quad u _y=1 = f   quad textand quad v _y=0 = v _y=1 = 0  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"The vorticity forcing is","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    F_omega = - xi^prime f_x (y^3 - y^2 - 6y + 2) - f f_x (12 y^3 - 12 y^2 + 4 y) + f (y^3 - y^2 - 12 y + 4)  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"which implies that","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    F_v = xi^prime f_x (tfrac14 y^4 - tfrac13 y^3 - 3 y^2 + 2y)\n        + f f_x (3 y^4 - 4 y^3 + 2y^2 )\n        - f (tfrac14 y^4 - tfrac13 y^3 - 6 y^2 + 4 y)  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"and","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    F_v = 3 y^5 - 5 y^4 + 2y^3  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"We set up the problem in the same manner as the forced, free-slip problem above. Note that we also must the no-slip boundary condition u _y=0 = 0 and the time-dependent fixed-slip condition u _y=1 = f. As for the free-slip problem, we find that the error between the numerical and analytical solutions decreases with 1  N_x^2 sim Delta x^2, where N_x is the number of grid points and Delta x is the spatial resolution:","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"(Image: Forced fixed slip convergence)","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"The convergence tests are performed using both y and z as the bounded direction.","category":"page"},{"location":"appendix/library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Documenting the public user interface.","category":"page"},{"location":"appendix/library/#Oceananigans.jl","page":"Library","title":"Oceananigans.jl","text":"","category":"section"},{"location":"appendix/library/#Oceananigans.Oceananigans","page":"Library","title":"Oceananigans.Oceananigans","text":"Main module for Oceananigans.jl â€“ a Julia software for fast, friendly, flexible, data-driven, ocean-flavored fluid dynamics on CPUs and GPUs.\n\n\n\n\n\n","category":"module"},{"location":"appendix/library/#Abstract-operations","page":"Library","title":"Abstract operations","text":"","category":"section"},{"location":"appendix/library/#Oceananigans.AbstractOperations.Average-Tuple{Oceananigans.Fields.AbstractField}","page":"Library","title":"Oceananigans.AbstractOperations.Average","text":"Average(field::AbstractField; dims=:, condition=nothing, mask=0)\n\nReturn Reduction representing a spatial average of field over dims.\n\nOver regularly-spaced dimensions this is equivalent to a numerical mean!.\n\nOver dimensions of variable spacing, field is multiplied by the appropriate \"averaging metric\" (length, area or volume for 1D, 2D, or 3D averages), and divided by the sum of the metric over the averaging region.\n\nSee ConditionalOperation for information and examples using condition and mask kwargs.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.BinaryOperation-Union{Tuple{G}, Tuple{IB}, Tuple{IA}, Tuple{B}, Tuple{A}, Tuple{O}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{O, A, B, IA, IB, G}} where {LX, LY, LZ, O, A, B, IA, IB, G}","page":"Library","title":"Oceananigans.AbstractOperations.BinaryOperation","text":"BinaryOperation{LX, LY, LZ}(op, a, b, â–¶a, â–¶b, grid)\n\nReturn an abstract representation of the binary operation op(â–¶a(a), â–¶b(b)) on grid, where â–¶a and â–¶b interpolate a and b to locations (LX, LY, LZ).\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.ConditionalOperation-Tuple{Oceananigans.Fields.AbstractField}","page":"Library","title":"Oceananigans.AbstractOperations.ConditionalOperation","text":"ConditionalOperation(operand::AbstractField;\n                     func = nothing,\n                     condition = nothing,\n                     mask = 0)\n\nReturn an abstract representation of a masking procedure applied when condition is satisfied on a field described by func(operand).\n\nPositional arguments\n\noperand: The AbstractField to be masked.\n\nKeyword arguments\n\nfunc: A unary transformation applied element-wise to the field operand at locations where         condition == true. Default is nothing which applies no transformation.\ncondition: either a function of (i, j, k, grid, operand) returning a Boolean,              or a 3-dimensional Boolean AbstractArray. At locations where condition == false,              operand will be masked by mask.\nmask: the scalar mask. Default: 0.\n\ncondition_operand is a convenience function used to construct a ConditionalOperation, e.g.,\n\ncondition_operand(func::Function, operand::AbstractField, condition, mask) =\n    ConditionalOperation(operand; func, condition, mask)\n\nExample\n\njulia> using Oceananigans\n\njulia> using Oceananigans.Fields: condition_operand\n\njulia> c = CenterField(RectilinearGrid(size=(2, 1, 1), extent=(1, 1, 1)));\n\njulia> add_2(c) = c + 2\nadd_2 (generic function with 1 method)\n\njulia> f(i, j, k, grid, c) = i < 2; d = condition_operand(add_2, c, f, 10.0)\nConditionalOperation at (Center, Center, Center)\nâ”œâ”€â”€ operand: 2Ã—1Ã—1 Field{Center, Center, Center} on RectilinearGrid on CPU\nâ”œâ”€â”€ grid: 2Ã—1Ã—1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 2Ã—1Ã—1 halo\nâ”œâ”€â”€ func: add_2 (generic function with 1 method)\nâ”œâ”€â”€ condition: f (generic function with 1 method)\nâ””â”€â”€ mask: 10.0\n\njulia> d[1, 1, 1]\n2.0\n\njulia> d[2, 1, 1]\n10.0\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.CumulativeIntegral-Tuple{Oceananigans.Fields.AbstractField}","page":"Library","title":"Oceananigans.AbstractOperations.CumulativeIntegral","text":"CumulativeIntegral(field::AbstractField; dims, reverse=false, condition=nothing, mask=0)\n\nReturn an Accumulation representing the cumulative spatial integral of field over dims.\n\nSee ConditionalOperation for information and examples using condition and mask kwargs.\n\nExample\n\nCompute the cumulative integral of f(z) = z over z âˆˆ [0, 1].\n\njulia> using Oceananigans\n\njulia> grid = RectilinearGrid(size=8, z=(0, 1), topology=(Flat, Flat, Bounded));\n\njulia> c = CenterField(grid);\n\njulia> set!(c, z -> z)\n1Ã—1Ã—8 Field{Center, Center, Center} on RectilinearGrid on CPU\nâ”œâ”€â”€ grid: 1Ã—1Ã—8 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0Ã—0Ã—3 halo\nâ”œâ”€â”€ boundary conditions: FieldBoundaryConditions\nâ”‚   â””â”€â”€ west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: ZeroFlux, top: ZeroFlux, immersed: Nothing\nâ””â”€â”€ data: 1Ã—1Ã—14 OffsetArray(::Array{Float64, 3}, 1:1, 1:1, -2:11) with eltype Float64 with indices 1:1Ã—1:1Ã—-2:11\n    â””â”€â”€ max=0.9375, min=0.0625, mean=0.5\n\njulia> C_op = CumulativeIntegral(c, dims=3)\nCumulativeIntegral of BinaryOperation at (Center, Center, Center) over dims 3\nâ””â”€â”€ operand: BinaryOperation at (Center, Center, Center)\n    â””â”€â”€ grid: 1Ã—1Ã—8 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0Ã—0Ã—3 halo\n\njulia> C = compute!(Field(C_op))\n1Ã—1Ã—8 Field{Center, Center, Center} on RectilinearGrid on CPU\nâ”œâ”€â”€ data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 1, 8)\nâ”œâ”€â”€ grid: 1Ã—1Ã—8 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0Ã—0Ã—3 halo\nâ”œâ”€â”€ operand: CumulativeIntegral of BinaryOperation at (Center, Center, Center) over dims 3\nâ”œâ”€â”€ status: time=0.0\nâ””â”€â”€ data: 1Ã—1Ã—14 OffsetArray(::Array{Float64, 3}, 1:1, 1:1, -2:11) with eltype Float64 with indices 1:1Ã—1:1Ã—-2:11\n    â””â”€â”€ max=0.5, min=0.0078125, mean=0.199219\n\njulia> C[1, 1, 8]\n0.5\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.Derivative-Union{Tuple{G}, Tuple{AD}, Tuple{IN}, Tuple{A}, Tuple{D}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{D, A, IN, AD, G}} where {LX, LY, LZ, D, A, IN, AD, G}","page":"Library","title":"Oceananigans.AbstractOperations.Derivative","text":"Derivative{LX, LY, LZ}(âˆ‚, arg, â–¶, grid)\n\nReturn an abstract representation of the derivative âˆ‚ on arg, and subsequent interpolation by â–¶ on grid.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.Integral-Tuple{Oceananigans.Fields.AbstractField}","page":"Library","title":"Oceananigans.AbstractOperations.Integral","text":"Integral(field::AbstractField; dims=:, condition=nothing, mask=0)\n\nReturn a Reduction representing a spatial integral of field over dims.\n\nSee ConditionalOperation for information and examples using condition and mask kwargs.\n\nExample\n\nCompute the integral of f(x y z) = x y z over the domain (x y z)  0 1  0 1  0 1. The analytical answer is  x y z  dx  dy  dz = 18.\n\njulia> using Oceananigans\n\njulia> grid = RectilinearGrid(size=(8, 8, 8), x=(0, 1), y=(0, 1), z=(0, 1));\n\njulia> f = CenterField(grid);\n\njulia> set!(f, (x, y, z) -> x * y * z)\n8Ã—8Ã—8 Field{Center, Center, Center} on RectilinearGrid on CPU\nâ”œâ”€â”€ grid: 8Ã—8Ã—8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ boundary conditions: FieldBoundaryConditions\nâ”‚   â””â”€â”€ west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: Nothing\nâ””â”€â”€ data: 14Ã—14Ã—14 OffsetArray(::Array{Float64, 3}, -2:11, -2:11, -2:11) with eltype Float64 with indices -2:11Ã—-2:11Ã—-2:11\n    â””â”€â”€ max=0.823975, min=0.000244141, mean=0.125\n\njulia> âˆ«f = Integral(f)\nIntegral of BinaryOperation at (Center, Center, Center) over dims (1, 2, 3)\nâ””â”€â”€ operand: BinaryOperation at (Center, Center, Center)\n    â””â”€â”€ grid: 8Ã—8Ã—8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\n\njulia> âˆ«f = Field(Integral(f));\n\njulia> compute!(âˆ«f);\n\njulia> âˆ«f[1, 1, 1]\n0.125\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.KernelFunctionOperation-Union{Tuple{G}, Tuple{K}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{K, G, Vararg{Any}}} where {LX, LY, LZ, K, G}","page":"Library","title":"Oceananigans.AbstractOperations.KernelFunctionOperation","text":"KernelFunctionOperation{LX, LY, LZ}(kernel_function, grid, arguments...)\n\nConstruct a KernelFunctionOperation at location (LX, LY, LZ) on grid with arguments.\n\nkernel_function is called with\n\nkernel_function(i, j, k, grid, arguments...)\n\nNote that compute!(kfo::KernelFunctionOperation) calls compute! on all kfo.arguments.\n\nExamples\n\nConstruct a KernelFunctionOperation that returns random numbers:\n\nusing Oceananigans\n\ngrid = RectilinearGrid(size=(1, 8, 8), extent=(1, 1, 1));\n\nrandom_kernel_function(i, j, k, grid) = rand();\nkernel_op = KernelFunctionOperation{Center, Center, Center}(random_kernel_function, grid)\n\n# output\nKernelFunctionOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 1Ã—8Ã—8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1Ã—3Ã—3 halo\nâ”œâ”€â”€ kernel_function: random_kernel_function (generic function with 1 method)\nâ””â”€â”€ arguments: ()\n\nConstruct a KernelFunctionOperation using the vertical vorticity operator used internally to compute vertical vorticity on all grids:\n\nusing Oceananigans.Operators: Î¶â‚ƒá¶ á¶ á¶œ # called with signature Î¶â‚ƒá¶ á¶ á¶œ(i, j, k, grid, u, v)\n\nmodel = HydrostaticFreeSurfaceModel(; grid);\nu, v, w = model.velocities;\nÎ¶_op = KernelFunctionOperation{Face, Face, Center}(Î¶â‚ƒá¶ á¶ á¶œ, grid, u, v)\n\n# output\nKernelFunctionOperation at (Face, Face, Center)\nâ”œâ”€â”€ grid: 1Ã—8Ã—8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1Ã—3Ã—3 halo\nâ”œâ”€â”€ kernel_function: Î¶â‚ƒá¶ á¶ á¶œ (generic function with 1 method)\nâ””â”€â”€ arguments: (\"Field\", \"Field\")\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.UnaryOperation-Union{Tuple{G}, Tuple{IN}, Tuple{A}, Tuple{O}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{O, A, IN, G}} where {LX, LY, LZ, O, A, IN, G}","page":"Library","title":"Oceananigans.AbstractOperations.UnaryOperation","text":"UnaryOperation{LX, LY, LZ}(op, arg, â–¶, grid)\n\nReturns an abstract UnaryOperation representing the action of op on arg, and subsequent interpolation by â–¶ on grid.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.âˆ‚x-Tuple{Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}}","page":"Library","title":"Oceananigans.AbstractOperations.âˆ‚x","text":"Return the x-derivative function acting at (X, Y, Any).\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.âˆ‚x-Union{Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Tuple, Oceananigans.Fields.AbstractField{LX, LY, LZ}}} where {LX, LY, LZ}","page":"Library","title":"Oceananigans.AbstractOperations.âˆ‚x","text":"âˆ‚x(L::Tuple, arg::AbstractField)\n\nReturn an abstract representation of an x-derivative acting on field arg followed by interpolation to L, where L is a 3-tuple of Faces and Centers.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.âˆ‚x-Union{Tuple{Oceananigans.Fields.AbstractField{LX, LY, LZ}}, Tuple{LZ}, Tuple{LY}, Tuple{LX}} where {LX, LY, LZ}","page":"Library","title":"Oceananigans.AbstractOperations.âˆ‚x","text":"âˆ‚x(arg::AbstractField)\n\nReturn an abstract representation of a x-derivative acting on field arg.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.âˆ‚y-Tuple{Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}}","page":"Library","title":"Oceananigans.AbstractOperations.âˆ‚y","text":"Return the y-derivative function acting at (X, Y, Any).\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.âˆ‚y-Union{Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Tuple, Oceananigans.Fields.AbstractField{LX, LY, LZ}}} where {LX, LY, LZ}","page":"Library","title":"Oceananigans.AbstractOperations.âˆ‚y","text":"âˆ‚y(L::Tuple, arg::AbstractField)\n\nReturn an abstract representation of a y-derivative acting on field arg followed by interpolation to L, where L is a 3-tuple of Faces and Centers.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.âˆ‚y-Union{Tuple{Oceananigans.Fields.AbstractField{LX, LY, LZ}}, Tuple{LZ}, Tuple{LY}, Tuple{LX}} where {LX, LY, LZ}","page":"Library","title":"Oceananigans.AbstractOperations.âˆ‚y","text":"âˆ‚y(arg::AbstractField)\n\nReturn an abstract representation of a y-derivative acting on field arg.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.âˆ‚z-Tuple{Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}}","page":"Library","title":"Oceananigans.AbstractOperations.âˆ‚z","text":"Return the z-derivative function acting at (Any, Any, Z).\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.âˆ‚z-Union{Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Tuple, Oceananigans.Fields.AbstractField{LX, LY, LZ}}} where {LX, LY, LZ}","page":"Library","title":"Oceananigans.AbstractOperations.âˆ‚z","text":"âˆ‚z(L::Tuple, arg::AbstractField)\n\nReturn an abstract representation of a z-derivative acting on field arg followed by  interpolation to L, where L is a 3-tuple of Faces and Centers.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.âˆ‚z-Union{Tuple{Oceananigans.Fields.AbstractField{LX, LY, LZ}}, Tuple{LZ}, Tuple{LY}, Tuple{LX}} where {LX, LY, LZ}","page":"Library","title":"Oceananigans.AbstractOperations.âˆ‚z","text":"âˆ‚z(arg::AbstractField)\n\nReturn an abstract representation of a z-derivative acting on field arg.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.@at-Tuple{Any, Any}","page":"Library","title":"Oceananigans.AbstractOperations.@at","text":"@at location abstract_operation\n\nModify the abstract_operation so that it returns values at location, where location is a 3-tuple of Faces and Centers.\n\n\n\n\n\n","category":"macro"},{"location":"appendix/library/#Oceananigans.AbstractOperations.@binary-Tuple","page":"Library","title":"Oceananigans.AbstractOperations.@binary","text":"@binary op1 op2 op3...\n\nTurn each binary function in the list (op1, op2, op3...) into a binary operator on Oceananigans.Fields for use in AbstractOperations.\n\nNote: a binary function is a function with two arguments: for example, +(x, y) is a binary function.\n\nAlso note: a binary function in Base must be imported to be extended: use import Base: op; @binary op.\n\nExample\n\njulia> using Oceananigans, Oceananigans.AbstractOperations\n\njulia> using Oceananigans.AbstractOperations: BinaryOperation, GridMetric, choose_location\n\njulia> plus_or_times(x, y) = x < 0 ? x + y : x * y\nplus_or_times (generic function with 1 method)\n\njulia> @binary plus_or_times\nSet{Any} with 6 elements:\n  :+\n  :/\n  :^\n  :-\n  :*\n  :plus_or_times\n\njulia> c, d = (CenterField(RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))) for i = 1:2);\n\njulia> plus_or_times(c, d)\nBinaryOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 1Ã—1Ã—1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1Ã—1Ã—1 halo\nâ””â”€â”€ tree:\n    plus_or_times at (Center, Center, Center)\n Â Â  â”œâ”€â”€ 1Ã—1Ã—1 Field{Center, Center, Center} on RectilinearGrid on CPU\n Â Â  â””â”€â”€ 1Ã—1Ã—1 Field{Center, Center, Center} on RectilinearGrid on CPU\n\n\n\n\n\n","category":"macro"},{"location":"appendix/library/#Oceananigans.AbstractOperations.@multiary-Tuple","page":"Library","title":"Oceananigans.AbstractOperations.@multiary","text":"@multiary op1 op2 op3...\n\nTurn each multiary operator in the list (op1, op2, op3...) into a multiary operator on Oceananigans.Fields for use in AbstractOperations.\n\nNote that a multiary operator:\n\nis a function with two or more arguments: for example, +(x, y, z) is a multiary function;\nmust be imported to be extended if part of Base: use import Base: op; @multiary op;\ncan only be called on Oceananigans.Fields if the \"location\" is noted explicitly; see example.\n\nExample\n\njulia> using Oceananigans, Oceananigans.AbstractOperations\n\njulia> harmonic_plus(a, b, c) = 1/3 * (1/a + 1/b + 1/c)\nharmonic_plus (generic function with 1 method)\n\njulia> c, d, e = Tuple(CenterField(RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))) for i = 1:3);\n\njulia> harmonic_plus(c, d, e) # before magic @multiary transformation\nBinaryOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 1Ã—1Ã—1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1Ã—1Ã—1 halo\nâ””â”€â”€ tree:\n    * at (Center, Center, Center)\n Â Â  â”œâ”€â”€ 0.3333333333333333\n Â Â  â””â”€â”€ + at (Center, Center, Center)\n Â Â   Â Â  â”œâ”€â”€ / at (Center, Center, Center)\n Â Â   Â Â  â”‚Â Â  â”œâ”€â”€ 1\n Â Â   Â Â  â”‚Â Â  â””â”€â”€ 1Ã—1Ã—1 Field{Center, Center, Center} on RectilinearGrid on CPU\n Â Â   Â Â  â”œâ”€â”€ / at (Center, Center, Center)\n Â Â   Â Â  â”‚Â Â  â”œâ”€â”€ 1\n Â Â   Â Â  â”‚Â Â  â””â”€â”€ 1Ã—1Ã—1 Field{Center, Center, Center} on RectilinearGrid on CPU\n Â Â   Â Â  â””â”€â”€ / at (Center, Center, Center)\n Â Â   Â Â   Â Â  â”œâ”€â”€ 1\n Â Â   Â Â   Â Â  â””â”€â”€ 1Ã—1Ã—1 Field{Center, Center, Center} on RectilinearGrid on CPU\n\njulia> @multiary harmonic_plus\nSet{Any} with 3 elements:\n  :+\n  :harmonic_plus\n  :*\n\njulia> harmonic_plus(c, d, e)\nMultiaryOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 1Ã—1Ã—1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1Ã—1Ã—1 halo\nâ””â”€â”€ tree:\n    harmonic_plus at (Center, Center, Center)\n Â Â  â”œâ”€â”€ 1Ã—1Ã—1 Field{Center, Center, Center} on RectilinearGrid on CPU\n Â Â  â”œâ”€â”€ 1Ã—1Ã—1 Field{Center, Center, Center} on RectilinearGrid on CPU\n Â Â  â””â”€â”€ 1Ã—1Ã—1 Field{Center, Center, Center} on RectilinearGrid on CPU\n\n\n\n\n\n","category":"macro"},{"location":"appendix/library/#Oceananigans.AbstractOperations.@unary-Tuple","page":"Library","title":"Oceananigans.AbstractOperations.@unary","text":"@unary op1 op2 op3...\n\nTurn each unary function in the list (op1, op2, op3...) into a unary operator on Oceananigans.Fields for use in AbstractOperations.\n\nNote: a unary function is a function with one argument: for example, sin(x) is a unary function.\n\nAlso note: a unary function in Base must be imported to be extended: use import Base: op; @unary op.\n\nExample\n\njulia> using Oceananigans, Oceananigans.Grids, Oceananigans.AbstractOperations\n\njulia> square_it(x) = x^2\nsquare_it (generic function with 1 method)\n\njulia> @unary square_it\nSet{Any} with 15 elements:\n  :+\n  :log10\n  :interpolate_identity\n  :cos\n  :exp\n  :tanh\n  :abs\n  :log\n  :cosh\n  :square_it\n  :-\n  :sqrt\n  :tan\n  :sinh\n  :sin\n\njulia> c = CenterField(RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)));\n\njulia> square_it(c)\nUnaryOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 1Ã—1Ã—1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1Ã—1Ã—1 halo\nâ””â”€â”€ tree:\n    square_it at (Center, Center, Center) via identity\n Â Â  â””â”€â”€ 1Ã—1Ã—1 Field{Center, Center, Center} on RectilinearGrid on CPU\n\n\n\n\n\n","category":"macro"},{"location":"appendix/library/#Advection","page":"Library","title":"Advection","text":"","category":"section"},{"location":"appendix/library/#Oceananigans.Advection.FluxFormAdvection-Tuple{Any, Any, Any}","page":"Library","title":"Oceananigans.Advection.FluxFormAdvection","text":"FluxFormAdvection(x_advection, y_advection, z_advection)\n\nReturn a FluxFormAdvection type with reconstructions schemes x_advection, y_advection, and z_advection to be applied in the x, y, and z directions, respectively.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Advection.VectorInvariant-Tuple{}","page":"Library","title":"Oceananigans.Advection.VectorInvariant","text":"VectorInvariant(; vorticity_scheme = EnstrophyConserving(),\n                  vorticity_stencil = VelocityStencil(),\n                  vertical_advection_scheme = EnergyConserving(),\n                  divergence_scheme = vertical_advection_scheme,\n                  kinetic_energy_gradient_scheme = divergence_scheme,\n                  upwinding  = OnlySelfUpwinding(; cross_scheme = divergence_scheme),\n                  multi_dimensional_stencil = false)\n\nReturn a vector-invariant momentum advection scheme.\n\nKeyword arguments\n\nvorticity_scheme: Scheme used for Center reconstruction of vorticity. Default: EnstrophyConserving(). Options:\nUpwindBiased()\nWENO()\nEnergyConserving()\nEnstrophyConserving()\nvorticity_stencil: Stencil used for smoothness indicators for WENO schemes. Default: VelocityStencil(). Options:\nVelocityStencil() (smoothness based on horizontal velocities)\nDefaultStencil() (smoothness based on variable being reconstructed)\nvertical_advection_scheme: Scheme used for vertical advection of horizontal momentum. Default: EnergyConserving().\nkinetic_energy_gradient_scheme: Scheme used for kinetic energy gradient reconstruction. Default: vertical_advection_scheme.\ndivergence_scheme: Scheme used for divergence flux. Only upwinding schemes are supported. Default: vorticity_scheme.\nupwinding: Treatment of upwinded reconstruction of divergence and kinetic energy gradient. Default: OnlySelfUpwinding(). Options:\nCrossAndSelfUpwinding()\nOnlySelfUpwinding()\nmulti_dimensional_stencil: whether or not to use a horizontal two-dimensional stencil for the reconstruction                              of vorticity, divergence and kinetic energy gradient. Currently the \"tangential\"                              direction uses 5th-order centered WENO reconstruction. Default: false\n\nExamples\n\njulia> using Oceananigans\n\njulia> VectorInvariant()\nVectorInvariant\nâ”œâ”€â”€ vorticity_scheme: Oceananigans.Advection.EnstrophyConserving{Float64}\nâ””â”€â”€ vertical_advection_scheme: Oceananigans.Advection.EnergyConserving{Float64}\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Advection.WENO","page":"Library","title":"Oceananigans.Advection.WENO","text":"WENO([FT=Float64, FT2=Float32;]\n     order = 5,\n     bounds = nothing)\n\nConstruct a weighted essentially non-oscillatory advection scheme of order order with precision FT.\n\nArguments\n\nFT: The floating point type used in the scheme. Default: Oceananigans.defaults.FloatType\nFT2: The floating point type used in some performance-critical parts of the scheme. Default: Float32\n\nKeyword arguments\n\norder: The order of the WENO advection scheme. Default: 5\nbounds (experimental): Whether to use bounds-preserving WENO, which produces a reconstruction                          that attempts to restrict a quantity to lie between a bounds tuple.                          Default: nothing, which does not use a boundary-preserving scheme.\n\nExamples\n\nTo build the default 5th-order scheme:\n\njulia> using Oceananigans\n\njulia> WENO()\nWENO{3, Float64, Float32}(order=5)\nâ”œâ”€â”€ buffer_scheme: WENO{2, Float64, Float32}(order=3)\nâ””â”€â”€ advection_velocity_scheme: Centered(order=4)\n\nTo build a 9th-order scheme (often a good choice for a stable yet minimally-dissipative advection scheme):\n\njulia> WENO(order=9)\nWENO{5, Float64, Float32}(order=9)\nâ”œâ”€â”€ buffer_scheme: WENO{4, Float64, Float32}(order=7)\nâ””â”€â”€ advection_velocity_scheme: Centered(order=8)\n\njulia> WENO(order=9, bounds=(0, 1))\nWENO{5, Float64, Float32}(order=9)\nâ”œâ”€â”€ bounds: (0, 1)\nâ”œâ”€â”€ buffer_scheme: WENO{4, Float64, Float32}(order=7)\nâ””â”€â”€ advection_velocity_scheme: Centered(order=8)\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Advection.WENOVectorInvariant","page":"Library","title":"Oceananigans.Advection.WENOVectorInvariant","text":"WENOVectorInvariant(FT = Float64;\n                    upwinding = nothing,\n                    vorticity_stencil = VelocityStencil(),\n                    order = nothing,\n                    vorticity_order = nothing,\n                    vertical_order = nothing,\n                    divergence_order = nothing,\n                    kinetic_energy_gradient_order = nothing,\n                    multi_dimensional_stencil = false,\n                    weno_kw...)\n\nReturn a vector-invariant weighted essentially non-oscillatory (WENO) scheme. See VectorInvariant and WENO for kwargs definitions.\n\nIf multi_dimensional_stencil = true is selected, then a 2D horizontal stencil is implemented for the WENO scheme (instead of a 1D stencil). This 2D horizontal stencil performs a centered 5th-order WENO reconstruction of vorticity, divergence and kinetic energy in the horizontal direction tangential to the upwind direction.\n\nExample\n\njulia> using Oceananigans\n\njulia> WENOVectorInvariant()\nWENOVectorInvariant{5, Float64, Float32}(vorticity_order=9, vertical_order=5)\nâ”œâ”€â”€ vorticity_scheme: WENO{5, Float64, Float32}(order=9)\nâ”œâ”€â”€ vorticity_stencil: Oceananigans.Advection.VelocityStencil\nâ”œâ”€â”€ vertical_advection_scheme: WENO{3, Float64, Float32}(order=5)\nâ”œâ”€â”€ kinetic_energy_gradient_scheme: WENO{3, Float64, Float32}(order=5)\nâ”œâ”€â”€ divergence_scheme: WENO{3, Float64, Float32}(order=5)\nâ””â”€â”€ upwinding: OnlySelfUpwinding\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Advection.div_Uc-NTuple{7, Any}","page":"Library","title":"Oceananigans.Advection.div_Uc","text":"div_uc(i, j, k, grid, advection, U, c)\n\nCalculate the divergence of the flux of a tracer quantity c being advected by a velocity field, (ğ¯ c),\n\n1/V * [Î´xá¶œáµƒáµƒ(Ax * u * â„‘xá¶ áµƒáµƒ(c)) + Î´yáµƒá¶œáµƒ(Ay * v * â„‘yáµƒá¶ áµƒ(c)) + Î´záµƒáµƒá¶œ(Az * w * â„‘záµƒáµƒá¶ (c))]\n\nwhich ends up at the location ccc.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Advection.div_ğ¯u-NTuple{7, Any}","page":"Library","title":"Oceananigans.Advection.div_ğ¯u","text":"div_ğ¯u(i, j, k, grid, advection, U, u)\n\nCalculate the advection of momentum in the x-direction using the conservative form, (ğ¯ u),\n\n1/Váµ˜ * [Î´xá¶ áµƒáµƒ(â„‘xá¶œáµƒáµƒ(Ax * u) * â„‘xá¶œáµƒáµƒ(u)) + Î´y_fca(â„‘xá¶ áµƒáµƒ(Ay * v) * â„‘yáµƒá¶ áµƒ(u)) + Î´z_fac(â„‘xá¶ áµƒáµƒ(Az * w) * â„‘záµƒáµƒá¶ (u))]\n\nwhich ends up at the location fcc.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Advection.div_ğ¯v-NTuple{7, Any}","page":"Library","title":"Oceananigans.Advection.div_ğ¯v","text":"div_ğ¯v(i, j, k, grid, advection, U, v)\n\nCalculate the advection of momentum in the y-direction using the conservative form, (ğ¯ v),\n\n1/VÊ¸ * [Î´x_cfa(â„‘yáµƒá¶ áµƒ(Ax * u) * â„‘xá¶ áµƒáµƒ(v)) + Î´yáµƒá¶ áµƒ(â„‘yáµƒá¶œáµƒ(Ay * v) * â„‘yáµƒá¶œáµƒ(v)) + Î´z_afc(â„‘xá¶ áµƒáµƒ(Az * w) * â„‘záµƒáµƒá¶ (w))]\n\nwhich ends up at the location cfc.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Advection.div_ğ¯w-NTuple{7, Any}","page":"Library","title":"Oceananigans.Advection.div_ğ¯w","text":"div_ğ¯w(i, j, k, grid, advection, U, w)\n\nCalculate the advection of momentum in the z-direction using the conservative form, (ğ¯ w),\n\n1/VÊ· * [Î´x_caf(â„‘záµƒáµƒá¶ (Ax * u) * â„‘xá¶ áµƒáµƒ(w)) + Î´y_acf(â„‘záµƒáµƒá¶ (Ay * v) * â„‘yáµƒá¶ áµƒ(w)) + Î´záµƒáµƒá¶ (â„‘záµƒáµƒá¶œ(Az * w) * â„‘záµƒáµƒá¶œ(w))]\n\nwhich ends up at the location ccf.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Architectures","page":"Library","title":"Architectures","text":"","category":"section"},{"location":"appendix/library/#Oceananigans.Architectures.AbstractArchitecture","page":"Library","title":"Oceananigans.Architectures.AbstractArchitecture","text":"AbstractArchitecture\n\nAbstract supertype for architectures supported by Oceananigans.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Architectures.AbstractSerialArchitecture","page":"Library","title":"Oceananigans.Architectures.AbstractSerialArchitecture","text":"AbstractSerialArchitecture\n\nAbstract supertype for serial architectures supported by Oceananigans.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Architectures.CPU","page":"Library","title":"Oceananigans.Architectures.CPU","text":"CPU <: AbstractArchitecture\n\nRun Oceananigans on one CPU node. Uses multiple threads if the environment variable JULIA_NUM_THREADS is set.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Architectures.GPU","page":"Library","title":"Oceananigans.Architectures.GPU","text":"GPU(device)\n\nReturn a GPU architecture using device. device defauls to CUDA.CUDABackend(always_inline=true) if CUDA is loaded.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Architectures.ReactantState","page":"Library","title":"Oceananigans.Architectures.ReactantState","text":"ReactantState <: AbstractArchitecture\n\nRun Oceananigans on Reactant.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Architectures.child_architecture-Tuple{Oceananigans.Architectures.AbstractSerialArchitecture}","page":"Library","title":"Oceananigans.Architectures.child_architecture","text":"child_architecture(arch)\n\nReturn architecture of child processes. On single-process, non-distributed systems, return arch.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Boundary-conditions","page":"Library","title":"Boundary conditions","text":"","category":"section"},{"location":"appendix/library/#Oceananigans.BoundaryConditions.BoundaryCondition","page":"Library","title":"Oceananigans.BoundaryConditions.BoundaryCondition","text":"struct BoundaryCondition{C<:AbstractBoundaryConditionClassification, T}\n\nContainer for boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.BoundaryConditions.BoundaryCondition-Tuple{Oceananigans.BoundaryConditions.AbstractBoundaryConditionClassification, Function}","page":"Library","title":"Oceananigans.BoundaryConditions.BoundaryCondition","text":"BoundaryCondition(classification::AbstractBoundaryConditionClassification, condition::Function;\n                  parameters = nothing,\n                  discrete_form = false,\n                  field_dependencies=())\n\nConstruct a boundary condition of type classification with a function boundary condition.\n\nBy default, the function boudnary condition is assumed to have the 'continuous form' condition(Î¾, Î·, t), where t is time and Î¾ and Î· vary along the boundary. In particular:\n\nOn x-boundaries, condition(y, z, t).\nOn y-boundaries, condition(x, z, t).\nOn z-boundaries, condition(x, y, t).\n\nIf parameters is not nothing, then function boundary conditions have the form func(Î¾, Î·, t, parameters), where Î¾ and Î· are spatial coordinates varying along the boundary as explained above.\n\nIf discrete_form = true, the function condition is assumed to have the \"discrete form\",\n\ncondition(i, j, grid, clock, model_fields)\n\nwhere i, and j are indices that vary along the boundary. If discrete_form = true and parameters is not nothing, the function condition is called with\n\ncondition(i, j, grid, clock, model_fields, parameters)\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.BoundaryConditions.FieldBoundaryConditions","page":"Library","title":"Oceananigans.BoundaryConditions.FieldBoundaryConditions","text":"FieldBoundaryConditions(grid, location, indices=(:, :, :);\n                        west     = default_auxiliary_bc(grid, boundary, loc),\n                        east     = default_auxiliary_bc(grid, boundary, loc),\n                        south    = default_auxiliary_bc(grid, boundary, loc),\n                        north    = default_auxiliary_bc(grid, boundary, loc),\n                        bottom   = default_auxiliary_bc(grid, boundary, loc),\n                        top      = default_auxiliary_bc(grid, boundary, loc),\n                        immersed = NoFluxBoundaryCondition())\n\nReturn boundary conditions for auxiliary fields (fields whose values are derived from a model's prognostic fields) on grid and at location.\n\nKeyword arguments\n\nKeyword arguments specify boundary conditions on the 6 possible boundaries:\n\nwest, left end point in the x-direction where i = 1\neast, right end point in the x-direction where i = grid.Nx\nsouth, left end point in the y-direction where j = 1\nnorth, right end point in the y-direction where j = grid.Ny\nbottom, right end point in the z-direction where k = 1\ntop, right end point in the z-direction where k = grid.Nz\nimmersed: boundary between solid and fluid for immersed boundaries\n\nIf a boundary condition is unspecified, the default for auxiliary fields and the topology in the boundary-normal direction is used:\n\nPeriodicBoundaryCondition for Periodic directions\nGradientBoundaryCondition(0) for Bounded directions and Centered-located fields\nnothing for Bounded directions and Face-located fields\nnothing for Flat directions and/or Nothing-located fields\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.BoundaryConditions.FieldBoundaryConditions-2","page":"Library","title":"Oceananigans.BoundaryConditions.FieldBoundaryConditions","text":"FieldBoundaryConditions(; kwargs...)\n\nReturn a template for boundary conditions on prognostic fields.\n\nKeyword arguments\n\nKeyword arguments specify boundary conditions on the 7 possible boundaries:\n\nwest: left end point in the x-direction where i = 1\neast: right end point in the x-direction where i = grid.Nx\nsouth: left end point in the y-direction where j = 1\nnorth: right end point in the y-direction where j = grid.Ny\nbottom: right end point in the z-direction where k = 1\ntop: right end point in the z-direction where k = grid.Nz\nimmersed: boundary between solid and fluid for immersed boundaries\n\nIf a boundary condition is unspecified, the default for prognostic fields and the topology in the boundary-normal direction is used:\n\nPeriodicBoundaryCondition for Periodic directions\nNoFluxBoundaryCondition for Bounded directions and Centered-located fields\nImpenetrableBoundaryCondition for Bounded directions and Face-located fields\nnothing for Flat directions and/or Nothing-located fields\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.BoundaryConditions.Flux","page":"Library","title":"Oceananigans.BoundaryConditions.Flux","text":"struct Flux <: AbstractBoundaryConditionClassification\n\nA classification specifying a boundary condition on the flux of a field.\n\nThe sign convention is such that a positive flux represents the flux of a quantity in the positive direction. For example, a positive vertical flux implies a quantity is fluxed upwards, in the +z direction.\n\nDue to this convention, a positive flux applied to the top boundary specifies that a quantity is fluxed upwards across the top boundary and thus out of the domain. As a result, a positive flux applied to a top boundary leads to a reduction of that quantity in the interior of the domain; for example, a positive, upwards flux of heat at the top of the domain acts to cool the interior of the domain. Conversely, a positive flux applied to the bottom boundary leads to an increase of the quantity in the interior of the domain. The same logic holds for east, west, north, and south boundaries.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.BoundaryConditions.Gradient","page":"Library","title":"Oceananigans.BoundaryConditions.Gradient","text":"struct Gradient <: AbstractBoundaryConditionClassification\n\nA classification specifying a boundary condition on the derivative or gradient of a field. Also called a Neumann boundary condition.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.BoundaryConditions.Open","page":"Library","title":"Oceananigans.BoundaryConditions.Open","text":"struct Open <: AbstractBoundaryConditionClassification\n\nA classification that specifies the halo regions of a field directly.\n\nFor fields located at Faces, Open also specifies field value on the boundary.\n\nOpen boundary conditions are used to specify the component of a velocity field normal to a boundary and can also be used to describe nested or linked simulation domains.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.BoundaryConditions.PerturbationAdvection","page":"Library","title":"Oceananigans.BoundaryConditions.PerturbationAdvection","text":"PerturbationAdvection(FT = defaults.FloatType;\n                      outflow_timescale = Inf,\n                      inflow_timescale = 0)\n\nCreate a PerturbationAdvection scheme to be used with an OpenBoundaryCondition. This scheme will nudge the boundary velocity to the OpenBoundaryCondition's exterior value val, using a time-scale inflow_timescale for inflow and outflow_timescale for outflow.\n\nFor cases where we assume that the internal flow is a small perturbation from an external prescribed or coarser flow, we can split the velocity into background and perturbation components.\n\nWe begin with the equation governing the fluid in the interior:     âˆ‚â‚œu + uâ‹…âˆ‡u = âˆ’âˆ‡P + F, and note that on the boundary the pressure gradient is zero. We can then assume that the flow composes of mean (Uâƒ—) and pertubation (uâƒ—â€²) components, and considering the x-component of velocity, we can rewrite the equation as     âˆ‚â‚œuâ‚ = -uâ‚âˆ‚â‚u - uâ‚‚âˆ‚â‚‚uâ‚ - uâ‚ƒâˆ‚â‚ƒuâ‚ + Fâ‚ â‰ˆ - Uâ‚âˆ‚â‚uâ‚â€² - Uâ‚‚âˆ‚â‚‚uâ‚â€² - Uâ‚ƒâˆ‚â‚ƒuâ‚â€² + F.\n\nSimplify by assuming that Uâƒ— = UxÌ‚, an then take a numerical step to find uâ‚.\n\nWhen the boundaries are filled the interior is at time tâ‚™â‚Šâ‚ so we can take a backwards euler step (in the case that the mean flow is boundary normal) on a right boundary:     (Uâ¿âºÂ¹ - Uâ¿) / Î”t + (uâ€²â¿âºÂ¹ - uâ€²â¿) / Î”t = - Uâ¿âºÂ¹ (uâ€²â¿âºÂ¹áµ¢ - uâ€²â¿âºÂ¹áµ¢â‚‹â‚) / Î”x + Fáµ¤.\n\nThis can not be solved for general forcing, but if we assume the dominant forcing is relaxation to the mean velocity (i.e. uâ€²â†’0) then Fáµ¤ = -uâ€² / Ï„ then we can find uâ€²â¿âºÂ¹:     uâ€²â¿âºÂ¹ = (uâ¿ + UÌƒuâ€²â¿âºÂ¹áµ¢â‚‹â‚ - Uâ¿âºÂ¹) / (1 + UÌƒ + Î”t/Ï„),\n\nwhere UÌƒ = U Î”t / Î”x, then uâ¿âºÂ¹ is:     uâ¿âºÂ¹ = (uáµ¢â¿ + UÌƒuáµ¢â‚‹â‚â¿âºÂ¹ + Uâ¿âºÂ¹Ï„Ìƒ) / (1 + Ï„Ìƒ + UÌƒ)\n\nwhere Ï„Ìƒ = Î”t/Ï„.\n\nThe same operation can be repeated for left boundaries.\n\nThe relaxation timescale Ï„ can be set to different values depending on whether U points in or out of the domain (inflow_timescale/outflow_timescale). Since the scheme is only valid when the flow is directed out of the domain the boundary condition falls back to relaxation to the prescribed value. By default this happens instantly but if the direction varies this may not be preferable. It is beneficial to relax the outflow (i.e. non-zero outflow_timescale) to reduce the shock when the flow changes direction to point into the domain.\n\nThe ideal value of the timescales probably depend on the grid spacing and details of the boundary flow.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.BoundaryConditions.Value","page":"Library","title":"Oceananigans.BoundaryConditions.Value","text":"struct Value <: AbstractBoundaryConditionClassification\n\nA classification specifying a boundary condition on the value of a field. Also called a Dirchlet boundary condition.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.BoundaryConditions.compute_x_bcs!-Tuple{Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any, Oceananigans.Architectures.AbstractArchitecture, Vararg{Any}}","page":"Library","title":"Oceananigans.BoundaryConditions.compute_x_bcs!","text":"Apply flux boundary conditions to a field c by adding the associated flux divergence to the source term Gc at the left and right.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.BoundaryConditions.compute_y_bcs!-Tuple{Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any, Oceananigans.Architectures.AbstractArchitecture, Vararg{Any}}","page":"Library","title":"Oceananigans.BoundaryConditions.compute_y_bcs!","text":"Apply flux boundary conditions to a field c by adding the associated flux divergence to the source term Gc at the left and right.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.BoundaryConditions.compute_z_bcs!-Tuple{Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any, Oceananigans.Architectures.AbstractArchitecture, Vararg{Any}}","page":"Library","title":"Oceananigans.BoundaryConditions.compute_z_bcs!","text":"Apply flux boundary conditions to a field c by adding the associated flux divergence to the source term Gc at the top and bottom.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.BoundaryConditions.fill_halo_regions!-Tuple{OffsetArrays.OffsetArray, Any, Any, Any, Any, Vararg{Any}}","page":"Library","title":"Oceananigans.BoundaryConditions.fill_halo_regions!","text":"Fill halo regions in x, y, and z for a given field's data.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Buoyancy-models","page":"Library","title":"Buoyancy models","text":"","category":"section"},{"location":"appendix/library/#Oceananigans.BuoyancyFormulations.BuoyancyForce-Tuple{Any}","page":"Library","title":"Oceananigans.BuoyancyFormulations.BuoyancyForce","text":"BuoyancyForce(formulation; gravity_unit_vector=NegativeZDirection())\n\nConstruct a buoyancy given a buoyancy model. Optional keyword argument gravity_unit_vector can be used to specify the direction of gravity (default NegativeZDirection()). The buoyancy acceleration acts in the direction opposite to gravity.\n\nExample\n\nusing Oceananigans\n\ngrid = RectilinearGrid(size=(1, 8, 8), extent=(1, 1, 1))\n\nÎ¸ = 45 # degrees\ngÌƒ = (0, -sind(Î¸), -cosd(Î¸))\n\nbuoyancy = BuoyancyForce(BuoyancyTracer(), gravity_unit_vector=gÌƒ)\n\nmodel = NonhydrostaticModel(; grid, buoyancy, tracers=:b)\n\n# output\n\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 1Ã—8Ã—8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1Ã—3Ã—3 halo\nâ”œâ”€â”€ timestepper: RungeKutta3TimeStepper\nâ”œâ”€â”€ advection scheme: Centered(order=2)\nâ”œâ”€â”€ tracers: b\nâ”œâ”€â”€ closure: Nothing\nâ”œâ”€â”€ buoyancy: BuoyancyTracer with gÌ‚ = (0.0, -0.707107, -0.707107)\nâ””â”€â”€ coriolis: Nothing\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.BuoyancyFormulations.BuoyancyTracer","page":"Library","title":"Oceananigans.BuoyancyFormulations.BuoyancyTracer","text":"BuoyancyTracer <: AbstractBuoyancyFormulation{Nothing}\n\nType indicating that the tracer b represents buoyancy.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.BuoyancyFormulations.LinearEquationOfState","page":"Library","title":"Oceananigans.BuoyancyFormulations.LinearEquationOfState","text":"LinearEquationOfState([FT=Float64;] thermal_expansion=1.67e-4, haline_contraction=7.80e-4)\n\nReturn LinearEquationOfState for SeawaterBuoyancy with thermal_expansion coefficient and haline_contraction coefficient. The buoyancy perturbation b for LinearEquationOfState is\n\n    b = g (Î± T - Î² S)\n\nwhere g is gravitational acceleration, Î± is thermal_expansion, Î² is haline_contraction, T is temperature, and S is practical salinity units.\n\nDefault constants in units inverse Kelvin and practical salinity units for thermal_expansion and haline_contraction, respectively, are taken from Table 1.2 (page 33) of Vallis, \"Atmospheric and Oceanic Fluid Dynamics: Fundamentals and Large-Scale Circulation\" (2nd ed, 2017).\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.BuoyancyFormulations.LinearEquationOfState-2","page":"Library","title":"Oceananigans.BuoyancyFormulations.LinearEquationOfState","text":"LinearEquationOfState{FT} <: AbstractEquationOfState\n\nLinear equation of state for seawater.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.BuoyancyFormulations.SeawaterBuoyancy","page":"Library","title":"Oceananigans.BuoyancyFormulations.SeawaterBuoyancy","text":"SeawaterBuoyancy([FT = Float64;]\n                 gravitational_acceleration = Oceananigans.defaults.gravitational_acceleration,\n                 equation_of_state = LinearEquationOfState(FT),\n                 constant_temperature = nothing,\n                 constant_salinity = nothing)\n\nReturn parameters for a temperature- and salt-stratified seawater buoyancy model with a gravitational_acceleration constant (typically called g), and an equation_of_state that related temperature and salinity (or conservative temperature and absolute salinity) to density anomalies and buoyancy.\n\nSetting constant_temperature to something that is not nothing indicates that buoyancy depends only on salinity. For a nonlinear equation of state, the value provided constant_temperature is used as the temperature of the system. Vice versa, setting constant_salinity indicates that buoyancy depends only on temperature.\n\nFor a linear equation of state, the values of constant_temperature or constant_salinity are irrelevant.\n\nExamples\n\nThe \"TEOS10\" equation of state, see https://www.teos-10.org\n\njulia> using SeawaterPolynomials.TEOS10: TEOS10EquationOfState\n\njulia> teos10 = TEOS10EquationOfState()\nBoussinesqEquationOfState{Float64}:\nâ”œâ”€â”€ seawater_polynomial: TEOS10SeawaterPolynomial{Float64}\nâ””â”€â”€ reference_density: 1020.0\n\nBuoyancy that depends on both temperature and salinity\n\njulia> using Oceananigans\n\njulia> buoyancy = SeawaterBuoyancy(equation_of_state=teos10)\nSeawaterBuoyancy{Float64}:\nâ”œâ”€â”€ gravitational_acceleration: 9.80665\nâ””â”€â”€ equation_of_state: BoussinesqEquationOfState{Float64}\n\nBuoyancy that depends only on salinity with temperature held at 20 degrees Celsius\n\njulia> salinity_dependent_buoyancy = SeawaterBuoyancy(equation_of_state=teos10, constant_temperature=20)\nSeawaterBuoyancy{Float64}:\nâ”œâ”€â”€ gravitational_acceleration: 9.80665\nâ”œâ”€â”€ constant_temperature: 20.0\nâ””â”€â”€ equation_of_state: BoussinesqEquationOfState{Float64}\n\nBuoyancy that depends only on temperature with salinity held at 35 psu\n\njulia> temperature_dependent_buoyancy = SeawaterBuoyancy(equation_of_state=teos10, constant_salinity=35)\nSeawaterBuoyancy{Float64}:\nâ”œâ”€â”€ gravitational_acceleration: 9.80665\nâ”œâ”€â”€ constant_salinity: 35.0\nâ””â”€â”€ equation_of_state: BoussinesqEquationOfState{Float64}\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.BuoyancyFormulations.SeawaterBuoyancy-2","page":"Library","title":"Oceananigans.BuoyancyFormulations.SeawaterBuoyancy","text":"SeawaterBuoyancy{FT, EOS, T, S} <: AbstractBuoyancyFormulation{EOS}\n\nBuoyancy formulation for seawater. T and S are either nothing if both temperature and salinity are active, or of type FT if temperature or salinity are constant, respectively.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.BuoyancyFormulations.âˆ‚x_b-Tuple{Any, Any, Any, Any, SeawaterBuoyancy, Any}","page":"Library","title":"Oceananigans.BuoyancyFormulations.âˆ‚x_b","text":"âˆ‚x_b(i, j, k, grid, b::SeawaterBuoyancy, C)\n\nReturns the x-derivative of buoyancy for temperature and salt-stratified water,\n\n_x b = g ( Î± _x T - Î² _x S ) \n\nwhere g is gravitational acceleration, Î± is the thermal expansion coefficient, Î² is the haline contraction coefficient, T is conservative temperature, and S is absolute salinity.\n\nNote: In Oceananigans, model.tracers.T is conservative temperature and model.tracers.S is absolute salinity.\n\nNote that _x T (âˆ‚x_T), _x S (âˆ‚x_S), Î±, and Î² are all evaluated at cell interfaces in x and cell centers in y and z.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.BuoyancyFormulations.âˆ‚y_b-Tuple{Any, Any, Any, Any, SeawaterBuoyancy, Any}","page":"Library","title":"Oceananigans.BuoyancyFormulations.âˆ‚y_b","text":"âˆ‚y_b(i, j, k, grid, b::SeawaterBuoyancy, C)\n\nReturns the y-derivative of buoyancy for temperature and salt-stratified water,\n\n_y b = g ( Î± _y T - Î² _y S ) \n\nwhere g is gravitational acceleration, Î± is the thermal expansion coefficient, Î² is the haline contraction coefficient, T is conservative temperature, and S is absolute salinity.\n\nNote: In Oceananigans, model.tracers.T is conservative temperature and model.tracers.S is absolute salinity.\n\nNote that _y T (âˆ‚y_T), _y S (âˆ‚y_S), Î±, and Î² are all evaluated at cell interfaces in y and cell centers in x and z.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.BuoyancyFormulations.âˆ‚z_b-Tuple{Any, Any, Any, Any, SeawaterBuoyancy, Any}","page":"Library","title":"Oceananigans.BuoyancyFormulations.âˆ‚z_b","text":"âˆ‚z_b(i, j, k, grid, b::SeawaterBuoyancy, C)\n\nReturns the vertical derivative of buoyancy for temperature and salt-stratified water,\n\n_z b = N^2 = g ( Î± _z T - Î² _z S ) \n\nwhere g is gravitational acceleration, Î± is the thermal expansion coefficient, Î² is the haline contraction coefficient, T is conservative temperature, and S is absolute salinity.\n\nNote: In Oceananigans, model.tracers.T is conservative temperature and model.tracers.S is absolute salinity.\n\nNote that _z T (âˆ‚z_T), _z S (âˆ‚z_S), Î±, and Î² are all evaluated at cell interfaces in z and cell centers in x and y.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Coriolis","page":"Library","title":"Coriolis","text":"","category":"section"},{"location":"appendix/library/#Oceananigans.Coriolis.BetaPlane","page":"Library","title":"Oceananigans.Coriolis.BetaPlane","text":"BetaPlane([FT=Float64;] fâ‚€=nothing, Î²=nothing,\n          rotation_rate=Oceananigans.defaults.planet_rotation_rate,\n          latitude=nothing, radius=Oceananigans.defaults.planet_radius)\n\nReturn a Î²-plane Coriolis parameter, f = fâ‚€ + Î² y with floating-point type FT.\n\nThe user may specify both fâ‚€ and Î², or the three parameters rotation_rate, latitude (in degrees), and radius that specify the rotation rate and radius of a planet, and the central latitude (where y = 0) at which the Î²-plane approximation is to be made.\n\nIf fâ‚€ and Î² are not specified, they are calculated from rotation_rate, latitude, and radius according to the relations fâ‚€ = 2 * rotation_rate * sind(latitude) and Î² = 2 * rotation_rate * cosd(latitude) / radius.\n\nBy default, the rotation_rate and planet radius are assumed to be Earth's.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Coriolis.ConstantCartesianCoriolis","page":"Library","title":"Oceananigans.Coriolis.ConstantCartesianCoriolis","text":"ConstantCartesianCoriolis([FT=Float64;] fx=nothing, fy=nothing, fz=nothing,\n                          f=nothing, rotation_axis=ZDirection(),\n                          rotation_rate=Oceananigans.defaults.planet_rotation_rate,\n                          latitude=nothing)\n\nReturn a parameter object for a constant rotation decomposed into the x, y, and z directions. In oceanography the components x, y, z correspond to the directions east, north, and up. This constant rotation can be specified in three different ways:\n\nSpecifying all components fx, fy and fz directly.\nSpecifying the Coriolis parameter f and (optionally) a rotation_axis (which defaults to the z direction if not specified).\nSpecifying latitude (in degrees) and (optionally) a rotation_rate in radians per second (which defaults to Earth's rotation rate).\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Coriolis.ConstantCartesianCoriolis-2","page":"Library","title":"Oceananigans.Coriolis.ConstantCartesianCoriolis","text":"struct ConstantCartesianCoriolis{FT} <: AbstractRotation\n\nA Coriolis implementation that accounts for the locally vertical and possibly both local horizontal components of a constant rotation vector. This is a more general implementation of FPlane, which only accounts for the locally vertical component.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Coriolis.FPlane","page":"Library","title":"Oceananigans.Coriolis.FPlane","text":"FPlane([FT = Oceananigans.defaults.FloatType;]\n       f = nothing,\n       rotation_rate = Oceananigans.defaults.planet_rotation_rate,\n       latitude = nothing)\n\nReturn a parameter object for constant rotation at the angular frequency f/2, and therefore with background vorticity f, around a vertical axis. If f is not specified, it is calculated from rotation_rate and latitude (in degrees) according to the relation f = 2 * rotation_rate * sind(latitude).\n\nBy default, rotation_rate is assumed to be Earth's.\n\nAlso called FPlane, after the \"f-plane\" approximation for the local effect of a planet's rotation in a planar coordinate system tangent to the planet's surface.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Coriolis.FPlane-2","page":"Library","title":"Oceananigans.Coriolis.FPlane","text":"struct FPlane{FT} <: AbstractRotation\n\nA parameter object for constant rotation around a vertical axis.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Coriolis.HydrostaticSphericalCoriolis","page":"Library","title":"Oceananigans.Coriolis.HydrostaticSphericalCoriolis","text":"struct HydrostaticSphericalCoriolis{S, FT} <: AbstractRotation\n\nA parameter object for constant rotation around a vertical axis on the sphere.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Coriolis.HydrostaticSphericalCoriolis-Union{Tuple{}, Tuple{DataType}, Tuple{S}} where S","page":"Library","title":"Oceananigans.Coriolis.HydrostaticSphericalCoriolis","text":"HydrostaticSphericalCoriolis([FT=Float64;]\n                             rotation_rate = Oceananigans.defaults.planet_rotation_rate,\n                             scheme = EnstrophyConserving())\n\nReturn a parameter object for Coriolis forces on a sphere rotating at rotation_rate.\n\nKeyword arguments\n\nrotation_rate: Sphere's rotation rate;  default: Oceananigans.defaults.planet_rotation_rate.\nscheme: Either EnergyConserving(), EnstrophyConserving(), or EnstrophyConserving() (default).\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Coriolis.NonTraditionalBetaPlane","page":"Library","title":"Oceananigans.Coriolis.NonTraditionalBetaPlane","text":"NonTraditionalBetaPlane([FT = Oceananigans.defaults.FloatType;]\n                        fz = nothing,\n                        fy = nothing,\n                        Î² = nothing,\n                        Î³ = nothing,\n                        rotation_rate = Oceananigans.defaults.planet_rotation_rate,\n                        latitude = nothing,\n                        radius = Oceananigans.defaults.planet_radius)\n\nThe user may directly specify fz, fy, Î², Î³, and radius or the three parameters rotation_rate, latitude (in degrees), and radius that specify the rotation rate and radius of a planet, and the central latitude (where y = 0) at which the non-traditional Î²-plane approximation is to be made.\n\nIf fz, fy, Î², and Î³ are not specified, they are calculated from rotation_rate, latitude, and radius according to the relations fz = 2 * rotation_rate * sind(latitude), fy = 2 * rotation_rate * cosd(latitude), Î² = 2 * rotation_rate * cosd(latitude) / radius, and Î³ = - 4 * rotation_rate * sind(latitude) / radius.\n\nBy default, the rotation_rate and planet radius is assumed to be Earth's.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Coriolis.NonTraditionalBetaPlane-2","page":"Library","title":"Oceananigans.Coriolis.NonTraditionalBetaPlane","text":"struct NonTraditionalBetaPlane{FT} <: AbstractRotation\n\nA Coriolis implementation that accounts for the latitudinal variation of both the locally vertical and the locally horizontal components of the rotation vector. The \"traditional\" approximation in ocean models accounts for only the locally vertical component of the rotation vector (see BetaPlane).\n\nThis implementation is based off of section 5 of paper by Dellar (2011) and it conserves energy, angular momentum, and potential vorticity.\n\nReferences\n\nDellar, P. (2011). Variations on a beta-plane: Derivation of non-traditional     beta-plane equations from Hamilton's principle on a sphere. Journal of     Fluid Mechanics, 674, 174-195. doi:10.1017/S0022112010006464\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Diagnostics","page":"Library","title":"Diagnostics","text":"","category":"section"},{"location":"appendix/library/#Oceananigans.Diagnostics.CFL","page":"Library","title":"Oceananigans.Diagnostics.CFL","text":"struct CFL{D, S}\n\nAn object for computing the Courant-Freidrichs-Lewy (CFL) number.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Diagnostics.CFL-Tuple{Any}","page":"Library","title":"Oceananigans.Diagnostics.CFL","text":"CFL(Î”t [, timescale = Oceananigans.Advection.cell_advection_timescale])\n\nReturn an object for computing the Courant-Freidrichs-Lewy (CFL) number associated with time step Î”t or TimeStepWizard and timescale.\n\nSee also AdvectiveCFL and DiffusiveCFL.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Diagnostics.StateChecker-Tuple{Any}","page":"Library","title":"Oceananigans.Diagnostics.StateChecker","text":"StateChecker(; schedule, fields)\n\nReturns a StateChecker that logs field information (minimum, maximum, mean) for each field in a named tuple of fields when schedule actuates.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Diagnostics.AdvectiveCFL-Tuple{Any}","page":"Library","title":"Oceananigans.Diagnostics.AdvectiveCFL","text":"AdvectiveCFL(Î”t)\n\nReturn an object for computing the Courant-Freidrichs-Lewy (CFL) number associated with time step Î”t or TimeStepWizard and the time scale for advection across a cell. The advective CFL is, e.g., U Î”t  Î”x.\n\nExample\n\njulia> using Oceananigans\n\njulia> model = NonhydrostaticModel(grid = RectilinearGrid(size=(16, 16, 16), extent=(8, 8, 8)));\n\njulia> Î”t = 1.0;\n\njulia> cfl = AdvectiveCFL(Î”t);\n\njulia> model.velocities.u .= Ï€;\n\njulia> cfl(model)\n6.283185307179586\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Diagnostics.DiffusiveCFL-Tuple{Any}","page":"Library","title":"Oceananigans.Diagnostics.DiffusiveCFL","text":"DiffusiveCFL(Î”t)\n\nReturns an object for computing the diffusive Courant-Freidrichs-Lewy (CFL) number associated with time step Î”t or TimeStepWizard and the time scale for diffusion across a cell associated with model.closure.  The diffusive CFL, e.g., for viscosity is Î½ Î”t  Î”xÂ².\n\nThe maximum diffusive CFL number among viscosity and all tracer diffusivities is returned.\n\nExample\n\njulia> using Oceananigans\n\njulia> model = NonhydrostaticModel(grid = RectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1)),\n                                   closure = ScalarDiffusivity(; Î½ = 1e-2));\n\njulia> Î”t = 0.1;\n\njulia> dcfl = DiffusiveCFL(Î”t);\n\njulia> dcfl(model)\n0.256\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Distributed","page":"Library","title":"Distributed","text":"","category":"section"},{"location":"appendix/library/#Oceananigans.DistributedComputations.Distributed","page":"Library","title":"Oceananigans.DistributedComputations.Distributed","text":"Distributed(child_architecture = CPU();\n            partition = Partition(MPI.Comm_size(communicator)),\n            devices = nothing,\n            communicator = MPI.COMM_WORLD,\n            synchronized_communication = false)\n\nReturn a distributed architecture that uses MPI for communications.\n\nPositional arguments\n\nchild_architecture: Specifies whether the computation is performed on CPUs or GPUs.                       Default: CPU().\n\nKeyword arguments\n\npartition: A Partition specifying the total processors in the x, y, and z direction.              Note that support for distributed z direction is  limited; we strongly suggest              using partition with z = 1 kwarg.\ndevices: GPU device linked to local rank. The GPU will be assigned based on the            local node rank as such devices[node_rank]. Make sure to run --ntasks-per-node <= --gres=gpu.            If nothing, the devices will be assigned automatically based on the available resources.            This argument is irrelevant if child_architecture = CPU().\ncommunicator: the MPI communicator that orchestrates data transfer between nodes.                 Default: MPI.COMM_WORLD.\nsynchronized_communication: This keyword argument can be used to control downstream code behavior.                               If true, then downstream code may use this tag to toggle between an algorithm                               that permits communication between nodes \"asynchronously\" with other computations,                               and an alternative serial algorithm in which communication and computation are                               \"synchronous\" (that is, performed one after the other).                               Default: false, specifying the use of asynchronous algorithms where supported,                               which may result in faster time-to-solution.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.DistributedComputations.DistributedFFTBasedPoissonSolver","page":"Library","title":"Oceananigans.DistributedComputations.DistributedFFTBasedPoissonSolver","text":"DistributedFFTBasedPoissonSolver(global_grid, local_grid)\n\nReturn an FFT-based solver for the Poisson equation,\n\nÂ²Ï† = b\n\nfor Distributed architectures.\n\nSupported configurations\n\nIn the following, Nx, Ny, and Nz are the number of grid points of the global grid, in the x, y, and z directions, while Rx, Ry, and Rz are the number of ranks in the x, y, and z directions, respectively. Furthermore, 'pencil' decomposition refers to a domain decomposed in two different directions (i.e., with Rx != 1 and Ry != 1), while 'slab' decomposition refers to a domain decomposed only in one direction, (i.e., with either Rx == 1 or Ry == 1). Additionally, storage indicates the TransposableField used for storing intermediate results; see TransposableField.\n\nThree dimensional grids with pencil decompositions in (x y) such the:\n\nthe z direction is local, Ny â‰¥ Rx and Ny % Rx = 0, and Nz â‰¥ Ry and Nz % Ry = 0.\n\nTwo dimensional grids decomposed in x where Ny â‰¥ Rx and Ny % Rx = 0.\n\nwarning: Unsupported decompositions\nAny configuration decomposed in z direction is not supported. Furthermore, any (x y) decompositions other than the configurations mentioned above are also not supported.\n\nAlgorithm for pencil decompositions\n\nFor pencil decompositions (useful for three-dimensional problems), there are three forward transforms, three backward transforms, and four transpositions that require MPI communication. In the algorithm below, the first dimension is always the local dimension. In our implementation we require Nz â‰¥ Ry and Nx â‰¥ Ry with the additional constraint that Nz % Ry = 0 and Ny % Rx = 0.\n\nstorage.zfield, partitioned over (x y) is initialized with the rhs that is b.\nTransform along z.\n\n3  Transpose storage.zfield + communicate to storage.yfield partitioned into (Rx, Ry) processes in (x z).\n\nTransform along y.\nTranspose storage.yfield + communicate to storage.xfield partitioned into (Rx, Ry) processes in (y z).\nTransform in x.\n\nAt this point the three in-place forward transforms are complete, and we solve the Poisson equation by updating storage.xfield. Then the process is reversed to obtain storage.zfield in physical space partitioned over (x y).\n\nAlgorithm for stencil decompositions\n\nThe stecil decomposition algorithm works in the same manner as the pencil decompostion described above while skipping the transposes that are not required. For example if the domain is decomposed in x, step 3 in the above algorithm is skipped (and the associated transposition step in the bakward transform)\n\nRestrictions\n\nPencil decomopositions:\nNy â‰¥ Rx and Ny % Rx = 0\nNz â‰¥ Ry and Nz % Ry = 0\nIf the z direction is Periodic, also the y and the x directions must be Periodic\nIf the y direction is Periodic, also the x direction must be Periodic\nStencil decomposition:\nsame as for pencil decompositions with Rx (or Ry) equal to one\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.DistributedComputations.Equal","page":"Library","title":"Oceananigans.DistributedComputations.Equal","text":"Equal()\n\nReturn a type that partitions a direction equally among remaining processes.\n\nEqual() can be used for only one direction. Other directions must either be unspecified, or specifically defined by Int, Fractional, or Sizes.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.DistributedComputations.Fractional-Tuple","page":"Library","title":"Oceananigans.DistributedComputations.Fractional","text":"Fractional(Ïµâ‚, Ïµâ‚‚, ..., Ïµâ‚™)\n\nReturn a type that partitions a direction unequally. The total work is W = sum(Ïµáµ¢), and each process is then allocated Ïµáµ¢ / W of the domain.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.DistributedComputations.Partition-Tuple{Any}","page":"Library","title":"Oceananigans.DistributedComputations.Partition","text":"Partition(; x = 1, y = 1, z = 1)\n\nReturn Partition representing the division of a domain in the x (first), y (second) and z (third) dimension\n\nKeyword arguments:\n\nx: partitioning of the first dimension\ny: partitioning of the second dimension\nz: partitioning of the third dimension\n\nif supplied as positional arguments x will be the first argument, y the second and z the third\n\nx, y and z can be:\n\nx::Int: allocate x processors to the first dimension\nEqual(): divide the domain in x equally among the remaining processes (not supported for multiple directions)\nFractional(Ïµâ‚, Ïµâ‚‚, ..., Ïµâ‚™): divide the domain unequally among N processes. The total work is W = sum(Ïµáµ¢),                                and each process is then allocated Ïµáµ¢ / W of the domain.\nSizes(nâ‚, nâ‚‚, ..., nâ‚™): divide the domain unequally. The total work is W = sum(náµ¢),                           and each process is then allocated náµ¢.\n\nExamples:\n\njulia> using Oceananigans; using Oceananigans.DistributedComputations\n\njulia> Partition(1, 4)\nPartition across 4 = 1Ã—4Ã—1 ranks:\nâ””â”€â”€ y: 4\n\njulia> Partition(x = Fractional(1, 2, 3, 4))\nPartition across 4 = 4Ã—1Ã—1 ranks:\nâ””â”€â”€ x: Fractional(0.1, 0.2, 0.3, 0.4)\n\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.DistributedComputations.partition-Tuple{AbstractArray, Oceananigans.DistributedComputations.Distributed, Any}","page":"Library","title":"Oceananigans.DistributedComputations.partition","text":"partition(A, arch, local_size)\n\nPartition the globally-sized A into local arrays with local_size on architecture.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.DistributedComputations.partition-Tuple{Any, Field}","page":"Library","title":"Oceananigans.DistributedComputations.partition","text":"partition(A, b)\n\nPartition the globally-sized A into local arrays with the same size as b.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.DistributedComputations.reconstruct_global_grid-Tuple{RectilinearGrid{FT, TX, TY, TZ, CZ, FX, FY, VX, VY, <:Oceananigans.DistributedComputations.Distributed} where {FT, TX, TY, TZ, CZ, FX, FY, VX, VY}}","page":"Library","title":"Oceananigans.DistributedComputations.reconstruct_global_grid","text":"reconstruct_global_grid(grid::DistributedGrid)\n\nReturn the global grid on child_architecture(grid)\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.DistributedComputations.@distribute-Tuple{Any, Any}","page":"Library","title":"Oceananigans.DistributedComputations.@distribute","text":"@distribute communicator for i in iterable\n    ...\nend\n\nDistribute a for loop among different ranks in communicator. If communicator is not provided, MPI.COMM_WORLD is used.\n\n\n\n\n\n","category":"macro"},{"location":"appendix/library/#Oceananigans.DistributedComputations.@handshake-Tuple{Any, Any}","page":"Library","title":"Oceananigans.DistributedComputations.@handshake","text":"@handshake communicator exp...\n\nPerform exp on all ranks in communicator, but only one rank at a time, that is ranks r2 > r1 wait for rank r1 to finish before executing exp. If communicator is not provided, MPI.COMM_WORLD is used.\n\n\n\n\n\n","category":"macro"},{"location":"appendix/library/#Oceananigans.DistributedComputations.@onrank-Tuple{Any, Any, Any}","page":"Library","title":"Oceananigans.DistributedComputations.@onrank","text":"@onrank communicator rank exp...\n\nPerform exp only on rank rank (0-based index) in communicator. Other ranks will wait for rank rank to finish before continuing. The expression is run anyways if MPI in not initialized. If communicator is not provided, MPI.COMM_WORLD is used.\n\n\n\n\n\n","category":"macro"},{"location":"appendix/library/#Oceananigans.DistributedComputations.@root-Tuple{Any, Any}","page":"Library","title":"Oceananigans.DistributedComputations.@root","text":"@root communicator exp...\n\nPerform exp only on rank 0 in communicator, otherwise known as the \"root\" rank. Other ranks will wait for the root rank to finish before continuing. If communicator is not provided, MPI.COMM_WORLD is used.\n\n\n\n\n\n","category":"macro"},{"location":"appendix/library/#Fields","page":"Library","title":"Fields","text":"","category":"section"},{"location":"appendix/library/#Oceananigans.Fields.AbstractField","page":"Library","title":"Oceananigans.Fields.AbstractField","text":"AbstractField{LX, LY, LZ, G, T, N}\n\nAbstract supertype for fields located at (LX, LY, LZ) and defined on a grid G with eltype T and N dimensions.\n\nNote: we need the parameter T to subtype AbstractArray.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Fields.Accumulation-Tuple{Any, Any}","page":"Library","title":"Oceananigans.Fields.Accumulation","text":"Accumulation(accumulate!, operand; dims)\n\nReturn a Accumulation of operand with accumulate!, where accumulate! can be called with\n\naccumulate!(field, operand; dims)\n\nto accumulate operand along dims and store in field.\n\nExample\n\nusing Oceananigans\n\nNx, Ny, Nz = 3, 3, 3\ngrid = RectilinearGrid(size=(Nx, Ny, Nz), x=(0, 1), y=(0, 1), z=(0, 1),\n                       topology=(Periodic, Periodic, Periodic))\n\nc = CenterField(grid)\nset!(c, (x, y, z) -> x + y + z)\ncumsum_cÂ² = Field(Accumulation(cumsum!, c^2, dims=3))\ncumsum_cÂ²[1:Nx, 1:Ny, 1:Nz]\n\n# output\n3Ã—3Ã—3 Array{Float64, 3}:\n[:, :, 1] =\n 0.25      0.694444  1.36111\n 0.694444  1.36111   2.25\n 1.36111   2.25      3.36111\n\n[:, :, 2] =\n 0.944444  2.05556  3.61111\n 2.05556   3.61111  5.61111\n 3.61111   5.61111  8.05556\n\n[:, :, 3] =\n 2.30556   4.30556   6.97222\n 4.30556   6.97222  10.3056\n 6.97222  10.3056   14.3056\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.Field-Union{Tuple{Oceananigans.Grids.AbstractGrid}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Oceananigans.Grids.AbstractGrid, DataType}} where {LX, LY, LZ}","page":"Library","title":"Oceananigans.Fields.Field","text":"Field{LX, LY, LZ}(grid::AbstractGrid,\n                  T::DataType=eltype(grid); kw...) where {LX, LY, LZ}\n\nConstruct a Field on grid with data type T at the location (LX, LY, LZ). Each of (LX, LY, LZ) is either Center or Face and determines the field's location in (x, y, z) respectively.\n\nKeyword arguments\n\ndata :: OffsetArray: An offset array with the fields data. If nothing is provided the field is filled with zeros.\nboundary_conditions: If nothing is provided, then field is created using the default boundary conditions via FieldBoundaryConditions.\nindices: Used to prescribe where a reduced field lives on. For example, at which k index does a two-dimensional x-y field lives on. Default: (:, :, :).\n\nExample\n\nA field at location (Face, Face, Center).\n\njulia> using Oceananigans\n\njulia> grid = RectilinearGrid(size=(2, 3, 4), extent=(1, 1, 1));\n\njulia> Ï‰ = Field{Face, Face, Center}(grid)\n2Ã—3Ã—4 Field{Face, Face, Center} on RectilinearGrid on CPU\nâ”œâ”€â”€ grid: 2Ã—3Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 2Ã—3Ã—3 halo\nâ”œâ”€â”€ boundary conditions: FieldBoundaryConditions\nâ”‚   â””â”€â”€ west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: Nothing\nâ””â”€â”€ data: 6Ã—9Ã—10 OffsetArray(::Array{Float64, 3}, -1:4, -2:6, -2:7) with eltype Float64 with indices -1:4Ã—-2:6Ã—-2:7\n    â””â”€â”€ max=0.0, min=0.0, mean=0.0\n\nNow, using indices we can create a two dimensional x-y field at location (Face, Face, Center) to compute, e.g., the vertical vorticity vx - uy at the fluid's surface z = 0, which for Center corresponds to k = Nz.\n\njulia> u = XFaceField(grid); v = YFaceField(grid);\n\njulia> Ï‰â‚› = Field(âˆ‚x(v) - âˆ‚y(u), indices=(:, :, grid.Nz))\n2Ã—3Ã—1 Field{Face, Face, Center} on RectilinearGrid on CPU\nâ”œâ”€â”€ grid: 2Ã—3Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 2Ã—3Ã—3 halo\nâ”œâ”€â”€ boundary conditions: FieldBoundaryConditions\nâ”‚   â””â”€â”€ west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: Nothing\nâ”œâ”€â”€ indices: (:, :, 4:4)\nâ”œâ”€â”€ operand: BinaryOperation at (Face, Face, Center)\nâ”œâ”€â”€ status: time=0.0\nâ””â”€â”€ data: 6Ã—9Ã—1 OffsetArray(::Array{Float64, 3}, -1:4, -2:6, 4:4) with eltype Float64 with indices -1:4Ã—-2:6Ã—4:4\n    â””â”€â”€ max=0.0, min=0.0, mean=0.0\n\njulia> compute!(Ï‰â‚›)\n2Ã—3Ã—1 Field{Face, Face, Center} on RectilinearGrid on CPU\nâ”œâ”€â”€ grid: 2Ã—3Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 2Ã—3Ã—3 halo\nâ”œâ”€â”€ boundary conditions: FieldBoundaryConditions\nâ”‚   â””â”€â”€ west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: Nothing\nâ”œâ”€â”€ indices: (:, :, 4:4)\nâ”œâ”€â”€ operand: BinaryOperation at (Face, Face, Center)\nâ”œâ”€â”€ status: time=0.0\nâ””â”€â”€ data: 6Ã—9Ã—1 OffsetArray(::Array{Float64, 3}, -1:4, -2:6, 4:4) with eltype Float64 with indices -1:4Ã—-2:6Ã—4:4\n    â””â”€â”€ max=0.0, min=0.0, mean=0.0\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.Reduction-Tuple{Any, Any}","page":"Library","title":"Oceananigans.Fields.Reduction","text":"Reduction(reduce!, operand; dims)\n\nReturn a Reduction of operand with reduce!, where reduce! can be called with\n\nreduce!(field, operand)\n\nto reduce operand along dims and store in field.\n\nExample\n\nusing Oceananigans\n\nNx, Ny, Nz = 3, 3, 3\ngrid = RectilinearGrid(size=(Nx, Ny, Nz), x=(0, 1), y=(0, 1), z=(0, 1),\n                       topology=(Periodic, Periodic, Periodic))\n\nc = CenterField(grid)\nset!(c, (x, y, z) -> x + y + z)\nmax_cÂ² = Field(Reduction(maximum!, c^2, dims=3))\nmax_cÂ²[1:Nx, 1:Ny]\n\n# output\n3Ã—3 Matrix{Float64}:\n 1.36111  2.25     3.36111\n 2.25     3.36111  4.69444\n 3.36111  4.69444  6.25\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.CenterField","page":"Library","title":"Oceananigans.Fields.CenterField","text":"CenterField(grid, T=eltype(grid); kw...)\n\nReturn a Field{Center, Center, Center} on grid. Additional keyword arguments are passed to the Field constructor.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.Fields.TracerFields-Tuple{@NamedTuple{}, Any, Any}","page":"Library","title":"Oceananigans.Fields.TracerFields","text":"Shortcut constructor for empty tracer fields.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.TracerFields-Tuple{Any, Any, Any}","page":"Library","title":"Oceananigans.Fields.TracerFields","text":"TracerFields(tracer_names, grid, user_bcs)\n\nReturn a NamedTuple with tracer fields specified by tracer_names initialized as CenterFields on grid. Boundary conditions user_bcs may be specified via a named tuple of FieldBoundaryConditions.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.TracerFields-Tuple{Any, Any}","page":"Library","title":"Oceananigans.Fields.TracerFields","text":"TracerFields(tracer_names, grid; kwargs...)\n\nReturn a NamedTuple with tracer fields specified by tracer_names initialized as CenterFields on grid. Fields may be passed via optional keyword arguments kwargs for each field.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.TracerFields-Tuple{NamedTuple, Any, Any}","page":"Library","title":"Oceananigans.Fields.TracerFields","text":"TracerFields(proposed_tracers::NamedTuple, grid, bcs)\n\nReturn a NamedTuple of tracers, overwriting boundary conditions in proposed_tracers with corresponding fields in the NamedTuple bcs.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.VelocityFields","page":"Library","title":"Oceananigans.Fields.VelocityFields","text":"VelocityFields(grid, user_bcs = NamedTuple())\n\nReturn a NamedTuple with fields u, v, w initialized on grid. Boundary conditions bcs may be specified via a named tuple of FieldBoundaryConditions.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.Fields.VelocityFields-Tuple{NamedTuple{(:u, :v, :w)}, Any, Any}","page":"Library","title":"Oceananigans.Fields.VelocityFields","text":"VelocityFields(proposed_velocities::NamedTuple{(:u, :v, :w)}, grid, bcs)\n\nReturn a NamedTuple of velocity fields, overwriting boundary conditions in proposed_velocities with corresponding fields in the NamedTuple bcs.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.XFaceField","page":"Library","title":"Oceananigans.Fields.XFaceField","text":"XFaceField(grid, T=eltype(grid); kw...)\n\nReturn a Field{Face, Center, Center} on grid. Additional keyword arguments are passed to the Field constructor.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.Fields.YFaceField","page":"Library","title":"Oceananigans.Fields.YFaceField","text":"YFaceField(grid, T=eltype(grid); kw...)\n\nReturn a Field{Center, Face, Center} on grid. Additional keyword arguments are passed to the Field constructor.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.Fields.ZFaceField","page":"Library","title":"Oceananigans.Fields.ZFaceField","text":"ZFaceField(grid, T=eltype(grid); kw...)\n\nReturn a Field{Center, Center, Face} on grid. Additional keyword arguments are passed to the Field constructor.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.Fields.compute!","page":"Library","title":"Oceananigans.Fields.compute!","text":"compute!(field)\n\nComputes field.data from field.operand.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.Fields.field-Tuple{Any, AbstractArray, Any}","page":"Library","title":"Oceananigans.Fields.field","text":"field(loc, a, grid)\n\nBuild a field from array a at loc and on grid.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.interior-Tuple{Field}","page":"Library","title":"Oceananigans.Fields.interior","text":"interior(f::Field)\n\nReturn a view of f that excludes halo points.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.interpolate-NTuple{4, Any}","page":"Library","title":"Oceananigans.Fields.interpolate","text":"interpolate(at_node, from_field, from_loc, from_grid)\n\nInterpolate from_field, at_node, on from_grid and at from_location, where at_node is a tuple of coordinates and and from_loc = (â„“x, â„“y, â„“z).\n\nNote that this is a lower-level interpolate method defined for use in CPU/GPU kernels.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.interpolate-Tuple{Any, Any}","page":"Library","title":"Oceananigans.Fields.interpolate","text":"interpolate(to_node, from_field)\n\nInterpolate field to the physical point (x, y, z) using trilinear interpolation.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.regrid!-Tuple{Any, Any}","page":"Library","title":"Oceananigans.Fields.regrid!","text":"regrid!(dst_field, src_field)\n\nRegrid src_field onto the grid of dst_field.\n\nExample\n\nGenerate a tracer field on a vertically stretched grid and regrid it on a regular grid.\n\nusing Oceananigans\n\nNz, Lz = 2, 1.0\ntopology = (Flat, Flat, Bounded)\n\ninput_grid = RectilinearGrid(size=Nz, z = [0, Lz/3, Lz], topology=topology, halo=1)\ninput_field = CenterField(input_grid)\ninput_field[1, 1, 1:Nz] = [2, 3]\n\noutput_grid = RectilinearGrid(size=Nz, z=(0, Lz), topology=topology, halo=1)\noutput_field = CenterField(output_grid)\n\nregrid!(output_field, input_field)\n\noutput_field[1, 1, :]\n\n# output\n4-element OffsetArray(::Vector{Float64}, 0:3) with eltype Float64 with indices 0:3:\n 0.0\n 2.333333333333333\n 3.0\n 0.0\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.location-Tuple{Any}","page":"Library","title":"Oceananigans.location","text":"Return the location (LX, LY, LZ) of an AbstractField{LX, LY, LZ}.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.@compute-Tuple{Any}","page":"Library","title":"Oceananigans.Fields.@compute","text":"@compute(exprs...)\n\nCall compute! on fields after defining them.\n\n\n\n\n\n","category":"macro"},{"location":"appendix/library/#XESMF.Regridder","page":"Library","title":"XESMF.Regridder","text":"Regridder(src_coordinates::Dict{String, <:AbstractArray},\n          dst_coordinates::Dict{String, <:AbstractArray};\n          method=\"conservative\", periodic=false)\n\nReturn a Regridder from the xESMF Python package to regrid data from src_coordinates to dst_coordinates using the specified method.\n\nThe src_coordinates and dst_coordinates are dictionaries that contain information about the two grids.\n\nxESMF exposes five different regridding algorithms from the ESMF library, specified with the method keyword argument:\n\n\"bilinear\": ESMF.RegridMethod.BILINEAR\n\"conservative\": ESMF.RegridMethod.CONSERVE\n\"conservative_normed\": ESMF.RegridMethod.CONSERVE\n\"patch\": ESMF.RegridMethod.PATCH\n\"nearest_s2d\": ESMF.RegridMethod.NEAREST_STOD\n\"nearest_d2s\": ESMF.RegridMethod.NEAREST_DTOS\n\nwhere conservative_normed is just the conservative method with the normalization set to ESMF.NormType.FRACAREA instead of the default norm_type = ESMF.NormType.DSTAREA.\n\nFor more information, see the Python xESMF documentation at:\n\nhttps://xesmf.readthedocs.io/en/latest/notebooks/Compare_algorithms.html\n\n\n\n\n\nRegridder(dst_field::AbstractField, src_field::AbstractField; method=\"conservative\")\n\nReturn a regridder from src_field to dst_field using the specified method. The regridder contains a sparse matrix with the regridding weights. The regridding weights are obtained via xESMF Python package. xESMF exposes five different regridding algorithms from the ESMF library, specified with the method keyword argument:\n\n\"bilinear\": ESMF.RegridMethod.BILINEAR\n\"conservative\": ESMF.RegridMethod.CONSERVE\n\"conservative_normed\": ESMF.RegridMethod.CONSERVE\n\"patch\": ESMF.RegridMethod.PATCH\n\"nearest_s2d\": ESMF.RegridMethod.NEAREST_STOD\n\"nearest_d2s\": ESMF.RegridMethod.NEAREST_DTOS\n\nwhere conservative_normed is just the conservative method with the normalization set to ESMF.NormType.FRACAREA instead of the default norm_type = ESMF.NormType.DSTAREA.\n\nFor more information, see the Python xESMF documentation at:\n\nhttps://xesmf.readthedocs.io/en/latest/notebooks/Compare_algorithms.html\n\nExample\n\nTo create a regridder for two fields that live on different grids.\n\nusing Oceananigans\nusing XESMF\n\nz = (-1, 0)\ntg = TripolarGrid(; size=(180, 85, 1), z, southernmost_latitude = -80)\nllg = LatitudeLongitudeGrid(; size=(170, 80, 1), z,\n                            longitude=(0, 360), latitude=(-82, 90))\n\nsrc_field = CenterField(tg)\ndst_field = CenterField(llg)\n\nregridder = XESMF.Regridder(dst_field, src_field, method=\"conservative\")\n\nWe can use the above regridder to regrid via regrid!.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Fields.regrid!","page":"Library","title":"Oceananigans.Fields.regrid!","text":"regrid!(dst_field, src_field)\n\nRegrid src_field onto the grid of dst_field.\n\nExample\n\nGenerate a tracer field on a vertically stretched grid and regrid it on a regular grid.\n\nusing Oceananigans\n\nNz, Lz = 2, 1.0\ntopology = (Flat, Flat, Bounded)\n\ninput_grid = RectilinearGrid(size=Nz, z = [0, Lz/3, Lz], topology=topology, halo=1)\ninput_field = CenterField(input_grid)\ninput_field[1, 1, 1:Nz] = [2, 3]\n\noutput_grid = RectilinearGrid(size=Nz, z=(0, Lz), topology=topology, halo=1)\noutput_field = CenterField(output_grid)\n\nregrid!(output_field, input_field)\n\noutput_field[1, 1, :]\n\n# output\n4-element OffsetArray(::Vector{Float64}, 0:3) with eltype Float64 with indices 0:3:\n 0.0\n 2.333333333333333\n 3.0\n 0.0\n\n\n\n\n\nregrid!(dst_field, regrider::XESMF.Regridder, src_field)\n\nRegrid src_field onto the grid of field dst_field using the regrider r.\n\nExample\n\nusing Oceananigans\nusing XESMF\n\nz = (-1, 0)\n\ntg = TripolarGrid(; size=(360, 170, 1), z, southernmost_latitude = -80)\n\nllg = LatitudeLongitudeGrid(; size=(360, 180, 1), z,\n                            longitude=(0, 360), latitude=(-82, 90))\n\nsrc_field = CenterField(tg)\ndst_field = CenterField(llg)\n\nÎ»â‚€, Ï†â‚€ = 150, 30   # degrees\nwidth = 12         # degrees\nset!(src_field, (Î», Ï†, z) -> exp(-((Î» - Î»â‚€)^2 + (Ï† - Ï†â‚€)^2) / 2width^2))\n\nregridder = XESMF.Regridder(dst_field, src_field, method=\"conservative\")\n\nregrid!(dst_field, regridder, src_field)\n\nfirst(Field(Integral(dst_field, dims=(1, 2))))\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Forcings","page":"Library","title":"Forcings","text":"","category":"section"},{"location":"appendix/library/#Oceananigans.Forcings.AdvectiveForcing-Tuple{}","page":"Library","title":"Oceananigans.Forcings.AdvectiveForcing","text":"AdvectiveForcing(u=ZeroField(), v=ZeroField(), w=ZeroField())\n\nBuild a forcing term representing advection by the velocity field u, v, w with an advection scheme.\n\nExample\n\nUsing a tracer field to model sinking particles\n\nusing Oceananigans\n\n# Physical parameters\ngravitational_acceleration          = 9.81     # m sâ»Â²\nocean_density                       = 1026     # kg mâ»Â³\nmean_particle_density               = 2000     # kg mâ»Â³\nmean_particle_radius                = 1e-3     # m\nocean_molecular_kinematic_viscosity = 1.05e-6  # mÂ² sâ»Â¹\n\n# Terminal velocity of a sphere in viscous flow\nÎ”b = gravitational_acceleration * (mean_particle_density - ocean_density) / ocean_density\nÎ½ = ocean_molecular_kinematic_viscosity\nR = mean_particle_radius\n\nw_Stokes = - 2/9 * Î”b / Î½ * R^2 # m sâ»Â¹\n\nsettling = AdvectiveForcing(w=w_Stokes)\n\n# output\nAdvectiveForcing:\nâ”œâ”€â”€ u: ZeroField{Int64}\nâ”œâ”€â”€ v: ZeroField{Int64}\nâ””â”€â”€ w: ConstantField(-1.97096)\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Forcings.ContinuousForcing","page":"Library","title":"Oceananigans.Forcings.ContinuousForcing","text":"ContinuousForcing{LX, LY, LZ, P, F, D, I, â„‘}\n\nA callable object that implements a \"continuous form\" forcing function on a field at the location LX, LY, LZ with optional parameters.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Forcings.ContinuousForcing-Tuple{Any}","page":"Library","title":"Oceananigans.Forcings.ContinuousForcing","text":"ContinuousForcing(func; parameters=nothing, field_dependencies=())\n\nConstruct a \"continuous form\" forcing with optional parameters and optional field_dependencies on other fields in a model.\n\nIf neither parameters nor field_dependencies are provided, then func must be callable with the signature\n\nfunc(X..., t)\n\nwhere, on a three-dimensional grid with no Flat directions, X = (x, y, z) is a 3-tuple containing the east-west, north-south, and vertical spatial coordinates, and t is time.\n\nDimensions with Flat topology are omitted from the coordinate tuple X. For example, on a grid with topology (Periodic, Periodic, Flat), and with no parameters or field_dependencies, then func must be callable\n\nfunc(x, y, t)\n\nwhere x and y are the east-west and north-south coordinates, respectively. For another example, on a grid with topology (Flat, Flat, Bounded) (e.g. a single column), and for a forcing with no parameters or field_dependencies, then func must be callable with\n\nfunc(z, t)\n\nwhere z is the vertical coordinate.\n\nIf field_dependencies are provided, the signature of func must include them. For example, if field_dependencies=(:u, :S) (and parameters are not provided), and on a three-dimensional grid with no Flat dimensions, then func must be callable with the signature\n\nfunc(x, y, z, t, u, S)\n\nwhere u is assumed to be the u-velocity component, and S is a tracer. Note that any field which does not have the name u, v, or w is assumed to be a tracer and must be present in model.tracers.\n\nIf parameters are provided, then the last argument to func must be parameters. For example, if func has no field_dependencies but does depend on parameters, then on a three-dimensional grid it must be callable with the signature\n\nfunc(x, y, z, t, parameters)\n\nWith field_dependencies=(:u, :v, :w, :c) and parameters and on a three-dimensional grid, then func must be callable with the signature\n\nfunc(x, y, z, t, u, v, w, c, parameters)\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Forcings.DiscreteForcing","page":"Library","title":"Oceananigans.Forcings.DiscreteForcing","text":"struct DiscreteForcing{P, F}\n\nWrapper for \"discrete form\" forcing functions with optional parameters.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Forcings.DiscreteForcing-Tuple{Any}","page":"Library","title":"Oceananigans.Forcings.DiscreteForcing","text":"DiscreteForcing(func; parameters=nothing)\n\nConstruct a \"discrete form\" forcing function with optional parameters. The forcing function is applied at grid point i, j, k.\n\nWhen parameters are not specified, func must be callable with the signature\n\nfunc(i, j, k, grid, clock, model_fields)\n\nwhere grid is model.grid, clock.time is the current simulation time and clock.iteration is the current model iteration, and model_fields is a NamedTuple with u, v, w and the fields in model.tracers.\n\nNote that the index end does not access the final physical grid point of a model field in any direction. The final grid point must be explicitly specified, as in model_fields.u[i, j, grid.Nz].\n\nWhen parameters is specified, func must be callable with the signature.\n\nfunc(i, j, k, grid, clock, model_fields, parameters)\n\nAbove, parameters is, in principle, arbitrary. Note, however, that GPU compilation can place constraints on typeof(parameters).\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Forcings.GaussianMask","page":"Library","title":"Oceananigans.Forcings.GaussianMask","text":"GaussianMask{D}(center, width)\n\nCallable object that returns a Gaussian masking function centered on center, with width, and varying along direction D, i.e.,\n\nexp(-(D - center)^2 / (2 * width^2))\n\nExample\n\nCreate a Gaussian mask centered on z=0 with width 1 meter.\n\njulia> using Oceananigans\n\njulia> mask = GaussianMask{:z}(center=0, width=1)\nGaussianMask{:z, Int64}(0, 1)\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Forcings.LinearTarget","page":"Library","title":"Oceananigans.Forcings.LinearTarget","text":"LinearTarget{D}(intercept, gradient)\n\nCallable object that returns a Linear target function with intercept and gradient, and varying along direction D, i.e.,\n\nintercept + D * gradient\n\nExample\n\nCreate a linear target function varying in z, equal to 0 at z=0 and with gradient 10â»â¶:\n\njulia> target = LinearTarget{:z}(intercept=0, gradient=1e-6)\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Forcings.PiecewiseLinearMask","page":"Library","title":"Oceananigans.Forcings.PiecewiseLinearMask","text":"PiecewiseLinearMask{D}(center, width)\n\nCallable object that returns a piecewise linear masking function centered on center, with width, and varying along direction D. The mask is:\n\n0 when |D - center| > width\n1 when D = center\nLinear interpolation between 0 and 1 when |D - center| â‰¤ width\n\nExample\n\nCreate a piecewise linear mask centered on z=0 with width 1 meter.\n\njulia> using Oceananigans\n\njulia> mask = PiecewiseLinearMask{:z}(center=0, width=1)\nPiecewiseLinearMask{:z, Int64}(0, 1)\n\njulia> mask(0, 0, 0) == 1\ntrue\n\njulia> mask(0, 0, 1) == mask(0, 0, -1) == 0\ntrue\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Forcings.Relaxation","page":"Library","title":"Oceananigans.Forcings.Relaxation","text":"struct Relaxation{R, M, T}\n\nCallable object for restoring fields to a target at some rate and within a masked region in x, y, z.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Forcings.Relaxation-Tuple{}","page":"Library","title":"Oceananigans.Forcings.Relaxation","text":"Relaxation(; rate, mask=onefunction, target=zerofunction)\n\nReturns a Forcing that restores a field to target(X..., t) at the specified rate, in the region mask(X...).\n\nThe functions onefunction and zerofunction always return 1 and 0, respectively. Thus the default mask leaves the whole domain uncovered, and the default target is zero.\n\nExample\n\nRestore a field to zero on a timescale of \"3600\" (equal to one hour if the time units of the simulation are seconds).\n\nusing Oceananigans\n\ndamping = Relaxation(rate = 1/3600)\n\n# output\nRelaxation{Float64, typeof(Oceananigans.Forcings.onefunction), typeof(Oceananigans.Forcings.zerofunction)}\nâ”œâ”€â”€ rate: 0.0002777777777777778\nâ”œâ”€â”€ mask: 1\nâ””â”€â”€ target: 0\n\nRestore a field to a linear z-gradient within the bottom 1/4 of a domain on a timescale of \"60\" (equal to one minute if the time units of the simulation are seconds).\n\ndTdz = 0.001 # â°C mâ»Â¹, temperature gradient\n\nTâ‚€ = 20 # â°C, surface temperature at z=0\n\nLz = 100 # m, depth of domain\n\nbottom_sponge_layer = Relaxation(; rate = 1/60,\n                                   target = LinearTarget{:z}(intercept=Tâ‚€, gradient=dTdz),\n                                   mask = GaussianMask{:z}(center=-Lz, width=Lz/4))\n\n# output\nRelaxation{Float64, GaussianMask{:z, Float64}, LinearTarget{:z, Float64}}\nâ”œâ”€â”€ rate: 0.016666666666666666\nâ”œâ”€â”€ mask: exp(-(z + 100.0)^2 / (2 * 25.0^2))\nâ””â”€â”€ target: 20.0 + 0.001 * z\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Forcings.Forcing-Tuple{AbstractArray}","page":"Library","title":"Oceananigans.Forcings.Forcing","text":"Forcing(array::AbstractArray)\n\nReturn a Forcing by array, which can be added to the tendency of a model field.\n\nForcing is computed by calling array[i, j, k], so array must be 3D with size(grid).\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Forcings.Forcing-Tuple{Any}","page":"Library","title":"Oceananigans.Forcings.Forcing","text":"Forcing(func; parameters=nothing, field_dependencies=(), discrete_form=false)\n\nReturn a Forcing function, which can be added to the tendency of a model field.\n\nIf discrete_form=false (the default), and neither parameters nor field_dependencies are provided, then func must be callable with the signature\n\nfunc(x, y, z, t)\n\nwhere x, y, z are the east-west, north-south, and vertical spatial coordinates, and t is time. Note that this form is also default in the constructor for NonhydrostaticModel, so that Forcing is not needed.\n\nIf discrete_form=false (the default), and field_dependencies are provided, the signature of func must include them. For example, if field_dependencies=(:u, :S) (and parameters are not provided), then func must be callable with the signature\n\nfunc(x, y, z, t, u, S)\n\nwhere u is assumed to be the u-velocity component, and S is a tracer. Note that any field which does not have the name u, v, or w is assumed to be a tracer and must be present in model.tracers.\n\nIf discrete_form=false (the default) and parameters are provided, then the last argument to func must be parameters. For example, if func has no field_dependencies but does depend on parameters, then it must be callable with the signature\n\nfunc(x, y, z, t, parameters)\n\nThe object parameters is arbitrary in principle, however GPU compilation can place constraints on typeof(parameters).\n\nWith field_dependencies=(:u, :v, :w, :c) and parameters, then func must be callable with the signature\n\nfunc(x, y, z, t, u, v, w, c, parameters)\n\nIf discrete_form=true then func must be callable with the \"discrete form\"\n\nfunc(i, j, k, grid, clock, model_fields)\n\nwhere i, j, k is the grid point at which the forcing is applied, grid is model.grid, clock.time is the current simulation time and clock.iteration is the current model iteration, and model_fields is a NamedTuple with u, v, w, the fields in model.tracers, and the fields in model.diffusivity_fields, each of which is an OffsetArrays (or NamedTuples of OffsetArrays depending on the turbulence closure) of field data.\n\nWhen discrete_form=true and parameters is specified, func must be callable with the signature\n\nfunc(i, j, k, grid, clock, model_fields, parameters)\n\nExamples\n\nusing Oceananigans\n\n# Parameterized forcing\nparameterized_func(x, y, z, t, p) = p.Î¼ * exp(z / p.Î») * cos(p.Ï‰ * t)\n\nv_forcing = Forcing(parameterized_func, parameters = (Î¼=42, Î»=0.1, Ï‰=Ï€))\n\n# output\nContinuousForcing{@NamedTuple{Î¼::Int64, Î»::Float64, Ï‰::Irrational{:Ï€}}}\nâ”œâ”€â”€ func: parameterized_func (generic function with 1 method)\nâ”œâ”€â”€ parameters: (Î¼ = 42, Î» = 0.1, Ï‰ = Ï€)\nâ””â”€â”€ field dependencies: ()\n\nNote that because forcing locations are regularized within the NonhydrostaticModel constructor:\n\ngrid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))\nmodel = NonhydrostaticModel(grid=grid, forcing=(v=v_forcing,))\n\nmodel.forcing.v\n\n# output\nContinuousForcing{@NamedTuple{Î¼::Int64, Î»::Float64, Ï‰::Irrational{:Ï€}}} at (Center, Face, Center)\nâ”œâ”€â”€ func: parameterized_func (generic function with 1 method)\nâ”œâ”€â”€ parameters: (Î¼ = 42, Î» = 0.1, Ï‰ = Ï€)\nâ””â”€â”€ field dependencies: ()\n\nAfter passing through the constructor for NonhydrostaticModel, the v-forcing location information is available and set to Center, Face, Center.\n\n# Field-dependent forcing\ngrowth_in_sunlight(x, y, z, t, P) = exp(z) * P\n\nplankton_forcing = Forcing(growth_in_sunlight, field_dependencies=:P)\n\n# output\nContinuousForcing{Nothing}\nâ”œâ”€â”€ func: growth_in_sunlight (generic function with 1 method)\nâ”œâ”€â”€ parameters: nothing\nâ””â”€â”€ field dependencies: (:P,)\n\n# Parameterized, field-dependent forcing\ntracer_relaxation(x, y, z, t, c, p) = p.Î¼ * exp((z + p.H) / p.Î») * (p.dCdz * z - c)\n\nc_forcing = Forcing(tracer_relaxation,\n                    field_dependencies = :c,\n                            parameters = (Î¼=1/60, Î»=10, H=1000, dCdz=1))\n\n# output\nContinuousForcing{@NamedTuple{Î¼::Float64, Î»::Int64, H::Int64, dCdz::Int64}}\nâ”œâ”€â”€ func: tracer_relaxation (generic function with 1 method)\nâ”œâ”€â”€ parameters: (Î¼ = 0.016666666666666666, Î» = 10, H = 1000, dCdz = 1)\nâ””â”€â”€ field dependencies: (:c,)\n\n# Unparameterized discrete-form forcing function\nfiltered_relaxation(i, j, k, grid, clock, model_fields) =\n    @inbounds - (model_fields.c[i-1, j, k] + model_fields.c[i, j, k] + model_fields.c[i+1, j, k]) / 3\n\nfiltered_forcing = Forcing(filtered_relaxation, discrete_form=true)\n\n# output\nDiscreteForcing{Nothing}\nâ”œâ”€â”€ func: filtered_relaxation (generic function with 1 method)\nâ””â”€â”€ parameters: nothing\n\n# Discrete-form forcing function with parameters\nmasked_damping(i, j, k, grid, clock, model_fields, parameters) =\n    @inbounds - parameters.Î¼ * exp(grid.z.cáµƒáµƒá¶œ[k] / parameters.Î») * model_fields.u[i, j, k]\n\nmasked_damping_forcing = Forcing(masked_damping, parameters=(Î¼=42, Î»=Ï€), discrete_form=true)\n\n# output\nDiscreteForcing{@NamedTuple{Î¼::Int64, Î»::Irrational{:Ï€}}}\nâ”œâ”€â”€ func: masked_damping (generic function with 1 method)\nâ””â”€â”€ parameters: (Î¼ = 42, Î» = Ï€)\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Forcings.Forcing-Tuple{Union{FieldTimeSeries{LX, LY, LZ, TI, K}, Oceananigans.OutputReaders.GPUAdaptedFieldTimeSeries{LX, LY, LZ, TI, K}} where {LX, LY, LZ, TI, K}}","page":"Library","title":"Oceananigans.Forcings.Forcing","text":"Forcing(array::FlavorOfFTS)\n\nReturn a Forcing by a FieldTimeSeries, which can be added to the tendency of a model field.\n\nForcing is computed by calling fts[i, j, k, Time(clock.time)], so the FieldTimeSeries must have the spatial dimensions of the grid.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Grids","page":"Library","title":"Grids","text":"","category":"section"},{"location":"appendix/library/#Oceananigans.Grids.AbstractCurvilinearGrid","page":"Library","title":"Oceananigans.Grids.AbstractCurvilinearGrid","text":"AbstractCurvilinearGrid{FT, TX, TY, TZ, CZ, Arch}\n\nAbstract supertype for curvilinear grids with elements of type FT, topology {TX, TY, TZ}, vertical coordinate CZ, and Architecture.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.AbstractGrid","page":"Library","title":"Oceananigans.Grids.AbstractGrid","text":"AbstractGrid{FT, TX, TY, TZ, Arch}\n\nAbstract supertype for grids with elements of type FT, topology {TX, TY, TZ}, and Architecture.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.AbstractHorizontallyCurvilinearGrid","page":"Library","title":"Oceananigans.Grids.AbstractHorizontallyCurvilinearGrid","text":"AbstractHorizontallyCurvilinearGrid{FT, TX, TY, TZ, CZ, Arch}\n\nAbstract supertype for horizontally-curvilinear grids with elements of type FT, topology {TX, TY, TZ}, vertical coordinate CZ, and Architecture.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.AbstractTopology","page":"Library","title":"Oceananigans.Grids.AbstractTopology","text":"AbstractTopology\n\nAbstract supertype for grid topologies.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.AbstractUnderlyingGrid","page":"Library","title":"Oceananigans.Grids.AbstractUnderlyingGrid","text":"AbstractUnderlyingGrid{FT, TX, TY, TZ, CZ, Arch}\n\nAbstract supertype for \"primary\" grids (as opposed to grids with immersed boundaries) with elements of type FT, topology {TX, TY, TZ}, vertical coordinate CZ, and Architecture.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.Bounded","page":"Library","title":"Oceananigans.Grids.Bounded","text":"Bounded\n\nGrid topology for bounded dimensions, e.g., wall-bounded dimensions.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.Center","page":"Library","title":"Oceananigans.Grids.Center","text":"Center\n\nA type describing the location at the center of a grid cell.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.ExponentialDiscretization-Tuple{Int64, Any, Any}","page":"Library","title":"Oceananigans.Grids.ExponentialDiscretization","text":"ExponentialDiscretization(N::Int, left, right;\n                          scale = (right - left) / 5,\n                          bias = :right,\n                          mutable = false)\n\nReturn a one-dimensional discretization with N cells that are exponentially spaced (or, equivalently, with spacings that grow linearly along the coordinate). The discretization spans the range [left, right]. The exponential e-folding is controlled by scale. The coordinate interfaces are closely stacked on the bias-side of the domain.\n\nArguments\n\nN: The number of cells in the discretization.\nleft: The left-most interface of the discretization.\nright: The right-most interface of the discretization.\n\nKeyword Arguments\n\nscale: The length scale of the exponential e-folding. Default: (right - left) / 5\nbias :: Symbol: Determine whether left or right biased. Default: :right.\nmutable: Whether the discretization is mutable, i.e., the discretization refers to a vertical coordinate that can evolve in time following certain rules. Default: false.\n\nExamples\n\nusing Oceananigans\n\nN = 10\nl = -1000\nr = 100\n\nx = ExponentialDiscretization(N, l, r)\n\n# output\nExponentialDiscretization\nâ”œâ”€ size: 10\nâ”œâ”€ faces: [-1000.0, -564.247649441104, -299.95048878528615, -139.64615757253702, -42.41666580727582, 16.55600197663209, 52.324733072619736, 74.0195651413529, 87.17814594835643, 95.15922864611028, 100.0]\nâ”œâ”€ left: -1000.0\nâ”œâ”€ right: 100.0\nâ”œâ”€ scale: 220.0\nâ””â”€ bias: :right\n\nTo inspect the interfaces of the coordinate we can call:\n\n[x(i) for i in 1:N+1]\n\n# output\n\n11-element Vector{Float64}:\n -1000.0\n  -564.247649441104\n  -299.95048878528615\n  -139.64615757253702\n   -42.41666580727582\n    16.55600197663209\n    52.324733072619736\n    74.0195651413529\n    87.17814594835643\n    95.15922864611028\n   100.0\n\nAbove, the default bias is :right and thus the interfaces are closer on the right = 100 side of the domain. We can get a left-biased grid via:\n\nx = ExponentialDiscretization(N, l, r, bias=:left)\n\n[x(i) for i in 1:N+1]\n\n# output\n\n11-element Vector{Float64}:\n -1000.0\n  -995.1592286461103\n  -987.1781459483565\n  -974.0195651413529\n  -952.3247330726198\n  -916.556001976632\n  -857.5833341927241\n  -760.353842427463\n  -600.0495112147139\n  -335.75235055889596\n   100.0\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.Face","page":"Library","title":"Oceananigans.Grids.Face","text":"Face\n\nA type describing the location at the face of a grid cell.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.Flat","page":"Library","title":"Oceananigans.Grids.Flat","text":"Flat\n\nGrid topology for flat dimensions, generally with one grid point, along which the solution is uniform and does not vary.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.FullyConnected","page":"Library","title":"Oceananigans.Grids.FullyConnected","text":"FullyConnected\n\nGrid topology for dimensions that are connected to other models or domains.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.LatitudeLongitudeGrid","page":"Library","title":"Oceananigans.Grids.LatitudeLongitudeGrid","text":"LatitudeLongitudeGrid([architecture = CPU(), FT = Oceananigans.defaults.FloatType];\n                      size,\n                      longitude,\n                      latitude,\n                      z = nothing,\n                      radius = Oceananigans.defaults.planet_radius,\n                      topology = nothing,\n                      precompute_metrics = true,\n                      halo = nothing)\n\nCreates a LatitudeLongitudeGrid with coordinates (Î», Ï†, z) denoting longitude, latitude, and vertical coordinate respectively.\n\nPositional arguments\n\narchitecture: Specifies whether arrays of coordinates and spacings are stored                 on the CPU or GPU. Default: CPU().\nFT : Floating point data type. Default: Float64.\n\nKeyword arguments\n\nsize (required): A 3-tuple prescribing the number of grid points each direction.\nlongitude (required), latitude (required), z (default: nothing): Each is either a:\n2-tuple that specify the end points of the domain,\none-dimensional array specifying the cell interface locations, or\nsingle-argument function that takes an index and returns cell interface location.\nNote: the latitude and longitude coordinates extents are expected in degrees.\nradius: The radius of the sphere the grid lives on. By default is equal to the radius of Earth.\ntopology: Tuple of topologies (Flat, Bounded, Periodic) for each direction. The vertical             topology[3] must be Bounded, while the latitude-longitude topologies can be             Bounded, Periodic, or Flat. If no topology is provided then, by default, the             topology is (Periodic, Bounded, Bounded) if the latitudinal extent is 360 degrees             or (Bounded, Bounded, Bounded) otherwise.\nprecompute_metrics: Boolean specifying whether to precompute horizontal spacings and areas.                       Default: true. When false, horizontal spacings and areas are computed                       on-the-fly during a simulation.\nhalo: A 3-tuple of integers specifying the size of the halo region of cells surrounding         the physical interior. The default is 3 halo cells in every direction.\n\nExamples\n\nA default grid with Float64 type:\n\njulia> using Oceananigans\n\njulia> grid = LatitudeLongitudeGrid(size=(36, 34, 25),\n                                    longitude = (-180, 180),\n                                    latitude = (-85, 85),\n                                    z = (-1000, 0))\n36Ã—34Ã—25 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3Ã—3Ã—3 halo and with precomputed metrics\nâ”œâ”€â”€ longitude: Periodic Î» âˆˆ [-180.0, 180.0) regularly spaced with Î”Î»=10.0\nâ”œâ”€â”€ latitude:  Bounded  Ï† âˆˆ [-85.0, 85.0]   regularly spaced with Î”Ï†=5.0\nâ””â”€â”€ z:         Bounded  z âˆˆ [-1000.0, 0.0]  regularly spaced with Î”z=40.0\n\nA bounded spherical sector with cell interfaces stretched hyperbolically near the top:\n\nusing Oceananigans\n\nÏƒ = 1.1 # stretching factor\nNz = 24 # vertical resolution\nLz = 1000 # depth (m)\nhyperbolically_spaced_faces(k) = - Lz * (1 - tanh(Ïƒ * (k - 1) / Nz) / tanh(Ïƒ))\n\ngrid = LatitudeLongitudeGrid(size=(36, 34, Nz),\n                             longitude = (-180, 180),\n                             latitude = (-20, 20),\n                             z = hyperbolically_spaced_faces,\n                             topology = (Bounded, Bounded, Bounded))\n\n# output\n\n36Ã—34Ã—24 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3Ã—3Ã—3 halo and with precomputed metrics\nâ”œâ”€â”€ longitude: Bounded  Î» âˆˆ [-180.0, 180.0] regularly spaced with Î”Î»=10.0\nâ”œâ”€â”€ latitude:  Bounded  Ï† âˆˆ [-20.0, 20.0]   regularly spaced with Î”Ï†=1.17647\nâ””â”€â”€ z:         Bounded  z âˆˆ [-1000.0, -0.0] variably spaced with min(Î”z)=21.3342, max(Î”z)=57.2159\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.LatitudeLongitudeGrid-Tuple{RectilinearGrid}","page":"Library","title":"Oceananigans.Grids.LatitudeLongitudeGrid","text":"LatitudeLongitudeGrid(rectilinear_grid::RectilinearGrid;\n                      radius = Oceananigans.defaults.planet_radius,\n                      origin = (0, 0))\n\nConstruct a LatitudeLongitudeGrid from a RectilinearGrid. The horizontal coordinates of the rectilinear grid are transformed to longitude-latitude coordinates in degrees, accounting for spherical Earth geometry. The longitudes are computed approximately using the latitudinal origin.\n\nThe vertical coordinate and architecture are inherited from the input grid.\n\nKeyword Arguments\n\nradius: The radius of the sphere, defaults to Earth's mean radius (â‰ˆ 6371 km)\norigin: Tuple of (longitude, latitude) in degrees specifying the origin of the rectilinear grid\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.LeftConnected","page":"Library","title":"Oceananigans.Grids.LeftConnected","text":"LeftConnected\n\nGrid topology for dimensions that are connected to other models or domains only on the left (the other direction is bounded)\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.LinearStretching","page":"Library","title":"Oceananigans.Grids.LinearStretching","text":"LinearStretching{T}\n\nÎ‘ linear stretching of the form x â†¦ (1 + coefficient) * x.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.LinearStretching-Tuple{Any}","page":"Library","title":"Oceananigans.Grids.LinearStretching","text":"(stretching::LinearStretching)(x)\n\nApply linear stretching to x via\n\n(1 + stretching.coefficient) * x\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.MutableVerticalDiscretization-Tuple{Any}","page":"Library","title":"Oceananigans.Grids.MutableVerticalDiscretization","text":"MutableVerticalDiscretization(r_faces)\n\nConstruct a MutableVerticalDiscretization from r_faces that can be a Tuple, a function of an index k, or an AbstractArray. A MutableVerticalDiscretization defines a vertical coordinate that can evolve in time following certain rules. Examples of MutableVerticalDiscretizations are the free-surface following coordinates (also known as \"zee-star\") or the terrain following coordinates (also known as \"sigma\" coordinates).\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.OrthogonalSphericalShellGrid","page":"Library","title":"Oceananigans.Grids.OrthogonalSphericalShellGrid","text":"OrthogonalSphericalShellGrid(arch = CPU(), FT = Oceananigans.defaults.FloatType;\n                            size,\n                            z,\n                            radius = Oceananigans.defaults.planet_radius,\n                            conformal_mapping = nothing,\n                            halo = (3, 3, 3),\n                            topology = (Bounded, Bounded, Bounded))\n\nReturn an OrthogonalSphericalShellGrid with empty horizontal metrics.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.Periodic","page":"Library","title":"Oceananigans.Grids.Periodic","text":"Periodic\n\nGrid topology for periodic dimensions.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.PowerLawStretching","page":"Library","title":"Oceananigans.Grids.PowerLawStretching","text":"PowerLawStretching{T}\n\nÎ‘ power-law stretching of the form x â†¦ x^power.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.PowerLawStretching-Tuple{Any}","page":"Library","title":"Oceananigans.Grids.PowerLawStretching","text":"(stretching::PowerLawStretching)(x)\n\nApply power-law stretching to x via\n\nx^stretching.power\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.RectilinearGrid","page":"Library","title":"Oceananigans.Grids.RectilinearGrid","text":"RectilinearGrid([architecture = CPU(), FT = Float64];\n                size,\n                x = nothing,\n                y = nothing,\n                z = nothing,\n                halo = nothing,\n                extent = nothing,\n                topology = (Periodic, Periodic, Bounded))\n\nCreate a RectilinearGrid with size = (Nx, Ny, Nz) grid points.\n\nPositional arguments\n\narchitecture: Specifies whether arrays of coordinates and spacings are stored                 on the CPU or GPU. Default: CPU().\nFT: Floating point data type. Default: Float64.\n\nKeyword arguments\n\nsize (required): A tuple prescribing the number of grid points in non-Flat directions.                    size is a 3-tuple for 3D models, a 2-tuple for 2D models, and either a                    scalar or 1-tuple for 1D models.\ntopology: A 3-tuple (TX, TY, TZ) specifying the topology of the domain.             TX, TY, and TZ specify whether the x-, y-, and z directions are             Periodic, Bounded, or Flat. The topology Flat indicates that a model does             not vary in those directions so that derivatives and interpolation are zero.             The default is topology = (Periodic, Periodic, Bounded).\nextent: A tuple prescribing the physical extent of the grid in non-Flat directions, e.g.,           (Lx, Ly, Lz). All directions are constructed with regular grid spacing and the domain           (in the case that no direction is Flat) is 0  x  L_x, 0  y  L_y, and           -L_z  z  0, which is most appropriate for oceanic applications in which z = 0           usually is the ocean's surface.\nx, y, and z: Each of x, y, z are either (i) 2-tuples that specify the end points of the domain                    in their respect directions (in which case scalar values may be used in Flat                    directions), (ii) arrays that specify the locations of cell faces in the x-, y-,                    or z-direction, or (iii) functions of the corresponding indices i, j, or k                    that specify the locations of cell faces in the x-, y-, or z-direction, respectively.                    For example, to prescribe the cell faces in z we need to provide a function that takes                    k as argument and returns the location of the faces for indices k = 1 through k = Nz + 1,                    where Nz is the size of the stretched z dimension.\nnote: Physical extent of grid\nEither extent, or all of x, y, and z must be specified.\nhalo: A tuple of integers that specifies the size of the halo region, that is the number of cells surrounding         the physical interior for each non-Flat direction. The default is 3 halo cells in every direction.\n\nThe physical extent of the domain can be specified either via x, y, and z keyword arguments indicating the left and right endpoints of each dimensions, e.g., x = (-Ï€, Ï€) or via the extent argument, e.g., extent = (Lx, Ly, Lz), which specifies the extent of each dimension in which case 0  x  L_x, 0  y  L_y, and -L_z  z  0.\n\nA grid topology may be specified via a tuple assigning one of Periodic, Bounded, and, Flat to each dimension. By default, a horizontally periodic grid topology (Periodic, Periodic, Bounded) is assumed.\n\nConstants are stored using floating point values of type FT. By default this is Float64. Make sure to specify the desired FT if not using Float64.\n\nGrid properties\n\narchitecture: The grid's architecture.\n(Nx, Ny, Nz) :: Int: Number of physical points in the (x y z)-direction.\n(Hx, Hy, Hz) :: Int: Number of halo points in the (x y z)-direction.\n(Lx, Ly, Lz) :: FT: Physical extent of the grid in the (x y z)-direction.\n(Î”xá¶œáµƒáµƒ, Î”yáµƒá¶œáµƒ, z.Î”cáµƒáµƒá¶œ): Spacings in the (x y z)-directions between the cell faces.                            These are the lengths in x, y, and z of Center cells and are                            defined at Center locations.\n(Î”xá¶ áµƒáµƒ, Î”yáµƒá¶ áµƒ, z.Î”cáµƒáµƒá¶ ): Spacings in the (x y z)-directions between the cell centers.                            These are the lengths in x, y, and z of Face cells and are                            defined at Face locations.\n(xá¶œáµƒáµƒ, yáµƒá¶œáµƒ, z.cáµƒáµƒá¶œ): (x y z) coordinates of cell Centers.\n(xá¶ áµƒáµƒ, yáµƒá¶ áµƒ, z.cáµƒáµƒá¶ ): (x y z) coordinates of cell Faces.\n\nExamples\n\nA grid with the default Float64 type:\n\nusing Oceananigans\ngrid = RectilinearGrid(size=(32, 32, 32), extent=(1, 2, 3))\n\n# output\n\n32Ã—32Ã—32 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ Periodic x âˆˆ [0.0, 1.0)  regularly spaced with Î”x=0.03125\nâ”œâ”€â”€ Periodic y âˆˆ [0.0, 2.0)  regularly spaced with Î”y=0.0625\nâ””â”€â”€ Bounded  z âˆˆ [-3.0, 0.0] regularly spaced with Î”z=0.09375\n\nA grid with Float32 type:\n\nusing Oceananigans\ngrid = RectilinearGrid(Float32; size=(32, 32, 16), x=(0, 8), y=(-10, 10), z=(-Ï€, Ï€))\n\n# output\n\n32Ã—32Ã—16 RectilinearGrid{Float32, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ Periodic x âˆˆ [0.0, 8.0)          regularly spaced with Î”x=0.25\nâ”œâ”€â”€ Periodic y âˆˆ [-10.0, 10.0)       regularly spaced with Î”y=0.625\nâ””â”€â”€ Bounded  z âˆˆ [-3.14159, 3.14159] regularly spaced with Î”z=0.392699\n\nA two-dimenisional, horizontally-periodic grid:\n\nusing Oceananigans\ngrid = RectilinearGrid(size=(32, 32), extent=(2Ï€, 4Ï€), topology=(Periodic, Periodic, Flat))\n\n# output\n\n32Ã—32Ã—1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3Ã—3Ã—0 halo\nâ”œâ”€â”€ Periodic x âˆˆ [3.60072e-17, 6.28319) regularly spaced with Î”x=0.19635\nâ”œâ”€â”€ Periodic y âˆˆ [7.20145e-17, 12.5664) regularly spaced with Î”y=0.392699\nâ””â”€â”€ Flat z\n\nA one-dimensional \"column\" grid:\n\nusing Oceananigans\ngrid = RectilinearGrid(size=256, z=(-128, 0), topology=(Flat, Flat, Bounded))\n\n# output\n\n1Ã—1Ã—256 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0Ã—0Ã—3 halo\nâ”œâ”€â”€ Flat x\nâ”œâ”€â”€ Flat y\nâ””â”€â”€ Bounded  z âˆˆ [-128.0, 0.0] regularly spaced with Î”z=0.5\n\nA horizontally-periodic regular grid with cell interfaces stretched hyperbolically near the top:\n\nusing Oceananigans\n\nÏƒ = 1.1 # stretching factor\nNz = 24 # vertical resolution\nLz = 32 # depth (m)\n\nhyperbolically_spaced_faces(k) = - Lz * (1 - tanh(Ïƒ * (k - 1) / Nz) / tanh(Ïƒ))\n\ngrid = RectilinearGrid(size = (32, 32, Nz),\n                       x = (0, 64), y = (0, 64),\n                       z = hyperbolically_spaced_faces)\n\n# output\n\n32Ã—32Ã—24 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ Periodic x âˆˆ [0.0, 64.0)   regularly spaced with Î”x=2.0\nâ”œâ”€â”€ Periodic y âˆˆ [0.0, 64.0)   regularly spaced with Î”y=2.0\nâ””â”€â”€ Bounded  z âˆˆ [-32.0, -0.0] variably spaced with min(Î”z)=0.682695, max(Î”z)=1.83091\n\nA three-dimensional grid with regular spacing in x, cell interfaces at Chebyshev nodes in y, and cell interfaces hyperbolically stretched in z near the top:\n\nusing Oceananigans\n\nNx, Ny, Nz = 32, 30, 24\nLx, Ly, Lz = 200, 100, 32 # (m)\n\nchebychev_nodes(j) = - Ly/2 * cos(Ï€ * (j - 1) / Ny)\n\nÏƒ = 1.1 # stretching factor\nhyperbolically_spaced_faces(k) = - Lz * (1 - tanh(Ïƒ * (k - 1) / Nz) / tanh(Ïƒ))\n\ngrid = RectilinearGrid(size = (Nx, Ny, Nz),\n                       topology = (Periodic, Bounded, Bounded),\n                       x = (0, Lx),\n                       y = chebychev_nodes,\n                       z = hyperbolically_spaced_faces)\n\n# output\n\n32Ã—30Ã—24 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ Periodic x âˆˆ [0.0, 200.0)  regularly spaced with Î”x=6.25\nâ”œâ”€â”€ Bounded  y âˆˆ [-50.0, 50.0] variably spaced with min(Î”y)=0.273905, max(Î”y)=5.22642\nâ””â”€â”€ Bounded  z âˆˆ [-32.0, -0.0] variably spaced with min(Î”z)=0.682695, max(Î”z)=1.83091\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.ReferenceToStretchedDiscretization-Tuple{}","page":"Library","title":"Oceananigans.Grids.ReferenceToStretchedDiscretization","text":"ReferenceToStretchedDiscretization(; extent,\n                                   bias = :right,\n                                   bias_edge = 0,\n                                   constant_spacing = extent / 20,\n                                   constant_spacing_extent = 5 * constant_spacing,\n                                   maximum_stretching_extent = Inf,\n                                   maximum_spacing = Inf,\n                                   stretching = PowerLawStretching(1.02),\n                                   rounding_digits = 2,\n                                   mutable = false)\n\nReturn a one-dimensional coordinate that has constant_spacing over a constant_spacing_extent on the bias-side of the domain. The coordinate has constant spacing over a distance\n\nceil(constant_spacing_extent / constant_spacing) * constant_spacing > constant_spacing_extent\n\nfrom the bias_edge. Beyond the above distance, the interface spacings stretch according the provided stretching law.\n\nKeyword arguments\n\nextent: The desired extent of the coordinate.\nbias :: Symbol: Whether the constant_spacing interfaces are on the left (:left) or right (:right) part of the domain. Default: :right.\nbias_edge: The first interface on the bias-side of the domain. Default: 0.\nconstant_spacing: The constant spacing on the bias-side of the domain. Default: extent / 20.\nconstant_spacing_extent: The extent of the domain away from the bias_edge for which we have constant_spacing. Default: 5 * constant_spacing.\nmaximum_stretching_extent: The distance away from the bias_edge beyond which there is no more stretching and instead we transition to a uniformly-spaced coordinate. Default: Inf.\nmaximum_spacing: The maximum spacing between two interfaces. Default: Inf.\nstretching: The stretching law. Available options are PowerLawStretching and LinearStretching.  Default: PowerLawStretching(1.02).\nrounding_digits: the accuracy with which the grid interfaces are saved. Default: 2.\nmutable: Whether the discretization is mutable, i.e., the discretization refers to a vertical coordinate that can evolve in time following certain rules. Default: false.\n\nExamples\n\nA vertical coordinate with constant 20-meter spacing at the top 110 meters. For that, we use the defaults bias = :right and bias_edge = 0.\nusing Oceananigans\n\nz = ReferenceToStretchedDiscretization(extent = 200,\n                                       constant_spacing = 25,\n                                       constant_spacing_extent = 90)\n# output\nReferenceToStretchedDiscretization\nâ”œâ”€ extent: 200.0\nâ”œâ”€ bias: :right\nâ”œâ”€ bias_edge: 0.0\nâ”œâ”€ constant_spacing: 25.0\nâ”œâ”€ constant_spacing_extent: 90.0\nâ”œâ”€ maximum_stretching_extent: Inf\nâ”œâ”€ maximum_spacing: Inf\nâ”œâ”€ stretching: PowerLawStretching{Float64}(1.02)\nâ””â”€ faces: : 9-element Vector{Float64}\nThe z coordinate above has\nN = length(z)\n\n# output\n8\ncells. The coordinate's interfaces are:\nz.faces\n\n# output\n9-element Vector{Float64}:\n -218.16\n -185.57\n -155.13\n -126.66\n -100.0\n  -75.0\n  -50.0\n  -25.0\n    0.0\nThe coordinate has an extent that is longer from what prescribed via the extent keyword argument, namely by:\n(z.faces[end] - z.faces[1]) - z.extent\n\n# output\n\n18.159999999999997\nA coordinate that that has a 20-meter spacing for 50 meters at the left side of the domain. The left-most interface of the domain is at -50 meters and the coordinate extends for at least 250 meters.\nusing Oceananigans\n\nx = ReferenceToStretchedDiscretization(extent = 250,\n                                       bias = :left,\n                                       bias_edge = -50,\n                                       constant_spacing = 20,\n                                       constant_spacing_extent = 50)\n\nx.faces\n\n# output\n\n12-element Vector{Float64}:\n -50.0\n -30.0\n -10.0\n  10.0\n  31.23\n  53.8\n  77.82\n 103.42\n 130.74\n 159.93\n 191.16\n 224.62\nthat ends up with\nlength(x)\n\n# output\n11\ncells that span a domain of:\nx.faces[end] - x.faces[1]\n\n# output\n274.62\nwhich is bigger than the desired extent.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.RightConnected","page":"Library","title":"Oceananigans.Grids.RightConnected","text":"RightConnected\n\nGrid topology for dimensions that are connected to other models or domains only on the right (the other direction is bounded)\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Architectures.on_architecture-Tuple{Oceananigans.Architectures.AbstractSerialArchitecture, RectilinearGrid}","page":"Library","title":"Oceananigans.Architectures.on_architecture","text":"on_architecture(architecture, grid)\n\nReturn a new_grid that's identical to grid but on architecture.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.halo_size-Tuple{Any}","page":"Library","title":"Oceananigans.Grids.halo_size","text":"halo_size(grid)\n\nReturn a 3-tuple with the number of halo cells on either side of the domain in (x, y, z).\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.minimum_xspacing-Tuple{Any, Vararg{Any}}","page":"Library","title":"Oceananigans.Grids.minimum_xspacing","text":"minimum_xspacing(grid, â„“x, â„“y, â„“z)\n\nReturn the minimum spacing for grid in x direction at location â„“x, â„“y, â„“z.\n\nExamples\n\njulia> using Oceananigans\n\njulia> grid = RectilinearGrid(size=(2, 4, 8), extent=(1, 1, 1));\n\njulia> minimum_xspacing(grid, Center(), Center(), Center())\n0.5\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.minimum_yspacing-Tuple{Any, Vararg{Any}}","page":"Library","title":"Oceananigans.Grids.minimum_yspacing","text":"minimum_yspacing(grid, â„“x, â„“y, â„“z)\n\nReturn the minimum spacing for grid in y direction at location â„“x, â„“y, â„“z.\n\nExamples\n\njulia> using Oceananigans\n\njulia> grid = RectilinearGrid(size=(2, 4, 8), extent=(1, 1, 1));\n\njulia> minimum_yspacing(grid, Center(), Center(), Center())\n0.25\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.minimum_zspacing-Tuple{Any, Vararg{Any}}","page":"Library","title":"Oceananigans.Grids.minimum_zspacing","text":"minimum_zspacing(grid, â„“x, â„“y, â„“z)\nminimum_zspacing(grid) = minimum_zspacing(grid, Center(), Center(), Center())\n\nReturn the minimum spacing for grid in z direction at location â„“x, â„“y, â„“z.\n\nExamples\n\njulia> using Oceananigans\n\njulia> grid = RectilinearGrid(size=(2, 4, 8), extent=(1, 1, 1));\n\njulia> minimum_zspacing(grid, Center(), Center(), Center())\n0.125\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.new_data","page":"Library","title":"Oceananigans.Grids.new_data","text":"new_data(FT, arch, loc, topo, sz, halo_sz, indices)\n\nReturn an OffsetArray of zeros of float type FT on architecture, with indices corresponding to a field on a grid of size(grid) and located at loc.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.Grids.nodes-Tuple{Oceananigans.Grids.AbstractGrid, Any}","page":"Library","title":"Oceananigans.Grids.nodes","text":"nodes(grid, (â„“x, â„“y, â„“z); reshape=false, with_halos=false)\nnodes(grid, â„“x, â„“y, â„“z; reshape=false, with_halos=false)\n\nReturn a 3-tuple of views over the interior nodes of the grid's native coordinates at the locations in loc=(â„“x, â„“y, â„“z) in x, y, z.\n\nIf reshape=true, the views are reshaped to 3D arrays with non-singleton dimensions 1, 2, 3 for x, y, z, respectively. These reshaped arrays can then be used in broadcast operations with 3D fields or arrays.\n\nFor RectilinearGrids the native coordinates are x, y, z; for curvilinear grids, like LatitudeLongitudeGrid or OrthogonalSphericalShellGrid the native coordinates are Î», Ï†, z.\n\nSee xnodes, ynodes, znodes, Î»nodes, and Ï†nodes.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.offset_data","page":"Library","title":"Oceananigans.Grids.offset_data","text":"offset_data(underlying_data, grid::AbstractGrid, loc, indices=default_indices(length(loc)))\n\nReturn an OffsetArray that maps to underlying_data in memory, with offset indices appropriate for the data of a field on a grid of size(grid) and located at loc.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.Grids.topology-Tuple{Any, Any}","page":"Library","title":"Oceananigans.Grids.topology","text":"topology(grid, dim)\n\nReturn the topology of the grid for the dim-th dimension.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.topology-Union{Tuple{Oceananigans.Grids.AbstractGrid{FT, TX, TY, TZ}}, Tuple{TZ}, Tuple{TY}, Tuple{TX}, Tuple{FT}} where {FT, TX, TY, TZ}","page":"Library","title":"Oceananigans.Grids.topology","text":"topology(grid)\n\nReturn a tuple with the topology of the grid for each dimension.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.total_size","page":"Library","title":"Oceananigans.Grids.total_size","text":"total_size(grid, loc)\n\nReturn the \"total\" size of a grid at loc. This is a 3-tuple of integers corresponding to the number of grid points along x, y, z.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.Grids.xnodes-NTuple{4, Any}","page":"Library","title":"Oceananigans.Grids.xnodes","text":"xnodes(grid, â„“x, â„“y, â„“z, with_halos=false)\n\nReturn the positions over the interior nodes on grid in the x-direction for the location â„“x, â„“y, â„“z. For Bounded directions, Face nodes include the boundary points.\n\nSee znodes for examples.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.ynodes-NTuple{4, Any}","page":"Library","title":"Oceananigans.Grids.ynodes","text":"ynodes(grid, â„“x, â„“y, â„“z, with_halos=false)\n\nReturn the positions over the interior nodes on grid in the y-direction for the location â„“x, â„“y, â„“z. For Bounded directions, Face nodes include the boundary points.\n\nSee znodes for examples.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.Î»nodes-Tuple{Oceananigans.Grids.AbstractCurvilinearGrid, Any, Any, Any}","page":"Library","title":"Oceananigans.Grids.Î»nodes","text":"Î»nodes(grid::AbstractCurvilinearGrid, â„“x, â„“y, â„“z, with_halos=false)\n\nReturn the positions over the interior nodes on a curvilinear grid in the Î»-direction for the location â„“Î», â„“Ï†, â„“z. For Bounded directions, Face nodes include the boundary points.\n\nSee znodes for examples.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.Ï†nodes-Tuple{Oceananigans.Grids.AbstractCurvilinearGrid, Any, Any, Any}","page":"Library","title":"Oceananigans.Grids.Ï†nodes","text":"Ï†nodes(grid::AbstractCurvilinearGrid, â„“x, â„“y, â„“z, with_halos=false)\n\nReturn the positions over the interior nodes on a curvilinear grid in the Ï†-direction for the location â„“Î», â„“Ï†, â„“z. For Bounded directions, Face nodes include the boundary points.\n\nSee znodes for examples.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#OrthogonalSphericalShellGrids","page":"Library","title":"OrthogonalSphericalShellGrids","text":"","category":"section"},{"location":"appendix/library/#Oceananigans.OrthogonalSphericalShellGrids.ConformalCubedSpherePanelGrid","page":"Library","title":"Oceananigans.OrthogonalSphericalShellGrids.ConformalCubedSpherePanelGrid","text":"ConformalCubedSpherePanelGrid(architecture::AbstractArchitecture = CPU(),\n                              FT::DataType = Float64;\n                              size,\n                              z,\n                              topology = (Bounded, Bounded, Bounded),\n                              Î¾ = (-1, 1),\n                              Î· = (-1, 1),\n                              radius = Oceananigans.defaults.planet_radius,\n                              halo = (1, 1, 1),\n                              rotation = nothing,\n                              non_uniform_conformal_mapping = false,\n                              spacing_type = \"geometric\",\n                              provided_conformal_mapping = nothing)\n\nCreate a OrthogonalSphericalShellGrid that represents a section of a sphere after it has been conformally mapped from the face of a cube. The cube's coordinates are Î¾ and Î· (which, by default, both take values in the range -1 1.\n\nThe mapping from the face of the cube to the sphere is done via the CubedSphere.jl package.\n\nPositional arguments\n\narchitecture: Specifies whether arrays of coordinates and spacings are stored on the CPU or GPU. Default: CPU().\nFT : Floating point data type. Default: Float64.\n\nKeyword arguments\n\nsize (required): A 3-tuple prescribing the number of grid points each direction.\nz (required): Either a\n2-tuple that specify the end points of the z-domain,\none-dimensional array specifying the cell interface locations, or\na single-argument function that takes an index and returns cell interface location.\ntopology: A 3-tuple (TX, TY, TZ) specifying the topology of the domain. TX, TY, and TZ specify whether the             x-, y-, and z directions are Periodic, Bounded, Flat or FullyConnected. The topology Flat             indicates that a model does not vary in those directions so that derivatives and interpolation are zero.             The default is topology = (Bounded, Bounded, Bounded).\nÎ¾, Î·: Tuples specifying the ranges of the one-dimensional computational coordinates of the cubed sphere panel           grid. Defaults to (-1, 1) for both.\nradius: The radius of the sphere the grid lives on. By default this is equal to the radius of Earth.\nhalo: A 3-tuple of integers specifying the size of the halo region of cells surrounding the physical interior. The         default is 1 halo cell in every direction.\nrotation :: Rotation: Rotation of the conformal cubed sphere panel about some axis that passes through the center of                         the sphere. If nothing is provided (default), then the panel includes the North Pole of the                         sphere in its center. For example, to construct a grid that includes tha South Pole we can                         pass either rotation = RotX(Ï€) or rotation = RotY(Ï€).\nnon_uniform_conformal_mapping: If true, the cubed sphere panel grid will be generated using a non-uniform                                  conformal mapping. The default is false.\nspacing_type: Specifies the spacing scheme for the non-uniform conformal mapping. Options are \"geometric\"                 (default) or \"exponential\".\nprovided_conformal_mapping: The conformal mapping supplied by the user. Defaults to nothing.\n\nExamples\n\nThe default conformal cubed sphere panel grid with Float64 type:\n\njulia> using Oceananigans, Oceananigans.OrthogonalSphericalShellGrids\n\njulia> grid = ConformalCubedSpherePanelGrid(size=(36, 34, 25), z=(-1000, 0))\n36Ã—34Ã—25 OrthogonalSphericalShellGrid{Float64, Bounded, Bounded, Bounded} on CPU with 1Ã—1Ã—1 halo and with precomputed metrics\nâ”œâ”€â”€ centered at: North Pole, (Î», Ï†) = (0.0, 90.0)\nâ”œâ”€â”€ longitude: Bounded  extent 90.0 degrees variably spaced with min(Î”Î»)=0.616164, max(Î”Î»)=2.58892\nâ”œâ”€â”€ latitude:  Bounded  extent 90.0 degrees variably spaced with min(Î”Ï†)=0.664958, max(Î”Ï†)=2.74119\nâ””â”€â”€ z:         Bounded  z âˆˆ [-1000.0, 0.0]  regularly spaced with Î”z=40.0\n\nThe conformal cubed sphere panel that includes the South Pole with Float32 type:\n\njulia> using Oceananigans, Oceananigans.OrthogonalSphericalShellGrids, Rotations\n\njulia> grid = ConformalCubedSpherePanelGrid(Float32, size=(36, 34, 25), z=(-1000, 0), rotation=RotY(Ï€))\n36Ã—34Ã—25 OrthogonalSphericalShellGrid{Float32, Bounded, Bounded, Bounded} on CPU with 1Ã—1Ã—1 halo and with precomputed metrics\nâ”œâ”€â”€ centered at: South Pole, (Î», Ï†) = (0.0, -90.0)\nâ”œâ”€â”€ longitude: Bounded  extent 90.0 degrees variably spaced with min(Î”Î»)=0.616167, max(Î”Î»)=2.58891\nâ”œâ”€â”€ latitude:  Bounded  extent 90.0 degrees variably spaced with min(Î”Ï†)=0.664956, max(Î”Ï†)=2.7412\nâ””â”€â”€ z:         Bounded  z âˆˆ [-1000.0, 0.0]  regularly spaced with Î”z=40.0\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.OrthogonalSphericalShellGrids.RotatedLatitudeLongitudeGrid","page":"Library","title":"Oceananigans.OrthogonalSphericalShellGrids.RotatedLatitudeLongitudeGrid","text":"RotatedLatitudeLongitudeGrid(arch::AbstractArchitecture = CPU(),\n                             FT::DataType = Oceananigans.defaults.FloatType;\n                             size,\n                             north_pole,\n                             longitude,\n                             latitude,\n                             z,\n                             halo = (3, 3, 3),\n                             radius = Oceananigans.defaults.planet_radius,\n                             topology = (Bounded, Bounded, Bounded))\n\nReturn a RotatedLatitudeLongitudeGrid with arbitrary north_pole, a 2-tuple giving the longitude and latitude of the \"grid north pole\", which may differ from the geographic north pole at (0, 90).\n\nNote that longitude and latitude are interpreted as applying to the grid before the pole is rotated.\n\nAll other arguments are the same as for LatitudeLongitudeGrid.\n\nExample\n\nusing Oceananigans\nusing Oceananigans.OrthogonalSphericalShellGrids: RotatedLatitudeLongitudeGrid\n\nsize = (90, 40, 1)\nlongitude = (0, 360)\nlatitude = (-80, 80)\nz = (0, 1)\ngrid = RotatedLatitudeLongitudeGrid(; size, longitude, latitude, z, north_pole=(70, 55))\n\n# output\n90Ã—40Ã—1 OrthogonalSphericalShellGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3Ã—3Ã—3 halo and with precomputed metrics\nâ”œâ”€â”€ centered at (Î», Ï†) = (146.656, 11.3134)\nâ”œâ”€â”€ longitude: Bounded  extent 360.0 degrees variably spaced with min(Î”Î»)=0.694593, max(Î”Î»)=4.0\nâ”œâ”€â”€ latitude:  Bounded  extent 160.0 degrees variably spaced with min(Î”Ï†)=4.0, max(Î”Ï†)=4.0\nâ””â”€â”€ z:         Bounded  z âˆˆ [0.0, 1.0]       regularly spaced with Î”z=1.0\n\nWe can also make an ordinary LatitudeLongitudeGrid using north_polar = (0, 90):\n\ngrid = RotatedLatitudeLongitudeGrid(; size, longitude, latitude, z, north_pole=(0, 90))\n\n# output\n90Ã—40Ã—1 OrthogonalSphericalShellGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3Ã—3Ã—3 halo and with precomputed metrics\nâ”œâ”€â”€ centered at (Î», Ï†) = (180.0, 0.0)\nâ”œâ”€â”€ longitude: Bounded  extent 360.0 degrees variably spaced with min(Î”Î»)=0.694593, max(Î”Î»)=4.0\nâ”œâ”€â”€ latitude:  Bounded  extent 160.0 degrees variably spaced with min(Î”Ï†)=4.0, max(Î”Ï†)=4.0\nâ””â”€â”€ z:         Bounded  z âˆˆ [0.0, 1.0]       regularly spaced with Î”z=1.0\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.OrthogonalSphericalShellGrids.TripolarGrid","page":"Library","title":"Oceananigans.OrthogonalSphericalShellGrids.TripolarGrid","text":"TripolarGrid(arch = CPU(), FT::DataType = Float64;\n             size,\n             southernmost_latitude = -80,\n             halo = (4, 4, 4),\n             radius = Oceananigans.defaults.planet_radius,\n             z = (0, 1),\n             north_poles_latitude = 55,\n             first_pole_longitude = 70)\n\nReturn an OrthogonalSphericalShellGrid tripolar grid on the sphere. The tripolar grid replaces the North pole singularity with two other singularities at north_poles_latitude that is less than 90áµ’.\n\nThe grid is constructed following the formulation by Murray (1996).\n\nPositional Arguments\n\narch: The architecture to use for the grid. Default is CPU().\nFT::DataType: The data type to use for the grid. Default is Float64.\n\nKeyword Arguments\n\nsize: The number of cells in the (longitude, latitude, vertical) dimensions.\nsouthernmost_latitude: The southernmost Center latitude of the grid. Default: -80.\nhalo: The halo size in the (longitude, latitude, vertical) dimensions. Default: (4, 4, 4).\nradius: The radius of the spherical shell. Default: Oceananigans.defaults.planet_radius.\nz: The vertical z-coordinate range of the grid. Could either be:      (i) 2-tuple that specifies the end points of the coordinate,      (ii) an array with the z interfaces, or      (iii) a function of k index that returns the locations of cell interfaces            in z-direction. Default: (0, 1).\nfirst_pole_longitude: The longitude of the first \"north\" singularity.                         The second singularity is located at first_pole_longitude + 180áµ’.                         Default: 75.\nnorth_poles_latitude: The latitude of the \"north\" singularities. Default: 55.\n\nwarning: Longitude coordinate must have even number of cells\nsize is a 3-tuple of the grid size in longitude, latitude, and vertical directions. Due to requirements of the folding at the north edge of the domain, the longitude size of the grid (i.e., the first component of size) must be an even number!\n\ninfo: North pole singularities\nThe north singularities are located at: i = 1, j = grid.Ny and i = grid.Nx Ã· 2 + 1, j = grid.Ny.\n\nReferences\n\nMurray, R. J. (1996). Explicit generation of orthogonal grids for ocean models.     Journal of Computational Physics, 126(2), 251-273.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.OrthogonalSphericalShellGrids.TripolarGrid-2","page":"Library","title":"Oceananigans.OrthogonalSphericalShellGrids.TripolarGrid","text":"TripolarGrid(arch::Distributed, FT::DataType = Float64; halo = (4, 4, 4), kwargs...)\n\nConstruct a tripolar grid on a distributed architecture.\n\ncompat: Supported partitionings\nAllowed partitionings include:Only partition in y, e.g., Distributed(CPU(), partition=Partition(1, 4)).\nPartition both in x and y with x partition even. For example:\nDistributed(CPU(), partition=Partition(2, 4)) is supported\nDistributed(CPU(), partition=Partition(3, 4)) is not supportedNote that partitioning only in x, e.g., Distributed(CPU(), partition=Partition(4)) or Distributed(CPU(), partition=Partition(4, 1)) is not supported.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Immersed-boundaries","page":"Library","title":"Immersed boundaries","text":"","category":"section"},{"location":"appendix/library/#Oceananigans.ImmersedBoundaries.GridFittedBottom-Tuple{Any}","page":"Library","title":"Oceananigans.ImmersedBoundaries.GridFittedBottom","text":"GridFittedBottom(bottom_height, [immersed_condition=CenterImmersedCondition()])\n\nReturn a bottom immersed boundary.\n\nKeyword Arguments\n\nbottom_height: an array or function that gives the height of the                  bottom in absolute z coordinates.\nimmersed_condition: Determine whether the part of the domain that is                       immersed are all the cell centers that lie below                       bottom_height (CenterImmersedCondition(); default)                       or all the cell faces that lie below bottom_height                       (InterfaceImmersedCondition()). The only purpose of                       immersed_condition to allow GridFittedBottom and                       PartialCellBottom to have the same behavior when the                       minimum fractional cell height for partial cells is set                       to 0.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.ImmersedBoundaries.GridFittedBoundary","page":"Library","title":"Oceananigans.ImmersedBoundaries.GridFittedBoundary","text":"GridFittedBoundary(mask)\n\nReturn a immersed boundary with a three-dimensional mask.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.ImmersedBoundaries.ImmersedBoundaryCondition-Tuple{}","page":"Library","title":"Oceananigans.ImmersedBoundaries.ImmersedBoundaryCondition","text":"ImmersedBoundaryCondition(; interfaces...)\n\nReturn an ImmersedBoundaryCondition with conditions on individual cell interfaces âˆˆ (west, east, south, north, bottom, top) between the fluid and the immersed boundary.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.ImmersedBoundaries.ImmersedBoundaryGrid-Tuple{Oceananigans.Grids.AbstractUnderlyingGrid, Oceananigans.ImmersedBoundaries.AbstractImmersedBoundary}","page":"Library","title":"Oceananigans.ImmersedBoundaries.ImmersedBoundaryGrid","text":"ImmersedBoundaryGrid(grid, ib::AbstractImmersedBoundary;\n                     active_cells_map=false, active_z_columns=active_cells_map)\n\nReturn a grid with an AbstractImmersedBoundary immersed boundary (ib). If active_cells_map or active_z_columns are true, the grid will populate interior_active_cells and active_z_columns fields â€“ a list of active indices in the interior and on a reduced x-y plane, respectively.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.ImmersedBoundaries.PartialCellBottom-Tuple{Any}","page":"Library","title":"Oceananigans.ImmersedBoundaries.PartialCellBottom","text":"PartialCellBottom(bottom_height; minimum_fractional_cell_height=0.2)\n\nReturn PartialCellBottom representing an immersed boundary with \"partial\" bottom cells. That is, the height of the bottommost cell in each column is reduced to fit the provided bottom_height, which may be a Field, Array, or function of (x, y).\n\nThe height of partial bottom cells is greater than\n\nminimum_fractional_cell_height * Î”z,\n\nwhere Î”z is the original height of the bottom cell underlying grid.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Logger","page":"Library","title":"Logger","text":"","category":"section"},{"location":"appendix/library/#Oceananigans.Logger.OceananigansLogger","page":"Library","title":"Oceananigans.Logger.OceananigansLogger","text":"OceananigansLogger(stream::IO=stdout, level=Logging.Info; show_info_source=false)\n\nBased on Logging.SimpleLogger, it tries to log all messages in the following format:\n\n[yyyy/mm/dd HH:MM:SS.sss] log_level message [-@-> source_file:line_number]\n\nwhere the source of the message between the square brackets is included only if show_info_source=true or if the message is not an info level message.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Models","page":"Library","title":"Models","text":"","category":"section"},{"location":"appendix/library/#Oceananigans.Models.BoundaryConditionOperation-Tuple{Field, Symbol, Oceananigans.AbstractModel}","page":"Library","title":"Oceananigans.Models.BoundaryConditionOperation","text":"BoundaryConditionOperation(field::Field, side::Symbol, model::AbstractModel)\n\nReturns a KernelFunctionOperation that evaluates a field's boundary condition on the specified side using the properties of model.\n\nExample\n\nBuild a BoundaryConditionOperation for a top flux boundary condition:\n\nusing Oceananigans\nusing Oceananigans.Models: BoundaryConditionOperation\n\ngrid = RectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1))\n\nc_flux(x, y, t) = sin(2Ï€ * x)\nc_top_bc = FluxBoundaryCondition(c_flux)\nc_bcs = FieldBoundaryConditions(top=c_top_bc)\nmodel = NonhydrostaticModel(; grid, tracers=:c, boundary_conditions=(; c=c_bcs))\n\nc_flux_op = BoundaryConditionOperation(model.tracers.c, :top, model)\n\n# output\nKernelFunctionOperation at (Center, Center, â‹…)\nâ”œâ”€â”€ grid: 16Ã—16Ã—16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ kernel_function: BoundaryConditionKernelFunction{top}(Flux)\nâ””â”€â”€ arguments: (\"Clock\", \"NamedTuple\")\n\nNext, we build a BoundaryConditionField for the top flux, and compute it:\n\nusing Oceananigans.Models: BoundaryConditionField\nc_flux_field = BoundaryConditionField(model.tracers.c, :top, model)\ncompute!(c_flux_field)\n\n# output\n16Ã—16Ã—1 Field{Center, Center, Nothing} reduced over dims = (3,) on RectilinearGrid on CPU\nâ”œâ”€â”€ grid: 16Ã—16Ã—16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ boundary conditions: FieldBoundaryConditions\nâ”‚   â””â”€â”€ west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: Nothing\nâ”œâ”€â”€ operand: KernelFunctionOperation at (Center, Center, â‹…)\nâ”œâ”€â”€ status: time=0.0\nâ””â”€â”€ data: 22Ã—22Ã—1 OffsetArray(::Array{Float64, 3}, -2:19, -2:19, 1:1) with eltype Float64 with indices -2:19Ã—-2:19Ã—1:1\n    â””â”€â”€ max=0.980785, min=-0.980785, mean=1.0842e-19\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Models.ForcingOperation-Tuple{Symbol, Oceananigans.AbstractModel}","page":"Library","title":"Oceananigans.Models.ForcingOperation","text":"ForcingOperation(name::Symbol, model::AbstractModel)\n\nCreate a KernelFunctionOperation that evaluates the model.forcing for prognostic variable name.\n\nExample\n\nusing Oceananigans\nusing Oceananigans.Models: ForcingOperation\n\ngrid = RectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1))\n\ndamping(x, y, z, t, c, Ï„) = - c / Ï„\nc_forcing = Forcing(damping, field_dependencies=:c, parameters=60)\nmodel = NonhydrostaticModel(; grid, tracers=:c, forcing=(; c=c_forcing))\n\nc_forcing_op = ForcingOperation(:c, model)\n\n# output\nKernelFunctionOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 16Ã—16Ã—16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ kernel_function: ForcingKernelFunction\nâ””â”€â”€ arguments: (\"Clock\", \"NamedTuple\")\n\nNext, we build a ForcingField for the damping, and compute it:\n\nusing Oceananigans.Models: ForcingField\nset!(model, c=1)\nc_forcing_field = ForcingField(:c, model)\ncompute!(c_forcing_field)\n\n# output\n16Ã—16Ã—16 Field{Center, Center, Center} on RectilinearGrid on CPU\nâ”œâ”€â”€ grid: 16Ã—16Ã—16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ boundary conditions: FieldBoundaryConditions\nâ”‚   â””â”€â”€ west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: Nothing\nâ”œâ”€â”€ operand: KernelFunctionOperation at (Center, Center, Center)\nâ”œâ”€â”€ status: time=0.0\nâ””â”€â”€ data: 22Ã—22Ã—22 OffsetArray(::Array{Float64, 3}, -2:19, -2:19, -2:19) with eltype Float64 with indices -2:19Ã—-2:19Ã—-2:19\n    â””â”€â”€ max=-0.0166667, min=-0.0166667, mean=-0.0166667\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Models.seawater_density-NTuple{5, Any}","page":"Library","title":"Oceananigans.Models.seawater_density","text":"Return a KernelFunctionOperation to compute the in-situ seawater_density.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Models.seawater_density-Tuple{Union{HydrostaticFreeSurfaceModel, NonhydrostaticModel}}","page":"Library","title":"Oceananigans.Models.seawater_density","text":"seawater_density(model;\n                 temperature = model_temperature(model.buoyancy.formulation, model),\n                 salinity = model_salinity(model.buoyancy.formulation, model),\n                 geopotential_height = model_geopotential_height(model)\n\nReturn a KernelFunctionOperation that computes the in-situ density of seawater with (gridded) temperature, salinity, and at geopotential_height. To compute the in-situ density, the 55-term polynomial approximation to the equation of state from Roquet et al. (2015) is used. By default, the seawater_density extracts the geopotential height from the model to compute the in-situ density. To compute a potential density at some user-chosen reference geopotential height, set geopotential_height to a constant for the density computation,\n\ngeopotential_height = 0 # sea-surface height\nÏƒâ‚€ = seawater_density(model; geopotential_height)\n\nNote: seawater_density must be passed a BoussinesqEquationOfState to compute the density. See the relevant documentation for how to set SeawaterBuoyancy using a BoussinesqEquationOfState.\n\nExample\n\nCompute a density Field using the KernelFunctionOperation returned from seawater_density\n\njulia> using Oceananigans, SeawaterPolynomials.TEOS10\n\njulia> using Oceananigans.Models: seawater_density\n\njulia> grid = RectilinearGrid(size=100, z=(-1000, 0), topology=(Flat, Flat, Bounded))\n1Ã—1Ã—100 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0Ã—0Ã—3 halo\nâ”œâ”€â”€ Flat x\nâ”œâ”€â”€ Flat y\nâ””â”€â”€ Bounded  z âˆˆ [-1000.0, 0.0] regularly spaced with Î”z=10.0\n\njulia> tracers = (:T, :S)\n(:T, :S)\n\njulia> eos = TEOS10EquationOfState()\nBoussinesqEquationOfState{Float64}:\nâ”œâ”€â”€ seawater_polynomial: TEOS10SeawaterPolynomial{Float64}\nâ””â”€â”€ reference_density: 1020.0\n\njulia> buoyancy = SeawaterBuoyancy(equation_of_state=eos)\nSeawaterBuoyancy{Float64}:\nâ”œâ”€â”€ gravitational_acceleration: 9.80665\nâ””â”€â”€ equation_of_state: BoussinesqEquationOfState{Float64}\n\njulia> model = NonhydrostaticModel(; grid, buoyancy, tracers)\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 1Ã—1Ã—100 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0Ã—0Ã—3 halo\nâ”œâ”€â”€ timestepper: RungeKutta3TimeStepper\nâ”œâ”€â”€ advection scheme: Centered(order=2)\nâ”œâ”€â”€ tracers: (T, S)\nâ”œâ”€â”€ closure: Nothing\nâ”œâ”€â”€ buoyancy: SeawaterBuoyancy with g=9.80665 and BoussinesqEquationOfState{Float64} with gÌ‚ = NegativeZDirection()\nâ””â”€â”€ coriolis: Nothing\n\njulia> set!(model, S = 34.7, T = 0.5)\n\njulia> density_operation = seawater_density(model)\nKernelFunctionOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 1Ã—1Ã—100 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0Ã—0Ã—3 halo\nâ”œâ”€â”€ kernel_function: Ï (generic function with 3 methods)\nâ””â”€â”€ arguments: (\"SeawaterPolynomials.BoussinesqEquationOfState\", \"Field\", \"Field\", \"KernelFunctionOperation\")\n\njulia> density_field = Field(density_operation)\n1Ã—1Ã—100 Field{Center, Center, Center} on RectilinearGrid on CPU\nâ”œâ”€â”€ grid: 1Ã—1Ã—100 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0Ã—0Ã—3 halo\nâ”œâ”€â”€ boundary conditions: FieldBoundaryConditions\nâ”‚   â””â”€â”€ west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: ZeroFlux, top: ZeroFlux, immersed: Nothing\nâ”œâ”€â”€ operand: KernelFunctionOperation at (Center, Center, Center)\nâ”œâ”€â”€ status: time=0.0\nâ””â”€â”€ data: 1Ã—1Ã—106 OffsetArray(::Array{Float64, 3}, 1:1, 1:1, -2:103) with eltype Float64 with indices 1:1Ã—1:1Ã—-2:103\n    â””â”€â”€ max=1032.38, min=1027.73, mean=1030.06\n\nValues for temperature, salinity and geopotential_height can be passed to seawater_density to override the defaults that are obtained from the model.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Non-hydrostatic-models","page":"Library","title":"Non-hydrostatic models","text":"","category":"section"},{"location":"appendix/library/#Oceananigans.Models.NonhydrostaticModels.BackgroundField","page":"Library","title":"Oceananigans.Models.NonhydrostaticModels.BackgroundField","text":"BackgroundField{F, P}\n\nTemporary container for storing information about BackgroundFields.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Models.NonhydrostaticModels.BackgroundField-Tuple{Any}","page":"Library","title":"Oceananigans.Models.NonhydrostaticModels.BackgroundField","text":"BackgroundField(func; parameters=nothing)\n\nReturns a BackgroundField to be passed to NonhydrostaticModel for use as a background velocity or tracer field.\n\nIf parameters is not provided, func must be callable with the signature\n\nfunc(x, y, z, t)\n\nIf parameters is provided, func must be callable with the signature\n\nfunc(x, y, z, t, parameters)\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Models.NonhydrostaticModels.NonhydrostaticModel-Tuple{}","page":"Library","title":"Oceananigans.Models.NonhydrostaticModels.NonhydrostaticModel","text":"NonhydrostaticModel(;           grid,\n                                clock = Clock{eltype(grid)}(time = 0),\n                            advection = Centered(),\n                             buoyancy = nothing,\n                             coriolis = nothing,\n                         stokes_drift = nothing,\n                  forcing::NamedTuple = NamedTuple(),\n                              closure = nothing,\n      boundary_conditions::NamedTuple = NamedTuple(),\n                              tracers = (),\n                          timestepper = :RungeKutta3,\n        background_fields::NamedTuple = NamedTuple(),\n        particles::ParticlesOrNothing = nothing,\nbiogeochemistry::AbstractBGCOrNothing = nothing,\n                           velocities = nothing,\n              nonhydrostatic_pressure = CenterField(grid),\n         hydrostatic_pressure_anomaly = DefaultHydrostaticPressureAnomaly(),\n                   diffusivity_fields = nothing,\n                      pressure_solver = nothing,\n                     auxiliary_fields = NamedTuple())\n\nConstruct a model for a non-hydrostatic, incompressible fluid on grid, using the Boussinesq approximation when buoyancy != nothing. By default, all Bounded directions are rigid and impenetrable.\n\nKeyword arguments\n\ngrid: (required) The resolution and discrete geometry on which the model is solved. The         architecture (CPU/GPU) that the model is solved on is inferred from the architecture         of the grid. Note that the grid needs to be regularly spaced in the horizontal         dimensions, x and y.\nadvection: The scheme that advects velocities and tracers. See Oceananigans.Advection.\nbuoyancy: The buoyancy model. See Oceananigans.BuoyancyFormulations.\ncoriolis: Parameters for the background rotation rate of the model.\nstokes_drift: Parameters for Stokes drift fields associated with surface waves. Default: nothing.\nforcing: NamedTuple of user-defined forcing functions that contribute to solution tendencies.\nclosure: The turbulence closure for model. See Oceananigans.TurbulenceClosures.\nboundary_conditions: NamedTuple containing field boundary conditions.\ntracers: A tuple of symbols defining the names of the modeled tracers, or a NamedTuple of            preallocated CenterFields.\ntimestepper: A symbol that specifies the time-stepping method. Either :QuasiAdamsBashforth2 or                :RungeKutta3 (default).\nbackground_fields: NamedTuple with background fields (e.g., background flow). Default: nothing.\nparticles: Lagrangian particles to be advected with the flow. Default: nothing.\nbiogeochemistry: Biogeochemical model for tracers.\nvelocities: The model velocities. Default: nothing.\nnonhydrostatic_pressure: The nonhydrostatic pressure field. Default: CenterField(grid).\nhydrostatic_pressure_anomaly: An optional field that stores the part of the nonhydrostatic pressure                                 in hydrostatic balance with the buoyancy field. If CenterField(grid) (default), the anomaly is precomputed by                                 vertically integrating the buoyancy field. In this case, the nonhydrostatic_pressure represents                                 only the part of pressure that deviates from the hydrostatic anomaly. If nothing, the anomaly                                 is not computed.\ndiffusivity_fields: Diffusivity fields. Default: nothing.\npressure_solver: Pressure solver to be used in the model. If nothing (default), the model constructor chooses the default based on the grid provide.\nauxiliary_fields: NamedTuple of auxiliary fields. Default: nothing\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Hydrostatic-free-surface-models","page":"Library","title":"Hydrostatic free-surface models","text":"","category":"section"},{"location":"appendix/library/#Oceananigans.Models.HydrostaticFreeSurfaceModels.ExplicitFreeSurface","page":"Library","title":"Oceananigans.Models.HydrostaticFreeSurfaceModels.ExplicitFreeSurface","text":"struct ExplicitFreeSurface{E, T}\n\nThe explicit free surface solver.\n\nÎ·::Any: free surface elevation\ngravitational_acceleration::Any: gravitational accelerations\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Models.HydrostaticFreeSurfaceModels.HydrostaticFreeSurfaceModel-Tuple{}","page":"Library","title":"Oceananigans.Models.HydrostaticFreeSurfaceModels.HydrostaticFreeSurfaceModel","text":"HydrostaticFreeSurfaceModel(; grid,\n                            clock = Clock{Float64}(time = 0),\n                            momentum_advection = VectorInvariant(),\n                            tracer_advection = Centered(),\n                            buoyancy = SeawaterBuoyancy(eltype(grid)),\n                            coriolis = nothing,\n                            free_surface = [default_free_surface],\n                            forcing::NamedTuple = NamedTuple(),\n                            closure = nothing,\n                            timestepper = :QuasiAdamsBashforth2,\n                            boundary_conditions::NamedTuple = NamedTuple(),\n                            tracers = (:T, :S),\n                            particles::ParticlesOrNothing = nothing,\n                            biogeochemistry::AbstractBGCOrNothing = nothing,\n                            velocities = nothing,\n                            pressure = nothing,\n                            diffusivity_fields = nothing,\n                            auxiliary_fields = NamedTuple(),\n                            vertical_coordinate = default_vertical_coordinate(grid))\n\nConstruct a hydrostatic model with a free surface on grid.\n\nKeyword arguments\n\ngrid: (required) The resolution and discrete geometry on which model is solved. The         architecture (CPU/GPU) that the model is solved is inferred from the architecture         of the grid.\nmomentum_advection: The scheme that advects velocities. See Oceananigans.Advection.\ntracer_advection: The scheme that advects tracers. See Oceananigans.Advection.\nbuoyancy: The buoyancy model. See Oceananigans.BuoyancyFormulations.\ncoriolis: Parameters for the background rotation rate of the model.\nfree_surface: The free surface model. The default free-surface solver depends on the                 geometry of the grid. If the grid is a RectilinearGrid that is                 regularly spaced in the horizontal the default is an ImplicitFreeSurface                 solver with solver_method = :FFTBasedPoissonSolver. In all other cases,                 the default is a SplitExplicitFreeSurface.\ntracers: A tuple of symbols defining the names of the modeled tracers, or a NamedTuple of            preallocated CenterFields.\nforcing: NamedTuple of user-defined forcing functions that contribute to solution tendencies.\nclosure: The turbulence closure for model. See Oceananigans.TurbulenceClosures.\ntimestepper: A symbol that specifies the time-stepping method.                Either :QuasiAdamsBashforth2 (default) or :SplitRungeKutta3.\nboundary_conditions: NamedTuple containing field boundary conditions.\nparticles: Lagrangian particles to be advected with the flow. Default: nothing.\nbiogeochemistry: Biogeochemical model for tracers.\nvelocities: The model velocities. Default: nothing.\npressure: Hydrostatic pressure field. Default: nothing.\ndiffusivity_fields: Diffusivity fields. Default: nothing.\nauxiliary_fields: NamedTuple of auxiliary fields. Default: nothing.\nvertical_coordinate: Algorithm for grid evolution: ZStarCoordinate() or ZCoordinate(grid).                        Default: default_vertical_coordinate(grid), which returns ZStarCoordinate(grid)                        for grids with MutableVerticalDiscretization otherwise returns                        ZCoordinate().\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Models.HydrostaticFreeSurfaceModels.ImplicitFreeSurface-Tuple{}","page":"Library","title":"Oceananigans.Models.HydrostaticFreeSurfaceModels.ImplicitFreeSurface","text":"ImplicitFreeSurface(; solver_method = :Default,\n                    gravitational_acceleration = Oceananigans.defaults.gravitational_acceleration,\n                    solver_settings...)\n\nReturn an implicit free-surface solver. The implicit free-surface equation is\n\nleft  _h  (H _h) - frac1g Î”t^2 right  Î·^n+1 = frac_h  ğ_g Î”t - fracÎ·^ng Î”t^2 \n\nwhere Î·^n is the free-surface elevation at the n-th time step, H is depth, g is the gravitational acceleration, Î”t is the time step, _h is the horizontal gradient operator, and ğ_ is the barotropic volume flux associated with the predictor velocity field ğ®_, i.e.,\n\nğ_ = int_-H^0 ğ®_  ğ–½ z \n\nwhere\n\nğ®_ = ğ®^n + int_t_n^t_n+1 ğ†áµ¤  ğ–½t \n\nThis equation can be solved, in general, using the ConjugateGradientSolver but other solvers can be invoked in special cases.\n\nIf H is constant, we divide through out to obtain\n\nleft ( ^2_h - frac1g H Î”t^2 right ) Î·^n+1  = frac1g H Î”t left ( _h  ğ_ - fracÎ·^nÎ”t right ) \n\nThus, for constant H and on grids with regular spacing in x and y directions, the free surface can be obtained using the FFTBasedPoissonSolver.\n\nsolver_method can be either of:\n\n:FastFourierTransform for FFTBasedPoissonSolver\n:PreconditionedConjugateGradient for ConjugateGradientSolver\n\nBy default, if the grid has regular spacing in the horizontal directions then the :FastFourierTransform is chosen, otherwise the :PreconditionedConjugateGradient.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Models.HydrostaticFreeSurfaceModels.PrescribedVelocityFields-Tuple{}","page":"Library","title":"Oceananigans.Models.HydrostaticFreeSurfaceModels.PrescribedVelocityFields","text":"PrescribedVelocityFields(; u = ZeroField(),\n                           v = ZeroField(),\n                           w = ZeroField(),\n                           parameters = nothing)\n\nBuilds PrescribedVelocityFields with prescribed functions u, v, and w.\n\nIf isnothing(parameters), then u, v, w are called with the signature\n\nu(x, y, z, t) = # something interesting\n\nIf !isnothing(parameters), then u, v, w are called with the signature\n\nu(x, y, z, t, parameters) = # something parameterized and interesting\n\nIn the constructor for HydrostaticFreeSurfaceModel, the functions u, v, w are wrapped in FunctionField and associated with the model's grid and clock.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Split-explicit-free-surface","page":"Library","title":"Split-explicit free-surface","text":"","category":"section"},{"location":"appendix/library/#Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurfaces.AdamsBashforth3Scheme-Tuple{}","page":"Library","title":"Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurfaces.AdamsBashforth3Scheme","text":"AdamsBashforth3Scheme(; Î² = 0.281105,\n                        Î± = 1.5 + Î²,\n                        Î¸ = -0.5 - 2Î²,\n                        Î³ = 0.088,\n                        Î´ = 0.614,\n                        Ïµ = 0.013,\n                        Î¼ = 1 - Î´ - Î³ - Ïµ)\n\nCreate an instance of AdamsBashforth3Scheme with the specified parameters. This scheme is used for substepping in the split-explicit free surface solver, where an AB3 extrapolation is used to evaluate barotropic velocities and free surface at time-step m + 1/2:\n\nThe equations are evolved as follows:\n\nbegingather\nÎ·^m+1 = Î·^m - Î”Ï„ g H (_x U + y V) \nU^m+1 = U^m - Î”Ï„ (_x Î· - G^U) \nV^m+1 = V^m - Î”Ï„ (_y Î· - G^V)\nendgather\n\nwhere Î·Ìƒ, UÌƒ and VÌƒ are the AB3 time-extrapolated values of free surface, barotropic zonal and meridional velocities, respectively:\n\nbegingather\nU = Î± U^m + Î¸ U^m-1 + Î² U^m-2 \nV = Î± V^m + Î¸ V^m-1 + Î² V^m-2 \nÎ· = Î´ Î·^m+1 + Î¼ Î·^m + Î³ Î·^m-1 + Ïµ Î·^m-2\nendgather\n\nThe default values for the time-extrapolation coefficients, described by Shchepetkin and McWilliams (2005), correspond to the best stability range for the AB3 algorithm.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurfaces.FixedSubstepNumber","page":"Library","title":"Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurfaces.FixedSubstepNumber","text":"An internal type for the SplitExplicitFreeSurface that allows substepping with a fixed number of substeps with time step size of fractional_step_size * Î”t_baroclinic \n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurfaces.FixedTimeStepSize","page":"Library","title":"Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurfaces.FixedTimeStepSize","text":"An internal type for the SplitExplicitFreeSurface that allows substepping with a fixed Î”t_barotropic based on a CFL condition \n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurfaces.ForwardBackwardScheme","page":"Library","title":"Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurfaces.ForwardBackwardScheme","text":"struct ForwardBackwardScheme\n\nA timestepping scheme used for substepping in the split-explicit free surface solver.\n\nThe equations are evolved as follows:\n\nbegingather\nÎ·^m+1 = Î·^m - Î”Ï„ (_x U^m + _y V^m) \nU^m+1 = U^m - Î”Ï„ (_x Î·^m+1 - G^U) \nV^m+1 = V^m - Î”Ï„ (_y Î·^m+1 - G^V)\nendgather\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurfaces.SplitExplicitFreeSurface","page":"Library","title":"Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurfaces.SplitExplicitFreeSurface","text":"SplitExplicitFreeSurface(grid = nothing;\n                         gravitational_acceleration = Oceananigans.defaults.gravitational_acceleration,\n                         substeps = nothing,\n                         cfl = nothing,\n                         fixed_Î”t = nothing,\n                         averaging_kernel = averaging_shape_function,\n                         timestepper = ForwardBackwardScheme())\n\nReturn a SplitExplicitFreeSurface representing an explicit time discretization of a free surface dynamics with gravitational_acceleration. The free surface dynamics are solved by discretizing:\n\nbegingather\n_t Î· = - nabla  U \n_t U = - g H nabla Î· + G^U\nendgather\n\nwhere Î· is the free surface displacement, U is the barotropic velocity vector, calculated as the vertical integral of the velocity field u and v, H is the column depth, G^U is the slow forcing calculated as the integral of the tendency of u and v, and g is the gravitational acceleration.\n\nThe discretized equations are solved within a baroclinic timestep (Î”t) by substepping with a Î”Ï„  Î”t. The barotropic velocities are filtered throughout the substepping and, finally, the barotropic mode of the velocities at the new time step is corrected with the filtered velocities.\n\nKeyword Arguments\n\ngravitational_acceleration: the gravitational acceleration (default: Oceananigans.defaults.gravitational_acceleration)\nsubsteps: The number of substeps that divide the range (t, t + 2Î”t), where Î”t is the baroclinic             timestep. Note that some averaging functions do not require substepping until 2Î”t.             The number of substeps is reduced automatically to the last index of averaging_kernel             for which averaging_kernel > 0.\ncfl: If set then the number of substeps are computed based on the advective timescale imposed from        the barotropic gravity-wave speed that corresponds to depth grid.Lz. If fixed_Î”t is provided,        then the number of substeps adapts to maintain an exact cfl. If not, the effective cfl will        always be lower than the specified cfl provided that the baroclinic time step satisfies        Î”t_baroclinic < fixed_Î”t.\n\ninfo: Needed keyword arguments\nEither substeps or cfl need to be prescribed.When cfl is prescribed then grid is also required as a positional argument.\n\nfixed_Î”t: The maximum baroclinic timestep allowed. If fixed_Î”t is a nothing and a cfl is provided,             then the number of substeps will be computed on the fly from the baroclinic time step to             maintain a constant cfl.\naveraging_kernel: A function of Ï„ used to average the barotropic transport U and the free surface                     Î· within the barotropic advancement. Ï„ is the fractional substep going from 0 to 2                     with the baroclinic time step t + Î”t located at Ï„ = 1. The averaging_kernel                     function should be centered at Ï„ = 1, that is,  (aâ‚˜ m  M) = 1, where the                     the summation occurs for m = 1  M_*. Here, m = 0 and m = M correspond                     to the two consecutive baroclinic timesteps between which the barotropic timestepping                     occurs and M_* corresponds to the last barotropic time step for which the                     averaging_kernel > 0. By default, the averaging kernel described by                     Shchepetkin and McWilliams (2005) is used.\ntimestepper: Time stepping scheme used for the barotropic advancement. Choose one of:\nForwardBackwardScheme() (default): Î· = f(U)   then U = f(Î·),\nAdamsBashforth3Scheme(): Î· = f(U, Uáµâ»Â¹, Uáµâ»Â²) then U = f(Î·, Î·áµ, Î·áµâ»Â¹, Î·áµâ»Â²).\n\nReferences\n\nShchepetkin, A. F., and McWilliams, J. C. (2005). The regional oceanic modeling system (ROMS): a split-explicit, free-surface, topography-following-coordinate oceanic model. Ocean Modelling, 9(4), 347-404.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Shallow-water-models","page":"Library","title":"Shallow-water models","text":"","category":"section"},{"location":"appendix/library/#Oceananigans.Models.ShallowWaterModels.ShallowWaterModel-Tuple{}","page":"Library","title":"Oceananigans.Models.ShallowWaterModels.ShallowWaterModel","text":"ShallowWaterModel(; grid,\n                    gravitational_acceleration,\n                          clock = Clock{eltype(grid)}(time = 0),\n             momentum_advection = UpwindBiased(order=5),\n               tracer_advection = WENO(),\n                 mass_advection = WENO(),\n                       coriolis = nothing,\n            forcing::NamedTuple = NamedTuple(),\n                        closure = nothing,\n                     bathymetry = nothing,\n                        tracers = (),\n             diffusivity_fields = nothing,\nboundary_conditions::NamedTuple = NamedTuple(),\n            timestepper::Symbol = :RungeKutta3,\n                    formulation = ConservativeFormulation())\n\nConstruct a shallow water model on grid with gravitational_acceleration constant.\n\nKeyword arguments\n\ngrid: (required) The resolution and discrete geometry on which model is solved. The         architecture (CPU/GPU) that the model is solve is inferred from the architecture         of the grid.\ngravitational_acceleration: (required) The gravitational acceleration constant.\nclock: The clock for the model.\nmomentum_advection: The scheme that advects velocities. See Oceananigans.Advection. Default: UpwindBiased(order=5).\ntracer_advection: The scheme that advects tracers. See Oceananigans.Advection. Default: WENO().\nmass_advection: The scheme that advects the mass equation. See Oceananigans.Advection. Default: WENO().\ncoriolis: Parameters for the background rotation rate of the model.\nforcing: NamedTuple of user-defined forcing functions that contribute to solution tendencies.\nclosure: The turbulence closure for model. See Oceananigans.TurbulenceClosures.\nbathymetry: The bottom bathymetry.\ntracers: A tuple of symbols defining the names of the modeled tracers, or a NamedTuple of            preallocated CenterFields.\ndiffusivity_fields: Stores diffusivity fields when the closures require a diffusivity to be                       calculated at each timestep.\nboundary_conditions: NamedTuple containing field boundary conditions.\ntimestepper: A symbol that specifies the time-stepping method. Either :QuasiAdamsBashforth2 or                :RungeKutta3 (default).\nformulation: Whether the dynamics are expressed in conservative form (ConservativeFormulation();                default) or in non-conservative form with a vector-invariant formulation for the                non-linear terms (VectorInvariantFormulation()).\n\nwarning: Formulation-grid compatibility requirements\nThe ConservativeFormulation() requires RectilinearGrid. Use VectorInvariantFormulation() with LatitudeLongitudeGrid.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Models.ShallowWaterModels.ShallowWaterScalarDiffusivity","page":"Library","title":"Oceananigans.Models.ShallowWaterModels.ShallowWaterScalarDiffusivity","text":"ShallowWaterScalarDiffusivity([FT::DataType=Float64;]\n                              Î½=0, Î¾=0, discrete_form=false)\n\nReturn a scalar diffusivity for the shallow water model.\n\nThe diffusivity for the shallow water model is calculated as h * Î½ so that we get a viscous term in the form h^-1   (h Î½ t), where t is the 2D stress tensor plus a trace, i.e., t = ğ® + (ğ®)^T - Î¾ I  (  ğ®).\n\nWith the VectorInvariantFormulation() (that evolves u and v) we compute h^-1 (Î½ h  t), while with the ConservativeFormulation() (that evolves u h and v h) we compute  (Î½ h  t).\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Lagrangian-particle-tracking","page":"Library","title":"Lagrangian particle tracking","text":"","category":"section"},{"location":"appendix/library/#Oceananigans.Models.LagrangianParticleTracking.DroguedParticleDynamics","page":"Library","title":"Oceananigans.Models.LagrangianParticleTracking.DroguedParticleDynamics","text":"DroguedParticleDynamics(depths)\n\nDroguedParticleDynamics goes in the dynamics slot of LagrangianParticles  and modifies their behaviour to mimic the behaviour of bouys which are  drogued at depths. The particles remain at the their z position so the \"measurment depth can be set\", and then are advected in the x and y directions according to the velocity field at depths.\n\ndepths should be an (abstract) array of length length(particles).\n\nExample\n\njulia> using Oceananigans\n\njulia> n = 10\n10\n\njulia> dynamics = DroguedParticleDynamics(-10:10/n:0)\nDroguedParticleDynamics{StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}(-10.0:1.0:0.0)\n\njulia> particles = LagrangianParticles(; x = zeros(n), y = zeros(n), z = zeros(n), dynamics)\n10 LagrangianParticles with eltype Particle:\nâ”œâ”€â”€ 3 properties: (:x, :y, :z)\nâ”œâ”€â”€ particle-wall restitution coefficient: 1.0\nâ”œâ”€â”€ 0 tracked fields: ()\nâ””â”€â”€ dynamics: DroguedParticleDynamics{StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}\n\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Models.LagrangianParticleTracking.LagrangianParticles-Tuple{StructArrays.StructArray}","page":"Library","title":"Oceananigans.Models.LagrangianParticleTracking.LagrangianParticles","text":"LagrangianParticles(particles::StructArray;\n                    restitution = 1.0,\n                    tracked_fields::NamedTuple=NamedTuple(),\n                    dynamics = no_dynamics,\n                    parameters = nothing)\n\nConstruct some LagrangianParticles that can be passed to a model. The particles should be a StructArray and can contain custom fields. The coefficient of restitution for particle-wall collisions is specified by restitution.\n\nA number of tracked_fields may be passed in as a NamedTuple of fields. Each particle will track the value of each field. Each tracked field must have a corresponding particle property. So if T is a tracked field, then T must also be a custom particle property.\n\ndynamics is a function of (lagrangian_particles, model, Î”t) that is called prior to advecting particles. parameters can be accessed inside the dynamics function.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Models.LagrangianParticleTracking.LagrangianParticles-Tuple{}","page":"Library","title":"Oceananigans.Models.LagrangianParticleTracking.LagrangianParticles","text":"LagrangianParticles(; x, y, z, restitution=1.0, dynamics=no_dynamics, parameters=nothing)\n\nConstruct some LagrangianParticles that can be passed to a model. The particles have initial locations x, y, and z. The coefficient of restitution for particle-wall collisions is specified by restitution.\n\ndynamics is a function of (lagrangian_particles, model, Î”t) that is called prior to advecting particles. parameters can be accessed inside the dynamics function.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#VarianceDissipationComputations","page":"Library","title":"VarianceDissipationComputations","text":"","category":"section"},{"location":"appendix/library/#Oceananigans.Models.VarianceDissipationComputations.VarianceDissipation-Tuple{Any, Any}","page":"Library","title":"Oceananigans.Models.VarianceDissipationComputations.VarianceDissipation","text":"VarianceDissipation(tracer_name, grid;\n                    Uâ¿â»Â¹ = VelocityFields(grid),\n                    Uâ¿   = VelocityFields(grid))\n\nConstruct a VarianceDissipation object for a tracer called tracer_name that lives on grid. This function computes the variance dissipation diagnostics for the specified tracer in the model. These include the numerical dissipation implicit to the advection scheme and the explicit dissipation associated to closures.\n\nThis diagnostic is especially useful for models that use a dissipative advection scheme like WENO or UpwindBiased.\n\nArguments\n\ntracer_name: The name of the tracer for which variance dissipation is computed. This should                be a Symbol. When calling Ïµ::VarianceDissipation on the model, this name is                used to identify the tracer in the model's state.\ngrid: The grid on which the tracer is defined.\n\nKeyword Arguments\n\nUâ¿â»Â¹: The velocity field at the previous time step. Default: VelocityFields(grid).\nUâ¿: The velocity field at the current time step. Default: VelocityFields(grid).\n\ncompat: Time stepper compatibility\nAt the moment, the variance dissipation diagnostic is supported only for a QuasiAdamsBashforth2TimeStepper and a SplitRungeKutta3TimeStepper.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Models.VarianceDissipationComputations.flatten_dissipation_fields-Tuple{Oceananigans.Models.VarianceDissipationComputations.VarianceDissipation}","page":"Library","title":"Oceananigans.Models.VarianceDissipationComputations.flatten_dissipation_fields","text":"flatten_dissipation_fields(t::VarianceDissipation)\n\nFlatten the dissipation fields of a VarianceDissipation object into a named tuple containing:\n\nThe dissipation associated with the advection scheme in fields named A-tracername-dir\nThe dissipation associated with the closures in fields names D-tracername-dir\nThe squared gradients (necessary for computing an \"effective diffusivity\") in fields named G-tracername-dir\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#MultiRegion","page":"Library","title":"MultiRegion","text":"","category":"section"},{"location":"appendix/library/#Oceananigans.MultiRegion.ConformalCubedSphereGrid","page":"Library","title":"Oceananigans.MultiRegion.ConformalCubedSphereGrid","text":"ConformalCubedSphereGrid(arch=CPU(), FT=Float64;\n                         panel_size,\n                         z,\n                         horizontal_direction_halo = 1,\n                         z_halo = horizontal_direction_halo,\n                         horizontal_topology = FullyConnected,\n                         z_topology = Bounded,\n                         radius = Oceananigans.defaults.planet_radius,\n                         non_uniform_conformal_mapping = false,\n                         spacing_type = \"geometric\",\n                         provided_conformal_mapping = nothing,\n                         partition = CubedSpherePartition(; R = 1))\n\nReturn a ConformalCubedSphereGrid that comprises of six ConformalCubedSpherePanelGrids; we refer to each of these grids as a \"panel\". Each panel corresponds to a face of the cube.\n\nThe keyword arguments prescribe the properties of each of the panels. Only the topology in the vertical direction can be prescribed and that's done via the z_topology keyword argument (default: Bounded). Topologies in both horizontal directions for a ConformalCubedSphereGrid are always FullyConnected.\n\nHalo size in both horizontal dimensions must be equal; this is prescribed via the horizontal_halo :: Integer keyword argument. The number of halo points in the z-direction is prescribed by the z_halo :: Integer keyword argument.\n\nThe connectivity between the ConformalCubedSphereGrid panels is depicted below.\n\n                          +==========+==========+\n                          âˆ¥    â†‘     âˆ¥    â†‘     âˆ¥\n                          âˆ¥    1W    âˆ¥    1S    âˆ¥\n                          âˆ¥â†3N P5 6Wâ†’âˆ¥â†5E P6 2Sâ†’âˆ¥\n                          âˆ¥    4N    âˆ¥    4E    âˆ¥\n                          âˆ¥    â†“     âˆ¥    â†“     âˆ¥\n               +==========+==========+==========+\n               âˆ¥    â†‘     âˆ¥    â†‘     âˆ¥\n               âˆ¥    5W    âˆ¥    5S    âˆ¥\n               âˆ¥â†1N P3 4Wâ†’âˆ¥â†3E P4 6Sâ†’âˆ¥\n               âˆ¥    2N    âˆ¥    2E    âˆ¥\n               âˆ¥    â†“     âˆ¥    â†“     âˆ¥\n    +==========+==========+==========+\n    âˆ¥    â†‘     âˆ¥    â†‘     âˆ¥\n    âˆ¥    3W    âˆ¥    3S    âˆ¥\n    âˆ¥â†5N P1 2Wâ†’âˆ¥â†1E P2 4Sâ†’âˆ¥\n    âˆ¥    6N    âˆ¥    6E    âˆ¥\n    âˆ¥    â†“     âˆ¥    â†“     âˆ¥\n    +==========+==========+\n\nThe North Pole of the sphere lies in the center of panel 3 (P3) and the South Pole in the center of panel 6 (P6).\n\nThe partition keyword argument prescribes the partitioning in regions within each panel; see CubedSpherePartition. For example, a CubedSpherePartition(; R=2) implies that each of the panels are partitioned into 2 regions in each dimension; this adds up, e.g., to 24 regions for the  whole sphere. In the depiction below, the intra-panel x, y indices are depicted in the center of each region and the overall region index is shown at the bottom right of each region.\n\n                                                +==========+==========+==========+==========+\n                                                âˆ¥    â†‘     |    â†‘     âˆ¥    â†‘     |    â†‘     âˆ¥\n                                                âˆ¥          |          âˆ¥          |          âˆ¥\n                                                âˆ¥â† (1, 2) â†’|â† (2, 2) â†’âˆ¥â† (1, 2) â†’|â† (2, 2) â†’âˆ¥\n                                                âˆ¥          |          âˆ¥          |          âˆ¥\n                                                âˆ¥    â†“  19 |    â†“  20 âˆ¥    â†“  23 |    â†“  24 âˆ¥\n                                                +-------- P 5 --------+-------- P 6 --------+\n                                                âˆ¥    â†‘     |    â†‘     âˆ¥    â†‘     |    â†‘     âˆ¥\n                                                âˆ¥          |          âˆ¥          |          âˆ¥\n                                                âˆ¥â† (1, 1) â†’|â† (2, 1) â†’âˆ¥â† (1, 1) â†’|â† (2, 1) â†’âˆ¥\n                                                âˆ¥          |          âˆ¥          |          âˆ¥\n                                                âˆ¥    â†“  17 |    â†“  18 âˆ¥    â†“  21 |    â†“  22 âˆ¥\n                          +==========+==========+==========+==========+==========+==========+\n                          âˆ¥    â†‘     |    â†‘     âˆ¥    â†‘     |    â†‘     âˆ¥\n                          âˆ¥          |          âˆ¥          |          âˆ¥\n                          âˆ¥â† (1, 2) â†’|â† (2, 2) â†’âˆ¥â† (1, 2) â†’|â† (2, 2) â†’âˆ¥\n                          âˆ¥          |          âˆ¥          |          âˆ¥\n                          âˆ¥    â†“ 11  |    â†“  12 âˆ¥    â†“  15 |    â†“  16 âˆ¥\n                          +-------- P 3 --------+-------- P 4 --------+\n                          âˆ¥    â†‘     |    â†‘     âˆ¥    â†‘     |    â†‘     âˆ¥\n                          âˆ¥          |          âˆ¥          |          âˆ¥\n                          âˆ¥â† (1, 1) â†’|â† (2, 1) â†’âˆ¥â† (1, 1) â†’|â† (2, 1) â†’âˆ¥\n                          âˆ¥          |          âˆ¥          |          âˆ¥\n                          âˆ¥    â†“  9  |    â†“  10 âˆ¥    â†“  13 |    â†“  14 âˆ¥\n    +==========+==========+==========+==========+==========+==========+\n    âˆ¥    â†‘     |    â†‘     âˆ¥    â†‘     |    â†‘     âˆ¥\n    âˆ¥          |          âˆ¥          |          âˆ¥\n    âˆ¥â† (1, 2) â†’|â† (2, 2) â†’âˆ¥â† (1, 2) â†’|â† (2, 2) â†’âˆ¥\n    âˆ¥          |          âˆ¥          |          âˆ¥\n    âˆ¥    â†“   3 |    â†“   4 âˆ¥    â†“   7 |    â†“   8 âˆ¥\n    +-------- P 1 --------+-------- P 2 --------+\n    âˆ¥    â†‘     |    â†‘     âˆ¥    â†‘     |    â†‘     âˆ¥\n    âˆ¥          |          âˆ¥          |          âˆ¥\n    âˆ¥â† (1, 1) â†’|â† (2, 1) â†’âˆ¥â† (1, 1) â†’|â† (2, 1) â†’âˆ¥\n    âˆ¥          |          âˆ¥          |          âˆ¥\n    âˆ¥    â†“   1 |    â†“   2 âˆ¥    â†“   5 |    â†“   6 âˆ¥\n    +==========+==========+==========+==========+\n\nBelow, we show in detail panels 1 and 2 and the connectivity of each panel.\n\n+===============+==============+==============+===============+\nâˆ¥       â†‘       |      â†‘       âˆ¥      â†‘       |      â†‘        âˆ¥\nâˆ¥      11W      |      9W      âˆ¥      9S      |     10S       âˆ¥\nâˆ¥â†19N (2, 1) 4Wâ†’|â†3E (2, 2) 7Wâ†’âˆ¥â†4E (2, 1) 8Wâ†’|â†7E (2, 2) 13Sâ†’âˆ¥\nâˆ¥       1N      |      2N      âˆ¥      5N      |      6N       âˆ¥\nâˆ¥       â†“     3 |      â†“     4 âˆ¥      â†“     7 |      â†“      8 âˆ¥\n+------------- P 1 ------------+------------ P 2 -------------+\nâˆ¥       â†‘       |      â†‘       âˆ¥      â†‘       |      â†‘        âˆ¥\nâˆ¥       3S      |      4S      âˆ¥      7S      |      8S       âˆ¥\nâˆ¥â†20N (1, 1) 2Wâ†’|â†1E (2, 1) 5Wâ†’âˆ¥â†2E (1, 1) 6Wâ†’|â†5E (2, 1) 14Sâ†’âˆ¥\nâˆ¥      23N      |     24N      âˆ¥     24N      |     22N       âˆ¥\nâˆ¥       â†“     1 |      â†“     2 âˆ¥      â†“     5 |      â†“      6 âˆ¥\n+===============+==============+==============+===============+\n\nExample\n\njulia> using Oceananigans\n\njulia> using Oceananigans.MultiRegion: ConformalCubedSphereGrid\n\njulia> grid = ConformalCubedSphereGrid(panel_size=(12, 12, 1), z=(-1, 0), radius=1)\nConformalCubedSphereGrid{Float64, FullyConnected, FullyConnected, Bounded} partitioned on CPU():\nâ”œâ”€â”€ region_grids: 12Ã—12Ã—1 OrthogonalSphericalShellGrid{Float64, FullyConnected, FullyConnected, Bounded} on CPU with 3Ã—3Ã—3 halo and with precomputed metrics\nâ”œâ”€â”€ partition: CubedSpherePartition with (1 region in each panel)\nâ””â”€â”€ connectivity: CubedSphereConnectivity\n\nThe connectivities of the regions of our grid are stored in grid.connectivity. For example, to find out all connectivites on the South boundary of each region we call\n\njulia> using Oceananigans.MultiRegion: East, North, West, South\n\njulia> for region in 1:length(grid); println(grid.connectivity.connections[region].south); end\nCubedSphereRegionalConnectivity\nâ”œâ”€â”€ from: Oceananigans.BoundaryConditions.North side, region 6\nâ”œâ”€â”€ to:   Oceananigans.BoundaryConditions.South side, region 1\nâ””â”€â”€ no rotation\nCubedSphereRegionalConnectivity\nâ”œâ”€â”€ from: Oceananigans.BoundaryConditions.East side, region 6\nâ”œâ”€â”€ to:   Oceananigans.BoundaryConditions.South side, region 2\nâ””â”€â”€ counter-clockwise rotation â†º\nCubedSphereRegionalConnectivity\nâ”œâ”€â”€ from: Oceananigans.BoundaryConditions.North side, region 2\nâ”œâ”€â”€ to:   Oceananigans.BoundaryConditions.South side, region 3\nâ””â”€â”€ no rotation\nCubedSphereRegionalConnectivity\nâ”œâ”€â”€ from: Oceananigans.BoundaryConditions.East side, region 2\nâ”œâ”€â”€ to:   Oceananigans.BoundaryConditions.South side, region 4\nâ””â”€â”€ counter-clockwise rotation â†º\nCubedSphereRegionalConnectivity\nâ”œâ”€â”€ from: Oceananigans.BoundaryConditions.North side, region 4\nâ”œâ”€â”€ to:   Oceananigans.BoundaryConditions.South side, region 5\nâ””â”€â”€ no rotation\nCubedSphereRegionalConnectivity\nâ”œâ”€â”€ from: Oceananigans.BoundaryConditions.East side, region 4\nâ”œâ”€â”€ to:   Oceananigans.BoundaryConditions.South side, region 6\nâ””â”€â”€ counter-clockwise rotation â†º\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.MultiRegion.ConformalCubedSphereGrid-2","page":"Library","title":"Oceananigans.MultiRegion.ConformalCubedSphereGrid","text":"ConformalCubedSphereGrid(filepath::AbstractString, arch::AbstractArchitecture=CPU(), FT=Float64;\n                         Nz,\n                         z,\n                         panel_halo = (4, 4, 4),\n                         panel_topology = (FullyConnected, FullyConnected, Bounded),\n                         radius = Oceananigans.defaults.planet_radius)\n\nLoad a ConformalCubedSphereGrid from filepath.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.MultiRegion.CubedSpherePartition-Tuple{}","page":"Library","title":"Oceananigans.MultiRegion.CubedSpherePartition","text":"CubedSpherePartition(; R = 1)\n\nReturn a cubed sphere partition with R partitions in each horizontal dimension of each panel of the sphere.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.MultiRegion.MultiRegionGrid-Tuple{Any}","page":"Library","title":"Oceananigans.MultiRegion.MultiRegionGrid","text":"MultiRegionGrid(global_grid; partition = XPartition(2))\n\nSplit a global_grid into different regions.\n\nPositional Arguments\n\nglobal_grid: the grid to be divided into regions.\n\nKeyword Arguments\n\npartition: the partitioning required. The implemented partitioning are XPartition              (division along the x direction) and YPartition (division along              the y direction).\n\nExample\n\njulia> using Oceananigans\n\njulia> using Oceananigans.MultiRegion: MultiRegionGrid, XPartition\n\njulia> grid = RectilinearGrid(size=(12, 12), extent=(1, 1), topology=(Bounded, Bounded, Flat));\n\njulia> multi_region_grid = MultiRegionGrid(grid, partition = XPartition(4))\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Operators","page":"Library","title":"Operators","text":"","category":"section"},{"location":"appendix/library/#Oceananigans.Operators.divá¶œá¶œá¶œ-NTuple{7, Any}","page":"Library","title":"Oceananigans.Operators.divá¶œá¶œá¶œ","text":"divá¶œá¶œá¶œ(i, j, k, grid, u, v, w)\n\nCalculate the divergence ğ• of a vector field ğ• = (u v w),\n\n1/V * [Î´xá¶œáµƒáµƒ(Ax * u) + Î´xáµƒá¶œáµƒ(Ay * v) + Î´záµƒáµƒá¶œ(Az * w)]\n\nwhich ends up at the cell centers ccc.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Operators.extrinsic_vector-Tuple{Any, Any, Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any}","page":"Library","title":"Oceananigans.Operators.extrinsic_vector","text":"extrinsic_vector(i, j, k, grid::AbstractGrid, uáµ¢, váµ¢, wáµ¢)\n\nConvert the three-dimensional vector with components uáµ¢, váµ¢, wáµ¢ defined on the intrinsic coordinate system of the grid, to the extrinsic coordinate system associated with the domain.\n\nextrinsic coordinate systems are:\n\nCartesian coordinates for any grid that discretizes a cartesian domain (e.g. a RectilinearGrid)\nGeographic coordinates for any grid that discretizes a spherical domain (e.g. an AbstractCurvilinearGrid)\n\nTherefore, for the RectilinearGrid and the LatitudeLongitudeGrid, the extrinsic and the intrinsic coordinate systems are equivalent. However, for other grids (e.g., for the  ConformalCubedSphereGrid) that might not be the case.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Operators.intrinsic_vector-Tuple{Any, Any, Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any}","page":"Library","title":"Oceananigans.Operators.intrinsic_vector","text":"intrinsic_vector(i, j, k, grid::AbstractGrid, uâ‚‘, vâ‚‘, wâ‚‘)\n\nConvert the three-dimensional vector with components uâ‚‘, vâ‚‘, wâ‚‘ defined in an extrinsic coordinate system associated with the domain, to the coordinate system intrinsic to the grid.\n\nextrinsic coordinate systems are:\n\nCartesian coordinates for any grid that discretizes a cartesian domain (e.g. a RectilinearGrid)\nGeographic coordinates for any grid that discretizes a spherical domain (e.g. an AbstractCurvilinearGrid)\n\nTherefore, for the RectilinearGrid and the LatitudeLongitudeGrid, the extrinsic and the intrinsic coordinate system are equivalent. However, for other grids (e.g., for the  ConformalCubedSphereGrid) that might not be the case.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Operators.Î¶â‚ƒá¶ á¶ á¶œ-NTuple{6, Any}","page":"Library","title":"Oceananigans.Operators.Î¶â‚ƒá¶ á¶ á¶œ","text":"Î¶â‚ƒá¶ á¶ á¶œ(i, j, k, grid, u, v)\n\nThe vertical vorticity associated with horizontal velocities u and v.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Operators.âˆ‡Â²á¶œá¶œá¶œ-NTuple{5, Any}","page":"Library","title":"Oceananigans.Operators.âˆ‡Â²á¶œá¶œá¶œ","text":"âˆ‡Â²á¶œá¶œá¶œ(i, j, k, grid, c)\n\nCalculate the Laplacian of c via\n\n1/V * [Î´xá¶œáµƒáµƒ(Ax * âˆ‚xá¶ áµƒáµƒ(c)) + Î´yáµƒá¶œáµƒ(Ay * âˆ‚yáµƒá¶ áµƒ(c)) + Î´záµƒáµƒá¶œ(Az * âˆ‚záµƒáµƒá¶ (c))]\n\nwhich ends up at the location ccc.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Output-readers","page":"Library","title":"Output readers","text":"","category":"section"},{"location":"appendix/library/#Oceananigans.OutputReaders.Clamp","page":"Library","title":"Oceananigans.OutputReaders.Clamp","text":"Clamp()\n\nSpecifies FieldTimeSeries Time extrapolation that returns data from the nearest value.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.OutputReaders.Cyclical","page":"Library","title":"Oceananigans.OutputReaders.Cyclical","text":"Cyclical(period=nothing)\n\nSpecifies cyclical FieldTimeSeries linear Time extrapolation. If period is not specified, it is inferred from the fts::FieldTimeSeries via\n\nt = fts.times\nÎ”t = t[end] - t[end-1]\nperiod = t[end] - t[1] + Î”t\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.OutputReaders.FieldDataset-Tuple{Any}","page":"Library","title":"Oceananigans.OutputReaders.FieldDataset","text":"FieldDataset(filepath;\n             architecture=CPU(), grid=nothing, backend=InMemory(), metadata_paths=[\"metadata\"])\n\nReturns a Dict containing a FieldTimeSeries for each field in the JLD2 file located at filepath. Note that model output must have been saved with halos.\n\nKeyword arguments\n\nbackend: Either InMemory() (default) or OnDisk(). The InMemory backend will\n\nload the data fully in memory as a 4D multi-dimensional array while the OnDisk() backend will lazily load field time snapshots when the FieldTimeSeries is indexed linearly.\n\nmetadata_paths: A list of JLD2 paths to look for metadata. By default it looks in file[\"metadata\"].\ngrid: May be specified to override the grid used in the JLD2 file.\nreader_kw: A named tuple or dictionary of keyword arguments to pass to the reader              (currently only JLD2) to be used when opening files.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.OutputReaders.FieldTimeSeries-Tuple{String, String}","page":"Library","title":"Oceananigans.OutputReaders.FieldTimeSeries","text":"FieldTimeSeries(path, name;\n                backend = InMemory(),\n                architecture = nothing,\n                grid = nothing,\n                location = nothing,\n                boundary_conditions = UnspecifiedBoundaryConditions(),\n                time_indexing = Linear(),\n                iterations = nothing,\n                times = nothing,\n                reader_kw = Dict{Symbol, Any}())\n\nReturn a FieldTimeSeries containing a time-series of the field name load from JLD2 output located at path.\n\nKeyword arguments\n\nbackend: InMemory() to load data into a 4D array, OnDisk() to lazily load data from disk            when indexing into FieldTimeSeries.\ngrid: A grid to associate with the data, in the case that the native grid was not serialized         properly.\niterations: Iterations to load. Defaults to all iterations found in the file.\ntimes: Save times to load, as determined through an approximate floating point          comparison to recorded save times. Defaults to times associated with iterations.          Takes precedence over iterations if times is specified.\nreader_kw: A named tuple or dictionary of keyword arguments to pass to the reader              (currently only JLD2) to be used when opening files.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.OutputReaders.FieldTimeSeries-Union{Tuple{Oceananigans.Grids.AbstractGrid}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Oceananigans.Grids.AbstractGrid, Any}} where {LX, LY, LZ}","page":"Library","title":"Oceananigans.OutputReaders.FieldTimeSeries","text":"FieldTimeSeries{LX, LY, LZ}(grid::AbstractGrid [, times=()]; kwargs...)\n\nConstruct a FieldTimeSeries on grid and at times.\n\nKeyword arguments\n\nindices: spatial indices\nbackend: backend, InMemory(indices=Colon()) or OnDisk()\npath: path to data for backend = OnDisk()\nname: name of field for backend = OnDisk()\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.OutputReaders.InMemory-Tuple{Int64}","page":"Library","title":"Oceananigans.OutputReaders.InMemory","text":"InMemory(length=nothing)\n\nReturn a backend for FieldTimeSeries that stores size fields in memory. The default size = nothing stores all fields in memory.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.OutputReaders.Linear","page":"Library","title":"Oceananigans.OutputReaders.Linear","text":"Linear()\n\nSpecifies FieldTimeSeries linear Time extrapolation.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.OutputReaders.OnDisk","page":"Library","title":"Oceananigans.OutputReaders.OnDisk","text":"OnDisk()\n\nReturn a lazy backend for FieldTimeSeries that keeps data on disk, only loading it as requested by indexing into the FieldTimeSeries.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Output-writers","page":"Library","title":"Output writers","text":"","category":"section"},{"location":"appendix/library/#Oceananigans.OutputWriters.AveragedTimeInterval","page":"Library","title":"Oceananigans.OutputWriters.AveragedTimeInterval","text":"mutable struct AveragedTimeInterval <: AbstractSchedule\n\nContainer for parameters that configure and handle time-averaged output.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.OutputWriters.AveragedTimeInterval-Tuple{Any}","page":"Library","title":"Oceananigans.OutputWriters.AveragedTimeInterval","text":"AveragedTimeInterval(interval; window=interval, stride=1)\n\nReturns a schedule that specifies periodic time-averaging of output. The time window specifies the extent of the time-average, which reoccurs every interval.\n\noutput is computed and accumulated into the average every stride iterations during the averaging window. For example, stride=1 computes output every iteration, whereas stride=2 computes output every other iteration. Time-averages with longer strides are faster to compute, but less accurate.\n\nThe time-average of a is a left Riemann sum corresponding to\n\na = TÂ¹ int_táµ¢-T^táµ¢ a mathrmd t  \n\nwhere a is the time-average of a, T is the time-window for averaging, and the táµ¢ are discrete times separated by the time interval. The táµ¢ specify both the end of the averaging window and the time at which output is written.\n\nExample\n\nusing Oceananigans.OutputWriters: AveragedTimeInterval\nusing Oceananigans.Utils: days\n\nschedule = AveragedTimeInterval(4days, window=2days)\n\n# output\nAveragedTimeInterval(window=2 days, stride=1, interval=4 days)\n\nAn AveragedTimeInterval schedule directs an output writer to time-average its outputs before writing them to disk:\n\nusing Oceananigans\nusing Oceananigans.Units\n\nmodel = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)))\n\nsimulation = Simulation(model, Î”t=10minutes, stop_time=30days)\n\nsimulation.output_writers[:velocities] = JLD2Writer(model, model.velocities,\n                                                    filename= \"averaged_velocity_data.jld2\",\n                                                    schedule = AveragedTimeInterval(4days, window=2days, stride=2))\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.OutputWriters.Checkpointer-Tuple{Any}","page":"Library","title":"Oceananigans.OutputWriters.Checkpointer","text":"Checkpointer(model;\n             schedule,\n             dir = \".\",\n             prefix = \"checkpoint\",\n             overwrite_existing = false,\n             verbose = false,\n             cleanup = false,\n             properties = required_checkpoint_properties(model))\n\nConstruct a Checkpointer that checkpoints the model to a JLD2 file on schedule. The model.clock.iteration is included in the filename to distinguish between multiple checkpoint files.\n\nTo restart or \"pickup\" a model from a checkpoint, specify pickup = true when calling run!, ensuring that the checkpoint file is in directory dir. See run! for more details.\n\nNote that extra model properties can be specified, but removing crucial properties such as :timestepper will render restoring from the checkpoint impossible.\n\nThe checkpointer attempts to serialize as much of the model to disk as possible, but functions or objects containing functions cannot be serialized at this time.\n\nKeyword arguments\n\nschedule (required): Schedule that determines when to checkpoint.\ndir: Directory to save output to. Default: \".\" (current working directory).\nprefix: Descriptive filename prefixed to all output files. Default: \"checkpoint\".\noverwrite_existing: Remove existing files if their filenames conflict. Default: false.\nverbose: Log what the output writer is doing with statistics on compute/write times            and file sizes. Default: false.\ncleanup: Previous checkpoint files are deleted once a new checkpoint file is written.            Default: false.\nproperties: List of model properties to checkpoint. This list must contain               :grid and :clock, and if there is a timestepper then also               :timestepper. Default: calls required_checkpoint_properties on               model to get these properties.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.OutputWriters.FileSizeLimit-Tuple{Any}","page":"Library","title":"Oceananigans.OutputWriters.FileSizeLimit","text":"FileSizeLimit(size_limit [, path=\"\"])\n\nReturn a schedule that actuates when the file at path exceeds the size_limit.\n\nThe path is automatically added and updated when FileSizeLimit is used with an output writer, and should not be provided manually.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.OutputWriters.JLD2Writer-Tuple{Any, Any}","page":"Library","title":"Oceananigans.OutputWriters.JLD2Writer","text":"JLD2Writer(model, outputs; filename, schedule,\n           dir = \".\",\n           indices = (:, :, :),\n           with_halos = true,\n           array_type = Array{Float32},\n           file_splitting = NoFileSplitting(),\n           overwrite_existing = false,\n           init = noinit,\n           including = [:grid, :coriolis, :buoyancy, :closure],\n           verbose = false,\n           part = 1,\n           jld2_kw = Dict{Symbol, Any}())\n\nConstruct a JLD2Writer for an Oceananigans model that writes label, output pairs in outputs to a JLD2 file.\n\nThe argument outputs may be a Dict or NamedTuple. The keys of outputs are symbols or strings that \"name\" output data. The values of outputs are either AbstractFields, objects that are called with the signature output(model), or WindowedTimeAverages of AbstractFieldss, functions, or callable objects.\n\nKeyword arguments\n\nFilenaming\n\nfilename (required): Descriptive filename. \".jld2\" is appended to filename in the file path                        if filename does not end in \".jld2\".\ndir: Directory to save output to. Default: \".\" (current working directory).\n\nOutput frequency and time-averaging\n\nschedule (required): AbstractSchedule that determines when output is saved.\n\nSlicing and type conversion prior to output\n\nindices: Specifies the indices to write to disk with a Tuple of Colon, UnitRange,            or Int elements. Indices must be Colon, Int, or contiguous UnitRange.            Defaults to (:, :, :) or \"all indices\". If !with_halos,            halo regions are removed from indices. For example, indices = (:, :, 1)            will save xy-slices of the bottom-most index.\nwith_halos (Bool): Whether or not to slice off or keep halo regions from fields before writing output.                      Preserving halo region data can be useful for postprocessing. Default: true.\narray_type: The array type to which output arrays are converted to prior to saving.               Default: Array{Float32}.\n\nFile management\n\nfile_splitting: Schedule for splitting the output file. The new files will be suffixed with                   _part1, _part2, etc. For example file_splitting = FileSizeLimit(sz) will                   split the output file when its size exceeds sz. Another example is                   file_splitting = TimeInterval(30days), which will split files every 30 days of                   simulation time. The default incurs no splitting (NoFileSplitting()).\noverwrite_existing: Remove existing files if their filenames conflict.                       Default: false.\n\nOutput file metadata management\n\ninit: A function of the form init(file, model) that runs when a JLD2 output file is initialized.         Default: noinit(args...) = nothing.\nincluding: List of model properties to save with every file.              Default depends of the type of model: default_included_properties(model)\n\nMiscellaneous keywords\n\nverbose: Log what the output writer is doing with statistics on compute/write times and file sizes.            Default: false.\npart: The starting part number used when file splitting.         Default: 1.\njld2_kw: Dict of kwargs to be passed to JLD2.jldopen when data is written.\n\nExample\n\nOutput 3D fields of the model velocities u, v, and w:\n\nusing Oceananigans\nusing Oceananigans.Units\n\nmodel = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)), tracers=:c)\nsimulation = Simulation(model, Î”t=12, stop_time=1hour)\n\nfunction init_save_some_metadata!(file, model)\n    file[\"author\"] = \"Chim Riggles\"\n    file[\"parameters/coriolis_parameter\"] = 1e-4\n    file[\"parameters/density\"] = 1027\n    return nothing\nend\n\nc_avg = Field(Average(model.tracers.c, dims=(1, 2)))\n\n# Note that model.velocities is NamedTuple\nsimulation.output_writers[:velocities] = JLD2Writer(model, model.velocities,\n                                                    filename = \"some_data.jld2\",\n                                                    schedule = TimeInterval(20minutes),\n                                                    init = init_save_some_metadata!)\n\nand also output a both 5-minute-time-average and horizontal-average of the tracer c every 20 minutes of simulation time to a file called some_averaged_data.jld2\n\nsimulation.output_writers[:avg_c] = JLD2Writer(model, (; c=c_avg),\n                                               filename = \"some_averaged_data.jld2\",\n                                               schedule = AveragedTimeInterval(20minute, window=5minutes))\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.OutputWriters.WindowedTimeAverage","page":"Library","title":"Oceananigans.OutputWriters.WindowedTimeAverage","text":"WindowedTimeAverage(operand, model=nothing; schedule)\n\nReturns an object for computing running averages of operand over schedule.window and recurring on schedule.interval, where schedule is an AveragedTimeInterval. During the collection period, averages are computed every schedule.stride iteration.\n\noperand may be a Oceananigans.Field or a function that returns an array or scalar.\n\nCalling wta(model) for wta::WindowedTimeAverage object returns wta.result.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.OutputWriters.NetCDFWriter","page":"Library","title":"Oceananigans.OutputWriters.NetCDFWriter","text":"NetCDFWriter(model, outputs;\n             filename,\n             schedule,\n             grid = model.grid,\n             dir = \".\",\n             array_type = Array{Float32},\n             indices = (:, :, :),\n             global_attributes = Dict(),\n             output_attributes = Dict(),\n             dimensions = Dict(),\n             with_halos = false,\n             include_grid_metrics = true,\n             overwrite_existing = nothing,\n             verbose = false,\n             deflatelevel = 0,\n             part = 1,\n             file_splitting = NoFileSplitting(),\n             dimension_name_generator = trilocation_dim_name)\n\nConstruct a NetCDFWriter that writes (label, output) pairs in outputs to a NetCDF file. The outputs can be a Dict or NamedTuple where each label is a string and each output is one of:\n\nA Field (e.g., model.velocities.u)\nA Reduction (e.g., Average(model.tracers.T, dims=(1, 2)))\nLagrangianParticles for particle tracking data\nA function f(model) that returns something to be written to disk\n\nIf any of outputs are not AbstractField, Reduction, or LagrangianParticles, their spatial dimensions must be provided.\n\nRequired arguments\n\nmodel: The Oceananigans model instance.\noutputs: A collection of outputs to write, specified as either:\nA Dict with string keys and Field/function values.\nA NamedTuple of Fields or functions.\n\nRequired keyword arguments\n\nfilename: Descriptive filename. \".nc\" is appended if not present.\nschedule: An AbstractSchedule that determines when output is saved. Options include:\nTimeInterval(dt): Save every dt seconds of simulation time.\nIterationInterval(n): Save every n iterations.\nAveragedTimeInterval(dt; window, stride): Time-average output over a window before saving.\nWallTimeInterval(dt): Save every dt seconds of wall clock time.\n\nOptional keyword arguments\n\ngrid: The grid associated with outputs. Defaults to model.grid. To use outputs on a different         grid than model.grid, provide the proper grid here.\ndir: Directory to save output to. Default: \".\".\narray_type: Type to convert outputs to before saving. Default: Array{Float32}.\nindices: Tuple of indices of the output variables to include. Default is (:, :, :), which            includes the full fields. This allows saving specific slices of the domain.\nglobal_attributes: Dict or NamedTuple of global attributes or metadata to save with every file.                      Default: Dict(). This is useful for saving information specific to the simulation.                      Some useful global attributes are included by default but will be overwritten if                      included in this Dict.\noutput_attributes: Dict or NamedTuple of attributes to be saved with each field variable.                      Default: Dict(). Reasonable defaults including descriptive names and units are                      provided for velocities, buoyancy, temperature, and salinity. Attributes provided                      here will overwrite the defaults.\ndimensions: A Dict or NamedTuple of dimension tuples to apply to outputs (required for function               outputs that return custom data).\nwith_halos: Boolean defining whether to include halos in the outputs. Default: false.               Note that to postprocess saved output (e.g., compute derivatives, etc.),               information about the boundary conditions is often crucial. In those cases,               you might need to set with_halos = true. Cannot be used with custom indices.\ninclude_grid_metrics: Include grid metrics such as grid spacings, areas, and volumes as                         additional variables. Default: true. Note that even with                         include_grid_metrics = false, core grid coordinates are still saved.\noverwrite_existing: If false, NetCDFWriter will append to existing files. If true,                       it will overwrite existing files or create new ones. Default: true if the                       file does not exist, false if it does.\nverbose: Log variable compute times, file write times, and file sizes. Default: false.\ndeflatelevel: Determines the NetCDF compression level of data (integer 0-9; 0 (default) means no compression                 and 9 means maximum compression). See NCDatasets.jl documentation                 for more information.\npart: The starting part number used when file splitting. Default: 1.\nfile_splitting: Schedule for splitting the output file. The new files will be suffixed with                   _part1, _part2, etc. Options include:                   * FileSizeLimit(sz): Split when file size exceeds sz (e.g., 200KiB).                   * TimeInterval(interval): Split every interval of simulation time.                   * NoFileSplitting() (default): Don't split files.\ndimension_name_generator: A function with signature (var_name, grid, LX, LY, LZ, dim) where dim is                             either Val(:x), Val(:y), or Val(:z) that returns a string corresponding                             to the name of the dimension var_name on grid with location (LX, LY, LZ)                             along dim. This advanced option can be used to rename dimensions and variables                             to satisfy certain naming conventions. Default: trilocation_dim_name.\n\nExamples\n\nSaving the u velocity field and temperature fields, the full 3D fields and surface 2D slices to separate NetCDF files:\n\nusing Oceananigans\n\ngrid = RectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1))\n\nmodel = NonhydrostaticModel(grid=grid, tracers=:c)\n\nsimulation = Simulation(model, Î”t=12, stop_time=3600)\n\nfields = Dict(\"u\" => model.velocities.u, \"c\" => model.tracers.c)\n\nsimulation.output_writers[:field_writer] =\n    NetCDFWriter(model, fields, filename=\"fields.nc\", schedule=TimeInterval(60))\n\nsimulation.output_writers[:surface_slice_writer] =\n    NetCDFWriter(model, fields, filename=\"surface_xy_slice.nc\",\n                 schedule=TimeInterval(60), indices=(:, :, grid.Nz))\n\nsimulation.output_writers[:averaged_profile_writer] =\n    NetCDFWriter(model, fields,\n                 filename = \"averaged_z_profile.nc\",\n                 schedule = AveragedTimeInterval(60, window=20),\n                 indices = (1, 1, :))\n\nNetCDFWriter also accepts output functions that write scalars and arrays to disk, provided that their dimensions are provided:\n\nusing Oceananigans\n\nNx, Ny, Nz = 16, 16, 16\n\ngrid = RectilinearGrid(size=(Nx, Ny, Nz), extent=(1, 2, 3))\n\nmodel = NonhydrostaticModel(; grid)\n\nsimulation = Simulation(model, Î”t=1.25, stop_iteration=3)\n\nf(model) = model.clock.time^2 # scalar output\n\nzC = znodes(grid, Center())\ng(model) = model.clock.time .* exp.(zC) # vector/profile output\n\nxC, yF = xnodes(grid, Center()), ynodes(grid, Face())\nXC = [xC[i] for i in 1:Nx, j in 1:Ny]\nYF = [yF[j] for i in 1:Nx, j in 1:Ny]\nh(model) = @. model.clock.time * sin(XC) * cos(YF) # xy slice output\n\noutputs = Dict(\"scalar\" => f, \"profile\" => g, \"slice\" => h)\n\ndims = Dict(\"scalar\" => (), \"profile\" => (\"zC\",), \"slice\" => (\"xC\", \"yC\"))\n\noutput_attributes = Dict(\n    \"scalar\"  => Dict(\"long_name\" => \"Some scalar\", \"units\" => \"bananas\"),\n    \"profile\" => Dict(\"long_name\" => \"Some vertical profile\", \"units\" => \"watermelons\"),\n    \"slice\"   => Dict(\"long_name\" => \"Some slice\", \"units\" => \"mushrooms\"))\n\nglobal_attributes = Dict(\"location\" => \"Bay of Fundy\", \"onions\" => 7)\n\nsimulation.output_writers[:things] =\n    NetCDFWriter(model, outputs,\n                 schedule=IterationInterval(1), filename=\"things.nc\", dimensions=dims, verbose=true,\n                 global_attributes=global_attributes, output_attributes=output_attributes)\n\nNetCDFWriter can also be configured for outputs that are interpolated or regridded to a different grid than model.grid. To use this functionality, include the keyword argument grid = output_grid.\n\nusing Oceananigans\nusing Oceananigans.Fields: interpolate!\n\ngrid = RectilinearGrid(size=(1, 1, 8), extent=(1, 1, 1));\nmodel = NonhydrostaticModel(; grid)\n\ncoarse_grid = RectilinearGrid(size=(grid.Nx, grid.Ny, grid.NzÃ·2), extent=(grid.Lx, grid.Ly, grid.Lz))\ncoarse_u = Field{Face, Center, Center}(coarse_grid)\n\ninterpolate_u(model) = interpolate!(coarse_u, model.velocities.u)\noutputs = (; u = interpolate_u)\n\noutput_writer = NetCDFWriter(model, outputs;\n                             grid = coarse_grid,\n                             filename = \"coarse_u.nc\",\n                             schedule = IterationInterval(1))\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Simulations","page":"Library","title":"Simulations","text":"","category":"section"},{"location":"appendix/library/#Oceananigans.Simulations.Callback","page":"Library","title":"Oceananigans.Simulations.Callback","text":"Callback(func, schedule=IterationInterval(1);\n         parameters=nothing, callsite=TimeStepCallsite())\n\nReturn Callback that executes func on schedule at the callsite with optional parameters. By default, schedule = IterationInterval(1) and callsite = TimeStepCallsite().\n\nIf isnothing(parameters), func(sim::Simulation) is called. Otherwise, func is called via func(sim::Simulation, parameters).\n\nThe callsite determines where Callback is executed. The possible values for callsite are:\n\nTimeStepCallsite(): after a time-step.\nTendencyCallsite(): after tendencies are calculated, but before taking a time-step (useful for modifying tendency calculations).\nUpdateStateCallsite(): within update_state!, after auxiliary variables have been computed (for multi-stage time-steppers, update_state! may be called multiple times per time-step).\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Simulations.Simulation-Tuple{Any}","page":"Library","title":"Oceananigans.Simulations.Simulation","text":"Simulation(model;\n           Î”t,\n           verbose = true,\n           stop_iteration = Inf,\n           stop_time = Inf,\n           wall_time_limit = Inf,\n           minimum_relative_step = 0)\n\nConstruct a Simulation for a model with time step Î”t.\n\nKeyword arguments\n\nÎ”t: Required keyword argument specifying the simulation time step. Can be a Number       for constant time steps or a TimeStepWizard for adaptive time-stepping.\nstop_iteration: Stop the simulation after this many iterations. Default: Inf.\nstop_time: Stop the simulation once this much model clock time has passed. Default: Inf.\nwall_time_limit: Stop the simulation if it's been running for longer than this many                    seconds of wall clock time. Default: Inf.\nalign_time_step: When true it implies that the simulation will automatically adjust the                    time-step to meet a constraint imposed by various schedules like ScheduledTimes,                    TimeInterval, AveragedTimeInterval, as well as a stop_time criterion.                    If false, i.e., no time-step alignment, then the simulation might blithely step passed                    the specified time. Default: true.                    By align_time_step = false we ensure that the time-step does not change within                    time_step!(simulation)\nminimum_relative_step: time steps smaller than Î”t * minimum_relative_step will be skipped.                          This avoids extremely high values when writing the pressure to disk.                          Default value is 0. See github.com/CliMA/Oceananigans.jl/issues/3593 for details.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Simulations.TimeStepWizard","page":"Library","title":"Oceananigans.Simulations.TimeStepWizard","text":"TimeStepWizard([FT=Float64;]\n               cfl = 0.2,\n               diffusive_cfl = Inf,\n               max_change = 1.1,\n               min_change = 0.5,\n               max_Î”t = Inf,\n               min_Î”t = 0.0,\n               cell_advection_timescale = cell_advection_timescale,\n               cell_diffusion_timescale = infinite_diffusion_timescale)\n\nCallback function that adjusts the simulation time step to meet specified target values for advective and diffusive Courant-Friedrichs-Lewy (CFL) numbers (cfl and diffusive_cfl), subject to the limits\n\nmax(min_Î”t, min_change * last_Î”t) â‰¤ new_Î”t â‰¤ min(max_Î”t, max_change * last_Î”t)\n\nwhere new_Î”t is the new time step calculated by the TimeStepWizard.\n\nFor more information on the CFL number, see its wikipedia entry.\n\nExample\n\nTo use TimeStepWizard, insert it into a Callback and then add the Callback to a Simulation:\n\njulia> simulation = Simulation(model, Î”t=0.9, stop_iteration=100)\n\njulia> wizard = TimeStepWizard(cfl=0.2)\n\njulia> simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(4))\n\nThen when run!(simulation) is invoked, the time-step simulation.Î”t will be updated every 4 iterations.\n\n(Note that the name :wizard is unimportant.)\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Simulations.add_callback!-Tuple{Any, Callback}","page":"Library","title":"Oceananigans.Simulations.add_callback!","text":"add_callback!(simulation, callback::Callback; name = GenericName(), callback_kw...)\n\nadd_callback!(simulation, func, schedule=IterationInterval(1); name = GenericName(), callback_kw...)\n\nAdd Callback(func, schedule) to simulation.callbacks under name. The default GenericName() generates a name of the form :callbackN, where N is big enough for the name to be unique.\n\nIf name::Symbol is supplied, it may be modified if simulation.callbacks[name] already exists.\n\ncallback_kw are passed to the constructor for Callback.\n\nThe callback (which contains a schedule) can also be supplied directly.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Simulations.conjure_time_step_wizard!","page":"Library","title":"Oceananigans.Simulations.conjure_time_step_wizard!","text":"conjure_time_step_wizard!(simulation, schedule=IterationInterval(5), wizard_kw...)\n\nAdd a TimeStepWizard built with wizard_kw as a Callback to simulation, called on schedule which is IterationInterval(5) by default.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.Simulations.run!-Tuple{Any}","page":"Library","title":"Oceananigans.Simulations.run!","text":"run!(simulation; pickup=false)\n\nRun a simulation until one of simulation.stop_criteria evaluates true. The simulation will then stop.\n\nPicking simulations up from a checkpoint\n\nSimulations are \"picked up\" from a checkpoint if pickup is either true, a String, or an Integer greater than 0.\n\nPicking up a simulation sets field and tendency data to the specified checkpoint, leaving all other model properties unchanged.\n\nPossible values for pickup are:\n\npickup=true picks a simulation up from the latest checkpoint associated with the Checkpointer in simulation.output_writers.\npickup=iteration::Int picks a simulation up from the checkpointed file associated  with iteration and the Checkpointer in simulation.output_writers.\npickup=filepath::String picks a simulation up from checkpointer data in filepath.\n\nNote that pickup=true and pickup=iteration fails if simulation.output_writers contains more than one checkpointer.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Solvers.iteration-Tuple{Simulation}","page":"Library","title":"Oceananigans.Solvers.iteration","text":"iteration(sim::Simulation)\n\nReturn the current simulation iteration.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Solvers","page":"Library","title":"Solvers","text":"","category":"section"},{"location":"appendix/library/#Oceananigans.Solvers.BatchedTridiagonalSolver","page":"Library","title":"Oceananigans.Solvers.BatchedTridiagonalSolver","text":"struct BatchedTridiagonalSolver{A, B, C, T, G, P}\n\nA batched solver for large numbers of triadiagonal systems.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Solvers.BatchedTridiagonalSolver-Tuple{Any}","page":"Library","title":"Oceananigans.Solvers.BatchedTridiagonalSolver","text":"BatchedTridiagonalSolver(grid;\n                         lower_diagonal,\n                         diagonal,\n                         upper_diagonal,\n                         scratch = zeros(architecture(grid), eltype(grid), grid.Nx, grid.Ny, grid.Nz),\n                         tridiagonal_direction = ZDirection()\n                         parameters = nothing)\n\nConstruct a solver for batched tridiagonal systems on grid of the form\n\n                    bâ±Ê²Â¹ Ï•â±Ê²Â¹ + câ±Ê²Â¹ Ï•â±Ê²Â²   = fâ±Ê²Â¹,\n    aâ±Ê²áµâ»Â¹ Ï•â±Ê²áµâ»Â¹ + bâ±Ê²áµ Ï•â±Ê²áµ + câ±Ê²áµ Ï•â±Ê²áµâºÂ¹ = fâ±Ê²áµ,  k = 2, ..., N-1\n    aâ±Ê²á´ºâ»Â¹ Ï•â±Ê²á´ºâ»Â¹ + bâ±Ê²á´º Ï•â±Ê²á´º               = fâ±Ê²á´º,\n\nor in matrix form\n\n    â¡ bâ±Ê²Â¹   câ±Ê²Â¹     0       â‹¯         0   â¤ â¡ Ï•â±Ê²Â¹ â¤   â¡ fâ±Ê²Â¹ â¤\n    â¢ aâ±Ê²Â¹   bâ±Ê²Â²   câ±Ê²Â²      0    â‹¯    â‹®   â¥ â¢ Ï•â±Ê²Â² â¥   â¢ fâ±Ê²Â² â¥\n    â¢  0      â‹±      â‹±       â‹±              â¥ â¢   .  â¥   â¢   .  â¥\n    â¢  â‹®                                0   â¥ â¢ Ï•â±Ê²áµ â¥   â¢ fâ±Ê²áµ â¥\n    â¢  â‹®           aâ±Ê²á´ºâ»Â²   bâ±Ê²á´ºâ»Â¹   câ±Ê²á´ºâ»Â¹ â¥ â¢      â¥   â¢   .  â¥\n    â£  0      â‹¯      0      aâ±Ê²á´ºâ»Â¹    bâ±Ê²á´º  â¦ â£ Ï•â±Ê²á´º â¦   â£ fâ±Ê²á´º â¦\n\nwhere a is the lower_diagonal, b is the diagonal, and c is the upper_diagonal.\n\nNote the convention used here for indexing the upper and lower diagonals; this can be different from other implementations where, e.g., aâ±Ê²Â² may appear at the second row, instead of aâ±Ê²Â¹ as above.\n\nÏ• is the solution and f is the right hand side source term passed to solve!(Ï•, tridiagonal_solver, f).\n\na, b, c, and f can be specified in three ways:\n\nA 1D array means, e.g., that aâ±Ê²áµ = a[k].\nA 3D array means, e.g., that aâ±Ê²áµ = a[i, j, k].\n\nOther coefficient types can be implemented by extending get_coefficient.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Solvers.ConjugateGradientSolver-Tuple{Any}","page":"Library","title":"Oceananigans.Solvers.ConjugateGradientSolver","text":"ConjugateGradientSolver(linear_operation;\n                                      template_field,\n                                      maxiter = size(template_field.grid),\n                                      reltol = sqrt(eps(template_field.grid)),\n                                      abstol = 0,\n                                      preconditioner = nothing,\n                                      enforce_gauge_condition! = no_gauge_enforcement!)\n\nReturns a ConjugateGradientSolver that solves the linear equation A x = b using a iterative conjugate gradient method with optional preconditioning.\n\nThe solver is used by calling\n\nsolve!(x, solver::PreconditionedConjugateGradientOperator, b, args...)\n\nfor solver, right-hand side b, solution x, and optional arguments args....\n\nArguments\n\nlinear_operation: Function with signature linear_operation!(p, y, args...) that calculates                     A * y and stores the result in p for a \"candidate solution\" y. args...                     are optional positional arguments passed from solve!(x, solver, b, args...).\ntemplate_field: Dummy field that is the same type and size as x and b, which                   is used to infer the architecture, grid, and to create work arrays                   that are used internally by the solver.\nmaxiter: Maximum number of iterations the solver may perform before exiting.\nreltol, abstol: Relative and absolute tolerance for convergence of the algorithm.                   The iteration stops when norm(A * x - b) < tolerance.\npreconditioner: Object for which precondition!(z, preconditioner, r, args...) computes z = P * r,                   where r is the residual. Typically P is approximately Aâ»Â¹.\nenforce_gauge_condition!: Function with signature enforce_gauge_condition!(x, r) that                             enforces a gauge condition on the solution x and residual r.                             This is useful for problems where the solution is not unique, such as                             the Poisson equation with purely Neumann boundary conditions.                             The function is called at the end of each iteration of a conjugate                             gradient iteration to ensure that the solution remains consistent                             with the gauge condition.                             The default is no_gauge_enforcement!, which does not enforce a gauge condition.\n\nSee solve! for more information about the preconditioned conjugate-gradient algorithm.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Solvers.FFTBasedPoissonSolver","page":"Library","title":"Oceananigans.Solvers.FFTBasedPoissonSolver","text":"FFTBasedPoissonSolver(grid, planner_flag=FFTW.PATIENT)\n\nReturn an FFTBasedPoissonSolver that solves the \"generalized\" Poisson equation,\n\n(Â² + m) Ï• = b\n\nwhere m is a number, using a eigenfunction expansion of the discrete Poisson operator on a staggered grid and for periodic or Neumann boundary conditions.\n\nIn-place transforms are applied to b, which means b must have complex-valued elements (typically the same type as solver.storage).\n\nSee solve! for more information about the FFT-based Poisson solver algorithm.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Solvers.FourierTridiagonalPoissonSolver","page":"Library","title":"Oceananigans.Solvers.FourierTridiagonalPoissonSolver","text":"FourierTridiagonalPoissonSolver(grid, planner_flag = FFTW.PATIENT; tridiagonal_formulation=nothing)\n\nConstruct a FourierTridiagonalPoissonSolver on grid with tridiagonal_formulation either XDirection(), YDirection(), or ZDirection(). The tridiagonal_formulation can be used to tweak the tridiagonal matrices to solve variants on the Poisson equation, such as the screened Poisson equation,\n\n(Â² + m) Ï• = b\n\nor the Poisson-like equation\n\nxÂ² Ï• + yÂ² Ï• + z (L z Ï•) = b\n\nor to implement boundary conditions other than the standard homogeneous Neumann boundary conditions.\n\nThe tridiagonal direction is determined by is tridiagonal_direction(tridiagonal_formulation).\n\nIf tridiagonal_formulation is not specified, the tridiagonal direction is selected as the variably-spaced direction of the grid, or as the ZDirection() for grids with uniform spacing in all three directions.\n\nThe (possibly perturbed) Poisson equation is solved with an FFT-based eigenfunction expansion in the non-tridiagonal-directions augmented by a tridiagonal solve in the tridiagonal direction. The non-tridiagonal-directions must be uniformly spaced.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Solvers.KrylovSolver-Tuple{Any}","page":"Library","title":"Oceananigans.Solvers.KrylovSolver","text":"KrylovSolver(linear_operator;\n             template_field::AbstractField,\n             maxiter::Int = prod(size(template_field)),\n             maxtime::Real = Inf,\n             reltol::Real = sqrt(eps(eltype(template_field.grid))),\n             abstol::Real = zero(eltype(template_field.grid)),\n             preconditioner = nothing,\n             method::Symbol = :cg)\n\nConstruct a Krylov subspace solver for implicit linear systems defined by linear_operator, using the structure of a reference field template_field.\n\nArguments\n\nlinear_operator: linear that defines the matrix-vector product y = A * x, where x has the same structure as template_field.\ntemplate_field::AbstractField: A sample field used to infer the architecture, domain geometry, and data types. It is also used to allocate internal buffers and define the operator dimensions.\nmaxiter::Int: Maximum number of Krylov iterations allowed.\nmaxtime::Real: Maximum wall-clock time (in seconds) allowed for solving.\nreltol::Real: Relative tolerance on the residual norm for convergence.\nabstol::Real: Absolute tolerance on the residual norm for convergence.\npreconditioner: An optional preconditioner, passed as a callable or left as nothing for no preconditioning.\nmethod::Symbol: Krylov method to use, such as :cg, :fom, :bicgstab, :gmres.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Solvers.solve!","page":"Library","title":"Oceananigans.Solvers.solve!","text":"solve!(Ï•, solver::FFTBasedPoissonSolver, b, m=0)\n\nSolve the \"generalized\" Poisson equation,\n\n(Â² + m) Ï• = b\n\nwhere m is a number, using a eigenfunction expansion of the discrete Poisson operator on a staggered grid and for periodic or Neumann boundary conditions.\n\nIn-place transforms are applied to b, which means b must have complex-valued elements (typically the same type as solver.storage).\n\ninfo: Alternative names for 'generalized' Poisson equation\nEquation (Â² + m) Ï• = b is sometimes referred to as the \"screened Poisson\" equation when m  0, or the Helmholtz equation when m  0.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.Solvers.solve!-Tuple{Any, Oceananigans.Solvers.BatchedTridiagonalSolver, Any, Vararg{Any}}","page":"Library","title":"Oceananigans.Solvers.solve!","text":"solve!(Ï•, solver::BatchedTridiagonalSolver, rhs, args...)\n\nSolve the batched tridiagonal system of linear equations with right hand side rhs and lower diagonal, diagonal, and upper diagonal coefficients described by the BatchedTridiagonalSolver solver. BatchedTridiagonalSolver uses a modified TriDiagonal Matrix Algorithm (TDMA).\n\nThe result is stored in Ï• which must have size (grid.Nx, grid.Ny, grid.Nz).\n\nImplementation follows Press William et al. (1992); Â§2.4. Note that a slightly different notation from Press et al. is used for indexing the off-diagonal elements; see BatchedTridiagonalSolver.\n\nReference\n\nPress William, H., Teukolsky Saul, A., Vetterling William, T., & Flannery Brian, P. (1992).     Numerical recipes: the art of scientific computing. Cambridge University Press\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Solvers.solve!-Tuple{Any, Oceananigans.Solvers.ConjugateGradientSolver, Any, Vararg{Any}}","page":"Library","title":"Oceananigans.Solvers.solve!","text":"solve!(x, solver::ConjugateGradientSolver, b, args...)\n\nSolve A * x = b using an iterative conjugate-gradient method, where A * x is determined by solver.linear_operation\n\nSee figure 2.5 in\n\nThe Preconditioned Conjugate Gradient Method in \"Templates for the Solution of Linear Systems: Building Blocks for Iterative Methods\" Barrett et. al, 2nd Edition.\n\nGiven:\n\nLinear Preconditioner operator M!(solution, x, other_args...) that computes M * x = solution\nA matrix operator A as a function A();\nA dot product function norm();\nA right-hand side b;\nAn initial guess x; and\nLocal vectors: z, r, p, q\n\nThis function executes the psuedocode algorithm\n\nÎ²  = 0\nr = b - A(x)\niteration  = 0\n\nLoop:\n     if iteration > maxiter\n        break\n     end\n\n     Ï = r â‹… z\n\n     z = M(r)\n     Î² = Ïâ±â»Â¹ / Ï\n     p = z + Î² * p\n     q = A(p)\n\n     Î± = Ï / (p â‹… q)\n     x = x + Î± * p\n     r = r - Î± * q\n\n     if |r| < tolerance\n        break\n     end\n\n     iteration += 1\n     Ïâ±â»Â¹ = Ï\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Stokes-drift","page":"Library","title":"Stokes drift","text":"","category":"section"},{"location":"appendix/library/#Oceananigans.StokesDrifts.StokesDrift-Tuple{}","page":"Library","title":"Oceananigans.StokesDrifts.StokesDrift","text":"StokesDrift(; âˆ‚z_uË¢=zerofunction, âˆ‚y_uË¢=zerofunction, âˆ‚t_uË¢=zerofunction,\n              âˆ‚z_vË¢=zerofunction, âˆ‚x_vË¢=zerofunction, âˆ‚t_vË¢=zerofunction,\n              âˆ‚x_wË¢=zerofunction, âˆ‚y_wË¢=zerofunction, âˆ‚t_wË¢=zerofunction, parameters=nothing)\n\nConstruct a set of functions of space and time for a Stokes drift velocity field corresponding to a surface gravity wave field with an envelope that (potentially) varies in the horizontal directions.\n\nTo resolve the evolution of the Lagrangian-mean momentum, we require all the components of the \"psuedovorticity\",\n\n  ğ¯Ë¢ = hatboldsymbolx (_y wË¢ - _z vË¢) + hatboldsymboly (_z uË¢ - _x wË¢) + hatboldsymbolz (_x vË¢ - _y uË¢)\n\nas well as the time-derivatives of uË¢, vË¢, and wË¢.\n\nNote that each function (e.g., âˆ‚z_uË¢) is generally a function of depth, horizontal coordinates, and time.Thus, the correct function signature depends on the grid, since Flat horizontal directions are omitted.\n\nFor example, on a grid with topology = (Periodic, Flat, Bounded) (and parameters=nothing), then, e.g., âˆ‚z_uË¢ is callable via âˆ‚z_uË¢(x, z, t). When !isnothing(parameters), then âˆ‚z_uË¢ is callable via âˆ‚z_uË¢(x, z, t, parameters). Similarly, on a grid with topology = (Periodic, Periodic, Bounded) and parameters=nothing, âˆ‚z_uË¢ is called via âˆ‚z_uË¢(x, y, z, t).\n\nExample\n\nA wavepacket moving with the group velocity in the x-direction. We write the Stokes drift as:\n\nuË¢(x y z t) = A(x - cáµ  t y) uË¢(z)\n\nwith A(Î¾ Î·) = exp-(Î¾^2 + Î·^2)  2Î´^2. We also assume vË¢ = 0. If ğ¯Ë¢ represents the solenoidal component of the Stokes drift, then in this system from incompressibility requirement we have that _z wË¢ = - _x uË¢ = - (_Î¾ A) uË¢ and therefore, under the assumption that wË¢ tends to zero at large depths, we get wË¢ = - (_Î¾ A  2k) uË¢.\n\nusing Oceananigans\nusing Oceananigans.Units\n\ng = 9.81 # gravitational acceleration\n\nÏµ = 0.1\nÎ» = 100meters  # horizontal wavelength\nconst k = 2Ï€ / Î»  # horizontal wavenumber\nc = sqrt(g / k)  # phase speed\nconst Î´ = 400kilometers  # wavepacket spread\nconst cáµ = c / 2  # group speed\nconst UË¢ = Ïµ^2 * c\n\n@inline A(Î¾, Î·) = exp(- (Î¾^2 + Î·^2) / 2Î´^2)\n\n@inline âˆ‚Î¾_A(Î¾, Î·) = - Î¾ / Î´^2 * A(Î¾, Î·)\n@inline âˆ‚Î·_A(Î¾, Î·) = - Î· / Î´^2 * A(Î¾, Î·)\n@inline âˆ‚Î·_âˆ‚Î¾_A(Î¾, Î·) = Î· * Î¾ / Î´^4 * A(Î¾, Î·)\n@inline âˆ‚Â²Î¾_A(Î¾, Î·) = (Î¾^2 / Î´^2 - 1) * A(Î¾, Î·) / Î´^2\n\n@inline uÌ‚Ë¢(z) = UË¢ * exp(2k * z)\n@inline uË¢(x, y, z, t) = A(x - cáµ * t, y) * uÌ‚Ë¢(z)\n\n@inline âˆ‚z_uË¢(x, y, z, t) = 2k * A(x - cáµ * t, y) * uÌ‚Ë¢(z)\n@inline âˆ‚y_uË¢(x, y, z, t) = âˆ‚Î·_A(x - cáµ * t, y) * uÌ‚Ë¢(z)\n@inline âˆ‚t_uË¢(x, y, z, t) = - cáµ * âˆ‚Î¾_A(x - cáµ * t, y) * uÌ‚Ë¢(z)\n@inline âˆ‚x_wË¢(x, y, z, t) = - 1 / 2k * âˆ‚Â²Î¾_A(x - cáµ * t, y) * uÌ‚Ë¢(z)\n@inline âˆ‚y_wË¢(x, y, z, t) = - 1 / 2k * âˆ‚Î·_âˆ‚Î¾_A(x - cáµ * t, y) * uÌ‚Ë¢(z)\n@inline âˆ‚t_wË¢(x, y, z, t) = + cáµ / 2k * âˆ‚Â²Î¾_A(x - cáµ * t, y) * uÌ‚Ë¢(z)\n\nstokes_drift = StokesDrift(; âˆ‚z_uË¢, âˆ‚t_uË¢, âˆ‚y_uË¢, âˆ‚t_wË¢, âˆ‚x_wË¢, âˆ‚y_wË¢)\n\n# output\n\nStokesDrift{Nothing}:\nâ”œâ”€â”€ âˆ‚x_vË¢: zerofunction\nâ”œâ”€â”€ âˆ‚x_wË¢: âˆ‚x_wË¢\nâ”œâ”€â”€ âˆ‚y_uË¢: âˆ‚y_uË¢\nâ”œâ”€â”€ âˆ‚y_wË¢: âˆ‚y_wË¢\nâ”œâ”€â”€ âˆ‚z_uË¢: âˆ‚z_uË¢\nâ”œâ”€â”€ âˆ‚z_vË¢: zerofunction\nâ”œâ”€â”€ âˆ‚t_uË¢: âˆ‚t_uË¢\nâ”œâ”€â”€ âˆ‚t_vË¢: zerofunction\nâ””â”€â”€ âˆ‚t_wË¢: âˆ‚t_wË¢\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.StokesDrifts.UniformStokesDrift-Tuple{}","page":"Library","title":"Oceananigans.StokesDrifts.UniformStokesDrift","text":"UniformStokesDrift(; âˆ‚z_uË¢=zerofunction, âˆ‚z_vË¢=zerofunction, âˆ‚t_uË¢=zerofunction, âˆ‚t_vË¢=zerofunction, parameters=nothing)\n\nConstruct a set of functions for a Stokes drift velocity field corresponding to a horizontally-uniform surface gravity wave field, with optional parameters.\n\nIf parameters=nothing, then the functions âˆ‚z_uË¢, âˆ‚z_vË¢, âˆ‚t_uË¢, âˆ‚t_vË¢ must be callable with signature (z, t). If !isnothing(parameters), then functions must be callable with the signature (z, t, parameters).\n\nTo resolve the evolution of the Lagrangian-mean momentum, we require vertical-derivatives and time-derivatives of the horizontal components of the Stokes drift, uË¢ and vË¢.\n\nExamples\n\nExponentially decaying Stokes drift corresponding to a surface Stokes drift of uË¢(z=0) = 0.005 and decay scale h = 20:\n\nusing Oceananigans\n\n@inline uniform_stokes_shear(z, t) = 0.005 * exp(z / 20)\n\nstokes_drift = UniformStokesDrift(âˆ‚z_uË¢=uniform_stokes_shear)\n\n# output\n\nUniformStokesDrift{Nothing}:\nâ”œâ”€â”€ âˆ‚z_uË¢: uniform_stokes_shear\nâ”œâ”€â”€ âˆ‚z_vË¢: zerofunction\nâ”œâ”€â”€ âˆ‚t_uË¢: zerofunction\nâ””â”€â”€ âˆ‚t_vË¢: zerofunction\n\nExponentially-decaying Stokes drift corresponding to a surface Stokes drift of uË¢ = 0.005 and decay scale h = 20, using parameters:\n\nusing Oceananigans\n\n@inline uniform_stokes_shear(z, t, p) = p.uË¢ * exp(z / p.h)\n\nstokes_drift_parameters = (uË¢ = 0.005, h = 20)\nstokes_drift = UniformStokesDrift(âˆ‚z_uË¢=uniform_stokes_shear, parameters=stokes_drift_parameters)\n\n# output\n\nUniformStokesDrift with parameters (uË¢=0.005, h=20):\nâ”œâ”€â”€ âˆ‚z_uË¢: uniform_stokes_shear\nâ”œâ”€â”€ âˆ‚z_vË¢: zerofunction\nâ”œâ”€â”€ âˆ‚t_uË¢: zerofunction\nâ””â”€â”€ âˆ‚t_vË¢: zerofunction\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Time-steppers","page":"Library","title":"Time steppers","text":"","category":"section"},{"location":"appendix/library/#Oceananigans.TimeSteppers.Clock","page":"Library","title":"Oceananigans.TimeSteppers.Clock","text":"mutable struct Clock{T, FT}\n\nKeeps track of the current time, last_Î”t, iteration number, and time-stepping stage. The stage is updated only for multi-stage time-stepping methods. The time::T is either a number or a DateTime object.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TimeSteppers.Clock-Tuple{}","page":"Library","title":"Oceananigans.TimeSteppers.Clock","text":"Clock(; time, last_Î”t=Inf, last_stage_Î”t=Inf, iteration=0, stage=1)\n\nReturn a Clock object. By default, Clock is initialized to the zeroth iteration and first time step stage with last_Î”t=last_stage_Î”t=Inf.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper-Union{Tuple{IT}, Tuple{Any, Any}, Tuple{Any, Any, Any}} where IT","page":"Library","title":"Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper","text":"QuasiAdamsBashforth2TimeStepper(grid, prognostic_fields, Ï‡ = 0.1;\n                                implicit_solver = nothing,\n                                Gâ¿ = map(similar, prognostic_fields),\n                                Gâ» = map(similar, prognostic_fields))\n\nReturn a 2nd-order quasi Adams-Bashforth (AB2) time stepper (QuasiAdamsBashforth2TimeStepper) on grid, with tracers, and AB2 parameter Ï‡. The tendency fields Gâ¿ and Gâ», usually equal to the prognostic_fields that is passed as positional argument, can be specified via optional kwargs.\n\nThe 2nd-order quasi Adams-Bashforth timestepper steps forward the state Uâ¿ by Î”t via\n\nUâ¿âºÂ¹ = Uâ¿ + Î”t * [(3/2 + Ï‡) * Gâ¿ - (1/2 + Ï‡) * Gâ¿â»Â¹]\n\nwhere Uâ¿ is the state at the n-th timestep, Gâ¿ is the tendency at the n-th timestep, and Gâ¿â»Â¹ is the tendency at the previous timestep (Gâ»).\n\nnote: First timestep\nFor the first timestep, since there are no saved tendencies from the previous timestep, the QuasiAdamsBashforth2TimeStepper performs an Euler timestep:Uâ¿âºÂ¹ = Uâ¿ + Î”t * Gâ¿\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.TimeSteppers.RungeKutta3TimeStepper","page":"Library","title":"Oceananigans.TimeSteppers.RungeKutta3TimeStepper","text":"RungeKutta3TimeStepper{FT, TG} <: AbstractTimeStepper\n\nHold parameters and tendency fields for a low storage, third-order Runge-Kutta-Wray time-stepping scheme described by Le and Moin (1991).\n\nReferences\n\nLe, H. and Moin, P. (1991). An improvement of fractional step methods for the incompressible     Navierâ€“Stokes equations. Journal of Computational Physics, 92, 369â€“379.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TimeSteppers.RungeKutta3TimeStepper-Union{Tuple{TG}, Tuple{TI}, Tuple{Any, Any}} where {TI, TG}","page":"Library","title":"Oceananigans.TimeSteppers.RungeKutta3TimeStepper","text":"RungeKutta3TimeStepper(grid, prognostic_fields;\n                       implicit_solver = nothing,\n                       Gâ¿ = map(similar, prognostic_fields),\n                       Gâ» = map(similar, prognostic_fields))\n\nReturn a 3rd-order Runge-Kutta timestepper (RungeKutta3TimeStepper) on grid and with prognostic_fields. The tendency fields Gâ¿ and Gâ», typically equal to the prognostic_fields can be modified via the optional kwargs.\n\nThe scheme is described by Le and Moin (1991). In a nutshell, the 3rd-order Runge-Kutta timestepper steps forward the state Uâ¿ by Î”t via 3 substeps. A pressure correction step is applied after at each substep.\n\nThe state U after each substep m is\n\nUáµâºÂ¹ = Uáµ + Î”t * (Î³áµ * Gáµ + Î¶áµ * Gáµâ»Â¹)\n\nwhere Uáµ is the state at the m-th substep, Gáµ is the tendency at the m-th substep, Gáµâ»Â¹ is the tendency at the previous substep, and constants Î³Â¹ = 8/15, Î³Â² = 5/12, Î³Â³ = 3/4, Î¶Â¹ = 0, Î¶Â² = -17/60, and Î¶Â³ = -5/12.\n\nThe state at the first substep is taken to be the one that corresponds to the n-th timestep, UÂ¹ = Uâ¿, and the state after the third substep is then the state at the Uâ¿âºÂ¹ = Uâ´.\n\nReferences\n\nLe, H. and Moin, P. (1991). An improvement of fractional step methods for the incompressible     Navierâ€“Stokes equations. Journal of Computational Physics, 92, 369â€“379.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.TimeSteppers.SplitRungeKutta3TimeStepper","page":"Library","title":"Oceananigans.TimeSteppers.SplitRungeKutta3TimeStepper","text":"SplitRungeKutta3TimeStepper{FT, TG, PF, TI} <: AbstractTimeStepper\n\nHold parameters and tendency fields for a low storage, third-order Runge-Kutta-Wray time-stepping scheme described by Lan et al. (2022).\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TimeSteppers.SplitRungeKutta3TimeStepper-Union{Tuple{PF}, Tuple{TG}, Tuple{TI}, Tuple{Any, Any, Vararg{Any}}} where {TI, TG, PF}","page":"Library","title":"Oceananigans.TimeSteppers.SplitRungeKutta3TimeStepper","text":"SplitRungeKutta3TimeStepper(grid, prognostic_fields, args...;\n                            implicit_solver::TI = nothing,\n                            Gâ¿::TG = map(similar, prognostic_fields),\n                            Î¨â»::PF = map(similar, prognostic_fields),\n                            kwargs...) where {TI, TG, PF}\n\nReturn a 3rd-order SplitRungeKutta3TimeStepper on grid and with tracers. The tendency fields Gâ¿ and Gâ», and the previous state Î¨â» can be modified via optional kwargs.\n\nThe scheme is described by Knoth and Wensch (2014). In a nutshell, the 3rd-order Runge-Kutta timestepper steps forward the state Uâ¿ by Î”t via 3 substeps. A barotropic velocity correction step is applied after at each substep.\n\nThe state U after each substep m is equivalent to an Euler step with a modified time step:\n\nÎ”tÌƒ   = Î”t / Î²áµ\nUáµâºÂ¹ = Uâ¿ + Î”tÌƒ * Gáµ\n\nwhere Uáµ is the state at the m-th substep, Uâ¿ is the state at the n-th timestep, Gáµ is the tendency at the m-th substep, and constants Î²Â¹ = 3, Î²Â² = 2, Î²Â³ = 1.\n\nThe state at the first substep is taken to be the one that corresponds to the n-th timestep, UÂ¹ = Uâ¿, and the state after the third substep is then the state at the Uâ¿âºÂ¹ = UÂ³.\n\nReferences\n\nKnoth, O., and Wensch, J. (2014). Generalized Split-Explicit Runge-Kutta methods for the     compressible Euler equations. Monthly Weather Review, 142, 2067-2081,     https://doi.org/10.1175/MWR-D-13-00068.1.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.TimeSteppers.time_step!-Tuple{Oceananigans.AbstractModel{<:QuasiAdamsBashforth2TimeStepper}, Any}","page":"Library","title":"Oceananigans.TimeSteppers.time_step!","text":"time_step!(model::AbstractModel{<:QuasiAdamsBashforth2TimeStepper}, Î”t; euler=false)\n\nStep forward model one time step Î”t with a 2nd-order Adams-Bashforth method and pressure-correction substep. Setting euler=true will take a forward Euler time step. The tendencies are calculated by the update_step! at the end of the time_step! function.\n\nThe steps of the Quasi-Adams-Bashforth second-order (AB2) algorithm are:\n\nIf this the first time step (model.clock.iteration == 0), then call update_state! and calculate the tendencies.\nAdvance tracers in time and compute predictor velocities (including implicit vertical diffusion).\nSolve the elliptic equation for pressure (three dimensional for the non-hydrostatic model, two-dimensional for the hydrostatic model).\nCorrect the velocities based on the results of step 3.\nStore the old tendencies.\nUpdate the model state.\nCompute tendencies for the next time step\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.TimeSteppers.time_step!-Tuple{Oceananigans.AbstractModel{<:RungeKutta3TimeStepper}, Any}","page":"Library","title":"Oceananigans.TimeSteppers.time_step!","text":"time_step!(model::AbstractModel{<:RungeKutta3TimeStepper}, Î”t)\n\nStep forward model one time step Î”t with a 3rd-order Runge-Kutta method. The 3rd-order Runge-Kutta method takes three intermediate substep stages to achieve a single timestep. A pressure correction step is applied at each intermediate stage.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Turbulence-closures","page":"Library","title":"Turbulence closures","text":"","category":"section"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation","page":"Library","title":"Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation","text":"AnisotropicMinimumDissipation{FT} <: AbstractTurbulenceClosure\n\nParameters for the \"anisotropic minimum dissipation\" turbulence closure for large eddy simulation proposed originally by Rozema et al. (2015) and Abkar et al. (2016), then modified by Verstappen (2018), and finally described and validated for by Vreugdenhil and Taylor (2018).\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation-Union{Tuple{}, Tuple{TD}, Tuple{TD, Any}} where TD","page":"Library","title":"Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation","text":"AnisotropicMinimumDissipation([time_discretization = ExplicitTimeDiscretization, FT = Float64;]\n                              C = 1/3, CÎ½ = nothing, CÎº = nothing, Cb = nothing)\n\nReturn parameters of type FT for the AnisotropicMinimumDissipation turbulence closure.\n\nArguments\n\ntime_discretization: Either ExplicitTimeDiscretization() or VerticallyImplicitTimeDiscretization(),                        which integrates the terms involving only z-derivatives in the                        viscous and diffusive fluxes with an implicit time discretization.                        Default ExplicitTimeDiscretization().\nFT: Float type; default Float64.\n\nKeyword arguments\n\nC: PoincarÃ© constant for both eddy viscosity and eddy diffusivities. C is overridden      for eddy viscosity or eddy diffusivity if CÎ½ or CÎº are set, respectively.\nCÎ½: PoincarÃ© constant for momentum eddy viscosity.\nCÎº: PoincarÃ© constant for tracer eddy diffusivities. If one number or function, the same       number or function is applied to all tracers. If a NamedTuple, it must possess       a field specifying the PoincarÃ© constant for every tracer.\nCb: Buoyancy modification multiplier (Cb = nothing turns it off, Cb = 1 was used by       Abkar et al. (2016)). Note: that we do not subtract the       horizontally-average component before computing this buoyancy modification term.       This implementation differs from that by Abkar et al. (2016)'s proposal       and the impact of this approximation has not been tested or validated.\n\nBy default: C = CÎ½ = CÎº = 1/3, and Cb = nothing, which turns off the buoyancy modification term. The default PoincarÃ© constant is found by discretizing subgrid scale energy production, assuming a second-order advection scheme. Verstappen et al. (2014) show that the PoincarÃ© constant should be 4 times larger than for straightforward (spectral) discretisation, resulting in C = 1/3 in our formulation. They also empirically demonstrated that this coefficient produces the correct discrete production-dissipation balance. Further demonstration of this can be found at https://github.com/CliMA/Oceananigans.jl/issues/4367.\n\nC, CÎ½ and CÎº may be numbers, or functions of x, y, z.\n\nExamples\n\njulia> using Oceananigans\n\njulia> pretty_diffusive_closure = AnisotropicMinimumDissipation(C=1/2)\nAnisotropicMinimumDissipation{ExplicitTimeDiscretization} turbulence closure with:\n           PoincareÌ constant for momentum eddy viscosity CÎ½: 0.5\n    PoincareÌ constant for tracer(s) eddy diffusivit(ies) CÎº: 0.5\n                        Buoyancy modification multiplier Cb: nothing\n\njulia> using Oceananigans\n\njulia> const Î”z = 0.5; # grid resolution at surface\n\njulia> surface_enhanced_tracer_C(x, y, z) = 1/12 * (1 + exp((z + Î”z/2) / 8Î”z));\n\njulia> fancy_closure = AnisotropicMinimumDissipation(CÎº=surface_enhanced_tracer_C)\nAnisotropicMinimumDissipation{ExplicitTimeDiscretization} turbulence closure with:\n           PoincareÌ constant for momentum eddy viscosity CÎ½: 0.3333333333333333\n    PoincareÌ constant for tracer(s) eddy diffusivit(ies) CÎº: surface_enhanced_tracer_C\n                        Buoyancy modification multiplier Cb: nothing\n\njulia> using Oceananigans\n\njulia> tracer_specific_closure = AnisotropicMinimumDissipation(CÎº=(câ‚=1/12, câ‚‚=1/6))\nAnisotropicMinimumDissipation{ExplicitTimeDiscretization} turbulence closure with:\n           PoincareÌ constant for momentum eddy viscosity CÎ½: 0.3333333333333333\n    PoincareÌ constant for tracer(s) eddy diffusivit(ies) CÎº: (câ‚ = 0.08333333333333333, câ‚‚ = 0.16666666666666666)\n                        Buoyancy modification multiplier Cb: nothing\n\nReferences\n\nAbkar, M., Bae, H. J., & Moin, P. (2016). Minimum-dissipation scalar transport model for     large-eddy simulation of turbulent flows. Physical Review Fluids, 1(4), 041701.\n\nVerstappen, R., Rozema, W., and Bae, J. H. (2014), \"Numerical scale separation in large-eddy     simulation\", Center for Turbulence ResearchProceedings of the Summer Program 2014.\n\nVreugdenhil C., and Taylor J. (2018), \"Large-eddy simulations of stratified plane Couette     flow using the anisotropic minimum-dissipation model\", Physics of Fluids 30, 085104.\n\nVerstappen, R. (2018), \"How much eddy dissipation is needed to counterbalance the nonlinear     production of small, unresolved scales in a large-eddy simulation of turbulence?\",     Computers & Fluids 176, pp. 276-284.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.ConvectiveAdjustmentVerticalDiffusivity","page":"Library","title":"Oceananigans.TurbulenceClosures.ConvectiveAdjustmentVerticalDiffusivity","text":"ConvectiveAdjustmentVerticalDiffusivity([time_discretization = VerticallyImplicitTimeDiscretization(), FT=Float64;]\n                                        convective_Îºz = 0,\n                                        convective_Î½z = 0,\n                                        background_Îºz = 0,\n                                        background_Î½z = 0)\n\nReturn a convective adjustment vertical diffusivity closure that applies different values of diffusivity and/or viscosity depending whether the region is statically stable (positive or zero buoyancy gradient) or statically unstable (negative buoyancy gradient).\n\nArguments\n\ntime_discretization: Either ExplicitTimeDiscretization() or VerticallyImplicitTimeDiscretization();                        default VerticallyImplicitTimeDiscretization().\nFT: Float type; default Float64.\n\nKeyword arguments\n\nconvective_Îºz: Vertical tracer diffusivity in regions with negative (unstable) buoyancy gradients. Either                  a single number, function, array, field, or tuple of diffusivities for each tracer.\nbackground_Îºz: Vertical tracer diffusivity in regions with zero or positive (stable) buoyancy gradients.\nconvective_Î½z: Vertical viscosity in regions with negative (unstable) buoyancy gradients. Either                 a number, function, array, or field.\nbackground_Îºz: Vertical viscosity in regions with zero or positive (stable) buoyancy gradients.\n\nExample\n\njulia> using Oceananigans\n\njulia> cavd = ConvectiveAdjustmentVerticalDiffusivity(convective_Îºz = 1)\nConvectiveAdjustmentVerticalDiffusivity{VerticallyImplicitTimeDiscretization}(background_Îºz=0.0 convective_Îºz=1 background_Î½z=0.0 convective_Î½z=0.0)\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization","page":"Library","title":"Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization","text":"struct ExplicitTimeDiscretization <: AbstractTimeDiscretization\n\nA fully-explicit time-discretization of a TurbulenceClosure.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.HorizontalDivergenceScalarDiffusivity","page":"Library","title":"Oceananigans.TurbulenceClosures.HorizontalDivergenceScalarDiffusivity","text":"HorizontalDivergenceScalarDiffusivity([time_discretization=ExplicitTimeDiscretization(),\n                                      FT::DataType=Float64;]\n                                      kwargs...)\n\nShorthand for a ScalarDiffusivity with HorizontalDivergenceFormulation(). See ScalarDiffusivity.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.HorizontalScalarDiffusivity","page":"Library","title":"Oceananigans.TurbulenceClosures.HorizontalScalarDiffusivity","text":"HorizontalScalarDiffusivity([time_discretization=ExplicitTimeDiscretization(),\n                            FT::DataType=Float64;]\n                            kwargs...)\n\nShorthand for a ScalarDiffusivity with HorizontalFormulation(). See ScalarDiffusivity.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.IsopycnalSkewSymmetricDiffusivity-Union{Tuple{}, Tuple{A}, Tuple{TD}, Tuple{TD, Any}} where {TD, A}","page":"Library","title":"Oceananigans.TurbulenceClosures.IsopycnalSkewSymmetricDiffusivity","text":"IsopycnalSkewSymmetricDiffusivity([time_disc=VerticallyImplicitTimeDiscretization(), FT=Float64;]\n                                  Îº_skew = 0,\n                                  Îº_symmetric = 0,\n                                  skew_flux_formulation = DiffusiveFormulation(),\n                                  isopycnal_tensor = SmallSlopeIsopycnalTensor(),\n                                  slope_limiter = FluxTapering(1e-2))\n\nReturn parameters for an isopycnal skew-symmetric tracer diffusivity with skew diffusivity Îº_skew and symmetric diffusivity Îº_symmetric that uses an isopycnal_tensor model for for calculating the isopycnal slopes, and (optionally) applying a slope_limiter to the calculated isopycnal slope values. The skew fluxes can be computed using either the AdvectiveFormulation or the DiffusiveFormulation.\n\nBoth Îº_skew and Îº_symmetric may be constants, arrays, fields, or functions of (x, y, z, t).\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.RiBasedVerticalDiffusivity","page":"Library","title":"Oceananigans.TurbulenceClosures.RiBasedVerticalDiffusivity","text":"RiBasedVerticalDiffusivity([time_discretization = VerticallyImplicitTimeDiscretization(),\n                           FT = Float64;]\n                           Ri_dependent_tapering = HyperbolicTangentRiDependentTapering(),\n                           horizontal_Ri_filter = nothing,\n                           minimum_entrainment_buoyancy_gradient = 1e-10,\n                           maximum_diffusivity = Inf,\n                           maximum_viscosity = Inf,\n                           Î½â‚€  = 0.7,\n                           Îºâ‚€  = 0.5,\n                           Îºá¶œáµƒ = 1.7,\n                           Cáµ‰â¿ = 0.1,\n                           Cáµƒáµ› = 0.6,\n                           Riâ‚€ = 0.1,\n                           RiáµŸ = 0.4,\n                           warning = true)\n\nReturn a closure that estimates the vertical viscosity and diffusivity from \"convective adjustment\" coefficients Î½â‚€ and Îºâ‚€ multiplied by a decreasing function of the Richardson number, Ri.\n\nArguments\n\ntime_discretization: Either ExplicitTimeDiscretization() or VerticallyImplicitTimeDiscretization(),                        which integrates the terms involving only z-derivatives in the                        viscous and diffusive fluxes with an implicit time discretization.                        Default VerticallyImplicitTimeDiscretization().\nFT: Float type; default Float64.\n\nKeyword arguments\n\nRi_dependent_tapering: The Ri-dependent tapering. Options are: PiecewiseLinearRiDependentTapering(), HyperbolicTangentRiDependentTapering() (default), and ExponentialRiDependentTapering().\nÎ½â‚€: Non-convective viscosity (units of kinematic viscosity, typically mÂ² sâ»Â¹).\nÎºâ‚€: Non-convective diffusivity for tracers (units of diffusivity, typically mÂ² sâ»Â¹).\nÎºá¶œáµƒ: Convective adjustment diffusivity for tracers (units of diffusivity, typically mÂ² sâ»Â¹).\nCáµ‰â¿: Entrainment coefficient for tracers (non-dimensional).        Set Cáµ‰â¿ = 0 to turn off the penetrative entrainment diffusivity.\nCáµƒáµ›: Time-averaging coefficient for viscosity and diffusivity (non-dimensional).\nRiâ‚€: Ri threshold for decreasing viscosity and diffusivity (non-dimensional).\nRiáµŸ: Ri-width over which viscosity and diffusivity decreases to 0 (non-dimensional).\nminimum_entrainment_buoyancy_gradient: Minimum buoyancy gradient for application of the entrainment                                          diffusvity. If the entrainment buoyancy gradient is less than the                                          minimum value, the entrainment diffusivity is 0. Units of                                          buoyancy gradient (typically sâ»Â²).\nmaximum_diffusivity: A limiting maximum tracer diffusivity (units of diffusivity, typically mÂ² sâ»Â¹).\nmaximum_viscosity: A limiting maximum viscosity (units of kinematic viscosity, typically mÂ² sâ»Â¹).\nhorizontal_Ri_filter: Horizontal filter to apply to Ri, which can help alleviate noise for                         some simulations. The default is nothing, or no filtering. The other                         option is horizontal_Ri_filter = FivePointHorizontalFilter().\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.ScalarBiharmonicDiffusivity","page":"Library","title":"Oceananigans.TurbulenceClosures.ScalarBiharmonicDiffusivity","text":"ScalarBiharmonicDiffusivity(formulation = ThreeDimensionalFormulation(), FT = Oceananigans.defaults.FloatType;\n                            Î½ = 0,\n                            Îº = 0,\n                            discrete_form = false,\n                            loc = (nothing, nothing, nothing),\n                            parameters = nothing)\n\nReturn a scalar biharmonic diffusivity turbulence closure with viscosity coefficient Î½ and tracer diffusivities Îº for each tracer field in tracers. If a single Îº is provided, it is applied to all tracers. Otherwise Îº must be a NamedTuple with values for every tracer individually.\n\nArguments\n\nformulation:\nHorizontalFormulation() for diffusivity applied in the horizontal direction(s)\nVerticalFormulation() for diffusivity applied in the vertical direction,\nThreeDimensionalFormulation() (default) for diffusivity applied isotropically to all directions\nHorizontalDivergenceFormulation() for horizontal viscosity with \"divergence damping\" and no effect on tracers\nHorizontalVectorInvariantFormulation() for horizontally isotropic vector invariant diffusivity\nFT: the float datatype (default: Float64)\n\nKeyword arguments\n\nÎ½: Viscosity. Number, AbstractArray, Field, or Function.\nÎº: Diffusivity. Number, AbstractArray, Field, Function, or      NamedTuple of diffusivities with entries for each tracer.\ndiscrete_form: Boolean; default: false.\nrequired_halo_size = 2: the required halo size for the closure. This value should be an integer. change only if using a function for Î½ or Îº that requires a halo size larger than 1 to compute.\n\nWhen prescribing the viscosities or diffusivities as functions, depending on the value of keyword argument discrete_form, the constructor expects:\n\ndiscrete_form = false (default): functions of the grid's native coordinates and time, e.g., (x, y, z, t) for a RectilinearGrid or (Î», Ï†, z, t) for a LatitudeLongitudeGrid.\ndiscrete_form = true:\nwith loc = (nothing, nothing, nothing) (default): functions of (i, j, k, grid, â„“x, â„“y, â„“z) with â„“x, â„“y, and â„“z either Face() or Center().\nwith loc = (â„“x, â„“y, â„“z) with â„“x, â„“y, and â„“z either Face() or Center(): functions of (i, j, k, grid).\nparameters: NamedTuple with parameters used by the functions that compute viscosity and/or diffusivity; default: nothing.\n\nFor examples see ScalarDiffusivity.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.ScalarBiharmonicDiffusivity-2","page":"Library","title":"Oceananigans.TurbulenceClosures.ScalarBiharmonicDiffusivity","text":"struct ScalarBiharmonicDiffusivity{F, N, V, K} <: AbstractScalarBiharmonicDiffusivity{F}\n\nHolds viscosity and diffusivities for models with prescribed isotropic diffusivities.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.ScalarDiffusivity","page":"Library","title":"Oceananigans.TurbulenceClosures.ScalarDiffusivity","text":"ScalarDiffusivity(time_discretization = ExplicitTimeDiscretization(),\n                  formulation = ThreeDimensionalFormulation(), FT = Float64;\n                  Î½ = 0,\n                  Îº = 0,\n                  discrete_form = false,\n                  loc = (nothing, nothing, nothing),\n                  parameters = nothing)\n\nReturn ScalarDiffusivity turbulence closure with viscosity Î½ and tracer diffusivities Îº for each tracer field in tracers. If a single Îº is provided, it is applied to all tracers. Otherwise Îº must be a NamedTuple with values for every tracer individually.\n\nArguments\n\ntime_discretization: either ExplicitTimeDiscretization() (default) or VerticallyImplicitTimeDiscretization().\nformulation:\nHorizontalFormulation() for diffusivity applied in the horizontal direction(s)\nVerticalFormulation() for diffusivity applied in the vertical direction,\nThreeDimensionalFormulation() (default) for diffusivity applied isotropically to all directions\nFT: the float datatype (default: Float64)\n\nKeyword arguments\n\nÎ½: Viscosity. Number, AbstractArray, Field, or Function.\nÎº: Diffusivity. Number, AbstractArray, Field, Function, or      NamedTuple of diffusivities with entries for each tracer.\ndiscrete_form: Boolean; default: false.\n\nWhen prescribing the viscosities or diffusivities as functions, depending on the value of keyword argument discrete_form, the constructor expects:\n\ndiscrete_form = false (default): functions of the grid's native coordinates and time, e.g., (x, y, z, t) for a RectilinearGrid or (Î», Ï†, z, t) for a LatitudeLongitudeGrid.\ndiscrete_form = true:\nwith loc = (nothing, nothing, nothing) and parameters = nothing (default): functions of (i, j, k, grid, â„“x, â„“y, â„“z, clock, fields) with â„“x, â„“y, and â„“z either Face() or Center().\nwith loc = (â„“x, â„“y, â„“z) with â„“x, â„“y, and â„“z either Face() or Center() and parameters = nothing: functions of (i, j, k, grid, clock, fields).\nwith loc = (nothing, nothing, nothing) and specified parameters: functions of (i, j, k, grid, â„“x, â„“y, â„“z, clock, fields, parameters).\nwith loc = (â„“x, â„“y, â„“z) and specified parameters: functions of (i, j, k, grid, clock, fields, parameters).\nrequired_halo_size = 1: the required halo size for the closure. This value should be an integer. change only if using a function for Î½ or Îº that requires a halo size larger than 1 to compute.\nparameters: NamedTuple with parameters used by the functions that compute viscosity and/or diffusivity; default: nothing.\n\nExamples\n\njulia> using Oceananigans\n\njulia> ScalarDiffusivity(Î½=1000, Îº=2000)\nScalarDiffusivity{ExplicitTimeDiscretization}(Î½=1000.0, Îº=2000.0)\n\njulia> const depth_scale = 100;\n\njulia> @inline Î½(x, y, z, t) = 1000 * exp(z / depth_scale)\nÎ½ (generic function with 1 method)\n\njulia> ScalarDiffusivity(Î½=Î½)\nScalarDiffusivity{ExplicitTimeDiscretization}(Î½=Î½ (generic function with 1 method), Îº=0.0)\n\njulia> using Oceananigans.Grids: znode\n\njulia> @inline function Îº(i, j, k, grid, â„“x, â„“y, â„“z, clock, fields)\n           z = znode(i, j, k, grid, â„“x, â„“y, â„“z)\n           return 2000 * exp(z / depth_scale)\n       end\nÎº (generic function with 1 method)\n\njulia> ScalarDiffusivity(Îº=Îº, discrete_form=true)\nScalarDiffusivity{ExplicitTimeDiscretization}(Î½=0.0, Îº=Oceananigans.TurbulenceClosures.DiscreteDiffusionFunction{Nothing, Nothing, Nothing, Nothing, typeof(Îº)})\n\njulia> @inline function another_Îº(i, j, k, grid, clock, fields, p)\n           z = znode(i, j, k, grid, Center(), Center(), Face())\n           return 2000 * exp(z / p.depth_scale)\n       end\nanother_Îº (generic function with 1 method)\n\njulia> ScalarDiffusivity(Îº=another_Îº, discrete_form=true, loc=(Center, Center, Face), parameters=(; depth_scale = 120.0))\nScalarDiffusivity{ExplicitTimeDiscretization}(Î½=0.0, Îº=Oceananigans.TurbulenceClosures.DiscreteDiffusionFunction{Center, Center, Face, @NamedTuple{depth_scale::Float64}, typeof(another_Îº)})\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.TwoDimensionalLeith","page":"Library","title":"Oceananigans.TurbulenceClosures.TwoDimensionalLeith","text":"TwoDimensionalLeith(FT=Float64;\n                    C=0.3, C_Redi=1, C_GM=1,\n                    isopycnal_model=SmallSlopeIsopycnalTensor())\n\nReturn a TwoDimensionalLeith type associated with the turbulence closure proposed by Leith (1968) and Foxâ€Kemper and Menemenlis (2008) which has an eddy viscosity of the form\n\nÎ½â‚‘ = (C * Î”á¶ )Â³ * âˆš(|âˆ‡â‚• Î¶|Â² + |âˆ‡â‚• âˆ‚w/âˆ‚z|Â²)\n\nand an eddy diffusivity of the form...\n\nwhere Î”á¶  is the filter width, Î¶ = âˆ‚v/âˆ‚x - âˆ‚u/âˆ‚y is the vertical vorticity, and C is a model constant.\n\nKeyword arguments\n\nC: Model constant\nC_Redi: Coefficient for down-gradient tracer diffusivity for each tracer.           Either a constant applied to every tracer, or a NamedTuple with fields           for each tracer individually.\nC_GM: Coefficient for down-gradient tracer diffusivity for each tracer.       Either a constant applied to every tracer, or a NamedTuple with fields       for each tracer individually.\n\nReferences\n\nLeith, C. E. (1968). \"Diffusion Approximation for Twoâ€Dimensional Turbulence\", The Physics of     Fluids 11, 671. doi: 10.1063/1.1691968\n\nFoxâ€Kemper, B., & D. Menemenlis (2008). \"Can large eddy simulation techniques improve mesoscale rich     ocean models?\", in Ocean Modeling in an Eddying Regime, Geophys. Monogr. Ser., 177, pp. 319â€“337.     doi: 10.1029/177GM19\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.VerticalScalarDiffusivity","page":"Library","title":"Oceananigans.TurbulenceClosures.VerticalScalarDiffusivity","text":"VerticalScalarDiffusivity([time_discretization=ExplicitTimeDiscretization(),\n                          FT::DataType=Float64;]\n                          kwargs...)\n\nShorthand for a ScalarDiffusivity with VerticalFormulation(). See ScalarDiffusivity.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.VerticallyImplicitTimeDiscretization","page":"Library","title":"Oceananigans.TurbulenceClosures.VerticallyImplicitTimeDiscretization","text":"struct VerticallyImplicitTimeDiscretization <: AbstractTimeDiscretization\n\nA vertically-implicit time-discretization of a TurbulenceClosure.\n\nThis implies that a flux divergence such as   ğª at the n-th timestep is time-discretized as\n\n[âˆ‡ â‹… q]â¿ = [explicit_flux_divergence]â¿ + [âˆ‚z (Îº âˆ‚z c)]â¿âºÂ¹\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.diffusivity","page":"Library","title":"Oceananigans.TurbulenceClosures.diffusivity","text":"diffusivity(closure, tracer_index, diffusivity_fields)\n\nReturns the scalar diffusivity associated with closure and tracer_index.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.viscosity","page":"Library","title":"Oceananigans.TurbulenceClosures.viscosity","text":"viscosity(closure, diffusivities)\n\nReturns the scalar viscosity associated with closure.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#TKEBasedVerticalDiffusivities","page":"Library","title":"TKEBasedVerticalDiffusivities","text":"","category":"section"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.TKEBasedVerticalDiffusivities.CATKEVerticalDiffusivity-Union{Tuple{}, Tuple{TD}, Tuple{TD, Any}} where TD","page":"Library","title":"Oceananigans.TurbulenceClosures.TKEBasedVerticalDiffusivities.CATKEVerticalDiffusivity","text":"CATKEVerticalDiffusivity([time_discretization = VerticallyImplicitTimeDiscretization(),\n                         FT = Float64;]\n                         mixing_length = CATKEMixingLength(),\n                         turbulent_kinetic_energy_equation = CATKEEquation(),\n                         maximum_tracer_diffusivity = Inf,\n                         maximum_tke_diffusivity = Inf,\n                         maximum_viscosity = Inf,\n                         minimum_tke = 1e-9,\n                         minimum_convective_buoyancy_flux = 1e-11,\n                         negative_tke_damping_time_scale = 1minute,\n                         tke_time_step = nothing)\n\nReturn the CATKEVerticalDiffusivity turbulence closure for vertical mixing by small-scale ocean turbulence based on the prognostic evolution of subgrid Turbulent Kinetic Energy (TKE).\n\nnote: CATKE vertical diffusivity\nCATKEVerticalDiffusivity is a new turbulence closure diffusivity. The default values for its free parameters are obtained from calibration against large eddy simulations. For more details please refer to Wagner et al. (2025).Use with caution and report any issues with the physics at https://github.com/CliMA/Oceananigans.jl/issues.\n\nArguments\n\ntime_discretization: Either ExplicitTimeDiscretization() or VerticallyImplicitTimeDiscretization();                        default VerticallyImplicitTimeDiscretization().\nFT: Float type; default Float64.\n\nKeyword arguments\n\nmixing_length: The formulation for mixing length; default: CATKEMixingLength().\nturbulent_kinetic_energy_equation: The TKE equation; default: CATKEEquation().\nmaximum_tracer_diffusivity: Maximum value for tracer diffusivity. CATKE-predicted tracer                               diffusivities that are larger than maximum_tracer_diffusivity                               are clipped. Default: Inf.\nmaximum_tke_diffusivity: Maximum value for TKE diffusivity. CATKE-predicted diffusivities                            for TKE that are larger than maximum_tke_diffusivity are clipped.                            Default: Inf.\nmaximum_viscosity: Maximum value for momentum diffusivity. CATKE-predicted momentum diffusivities                      that are larger than maximum_viscosity are clipped. Default: Inf.\nminimum_tke: Minimum value for the turbulent kinetic energy. Can be used to model the presence                \"background\" TKE levels due to, for example, mixing by breaking internal waves.                Default: 1e-9.\nminimum_convective_buoyancy_flux Minimum value for the convective buoyancy flux. Default: 1e-11.\nnegative_tke_damping_time_scale: Damping time-scale for spurious negative values of TKE,                                    typically generated by oscillatory errors associated                                    with the TKE advection. Default: 1 minute.\n\nReferences\n\nWagner, G. L., Hillier, A., Constantinou, N. C., Silvestri, S., Souza, A., Burns, K., Hill,     C., Campin, J.-M., Marshall, J., and Ferrari, R. (2025). Formulation and calibration of CATKE,     a one-equation parameterization for microscale ocean mixing. J. Adv. Model. Earth Sy., 17, e2024MS004522.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.TKEBasedVerticalDiffusivities.TKEDissipationVerticalDiffusivity-Union{Tuple{}, Tuple{TD}, Tuple{TD, Any}} where TD","page":"Library","title":"Oceananigans.TurbulenceClosures.TKEBasedVerticalDiffusivities.TKEDissipationVerticalDiffusivity","text":"TKEDissipationVerticalDiffusivity([time_discretization = VerticallyImplicitTimeDiscretization(),\n                                  FT = Float64;]\n                                  tke_dissipation_equations = TKEDissipationEquations(),\n                                  stability_functions = VariableStabilityFunctions(),\n                                  minimum_length_scale = StratifiedDisplacementScale(),\n                                  maximum_tracer_diffusivity = Inf,\n                                  maximum_tke_diffusivity = Inf,\n                                  maximum_dissipation_diffusivity = Inf,\n                                  maximum_viscosity = Inf,\n                                  minimum_tke = 1e-6,\n                                  minimum_stratification_number_safety_factor = 0.73,\n                                  negative_tke_damping_time_scale = 1minute,\n                                  tke_dissipation_time_step = nothing)\n\nReturn the TKEDissipationVerticalDiffusivity turbulence closure for vertical mixing by microscale ocean turbulence based on the prognostic evolution of two variables: the turbulent kinetic energy (TKE), and the turbulent kinetic energy dissipation. Elsewhere this is referred to as \"k-Ïµ\". For more information about k-Ïµ, see Burchard and Bolding (2001), Umlauf and Burchard (2003), and Umlauf and Burchard (2005).\n\nArguments\n\ntime_discretization: Either ExplicitTimeDiscretization() or VerticallyImplicitTimeDiscretization();                        default VerticallyImplicitTimeDiscretization().\nFT: Float type; default Float64.\n\nKeyword arguments\n\nmaximum_diffusivity: Maximum value for tracer, momentum, and TKE diffusivities.                        Used to clip the diffusivity when/if                        TKEDissipationVerticalDiffusivity predicts diffusivities                        that are too large.                        Default: Inf.\nminimum_tke: Minimum value for the turbulent kinetic energy.                Can be used to model the presence \"background\" TKE                levels due to, for example, mixing by breaking internal waves.                Default: 1e-9.\nnegative_tke_damping_time_scale: Damping time-scale for spurious negative values of TKE,                                    typically generated by oscillatory errors associated                                    with TKE advection.                                    Default: 1 minute.\n\nNote that for numerical stability, it is recommended to either have a relative short negative_turbulent_kinetic_energy_damping_time_scale or a reasonable minimum_turbulent_kinetic_energy, or both.\n\nReferences\n\nBurchard, H., and Bolding, K. (2001). Comparative analysis of four second-moment turbulence closure     models for the oceanic mixed layer. Journal of Physical Oceanography, 31(8), 1943-1968.\n\nUmlauf, L., and H. Burchard. (2003). A generic length-scale equation for geophysical turbulence models.     Journal of Marine Research 61, (2). https://elischolar.library.yale.edu/journalofmarine_research/9\n\nUmlauf, L., and Burchard, H. (2005). Second-order turbulence closure models for geophysical boundary layers.     A review of recent work. Continental Shelf Research, 25(7-8), 795-827.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Utilities","page":"Library","title":"Utilities","text":"","category":"section"},{"location":"appendix/library/#Oceananigans.Utils.AndSchedule-Tuple","page":"Library","title":"Oceananigans.Utils.AndSchedule","text":"AndSchedule(schedules...)\n\nReturn a schedule that actuates when all child_schedules actuate.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Utils.IterationInterval-Tuple{Int64}","page":"Library","title":"Oceananigans.Utils.IterationInterval","text":"IterationInterval(interval; offset=0)\n\nReturn a callable IterationInterval that \"actuates\" (i.e., schedules output or callback execution) whenever the model iteration (modified by offset) is a multiple of interval.\n\nFor example,\n\nIterationInterval(100) actuates at iterations [100, 200, 300, ...].\nIterationInterval(100, offset=-1) actuates at iterations [99, 199, 299, ...].\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Utils.KernelParameters-Tuple{AbstractUnitRange}","page":"Library","title":"Oceananigans.Utils.KernelParameters","text":"KernelParameters(range1, [range2, range3])\n\nReturn parameters for launching a kernel of up to three dimensions, where the indices spanned by the kernel in each dimension are given by (range1, range2, range3).\n\nExample\n\nkp = KernelParameters(1:4, 0:10)\n\n# Launch a kernel with indices that range from i=1:4, j=0:10,\n# where i, j are the first and second index, respectively.\nlaunch!(arch, grid, kp, kernel!, kernel_args...)\n\nSee the documentation for launch!.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Utils.KernelParameters-Tuple{Any, Any}","page":"Library","title":"Oceananigans.Utils.KernelParameters","text":"KernelParameters(size, offsets)\n\nReturn parameters for kernel launching and execution that define (i) a tuple that defines the size of the kernel being launched and (ii) a tuple of offsets that offset loop indices. For example, offsets = (0, 0, 0) with size = (N, N, N) means all indices loop from 1:N. If offsets = (1, 1, 1), then all indices loop from 2:N+1. And so on.\n\nExample\n\nsize = (8, 6, 4)\noffsets = (0, 1, 2)\nkp = KernelParameters(size, offsets)\n\n# Launch a kernel with indices that range from i=1:8, j=2:7, k=3:6,\n# where i, j, k are the first, second, and third index, respectively:\n\nlaunch!(arch, grid, kp, kernel!, kernel_args...)\n\nSee launch!.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Utils.OrSchedule-Tuple","page":"Library","title":"Oceananigans.Utils.OrSchedule","text":"OrSchedule(schedules...)\n\nReturn a schedule that actuates when any of the child_schedules actuates.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Utils.SpecifiedTimes-Union{Tuple{Vararg{T}}, Tuple{T}} where T","page":"Library","title":"Oceananigans.Utils.SpecifiedTimes","text":"SpecifiedTimes(times)\n\nReturn a schedule::SpecifiedTimes that \"actuates\" (i.e., schedules output or callback execution) whenever the model's clock equals the specified values in times. For example,\n\nSpecifiedTimes([1, 15.3]) actuates when model.clock.time is 1 and 15.3.\n\ninfo: Sorting specified times\nThe specified times need not be ordered as the SpecifiedTimes constructor will check and order them in ascending order if needed.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Utils.TimeInterval-Tuple{Any}","page":"Library","title":"Oceananigans.Utils.TimeInterval","text":"TimeInterval(interval)\n\nReturn a callable TimeInterval that schedules periodic output or diagnostic evaluation on a interval of simulation time, as kept by model.clock.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Utils.WallTimeInterval-Tuple{Any}","page":"Library","title":"Oceananigans.Utils.WallTimeInterval","text":"WallTimeInterval(interval; start_time = time_ns() * 1e-9)\n\nReturn a callable WallTimeInterval that schedules periodic output or diagnostic evaluation on a interval of \"wall time\" while a simulation runs, in units of seconds.\n\nThe \"wall time\" is the actual real world time in seconds, as kept by an actual or hypothetical clock hanging on your wall.\n\nThe keyword argument start_time can be used to specify a starting wall time other than the moment WallTimeInterval is constructed.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Utils.configure_kernel-NTuple{4, Any}","page":"Library","title":"Oceananigans.Utils.configure_kernel","text":"configure_kernel(arch, grid, workspec, kernel!, [active_cells_map=nothing, exclude_periphery=nothing];\n                 reduced_dimensions = (),\n                 location = nothing)\n\nConfigure kernel! to launch over the dims of grid on the architecture arch.\n\nArguments\n\narch: The architecture on which the kernel will be launched.\ngrid: The grid on which the kernel will be executed.\nworkspec: The workspec that defines the work distribution.\nkernel!: The kernel function to be executed.\n\nKeyword Arguments\n\nreduced_dimensions: A tuple specifying the dimensions to be reduced in the work distribution. Default is an empty tuple.\nlocation: The location of the kernel execution, needed for include_right_boundaries. Default is nothing.\nactive_cells_map: A map indicating the active cells in the grid. If the map is not a nothing, the workspec will be disregarded and                     the kernel is configured as a linear kernel with a worksize equal to the length of the active cell map. Default is nothing.\nexclude_periphery: A boolean indicating whether to exclude the periphery, used only for interior kernels.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Utils.launch!-Tuple","page":"Library","title":"Oceananigans.Utils.launch!","text":"launch!(arch, grid, workspec, kernel!, kernel_args...; kw...)\n\nLaunches kernel! with arguments kernel_args over the dims of grid on the architecture arch. Kernels run on the default stream.\n\nSee configure_kernel for more information and also a list of the keyword arguments kw.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Utils.newton_div-Union{Tuple{FT}, Tuple{Any, Any, FT}} where FT","page":"Library","title":"Oceananigans.Utils.newton_div","text":"newton_div(inv_FT, a, b::FT)\n\nCompute an approximation of a / b that uses inv_FT type to compute 1/b, and then performs a single Newton iteration to add a few more bits of precision afterwards.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Utils.pretty_filesize","page":"Library","title":"Oceananigans.Utils.pretty_filesize","text":"pretty_filesize(s, suffix=\"B\")\n\nConvert a floating point value s representing a file size to a more human-friendly formatted string with one decimal places with a suffix defaulting to \"B\". Depending on the value of s the string will be formatted to show s using an SI prefix from bytes, kiB (1024 bytes), MiB (1024Â² bytes), and so on up to YiB (1024â¸ bytes).\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.Utils.prettytime","page":"Library","title":"Oceananigans.Utils.prettytime","text":"prettytime(t, longform=true)\n\nConvert a floating point value t representing an amount of time in SI units of seconds to a human-friendly string with three decimal places. Depending on the value of t the string will be formatted to show t in nanoseconds (ns), microseconds (Î¼s), milliseconds (ms), seconds, minutes, hours, or days.\n\nWith longform=false, we use s, m, hrs, and d in place of seconds, minutes, and hours.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.Utils.with_tracers-Tuple{Any, NamedTuple, Any}","page":"Library","title":"Oceananigans.Utils.with_tracers","text":"with_tracers(tracer_names, initial_tuple, tracer_default)\n\nCreate a tuple corresponding to the solution variables u, v, w, and tracer_names. initial_tuple is a NamedTuple that at least has fields u, v, and w, and may have some fields corresponding to the names in tracer_names. tracer_default is a function that produces a default tuple value for each tracer if not included in initial_tuple.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Utils.@apply_regionally-Tuple{Any}","page":"Library","title":"Oceananigans.Utils.@apply_regionally","text":"@apply_regionally expr\n\nDistributes locally the function calls in expression\n\nWhen the function call in expr does not return anything, then apply_regionally! method is used. When the function in expr returns something, the construct_regionally method is used.\n\n\n\n\n\n","category":"macro"},{"location":"appendix/library/#Units","page":"Library","title":"Units","text":"","category":"section"},{"location":"appendix/library/#Oceananigans.Units.GiB","page":"Library","title":"Oceananigans.Units.GiB","text":"GiB\n\nA Float64 constant equal to 1024MiB. Useful for increasing the clarity of scripts, e.g. max_filesize = 50GiB.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.KiB","page":"Library","title":"Oceananigans.Units.KiB","text":"KiB\n\nA Float64 constant equal to 1024.0. Useful for increasing the clarity of scripts, e.g. max_filesize = 250KiB.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.MiB","page":"Library","title":"Oceananigans.Units.MiB","text":"MiB\n\nA Float64 constant equal to 1024KiB. Useful for increasing the clarity of scripts, e.g. max_filesize = 100MiB.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.TiB","page":"Library","title":"Oceananigans.Units.TiB","text":"TiB\n\nA Float64 constant equal to 1024GiB. Useful for increasing the clarity of scripts, e.g. max_filesize = 2TiB.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.day","page":"Library","title":"Oceananigans.Units.day","text":"day\n\nA Float64 constant equal to 24hours. Useful for increasing the clarity of scripts, e.g. stop_time = 1day.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.days","page":"Library","title":"Oceananigans.Units.days","text":"days\n\nA Float64 constant equal to 24hours. Useful for increasing the clarity of scripts, e.g. stop_time = 7days.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.hour","page":"Library","title":"Oceananigans.Units.hour","text":"hour\n\nA Float64 constant equal to 60minutes. Useful for increasing the clarity of scripts, e.g. Î”t = 1hour.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.hours","page":"Library","title":"Oceananigans.Units.hours","text":"hours\n\nA Float64 constant equal to 60minutes. Useful for increasing the clarity of scripts, e.g. Î”t = 3hours.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.kilometer","page":"Library","title":"Oceananigans.Units.kilometer","text":"kilometer\n\nA Float64 constant equal to 1000meters. Useful for increasing the clarity of scripts, e.g. Lx = 1kilometer.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.kilometers","page":"Library","title":"Oceananigans.Units.kilometers","text":"kilometers\n\nA Float64 constant equal to 1000meters. Useful for increasing the clarity of scripts, e.g. Lx = 5000kilometers.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.meter","page":"Library","title":"Oceananigans.Units.meter","text":"meter\n\nA Float64 constant equal to 1.0. Useful for increasing the clarity of scripts, e.g. Lx = 1meter.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.meters","page":"Library","title":"Oceananigans.Units.meters","text":"meters\n\nA Float64 constant equal to 1.0. Useful for increasing the clarity of scripts, e.g. Lx = 50meters.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.minute","page":"Library","title":"Oceananigans.Units.minute","text":"minute\n\nA Float64 constant equal to 60seconds. Useful for increasing the clarity of scripts, e.g. Î”t = 1minute.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.minutes","page":"Library","title":"Oceananigans.Units.minutes","text":"minutes\n\nA Float64 constant equal to 60seconds. Useful for increasing the clarity of scripts, e.g. Î”t = 15minutes.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.second","page":"Library","title":"Oceananigans.Units.second","text":"second\n\nA Float64 constant equal to 1.0. Useful for increasing the clarity of scripts, e.g. Î”t = 1second.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.seconds","page":"Library","title":"Oceananigans.Units.seconds","text":"seconds\n\nA Float64 constant equal to 1.0. Useful for increasing the clarity of scripts, e.g. Î”t = 7seconds.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.Time","page":"Library","title":"Oceananigans.Units.Time","text":"Time(t)\n\nReturn a time \"selector\" at the continuous time t for linearly interpolating FieldTimeSeries.\n\nExamples\n\n# Interpolate `field_time_series` to `t=0.1`, returning `interpolated::Field`\ninterpolated = field_time_series[Time(0.1)]\n\n# Interpolate `field_time_series` at `i, j, k` and `t=0.1`\ninterpolated_ijk = field_time_series[i, j, k, Time(0.1)]\n\n\n\n\n\n","category":"type"},{"location":"numerical_implementation/time_stepping/#time_stepping","page":"Time stepping","title":"Time-stepping and the fractional step method","text":"","category":"section"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"With the pressure decomposition as discussed, the momentum evolves via:","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"    beginequation\n    labeleqmomentum-time-derivative\n    partial_t boldsymbolv = boldsymbolG_boldsymbolv - boldsymbolnabla p_rmnon  \n    endequation","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"where, e.g., for the non-hydrostatic model (ignoring background velocities and surface-wave effects)","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"boldsymbolG_boldsymbolv equiv - boldsymbolnabla_h p_rmhyd\n                       - left ( boldsymbolv boldsymbolcdot boldsymbolnabla right ) boldsymbolv\n                       - boldsymbolf times boldsymbolv\n                       + boldsymbolnabla boldsymbolcdot boldsymboltau\n                       + boldsymbolF_boldsymbolv","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"collects all terms on the right side of the momentum equation \\eqref{eq:momentum-time-derivative}, except the contribution of non-hydrostatic pressure boldsymbolnabla p_rmnon.","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"The time-integral of the momentum equation \\eqref{eq:momentum-time-derivative} from time step n at t = t_n to time step n+1 at t_n+1 is:","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"    beginequation\n    labeleqmomentum-time-integral\n    boldsymbolv^n+1 - boldsymbolv^n =\n        int_t_n^t_n+1 Big  - boldsymbolnabla p_rmnon + boldsymbolG_boldsymbolv Big   mathrmd t  \n    endequation","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"where the superscript n and n+1 imply evaluation at t_n and t_n+1, such that boldsymbolv^n equiv boldsymbolv(t=t_n). The crux of the fractional step method is to treat the pressure term boldsymbolnabla p_rmnon implicitly using the approximation","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"    beginalign\n    labeleqpnon_implicit\n    int_t_n^t_n+1 boldsymbolnabla p_rmnon  mathrmd t approx\n        Delta t boldsymbolnabla p_rmnon^n+1  \n    endalign","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"while treating the rest of the terms on the right hand side of \\eqref{eq:momentum-time-integral} explicitly. The implicit treatment of pressure ensures that the velocity field obtained at time step n+1 is divergence-free.","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"To effect such a fractional step method, we define an intermediate velocity field boldsymbolv^star such that","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"    beginequation\n    labeleqintermediate-velocity-field\n    boldsymbolv^star - boldsymbolv^n = int_t_n^t_n+1 boldsymbolG_boldsymbolv  mathrmd t  \n    endequation","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"The integral on the right of the equation for boldsymbolv^star may be approximated by a variety of explicit methods. For example, a forward Euler method approximates the integral via","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"    beginequation\n    int_t_n^t_n+1 G  mathrmd t approx Delta t G^n  \n    labeleqforward-euler\n    endequation","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"for any time-dependent function G(t), while a second-order Adams-Bashforth method uses the approximation","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"    beginequation\n    labeleqadams-bashforth\n    int_t_n^t_n+1 G  mathrmd t approx\n        Delta t left  left ( tfrac32 + chi right ) G^n\n        - left ( tfrac12 + chi right ) G^n-1 right   \n    endequation","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"where chi is a parameter. Ascher et al. (1995) claim that chi = tfrac18 is optimal; chi = -tfrac12 yields the forward Euler scheme.","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"Combining the equation \\eqref{eq:intermediate-velocity-field} for boldsymbolv^star and the time integral of the non-hydrostatic pressure \\eqref{eq:pnon_implicit} yields","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"    beginequation\n    labeleqfractional-step\n    boldsymbolv^n+1 - boldsymbolv^star = - Delta t boldsymbolnabla p_rmnon^n+1  \n    endequation","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"Taking the divergence of fractional step equation \\eqref{eq:fractional-step} and requiring that boldsymbolnabla boldsymbolcdot boldsymbolv^n+1 = 0 yields a Poisson equation for the kinematic pressure p_rmnon at time-step n+1:","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"    beginequation\n    labeleqpressure-poisson\n    nabla^2 p_rmnon^n+1 = fracboldsymbolnabla boldsymbolcdot boldsymbolv^starDelta t  \n    endequation","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"With boldsymbolv^star in hand we can invert \\eqref{eq:pressure-poisson} to get p_rmnon^n+1 and then boldsymbolv^n+1 is computed via the fractional step equation \\eqref{eq:fractional-step}.","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"Tracers are stepped forward explicitly via","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"    beginequation\n    labeleqtracer-timestep\n    c^n+1 - c^n = int_t_n^t_n+1 G_c  mathrmd t  \n    endequation","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"where","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"    beginequation\n    G_c equiv - boldsymbolnabla boldsymbolcdot left ( boldsymbolv c right ) - boldsymbolnabla boldsymbolcdot boldsymbolq_c + F_c  \n    endequation","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"and the same forward Euler or Adams-Bashforth scheme as for the explicit evaluation of the time-integral of boldsymbolG_u is used to evaluate the integral of G_c.","category":"page"},{"location":"numerical_implementation/turbulence_closures/#numerical_closures","page":"Turbulence closures","title":"Turbulence closures","text":"","category":"section"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"To truly simulate and resolve turbulence at high Reynolds number (so basically all interesting flows) would require you resolve all motions down to the Kolmogorov (1941) length scale eta = (nu^3  varepsilon)^14 where nu is the kinematic viscosity and varepsilon the average rate of dissipation of turbulence kinetic energy per unit mass.","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"As pointed out way back by Corrsin (1961), to run a simulation on a horizontal domain about 10 times the size of an \"average eddy\" with 100 vertical levels and where the grid spacing is given by eta would require the computer to store on the order of 10^14 variables.[1] This is still impractical today, although may be within reach in less than a decade. He ends by suggesting the use of an analog rather digital computerâ€“-a tank of water.","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"[1]: And even then, eta gives the maximum allowable grid spacing. There is significant flow structure smaller than eta.","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"To have any hope of simulating high Reynolds number flows we need some way of resolving the sub-grid scale motions.[2]","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"[2]: In reality there is no need to resolve all motions down to the Kolmogorov length scale to achieve acceptable accuracy. Perhaps good results can be achieved if 80\\% of the kinetic energy is resolved (Â§13) (Pope, 2000).","category":"page"},{"location":"numerical_implementation/turbulence_closures/#Reynolds-averaged-Navierâ€“Stokes-equations","page":"Turbulence closures","title":"Reynolds-averaged Navierâ€“Stokes equations","text":"","category":"section"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"Following Reynolds (1895), we can decompose flow variables such as velocity boldsymbolv into the mean component overlineboldsymbolv and the fluctuating component boldsymbolv^prime so that boldsymbolv = overlineboldsymbolv + boldsymbolv^prime [see Â§4 of Pope (2000) for a modern discussion].","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"Expressing the Navier-Stokes equations in tensor notation","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"beginalign\n    partial_i v_i = 0   \n    partial_t v_i + v_j partial_j v_i = f_i - alphapartial_i p + nu partial_j partial_j v_i  \nendalign","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"where alpha = rho^-1 is the specific volume and f_i represents external forces. We can plug in the Reynolds decomposition for boldsymbolv and after some manipulation arrive at the following form for the Reynolds-averaged Navier-Stokes equations","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"beginalign\n    partial_i overlineu_i = 0   \n    partial_t overlineu_i + overlineu_j partial_j overlineu_i = overlinef_i -\n    partial_j left(-alphaoverlinepdelta_ij + 2nu overlineS_ij - overlinev_i^prime v_j^primeright)  \nendalign","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"where","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"overlineS_ij = frac12 ( partial_j overlineu_i + partial_i overlineu_j )  ","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"is the mean rate of strain tensor.","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"Thanks to the non-linearity of the Navier-Stokes equations, even when averaged we are left with pesky fluctuation terms which form the components of the Reynolds stress tensor","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"tau_ij = rho overlinev_i^prime v_j^prime  ","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"Attempting to close the equations leads to the closure problem: the time evolution of the Reynolds stresses depends on  triple covariances overlinev_i^prime v_j^prime v_k^prime and covariances with pressure, which depend on quadruple covariances and so on (Chou, 1945).","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"This is kind of hopeless so we will have to find some way to model the Reynolds stresses.","category":"page"},{"location":"numerical_implementation/turbulence_closures/#Gradient-diffusion-hypothesis-and-eddy-viscosity-models","page":"Turbulence closures","title":"Gradient-diffusion hypothesis and eddy viscosity models","text":"","category":"section"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"The gradient-diffusion hypothesis, due to Boussinesq (1877), assumes that the transport of scalar fluxes such as overlineboldsymbolv^prime c^prime and overlinev_i^prime v_j^prime occurs down the mean scalar gradient boldsymbolnabla overlinec as if they are being diffused (Â§4.4) (Pope, 2000). This is in analogy with how momentum transfer by molecular motion in a gas can be described by a molecular viscosity.","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"Taking this assumption we can express the Reynolds stresses and turbulent tracer fluxes in terms of the mean variables and close the equations","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"overlineboldsymbolv^prime c^prime = -kappa_e boldsymbolnabla overlinec\nquad textand quad\noverlinev_i^prime v_j^prime = -2nu_e overlineS_ij  ","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"where nu_e = nu_e(boldsymbolx t) is the turbulent or eddy viscosity and kappa_e = kappa_e(boldsymbolx t) is the eddy diffusivity.","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"The effective diffusivity ends up being the sum of the molecular and eddy diffusivities. So just by using an elevated value for the viscosity and diffusivity, you are already using an eddy viscosity model.","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"The eddy viscosity model is simple and for that reason is very popular. It can work well even with a constant eddy diffusivity. However, it does assume that the flux is aligned down gradient, which is not true even in simple turbulent flows as the physics of turbulence is quite different from that of colliding molecules leading to the viscous stress law (Â§4.4,10.1) (Pope, 2000). So we might want something a little bit more sophisticated.","category":"page"},{"location":"model_setup/output_writers/#Output-writers","page":"Output writers","title":"Output writers","text":"","category":"section"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"AbstractOutputWriters save data to disk. Oceananigans provides three ways to write output:","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"NetCDFWriter for output of arrays and scalars that uses NCDatasets.jl\nJLD2Writer for arbitrary julia data structures that uses JLD2.jl\nCheckpointer that automatically saves as much model data as possible, using JLD2.jl","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"The Checkpointer is discussed in detail on a separate section of the documentation.","category":"page"},{"location":"model_setup/output_writers/#Basic-usage","page":"Output writers","title":"Basic usage","text":"","category":"section"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"NetCDFWriter and JLD2Writer require four inputs:","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"The model from which output data is sourced (required to initialize the OutputWriter).\nA key-value pairing of output \"names\" and \"output\" objects. JLD2Writer accepts NamedTuples and Dicts; NetCDFWriter accepts Dicts with string-valued keys. Output objects are either AbstractFields or functions that return data when called via func(model).\nA schedule on which output is written. TimeInterval, IterationInterval, WallTimeInterval schedule periodic output according to the simulation time, simulation interval, or \"wall time\" (the physical time according to a clock on your wall). A fourth schedule called AveragedTimeInterval specifies periodic output that is time-averaged over a window prior to being written.\nThe filename and directory.","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"Other important keyword arguments are","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"indices for outputting subregions, two- and one-dimensional slices of fields. Specifies the indices to write to disk with a Tuple of Colon, UnitRange,or Int elements. For example, indices = (:, :, 1) implies outputing x-y-slices of the bottom-most index (k=1). Defaults to (:, :, :), i.e., \"all indices\".\nwith_halos :: Boolean: whether to output the halos (true) or only the interior points (false; default).\narray_type for specifying the type of the array that holds outputted field data. The default is Array{Float64}, or arrays of single-precision floating point numbers.","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"Once an OutputWriter is created, it can be used to write output by adding it the ordered dictionary simulation.output_writers. prior to calling run!(simulation).","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"More specific detail about the NetCDFWriter and JLD2Writer is given below.","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"tip: Time step alignment and output writing\nOceananigans simulations will shorten the time step as needed to align model output with each output writer's schedule.","category":"page"},{"location":"model_setup/output_writers/#NetCDF-output-writer","page":"Output writers","title":"NetCDF output writer","text":"","category":"section"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"Model data can be saved to NetCDF files along with associated metadata. The NetCDF output writer is generally used by passing it a dictionary of (label, field) pairs and any indices for slicing if you don't want to save the full 3D field.","category":"page"},{"location":"model_setup/output_writers/#Examples","page":"Output writers","title":"Examples","text":"","category":"section"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"Saving the u velocity field and temperature fields as full 3D fields, surface 2D slices, and 1D columns to separate NetCDF files:","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"using Oceananigans\nusing NCDatasets\n\ngrid = RectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1))\n\nmodel = NonhydrostaticModel(grid=grid, tracers=:c)\n\nsimulation = Simulation(model, Î”t=12, stop_time=3600)\n\nfields = Dict(\"u\" => model.velocities.u, \"c\" => model.tracers.c)\n\nsimulation.output_writers[:field_writer] =\n    NetCDFWriter(model, fields, filename=\"more_fields.nc\", schedule=TimeInterval(60))","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"simulation.output_writers[:surface_slice_writer] =\n    NetCDFWriter(model, fields, filename=\"another_surface_xy_slice.nc\",\n                 schedule=TimeInterval(60), indices=(:, :, grid.Nz))","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"simulation.output_writers[:averaged_profile_writer] =\n    NetCDFWriter(model, fields,\n                 filename = \"another_averaged_z_profile.nc\",\n                 schedule = AveragedTimeInterval(60, window=20),\n                 indices = (1, 1, :))","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"NetCDFWriter also accepts output functions that write scalars and arrays to disk, provided that their dimensions are provided:","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"using Oceananigans\nusing NCDatasets\n\nNx, Ny, Nz = 16, 16, 16\n\ngrid = RectilinearGrid(size=(Nx, Ny, Nz), extent=(1, 2, 3))\n\nmodel = NonhydrostaticModel(grid=grid)\n\nsimulation = Simulation(model, Î”t=1.25, stop_iteration=3)\n\nf(model) = model.clock.time^2; # scalar output\n\ng(model) = model.clock.time .* exp.(znodes(grid, Center())) # single-column profile output (vector)\n\nxC, yF = xnodes(grid, Center()), ynodes(grid, Face())\n\nXC = [xC[i] for i in 1:Nx, j in 1:Ny]\nYF = [yF[j] for i in 1:Nx, j in 1:Ny]\n\nh(model) = @. model.clock.time * sin(XC) * cos(YF) # x-y slice output (2D array)\n\noutputs = Dict(\"scalar\" => f, \"profile\" => g, \"slice\" => h)\n\ndims = Dict(\"scalar\" => (), \"profile\" => (\"z_aac\",), \"slice\" => (\"x_caa\", \"y_aca\"))\n\noutput_attributes = Dict(\n    \"scalar\"  => Dict(\"longname\" => \"Some scalar\", \"units\" => \"bananas\"),\n    \"profile\" => Dict(\"longname\" => \"Some vertical profile\", \"units\" => \"watermelons\"),\n    \"slice\"   => Dict(\"longname\" => \"Some slice\", \"units\" => \"mushrooms\"))\n\nglobal_attributes = Dict(\"location\" => \"Bay of Fundy\", \"onions\" => 7)\n\nsimulation.output_writers[:things] =\n    NetCDFWriter(model, outputs,\n                 schedule=IterationInterval(1), filename=\"things.nc\", dimensions=dims, verbose=true,\n                 global_attributes=global_attributes, output_attributes=output_attributes)","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"NetCDFWriter can also be configured for outputs that are interpolated or regridded to a different grid than model.grid. To use this functionality, include the keyword argument grid = output_grid.","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"using Oceananigans\nusing Oceananigans.Fields: interpolate!\nusing NCDatasets\n\ngrid = RectilinearGrid(size=(1, 1, 8), extent=(1, 1, 1));\nmodel = NonhydrostaticModel(; grid)\n\ncoarse_grid = RectilinearGrid(size=(grid.Nx, grid.Ny, grid.NzÃ·2), extent=(grid.Lx, grid.Ly, grid.Lz))\ncoarse_u = Field{Face, Center, Center}(coarse_grid)\n\ninterpolate_u(model) = interpolate!(coarse_u, model.velocities.u)\noutputs = (; u = interpolate_u)\n\noutput_writer = NetCDFWriter(model, outputs;\n                             grid = coarse_grid,\n                             filename = \"coarse_u.nc\",\n                             schedule = IterationInterval(1))","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"See NetCDFWriter for more information.","category":"page"},{"location":"model_setup/output_writers/#JLD2-output-writer","page":"Output writers","title":"JLD2 output writer","text":"","category":"section"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"JLD2 is a fast HDF5 compatible file format written in pure Julia. JLD2 files can be opened in Julia with the JLD2.jl package and in Python with the h5py package.","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"The JLD2Writer receives either a Dictionary or NamedTuple containing name, output pairs. The name can be a symbol or string. The output must either be an AbstractField or a function called with func(model) that returns arbitrary output. Whenever output needs to be written, the functions will be called and the output of the function will be saved to the JLD2 file.","category":"page"},{"location":"model_setup/output_writers/#Examples-2","page":"Output writers","title":"Examples","text":"","category":"section"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"Write out 3D fields for u, v, w, and a tracer c, along with a horizontal average:","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"using Oceananigans\nusing Oceananigans.Utils: hour, minute\n\nmodel = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)), tracers=(:c,))\nsimulation = Simulation(model, Î”t=12, stop_time=1hour)\n\nfunction init_save_some_metadata!(file, model)\n    file[\"author\"] = \"Chim Riggles\"\n    file[\"parameters/coriolis_parameter\"] = 1e-4\n    file[\"parameters/density\"] = 1027\n    return nothing\nend\n\nc_avg = Field(Average(model.tracers.c, dims=(1, 2)))\n\n# Note that model.velocities is NamedTuple\nsimulation.output_writers[:velocities] = JLD2Writer(model, model.velocities,\n                                                    filename = \"some_more_data.jld2\",\n                                                    schedule = TimeInterval(20minute),\n                                                    init = init_save_some_metadata!)","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"and a time- and horizontal-average of tracer c every 20 minutes of simulation time to a file called some_more_averaged_data.jld2","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"simulation.output_writers[:avg_c] = JLD2Writer(model, (; c=c_avg),\n                                               filename = \"some_more_averaged_data.jld2\",\n                                               schedule = AveragedTimeInterval(20minute, window=5minute))","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"See JLD2Writer for more information.","category":"page"},{"location":"model_setup/output_writers/#Time-averaged-output","page":"Output writers","title":"Time-averaged output","text":"","category":"section"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"Time-averaged output is specified by setting the schedule keyword argument for either NetCDFWriter or JLD2Writer to AveragedTimeInterval.","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"With AveragedTimeInterval, the time-average of a is taken as a left Riemann sum corresponding to","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"langle a rangle = frac1T int_t_i-T^t_i a  mathrmd t  ","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"where langle a rangle is the time-average of a, T is the time-window for averaging specified by the window keyword argument to AveragedTimeInterval, and the t_i are discrete times separated by the time interval. The t_i specify both the end of the averaging window and the time at which output is written.","category":"page"},{"location":"model_setup/output_writers/#Example","page":"Output writers","title":"Example","text":"","category":"section"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"Building an AveragedTimeInterval that averages over a 1 day window, every 4 days,","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"using Oceananigans\nusing Oceananigans.Units\n\nschedule = AveragedTimeInterval(4days, window=1day)\n\n# output\nAveragedTimeInterval(window=1 day, stride=1, interval=4 days)","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"An AveragedTimeInterval schedule directs an output writer to time-average its outputs before writing them to disk:","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"using Oceananigans\nusing Oceananigans.Units\n\nmodel = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)))\n\nsimulation = Simulation(model, Î”t=10minutes, stop_time=30days)\n\nsimulation.output_writers[:velocities] = JLD2Writer(model, model.velocities,\n                                                    filename = \"even_more_averaged_velocity_data.jld2\",\n                                                    schedule = AveragedTimeInterval(4days, window=1day, stride=2))","category":"page"},{"location":"literated/horizontal_convection/#Horizontal-convection-example","page":"Horizontal convection","title":"Horizontal convection example","text":"","category":"section"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"In \"horizontal convection\", a non-uniform buoyancy is imposed on top of an initially resting fluid.","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"This example demonstrates:","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"How to use computed Fields for output.\nHow to post-process saved output using FieldTimeSeries.","category":"page"},{"location":"literated/horizontal_convection/#Install-dependencies","page":"Horizontal convection","title":"Install dependencies","text":"","category":"section"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"using Pkg\npkg\"add Oceananigans, CairoMakie\"","category":"page"},{"location":"literated/horizontal_convection/#Horizontal-convection","page":"Horizontal convection","title":"Horizontal convection","text":"","category":"section"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"We consider two-dimensional horizontal convection of an incompressible flow boldsymbolu = (u w) on the (x z)-plane (-L_x2 le x le L_x2 and -H le z le 0). The flow evolves under the effect of gravity. The only forcing on the fluid comes from a prescribed, non-uniform buoyancy at the top-surface of the domain.","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"We start by importing Oceananigans and Printf.","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"using Oceananigans\nusing Printf","category":"page"},{"location":"literated/horizontal_convection/#The-grid","page":"Horizontal convection","title":"The grid","text":"","category":"section"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"H = 1            # vertical domain extent\nLx = 2H          # horizontal domain extent\nNx, Nz = 128, 64 # horizontal, vertical resolution\n\ngrid = RectilinearGrid(size = (Nx, Nz),\n                       x = (-Lx/2, Lx/2),\n                       z = (-H, 0),\n                       topology = (Bounded, Flat, Bounded))","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"128Ã—1Ã—64 RectilinearGrid{Float64, Bounded, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo\nâ”œâ”€â”€ Bounded  x âˆˆ [-1.0, 1.0] regularly spaced with Î”x=0.015625\nâ”œâ”€â”€ Flat y                   \nâ””â”€â”€ Bounded  z âˆˆ [-1.0, 0.0] regularly spaced with Î”z=0.015625","category":"page"},{"location":"literated/horizontal_convection/#Boundary-conditions","page":"Horizontal convection","title":"Boundary conditions","text":"","category":"section"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"At the surface, the imposed buoyancy is","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"b(x z = 0 t) = - b_* cos (2 pi x  L_x)  ","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"while zero-flux boundary conditions are imposed on all other boundaries. We use free-slip boundary conditions on u and w everywhere.","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"bâ˜… = 1\n@inline bË¢(x, t, p) = - p.bâ˜… * cos(2Ï€ * x / p.Lx)\n\nb_bcs = FieldBoundaryConditions(top = ValueBoundaryCondition(bË¢, parameters=(; bâ˜…, Lx)))","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"Oceananigans.FieldBoundaryConditions, with boundary conditions\nâ”œâ”€â”€ west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ bottom: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ top: ValueBoundaryCondition: ContinuousBoundaryFunction bË¢ at (Nothing, Nothing, Nothing)\nâ””â”€â”€ immersed: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)","category":"page"},{"location":"literated/horizontal_convection/#Non-dimensional-control-parameters-and-Turbulence-closure","page":"Horizontal convection","title":"Non-dimensional control parameters and Turbulence closure","text":"","category":"section"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"The problem is characterized by three non-dimensional parameters. The first is the domain's aspect ratio, L_x  H and the other two are the Rayleigh (Ra) and Prandtl (Pr) numbers:","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"Ra = fracb_* L_x^3nu kappa   quad textand quad Pr = fracnukappa  ","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"The Prandtl number expresses the ratio of momentum over heat diffusion; the Rayleigh number is a measure of the relative importance of gravity over viscosity in the momentum equation.","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"For a domain with a given extent, the nondimensional values of Ra and Pr uniquely determine the viscosity and diffusivity, i.e.,","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"nu = sqrtfracPr b_* L_x^3Ra quad textand quad kappa = sqrtfracb_* L_x^3Pr Ra  ","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"We use isotropic viscosity and diffusivities, Î½ and Îº whose values are obtain from the prescribed Ra and Pr numbers. Here, we use Pr = 1 and Ra = 10^8:","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"Pr = 1      # Prandtl number\nRa = 1e8    # Rayleigh number\n\nÎ½ = sqrt(Pr * bâ˜… * Lx^3 / Ra)  # Laplacian viscosity\nÎº = Î½ / Pr                     # Laplacian diffusivity","category":"page"},{"location":"literated/horizontal_convection/#Model-instantiation","page":"Horizontal convection","title":"Model instantiation","text":"","category":"section"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"We instantiate the model with the fifth-order WENO advection scheme, a 3rd order Runge-Kutta time-stepping scheme, and a BuoyancyTracer.","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"model = NonhydrostaticModel(; grid,\n                            advection = WENO(),\n                            timestepper = :RungeKutta3,\n                            tracers = :b,\n                            buoyancy = BuoyancyTracer(),\n                            closure = ScalarDiffusivity(; Î½, Îº),\n                            boundary_conditions = (; b=b_bcs))","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 128Ã—1Ã—64 RectilinearGrid{Float64, Bounded, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo\nâ”œâ”€â”€ timestepper: RungeKutta3TimeStepper\nâ”œâ”€â”€ advection scheme: WENO{3, Float64, Float32}(order=5)\nâ”œâ”€â”€ tracers: b\nâ”œâ”€â”€ closure: ScalarDiffusivity{ExplicitTimeDiscretization}(Î½=0.000282843, Îº=(b=0.000282843,))\nâ”œâ”€â”€ buoyancy: BuoyancyTracer with gÌ‚ = NegativeZDirection()\nâ””â”€â”€ coriolis: Nothing","category":"page"},{"location":"literated/horizontal_convection/#Simulation-set-up","page":"Horizontal convection","title":"Simulation set-up","text":"","category":"section"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"We set up a simulation that runs up to t = 40 with a JLD2Writer that saves the flow speed, sqrtu^2 + w^2, the buoyancy, b, and the vorticity, partial_z u - partial_x w.","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"simulation = Simulation(model, Î”t=1e-2, stop_time=40.0)","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"Simulation of NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ Next time step: 10 ms\nâ”œâ”€â”€ Elapsed wall time: 0 seconds\nâ”œâ”€â”€ Wall time per iteration: NaN days\nâ”œâ”€â”€ Stop time: 40 seconds\nâ”œâ”€â”€ Stop iteration: Inf\nâ”œâ”€â”€ Wall time limit: Inf\nâ”œâ”€â”€ Minimum relative step: 0.0\nâ”œâ”€â”€ Callbacks: OrderedDict with 4 entries:\nâ”‚   â”œâ”€â”€ stop_time_exceeded => 4\nâ”‚   â”œâ”€â”€ stop_iteration_exceeded => -\nâ”‚   â”œâ”€â”€ wall_time_limit_exceeded => e\nâ”‚   â””â”€â”€ nan_checker => }\nâ”œâ”€â”€ Output writers: OrderedDict with no entries\nâ””â”€â”€ Diagnostics: OrderedDict with no entries","category":"page"},{"location":"literated/horizontal_convection/#The-TimeStepWizard","page":"Horizontal convection","title":"The TimeStepWizard","text":"","category":"section"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"The TimeStepWizard manages the time-step adaptively, keeping the Courant-Freidrichs-Lewy (CFL) number close to 0.7.","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"conjure_time_step_wizard!(simulation, IterationInterval(50), cfl=0.7, max_Î”t=1e-1)","category":"page"},{"location":"literated/horizontal_convection/#A-progress-messenger","page":"Horizontal convection","title":"A progress messenger","text":"","category":"section"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"We write a function that prints out a helpful progress message while the simulation runs.","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"progress(sim) = @printf(\"Iter: % 6d, sim time: % 1.3f, wall time: % 10s, Î”t: % 1.4f, advective CFL: %.2e, diffusive CFL: %.2e\\n\",\n                        iteration(sim), time(sim), prettytime(sim.run_wall_time),\n                        sim.Î”t, AdvectiveCFL(sim.Î”t)(sim.model), DiffusiveCFL(sim.Î”t)(sim.model))\n\nsimulation.callbacks[:progress] = Callback(progress, IterationInterval(50))","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"Callback of progress on IterationInterval(50)","category":"page"},{"location":"literated/horizontal_convection/#Output","page":"Horizontal convection","title":"Output","text":"","category":"section"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"We use computed Fields to diagnose and output the total flow speed, the vorticity, zeta, and the buoyancy, b. Note that computed Fields take \"AbstractOperations\" on Fields as input:","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"u, v, w = model.velocities # unpack velocity `Field`s\nb = model.tracers.b        # unpack buoyancy `Field`\n\n# total flow speed\ns = @at (Center, Center, Center) sqrt(u^2 + w^2)\n\n# y-component of vorticity\nÎ¶ = âˆ‚z(u) - âˆ‚x(w)","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"We create a JLD2Writer that saves the speed, and the vorticity. Because we want to post-process buoyancy and compute the buoyancy variance dissipation (which is proportional to boldsymbolnabla b^2) we use the with_halos = true. This way, the halos for the fields are saved and thus when we load them as fields they will come with the proper boundary conditions.","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"We then add the JLD2Writer to the simulation.","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"saved_output_filename = \"horizontal_convection.jld2\"\n\nsimulation.output_writers[:fields] = JLD2Writer(model, (; s, b, Î¶),\n                                                schedule = TimeInterval(0.5),\n                                                filename = saved_output_filename,\n                                                with_halos = true,\n                                                      overwrite_existing = true)","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"Ready to press the big red button:","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"run!(simulation)","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"[ Info: Initializing simulation...\nIter:      0, sim time:  0.000, wall time:  0 seconds, Î”t:  0.0110, advective CFL: 0.00e+00, diffusive CFL: 1.27e-02\n[ Info:     ... simulation initialization complete (7.577 seconds)\n[ Info: Executing initial time step...\n[ Info:     ... initial time step complete (7.810 seconds).\nIter:     50, sim time:  0.544, wall time: 16.284 seconds, Î”t:  0.0121, advective CFL: 4.38e-03, diffusive CFL: 1.40e-02\nIter:    100, sim time:  1.145, wall time: 16.848 seconds, Î”t:  0.0133, advective CFL: 1.66e-02, diffusive CFL: 1.54e-02\nIter:    150, sim time:  1.806, wall time: 17.415 seconds, Î”t:  0.0146, advective CFL: 3.74e-02, diffusive CFL: 1.70e-02\nIter:    200, sim time:  2.500, wall time: 17.944 seconds, Î”t:  0.0161, advective CFL: 6.80e-02, diffusive CFL: 1.87e-02\nIter:    250, sim time:  3.290, wall time: 18.446 seconds, Î”t:  0.0177, advective CFL: 1.16e-01, diffusive CFL: 2.05e-02\nIter:    300, sim time:  4.159, wall time: 18.965 seconds, Î”t:  0.0195, advective CFL: 2.06e-01, diffusive CFL: 2.26e-02\nIter:    350, sim time:  5.117, wall time: 19.481 seconds, Î”t:  0.0214, advective CFL: 5.91e-01, diffusive CFL: 2.48e-02\nIter:    400, sim time:  6.171, wall time: 20.011 seconds, Î”t:  0.0164, advective CFL: 7.00e-01, diffusive CFL: 1.90e-02\nIter:    450, sim time:  6.976, wall time: 20.523 seconds, Î”t:  0.0159, advective CFL: 7.00e-01, diffusive CFL: 1.84e-02\nIter:    500, sim time:  7.755, wall time: 21.015 seconds, Î”t:  0.0155, advective CFL: 7.00e-01, diffusive CFL: 1.80e-02\nIter:    550, sim time:  8.516, wall time: 21.497 seconds, Î”t:  0.0153, advective CFL: 7.00e-01, diffusive CFL: 1.77e-02\nIter:    600, sim time:  9.275, wall time: 22.041 seconds, Î”t:  0.0165, advective CFL: 7.00e-01, diffusive CFL: 1.91e-02\nIter:    650, sim time:  10.082, wall time: 22.520 seconds, Î”t:  0.0155, advective CFL: 7.00e-01, diffusive CFL: 1.80e-02\nIter:    700, sim time:  10.857, wall time: 23.002 seconds, Î”t:  0.0159, advective CFL: 7.00e-01, diffusive CFL: 1.84e-02\nIter:    750, sim time:  11.627, wall time: 23.487 seconds, Î”t:  0.0174, advective CFL: 7.00e-01, diffusive CFL: 2.02e-02\nIter:    800, sim time:  12.488, wall time: 23.969 seconds, Î”t:  0.0178, advective CFL: 7.00e-01, diffusive CFL: 2.06e-02\nIter:    850, sim time:  13.356, wall time: 24.493 seconds, Î”t:  0.0180, advective CFL: 7.00e-01, diffusive CFL: 2.08e-02\nIter:    900, sim time:  14.233, wall time: 25.015 seconds, Î”t:  0.0183, advective CFL: 7.00e-01, diffusive CFL: 2.12e-02\nIter:    950, sim time:  15.110, wall time: 25.492 seconds, Î”t:  0.0197, advective CFL: 7.00e-01, diffusive CFL: 2.28e-02\nIter:   1000, sim time:  16.059, wall time: 25.976 seconds, Î”t:  0.0197, advective CFL: 7.00e-01, diffusive CFL: 2.28e-02\nIter:   1050, sim time:  17.020, wall time: 26.454 seconds, Î”t:  0.0197, advective CFL: 7.00e-01, diffusive CFL: 2.28e-02\nIter:   1100, sim time:  17.972, wall time: 26.988 seconds, Î”t:  0.0200, advective CFL: 7.00e-01, diffusive CFL: 2.32e-02\nIter:   1150, sim time:  18.961, wall time: 27.452 seconds, Î”t:  0.0208, advective CFL: 7.00e-01, diffusive CFL: 2.41e-02\nIter:   1200, sim time:  19.958, wall time: 27.935 seconds, Î”t:  0.0218, advective CFL: 7.00e-01, diffusive CFL: 2.53e-02\nIter:   1250, sim time:  21.044, wall time: 28.422 seconds, Î”t:  0.0220, advective CFL: 7.00e-01, diffusive CFL: 2.55e-02\nIter:   1300, sim time:  22.132, wall time: 28.906 seconds, Î”t:  0.0205, advective CFL: 7.00e-01, diffusive CFL: 2.38e-02\nIter:   1350, sim time:  23.144, wall time: 29.425 seconds, Î”t:  0.0214, advective CFL: 7.00e-01, diffusive CFL: 2.48e-02\nIter:   1400, sim time:  24.171, wall time: 29.891 seconds, Î”t:  0.0220, advective CFL: 7.00e-01, diffusive CFL: 2.55e-02\nIter:   1450, sim time:  25.265, wall time: 30.375 seconds, Î”t:  0.0243, advective CFL: 6.86e-01, diffusive CFL: 2.81e-02\nIter:   1500, sim time:  26.437, wall time: 30.867 seconds, Î”t:  0.0260, advective CFL: 7.00e-01, diffusive CFL: 3.02e-02\nIter:   1550, sim time:  27.682, wall time: 31.355 seconds, Î”t:  0.0203, advective CFL: 7.00e-01, diffusive CFL: 2.35e-02\nIter:   1600, sim time:  28.682, wall time: 31.880 seconds, Î”t:  0.0161, advective CFL: 7.00e-01, diffusive CFL: 1.87e-02\nIter:   1650, sim time:  29.484, wall time: 32.339 seconds, Î”t:  0.0152, advective CFL: 7.00e-01, diffusive CFL: 1.76e-02\nIter:   1700, sim time:  30.228, wall time: 32.821 seconds, Î”t:  0.0147, advective CFL: 7.00e-01, diffusive CFL: 1.71e-02\nIter:   1750, sim time:  30.957, wall time: 33.300 seconds, Î”t:  0.0162, advective CFL: 6.39e-01, diffusive CFL: 1.88e-02\nIter:   1800, sim time:  31.759, wall time: 33.782 seconds, Î”t:  0.0178, advective CFL: 6.18e-01, diffusive CFL: 2.06e-02\nIter:   1850, sim time:  32.625, wall time: 34.303 seconds, Î”t:  0.0196, advective CFL: 6.62e-01, diffusive CFL: 2.27e-02\nIter:   1900, sim time:  33.578, wall time: 34.768 seconds, Î”t:  0.0211, advective CFL: 7.00e-01, diffusive CFL: 2.45e-02\nIter:   1950, sim time:  34.627, wall time: 35.265 seconds, Î”t:  0.0218, advective CFL: 7.00e-01, diffusive CFL: 2.53e-02\nIter:   2000, sim time:  35.696, wall time: 35.749 seconds, Î”t:  0.0223, advective CFL: 7.00e-01, diffusive CFL: 2.58e-02\nIter:   2050, sim time:  36.790, wall time: 36.232 seconds, Î”t:  0.0227, advective CFL: 7.00e-01, diffusive CFL: 2.63e-02\nIter:   2100, sim time:  37.909, wall time: 36.751 seconds, Î”t:  0.0235, advective CFL: 7.00e-01, diffusive CFL: 2.72e-02\nIter:   2150, sim time:  39.000, wall time: 37.220 seconds, Î”t:  0.0242, advective CFL: 7.00e-01, diffusive CFL: 2.81e-02\n[ Info: Simulation is stopping after running for 37.629 seconds.\n[ Info: Simulation time 40 seconds equals or exceeds stop time 40 seconds.\n","category":"page"},{"location":"literated/horizontal_convection/#Load-saved-output,-process,-visualize","page":"Horizontal convection","title":"Load saved output, process, visualize","text":"","category":"section"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"We animate the results by loading the saved output, extracting data for the iterations we ended up saving at, and plotting the saved fields. From the saved buoyancy field we compute the buoyancy dissipation, chi = kappa boldsymbolnabla b^2, and plot that also.","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"To start we load the saved fields are FieldTimeSeries and prepare for animating the flow by creating coordinate arrays that each field lives on.","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"using CairoMakie\nusing Oceananigans\nusing Oceananigans.Fields\nusing Oceananigans.AbstractOperations: volume\n\nsaved_output_filename = \"horizontal_convection.jld2\"\n\n# Open the file with our data\ns_timeseries = FieldTimeSeries(saved_output_filename, \"s\")\nb_timeseries = FieldTimeSeries(saved_output_filename, \"b\")\nÎ¶_timeseries = FieldTimeSeries(saved_output_filename, \"Î¶\")\n\ntimes = b_timeseries.times\n\nÏ‡_timeseries = deepcopy(b_timeseries)\n\nfor n in 1:length(times)\n    bn = b_timeseries[n]\n    Ï‡_timeseries[n] .= @at (Center, Center, Center) Îº * (âˆ‚x(bn)^2 + âˆ‚z(bn)^2)\nend","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"Now we're ready to animate using Makie.","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"@info \"Making an animation from saved data...\"\n\nn = Observable(1)\n\ntitle = @lift @sprintf(\"t=%1.2f\", times[$n])\n\nsn = @lift s_timeseries[$n]\nÎ¶n = @lift Î¶_timeseries[$n]\nbn = @lift b_timeseries[$n]\nÏ‡n = @lift Ï‡_timeseries[$n]\n\nslim = 0.6\nblim = 0.6\nÎ¶lim = 9\nÏ‡lim = 0.025\n\naxis_kwargs = (xlabel = L\"x / H\",\n               ylabel = L\"z / H\",\n               limits = ((-Lx/2, Lx/2), (-H, 0)),\n               aspect = Lx / H,\n               titlesize = 20)\n\nfig = Figure(size = (600, 1100))\n\nax_s = Axis(fig[2, 1]; title = L\"speed, $(u^2+w^2)^{1/2} / (L_x b_*)^{1/2}$\", axis_kwargs...)\nax_b = Axis(fig[3, 1]; title = L\"buoyancy, $b / b_*$\", axis_kwargs...)\nax_Î¶ = Axis(fig[4, 1]; axis_kwargs...,\n            title = L\"vorticity, $(âˆ‚u/âˆ‚z - âˆ‚w/âˆ‚x) \\, (L_x / b_*)^{1/2}$\")\n\nax_Ï‡ = Axis(fig[5, 1]; axis_kwargs...,\n            title = L\"buoyancy dissipation, $Îº |\\mathbf{\\nabla}b|^2 \\, (L_x / {b_*}^5)^{1/2}$\")\n\nfig[1, :] = Label(fig, title, fontsize=24, tellwidth=false)\n\nhm_s = heatmap!(ax_s, sn; colorrange=(0, slim), colormap=:speed)\nColorbar(fig[2, 2], hm_s)\n\nhm_b = heatmap!(ax_b, bn; colorrange=(-blim, blim), colormap=:thermal)\nColorbar(fig[3, 2], hm_b)\n\nhm_Î¶ = heatmap!(ax_Î¶, Î¶n; colorrange=(-Î¶lim, Î¶lim), colormap=:balance)\nColorbar(fig[4, 2], hm_Î¶)\n\nhm_Ï‡ = heatmap!(ax_Ï‡, Ï‡n; colorrange=(0, Ï‡lim), colormap=:dense)\nColorbar(fig[5, 2], hm_Ï‡)","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"Colorbar()","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"And, finally, we record a movie.","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"frames = 1:length(times)\n\nrecord(fig, \"horizontal_convection.mp4\", frames, framerate=8) do i\n    msg = string(\"Plotting frame \", i, \" of \", frames[end])\n    print(msg * \" \\r\")\n    n[] = i\nend","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"Plotting frame 1 of 81 Plotting frame 2 of 81 Plotting frame 3 of 81 Plotting frame 4 of 81 Plotting frame 5 of 81 Plotting frame 6 of 81 Plotting frame 7 of 81 Plotting frame 8 of 81 Plotting frame 9 of 81 Plotting frame 10 of 81 Plotting frame 11 of 81 Plotting frame 12 of 81 Plotting frame 13 of 81 Plotting frame 14 of 81 Plotting frame 15 of 81 Plotting frame 16 of 81 Plotting frame 17 of 81 Plotting frame 18 of 81 Plotting frame 19 of 81 Plotting frame 20 of 81 Plotting frame 21 of 81 Plotting frame 22 of 81 Plotting frame 23 of 81 Plotting frame 24 of 81 Plotting frame 25 of 81 Plotting frame 26 of 81 Plotting frame 27 of 81 Plotting frame 28 of 81 Plotting frame 29 of 81 Plotting frame 30 of 81 Plotting frame 31 of 81 Plotting frame 32 of 81 Plotting frame 33 of 81 Plotting frame 34 of 81 Plotting frame 35 of 81 Plotting frame 36 of 81 Plotting frame 37 of 81 Plotting frame 38 of 81 Plotting frame 39 of 81 Plotting frame 40 of 81 Plotting frame 41 of 81 Plotting frame 42 of 81 Plotting frame 43 of 81 Plotting frame 44 of 81 Plotting frame 45 of 81 Plotting frame 46 of 81 Plotting frame 47 of 81 Plotting frame 48 of 81 Plotting frame 49 of 81 Plotting frame 50 of 81 Plotting frame 51 of 81 Plotting frame 52 of 81 Plotting frame 53 of 81 Plotting frame 54 of 81 Plotting frame 55 of 81 Plotting frame 56 of 81 Plotting frame 57 of 81 Plotting frame 58 of 81 Plotting frame 59 of 81 Plotting frame 60 of 81 Plotting frame 61 of 81 Plotting frame 62 of 81 Plotting frame 63 of 81 Plotting frame 64 of 81 Plotting frame 65 of 81 Plotting frame 66 of 81 Plotting frame 67 of 81 Plotting frame 68 of 81 Plotting frame 69 of 81 Plotting frame 70 of 81 Plotting frame 71 of 81 Plotting frame 72 of 81 Plotting frame 73 of 81 Plotting frame 74 of 81 Plotting frame 75 of 81 Plotting frame 76 of 81 Plotting frame 77 of 81 Plotting frame 78 of 81 Plotting frame 79 of 81 Plotting frame 80 of 81 Plotting frame 81 of 81 ","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"(Image: )","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"At higher Rayleigh numbers the flow becomes much more vigorous. See, for example, an animation of the voricity of the fluid at Ra = 10^12 on vimeo.","category":"page"},{"location":"literated/horizontal_convection/#The-Nusselt-number","page":"Horizontal convection","title":"The Nusselt number","text":"","category":"section"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"Often we are interested on how much the flow enhances mixing. This is quantified by the Nusselt number, which measures how much the flow enhances mixing compared if only diffusion was in operation. The Nusselt number is given by","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"Nu = fraclangle chi ranglelangle chi_rm diff rangle  ","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"where angle brackets above denote both a volume and time average and chi_rm diff is the buoyancy dissipation that we get without any flow, i.e., the buoyancy dissipation associated with the buoyancy distribution that satisfies","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"kappa nabla^2 b_rm diff = 0  ","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"with the same boundary conditions same as our setup. In this case, we can readily find that","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"b_rm diff(x z) = b_s(x) fraccosh left 2 pi (H + z)  L_x right cosh(2 pi H  L_x)  ","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"where b_s(x) is the surface boundary condition. The diffusive solution implies","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"langle chi_rm diff rangle = frackappa b_*^2 piL_x H tanh(2 pi Î—  L_x) ","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"We use the loaded FieldTimeSeries to compute the Nusselt number from buoyancy and the volume average kinetic energy of the fluid.","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"First we compute the diffusive buoyancy dissipation, chi_rm diff (which is just a scalar):","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"Ï‡_diff = Îº * bâ˜…^2 * Ï€ * tanh(2Ï€ * H / Lx) / (Lx * H)","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"We recover the time from the saved FieldTimeSeries and construct two empty arrays to store the volume-averaged kinetic energy and the instantaneous Nusselt number,","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"t = b_timeseries.times\n\nkinetic_energy, Nu = zeros(length(t)), zeros(length(t))","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"Now we can loop over the fields in the FieldTimeSeries, compute kinetic energy and Nu, and plot. We make use of Integral to compute the volume integral of fields over our domain.","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"for n = 1:length(t)\n    ke = Field(Integral(1/2 * s_timeseries[n]^2 / (Lx * H)))\n    kinetic_energy[n] = ke[1, 1, 1]\n\n    Ï‡ = Field(Integral(Ï‡_timeseries[n] / (Lx * H)))\n    Nu[n] = Ï‡[1, 1, 1] / Ï‡_diff\nend\n\nfig = Figure(size = (850, 450))\n\nax_KE = Axis(fig[1, 1], xlabel = L\"t \\, (b_* / L_x)^{1/2}\", ylabel = L\"KE $ / (L_x b_*)$\")\nlines!(ax_KE, t, kinetic_energy; linewidth = 3)\n\nax_Nu = Axis(fig[2, 1], xlabel = L\"t \\, (b_* / L_x)^{1/2}\", ylabel = L\"Nu\")\nlines!(ax_Nu, t, Nu; linewidth = 3)\n\nfig","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"(Image: )","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"This page was generated using Literate.jl.","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#turbulence_closures","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and large eddy simulation models","text":"","category":"section"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"A turbulent diffusivity closure representing the effects of viscous dissipation and diffusion can be passed via the closure keyword.","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"See turbulence closures and large eddy simulation for more details on turbulent diffusivity closures.","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#Constant-isotropic-diffusivity","page":"Turbulent diffusivity closures and LES models","title":"Constant isotropic diffusivity","text":"","category":"section"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"To use constant isotropic values for the viscosity nu and diffusivity kappa you can use ScalarDiffusivity:","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"julia> using Oceananigans.TurbulenceClosures\n\njulia> closure = ScalarDiffusivity(Î½=1e-2, Îº=1e-2)\nScalarDiffusivity{ExplicitTimeDiscretization}(Î½=0.01, Îº=0.01)","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#Constant-anisotropic-diffusivity","page":"Turbulent diffusivity closures and LES models","title":"Constant anisotropic diffusivity","text":"","category":"section"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"To specify constant values for the horizontal and vertical viscosities, nu_h and nu_z, and horizontal and vertical diffusivities, kappa_h and kappa_z, you can use HorizontalScalarDiffusivity() and VerticalScalarDiffusivity(), e.g.,","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"julia> using Oceananigans.TurbulenceClosures\n\njulia> horizontal_closure = HorizontalScalarDiffusivity(Î½=1e-3, Îº=2e-3)\nHorizontalScalarDiffusivity{ExplicitTimeDiscretization}(Î½=0.001, Îº=0.002)\n\njulia> vertical_closure = VerticalScalarDiffusivity(Î½=1e-3, Îº=2e-3)\nVerticalScalarDiffusivity{ExplicitTimeDiscretization}(Î½=0.001, Îº=0.002)","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"After that you can set, e.g., closure = (horizontal_closure, vertical_closure) when constructing the model so that all components will be taken into account when calculating the diffusivity term. Note that VerticalScalarDiffusivity and HorizontalScalarDiffusivity are implemented using different schemes with different conservation properties.","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#Tracer-specific-diffusivities","page":"Turbulent diffusivity closures and LES models","title":"Tracer-specific diffusivities","text":"","category":"section"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"You can also set different diffusivities for each tracer in your simulation by passing a NamedTuple as the argument kappa:","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"julia> using Oceananigans.TurbulenceClosures\n\njulia> ScalarDiffusivity(Î½=1e-6, Îº=(S=1e-7, T=1e-10))\nScalarDiffusivity{ExplicitTimeDiscretization}(Î½=1.0e-6, Îº=(S=1.0e-7, T=1.0e-10))","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"The example above sets a viscosity of 1e-6, a diffusivity for a tracer called T of 1e-7, and a diffusivity for a tracer called S of 1e-10. Specifying diffusivities this way is also valid for HorizontalScalarDiffusivity and VerticalScalarDiffusivity. If this method is used, diffusivities for all tracers need to be specified.","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#Smagorinsky-Lilly","page":"Turbulent diffusivity closures and LES models","title":"Smagorinsky-Lilly","text":"","category":"section"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"To use the default Smagorinsky-Lilly LES closure, we write","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"julia> using Oceananigans.TurbulenceClosures\n\njulia> closure = SmagorinskyLilly()\nSmagorinsky closure with\nâ”œâ”€â”€ coefficient = LillyCoefficient(smagorinsky = 0.16, reduction_factor = 1.0)\nâ””â”€â”€ Pr = 1.0","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"The parameters C, Cb, and Pr may alternatively be specified explicitly. For more details see SmagorinskyLilly.","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#Anisotropic-minimum-dissipation","page":"Turbulent diffusivity closures and LES models","title":"Anisotropic minimum dissipation","text":"","category":"section"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"To use the constant anisotropic minimum dissipation (AMD) LES closure,","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"julia> using Oceananigans.TurbulenceClosures\n\njulia> closure = AnisotropicMinimumDissipation()\nAnisotropicMinimumDissipation{ExplicitTimeDiscretization} turbulence closure with:\n           PoincareÌ constant for momentum eddy viscosity CÎ½: 0.3333333333333333\n    PoincareÌ constant for tracer(s) eddy diffusivit(ies) CÎº: 0.3333333333333333\n                        Buoyancy modification multiplier Cb: nothing","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"no parameters are required although they may be specified. By default, the background viscosity and diffusivity are assumed to be the molecular values for seawater. For more details see AnisotropicMinimumDissipation.","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#Convective-Adjustment-Vertical-Diffusivityâ€“Viscosity","page":"Turbulent diffusivity closures and LES models","title":"Convective Adjustment Vertical Diffusivityâ€“Viscosity","text":"","category":"section"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"To use the a convective adjustment scheme that applies enhanced values for vertical diffusivity kappa_z and/or viscosity nu_z, anytime and anywhere the background stratification becomes unstable.","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"julia> using Oceananigans\n\njulia> closure = ConvectiveAdjustmentVerticalDiffusivity(convective_Îºz = 1.0, background_Îºz = 1e-3)\nConvectiveAdjustmentVerticalDiffusivity{VerticallyImplicitTimeDiscretization}(background_Îºz=0.001 convective_Îºz=1.0 background_Î½z=0.0 convective_Î½z=0.0)","category":"page"},{"location":"literated/one_dimensional_diffusion/#one_dimensional_diffusion_example","page":"One-dimensional diffusion","title":"Simple diffusion example","text":"","category":"section"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"This is Oceananigans.jl's simplest example: the diffusion of a one-dimensional Gaussian. This example demonstrates","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"How to load Oceananigans.jl.\nHow to instantiate an Oceananigans.jl model.\nHow to create simple Oceananigans.jl output.\nHow to set an initial condition with a function.\nHow to time-step a model forward.\nHow to look at results.","category":"page"},{"location":"literated/one_dimensional_diffusion/#Install-dependencies","page":"One-dimensional diffusion","title":"Install dependencies","text":"","category":"section"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"using Pkg\npkg\"add Oceananigans, CairoMakie\"","category":"page"},{"location":"literated/one_dimensional_diffusion/#Using-Oceananigans.jl","page":"One-dimensional diffusion","title":"Using Oceananigans.jl","text":"","category":"section"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Write","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"using Oceananigans","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"to load Oceananigans functions and objects into our script.","category":"page"},{"location":"literated/one_dimensional_diffusion/#Instantiating-and-configuring-a-model","page":"One-dimensional diffusion","title":"Instantiating and configuring a model","text":"","category":"section"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"A core Oceananigans type is NonhydrostaticModel. We build a NonhydrostaticModel by passing it a grid, plus information about the equations we would like to solve.","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Below, we build a rectilinear grid with 128 regularly-spaced grid points in the z-direction, where z spans from z = -0.5 to z = 0.5,","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"grid = RectilinearGrid(size=128, z=(-0.5, 0.5), topology=(Flat, Flat, Bounded))","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"1Ã—1Ã—128 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0Ã—0Ã—3 halo\nâ”œâ”€â”€ Flat x                   \nâ”œâ”€â”€ Flat y                   \nâ””â”€â”€ Bounded  z âˆˆ [-0.5, 0.5] regularly spaced with Î”z=0.0078125","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"The default topology is (Periodic, Periodic, Bounded). In this example, we're trying to solve a one-dimensional problem, so we assign Flat to the x and y topologies. We excise halos and avoid interpolation or differencing in Flat directions, saving computation and memory.","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"We next specify a model with an ScalarDiffusivity, which models either molecular or turbulent diffusion,","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"closure = ScalarDiffusivity(Îº=1)","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"ScalarDiffusivity{ExplicitTimeDiscretization}(Î½=0.0, Îº=1.0)","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"We finally pass these two ingredients to NonhydrostaticModel,","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"model = NonhydrostaticModel(; grid, closure, tracers=:T)","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 1Ã—1Ã—128 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0Ã—0Ã—3 halo\nâ”œâ”€â”€ timestepper: RungeKutta3TimeStepper\nâ”œâ”€â”€ advection scheme: Centered(order=2)\nâ”œâ”€â”€ tracers: T\nâ”œâ”€â”€ closure: ScalarDiffusivity{ExplicitTimeDiscretization}(Î½=0.0, Îº=(T=1.0,))\nâ”œâ”€â”€ buoyancy: Nothing\nâ””â”€â”€ coriolis: Nothing","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"By default, NonhydrostaticModel has no-flux (insulating and stress-free) boundary conditions on all fields.","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Next, we set! an initial condition on the temperature field, model.tracers.T. Our objective is to observe the diffusion of a Gaussian.","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"width = 0.1\ninitial_temperature(z) = exp(-z^2 / (2width^2))\nset!(model, T=initial_temperature)","category":"page"},{"location":"literated/one_dimensional_diffusion/#Visualizing-model-data","page":"One-dimensional diffusion","title":"Visualizing model data","text":"","category":"section"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Calling set! above changes the data contained in model.tracers.T, which was initialized as 0's when the model was created. To see the new data in model.tracers.T, we plot it:","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"using CairoMakie\nset_theme!(Theme(fontsize = 20, linewidth=3))\n\nfig = Figure()\naxis = (xlabel = \"Temperature (áµ’C)\", ylabel = \"z\")\nlabel = \"t = 0\"\nlines(model.tracers.T; label, axis)","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"(Image: )","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"The function interior above extracts a view of model.tracers.T over the physical points (excluding halos) at (1, 1, :).","category":"page"},{"location":"literated/one_dimensional_diffusion/#Running-a-Simulation","page":"One-dimensional diffusion","title":"Running a Simulation","text":"","category":"section"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Next we set-up a Simulation that time-steps the model forward and manages output.","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"# Time-scale for diffusion across a grid cell\nmin_Î”z = minimum_zspacing(model.grid)\ndiffusion_time_scale = min_Î”z^2 / model.closure.Îº.T\n\nsimulation = Simulation(model, Î”t = 0.1 * diffusion_time_scale, stop_iteration = 1000)","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Simulation of NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ Next time step: 6.104 Î¼s\nâ”œâ”€â”€ Elapsed wall time: 0 seconds\nâ”œâ”€â”€ Wall time per iteration: NaN days\nâ”œâ”€â”€ Stop time: Inf days\nâ”œâ”€â”€ Stop iteration: 1000.0\nâ”œâ”€â”€ Wall time limit: Inf\nâ”œâ”€â”€ Minimum relative step: 0.0\nâ”œâ”€â”€ Callbacks: OrderedDict with 4 entries:\nâ”‚   â”œâ”€â”€ stop_time_exceeded => 4\nâ”‚   â”œâ”€â”€ stop_iteration_exceeded => -\nâ”‚   â”œâ”€â”€ wall_time_limit_exceeded => e\nâ”‚   â””â”€â”€ nan_checker => }\nâ”œâ”€â”€ Output writers: OrderedDict with no entries\nâ””â”€â”€ Diagnostics: OrderedDict with no entries","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"simulation will run for 1000 iterations with a time-step that resolves the time-scale at which our temperature field diffuses. All that's left is to","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"run!(simulation)","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"[ Info: Initializing simulation...\n[ Info:     ... simulation initialization complete (1.003 seconds)\n[ Info: Executing initial time step...\n[ Info:     ... initial time step complete (3.172 seconds).\n[ Info: Simulation is stopping after running for 5.057 seconds.\n[ Info: Model iteration 1000 equals or exceeds stop iteration 1000.\n","category":"page"},{"location":"literated/one_dimensional_diffusion/#Visualizing-the-results","page":"One-dimensional diffusion","title":"Visualizing the results","text":"","category":"section"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Let's look at how model.tracers.T changed during the simulation.","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"using Printf\n\nlabel = @sprintf(\"t = %.3f\", model.clock.time)\nlines!(model.tracers.T; label)\naxislegend()","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"(Image: )","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Very interesting! Next, we run the simulation a bit longer and make an animation. For this, we use the JLD2Writer to write data to disk as the simulation progresses.","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"simulation.output_writers[:temperature] =\n    JLD2Writer(model, model.tracers,\n               filename = \"one_dimensional_diffusion.jld2\",\n               schedule=IterationInterval(100),\n               overwrite_existing = true)","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"JLD2Writer scheduled on IterationInterval(100):\nâ”œâ”€â”€ filepath: one_dimensional_diffusion.jld2\nâ”œâ”€â”€ 1 outputs: T\nâ”œâ”€â”€ array_type: Array{Float32}\nâ”œâ”€â”€ including: [:grid, :coriolis, :buoyancy, :closure]\nâ”œâ”€â”€ file_splitting: NoFileSplitting\nâ””â”€â”€ file size: 22.5 KiB","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"We run the simulation for 10,000 more iterations,","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"simulation.stop_iteration += 10000\nrun!(simulation)","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"[ Info: Initializing simulation...\n[ Info:     ... simulation initialization complete (17.860 ms)\n[ Info: Executing initial time step...\n[ Info:     ... initial time step complete (1.146 ms).\n[ Info: Simulation is stopping after running for 8.122 seconds.\n[ Info: Model iteration 11000 equals or exceeds stop iteration 11000.\n","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Finally, we animate the results by opening the JLD2 file, extract the iterations we ended up saving at, and plot the evolution of the temperature profile in a loop over the iterations.","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"T_timeseries = FieldTimeSeries(\"one_dimensional_diffusion.jld2\", \"T\")\ntimes = T_timeseries.times\n\nfig = Figure()\nax = Axis(fig[2, 1]; xlabel = \"Temperature (áµ’C)\", ylabel = \"z\")\nxlims!(ax, 0, 1)\n\nn = Observable(1)\n\nT = @lift T_timeseries[$n]\nlines!(T)\n\nlabel = @lift \"t = \" * string(round(times[$n], digits=3))\nLabel(fig[1, 1], label, tellwidth=false)\n\nfig","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"(Image: )","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Finally, we record a movie.","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"frames = 1:length(times)\n\n@info \"Making an animation...\"\n\nrecord(fig, \"one_dimensional_diffusion.mp4\", frames, framerate=24) do i\n    n[] = i\nend","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"[ Info: Making an animation...\n","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"(Image: )","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"This page was generated using Literate.jl.","category":"page"},{"location":"physics/notation/#Coordinate-system-and-notation","page":"Coordinate system and notation","title":"Coordinate system and notation","text":"","category":"section"},{"location":"physics/notation/","page":"Coordinate system and notation","title":"Coordinate system and notation","text":"Oceananigans.jl is formulated in a Cartesian coordinate system boldsymbolx = (x y z) with unit vectors boldsymbolhat x, boldsymbolhat y, and boldsymbolhat z, where boldsymbolhat x points east, boldsymbolhat y points north, and boldsymbolhat z points 'upward', opposite the direction of gravitational acceleration.","category":"page"},{"location":"physics/notation/","page":"Coordinate system and notation","title":"Coordinate system and notation","text":"We denote time with t, partial derivatives with respect to time t or a coordinate x with partial_t or partial_x, and denote the gradient operator boldsymbolnabla equiv partial_x boldsymbolhat x + partial_y boldsymbolhat y + partial_z boldsymbolhat z. Horizontal gradients are denoted with boldsymbolnabla_h equiv partial_x boldsymbolhat x + partial_y boldsymbolhat y.","category":"page"},{"location":"physics/notation/","page":"Coordinate system and notation","title":"Coordinate system and notation","text":"We use u, v, and w to denote the east, north, and vertical velocity components, such that boldsymbolv = u boldsymbolhat x + v boldsymbolhat y + w boldsymbolhat z. We reserve boldsymbolv for the three-dimensional velocity field and use boldsymbolu to denote the horizontal components of flow, i.e., boldsymbolu = u boldsymbolhat x + v boldsymbolhat y.","category":"page"},{"location":"simulations/#Simulations","page":"Simulations","title":"Simulations","text":"","category":"section"},{"location":"simulations/","page":"Simulations","title":"Simulations","text":"Simulations are basically a utility for managing a time-stepping loop, including scheduling important activities such as:","category":"page"},{"location":"simulations/","page":"Simulations","title":"Simulations","text":"Logging the progress of a simulation,\nComputing and writing diagnostics or other output to disk,\nStopping a simulation when its time has come.","category":"page"},{"location":"simulations/","page":"Simulations","title":"Simulations","text":"The most important line in any script is run!(simulation).","category":"page"},{"location":"literated/kelvin_helmholtz_instability/#Stratified-Kelvin-Helmholtz-instability","page":"Kelvin-Helmholtz instability","title":"Stratified Kelvin-Helmholtz instability","text":"","category":"section"},{"location":"literated/kelvin_helmholtz_instability/#Install-dependencies","page":"Kelvin-Helmholtz instability","title":"Install dependencies","text":"","category":"section"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"using Pkg\npkg\"add Oceananigans, CairoMakie\"","category":"page"},{"location":"literated/kelvin_helmholtz_instability/#The-physical-domain","page":"Kelvin-Helmholtz instability","title":"The physical domain","text":"","category":"section"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"We simulate a Kelvin-Helmholtz instability in two-dimensions in x z and therefore assign Flat to the y direction,","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"using Oceananigans\n\ngrid = RectilinearGrid(size=(64, 64), x=(-5, 5), z=(-5, 5),\n                       topology=(Periodic, Flat, Bounded))","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"64Ã—1Ã—64 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo\nâ”œâ”€â”€ Periodic x âˆˆ [-5.0, 5.0) regularly spaced with Î”x=0.15625\nâ”œâ”€â”€ Flat y                   \nâ””â”€â”€ Bounded  z âˆˆ [-5.0, 5.0] regularly spaced with Î”z=0.15625","category":"page"},{"location":"literated/kelvin_helmholtz_instability/#The-basic-state","page":"Kelvin-Helmholtz instability","title":"The basic state","text":"","category":"section"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"We're simulating the instability of a sheared and stably-stratified basic state U(z) and B(z). Two parameters define our basic state: the Richardson number,","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Ri = frac_z B(_z U)^2 ","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"and the width of the stratification layer, h.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"shear_flow(x, z, t) = tanh(z)\n\nstratification(x, z, t, p) = p.h * p.Ri * tanh(z / p.h)\n\nU = BackgroundField(shear_flow)\n\nB = BackgroundField(stratification, parameters=(Ri=0.1, h=1/4))","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"BackgroundField{typeof(Main.var\"##2496\".stratification), @NamedTuple{Ri::Float64, h::Float64}}\nâ”œâ”€â”€ func: stratification (generic function with 1 method)\nâ””â”€â”€ parameters: (Ri = 0.1, h = 0.25)","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Our basic state thus has a thin layer of stratification in the center of the channel, embedded within a thicker shear layer surrounded by unstratified fluid.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"using CairoMakie\n\nzF = znodes(grid, Face())\nzC = znodes(grid, Center())\n\nRi, h = B.parameters\n\nfig = Figure(size = (850, 450))\n\nax = Axis(fig[1, 1], xlabel = \"U(z)\", ylabel = \"z\")\nlines!(ax, shear_flow.(0, zC, 0), zC; linewidth = 3)\n\nax = Axis(fig[1, 2], xlabel = \"B(z)\")\nlines!(ax, [stratification(0, z, 0, (Ri=Ri, h=h)) for z in zC], zC; linewidth = 3, color = :red)\n\nax = Axis(fig[1, 3], xlabel = \"Ri(z)\")\nlines!(ax, [Ri * sech(z / h)^2 / sech(z)^2 for z in zF], zF; linewidth = 3, color = :black) # Ri(z)= âˆ‚_z B / (âˆ‚_z U)Â²; derivatives computed by hand\n\nfig","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"(Image: )","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"In unstable flows it is often useful to determine the dominant spatial structure of the instability and the growth rate at which the instability grows. If the simulation idealizes a physical flow, this can be used to make predictions as to what should develop and how quickly. Since these instabilities are often attributed to a linear instability, we can determine information about the structure and the growth rate of the instability by analyzing the linear operator that governs small perturbations about a base state, or by solving for the linear dynamics.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Here, we discuss first briefly linear instabilities and how one can obtain growth rates and structures of most unstable modes via eigenanalysis. Then we present an alternative method for approximating the eigenanalysis results when one does not have access to the linear dynamics or the linear operator about the base state.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/#Linear-Instabilities","page":"Kelvin-Helmholtz instability","title":"Linear Instabilities","text":"","category":"section"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"The base state U(z), B(z) is a solution of the inviscid equations of motion. Whether the base state is stable or not is determined by whether small perturbations about this base state grow or decay. To formalize this, we study the linearized dynamics satisfied by perturbations about the base state:","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"partial_t Phi = L Phi  ","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"where Phi = (u v w b) is a vector of the perturbation velocities u v w and perturbation buoyancy b and L a linear operator that depends on the base state, L = L(U(z) B(z)) (the background_fields). Eigenanalysis of the linear operator L determines the stability of the base state, such as the Kelvin-Helmholtz instability. That is, by using the ansantz","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Phi(x y z t) = phi(x y z)  exp(lambda t)  ","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"then lambda and phi are respectively eigenvalues and eigenmodes of L, i.e., they obey","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"L  phi_j = lambda_j  phi_j quad j=12dots  ","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"From hereafter we'll use the convention that the eigenvalues are ordered according to their real part, mathrmRe(lambda_1) ge mathrmRe(lambda_2) ge dotsb.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Remarks:","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"As we touched upon briefly above, Oceananigans.jl, does not include the linearized version of the equations. Furthermore, Oceananigans.jl does not give us access to the linear operator L so that we can perform eigenanalysis. Below we discuss an alternative way of approximating the eigenanalysis results. The method boils down to solving the nonlinear equations while continually renormalize the magnitude of the perturbations to ensure that nonlinear terms (terms that are quadratic or higher in perturbations) remain negligibly small, i.e.,much smaller than the background flow.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/#The-power-method-algorithm","page":"Kelvin-Helmholtz instability","title":"The power method algorithm","text":"","category":"section"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Successive application of L to a random initial state will eventually render it parallel with eigenmode phi_1:","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"lim_n to infty L^n Phi propto phi_1  ","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Of course, if phi_1 is an unstable mode (i.e., sigma_1 = mathrmRe(lambda_1)  0), then successive application of L will lead to exponential amplification. (Similarly, if sigma_1  0, successive application of L will lead to exponential decay of Phi down to machine precision.) Therefore, after each application of the linear operator L, we rescale the output L Phi back to a pre-selected amplitude.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"So, we initialize a simulation with random initial conditions with amplitude much less than those of the base state (which are O(1)). Instead of \"applying\" L on our initial state, we evolve the (approximately) linear dynamics for interval Delta tau. We measure how much the energy has grown during that interval, rescale the perturbations back to original energy amplitude and repeat. After some iterations the state will converge to the most unstable eigenmode.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"In summary, each iteration of the power method includes:","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"compute the perturbation energy, E_0,\nevolve the system for a time-interval Delta tau,\ncompute the perturbation energy, E_1,\ndetermine the exponential growth of the most unstable mode during the interval Delta tau as  log(E_1  E_0)  (2 Delta tau),\nrepeat the above until growth rate converges.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"By fiddling a bit with Delta t we can get convergence after only a few iterations.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Let's apply all these to our example.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/#The-model","page":"Kelvin-Helmholtz instability","title":"The model","text":"","category":"section"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"model = NonhydrostaticModel(; grid,\n                            advection = UpwindBiased(order=5),\n                            background_fields = (u=U, b=B),\n                            closure = ScalarDiffusivity(Î½=2e-4, Îº=2e-4),\n                            buoyancy = BuoyancyTracer(),\n                            tracers = :b)","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 64Ã—1Ã—64 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo\nâ”œâ”€â”€ timestepper: RungeKutta3TimeStepper\nâ”œâ”€â”€ advection scheme: UpwindBiased(order=5)\nâ”œâ”€â”€ tracers: b\nâ”œâ”€â”€ closure: ScalarDiffusivity{ExplicitTimeDiscretization}(Î½=0.0002, Îº=(b=0.0002,))\nâ”œâ”€â”€ buoyancy: BuoyancyTracer with gÌ‚ = NegativeZDirection()\nâ””â”€â”€ coriolis: Nothing","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"We have included a \"pinch\" of viscosity and diffusivity in anticipation of what will follow further down: viscosity and diffusivity will ensure numerical stability when we evolve the unstable mode to the point it becomes nonlinear.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Here, we take Delta tau = 15. We also set verbose=false so that run!(simulation) is a little quieter.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"simulation = Simulation(model, Î”t=0.1, stop_iteration=150, verbose=false)","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Simulation of NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ Next time step: 100 ms\nâ”œâ”€â”€ Elapsed wall time: 0 seconds\nâ”œâ”€â”€ Wall time per iteration: NaN days\nâ”œâ”€â”€ Stop time: Inf days\nâ”œâ”€â”€ Stop iteration: 150.0\nâ”œâ”€â”€ Wall time limit: Inf\nâ”œâ”€â”€ Minimum relative step: 0.0\nâ”œâ”€â”€ Callbacks: OrderedDict with 4 entries:\nâ”‚   â”œâ”€â”€ stop_time_exceeded => 4\nâ”‚   â”œâ”€â”€ stop_iteration_exceeded => -\nâ”‚   â”œâ”€â”€ wall_time_limit_exceeded => e\nâ”‚   â””â”€â”€ nan_checker => }\nâ”œâ”€â”€ Output writers: OrderedDict with no entries\nâ””â”€â”€ Diagnostics: OrderedDict with no entries","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Now some helper functions that will be used during for the power method algorithm.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"First a function that evolves the state for Delta tau and measure the energy growth over that period.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"\"\"\"\n    grow_instability!(simulation, energy)\n\nGrow an instability by running `simulation`.\n\nEstimates the growth rate ``Ïƒ`` of the instability\nusing the fractional change in volume-mean kinetic energy,\nover the course of the `simulation`\n\n``\nenergy(tâ‚€ + Î”Ï„) / energy(tâ‚€) â‰ˆ exp(2 Ïƒ Î”Ï„)\n``\n\nwhere ``tâ‚€`` is the starting time of the simulation and ``tâ‚€ + Î”Ï„``\nthe ending time of the simulation. We thus find that the growth rate\nis measured by\n\n``\nÏƒ = log(energy(tâ‚€ + Î”Ï„) / energy(tâ‚€)) / (2 Î”Ï„) .\n``\n\"\"\"\nfunction grow_instability!(simulation, energy)\n    # Initialize\n    simulation.model.clock.iteration = 0\n    tâ‚€ = simulation.model.clock.time = 0\n    compute!(energy)\n    energyâ‚€ = energy[1, 1, 1]\n\n    # Grow\n    run!(simulation)\n\n    # Analyze\n    compute!(energy)\n    energyâ‚ = energy[1, 1, 1]\n    Î”Ï„ = simulation.model.clock.time - tâ‚€\n\n    # Â½(uÂ² + vÂ²) ~ exp(2 Ïƒ Î”Ï„)\n    Ïƒ = growth_rate = log(energyâ‚ / energyâ‚€) / 2Î”Ï„\n\n    return growth_rate\nend","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Finally, we write a function that rescales the state. The rescaling is done via computing the kinetic energy and then rescaling all flow fields so that the kinetic energy assumes a targetted value.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"(Measuring the perturbation growth via the kinetic energy works fine unless an unstable mode only has buoyancy structure. In that case, the total perturbation energy is more adequate.)","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"\"\"\"\n    rescale!(model, energy; target_kinetic_energy = 1e-3)\n\nRescales all model fields so that `energy = target_kinetic_energy`.\n\"\"\"\nfunction rescale!(model, energy; target_kinetic_energy = 1e-6)\n    compute!(energy)\n    rescale_factor = âˆš(target_kinetic_energy / energy[1, 1, 1])\n\n    for f in merge(model.velocities, model.tracers)\n        f .*= rescale_factor\n    end\n\n    return nothing\nend\n\nusing Printf","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Another helper function for the power method,","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"\"\"\"\n    convergence(Ïƒ)\n\nCheck if the growth rate has converged. If the array `Ïƒ` has at least 2 elements then returns the\nrelative difference between ``Ïƒ[end]`` and ``Ïƒ[end-1]``.\n\"\"\"\nconvergence(Ïƒ) = length(Ïƒ) > 1 ? abs((Ïƒ[end] - Ïƒ[end-1]) / Ïƒ[end]) : 9.1e18 # pretty big (not Inf tho)","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"and the main function that performs the power method iteration.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"\"\"\"\n    estimate_growth_rate(simulation, energy, Ï‰; convergence_criterion=1e-3)\n\nEstimates the growth rate iteratively until the relative change\nin the estimated growth rate ``Ïƒ`` falls below `convergence_criterion`.\n\nReturns ``Ïƒ``.\n\"\"\"\nfunction estimate_growth_rate(simulation, energy, Ï‰, b; convergence_criterion=1e-3)\n    Ïƒ = []\n    power_method_data = []\n    compute!(Ï‰)\n    push!(power_method_data, (Ï‰=deepcopy(Ï‰), b=deepcopy(b), Ïƒ=deepcopy(Ïƒ)))\n\n    while convergence(Ïƒ) > convergence_criterion\n        compute!(energy)\n\n        @info @sprintf(\"About to start power method iteration %d; kinetic energy: %.2e\", length(Ïƒ)+1, energy[1, 1, 1])\n        push!(Ïƒ, grow_instability!(simulation, energy))\n        compute!(energy)\n\n        @info @sprintf(\"Power method iteration %d, kinetic energy: %.2e, Ïƒâ¿: %.2e, relative Î”Ïƒ: %.2e\",\n                       length(Ïƒ), energy[1, 1, 1], Ïƒ[end], convergence(Ïƒ))\n\n        compute!(Ï‰)\n        rescale!(simulation.model, energy)\n    push!(power_method_data, (Ï‰=deepcopy(Ï‰), b=deepcopy(b), Ïƒ=deepcopy(Ïƒ)))\n    end\n\n    return Ïƒ, power_method_data\nend","category":"page"},{"location":"literated/kelvin_helmholtz_instability/#Eigenplotting","page":"Kelvin-Helmholtz instability","title":"Eigenplotting","text":"","category":"section"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"A good algorithm wouldn't be complete without a good visualization,","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"u, v, w = model.velocities\nb = model.tracers.b\n\nperturbation_vorticity = Field(âˆ‚z(u) - âˆ‚x(w))","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"64Ã—1Ã—65 Field{Face, Center, Face} on RectilinearGrid on CPU\nâ”œâ”€â”€ grid: 64Ã—1Ã—64 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo\nâ”œâ”€â”€ boundary conditions: FieldBoundaryConditions\nâ”‚   â””â”€â”€ west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: Nothing\nâ”œâ”€â”€ operand: BinaryOperation at (Face, Center, Face)\nâ”œâ”€â”€ status: time=0.0\nâ””â”€â”€ data: 70Ã—1Ã—71 OffsetArray(::Array{Float64, 3}, -2:67, 1:1, -2:68) with eltype Float64 with indices -2:67Ã—1:1Ã—-2:68\n    â””â”€â”€ max=0.0, min=0.0, mean=0.0","category":"page"},{"location":"literated/kelvin_helmholtz_instability/#Rev-your-engines...","page":"Kelvin-Helmholtz instability","title":"Rev your engines...","text":"","category":"section"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"We initialize the power iteration with random noise and rescale to have a target_kinetic_energy","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"using Random, Statistics\n\nmean_perturbation_kinetic_energy = Field(Average(1/2 * (u^2 + w^2)))\nnoise(x, z) = randn()\nset!(model, u=noise, w=noise, b=noise)\nrescale!(simulation.model, mean_perturbation_kinetic_energy, target_kinetic_energy=1e-6)\ngrowth_rates, power_method_data = estimate_growth_rate(simulation, mean_perturbation_kinetic_energy, perturbation_vorticity, b)\n\n@info \"Power iterations converged! Estimated growth rate: $(growth_rates[end])\"","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"[ Info: About to start power method iteration 1; kinetic energy: 2.15e-03\n[ Info: Power method iteration 1, kinetic energy: 4.69e-06, Ïƒâ¿: -2.04e-01, relative Î”Ïƒ: 9.10e+18\n[ Info: About to start power method iteration 2; kinetic energy: 1.01e-06\n[ Info: Power method iteration 2, kinetic energy: 5.95e-06, Ïƒâ¿: 5.92e-02, relative Î”Ïƒ: 4.45e+00\n[ Info: About to start power method iteration 3; kinetic energy: 1.03e-06\n[ Info: Power method iteration 3, kinetic energy: 1.38e-05, Ïƒâ¿: 8.67e-02, relative Î”Ïƒ: 3.17e-01\n[ Info: About to start power method iteration 4; kinetic energy: 1.09e-06\n[ Info: Power method iteration 4, kinetic energy: 1.70e-05, Ïƒâ¿: 9.16e-02, relative Î”Ïƒ: 5.33e-02\n[ Info: About to start power method iteration 5; kinetic energy: 1.13e-06\n[ Info: Power method iteration 5, kinetic energy: 1.72e-05, Ïƒâ¿: 9.08e-02, relative Î”Ïƒ: 8.27e-03\n[ Info: About to start power method iteration 6; kinetic energy: 1.13e-06\n[ Info: Power method iteration 6, kinetic energy: 1.72e-05, Ïƒâ¿: 9.08e-02, relative Î”Ïƒ: 1.33e-04\n[ Info: Power iterations converged! Estimated growth rate: 0.09082625126792908\n","category":"page"},{"location":"literated/kelvin_helmholtz_instability/#Powerful-convergence","page":"Kelvin-Helmholtz instability","title":"Powerful convergence","text":"","category":"section"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"We animate the power method steps. A scatter plot illustrates how the growth rate converges as the power method iterates.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"n = Observable(1)\n\nfig = Figure(size=(800, 600))\n\nkwargs = (xlabel=\"x\", ylabel=\"z\", limits = ((-5, 5), (-5, 5)), aspect=1)\n\nÏ‰_title(t) = t === nothing ? @sprintf(\"vorticity\") : @sprintf(\"vorticity at t = %.2f\", t)\nb_title(t) = t === nothing ? @sprintf(\"buoyancy\")  : @sprintf(\"buoyancy at t = %.2f\", t)\n\nax_Ï‰ = Axis(fig[2, 1]; title = Ï‰_title(nothing), kwargs...)\n\nax_b = Axis(fig[2, 3]; title = b_title(nothing), kwargs...)\n\nÏ‰â‚™ = @lift power_method_data[$n].Ï‰\nbâ‚™ = @lift power_method_data[$n].b\n\nÏƒâ‚™ = @lift [(i-1, i==1 ? NaN : growth_rates[i-1]) for i in 1:$n]\n\nÏ‰_lims = @lift (-maximum(abs, power_method_data[$n].Ï‰), maximum(abs, power_method_data[$n].Ï‰))\nb_lims = @lift (-maximum(abs, power_method_data[$n].b), maximum(abs, power_method_data[$n].b))\n\nhm_Ï‰ = heatmap!(ax_Ï‰, Ï‰â‚™; colorrange = Ï‰_lims, colormap = :balance)\nColorbar(fig[2, 2], hm_Ï‰)\n\nhm_b = heatmap!(ax_b, bâ‚™; colorrange = b_lims, colormap = :balance)\nColorbar(fig[2, 4], hm_b)\n\neigentitle(Ïƒ, t) = length(Ïƒ) > 0 ? @sprintf(\"Iteration #%i; growth rate %.2e\", length(Ïƒ), Ïƒ[end]) : @sprintf(\"Initial perturbation fields\")\nÏƒ_title = @lift eigentitle(power_method_data[$n].Ïƒ, nothing)\n\nax_Ïƒ = Axis(fig[1, :];\n            xlabel = \"Power iteration\",\n            ylabel = \"Growth rate\",\n            title = Ïƒ_title,\n            xticks = 1:length(power_method_data)-1,\n            limits = ((0.5, length(power_method_data)-0.5), (-0.25, 0.25)))\n\nscatter!(ax_Ïƒ, Ïƒâ‚™; color = :blue)\n\nframes = 1:length(power_method_data)\n\nrecord(fig, \"powermethod.mp4\", frames, framerate=1) do i\n    n[] = i\nend\n","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"(Image: )","category":"page"},{"location":"literated/kelvin_helmholtz_instability/#Now-for-the-fun-part","page":"Kelvin-Helmholtz instability","title":"Now for the fun part","text":"","category":"section"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Now we simulate the nonlinear evolution of the eigenmode we've isolated for a few e-folding times 1sigma,","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"# Reset the clock\nmodel.clock.iteration = 0\nmodel.clock.time = 0\n\nestimated_growth_rate = growth_rates[end]\n\nsimulation.stop_time = 5 / estimated_growth_rate\nsimulation.stop_iteration = 9.1e18 # pretty big (not Inf tho)\n\n# Rescale the eigenmode\ninitial_eigenmode_energy = 5e-5\nrescale!(simulation.model, mean_perturbation_kinetic_energy, target_kinetic_energy=initial_eigenmode_energy)","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Let's save and plot the perturbation vorticity and buoyancy and also the total vorticity and buoyancy (perturbation + basic state). It'll be also neat to plot the kinetic energy time-series and confirm it grows with the estimated growth rate.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"total_vorticity = Field(âˆ‚z(u) + âˆ‚z(model.background_fields.velocities.u) - âˆ‚x(w))\n\ntotal_b = Field(b + model.background_fields.tracers.b)\n\nsimulation.output_writers[:vorticity] =\n    JLD2Writer(model, (Ï‰=perturbation_vorticity, Î©=total_vorticity, b=b, B=total_b, KE=mean_perturbation_kinetic_energy),\n               schedule = TimeInterval(0.10 / estimated_growth_rate),\n               filename = \"kelvin_helmholtz_instability.jld2\",\n               overwrite_existing = true)","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"JLD2Writer scheduled on TimeInterval(1.101 seconds):\nâ”œâ”€â”€ filepath: kelvin_helmholtz_instability.jld2\nâ”œâ”€â”€ 5 outputs: (Ï‰, Î©, b, B, KE)\nâ”œâ”€â”€ array_type: Array{Float32}\nâ”œâ”€â”€ including: [:grid, :coriolis, :buoyancy, :closure]\nâ”œâ”€â”€ file_splitting: NoFileSplitting\nâ””â”€â”€ file size: 43.3 KiB","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"And now we...","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"@info \"*** Running a simulation of Kelvin-Helmholtz instability...\"\nrun!(simulation)","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"[ Info: *** Running a simulation of Kelvin-Helmholtz instability...\n","category":"page"},{"location":"literated/kelvin_helmholtz_instability/#Pretty-things","page":"Kelvin-Helmholtz instability","title":"Pretty things","text":"","category":"section"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"First we plot the nonlinear equilibration of the perturbation fields together with the evolution of the kinetic energy,","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"@info \"Making a neat movie of stratified shear flow...\"\n\nfilepath = simulation.output_writers[:vorticity].filepath\n\nÏ‰_timeseries = FieldTimeSeries(filepath, \"Ï‰\")\nb_timeseries = FieldTimeSeries(filepath, \"b\")\nÎ©_timeseries = FieldTimeSeries(filepath, \"Î©\")\nB_timeseries = FieldTimeSeries(filepath, \"B\")\nKE_timeseries = FieldTimeSeries(filepath, \"KE\")\n\ntimes = Ï‰_timeseries.times\n\nt_final = times[end]\n\nn = Observable(1)\n\nÏ‰â‚™ = @lift Ï‰_timeseries[$n]\nbâ‚™ = @lift b_timeseries[$n]\n\nfig = Figure(size=(800, 600))\n\nkwargs = (xlabel=\"x\", ylabel=\"z\", limits = ((-5, 5), (-5, 5)), aspect=1)\n\ntitle = @lift @sprintf(\"t = %.2f\", times[$n])\n\nax_Ï‰ = Axis(fig[2, 1]; title = \"perturbation vorticity\", kwargs...)\n\nax_b = Axis(fig[2, 3]; title = \"perturbation buoyancy\", kwargs...)\n\nax_KE = Axis(fig[3, :];\n             yscale = log10,\n             limits = ((0, t_final), (initial_eigenmode_energy, 1e-1)),\n             xlabel = \"time\")\n\nfig[1, :] = Label(fig, title, fontsize=24, tellwidth=false)\n\nÏ‰_lims = @lift (-maximum(abs, Ï‰_timeseries[$n]), maximum(abs, Ï‰_timeseries[$n]))\nb_lims = @lift (-maximum(abs, b_timeseries[$n]), maximum(abs, b_timeseries[$n]))\n\nhm_Ï‰ = heatmap!(ax_Ï‰, Ï‰â‚™; colorrange = Ï‰_lims, colormap = :balance)\nColorbar(fig[2, 2], hm_Ï‰)\n\nhm_b = heatmap!(ax_b, bâ‚™; colorrange = b_lims, colormap = :balance)\nColorbar(fig[2, 4], hm_b)\n\ntâ‚™ = @lift times[1:$n]\nKEâ‚™ = @lift KE_timeseries[1:$n]\n\nlines!(ax_KE, [0, t_final], @. initial_eigenmode_energy * exp(2 * estimated_growth_rate * [0, t_final]);\n       label = \"~ exp(2 Ïƒ t)\",\n       linewidth = 2,\n       color = :black)\n\nlines!(ax_KE, times, KE_timeseries[:];\n       label = \"perturbation kinetic energy\",\n       linewidth = 4, color = :blue, alpha = 0.4)\n\nKE_point = @lift Point2f[(times[$n], KE_timeseries[$n][1, 1, 1])]\n\nscatter!(ax_KE, KE_point;\n         marker = :circle, markersize = 16, color = :blue)\n\nframes = 1:length(times)\n\nrecord(fig, \"kelvin_helmholtz_instability_perturbations.mp4\", frames, framerate=8) do i\n    @info \"Plotting frame $i of $(frames[end])...\"\n    n[] = i\nend","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"[ Info: Making a neat movie of stratified shear flow...\n[ Info: Plotting frame 1 of 51...\n[ Info: Plotting frame 2 of 51...\n[ Info: Plotting frame 3 of 51...\n[ Info: Plotting frame 4 of 51...\n[ Info: Plotting frame 5 of 51...\n[ Info: Plotting frame 6 of 51...\n[ Info: Plotting frame 7 of 51...\n[ Info: Plotting frame 8 of 51...\n[ Info: Plotting frame 9 of 51...\n[ Info: Plotting frame 10 of 51...\n[ Info: Plotting frame 11 of 51...\n[ Info: Plotting frame 12 of 51...\n[ Info: Plotting frame 13 of 51...\n[ Info: Plotting frame 14 of 51...\n[ Info: Plotting frame 15 of 51...\n[ Info: Plotting frame 16 of 51...\n[ Info: Plotting frame 17 of 51...\n[ Info: Plotting frame 18 of 51...\n[ Info: Plotting frame 19 of 51...\n[ Info: Plotting frame 20 of 51...\n[ Info: Plotting frame 21 of 51...\n[ Info: Plotting frame 22 of 51...\n[ Info: Plotting frame 23 of 51...\n[ Info: Plotting frame 24 of 51...\n[ Info: Plotting frame 25 of 51...\n[ Info: Plotting frame 26 of 51...\n[ Info: Plotting frame 27 of 51...\n[ Info: Plotting frame 28 of 51...\n[ Info: Plotting frame 29 of 51...\n[ Info: Plotting frame 30 of 51...\n[ Info: Plotting frame 31 of 51...\n[ Info: Plotting frame 32 of 51...\n[ Info: Plotting frame 33 of 51...\n[ Info: Plotting frame 34 of 51...\n[ Info: Plotting frame 35 of 51...\n[ Info: Plotting frame 36 of 51...\n[ Info: Plotting frame 37 of 51...\n[ Info: Plotting frame 38 of 51...\n[ Info: Plotting frame 39 of 51...\n[ Info: Plotting frame 40 of 51...\n[ Info: Plotting frame 41 of 51...\n[ Info: Plotting frame 42 of 51...\n[ Info: Plotting frame 43 of 51...\n[ Info: Plotting frame 44 of 51...\n[ Info: Plotting frame 45 of 51...\n[ Info: Plotting frame 46 of 51...\n[ Info: Plotting frame 47 of 51...\n[ Info: Plotting frame 48 of 51...\n[ Info: Plotting frame 49 of 51...\n[ Info: Plotting frame 50 of 51...\n[ Info: Plotting frame 51 of 51...\n","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"(Image: )","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"And then the same for total vorticity & buoyancy of the fluid.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"n = Observable(1)\n\nÎ©â‚™ = @lift Î©_timeseries[$n]\nBâ‚™ = @lift B_timeseries[$n]\n\nfig = Figure(size=(800, 600))\n\nkwargs = (xlabel=\"x\", ylabel=\"z\", limits = ((-5, 5), (-5, 5)), aspect=1)\n\ntitle = @lift @sprintf(\"t = %.2f\", times[$n])\n\nax_Î© = Axis(fig[2, 1]; title = \"total vorticity\", kwargs...)\n\nax_B = Axis(fig[2, 3]; title = \"total buoyancy\", kwargs...)\n\nax_KE = Axis(fig[3, :];\n             yscale = log10,\n             limits = ((0, t_final), (initial_eigenmode_energy, 1e-1)),\n             xlabel = \"time\")\n\nfig[1, :] = Label(fig, title, fontsize=24, tellwidth=false)\n\nhm_Î© = heatmap!(ax_Î©, Î©â‚™; colorrange = (-1, 1), colormap = :balance)\nColorbar(fig[2, 2], hm_Î©)\n\nhm_B = heatmap!(ax_B, Bâ‚™; colorrange = (-0.05, 0.05), colormap = :balance)\nColorbar(fig[2, 4], hm_B)\n\ntâ‚™ = @lift times[1:$n]\nKEâ‚™ = @lift KE_timeseries[1, 1, 1, 1:$n]\n\nlines!(ax_KE, [0, t_final], @. initial_eigenmode_energy * exp(2 * estimated_growth_rate * [0, t_final]);\n       label = \"~ exp(2 Ïƒ t)\",\n       linewidth = 2,\n       color = :black)\n\nlines!(ax_KE, times, KE_timeseries[:];\n       label = \"perturbation kinetic energy\",\n       linewidth = 4, color = :blue, alpha = 0.4)\n\nKE_point = @lift Point2f[(times[$n], KE_timeseries[$n][1, 1, 1])]\n\nscatter!(ax_KE, KE_point;\n         marker = :circle, markersize = 16, color = :blue)\n\naxislegend(ax_KE; position = :rb)\n\nrecord(fig, \"kelvin_helmholtz_instability_total.mp4\", frames, framerate=8) do i\n    n[] = i\nend","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"(Image: )","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"This page was generated using Literate.jl.","category":"page"},{"location":"model_setup/checkpointing/#checkpointing","page":"Checkpointing","title":"Checkpointing","text":"","category":"section"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"A Checkpointer can be used to serialize the entire model state to a file from which the model can be restored at any time. This is useful if you'd like to periodically checkpoint when running long simulations in case of crashes or hitting cluster time limits, but also if you'd like to restore from a checkpoint and try out multiple scenarios.","category":"page"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"For example, to periodically checkpoint the model state to disk every 1,000,000 seconds of simulation time to files of the form model_checkpoint_iteration12500.jld2 where 12500 is the iteration number (automatically filled in).","category":"page"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"Here's an example where we checkpoint every 5 iterations. This is far more often than appropriate for typical applications: we only do it here for illustration purposes.","category":"page"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"using Oceananigans\n\nmodel = NonhydrostaticModel(grid=RectilinearGrid(size=(8, 8, 8), extent=(1, 1, 1)))\n\nsimulation = Simulation(model, Î”t=1, stop_iteration=8)\n\nsimulation.output_writers[:checkpointer] = Checkpointer(model, schedule=IterationInterval(5), prefix=\"model_checkpoint\")","category":"page"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"Again, for illustration purposes of this example, we also add another callback so we can see the iteration of the simulation","category":"page"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"show_iteration(sim) = @info \"iteration: $(iteration(sim)); time: $(prettytime(sim.model.clock.time))\"\nadd_callback!(simulation, show_iteration, name=:info, IterationInterval(1))","category":"page"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"Now let's run","category":"page"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"run!(simulation)","category":"page"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"The default options should provide checkpoint files that are easy to restore from (in most cases). For more advanced options and features, see Checkpointer.","category":"page"},{"location":"model_setup/checkpointing/#Picking-up-a-simulation-from-a-checkpoint-file","page":"Checkpointing","title":"Picking up a simulation from a checkpoint file","text":"","category":"section"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"Picking up a simulation from a checkpoint requires the original script that was used to generate the checkpoint data. Change the first instance of run! in the script to take pickup=true.","category":"page"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"When pickup=true is provided to run! then it finds the latest checkpoint file in the current working directory, loads prognostic fields and their tendencies from file, resets the model clock and iteration, to the clock time and iteration that the checkpoint corresponds to, and updates the model auxiliary state. After that, the time-stepping loop. In this simple example, although the simulation run up to iteration 8, the latest checkpoint is associated with iteration 5.","category":"page"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"simulation.stop_iteration = 12\n\nrun!(simulation, pickup=true)","category":"page"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"Use pickup=iteration, where iteration is an Integer, to pick up from a specific iteration. Or, use pickup=filepath, where filepath is a string, to pickup from a specific file located at filepath.","category":"page"},{"location":"model_setup/forcing_functions/#forcing_functions","page":"Forcing functions","title":"Forcing functions","text":"","category":"section"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"\"Forcings\" are user-defined terms appended to right-hand side of the momentum or tracer evolution equations. In Oceananigans, momentum and tracer forcings are defined via julia functions. Oceananigans includes an interface for implementing forcing functions that depend on spatial coordinates, time, model velocity and tracer fields, and external parameters.","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"Forcings are added to models by passing a NamedTuple of functions or forcing objects to the forcing keyword argument in NonhydrostaticModel's constructor. By default, momentum and tracer forcing functions are assumed to be functions of x, y, z, t. A basic example is","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"u_forcing(x, y, z, t) = exp(z) * cos(x) * sin(t)\n\ngrid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))\nmodel = NonhydrostaticModel(grid=grid, forcing=(u=u_forcing,))\n\nmodel.forcing.u\n\n# output\nContinuousForcing{Nothing} at (Face, Center, Center)\nâ”œâ”€â”€ func: u_forcing (generic function with 1 method)\nâ”œâ”€â”€ parameters: nothing\nâ””â”€â”€ field dependencies: ()","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"More general forcing functions are built via the Forcing constructor described below. Oceananigans also provides two convenience types:","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"Relaxation for damping terms that restore a field to a target distribution outside of a masked region of space. Relaxation can be used to implement sponge layers near the boundaries of a domain.\nAdvectiveForcing for advecting individual quantities by a separate or \"slip\" velocity relative to both the prognostic model velocity field and any BackgroundField velocity field.","category":"page"},{"location":"model_setup/forcing_functions/#The-Forcing-constructor","page":"Forcing functions","title":"The Forcing constructor","text":"","category":"section"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"The Forcing constructor provides an interface for specifying forcing functions that","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"Depend on external parameters; and\nDepend on model fields at the x, y, z location that forcing is applied; and/or\nRequire access to discrete model data.","category":"page"},{"location":"model_setup/forcing_functions/#Forcing-functions-with-external-parameters","page":"Forcing functions","title":"Forcing functions with external parameters","text":"","category":"section"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"Most forcings involve external, changeable parameters. Here are two examples of forcing_functions that depend on (i) a single scalar parameter s, and (ii) a NamedTuple of parameters, p:","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"# Forcing that depends on a scalar parameter `s`\nu_forcing_func(x, y, z, t, s) = s * z\n\nu_forcing = Forcing(u_forcing_func, parameters=0.1)\n\n# Forcing that depends on a `NamedTuple` of parameters `p`\nT_forcing_func(x, y, z, t, p) = - p.Î¼ * exp(z / p.Î») * cos(p.k * x) * sin(p.Ï‰ * t)\n\nT_forcing = Forcing(T_forcing_func, parameters=(Î¼=1, Î»=0.5, k=2Ï€, Ï‰=4Ï€))\n\ngrid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))\nmodel = NonhydrostaticModel(grid=grid, forcing=(u=u_forcing, T=T_forcing), buoyancy=SeawaterBuoyancy(), tracers=(:T, :S))\n\nmodel.forcing.T\n\n# output\nContinuousForcing{@NamedTuple{Î¼::Int64, Î»::Float64, k::Float64, Ï‰::Float64}} at (Center, Center, Center)\nâ”œâ”€â”€ func: T_forcing_func (generic function with 1 method)\nâ”œâ”€â”€ parameters: (Î¼ = 1, Î» = 0.5, k = 6.283185307179586, Ï‰ = 12.566370614359172)\nâ””â”€â”€ field dependencies: ()","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"model.forcing.u\n\n# output\nContinuousForcing{Float64} at (Face, Center, Center)\nâ”œâ”€â”€ func: u_forcing_func (generic function with 1 method)\nâ”œâ”€â”€ parameters: 0.1\nâ””â”€â”€ field dependencies: ()","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"In this example, the objects passed to the parameters keyword in the construction of u_forcing and T_forcing â€“ a floating point number for u_forcing, and a NamedTuple of parameters for T_forcing â€“ are passed on to u_forcing_func and T_forcing_func when they are called during time-stepping. The object passed to parameters is in principle arbitrary. However, if using the GPU, then typeof(parameters) may be restricted by the requirements of GPU-compiliability.","category":"page"},{"location":"model_setup/forcing_functions/#Forcing-functions-that-depend-on-model-fields","page":"Forcing functions","title":"Forcing functions that depend on model fields","text":"","category":"section"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"Forcing functions may depend on model fields (velocity, tracers or auxiliary fields) evaluated at the x, y, z where forcing is applied. Here's a somewhat non-sensical example:","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"# Forcing that depends on the velocity fields `u`, `v`, and `w`\nw_forcing_func(x, y, z, t, u, v, w) = - (u^2 + v^2 + w^2) / 2\n\nw_forcing = Forcing(w_forcing_func, field_dependencies=(:u, :v, :w))\n\n# Forcing that depends on salinity `S` and a scalar parameter\nS_forcing_func(x, y, z, t, S, Î¼) = - Î¼ * S\n\nS_forcing = Forcing(S_forcing_func, parameters=0.01, field_dependencies=:S)\n\ngrid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))\nmodel = NonhydrostaticModel(grid=grid, forcing=(w=w_forcing, S=S_forcing), buoyancy=SeawaterBuoyancy(), tracers=(:T, :S))\n\nmodel.forcing.w\n\n# output\nContinuousForcing{Nothing} at (Center, Center, Face)\nâ”œâ”€â”€ func: w_forcing_func (generic function with 1 method)\nâ”œâ”€â”€ parameters: nothing\nâ””â”€â”€ field dependencies: (:u, :v, :w)","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"model.forcing.S\n\n# output\nContinuousForcing{Float64} at (Center, Center, Center)\nâ”œâ”€â”€ func: S_forcing_func (generic function with 1 method)\nâ”œâ”€â”€ parameters: 0.01\nâ””â”€â”€ field dependencies: (:S,)","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"The field_dependencies arguments follow x, y, z, t in the forcing function in the order they are specified in Forcing. If both field_dependencies and parameters are specified, then the field_dependencies arguments follow x, y, z, t, and parameters follow field_dependencies.","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"Model fields that arise in the arguments of continuous Forcing functions are automatically interpolated to the staggered grid location at which the forcing is applied.","category":"page"},{"location":"model_setup/forcing_functions/#\"Discrete-form\"-forcing-functions","page":"Forcing functions","title":"\"Discrete form\" forcing functions","text":"","category":"section"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"\"Discrete form\" forcing functions are either called with the signature","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"func(i, j, k, grid, clock, model_fields)","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"or the parameterized form","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"func(i, j, k, grid, clock, model_fields, parameters)","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"Discrete form forcing functions can access the entirety of model field data through the argument model_fields. The object model_fields is a NamedTuple whose properties include the velocity fields model_fields.u, model_fields.v, model_fields.w and all fields in model.tracers.","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"Using discrete forcing functions may require understanding the staggered arrangement of velocity fields and tracers in Oceananigans. Here's a slightly non-sensical example in which the vertical derivative of a buoyancy tracer is used as a time-scale for damping the u-velocity field:","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"# A damping term that depends on a \"local average\":\nlocal_average(i, j, k, grid, c) = @inbounds (c[i, j, k] + c[i-1, j, k] + c[i+1, j, k] +\n                                                          c[i, j-1, k] + c[i, j+1, k] +\n                                                          c[i, j, k-1] + c[i, j, k+1]) / 7\n\nb_forcing_func(i, j, k, grid, clock, model_fields) = - local_average(i, j, k, grid, model_fields.b)\n\nb_forcing = Forcing(b_forcing_func, discrete_form=true)\n\n# A term that damps the local velocity field in the presence of stratification\nusing Oceananigans.Operators: âˆ‚zá¶ á¶œá¶ , â„‘xzá¶ áµƒá¶œ\n\nfunction u_forcing_func(i, j, k, grid, clock, model_fields, Îµ)\n    # The vertical derivative of buoyancy, interpolated to the u-velocity location:\n    NÂ² = â„‘xzá¶ áµƒá¶œ(i, j, k, grid, âˆ‚zá¶ á¶œá¶ , model_fields.b)\n\n    # Set to zero in unstable stratification where NÂ² < 0:\n    NÂ² = max(NÂ², zero(typeof(NÂ²)))\n\n    return @inbounds - Îµ * sqrt(NÂ²) * model_fields.u[i, j, k]\nend\n\nu_forcing = Forcing(u_forcing_func, discrete_form=true, parameters=1e-3)\n\ngrid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))\nmodel = NonhydrostaticModel(grid=grid, tracers=:b, buoyancy=BuoyancyTracer(), forcing=(u=u_forcing, b=b_forcing))\n\nmodel.forcing.b\n\n# output\nDiscreteForcing{Nothing}\nâ”œâ”€â”€ func: b_forcing_func (generic function with 1 method)\nâ””â”€â”€ parameters: nothing","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"model.forcing.u\n\n# output\nDiscreteForcing{Float64}\nâ”œâ”€â”€ func: u_forcing_func (generic function with 1 method)\nâ””â”€â”€ parameters: 0.001","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"The annotation @inbounds is crucial for performance when accessing array indices of the fields in model_fields.","category":"page"},{"location":"model_setup/forcing_functions/#Relaxation","page":"Forcing functions","title":"Relaxation","text":"","category":"section"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"Relaxation defines a special forcing function that restores a field at a specified rate to a target distribution, within a region uncovered by a masking function. Relaxation is useful for implementing sponge layers, as shown in the second example.","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"The following code constructs a model in which all components of the velocity field are damped to zero everywhere on a time-scale of 1000 seconds, or ~17 minutes:","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"damping = Relaxation(rate = 1/1000)\n\ngrid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))\nmodel = NonhydrostaticModel(grid=grid, forcing=(u=damping, v=damping, w=damping))\n\nmodel.forcing.w\n\n# output\nContinuousForcing{Nothing} at (Center, Center, Face)\nâ”œâ”€â”€ func: Relaxation(rate=0.001, mask=1, target=0)\nâ”œâ”€â”€ parameters: nothing\nâ””â”€â”€ field dependencies: (:w,)","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"The constructor for Relaxation accepts the keyword arguments mask, and target, which specify a mask(x, y, z) function that multiplies the forcing, and a target(x, y, z) distribution for the quantity in question. By default, mask uncovered the whole domain and target restores the field in question to 0","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"We illustrate usage of mask and target by implementing a sponge layer that relaxes velocity fields to zero and restores temperature to a linear gradient in the bottom 1/10th of the domain:","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"grid = RectilinearGrid(size=(1, 1, 1), x=(0, 1), y=(0, 1), z=(-1, 0))\n\n        damping_rate = 1/100 # relax fields on a 100 second time-scale\ntemperature_gradient = 0.001 # â°C mâ»Â¹\n surface_temperature = 20    # â°C (at z=0)\n\ntarget_temperature = LinearTarget{:z}(intercept=surface_temperature, gradient=temperature_gradient)\n       bottom_mask = GaussianMask{:z}(center=-grid.Lz, width=grid.Lz/10)\n\nuvw_sponge = Relaxation(rate=damping_rate, mask=bottom_mask)\n  T_sponge = Relaxation(rate=damping_rate, mask=bottom_mask, target=target_temperature)\n\nmodel = NonhydrostaticModel(grid=grid, forcing=(u=uvw_sponge, v=uvw_sponge, w=uvw_sponge, T=T_sponge), buoyancy=SeawaterBuoyancy(), tracers=(:T, :S))\n\nmodel.forcing.u\n\n# output\nContinuousForcing{Nothing} at (Face, Center, Center)\nâ”œâ”€â”€ func: Relaxation(rate=0.01, mask=exp(-(z + 1.0)^2 / (2 * 0.1^2)), target=0)\nâ”œâ”€â”€ parameters: nothing\nâ””â”€â”€ field dependencies: (:u,)","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"model.forcing.T\n\n# output\nContinuousForcing{Nothing} at (Center, Center, Center)\nâ”œâ”€â”€ func: Relaxation(rate=0.01, mask=exp(-(z + 1.0)^2 / (2 * 0.1^2)), target=20.0 + 0.001 * z)\nâ”œâ”€â”€ parameters: nothing\nâ””â”€â”€ field dependencies: (:T,)","category":"page"},{"location":"model_setup/forcing_functions/#AdvectiveForcing","page":"Forcing functions","title":"AdvectiveForcing","text":"","category":"section"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"AdvectiveForcing defines a forcing function that represents advection by a separate or \"slip\" velocity relative to the prognostic model velocity field. AdvectiveForcing is implemented with native Oceananigans advection operators, which means that tracers advected by the \"flux form\" advection term ğ®_rm slip c. Caution is advised when ğ®_rm slip is not divergence free.","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"As an example, consider a model for sediment settling at a constant rate:","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"using Oceananigans\n\nr_sediment = 1e-4 # [m] \"Fine sand\"\nÏ_sediment = 1200 # kg mâ»Â³\nÏ_ocean = 1026 # kg mâ»Â³\nÎ”b = 9.81 * (Ï_ocean - Ï_sediment) / Ï_ocean # m sâ»Â²\nÎ½_molecular = 1.05e-6 # mÂ² sâ»Â¹\nw_sediment = 2/9 * Î”b / Î½_molecular * r_sediment^2 # m sâ»Â¹\n\nsinking = AdvectiveForcing(w=w_sediment)\n\n# output\nAdvectiveForcing:\nâ”œâ”€â”€ u: ZeroField{Int64}\nâ”œâ”€â”€ v: ZeroField{Int64}\nâ””â”€â”€ w: ConstantField(-0.00352102)","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"The three keyword arguments specify the u, v, and w components of the separate slip velocity field. The default for each u, v, w is ZeroField.","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"Next we consider a dynamically-evolving slip velocity. For this we use ZFaceField with appropriate boundary conditions as our slip velocity:","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"using Oceananigans\nusing Oceananigans.BoundaryConditions: ImpenetrableBoundaryCondition\n\ngrid = RectilinearGrid(size=(32, 32, 32), x=(-10, 10), y=(-10, 10), z=(-4, 4),\n                       topology=(Periodic, Periodic, Bounded))\n\nno_penetration = ImpenetrableBoundaryCondition()\nslip_bcs = FieldBoundaryConditions(grid, (Center, Center, Face),\n                                   top=no_penetration, bottom=no_penetration)\n\nw_slip = ZFaceField(grid, boundary_conditions=slip_bcs)\nsinking = AdvectiveForcing(w=w_slip)\n\n# output\nAdvectiveForcing:\nâ”œâ”€â”€ u: ZeroField{Int64}\nâ”œâ”€â”€ v: ZeroField{Int64}\nâ””â”€â”€ w: 32Ã—32Ã—33 Field{Center, Center, Face} on RectilinearGrid on CPU","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"To compute the slip velocity, we must add a Callbackto simulations.callback that computes w_slip ever iteration:","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"using Oceananigans.BoundaryConditions: fill_halo_regions!\n\nmodel = NonhydrostaticModel(; grid, tracers=(:b, :P), forcing=(; P=sinking))\nsimulation = Simulation(model; Î”t=1, stop_iteration=100)\n\n# Build abstract operation for slip velocity\nb_particle = - 1e-4 # relative buoyancy depends on reference density and initial buoyancy condition\nb = model.tracers.b\nR = 1e-3 # [m] mean particle radius\nÎ½ = 1.05e-6 # [mÂ² sâ»Â¹] molecular kinematic viscosity of water\nw_slip_op = 2/9 * (b - b_particle) / Î½ * R^2 # Stokes terminal velocity\n\nfunction compute_slip_velocity!(sim)\n    w_slip .= w_slip_op\n    fill_halo_regions!(w_slip)\n    return nothing\nend\n\nsimulation.callbacks[:slip] = Callback(compute_slip_velocity!)\n\n# output\nCallback of compute_slip_velocity! on IterationInterval(1)","category":"page"},{"location":"literated/internal_wave/#Internal-wave-example","page":"Internal wave","title":"Internal wave example","text":"","category":"section"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"In this example, we initialize an internal wave packet in two-dimensions and watch it propagate. This example illustrates how to set up a two-dimensional model, set initial conditions, and how to use BackgroundFields.","category":"page"},{"location":"literated/internal_wave/#Install-dependencies","page":"Internal wave","title":"Install dependencies","text":"","category":"section"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"using Pkg\npkg\"add Oceananigans, CairoMakie\"","category":"page"},{"location":"literated/internal_wave/#The-physical-domain","page":"Internal wave","title":"The physical domain","text":"","category":"section"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"First, we pick a resolution and domain size. We use a two-dimensional domain that's periodic in (x z) and is Flat in y:","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"using Oceananigans\n\ngrid = RectilinearGrid(size=(128, 128), x=(-Ï€, Ï€), z=(-Ï€, Ï€), topology=(Periodic, Flat, Periodic))","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"128Ã—1Ã—128 RectilinearGrid{Float64, Periodic, Flat, Periodic} on CPU with 3Ã—0Ã—3 halo\nâ”œâ”€â”€ Periodic x âˆˆ [-3.14159, 3.14159) regularly spaced with Î”x=0.0490874\nâ”œâ”€â”€ Flat y                           \nâ””â”€â”€ Periodic z âˆˆ [-3.14159, 3.14159) regularly spaced with Î”z=0.0490874","category":"page"},{"location":"literated/internal_wave/#Internal-wave-parameters","page":"Internal wave","title":"Internal wave parameters","text":"","category":"section"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"Inertia-gravity waves propagate in fluids that are both (i) rotating, and (ii) density-stratified. We use Oceananigans' Coriolis abstraction to implement a background rotation rate:","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"coriolis = FPlane(f=0.2)","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"FPlane{Float64}(f=0.2)","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"On an FPlane, the domain is idealized as rotating at a constant rate with rotation period 2Ï€/f. coriolis is passed to NonhydrostaticModel below. Our units are arbitrary.","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"We use Oceananigans' background_fields abstraction to define a background buoyancy field B(z) = N^2 * z, where z is the vertical coordinate and N is the \"buoyancy frequency\". This means that the modeled buoyancy field perturbs the basic state B(z).","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"# Background fields are functions of `x, y, z, t`, and optional parameters.\n# Here we have one parameter, the buoyancy frequency\n\nN = 1       # buoyancy frequency [sâ»Â¹]\nB_func(x, z, t, N) = N^2 * z\nB = BackgroundField(B_func, parameters=N)","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"BackgroundField{typeof(Main.var\"##2584\".B_func), Int64}\nâ”œâ”€â”€ func: B_func (generic function with 1 method)\nâ””â”€â”€ parameters: 1","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"We are now ready to instantiate our model. We pass grid, coriolis, and B to the NonhydrostaticModel constructor. We add a small amount of IsotropicDiffusivity to keep the model stable during time-stepping, and specify that we're using a single tracer called b that we identify as buoyancy by setting buoyancy=BuoyancyTracer().","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"model = NonhydrostaticModel(; grid, coriolis,\n                            advection = Centered(order=4),\n                            closure = ScalarDiffusivity(Î½=1e-6, Îº=1e-6),\n                            tracers = :b,\n                            buoyancy = BuoyancyTracer(),\n                            background_fields = (; b=B)) # `background_fields` is a `NamedTuple`","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 128Ã—1Ã—128 RectilinearGrid{Float64, Periodic, Flat, Periodic} on CPU with 3Ã—0Ã—3 halo\nâ”œâ”€â”€ timestepper: RungeKutta3TimeStepper\nâ”œâ”€â”€ advection scheme: Centered(order=4)\nâ”œâ”€â”€ tracers: b\nâ”œâ”€â”€ closure: ScalarDiffusivity{ExplicitTimeDiscretization}(Î½=1.0e-6, Îº=(b=1.0e-6,))\nâ”œâ”€â”€ buoyancy: BuoyancyTracer with gÌ‚ = NegativeZDirection()\nâ””â”€â”€ coriolis: FPlane{Float64}(f=0.2)","category":"page"},{"location":"literated/internal_wave/#A-Gaussian-wavepacket","page":"Internal wave","title":"A Gaussian wavepacket","text":"","category":"section"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"Next, we set up an initial condition that excites an internal wave that propates through our rotating, stratified fluid. This internal wave has the pressure field","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"p(x z t) = a(x z)  cos(k x + m z - Ï‰ t)  ","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"where m is the vertical wavenumber, k is the horizontal wavenumber, Ï‰ is the wave frequncy, and a(x z) is a Gaussian envelope. The internal wave dispersion relation links the wave numbers k and m, the Coriolis parameter f, and the buoyancy frequency N:","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"Non-dimensional internal wave parameters","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"m = 16      # vertical wavenumber\nk = 8       # horizontal wavenumber\nf = coriolis.f\n\n# Dispersion relation for inertia-gravity waves\nÏ‰Â² = (N^2 * k^2 + f^2 * m^2) / (k^2 + m^2)\n\nÏ‰ = sqrt(Ï‰Â²)","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"We define a Gaussian envelope for the wave packet so that we can observe wave propagation.","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"# Some Gaussian parameters\ngaussian_amplitude = 1e-9\ngaussian_width = grid.Lx / 15\n\n# A Gaussian envelope centered at `(x, z) = (0, 0)`\na(x, z) = gaussian_amplitude * exp( -( x^2 + z^2 ) / 2gaussian_width^2 )","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"An inertia-gravity wave is a linear solution to the Boussinesq equations. In order that our initial condition excites an inertia-gravity wave, we initialize the velocity and buoyancy perturbation fields to be consistent with the pressure field p = a  cos(kx + mx - Ï‰t) at t=0. These relations are sometimes called the \"polarization relations\". At t=0, the polarization relations yield","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"uâ‚€(x, z) = a(x, z) * k * Ï‰   / (Ï‰^2 - f^2) * cos(k * x + m * z)\nvâ‚€(x, z) = a(x, z) * k * f   / (Ï‰^2 - f^2) * sin(k * x + m * z)\nwâ‚€(x, z) = a(x, z) * m * Ï‰   / (Ï‰^2 - N^2) * cos(k * x + m * z)\nbâ‚€(x, z) = a(x, z) * m * N^2 / (Ï‰^2 - N^2) * sin(k * x + m * z)\n\nset!(model, u=uâ‚€, v=vâ‚€, w=wâ‚€, b=bâ‚€)","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"Recall that the buoyancy b is a perturbation, so that the total buoyancy field is N^2 z + b.","category":"page"},{"location":"literated/internal_wave/#A-wave-packet-on-the-loose","page":"Internal wave","title":"A wave packet on the loose","text":"","category":"section"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"We're ready to release the packet. We build a simulation with a constant time-step,","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"simulation = Simulation(model, Î”t = 0.1 * 2Ï€/Ï‰, stop_iteration = 20)","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"Simulation of NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ Next time step: 1.304 seconds\nâ”œâ”€â”€ Elapsed wall time: 0 seconds\nâ”œâ”€â”€ Wall time per iteration: NaN days\nâ”œâ”€â”€ Stop time: Inf days\nâ”œâ”€â”€ Stop iteration: 20.0\nâ”œâ”€â”€ Wall time limit: Inf\nâ”œâ”€â”€ Minimum relative step: 0.0\nâ”œâ”€â”€ Callbacks: OrderedDict with 4 entries:\nâ”‚   â”œâ”€â”€ stop_time_exceeded => 4\nâ”‚   â”œâ”€â”€ stop_iteration_exceeded => -\nâ”‚   â”œâ”€â”€ wall_time_limit_exceeded => e\nâ”‚   â””â”€â”€ nan_checker => }\nâ”œâ”€â”€ Output writers: OrderedDict with no entries\nâ””â”€â”€ Diagnostics: OrderedDict with no entries","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"and add an output writer that saves the vertical velocity field every two iterations:","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"filename = \"internal_wave.jld2\"\nsimulation.output_writers[:velocities] = JLD2Writer(model, model.velocities; filename,\n                                                    schedule = IterationInterval(1),\n                                                    overwrite_existing = true)","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"JLD2Writer scheduled on IterationInterval(1):\nâ”œâ”€â”€ filepath: internal_wave.jld2\nâ”œâ”€â”€ 3 outputs: (u, v, w)\nâ”œâ”€â”€ array_type: Array{Float32}\nâ”œâ”€â”€ including: [:grid, :coriolis, :buoyancy, :closure]\nâ”œâ”€â”€ file_splitting: NoFileSplitting\nâ””â”€â”€ file size: 35.5 KiB","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"With initial conditions set and an output writer at the ready, we run the simulation","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"run!(simulation)","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"[ Info: Initializing simulation...\n[ Info:     ... simulation initialization complete (2.173 seconds)\n[ Info: Executing initial time step...\n[ Info:     ... initial time step complete (4.191 seconds).\n[ Info: Simulation is stopping after running for 6.650 seconds.\n[ Info: Model iteration 20 equals or exceeds stop iteration 20.\n","category":"page"},{"location":"literated/internal_wave/#Animating-a-propagating-packet","page":"Internal wave","title":"Animating a propagating packet","text":"","category":"section"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"To animate a the propagating wavepacket we just simulated, we load CairoMakie and make a Figure and an Axis for the animation,","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"using CairoMakie\nset_theme!(Theme(fontsize = 20))\n\nfig = Figure(size = (600, 600))\n\nax = Axis(fig[2, 1]; xlabel = \"x\", ylabel = \"z\",\n          limits = ((-Ï€, Ï€), (-Ï€, Ï€)), aspect = AxisAspect(1))\n","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"Next, we load w data with FieldTimeSeries of w and make contour plots of vertical velocity. We use Makie's Observable to animate the data. To dive into how Observables work, refer to Makie.jl's Documentation.","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"n = Observable(1)\n\nw_timeseries = FieldTimeSeries(filename, \"w\")\nw = @lift w_timeseries[$n]\nw_lim = 1e-8\n\ncontourf!(ax, w;\n          levels = range(-w_lim, stop=w_lim, length=10),\n          colormap = :balance,\n          extendlow = :auto,\n          extendhigh = :auto)\n\ntitle = @lift \"Ï‰t = \" * string(round(w_timeseries.times[$n] * Ï‰, digits=2))\nfig[1, 1] = Label(fig, title, fontsize=24, tellwidth=false)","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"Label()","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"And, finally, we record a movie.","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"using Printf\n\nframes = 1:length(w_timeseries.times)\n\n@info \"Animating a propagating internal wave...\"\n\nrecord(fig, \"internal_wave.mp4\", frames, framerate=8) do i\n    n[] = i\nend","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"[ Info: Animating a propagating internal wave...\n","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"(Image: )","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"This page was generated using Literate.jl.","category":"page"},{"location":"field_time_series/#FieldTimeSeries","page":"FieldTimeSeries","title":"FieldTimeSeries","text":"","category":"section"},{"location":"appendix/function_index/#Index","page":"Function index","title":"Index","text":"","category":"section"},{"location":"appendix/function_index/","page":"Function index","title":"Function index","text":"","category":"page"},{"location":"physics/boussinesq/#boussinesq_approximation","page":"Boussinesq approximation","title":"The Boussinesq approximation","text":"","category":"section"},{"location":"physics/boussinesq/","page":"Boussinesq approximation","title":"Boussinesq approximation","text":"Oceananigans.jl often employs the Boussinesq approximation[1]. In the Boussinesq approximation the fluid density rho is, in general, decomposed into three components:","category":"page"},{"location":"physics/boussinesq/","page":"Boussinesq approximation","title":"Boussinesq approximation","text":"    rho(boldsymbolx t) = rho_0 + rho_*(z) + rho(boldsymbolx t)  ","category":"page"},{"location":"physics/boussinesq/","page":"Boussinesq approximation","title":"Boussinesq approximation","text":"where rho_0 is a constant 'reference' density, rho_*(z) is a background density profile which, when non-zero, is typically associated with the hydrostatic compression of seawater in the deep ocean, and rho(boldsymbolx t) is the dynamic component of density corresponding to inhomogeneous distributions of a buoyant tracer such as temperature or salinity.","category":"page"},{"location":"physics/boussinesq/","page":"Boussinesq approximation","title":"Boussinesq approximation","text":"The fluid buoyancy, associated with the buoyant acceleration of fluid, is defined in terms of rho as","category":"page"},{"location":"physics/boussinesq/","page":"Boussinesq approximation","title":"Boussinesq approximation","text":"    b = - fracg rhorho_0  ","category":"page"},{"location":"physics/boussinesq/","page":"Boussinesq approximation","title":"Boussinesq approximation","text":"where g is gravitational acceleration.","category":"page"},{"location":"physics/boussinesq/","page":"Boussinesq approximation","title":"Boussinesq approximation","text":"The Boussinesq approximation is valid when rho_* + rho ll rho_0, which implies the fluid is approximately incompressible, and thus does not support acoustic waves. In this case, the mass conservation equation reduces to the continuity equation","category":"page"},{"location":"physics/boussinesq/","page":"Boussinesq approximation","title":"Boussinesq approximation","text":"    beginequation\n    boldsymbolnabla boldsymbolcdot boldsymbolv = partial_x u + partial_y v + partial_z w = 0  \n    labeleqcontinuity\n    endequation","category":"page"},{"location":"physics/boussinesq/","page":"Boussinesq approximation","title":"Boussinesq approximation","text":"Similarly, in the the momentum equations we can divide through with rho_0 and use that rho_* + rho ll rho_0 to get:","category":"page"},{"location":"physics/boussinesq/","page":"Boussinesq approximation","title":"Boussinesq approximation","text":"    beginequation\n    partial_t boldsymbolv + boldsymbolv boldsymbolcdot boldsymbolnabla boldsymbolv + dotsb = - frac1rho_0 boldsymbolnabla p - g fracrhorho_0 hatboldsymbolz + dotsb  \n    labeleqmomentum\n    endequation","category":"page"},{"location":"physics/boussinesq/","page":"Boussinesq approximation","title":"Boussinesq approximation","text":"We refer to p  rho_0 as the \"kinematic pressure\" with dimensions of velocity squared. Hereafter, we abuse notation a bit and denote the kinematic pressure simply as p.","category":"page"},{"location":"physics/boussinesq/","page":"Boussinesq approximation","title":"Boussinesq approximation","text":"info: Convention on dynamic versus kinematic pressure\nIn Oceananigans, the pressure p refers to \"kinematic pressure\" (with dimensions velocity squared), i.e., the dynamic pressure scaled with the reference fluid density rho_0.","category":"page"},{"location":"physics/boussinesq/","page":"Boussinesq approximation","title":"Boussinesq approximation","text":"[1]: Named after Boussinesq (1903) although used earlier by Oberbeck (1879), the Boussinesq   approximation neglects density differences in the momentum equation except when associated   with the gravitational term. It is an accurate approximation for many flows, and especially   so for oceanic flows where density differences are very small. See Vallis (2017, section 2.4)   for an oceanographic introduction to the Boussinesq equations and Vallis (2017, Section 2.A)   for an asymptotic derivation. See Kundu (2015, Section 4.9) for an engineering   introduction.","category":"page"},{"location":"numerical_implementation/finite_volume/#finite_volume","page":"Finite volume method","title":"Finite volume method on a staggered grid","text":"","category":"section"},{"location":"numerical_implementation/finite_volume/","page":"Finite volume method","title":"Finite volume method","text":"The Oceananigans.jl staggered grid is defined by a rectilinear array of cuboids of horizontal dimensions Delta x_i j k Delta y_i j k and vertical dimension Delta z_i j k, where (i j k) index the location of each cell in the staggered grid. Note that the indices (i j k) increase with increasing coordinate (x y z).","category":"page"},{"location":"numerical_implementation/finite_volume/","page":"Finite volume method","title":"Finite volume method","text":"(Image: Schematic of staggered grid) A schematic of Oceananigans.jl finite volumes for a two-dimensional staggered grid in (x z). Tracers c and pressure p are defined at the center of the control volume. The u control volumes are centered on the left and right edges of the pressure control volume while the w control volumes are centered on the top and bottom edges of the pressure control volumes. The indexing convention places the i^rmth u-node on cell x-faces to the left of the i tracer point at cell centers.","category":"page"},{"location":"numerical_implementation/finite_volume/","page":"Finite volume method","title":"Finite volume method","text":"Dropping explicit indexing, the areas of cell faces are given by","category":"page"},{"location":"numerical_implementation/finite_volume/","page":"Finite volume method","title":"Finite volume method","text":"    A_x = Delta y Delta z quad A_y = Delta x Delta z quad A_z = Delta x Delta y  ","category":"page"},{"location":"numerical_implementation/finite_volume/","page":"Finite volume method","title":"Finite volume method","text":"so that each cell encloses a volume V = Delta x Delta y Delta z.","category":"page"},{"location":"numerical_implementation/finite_volume/","page":"Finite volume method","title":"Finite volume method","text":"A finite volume method discretizes a continuous quantity c by considering its average over a finite volume:","category":"page"},{"location":"numerical_implementation/finite_volume/","page":"Finite volume method","title":"Finite volume method","text":"    c_i j k equiv frac1V_i j k int c(boldsymbolx)  mathrmd V_i j k  ","category":"page"},{"location":"numerical_implementation/finite_volume/","page":"Finite volume method","title":"Finite volume method","text":"The finite volumes that discretize each of u, v, and w are located on a grid which is \"staggered\" with respect to the grid that defines tracer finite volumes. The nodes, or central points of the velocity finite volumes are co-located with the faces of the tracer finite volume. In particular, the u-nodes are located in the center of the \"x-face\" (east of the tracer point), v-nodes are located on y-faces south of the tracer point, and w-nodes are located on z-faces downwards from the tracer point.","category":"page"},{"location":"grids/#grids_tutorial","page":"Grids","title":"Grids","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"Oceananigans simulates the dynamics of ocean-flavored fluids by solving equations that conserve momentum, mass, and energy on a grid of finite volumes or \"cells\". The first decision we make when setting up a simulation is: on what grid are we going to run our simulation? The \"grid\" captures the","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"The geometry of the physical domain;\nThe way that domain is divided into a mesh of finite volumes;\nThe machine architecture (CPU, GPU, lots of CPUs or lots of GPUs); and\nThe precision of floating point numbers (double precision or single precision).","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"We start by making a simple grid that divides a three-dimensional rectangular domain â€“ \"a box\" â€“ into evenly-spaced cells,","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"using Oceananigans\n\ngrid = RectilinearGrid(topology = (Periodic, Periodic, Bounded),\n                       size = (16, 8, 4),\n                       x = (0, 64),\n                       y = (0, 32),\n                       z = (0, 8))\n\n# output\n16Ã—8Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ Periodic x âˆˆ [0.0, 64.0) regularly spaced with Î”x=4.0\nâ”œâ”€â”€ Periodic y âˆˆ [0.0, 32.0) regularly spaced with Î”y=4.0\nâ””â”€â”€ Bounded  z âˆˆ [0.0, 8.0]  regularly spaced with Î”z=2.0","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"This simple grid","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"Has a domain that's \"periodic\" in x y, but bounded in z.\nHas 16 cells in x, 8 cells in y, and 4 cells in z. That means there are 16 times 8 times 4 = 512 cells in all.\nHas an x dimension that spans from x=0, to x=64. And y spans y=0 to y=32, and z spans z=0 to z=8.\nHas cells that are all the same size, dividing the box in 512 that each has dimension 4 times 4 times 2. Note that length units are whatever is used to construct the grid, so it's up to the user to make sure that all inputs use consistent units.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"In building our first grid, we did not specify whether it should be constructed on the CPU or GPU. As a result, the grid was constructed by default on the CPU. Next we build a grid on the GPU that's two-dimensional in x z and has variably-spaced cell interfaces in the z-direction,","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"using CUDA\narchitecture = GPU()\nz_faces = [0, 1, 3, 6, 10]\n\ngrid = RectilinearGrid(architecture,\n                       topology = (Periodic, Flat, Bounded),\n                       size = (10, 4),\n                       x = (0, 20),\n                       z = z_faces)\n\n# output\n10Ã—1Ã—4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CUDAGPU with 3Ã—0Ã—3 halo\nâ”œâ”€â”€ Periodic x âˆˆ [0.0, 20.0) regularly spaced with Î”x=2.0\nâ”œâ”€â”€ Flat y\nâ””â”€â”€ Bounded  z âˆˆ [0.0, 10.0] variably spaced with min(Î”z)=1.0, max(Î”z)=4.0","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"note: GPU architecture requires a CUDA-, ROC- or Metal-enabled device\nRunning this example and creating a grid on the GPU requires a device that supports CUDA, ROC, or Metal. In other words, you must have an Nvidia, AMD, or Apple-compatible GPU available. For more information about CUDA, see the CUDA.jl documentation.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"The y-dimension is \"missing\" because it's marked Flat in topology = (Periodic, Flat, Bounded). So nothing varies in y: y-derivatives are 0. Also, the keyword argument (or \"kwarg\" for short) that specifies the y-domains may be omitted, and size has only two elements rather than 3 as in the first example. In the stretched cell interfaces specified by z_interfaces, the number of vertical cell interfaces is Nz + 1 = length(z_interfaces) = 5, where Nz = 4 is the number of cells in the vertical.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"A bit later in this tutorial, we'll give examples that illustrate how to build a grid thats Distributed across multiple CPUs and GPUs.","category":"page"},{"location":"grids/#Grid-types:-squares,-shells,-and-mountains","page":"Grids","title":"Grid types: squares, shells, and mountains","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"The shape of the physical domain determines what grid type should be used:","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"RectilinearGrid can be fashioned into lines, rectangles and boxes.\nLatitudeLongitudeGrid represents sectors of thin spherical shells, with cells bounded by lines of constant latitude and longitude.\nOrthogonalSphericalShellGrid represents sectors of thin spherical shells divided with mesh lines that intersect at right angles (thus, orthogonal) but are otherwise arbitrary.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"note: OrthogonalSphericalShellGrids\nSee the auxiliary module OrthogonalSphericalShellGrids for recipes that implement some useful OrthogonalSphericalShellGrids, including the \"tripolar\" grid.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"For example, to make a LatitudeLongitudeGrid that wraps around the sphere, extends for 60 degrees latitude on either side of the equator, and has 5 vertical levels down to 1000 meters, we write","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"architecture = CPU()\n\ngrid = LatitudeLongitudeGrid(architecture,\n                             size = (180, 10, 5),\n                             longitude = (-180, 180),\n                             latitude = (-60, 60),\n                             z = (-1000, 0))\n\n# output\n180Ã—10Ã—5 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3Ã—3Ã—3 halo and with precomputed metrics\nâ”œâ”€â”€ longitude: Periodic Î» âˆˆ [-180.0, 180.0) regularly spaced with Î”Î»=2.0\nâ”œâ”€â”€ latitude:  Bounded  Ï† âˆˆ [-60.0, 60.0]   regularly spaced with Î”Ï†=12.0\nâ””â”€â”€ z:         Bounded  z âˆˆ [-1000.0, 0.0]  regularly spaced with Î”z=200.0","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"The main difference between the syntax for LatitudeLongitudeGrid versus that for the RectilinearGrid are the names of the horizontal coordinates: LatitudeLongitudeGrid has longitude and latitude where RectilinearGrid has x and y.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"note: Extrinsic and intrinsic coordinate systems\nEvery grid is associated with an \"extrinsic\" coordinate system: RectilinearGrid uses a Cartesian coordinate system (x, y, z), while LatitudeLongitudeGrid and OrthogonalSphericalShellGrid use the geographic coordinates (Î», Ï†, z), where Î» is longitude, Ï† is latitude, and z is height. Additionally, OrthogonalSphericalShellGrid has an \"intrinsic\" coordinate system associated with the orientation of its finite volumes (which, in general, are not aligned with geographic coordinates).To type Î» or Ï† at the REPL, write either \\lambda (for Î») or \\varphi (for Ï†) and then press <TAB>.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"If topology is not provided for LatitudeLongitudeGrid, then Oceananigans tries infer it: if the longitude spans 360 degrees, the default x-topology is Periodic; if longitude spans less than 360 degrees x-topology is Bounded.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"For example,","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"grid = LatitudeLongitudeGrid(size = (60, 10, 5),\n                             longitude = (0, 60),\n                             latitude = (-60, 60),\n                             z = (-1000, 0))\n\n# output\n60Ã—10Ã—5 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3Ã—3Ã—3 halo and with precomputed metrics\nâ”œâ”€â”€ longitude: Bounded  Î» âˆˆ [0.0, 60.0]    regularly spaced with Î”Î»=1.0\nâ”œâ”€â”€ latitude:  Bounded  Ï† âˆˆ [-60.0, 60.0]  regularly spaced with Î”Ï†=12.0\nâ””â”€â”€ z:         Bounded  z âˆˆ [-1000.0, 0.0] regularly spaced with Î”z=200.0","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"is Bounded by default, because longitude = (0, 60).","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"note: LatitudeLongitudeGrid topologies\nIt's still possible to use topology = (Periodic, Bounded, Bounded) even if longitude doesn't span 360 degrees. But neither latitude nor z may be Periodic with LatitudeLongitudeGrid.","category":"page"},{"location":"grids/#Bathymetry,-topography,-and-other-irregularities","page":"Grids","title":"Bathymetry, topography, and other irregularities","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"Irregular or \"complex\" domains are represented with ImmersedBoundaryGrid, which combines one of the above underlying grids with a type of immersed boundary. The immersed boundaries currently supported are:","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"GridFittedBottom, which fits a one- or two-dimensional bottom height to the underlying grid, so the active part of the domain is above the bottom height.\nPartialCellBottom, which is similar to GridFittedBottom, except that the height of the bottommost cell is changed to conform to bottom height, limited to prevent the bottom cells from becoming too thin.\nGridFittedBoundary, which fits a three-dimensional mask to the grid.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"To build an ImmersedBoundaryGrid, we start by building one of the three underlying grids, and then embedding a boundary into that underlying grid.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"using Oceananigans.Units\n\ngrid = RectilinearGrid(topology = (Bounded, Bounded, Bounded),\n                       size = (20, 20, 20),\n                       x = (-5kilometers, 5kilometers),\n                       y = (-5kilometers, 5kilometers),\n                       z = (0, 1kilometer))\n\n# Height and width\nH = 100meters\nW = 1kilometer\n\nmountain(x, y) = H * exp(-(x^2 + y^2) / 2W^2)\nmountain_grid = ImmersedBoundaryGrid(grid, GridFittedBottom(mountain))\n\n# output\n20Ã—20Ã—20 ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3Ã—3Ã—3 halo:\nâ”œâ”€â”€ immersed_boundary: GridFittedBottom(mean(z)=4.5, min(z)=0.0, max(z)=100.0)\nâ”œâ”€â”€ underlying_grid: 20Ã—20Ã—20 RectilinearGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ Bounded  x âˆˆ [-5000.0, 5000.0] regularly spaced with Î”x=500.0\nâ”œâ”€â”€ Bounded  y âˆˆ [-5000.0, 5000.0] regularly spaced with Î”y=500.0\nâ””â”€â”€ Bounded  z âˆˆ [0.0, 1000.0]     regularly spaced with Î”z=50.0","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"Yep, that's a Gaussian mountain:","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"using CairoMakie\n\nh = mountain_grid.immersed_boundary.bottom_height\n\nfig = Figure()\nax = Axis(fig[2, 1], xlabel=\"x (m)\", ylabel=\"y (m)\", aspect=1)\nhm = heatmap!(ax, h)\nColorbar(fig[1, 1], hm, vertical=false, label=\"Bottom height (m)\")\n\nfig","category":"page"},{"location":"grids/#Once-more-with-feeling","page":"Grids","title":"Once more with feeling","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"In summary, making a grid requires","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"The machine architecture, or whether data is stored on the CPU, GPU, or distributed across multiple devices or nodes.\nInformation about the domain geometry. Domains can take a variety of shapes, including\nlines (one-dimensional),\nrectangles (two-dimensional),\nboxes (three-dimensional),\nsectors of a thin spherical shells (two- or three-dimensional).\nIrregular domains â€“ such as domains that include bathymetry or topography â€“ are represented by using a masking technique to \"immerse\" an irregular boundary within an \"underlying\" regular grid. Part of specifying the shape of the domain also requires specifying the nature of each dimension, which may be\nPeriodic, which means that the dimension circles back onto itself: information leaving the left side of the domain re-enters on the right.\nBounded, which means that the two sides of the dimension are either impenetrable (solid walls), or \"open\", representing a specified external state.\nFlat, which means nothing can vary in that dimension, reducing the overall dimensionality of the grid.\nDefining the number of cells that divide each dimension. The number of cells, with or without explicit specification of the cell interfaces, determines the spatial resolution of the grid.\nThe representation of floating point numbers, which can be single-precision (Float32) or double precision (Float64).","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"Let's dive into each of these options in more detail.","category":"page"},{"location":"grids/#Specifying-the-machine-architecture","page":"Grids","title":"Specifying the machine architecture","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"The positional argument CPU() or GPU(), specifies the \"architecture\" of the simulation. By using architecture = GPU(), any fields constructed on grid store their data on an Nvidia GPU, if one is available. By default, the grid will be constructed on the CPU if this argument is omitted. So, for example,","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"grid     = RectilinearGrid(size=3, z=(0, 1), topology=(Flat, Flat, Bounded))\ncpu_grid = RectilinearGrid(CPU(), size=3, z=(0, 1), topology=(Flat, Flat, Bounded))\n\ngrid == cpu_grid\n\n# output\ntrue","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"To use more than one CPU, we use the Distributed architecture,","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"using Oceananigans\n\nchild_architecture = CPU()\narchitecture = Distributed(child_architecture)","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"which allows us to distributed computations across either CPUs or GPUs. In this case, we didn't launch julia on multiple processes using MPI, so we're only \"distributed\" across 1 process. For more, see Distributed grids.","category":"page"},{"location":"grids/#Specifying-the-topology-for-each-dimension","page":"Grids","title":"Specifying the topology for each dimension","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"The keyword argument topology determines if the grid is one-, two-, or three-dimensional (the current case), and additionally specifies the nature of each dimension. topology is always a Tuple with three elements (a 3-Tuple). For RectilinearGrid, the three elements correspond to (x y z) and indicate whether the respective direction is Periodic, Bounded, or Flat. A few more examples are,","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"topology = (Periodic, Periodic, Periodic) # triply periodic\ntopology = (Periodic, Periodic, Bounded)  # periodic in x, y, bounded in z\ntopology = (Periodic, Bounded, Bounded)   # periodic in x, but bounded in y, z (a \"channel\")\ntopology = (Bounded, Bounded, Bounded)    # bounded in x, y, z (a closed box)\ntopology = (Periodic, Periodic, Flat)     # two-dimensional, doubly-periodic in x, y (a torus)\ntopology = (Periodic, Flat, Flat)         # one-dimensional, periodic in x (a line)\ntopology = (Flat, Flat, Bounded)          # one-dimensional and bounded in z (a single column)","category":"page"},{"location":"grids/#Specifying-the-size-of-the-grid","page":"Grids","title":"Specifying the size of the grid","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"The size is a Tuple that specifies the number of grid points in each direction. The number of tuple elements corresponds to the number of dimensions that are not Flat.","category":"page"},{"location":"grids/#The-halo-size","page":"Grids","title":"The halo size","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"An additional keyword argument halo allows us to set the number of \"halo cells\" that surround the core \"interior\" grid. The default is 3 for each non-flat coordinate. But we can change the halo size, for example,","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"big_halo_grid = RectilinearGrid(topology = (Periodic, Periodic, Flat),\n                                size = (32, 16),\n                                halo = (7, 7),\n                                x = (0, 2Ï€),\n                                y = (0, Ï€))\n\n# output\n32Ã—16Ã—1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 7Ã—7Ã—0 halo\nâ”œâ”€â”€ Periodic x âˆˆ [-6.90805e-17, 6.28319) regularly spaced with Î”x=0.19635\nâ”œâ”€â”€ Periodic y âˆˆ [-1.07194e-16, 3.14159) regularly spaced with Î”y=0.19635\nâ””â”€â”€ Flat z","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"The halo size has to be set for certain advection schemes that require more halo points than the default 3 in every direction. Note that both size and halo are 2-Tuples, rather than the 3-Tuple that would be required for a three-dimensional grid, or the single number that would be used for a one-dimensional grid.","category":"page"},{"location":"grids/#The-dimensions:-x,-y,-z-for-RectilinearGrid,-or-latitude,-longitude,-z-for-LatitudeLongitudeGrid","page":"Grids","title":"The dimensions: x, y, z for RectilinearGrid, or latitude, longitude, z for LatitudeLongitudeGrid","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"These keyword arguments specify the extent and location of the finite volume cells that divide up the three dimensions of the grid. For RectilinearGrid, the dimensions are called x, y, and z, whereas for LatitudeLongitudeGrid the dimensions are called latitude, longitude, and z. The type of each keyword argument determines how the dimension is divided up:","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"Tuples that specify only the end points indicate that the dimension should be divided into equally-spaced cells. For example, x = (0, 64) with size = (16, 8, 4) means that the x-dimension is divided into 16 cells, where the first or leftmost cell interface is located at x = 0 and the last or rightmost cell interface is located at x = 64. The width of each cell is Î”x=4.0.\nVectors and functions alternatively give the location of each cell interface, and thereby may be used to build grids that are divided into cells of varying width.","category":"page"},{"location":"grids/#A-complicated-example:-three-dimensional-RectilinearGrid-with-variable-spacing-via-functions","page":"Grids","title":"A complicated example: three-dimensional RectilinearGrid with variable spacing via functions","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"Next we build a grid that is both Bounded and stretched in both the y and z directions. The purpose of the stretching is to increase grid resolution near the boundaries. We'll do this by using functions to specify the keyword arguments y and z.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"Nx = Ny = 64\nNz = 32\n\nLx = Ly = 1e4\nLz = 1e3\n\n# Note that j varies from 1 to Ny\nchebychev_spaced_y_faces(j) = Ly * (1 - cos(Ï€ * (j - 1) / Ny)) / 2\n\n# Note that k varies from 1 to Nz\nchebychev_spaced_z_faces(k) = - Lz * (1 + cos(Ï€ * (k - 1) / Nz)) / 2\n\ngrid = RectilinearGrid(size = (Nx, Ny, Nz),\n                       topology = (Periodic, Bounded, Bounded),\n                       x = (0, Lx),\n                       y = chebychev_spaced_y_faces,\n                       z = chebychev_spaced_z_faces)\n\n# output\n64Ã—64Ã—32 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ Periodic x âˆˆ [0.0, 10000.0)  regularly spaced with Î”x=156.25\nâ”œâ”€â”€ Bounded  y âˆˆ [0.0, 10000.0]  variably spaced with min(Î”y)=6.02272, max(Î”y)=245.338\nâ””â”€â”€ Bounded  z âˆˆ [-1000.0, -0.0] variably spaced with min(Î”z)=2.40764, max(Î”z)=49.0086","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"We can easily visualize the spacings of y and z directions. We can use, e.g., ynodes and yspacings to extract the positions and spacings of the nodes from the grid.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"yc = ynodes(grid, Center())\nzc = znodes(grid, Center())\n\nyf = ynodes(grid, Face())\nzf = znodes(grid, Face())\n\nÎ”y = yspacings(grid, Center())\nÎ”z = zspacings(grid, Center())\n\nusing CairoMakie\n\nfig = Figure(size=(1000, 1000))\n\naxy = Axis(fig[1, 1], title=\"y-grid\")\nlines!(axy, [0, Ly], [0, 0], color=:gray)\nscatter!(axy, yf, 0 * yf, marker=:vline, color=:gray, markersize=25)\nscatter!(axy, yc, 0 * yc)\nhidedecorations!(axy)\nhidespines!(axy)\n\naxÎ”y = Axis(fig[2, 1]; xlabel = \"y (m)\", ylabel = \"y-spacing (m)\")\nscatter!(axÎ”y, yc, Î”y)\nhidespines!(axÎ”y, :t, :r)\n\naxz = Axis(fig[3, 1], title=\"z-grid\")\nlines!(axz, [-Lz, 0], [0, 0], color=:gray)\nscatter!(axz, zf, 0 * zf, marker=:vline, color=:gray, markersize=25)\nscatter!(axz, zc, 0 * zc)\nhidedecorations!(axz)\nhidespines!(axz)\n\naxÎ”z = Axis(fig[4, 1]; xlabel = \"z (m)\", ylabel = \"z-spacing (m)\")\nscatter!(axÎ”z, zc, Î”z)\nhidespines!(axÎ”z, :t, :r)\n\nrowsize!(fig.layout, 1, Relative(0.1))\nrowsize!(fig.layout, 3, Relative(0.1))\n\nfig","category":"page"},{"location":"grids/#Inspecting-LatitudeLongitudeGrid-cell-spacings","page":"Grids","title":"Inspecting LatitudeLongitudeGrid cell spacings","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"grid = LatitudeLongitudeGrid(size = (1, 44),\n                             longitude = (0, 1),\n                             latitude = (0, 88),\n                             topology = (Bounded, Bounded, Flat))\n\nÎ”x = xspacings(grid, Center(), Center())\n\nusing CairoMakie\n\nfig = Figure()\nax = Axis(fig[1, 1], xlabel=\"Zonal spacing on 2 degree grid (km)\", ylabel=\"Latitude (degrees)\")\nscatter!(ax, Î”x / 1e3)\nfig","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"(Image: )","category":"page"},{"location":"grids/#LatitudeLongitudeGrid-with-variable-spacing","page":"Grids","title":"LatitudeLongitudeGrid with variable spacing","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"The syntax for building a grid with variably-spaced cells is the same as for RectilinearGrid. In our next example, we use a function to build a Mercator grid with a spacing of 2 degrees at the equator,","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"# Mercator scale factor\nscale_factor(Ï†) = 1 / cosd(Ï†)\n\n# Compute cell interfaces with Mercator spacing\nm = 2 # spacing at the equator in degrees\nfunction latitude_faces(j)\n    if j == 1 # equator\n        return 0\n    else # crudely estimate the location of the jth face\n        Ï†â‚‹ = latitude_faces(j-1)\n        Ï†â€² = Ï†â‚‹ + m * scale_factor(Ï†â‚‹) / 2\n        return Ï†â‚‹ + m * scale_factor(Ï†â€²)\n    end\nend\n\nLx = 360\nNx = Int(Lx / m)\nNy = findfirst(latitude_faces.(1:Nx) .> 90) - 2\n\ngrid = LatitudeLongitudeGrid(size = (Nx, Ny),\n                             longitude = (0, Lx),\n                             latitude = latitude_faces,\n                             topology = (Bounded, Bounded, Flat))\n\n# output\n180Ã—28Ã—1 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Flat} on CPU with 3Ã—3Ã—0 halo and with precomputed metrics\nâ”œâ”€â”€ longitude: Bounded  Î» âˆˆ [0.0, 360.0]   regularly spaced with Î”Î»=2.0\nâ”œâ”€â”€ latitude:  Bounded  Ï† âˆˆ [0.0, 77.2679] variably spaced with min(Î”Ï†)=2.0003, max(Î”Ï†)=6.95319\nâ””â”€â”€ z:         Flat z","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"We've also illustrated the construction of a grid that is Flat in the vertical direction. Now let's plot the metrics for this grid,","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"Ï† = Ï†nodes(grid, Center())\nÎ”x = xspacings(grid, Center(), Center())[1, 1:Ny]\nÎ”y = yspacings(grid, Center(), Center())[1, 1:Ny]\n\nusing CairoMakie\n\nfig = Figure(size=(800, 400), title=\"Spacings on a Mercator grid\")\naxx = Axis(fig[1, 1], xlabel=\"Zonal spacing (km)\", ylabel=\"Latitude (degrees)\")\nscatter!(axx, Î”x / 1e3, Ï†)\n\naxy = Axis(fig[1, 2], xlabel=\"Meridional spacing (km)\")\nscatter!(axy, Î”y / 1e3, Ï†)\n\nhidespines!(axx, :t, :r)\nhidespines!(axy, :t, :l, :r)\nhideydecorations!(axy, grid=false)\n\nfig","category":"page"},{"location":"grids/#Coordinate-helper-utilities","page":"Grids","title":"Coordinate helper utilities","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"As described above, to construct grids with stretched coordinates we need to provide as input either a function the returns the coordinate's interfaces or an array with the interfaces.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"Here we showcase some helper utilities that can be used to define few special types of discretizations with variable spacings.","category":"page"},{"location":"grids/#Exponential-discretization","page":"Grids","title":"Exponential discretization","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"ExponentialDiscretization returns a discretization with interfaces that lie on an exponential profile. By that, we mean that a uniformly discretized domain in the range l r is mapped back onto itself via either","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"Î¾ mapsto w(Î¾) = r - (r - l) fracexp(r - Î¾)  h - 1exp(r - l)  h - 1 quad text(right biased)","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"or","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"Î¾ mapsto w(Î¾) = l + (r - l) fracexp(Î¾ - l)  h - 1exp(r - l)  h - 1 quad text(left biased)","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"The exponential mappings above have an e-folding controlled by scale h. It's worth noting that the exponential maps imply that the cell widths (distances between interfaces) grow linearly at a rate inversely proportional to h  (r - l).","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"The right-biased map biases the interfaces being closer towards r; the left-biased map biases the interfaces towards l.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"At the limit h  (r - l) to infty both mappings reduce to identity (w to Î¾) and thus the discretization becomes uniformly spaced.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"note: Oceanography-related bias\nFor vertical coordinates fit for oceanographic purposes, the right-biased mapping is usually more relevant as it implies finer vertical resolution near the ocean's surface.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"using Oceananigans.Grids: rightbiased_exponential_mapping, leftbiased_exponential_mapping\n\nusing CairoMakie\n\nl, r = 0, 1\n\nÎ¾  = range(l, stop=r, length=501)\nÎ¾p = range(l, stop=r, length=6)   # coarser for plotting\n\nfig = Figure(size=(1200, 550))\n\naxis_labels = (xlabel=\"uniform Î¾ / (r - l)\",\n               ylabel=\"mapped w / (r - l)\")\n\naxl = Axis(fig[1, 1]; title=\"left-biased map\", axis_labels...)\naxr = Axis(fig[1, 2]; title=\"right-biased map\", axis_labels...)\n\nfor scale in (1/20, 1/5, 1/2, 1e12)\n    label = \"h / (r-l) = $scale\"\n\n    lines!(axl, Î¾, leftbiased_exponential_mapping.(Î¾, l, r, scale); label)\n    scatter!(axl, Î¾p, leftbiased_exponential_mapping.(Î¾p, l, r, scale), markersize=20)\n\n    lines!(axr, Î¾, rightbiased_exponential_mapping.(Î¾, l, r, scale); label)\n    scatter!(axr, Î¾p, rightbiased_exponential_mapping.(Î¾p, l, r, scale), markersize=20)\nend\n\nLegend(fig[2, :], axl, orientation = :horizontal)\n\nfig","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"Note that the smallest the ratio h  (r - l) is, the more finely-packed are the mapped points towards the left or right side of the domain.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"Let's see how we use ExponentialDiscretization. Below we construct a coordinate with 10 cells that spans the range -700 300. By default, the ExponentialDiscretization is right-biased.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"using Oceananigans\n\nN = 10\nl = -700\nr = 300\n\nx = ExponentialDiscretization(N, l, r)","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"Note that above, the default e-folding scale (scale = (r - l) / 5) was used.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"We can inspect the interfaces of the coordinate via","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"[x(i) for i in 1:N+1]","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"Being right-biased, note above how the interfaces are closer together near r.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"To demonstrate how the scale h affects the discretization, we construct below two such exponential discretizations: the first with h  (r - l) = 15 and the second with h  (r - l) = 12.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"using Oceananigans\n\nN = 10\nl = -700\nr = 300\nextent = r - l\n\nusing CairoMakie\n\nfig = Figure(size=(1000, 1000))\n\nscale = extent / 5\nx = ExponentialDiscretization(N, l, r; scale)\ngrid = RectilinearGrid(; size=N, x, topology=(Bounded, Flat, Flat))\nxc = xnodes(grid, Center())\nxf = xnodes(grid, Face())\nÎ”x = xspacings(grid, Center())\n\naxx1 = Axis(fig[1, 1],  title = \"scale = extent / 5\")\nlines!(axx1, [l, r], [0, 0], color=:gray)\nscatter!(axx1, xf, 0 * xf, marker=:vline, color=:gray, markersize=25)\nscatter!(axx1, xc, 0 * xc)\naxÎ”x1 = Axis(fig[2, 1]; xlabel = \"x (m)\", ylabel = \"x-spacing (m)\")\nlÎ”x = lines!(axÎ”x1, xf, Î”x[1] .+ (xc[1] .- xf) * (extent / scale) / N, color=(:purple, 0.3), linewidth=4)\nscatter!(axÎ”x1, xc, Î”x)\n\n\nscale = extent / 2\nx = ExponentialDiscretization(N, l, r; scale)\ngrid = RectilinearGrid(; size=N, x, topology=(Bounded, Flat, Flat))\nxc = xnodes(grid, Center())\nxf = xnodes(grid, Face())\nÎ”x = xspacings(grid, Center())\n\naxx2 = Axis(fig[3, 1], title = \"scale = extent / 2\")\nlines!(axx2, [l, r], [0, 0], color=:gray)\nscatter!(axx2, xf, 0 * xf, marker=:vline, color=:gray, markersize=25)\nscatter!(axx2, xc, 0 * xc)\naxÎ”x2 = Axis(fig[4, 1]; xlabel = \"x (m)\", ylabel = \"x-spacing (m)\")\nlÎ”x = lines!(axÎ”x2, xf, Î”x[1] .+ (xc[1] .- xf) * (extent / scale) / N, color=(:purple, 0.3), linewidth=4)\nscatter!(axÎ”x2, xc, Î”x)\n\n\nlegend = Legend(fig[5, :], [lÎ”x], [\"slope = (extent / scale) / Nz\"], orientation = :horizontal)\n\nfor ax in (axx1, axx2)\n    hidedecorations!(ax)\n    hidespines!(ax)\nend\n\nfor ax in (axÎ”x1, axÎ”x2)\n    ylims!(ax, -10, 450)\n    hidespines!(ax, :t, :r)\nend\n\nrowsize!(fig.layout, 1, Relative(0.1))\nrowsize!(fig.layout, 3, Relative(0.1))\nfig","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"A downside of ExponentialDiscretization discretization is that we don't have tight control on the minimum spacing at the biased edge. To obtain a discretization with a certain minimum spacing we need to play around with the scale h and the number of cells.","category":"page"},{"location":"grids/#Reference-to-stretched-spacing-discretization","page":"Grids","title":"Reference-to-stretched-spacing discretization","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"ReferenceToStretchedDiscretization returns a discretization with a constant reference spacing over some extent and beyond which the spacing increases with a prescribed stretching law; this allows a tighter control on the spacing at the biased edge. That is, we can prescribe a constant spacing over the top surface_layer_height  below which the grid spacing increases following a prescribed stretching law. The downside here is that neither the final discretization extent nor the total number of cells can be prescribed. The discretization's extent is greater or equal from what we prescribe via the keyword argument extent. Also, the total number of cells we end up with depends on the stretching law.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"As an example, we build three single-column vertical grids. We use right-biased discretization (i.e., bias = :right) since this way we can have tight control of the spacing at the ocean's surface (bias_edge = 0). The three grids below have constant 30-meter spacing for the top 180 meters. We prescribe to all three a extent = 800 meters and we apply power-law stretching for depths below 120 meters. The bigger the power-law stretching factor is, the further the last interface goes beyond the prescribed depth and/or with less total number of cells.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"bias = :right\nbias_edge = 0\nextent = 800\nconstant_spacing = 25\nconstant_spacing_extent = 160\n\nz = ReferenceToStretchedDiscretization(; extent, bias, bias_edge,\n                                       constant_spacing,  constant_spacing_extent,\n                                       stretching =  PowerLawStretching(1.06))\ngrid = RectilinearGrid(; size=length(z), z, topology=(Flat, Flat, Bounded))\nzf = znodes(grid, Face())\nzc = znodes(grid, Center())\nÎ”z = zspacings(grid, Center())\nÎ”z = view(Î”z, 1, 1, :)  # for plotting\n\nfig = Figure(size=(800, 550), colgap = 5)\n\naxÎ”z1 = Axis(fig[1, 1];\n             xlabel = \"z-spacing (m)\",\n             ylabel = \"z (m)\",\n             title = \"PowerLawStretching(1.06)\\n $(length(zf)) cells\\n bottom @ z = $(zf[1]) m\\n \")\n\naxz1 = Axis(fig[1, 2])\n\nldepth = hlines!(axÎ”z1, bias_edge - extent, color = :salmon, linestyle=:dash)\nlzbottom = hlines!(axÎ”z1, zf[1], color = :grey)\nscatter!(axÎ”z1, Î”z, zc)\nhidespines!(axÎ”z1, :t, :r)\n\nlines!(axz1, [0, 0], [zf[1], 0], color=:gray)\nscatter!(axz1, 0 * zf, zf, marker=:hline, color=:gray, markersize=20)\nscatter!(axz1, 0 * zc, zc)\nhidedecorations!(axz1)\nhidespines!(axz1)\n\n\nz = ReferenceToStretchedDiscretization(; extent, bias, bias_edge,\n                                       constant_spacing,  constant_spacing_extent,\n                                       stretching =  PowerLawStretching(1.03))\ngrid = RectilinearGrid(; size=length(z), z, topology=(Flat, Flat, Bounded))\nzf = znodes(grid, Face())\nzc = znodes(grid, Center())\nÎ”z = zspacings(grid, Center())\nÎ”z = view(Î”z, 1, 1, :)  # for plotting\n\naxÎ”z2 = Axis(fig[1, 3];\n             xlabel = \"z-spacing (m)\",\n             ylabel = \"z (m)\",\n             title = \"PowerLawStretching(1.03)\\n $(length(zf)) cells\\n bottom @ z = $(zf[1]) m\\n \")\naxz2 = Axis(fig[1, 4])\n\nldepth = hlines!(axÎ”z2, bias_edge - extent, color = :salmon, linestyle=:dash)\nlzbottom = hlines!(axÎ”z2, zf[1], color = :grey)\nscatter!(axÎ”z2, Î”z, zc)\nhidespines!(axÎ”z2, :t, :r)\n\nlines!(axz2, [0, 0], [zf[1], 0], color=:gray)\nscatter!(axz2, 0 * zf, zf, marker=:hline, color=:gray, markersize=20)\nscatter!(axz2, 0 * zc, zc)\nhidedecorations!(axz2)\nhidespines!(axz2)\n\nz = ReferenceToStretchedDiscretization(; extent, bias, bias_edge,\n                                       constant_spacing,  constant_spacing_extent,\n                                       stretching =  PowerLawStretching(1.03),\n                                       maximum_stretching_extent =  500)\n\ngrid = RectilinearGrid(; size=length(z), z, topology=(Flat, Flat, Bounded))\nzf = znodes(grid, Face())\nzc = znodes(grid, Center())\nÎ”z = zspacings(grid, Center())\nÎ”z = view(Î”z, 1, 1, :)  # for plotting\n\naxÎ”z3 = Axis(fig[1, 5];\n             xlabel = \"z-spacing (m)\",\n             ylabel = \"z (m)\",\n             title = \"PowerLawStretching(1.03)\\n $(length(zf)) cells\\n bottom @ z = $(zf[1]) m\\n maximum_stretching_extent = 500\")\naxz3 = Axis(fig[1, 6])\n\nldepth = hlines!(axÎ”z3, bias_edge - extent, color = :salmon, linestyle=:dash)\nlzbottom = hlines!(axÎ”z3, zf[1], color = :grey)\nscatter!(axÎ”z3, Î”z, zc)\n\nhidespines!(axÎ”z3, :t, :r)\n\nlines!(axz3, [0, 0], [zf[1], 0], color=:gray)\nscatter!(axz3, 0 * zf, zf, marker=:hline, color=:gray, markersize=20)\nscatter!(axz3, 0 * zc, zc)\nhidedecorations!(axz3)\nhidespines!(axz3)\n\n\nlinkaxes!(axÎ”z1, axz1, axÎ”z2, axz2, axÎ”z3, axz3)\n\nLegend(fig[2, :], [ldepth, lzbottom], [\"prescribed extent\", \"bottom z interface\"], orientation = :horizontal)\n\ncolsize!(fig.layout, 2, Relative(0.1))\ncolsize!(fig.layout, 4, Relative(0.1))\ncolsize!(fig.layout, 6, Relative(0.1))\n\nfig","category":"page"},{"location":"grids/#Single-precision-RectilinearGrid","page":"Grids","title":"Single-precision RectilinearGrid","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"To build a grid whose fields are represented with single-precision floating point values, we specify the float_type argument along with the (optional) architecture argument,","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"architecture = CPU()\nfloat_type = Float32\n\ngrid = RectilinearGrid(architecture, float_type,\n                       topology = (Periodic, Periodic, Bounded),\n                       size = (16, 8, 4),\n                       x = (0, 64),\n                       y = (0, 32),\n                       z = (0, 8))\n\n# output\n16Ã—8Ã—4 RectilinearGrid{Float32, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ Periodic x âˆˆ [0.0, 64.0) regularly spaced with Î”x=4.0\nâ”œâ”€â”€ Periodic y âˆˆ [0.0, 32.0) regularly spaced with Î”y=4.0\nâ””â”€â”€ Bounded  z âˆˆ [0.0, 8.0]  regularly spaced with Î”z=2.0","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"warn: Using single precision\nSingle precision should be used with care. Users interested in performing single-precision simulations should get in touch via Discussions, and should subject their work to extensive testing and validation.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"For more examples see RectilinearGrid and LatitudeLongitudeGrid.","category":"page"},{"location":"grids/#Distributed-grids","page":"Grids","title":"Distributed grids","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"note: Note\nFor the following examples, make sure to have both Oceananigans and MPI in your environment.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"Next we turn to the distribution of grids across disparate nodes. This is useful for running simulations that cannot fit on one node. It can also be used to speed up a simulation â€“ provided that the simulation is large enough such that the added cost of communicating information between nodes does not exceed the benefit of dividing up the computation among different nodes.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"# Make a simple program that can be written to file\nmake_distributed_arch = \"\"\"\n\nusing Oceananigans\nusing Oceananigans.DistributedComputations\nusing MPI; MPI.Init()\narchitecture = Distributed()\n@onrank 0 @show architecture\n@onrank 1 @show architecture\n\"\"\"\n\nwrite(\"distributed_arch_example.jl\", make_distributed_arch)\n\n# Run the program from inside julia.\n# The program can also be run by exiting julia and running\n#\n# $ mpiexec -n 2 julia --project distributed_architecture_example.jl\n#\n# from the terminal.\nusing MPI\nrun(`$(mpiexec()) -n 2 julia --project distributed_arch_example.jl`)\nrm(\"distributed_architecture_example.jl\")","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"gives","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"architecture = Distributed{CPU} across 2 = 2Ã—1Ã—1 ranks:\nâ”œâ”€â”€ local_rank: 0 of 0-1\nâ”œâ”€â”€ local_index: [1, 1, 1]\nâ””â”€â”€ connectivity: east=1 west=1\narchitecture = Distributed{CPU} across 2 = 2Ã—1Ã—1 ranks:\nâ”œâ”€â”€ local_rank: 1 of 0-1\nâ”œâ”€â”€ local_index: [2, 1, 1]\nâ””â”€â”€ connectivity: east=0 west=0","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"That's what it looks like to build a Distributed architecture. Notice we chose to display only if we're on rank 0 â€“ because otherwise, all the ranks print to the terminal at once, talking over each other, and things get messy. Also, we used the \"default communicator\" MPI.COMM_WORLD to determine whether we were on rank 0. This works because Distributed uses communicator = MPI.COMM_WORLD by default (and this should be changed only with great intention). See the Distributed docstring for more information.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"Next, let's try to build a distributed grid:","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"make_distributed_grid = \"\"\"\n\nusing Oceananigans\nusing Oceananigans.DistributedComputations\nusing MPI; MPI.Init()\n\nchild_architecture = CPU()\narchitecture = Distributed(child_architecture)\n\ngrid = RectilinearGrid(architecture,\n                       size = (48, 48, 16),\n                       x = (0, 64),\n                       y = (0, 64),\n                       z = (0, 16),\n                       topology = (Periodic, Periodic, Bounded))\n\n@handshake @info grid\n\"\"\"\n\nwrite(\"distributed_grid_example.jl\", make_distributed_grid)\n\nrun(`$(mpiexec()) -n 2 julia --project distributed_grid_example.jl`)","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"gives","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"grid = 24Ã—48Ã—16 RectilinearGrid{Float64, FullyConnected, Periodic, Bounded} on Distributed{CPU} with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ FullyConnected x âˆˆ [0.0, 32.0) regularly spaced with Î”x=1.33333\nâ”œâ”€â”€ Periodic y âˆˆ [0.0, 64.0)       regularly spaced with Î”y=1.33333\nâ””â”€â”€ Bounded  z âˆˆ [0.0, 16.0]       regularly spaced with Î”z=1.0\ngrid = 24Ã—48Ã—16 RectilinearGrid{Float64, FullyConnected, Periodic, Bounded} on Distributed{CPU} with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ FullyConnected x âˆˆ (32.0, 64.0) regularly spaced with Î”x=1.33333\nâ”œâ”€â”€ Periodic y âˆˆ [0.0, 64.0)       regularly spaced with Î”y=1.33333\nâ””â”€â”€ Bounded  z âˆˆ [0.0, 16.0]       regularly spaced with Î”z=1.0","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"Now we're getting somewhere. Let's note a few things:","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"For the second example, we explicitly specified child_architecture = CPU() to distribute the grid across CPUs. Changing this to child_architecture = GPU() distributes the grid across GPUs.\nWe built the grid with size = (48, 48, 16), but ended up with a 24Ã—48Ã—16 grid. Why's that? Well, (48, 48, 16) is the size of the global grid, or in other words, the grid that we would get if we stitched together all the grids from each rank. Here we have two ranks. By default, the local grids are distributed equally in x, which means that each of the two local grids have half of the grids points of the global grid â€“ yielding local sizes of (24, 48, 16).\nThe global grid has topology (Periodic, Periodic, Bounded), but the local grids have the topology (FullyConnected, Periodic, Bounded). That means that each local grid, which represents half of the global grid and is partitioned in x, is not Periodic in x. Instead, the west and east sides of each local grid (left and right in the x-direction) are \"connected\" to another rank.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"To drive these points home, let's run the same script, but using 3 processors instead of 2:","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"run(`$(mpiexec()) -n 3 julia --project distributed_grid_example.jl`)","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"gives","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"grid = 16Ã—48Ã—16 RectilinearGrid{Float64, Oceananigans.Grids.FullyConnected, Periodic, Bounded} on Distributed{CPU} with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ FullyConnected x âˆˆ [0.0, 21.3333) regularly spaced with Î”x=1.33333\nâ”œâ”€â”€ Periodic y âˆˆ [0.0, 64.0)          regularly spaced with Î”y=1.33333\nâ””â”€â”€ Bounded  z âˆˆ [0.0, 16.0]          regularly spaced with Î”z=1.0\ngrid = 16Ã—48Ã—16 RectilinearGrid{Float64, Oceananigans.Grids.FullyConnected, Periodic, Bounded} on Distributed{CPU} with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ FullyConnected x âˆˆ [21.3333, 42.6667) regularly spaced with Î”x=1.33333\nâ”œâ”€â”€ Periodic y âˆˆ [0.0, 64.0)              regularly spaced with Î”y=1.33333\nâ””â”€â”€ Bounded  z âˆˆ [0.0, 16.0]              regularly spaced with Î”z=1.0\ngrid = 16Ã—48Ã—16 RectilinearGrid{Float64, Oceananigans.Grids.FullyConnected, Periodic, Bounded} on Distributed{CPU} with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ FullyConnected x âˆˆ [42.6667, 64.0) regularly spaced with Î”x=1.33333\nâ”œâ”€â”€ Periodic y âˆˆ [0.0, 64.0)           regularly spaced with Î”y=1.33333\nâ””â”€â”€ Bounded  z âˆˆ [0.0, 16.0]           regularly spaced with Î”z=1.0","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"Now we have three local grids, each with size (16, 48, 16).","category":"page"},{"location":"grids/#Custom-partitions-grids-in-both-x-and-y","page":"Grids","title":"Custom partitions grids in both x and y","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"To distribute a grid in different ways â€“ for example, in both x and y â€“ we use a custom Partition.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"The default Partition is equally distributed in x. To equally distribute in y, we write","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"make_y_partition = \"\"\"\n\nusing Oceananigans\nusing Oceananigans.DistributedComputations: Equal\nusing MPI\nMPI.Init()\n\npartition = Partition(y=Equal())\n\nif MPI.Comm_rank(MPI.COMM_WORLD) == 0\n    @show partition\nend\n\"\"\"\n\nwrite(\"partition_example.jl\", make_y_partition)\n\nrun(`$(mpiexec()) -n 2 julia --project partition_example.jl`)","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"gives","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"partition = Partition across 2 = 1Ã—2Ã—1 ranks:\nâ””â”€â”€ y: 2","category":"page"},{"location":"grids/#Manually-specifying-ranks-in-x,-y","page":"Grids","title":"Manually specifying ranks in x y","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"It's easy to manually configure Partition(x=Rx, y=Ry), where Rx * Ry is the total number of MPI ranks. For example, Partition(x=3, y=2) is compatible with a_program.jl launched via","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"mpiexec -n 6 julia --project a_program.jl","category":"page"},{"location":"grids/#Programmatically-specifying-ranks-in-x,-y","page":"Grids","title":"Programmatically specifying ranks in x y","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"Programatic specification of ranks is often better for applications that need to scale. For this the specification Equal is useful: if the number of ranks in one dimension is specified, and the other is Equal, then the Equal dimension is allocated the remaining workers. For example,","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"make_xy_partition = \"\"\"\n\nusing Oceananigans\nusing Oceananigans.DistributedComputations: Equal\nusing MPI\nMPI.Init()\n\npartition = Partition(x=Equal(), y=2)\n\nif MPI.Comm_rank(MPI.COMM_WORLD) == 0\n    @show partition\nend\n\"\"\"\n\nwrite(\"programmatic_partition_example.jl\", make_xy_partition)\n\nrun(`$(mpiexec()) -n 6 julia --project programmatic_partition_example.jl`)","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"gives","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"partition = Partition across 2 = 3Ã—2Ã—1 ranks:\nâ”œâ”€â”€ x: 3\nâ””â”€â”€ y: 2","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"Finally, we can use Equal to partition a grid evenly in x y:","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"partitioned_grid_example = \"\"\"\n\nusing Oceananigans\nusing Oceananigans.DistributedComputations: Equal, barrier\nusing MPI\nMPI.Init()\n\n# Total number of ranks\nNr = MPI.Comm_size(MPI.COMM_WORLD)\n\n# Allocate half the ranks to y, and the rest to x\nRx = Nr Ã· 2\npartition = Partition(x=Rx, y=Equal())\narch = Distributed(CPU(); partition)\n\ngrid = RectilinearGrid(arch,\n                       size = (48, 48, 16),\n                       x = (0, 64),\n                       y = (0, 64),\n                       z = (0, 16),\n                       topology = (Periodic, Periodic, Bounded))\n\n# Let's see all the grids this time.\nfor r in 0:Nr-1\n    if r == arch.local_rank\n        msg = string(\"On rank \", r, \":\", '\\n', '\\n',\n                     arch, '\\n',\n                     grid)\n        @info msg\n    end\n\n    barrier(arch)\nend\n\"\"\"\n\nwrite(\"equally_partitioned_grids.jl\", partitioned_grid_example)\n\nrun(`$(mpiexec()) -n 4 julia --project equally_partitioned_grids.jl`)","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"gives","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"â”Œ Info: On rank 0:\nâ”‚\nâ”‚ Distributed{CPU} across 4 = 2Ã—2Ã—1 ranks:\nâ”‚ â”œâ”€â”€ local_rank: 0 of 0-3\nâ”‚ â”œâ”€â”€ local_index: [1, 1, 1]\nâ”‚ â””â”€â”€ connectivity: east=2 west=2 north=1 south=1 southwest=3 southeast=3 northwest=3 northeast=3\nâ”‚ 24Ã—24Ã—16 RectilinearGrid{Float64, FullyConnected, FullyConnected, Bounded} on Distributed{CPU} with 3Ã—3Ã—3 halo\nâ”‚ â”œâ”€â”€ FullyConnected x âˆˆ [0.0, 32.0) regularly spaced with Î”x=1.33333\nâ”‚ â”œâ”€â”€ FullyConnected y âˆˆ [0.0, 32.0) regularly spaced with Î”y=1.33333\nâ”” â””â”€â”€ Bounded  z âˆˆ [0.0, 16.0]       regularly spaced with Î”z=1.0\nâ”Œ Info: On rank 1:\nâ”‚\nâ”‚ Distributed{CPU} across 4 = 2Ã—2Ã—1 ranks:\nâ”‚ â”œâ”€â”€ local_rank: 1 of 0-3\nâ”‚ â”œâ”€â”€ local_index: [1, 2, 1]\nâ”‚ â””â”€â”€ connectivity: east=3 west=3 north=0 south=0 southwest=2 southeast=2 northwest=2 northeast=2\nâ”‚ 24Ã—24Ã—16 RectilinearGrid{Float64, FullyConnected, FullyConnected, Bounded} on Distributed{CPU} with 3Ã—3Ã—3 halo\nâ”‚ â”œâ”€â”€ FullyConnected x âˆˆ [0.0, 32.0)  regularly spaced with Î”x=1.33333\nâ”‚ â”œâ”€â”€ FullyConnected y âˆˆ [32.0, 64.0) regularly spaced with Î”y=1.33333\nâ”” â””â”€â”€ Bounded  z âˆˆ [0.0, 16.0]        regularly spaced with Î”z=1.0\nâ”Œ Info: On rank 2:\nâ”‚\nâ”‚ Distributed{CPU} across 4 = 2Ã—2Ã—1 ranks:\nâ”‚ â”œâ”€â”€ local_rank: 2 of 0-3\nâ”‚ â”œâ”€â”€ local_index: [2, 1, 1]\nâ”‚ â””â”€â”€ connectivity: east=0 west=0 north=3 south=3 southwest=1 southeast=1 northwest=1 northeast=1\nâ”‚ 24Ã—24Ã—16 RectilinearGrid{Float64, FullyConnected, FullyConnected, Bounded} on Distributed{CPU} with 3Ã—3Ã—3 halo\nâ”‚ â”œâ”€â”€ FullyConnected x âˆˆ [32.0, 64.0) regularly spaced with Î”x=1.33333\nâ”‚ â”œâ”€â”€ FullyConnected y âˆˆ [0.0, 32.0)  regularly spaced with Î”y=1.33333\nâ”” â””â”€â”€ Bounded  z âˆˆ [0.0, 16.0]        regularly spaced with Î”z=1.0\nâ”Œ Info: On rank 3:\nâ”‚\nâ”‚ Distributed{CPU} across 4 = 2Ã—2Ã—1 ranks:\nâ”‚ â”œâ”€â”€ local_rank: 3 of 0-3\nâ”‚ â”œâ”€â”€ local_index: [2, 2, 1]\nâ”‚ â””â”€â”€ connectivity: east=1 west=1 north=2 south=2 southwest=0 southeast=0 northwest=0 northeast=0\nâ”‚ 24Ã—24Ã—16 RectilinearGrid{Float64, FullyConnected, FullyConnected, Bounded} on Distributed{CPU} with 3Ã—3Ã—3 halo\nâ”‚ â”œâ”€â”€ FullyConnected x âˆˆ [32.0, 64.0) regularly spaced with Î”x=1.33333\nâ”‚ â”œâ”€â”€ FullyConnected y âˆˆ [32.0, 64.0) regularly spaced with Î”y=1.33333\nâ”” â””â”€â”€ Bounded  z âˆˆ [0.0, 16.0]        regularly spaced with Î”z=1.0","category":"page"},{"location":"literated/langmuir_turbulence/#Langmuir-turbulence-example","page":"Langmuir turbulence","title":"Langmuir turbulence example","text":"","category":"section"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"This example implements a Langmuir turbulence simulation similar to the one reported in section 4 of","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"Wagner et al., \"Near-inertial waves and turbulence driven by the growth of swell\", Journal of Physical Oceanography (2021)","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"This example demonstrates","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"How to run large eddy simulations with surface wave effects via the Craik-Leibovich approximation.\nHow to specify time- and horizontally-averaged output.","category":"page"},{"location":"literated/langmuir_turbulence/#Install-dependencies","page":"Langmuir turbulence","title":"Install dependencies","text":"","category":"section"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"using Pkg\npkg\"add Oceananigans, CairoMakie, CUDA\"","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"using Oceananigans\nusing Oceananigans.Units: minute, minutes, hours\nusing CUDA","category":"page"},{"location":"literated/langmuir_turbulence/#Model-set-up","page":"Langmuir turbulence","title":"Model set-up","text":"","category":"section"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"To build the model, we specify the grid, Stokes drift, boundary conditions, and Coriolis parameter.","category":"page"},{"location":"literated/langmuir_turbulence/#Domain-and-numerical-grid-specification","page":"Langmuir turbulence","title":"Domain and numerical grid specification","text":"","category":"section"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"We use a modest resolution and the same total extent as Wagner et al. (2021),","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"grid = RectilinearGrid(GPU(), size=(128, 128, 64), extent=(128, 128, 64))","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"128Ã—128Ã—64 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CUDAGPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ Periodic x âˆˆ [0.0, 128.0) regularly spaced with Î”x=1.0\nâ”œâ”€â”€ Periodic y âˆˆ [0.0, 128.0) regularly spaced with Î”y=1.0\nâ””â”€â”€ Bounded  z âˆˆ [-64.0, 0.0] regularly spaced with Î”z=1.0","category":"page"},{"location":"literated/langmuir_turbulence/#The-Stokes-Drift-profile","page":"Langmuir turbulence","title":"The Stokes Drift profile","text":"","category":"section"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"The surface wave Stokes drift profile prescribed in Wagner et al. (2021), corresponds to a 'monochromatic' (that is, single-frequency) wave field.","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"A monochromatic wave field is characterized by its wavelength and amplitude (half the distance from wave crest to wave trough), which determine the wave frequency and the vertical scale of the Stokes drift profile.","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"g = Oceananigans.defaults.gravitational_acceleration\n\namplitude = 0.8 # m\nwavelength = 60  # m\nwavenumber = 2Ï€ / wavelength # mâ»Â¹\nfrequency = sqrt(g * wavenumber) # sâ»Â¹\n\n# The vertical scale over which the Stokes drift of a monochromatic surface wave\n# decays away from the surface is `1/2wavenumber`, or\nconst vertical_scale = wavelength / 4Ï€\n\n# Stokes drift velocity at the surface\nconst UË¢ = amplitude^2 * wavenumber * frequency # m sâ»Â¹","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"0.06791774197745354","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"The const declarations ensure that Stokes drift functions compile on the GPU. To run this example on the CPU, replace GPU() with CPU() in the RectilinearGrid constructor above.","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"The Stokes drift profile is","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"uË¢(z) = UË¢ * exp(z / vertical_scale)","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"uË¢ (generic function with 1 method)","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"and its z-derivative is","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"âˆ‚z_uË¢(z, t) = 1 / vertical_scale * UË¢ * exp(z / vertical_scale)","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"âˆ‚z_uË¢ (generic function with 1 method)","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"info: The Craik-Leibovich equations in Oceananigans\nOceananigans implements the Craik-Leibovich approximation for surface wave effects using the Lagrangian-mean velocity field as its prognostic momentum variable. In other words, model.velocities.u is the Lagrangian-mean x-velocity beneath surface waves. This differs from models that use the Eulerian-mean velocity field as a prognostic variable, but has the advantage that u accounts for the total advection of tracers and momentum, and that u = v = w = 0 is a steady solution even when Coriolis forces are present. See the physics documentation for more information.","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"Finally, we note that the time-derivative of the Stokes drift must be provided if the Stokes drift and surface wave field undergoes forced changes in time. In this example, the Stokes drift is constant and thus the time-derivative of the Stokes drift is 0.","category":"page"},{"location":"literated/langmuir_turbulence/#Boundary-conditions","page":"Langmuir turbulence","title":"Boundary conditions","text":"","category":"section"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"At the surface z = 0, Wagner et al. (2021) impose","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"Ï„x = -3.72e-5 # mÂ² sâ»Â², surface kinematic momentum flux\nu_boundary_conditions = FieldBoundaryConditions(top = FluxBoundaryCondition(Ï„x))","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"Oceananigans.FieldBoundaryConditions, with boundary conditions\nâ”œâ”€â”€ west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ bottom: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ top: FluxBoundaryCondition: -3.72e-5\nâ””â”€â”€ immersed: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"Wagner et al. (2021) impose a linear buoyancy gradient NÂ² at the bottom along with a weak, destabilizing flux of buoyancy at the surface to faciliate spin-up from rest.","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"Jáµ‡ = 2.307e-8 # mÂ² sâ»Â³, surface buoyancy flux\nNÂ² = 1.936e-5 # sâ»Â², initial and bottom buoyancy gradient\n\nb_boundary_conditions = FieldBoundaryConditions(top = FluxBoundaryCondition(Jáµ‡),\n                                                bottom = GradientBoundaryCondition(NÂ²))","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"Oceananigans.FieldBoundaryConditions, with boundary conditions\nâ”œâ”€â”€ west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ bottom: GradientBoundaryCondition: 1.936e-5\nâ”œâ”€â”€ top: FluxBoundaryCondition: 2.307e-8\nâ””â”€â”€ immersed: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"info: The flux convention in Oceananigans\nNote that Oceananigans uses \"positive upward\" conventions for all fluxes. In consequence, a negative flux at the surface drives positive velocities, and a positive flux of buoyancy drives cooling.","category":"page"},{"location":"literated/langmuir_turbulence/#Coriolis-parameter","page":"Langmuir turbulence","title":"Coriolis parameter","text":"","category":"section"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"Wagner et al. (2021) use","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"coriolis = FPlane(f=1e-4) # sâ»Â¹","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"FPlane{Float64}(f=0.0001)","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"which is typical for mid-latitudes on Earth.","category":"page"},{"location":"literated/langmuir_turbulence/#Model-instantiation","page":"Langmuir turbulence","title":"Model instantiation","text":"","category":"section"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"We are ready to build the model. We use a fifth-order Weighted Essentially Non-Oscillatory (WENO) advection scheme and the AnisotropicMinimumDissipation model for large eddy simulation. Because our Stokes drift does not vary in x y, we use UniformStokesDrift, which expects Stokes drift functions of z t only.","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"model = NonhydrostaticModel(; grid, coriolis,\n                            advection = WENO(order=9),\n                            tracers = :b,\n                            buoyancy = BuoyancyTracer(),\n                            stokes_drift = UniformStokesDrift(âˆ‚z_uË¢=âˆ‚z_uË¢),\n                            boundary_conditions = (u=u_boundary_conditions, b=b_boundary_conditions))","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"NonhydrostaticModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 128Ã—128Ã—64 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CUDAGPU with 5Ã—5Ã—5 halo\nâ”œâ”€â”€ timestepper: RungeKutta3TimeStepper\nâ”œâ”€â”€ advection scheme: WENO{5, Float64, Float32}(order=9)\nâ”œâ”€â”€ tracers: b\nâ”œâ”€â”€ closure: Nothing\nâ”œâ”€â”€ buoyancy: BuoyancyTracer with gÌ‚ = NegativeZDirection()\nâ””â”€â”€ coriolis: FPlane{Float64}(f=0.0001)","category":"page"},{"location":"literated/langmuir_turbulence/#Initial-conditions","page":"Langmuir turbulence","title":"Initial conditions","text":"","category":"section"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"We make use of random noise concentrated in the upper 4 meters for buoyancy and velocity initial conditions,","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"Î(z) = randn() * exp(z / 4)","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"Our initial condition for buoyancy consists of a surface mixed layer 33 m deep, a deep linear stratification, plus noise,","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"initial_mixed_layer_depth = 33 # m\nstratification(z) = z < - initial_mixed_layer_depth ? NÂ² * z : NÂ² * (-initial_mixed_layer_depth)\n\nbáµ¢(x, y, z) = stratification(z) + 1e-1 * Î(z) * NÂ² * model.grid.Lz","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"báµ¢ (generic function with 1 method)","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"The simulation we reproduce from Wagner et al. (2021) is zero Lagrangian-mean velocity. This initial condition is consistent with a wavy, quiescent ocean suddenly impacted by winds. To this quiescent state we add noise scaled by the friction velocity to u and w.","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"uâ˜… = sqrt(abs(Ï„x))\nuáµ¢(x, y, z) = uâ˜… * 1e-1 * Î(z)\nwáµ¢(x, y, z) = uâ˜… * 1e-1 * Î(z)\n\nset!(model, u=uáµ¢, w=wáµ¢, b=báµ¢)","category":"page"},{"location":"literated/langmuir_turbulence/#Setting-up-the-simulation","page":"Langmuir turbulence","title":"Setting up the simulation","text":"","category":"section"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"simulation = Simulation(model, Î”t=45.0, stop_time=4hours)","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"Simulation of NonhydrostaticModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ Next time step: 45 seconds\nâ”œâ”€â”€ Elapsed wall time: 0 seconds\nâ”œâ”€â”€ Wall time per iteration: NaN days\nâ”œâ”€â”€ Stop time: 4 hours\nâ”œâ”€â”€ Stop iteration: Inf\nâ”œâ”€â”€ Wall time limit: Inf\nâ”œâ”€â”€ Minimum relative step: 0.0\nâ”œâ”€â”€ Callbacks: OrderedDict with 4 entries:\nâ”‚   â”œâ”€â”€ stop_time_exceeded => 4\nâ”‚   â”œâ”€â”€ stop_iteration_exceeded => -\nâ”‚   â”œâ”€â”€ wall_time_limit_exceeded => e\nâ”‚   â””â”€â”€ nan_checker => }\nâ”œâ”€â”€ Output writers: OrderedDict with no entries\nâ””â”€â”€ Diagnostics: OrderedDict with no entries","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"We use the TimeStepWizard for adaptive time-stepping with a Courant-Freidrichs-Lewy (CFL) number of 1.0,","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"conjure_time_step_wizard!(simulation, cfl=1.0, max_Î”t=1minute)","category":"page"},{"location":"literated/langmuir_turbulence/#Nice-progress-messaging","page":"Langmuir turbulence","title":"Nice progress messaging","text":"","category":"section"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"We define a function that prints a helpful message with maximum absolute value of u v w and the current wall clock time.","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"using Printf\n\nfunction progress(simulation)\n    u, v, w = simulation.model.velocities\n\n    # Print a progress message\n    msg = @sprintf(\"i: %04d, t: %s, Î”t: %s, umax = (%.1e, %.1e, %.1e) msâ»Â¹, wall time: %s\\n\",\n                   iteration(simulation),\n                   prettytime(time(simulation)),\n                   prettytime(simulation.Î”t),\n                   maximum(abs, u), maximum(abs, v), maximum(abs, w),\n                   prettytime(simulation.run_wall_time))\n\n    @info msg\n\n    return nothing\nend\n\nsimulation.callbacks[:progress] = Callback(progress, IterationInterval(20))","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"Callback of progress on IterationInterval(20)","category":"page"},{"location":"literated/langmuir_turbulence/#Output","page":"Langmuir turbulence","title":"Output","text":"","category":"section"},{"location":"literated/langmuir_turbulence/#A-field-writer","page":"Langmuir turbulence","title":"A field writer","text":"","category":"section"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"We set up an output writer for the simulation that saves all velocity fields, tracer fields, and the subgrid turbulent diffusivity.","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"output_interval = 5minutes\n\nfields_to_output = merge(model.velocities, model.tracers)\n\nsimulation.output_writers[:fields] =\n    JLD2Writer(model, fields_to_output,\n               schedule = TimeInterval(output_interval),\n               filename = \"langmuir_turbulence_fields.jld2\",\n               overwrite_existing = true)","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"JLD2Writer scheduled on TimeInterval(5 minutes):\nâ”œâ”€â”€ filepath: langmuir_turbulence_fields.jld2\nâ”œâ”€â”€ 4 outputs: (u, v, w, b)\nâ”œâ”€â”€ array_type: Array{Float32}\nâ”œâ”€â”€ including: [:grid, :coriolis, :buoyancy, :closure]\nâ”œâ”€â”€ file_splitting: NoFileSplitting\nâ””â”€â”€ file size: 44.7 KiB","category":"page"},{"location":"literated/langmuir_turbulence/#An-\"averages\"-writer","page":"Langmuir turbulence","title":"An \"averages\" writer","text":"","category":"section"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"We also set up output of time- and horizontally-averaged velocity field and momentum fluxes.","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"u, v, w = model.velocities\nb = model.tracers.b\n\n U = Average(u, dims=(1, 2))\n V = Average(v, dims=(1, 2))\n B = Average(b, dims=(1, 2))\nwu = Average(w * u, dims=(1, 2))\nwv = Average(w * v, dims=(1, 2))\n\nsimulation.output_writers[:averages] =\n    JLD2Writer(model, (; U, V, B, wu, wv),\n               schedule = AveragedTimeInterval(output_interval, window=2minutes),\n               filename = \"langmuir_turbulence_averages.jld2\",\n               overwrite_existing = true)","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"JLD2Writer scheduled on TimeInterval(5 minutes):\nâ”œâ”€â”€ filepath: langmuir_turbulence_averages.jld2\nâ”œâ”€â”€ 5 outputs: (U, V, B, wu, wv) averaged on AveragedTimeInterval(window=2 minutes, stride=1, interval=5 minutes)\nâ”œâ”€â”€ array_type: Array{Float32}\nâ”œâ”€â”€ including: [:grid, :coriolis, :buoyancy, :closure]\nâ”œâ”€â”€ file_splitting: NoFileSplitting\nâ””â”€â”€ file size: 44.3 KiB","category":"page"},{"location":"literated/langmuir_turbulence/#Running-the-simulation","page":"Langmuir turbulence","title":"Running the simulation","text":"","category":"section"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"This part is easy,","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"run!(simulation)","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"[ Info: Initializing simulation...\n[ Info: i: 0000, t: 0 seconds, Î”t: 49.500 seconds, umax = (1.4e-03, 8.6e-04, 1.5e-03) msâ»Â¹, wall time: 0 seconds\n[ Info:     ... simulation initialization complete (18.271 seconds)\n[ Info: Executing initial time step...\n[ Info:     ... initial time step complete (4.030 seconds).\n[ Info: i: 0020, t: 11.928 minutes, Î”t: 28.546 seconds, umax = (2.8e-02, 1.3e-02, 2.2e-02) msâ»Â¹, wall time: 23.348 seconds\n[ Info: i: 0040, t: 20.414 minutes, Î”t: 20.471 seconds, umax = (4.1e-02, 1.1e-02, 2.2e-02) msâ»Â¹, wall time: 23.935 seconds\n[ Info: i: 0060, t: 26.785 minutes, Î”t: 17.420 seconds, umax = (4.7e-02, 1.6e-02, 2.3e-02) msâ»Â¹, wall time: 24.343 seconds\n[ Info: i: 0080, t: 32.227 minutes, Î”t: 16.249 seconds, umax = (4.9e-02, 1.6e-02, 2.2e-02) msâ»Â¹, wall time: 24.798 seconds\n[ Info: i: 0100, t: 37.309 minutes, Î”t: 15.839 seconds, umax = (5.0e-02, 1.8e-02, 2.4e-02) msâ»Â¹, wall time: 25.284 seconds\n[ Info: i: 0120, t: 42.350 minutes, Î”t: 15.209 seconds, umax = (5.3e-02, 1.9e-02, 2.6e-02) msâ»Â¹, wall time: 25.789 seconds\n[ Info: i: 0140, t: 47.147 minutes, Î”t: 14.353 seconds, umax = (5.6e-02, 1.9e-02, 2.6e-02) msâ»Â¹, wall time: 26.271 seconds\n[ Info: i: 0160, t: 51.873 minutes, Î”t: 13.830 seconds, umax = (5.8e-02, 2.2e-02, 2.7e-02) msâ»Â¹, wall time: 26.742 seconds\n[ Info: i: 0180, t: 56.109 minutes, Î”t: 13.121 seconds, umax = (5.9e-02, 2.4e-02, 3.2e-02) msâ»Â¹, wall time: 27.299 seconds\n[ Info: i: 0200, t: 1.007 hours, Î”t: 12.571 seconds, umax = (6.2e-02, 2.5e-02, 3.3e-02) msâ»Â¹, wall time: 27.858 seconds\n[ Info: i: 0220, t: 1.075 hours, Î”t: 11.358 seconds, umax = (6.7e-02, 2.6e-02, 2.9e-02) msâ»Â¹, wall time: 28.229 seconds\n[ Info: i: 0240, t: 1.133 hours, Î”t: 11.720 seconds, umax = (6.4e-02, 2.9e-02, 3.7e-02) msâ»Â¹, wall time: 28.772 seconds\n[ Info: i: 0260, t: 1.193 hours, Î”t: 11.097 seconds, umax = (6.5e-02, 3.2e-02, 3.3e-02) msâ»Â¹, wall time: 29.282 seconds\n[ Info: i: 0280, t: 1.253 hours, Î”t: 11.601 seconds, umax = (6.6e-02, 3.0e-02, 3.4e-02) msâ»Â¹, wall time: 29.902 seconds\n[ Info: i: 0300, t: 1.317 hours, Î”t: 11.555 seconds, umax = (7.1e-02, 3.3e-02, 3.4e-02) msâ»Â¹, wall time: 30.230 seconds\n[ Info: i: 0320, t: 1.378 hours, Î”t: 10.922 seconds, umax = (7.1e-02, 3.2e-02, 3.9e-02) msâ»Â¹, wall time: 30.699 seconds\n[ Info: i: 0340, t: 1.434 hours, Î”t: 10.367 seconds, umax = (7.1e-02, 3.4e-02, 3.3e-02) msâ»Â¹, wall time: 31.221 seconds\n[ Info: i: 0360, t: 1.492 hours, Î”t: 10.381 seconds, umax = (7.5e-02, 3.8e-02, 3.7e-02) msâ»Â¹, wall time: 31.653 seconds\n[ Info: i: 0380, t: 1.550 hours, Î”t: 10.226 seconds, umax = (7.2e-02, 3.9e-02, 3.7e-02) msâ»Â¹, wall time: 32.138 seconds\n[ Info: i: 0400, t: 1.607 hours, Î”t: 10.575 seconds, umax = (7.4e-02, 3.8e-02, 3.6e-02) msâ»Â¹, wall time: 32.631 seconds\n[ Info: i: 0420, t: 1.664 hours, Î”t: 9.981 seconds, umax = (7.4e-02, 4.4e-02, 3.8e-02) msâ»Â¹, wall time: 33.097 seconds\n[ Info: i: 0440, t: 1.717 hours, Î”t: 9.759 seconds, umax = (7.7e-02, 4.1e-02, 3.9e-02) msâ»Â¹, wall time: 33.573 seconds\n[ Info: i: 0460, t: 1.766 hours, Î”t: 9.716 seconds, umax = (7.5e-02, 4.0e-02, 4.1e-02) msâ»Â¹, wall time: 34.119 seconds\n[ Info: i: 0480, t: 1.820 hours, Î”t: 9.793 seconds, umax = (7.8e-02, 4.7e-02, 4.1e-02) msâ»Â¹, wall time: 34.561 seconds\n[ Info: i: 0500, t: 1.873 hours, Î”t: 9.423 seconds, umax = (8.0e-02, 4.4e-02, 4.3e-02) msâ»Â¹, wall time: 35.095 seconds\n[ Info: i: 0520, t: 1.925 hours, Î”t: 9.852 seconds, umax = (7.7e-02, 4.7e-02, 3.9e-02) msâ»Â¹, wall time: 35.701 seconds\n[ Info: i: 0540, t: 1.980 hours, Î”t: 9.789 seconds, umax = (7.7e-02, 4.5e-02, 4.0e-02) msâ»Â¹, wall time: 36.072 seconds\n[ Info: i: 0560, t: 2.033 hours, Î”t: 9.615 seconds, umax = (8.0e-02, 4.4e-02, 4.3e-02) msâ»Â¹, wall time: 36.597 seconds\n[ Info: i: 0580, t: 2.083 hours, Î”t: 9.360 seconds, umax = (7.8e-02, 4.3e-02, 4.1e-02) msâ»Â¹, wall time: 37.072 seconds\n[ Info: i: 0600, t: 2.134 hours, Î”t: 9.194 seconds, umax = (8.2e-02, 4.7e-02, 4.1e-02) msâ»Â¹, wall time: 37.550 seconds\n[ Info: i: 0620, t: 2.185 hours, Î”t: 9.092 seconds, umax = (8.1e-02, 4.9e-02, 4.2e-02) msâ»Â¹, wall time: 38.123 seconds\n[ Info: i: 0640, t: 2.235 hours, Î”t: 8.834 seconds, umax = (8.3e-02, 4.9e-02, 4.2e-02) msâ»Â¹, wall time: 38.629 seconds\n[ Info: i: 0660, t: 2.283 hours, Î”t: 8.935 seconds, umax = (7.9e-02, 5.4e-02, 4.3e-02) msâ»Â¹, wall time: 39.154 seconds\n[ Info: i: 0680, t: 2.332 hours, Î”t: 8.901 seconds, umax = (8.2e-02, 5.2e-02, 4.4e-02) msâ»Â¹, wall time: 39.679 seconds\n[ Info: i: 0700, t: 2.380 hours, Î”t: 8.844 seconds, umax = (8.5e-02, 4.9e-02, 4.2e-02) msâ»Â¹, wall time: 40.204 seconds\n[ Info: i: 0720, t: 2.429 hours, Î”t: 8.692 seconds, umax = (7.9e-02, 5.5e-02, 4.1e-02) msâ»Â¹, wall time: 40.778 seconds\n[ Info: i: 0740, t: 2.477 hours, Î”t: 8.402 seconds, umax = (8.1e-02, 5.0e-02, 4.3e-02) msâ»Â¹, wall time: 41.206 seconds\n[ Info: i: 0760, t: 2.523 hours, Î”t: 8.604 seconds, umax = (8.0e-02, 5.4e-02, 4.6e-02) msâ»Â¹, wall time: 41.711 seconds\n[ Info: i: 0780, t: 2.572 hours, Î”t: 8.758 seconds, umax = (8.3e-02, 5.1e-02, 4.0e-02) msâ»Â¹, wall time: 42.195 seconds\n[ Info: i: 0800, t: 2.620 hours, Î”t: 8.567 seconds, umax = (8.3e-02, 5.7e-02, 4.3e-02) msâ»Â¹, wall time: 42.728 seconds\n[ Info: i: 0820, t: 2.667 hours, Î”t: 8.652 seconds, umax = (8.2e-02, 5.6e-02, 4.1e-02) msâ»Â¹, wall time: 43.274 seconds\n[ Info: i: 0840, t: 2.715 hours, Î”t: 8.539 seconds, umax = (8.5e-02, 5.5e-02, 4.4e-02) msâ»Â¹, wall time: 43.777 seconds\n[ Info: i: 0860, t: 2.762 hours, Î”t: 8.378 seconds, umax = (8.7e-02, 6.1e-02, 4.3e-02) msâ»Â¹, wall time: 44.354 seconds\n[ Info: i: 0880, t: 2.808 hours, Î”t: 8.405 seconds, umax = (8.2e-02, 6.1e-02, 5.1e-02) msâ»Â¹, wall time: 44.778 seconds\n[ Info: i: 0900, t: 2.852 hours, Î”t: 8.092 seconds, umax = (8.7e-02, 6.1e-02, 4.7e-02) msâ»Â¹, wall time: 45.284 seconds\n[ Info: i: 0920, t: 2.896 hours, Î”t: 8.589 seconds, umax = (8.6e-02, 5.8e-02, 4.6e-02) msâ»Â¹, wall time: 45.772 seconds\n[ Info: i: 0940, t: 2.941 hours, Î”t: 8.642 seconds, umax = (8.5e-02, 6.0e-02, 4.5e-02) msâ»Â¹, wall time: 46.276 seconds\n[ Info: i: 0960, t: 2.988 hours, Î”t: 8.445 seconds, umax = (8.2e-02, 5.7e-02, 4.6e-02) msâ»Â¹, wall time: 46.773 seconds\n[ Info: i: 0980, t: 3.032 hours, Î”t: 8.578 seconds, umax = (8.3e-02, 6.0e-02, 4.5e-02) msâ»Â¹, wall time: 47.312 seconds\n[ Info: i: 1000, t: 3.079 hours, Î”t: 8.294 seconds, umax = (8.5e-02, 5.8e-02, 4.6e-02) msâ»Â¹, wall time: 47.812 seconds\n[ Info: i: 1020, t: 3.125 hours, Î”t: 8.305 seconds, umax = (8.7e-02, 6.4e-02, 4.4e-02) msâ»Â¹, wall time: 48.357 seconds\n[ Info: i: 1040, t: 3.169 hours, Î”t: 7.909 seconds, umax = (8.4e-02, 6.4e-02, 4.7e-02) msâ»Â¹, wall time: 49.044 seconds\n[ Info: i: 1060, t: 3.213 hours, Î”t: 8.247 seconds, umax = (8.5e-02, 6.1e-02, 4.6e-02) msâ»Â¹, wall time: 49.435 seconds\n[ Info: i: 1080, t: 3.259 hours, Î”t: 8.531 seconds, umax = (8.5e-02, 5.9e-02, 4.3e-02) msâ»Â¹, wall time: 50.053 seconds\n[ Info: i: 1100, t: 3.306 hours, Î”t: 8.403 seconds, umax = (8.3e-02, 6.0e-02, 4.4e-02) msâ»Â¹, wall time: 50.453 seconds\n[ Info: i: 1120, t: 3.352 hours, Î”t: 8.099 seconds, umax = (8.9e-02, 6.3e-02, 4.5e-02) msâ»Â¹, wall time: 50.971 seconds\n[ Info: i: 1140, t: 3.396 hours, Î”t: 7.781 seconds, umax = (8.9e-02, 6.3e-02, 4.4e-02) msâ»Â¹, wall time: 51.462 seconds\n[ Info: i: 1160, t: 3.439 hours, Î”t: 7.871 seconds, umax = (8.9e-02, 6.7e-02, 4.9e-02) msâ»Â¹, wall time: 51.994 seconds\n[ Info: i: 1180, t: 3.482 hours, Î”t: 8.028 seconds, umax = (9.3e-02, 6.4e-02, 4.4e-02) msâ»Â¹, wall time: 52.486 seconds\n[ Info: i: 1200, t: 3.527 hours, Î”t: 8.154 seconds, umax = (8.9e-02, 6.4e-02, 5.4e-02) msâ»Â¹, wall time: 53.004 seconds\n[ Info: i: 1220, t: 3.573 hours, Î”t: 8.197 seconds, umax = (8.6e-02, 6.8e-02, 5.8e-02) msâ»Â¹, wall time: 53.501 seconds\n[ Info: i: 1240, t: 3.618 hours, Î”t: 8.114 seconds, umax = (8.6e-02, 6.7e-02, 5.4e-02) msâ»Â¹, wall time: 54.036 seconds\n[ Info: i: 1260, t: 3.663 hours, Î”t: 8.122 seconds, umax = (9.0e-02, 6.5e-02, 5.2e-02) msâ»Â¹, wall time: 54.532 seconds\n[ Info: i: 1280, t: 3.705 hours, Î”t: 8.288 seconds, umax = (9.0e-02, 6.5e-02, 4.7e-02) msâ»Â¹, wall time: 55.069 seconds\n[ Info: i: 1300, t: 3.750 hours, Î”t: 8.185 seconds, umax = (9.1e-02, 6.3e-02, 4.3e-02) msâ»Â¹, wall time: 55.569 seconds\n[ Info: i: 1320, t: 3.796 hours, Î”t: 8.045 seconds, umax = (9.3e-02, 6.0e-02, 4.6e-02) msâ»Â¹, wall time: 56.102 seconds\n[ Info: i: 1340, t: 3.840 hours, Î”t: 7.981 seconds, umax = (8.7e-02, 6.0e-02, 4.7e-02) msâ»Â¹, wall time: 56.787 seconds\n[ Info: i: 1360, t: 3.884 hours, Î”t: 7.764 seconds, umax = (8.9e-02, 6.7e-02, 5.2e-02) msâ»Â¹, wall time: 57.159 seconds\n[ Info: i: 1380, t: 3.928 hours, Î”t: 7.590 seconds, umax = (8.9e-02, 5.9e-02, 5.0e-02) msâ»Â¹, wall time: 57.753 seconds\n[ Info: i: 1400, t: 3.970 hours, Î”t: 7.708 seconds, umax = (8.8e-02, 5.6e-02, 4.6e-02) msâ»Â¹, wall time: 58.157 seconds\n[ Info: Simulation is stopping after running for 58.559 seconds.\n[ Info: Simulation time 4 hours equals or exceeds stop time 4 hours.\n","category":"page"},{"location":"literated/langmuir_turbulence/#Making-a-neat-movie","page":"Langmuir turbulence","title":"Making a neat movie","text":"","category":"section"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"We look at the results by loading data from file with FieldTimeSeries, and plotting vertical slices of u and w, and a horizontal slice of w to look for Langmuir cells.","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"using CairoMakie\n\ntime_series = (;\n     w = FieldTimeSeries(\"langmuir_turbulence_fields.jld2\", \"w\"),\n     u = FieldTimeSeries(\"langmuir_turbulence_fields.jld2\", \"u\"),\n     B = FieldTimeSeries(\"langmuir_turbulence_averages.jld2\", \"B\"),\n     U = FieldTimeSeries(\"langmuir_turbulence_averages.jld2\", \"U\"),\n     V = FieldTimeSeries(\"langmuir_turbulence_averages.jld2\", \"V\"),\n    wu = FieldTimeSeries(\"langmuir_turbulence_averages.jld2\", \"wu\"),\n    wv = FieldTimeSeries(\"langmuir_turbulence_averages.jld2\", \"wv\"))\n\ntimes = time_series.w.times","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"We are now ready to animate using Makie. We use Makie's Observable to animate the data. To dive into how Observables work we refer to Makie.jl's Documentation.","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"n = Observable(1)\n\nwxy_title = @lift string(\"w(x, y, t) at z=-8 m and t = \", prettytime(times[$n]))\nwxz_title = @lift string(\"w(x, z, t) at y=0 m and t = \", prettytime(times[$n]))\nuxz_title = @lift string(\"u(x, z, t) at y=0 m and t = \", prettytime(times[$n]))\n\nfig = Figure(size = (850, 850))\n\nax_B = Axis(fig[1, 4];\n            xlabel = \"Buoyancy (m sâ»Â²)\",\n            ylabel = \"z (m)\")\n\nax_U = Axis(fig[2, 4];\n            xlabel = \"Velocities (m sâ»Â¹)\",\n            ylabel = \"z (m)\",\n            limits = ((-0.07, 0.07), nothing))\n\nax_fluxes = Axis(fig[3, 4];\n                 xlabel = \"Momentum fluxes (mÂ² sâ»Â²)\",\n                 ylabel = \"z (m)\",\n                 limits = ((-3.5e-5, 3.5e-5), nothing))\n\nax_wxy = Axis(fig[1, 1:2];\n              xlabel = \"x (m)\",\n              ylabel = \"y (m)\",\n              aspect = DataAspect(),\n              limits = ((0, grid.Lx), (0, grid.Ly)),\n              title = wxy_title)\n\nax_wxz = Axis(fig[2, 1:2];\n              xlabel = \"x (m)\",\n              ylabel = \"z (m)\",\n              aspect = AxisAspect(2),\n              limits = ((0, grid.Lx), (-grid.Lz, 0)),\n              title = wxz_title)\n\nax_uxz = Axis(fig[3, 1:2];\n              xlabel = \"x (m)\",\n              ylabel = \"z (m)\",\n              aspect = AxisAspect(2),\n              limits = ((0, grid.Lx), (-grid.Lz, 0)),\n              title = uxz_title)\n\n\nwâ‚™ = @lift time_series.w[$n]\nuâ‚™ = @lift time_series.u[$n]\nBâ‚™ = @lift view(time_series.B[$n], 1, 1, :)\nUâ‚™ = @lift view(time_series.U[$n], 1, 1, :)\nVâ‚™ = @lift view(time_series.V[$n], 1, 1, :)\nwuâ‚™ = @lift view(time_series.wu[$n], 1, 1, :)\nwvâ‚™ = @lift view(time_series.wv[$n], 1, 1, :)\n\nk = searchsortedfirst(znodes(grid, Face(); with_halos=true), -8)\nwxyâ‚™ = @lift view(time_series.w[$n], :, :, k)\nwxzâ‚™ = @lift view(time_series.w[$n], :, 1, :)\nuxzâ‚™ = @lift view(time_series.u[$n], :, 1, :)\n\nwlims = (-0.03, 0.03)\nulims = (-0.05, 0.05)\n\nlines!(ax_B, Bâ‚™)\n\nlines!(ax_U, Uâ‚™; label = L\"\\bar{u}\")\nlines!(ax_U, Vâ‚™; label = L\"\\bar{v}\")\naxislegend(ax_U; position = :rb)\n\nlines!(ax_fluxes, wuâ‚™; label = L\"mean $wu$\")\nlines!(ax_fluxes, wvâ‚™; label = L\"mean $wv$\")\naxislegend(ax_fluxes; position = :rb)\n\nhm_wxy = heatmap!(ax_wxy, wxyâ‚™;\n                  colorrange = wlims,\n                  colormap = :balance)\n\nColorbar(fig[1, 3], hm_wxy; label = \"m sâ»Â¹\")\n\nhm_wxz = heatmap!(ax_wxz, wxzâ‚™;\n                  colorrange = wlims,\n                  colormap = :balance)\n\nColorbar(fig[2, 3], hm_wxz; label = \"m sâ»Â¹\")\n\nax_uxz = heatmap!(ax_uxz, uxzâ‚™;\n                  colorrange = ulims,\n                  colormap = :balance)\n\nColorbar(fig[3, 3], ax_uxz; label = \"m sâ»Â¹\")\n\nfig","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"(Image: )","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"And, finally, we record a movie.","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"frames = 1:length(times)\n\nCairoMakie.record(fig, \"langmuir_turbulence.mp4\", frames, framerate=8) do i\n    n[] = i\nend","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"(Image: )","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"This page was generated using Literate.jl.","category":"page"},{"location":"physics/hydrostatic_free_surface_model/#hydrostatic_free_surface_model","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"","category":"section"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"The HydrostaticFreeSurfaceModel solves the incompressible Navier-Stokes equations under the Boussinesq and hydrostatic approximations and with an arbitrary number of tracer conservation equations. Physics associated with individual terms in the momentum and tracer conservation equations â€“ the background rotation rate of the equation's reference frame, gravitational effects associated with buoyant tracers under the Boussinesq approximation, generalized stresses and tracer fluxes associated with viscous and diffusive physics, and arbitrary \"forcing functions\" â€“ are determined by the whims of the user.","category":"page"},{"location":"physics/hydrostatic_free_surface_model/#hydrostatic_mass_conservation_free_surface","page":"Hydrostatic model with a free surface","title":"Mass conservation and free surface evolution equation","text":"","category":"section"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"The mass conservation equation is","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"    0 = boldsymbolnabla_h boldsymbolcdot boldsymbolu + partial_z w  ","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"Given the horizontal flow boldsymbolu we use the above to diagnose the vertical velocity w. We integrate the mass conservation equation from the bottom of the fluid (where w = 0) up to depth z and recover w(x y z t).","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"The free surface displacement eta(x y t) satisfies the linearized kinematic boundary condition at the surface","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"    partial_t eta = w(x y z=0 t)  ","category":"page"},{"location":"physics/hydrostatic_free_surface_model/#The-momentum-conservation-equation","page":"Hydrostatic model with a free surface","title":"The momentum conservation equation","text":"","category":"section"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"The equations governing the conservation of momentum in a rotating fluid, including buoyancy via the Boussinesq approximation are","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"    beginalign\n    partial_t boldsymbolu  = - left ( boldsymbolv boldsymbolcdot boldsymbolnabla right ) boldsymbolu\n                        - boldsymbolf times boldsymbolu\n                        - boldsymbolnabla_h (p + g eta)\n                        - boldsymbolnabla boldsymbolcdot boldsymboltau\n                        + boldsymbolF_u   labeleqmomentum\n    0  = b - partial_z p   labeleqhydrostatic\n    endalign","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"where b the is buoyancy, boldsymboltau is the hydrostatic kinematic stress tensor, boldsymbolF_u denotes an internal forcing of the horizontal flow boldsymbolu, boldsymbolv = boldsymbolu + w hatboldsymbolz is the three-dimensional flow, p is kinematic pressure, eta is the free-surface displacement, and boldsymbolf is the Coriolis parameter, or the background vorticity associated with the specified rate of rotation of the frame of reference.","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"We can recast the advection term (boldsymbolv boldsymbolcdot boldsymbolnabla) boldsymbolu above in vector-invariant form as:","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"left ( boldsymbolv boldsymbolcdot boldsymbolnabla right ) boldsymbolu = zeta hatboldsymbolz times boldsymbolu + boldsymbolnablaleft(frac12 boldsymbolu boldsymbolcdot boldsymboluright) + w partial_z boldsymbolu","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"with zeta(x y t) = partial_x v - partial_y u the vertical component of the relative vorticity. The vector-invariant form is used with curvilinear grids, like LatitudeLongitudeGrid or OrthogonalSphericalShellGrid.","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"The hydrostatic approximation \\eqref{eq:hydrostatic} above comes about as the dominant balance of terms in the Navier-Stokes vertical momentum equation under the Boussinesq approximation.","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"The terms that appear on the right-hand side of the momentum conservation equation are (in order):","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"momentum advection: left ( boldsymbolv boldsymbolcdot boldsymbolnabla right ) boldsymbolu,\nCoriolis: boldsymbolf times boldsymbolu,\nbaroclinic kinematic pressure gradient: boldsymbolnabla p,\nbarotropic kinematic pressure gradient: boldsymbolnabla (g eta),\nmolecular or turbulence viscous stress: boldsymbolnabla boldsymbolcdot boldsymboltau, and\nan arbitrary internal source of momentum: boldsymbolF_u.","category":"page"},{"location":"physics/hydrostatic_free_surface_model/#The-tracer-conservation-equation","page":"Hydrostatic model with a free surface","title":"The tracer conservation equation","text":"","category":"section"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"The conservation law for tracers is","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"    beginalign\n    partial_t c = - boldsymbolv boldsymbolcdot boldsymbolnabla c\n                   - boldsymbolnabla boldsymbolcdot boldsymbolq_c\n                   + F_c  \n    labeleqtracer\n    endalign","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"where boldsymbolq_c is the diffusive flux of c and F_c is an arbitrary source term. An arbitrary tracers are permitted and thus an arbitrary number of tracer equations can be solved simultaneously alongside with the momentum equations.","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"From left to right, the terms that appear on the right-hand side of the tracer conservation equation are","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"tracer advection: boldsymbolv boldsymbolcdot boldsymbolnabla c,\nmolecular or turbulent diffusion: boldsymbolnabla boldsymbolcdot boldsymbolq_c, and\nan arbitrary internal source of tracer: F_c.","category":"page"},{"location":"physics/hydrostatic_free_surface_model/#Vertical-coordinates","page":"Hydrostatic model with a free surface","title":"Vertical coordinates","text":"","category":"section"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"We can use either ZCoordinate, that is height coordinate, or the ZStarCoordinate generalized vertical coordinate.","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"The ZStarCoordinate vertical coordinate conserves tracers and volume with the grid following  the evolution of the free surface in the domain (Adcroft and Campin, 2004).","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"In terms of the notation in the Generalized vertical coordinates section, for a ZCoordinate we have that","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"r(x y z t) = z","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"and the specific thickness is sigma = partial z  partial r = 1.","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"The ZStarCoordinate generalized vertical coordinate is often denoted as z^* (zee-star), i.e.,","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"beginequation\n    r(x y z t) = z^*(x y z t) = fracH(x y)H(x y) + eta(x y t)z - eta(x y t) labelzstardef\nendequation","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"where eta is the free surface and z = -H(x y) is the bottom of the domain.","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"(Image: Schematic of the quantities involved in the ZStarCoordinate generalized vertical coordinate)","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"Note that in both depth and z^* coordinates, the bottom boundary is the same z = z^* = - H(x y). On the other hand, while in depth coordinates the upper boundary z = eta(x y t) changes with time, but in z^* coordinates is fixed to z^* = 0.","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"The ZStarCoordinate definition \\eqref{zstardef} implies a specific thickness","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"sigma = 1 + fracetaH","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"All the equations transformed in r-coordinates are described in the Generalized vertical coordinates section.","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"For the specific choice of ZStarCoordinate coordinate \\eqref{zstardef}, the partial etapartial r identically vanishes and thus the horizontal gradient of the free surface remain unchanged under vertical coordinate transformation, i.e.,","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"beginalign\n    fracpartial etapartial x biggrvert_z  = fracpartial etapartial x biggrvert_r \n    fracpartial etapartial y biggrvert_z  = fracpartial etapartial y biggrvert_r\nendalign","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"An example of how the vertical coordinate surfaces differ for ZCoordinate and the time-varying ZStarCoordinate coordinate is shown below.","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"using CairoMakie\n\nLx, Lz = 1e3, 25 # m\n\nx = range(-Lx/2, stop=Lx/2, length=200)\n\nÏƒ = Lx/15 # a horizontal length scale\n\n# bottom, H(x)\nxâ‚€, hâ‚€ = -Lx/3,  15 # m\nslope = @. hâ‚€ * (1 + tanh(-(x - xâ‚€) / Ïƒ)) / 2\nxâ‚€, hâ‚€ = Lx/3, 6 # m\nmountain = @. hâ‚€ * sech((x - xâ‚€) / Ïƒ)^2\nH = @. Lz - slope - mountain\n\n# free surface, Î·(x)\nxâ‚€ = -Lx/8\nÎ·â‚€ = 2.5 # m\nt = Observable(0.0)\nÎ· = @lift @. -Î·â‚€ * ((x - xâ‚€)^2 / Ïƒ^2 - 1) * exp(-(x - xâ‚€)^2 / 2Ïƒ^2) * cos(2Ï€ * $t)\n\nfig = Figure(size=(1000, 400))\naxis_kwargs = (titlesize = 20, xlabel = \"x\", ygridvisible = false)\nax1 = Axis(fig[1, 1]; title=\"ZCoordinate\", ylabel=\"z\", axis_kwargs...)\nax2 = Axis(fig[1, 2]; title=\"ZStarCoordinate\", axis_kwargs...)\n\nfor ax in (ax1, ax2)\n    band!(ax, x, -H, Î·, color = (:dodgerblue, 0.5))\n    band!(ax, x, -1.1 * Lz, -H, color = (:orange, 0.2))\n    lines!(ax, x,  Î·, linewidth=5, color=:darkblue)\n    lines!(ax, x, -H, linewidth=5, color=:darkgrey)\nend\n\nfor r in range(-Lz, stop=0, length=6)\n    # ZCoordinate\n    z = r * ones(size(x))\n    lines!(ax1, x, z, color=:crimson, linestyle=:dash)\n\n    # ZStarCoordinate\n    z = lift(Î·) do Î·_val\n        @. r * (H + Î·_val) / H + Î·_val\n    end\n    lines!(ax2, x, z, color=:crimson, linestyle=:dash)\nend\n\nNt = 50\ntimes = 0:1/Nt:1-1/Nt # one period of cos(2Ï€t)\nCairoMakie.record(fig, \"z-zstar.gif\", times, framerate=12) do val\n    t[] = val\nend\n\nnothing #hide","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"(Image: )","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"Near the top, the surfaces of ZStarCoordinate mimic the free surface. Further away from the fluid's surface, the surfaces of ZStarCoordinate resemble more surfaces of constant depth ZCoordinate.","category":"page"},{"location":"fields/#Fields-basics","page":"Fields","title":"Fields basics","text":"","category":"section"},{"location":"fields/","page":"Fields","title":"Fields","text":"Fields and its relatives are core Oceananigans data structures. Fields are arrays of data located on a grid, whose entries correspond to the average value of some quantity over some finite-sized volume. Fields also may contain boundary_conditions, may be computed from an operand or expression involving other fields, and may cover only a portion of the total indices spanned by the grid.","category":"page"},{"location":"fields/#Staggered-grids-and-field-locations","page":"Fields","title":"Staggered grids and field locations","text":"","category":"section"},{"location":"fields/","page":"Fields","title":"Fields","text":"Oceananigans ocean-flavored fluids simulations rely fundamentally on \"staggered grid\" numerical methods.","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"Recall that grids represent a physical domain divided into finite volumes. For example, let's consider a horizontally-periodic, vertically-bounded grid of cells that divide up a cube with dimensions 1 times 1 times 1:","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"using Oceananigans\n\ngrid = RectilinearGrid(topology = (Periodic, Periodic, Bounded),\n                       size = (4, 5, 4),\n                       halo = (1, 1, 1),\n                       x = (0, 1),\n                       y = (0, 1),\n                       z = [0, 0.1, 0.3, 0.6, 1])\n\n# output\n4Ã—5Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1Ã—1Ã—1 halo\nâ”œâ”€â”€ Periodic x âˆˆ [0.0, 1.0) regularly spaced with Î”x=0.25\nâ”œâ”€â”€ Periodic y âˆˆ [0.0, 1.0) regularly spaced with Î”y=0.2\nâ””â”€â”€ Bounded  z âˆˆ [0.0, 1.0] variably spaced with min(Î”z)=0.1, max(Î”z)=0.4","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"The cubic domain is divided into a \"primary mesh\" of 4 times 5 times 4 = 80 cells, which are evenly spaced in x y but variably spaced in z. Now, in addition to the primary mesh, the grid defines also a set of \"staggered\" grids whose cells are shifted by half a cell width relative to the primary mesh. In other words, the staggered grid cells have a \"location\" in each direction â€“ either Center, and therefore co-located with the primary mesh, or Face and located over the interfaces of the primary mesh. For example, the primary or Center cell spacings in z are","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"zspacings(grid, Center())[:, :, 1:4]\n\n# output\n4-element Vector{Float64}:\n 0.1\n 0.19999999999999998\n 0.3\n 0.4","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"corresponding to cell interfaces located at z = [0, 0.1, 0.3, 0.6, 1]. But then for the grid which is staggered in z relative to the primary mesh,","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"zspacings(grid, Face())[:, :, 1:5]\n\n# output\n5-element Vector{Float64}:\n 0.1\n 0.15000000000000002\n 0.24999999999999994\n 0.3500000000000001\n 0.3999999999999999","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"The cells for the vertically staggered grid have different spacings than the primary mesh. That's because the edges of the vertically-staggered mesh coincide with the nodes (the cell centers) of the primary mesh. The nodes of the primary mesh are","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"znodes(grid, Center(), with_halos=true)\n\n# output\n6-element OffsetArray(::Vector{Float64}, 0:5) with eltype Float64 with indices 0:5:\n -0.05\n  0.05\n  0.2\n  0.44999999999999996\n  0.8\n  1.2","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"The center of the leftmost \"halo cell\" is z = -0.05, while the center of the first cell from the left is z = 0.05. This means that the width of the first cell on the vertically-staggered grid is 0.05 - (-0.05) = 0.1 â€“ and so on. Finally, note that the nodes of the staggered mesh coincide with the cell interfaces of the primary mesh, so:","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"znodes(grid, Center())\n\n# output\n4-element view(::Vector{Float64}, 2:5) with eltype Float64:\n 0.05\n 0.2\n 0.44999999999999996\n 0.8","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"In a three-dimensional domain, there are 2Â³ = 8 meshes â€“ 1 primary mesh, and 7 meshes that are staggered to varying degrees from the primary mesh. This system of staggered grids is commonly used in fluid dynamics and was invented specifically for simulations of the atmosphere and ocean.","category":"page"},{"location":"fields/#Constructing-Fields-at-specified-locations","page":"Fields","title":"Constructing Fields at specified locations","text":"","category":"section"},{"location":"fields/","page":"Fields","title":"Fields","text":"Every Field is associated with either the primary mesh or one of the staggered meshes by a three-dimensional \"location\" associated with each field. To build a fully-centered Field, for example, we write","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"c = Field{Center, Center, Center}(grid)\n\n# output\n4Ã—5Ã—4 Field{Center, Center, Center} on RectilinearGrid on CPU\nâ”œâ”€â”€ grid: 4Ã—5Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1Ã—1Ã—1 halo\nâ”œâ”€â”€ boundary conditions: FieldBoundaryConditions\nâ”‚   â””â”€â”€ west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: Nothing\nâ””â”€â”€ data: 6Ã—7Ã—6 OffsetArray(::Array{Float64, 3}, 0:5, 0:6, 0:5) with eltype Float64 with indices 0:5Ã—0:6Ã—0:5\n    â””â”€â”€ max=0.0, min=0.0, mean=0.0","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"Fully-centered fields also go by the alias CenterField,","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"c == CenterField(grid)\n\n# output\ntrue","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"Many fluid dynamical variables are located at cell centers â€“ for example, tracers like temperature and salinity. Another common type of Field we encounter have cells located over the x-interfaces of the primary grid,","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"u = Field{Face, Center, Center}(grid)\n\n# output\n4Ã—5Ã—4 Field{Face, Center, Center} on RectilinearGrid on CPU\nâ”œâ”€â”€ grid: 4Ã—5Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1Ã—1Ã—1 halo\nâ”œâ”€â”€ boundary conditions: FieldBoundaryConditions\nâ”‚   â””â”€â”€ west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: Nothing\nâ””â”€â”€ data: 6Ã—7Ã—6 OffsetArray(::Array{Float64, 3}, 0:5, 0:6, 0:5) with eltype Float64 with indices 0:5Ã—0:6Ã—0:5\n    â””â”€â”€ max=0.0, min=0.0, mean=0.0","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"which also goes by the alias u = XFaceField(grid). The name u is suggestive: in the Arakawa type-C grid ('C-grid' for short) used by Oceananigans, the x-component of the velocity field is stored at Face, Center, Center location.","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"The centers of the u cells are shifted to the left relative to the c cells:","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"@show collect(xnodes(c))\n@show collect(xnodes(u))\nnothing\n\n# output\ncollect(xnodes(c)) = [0.125, 0.375, 0.625, 0.875]\ncollect(xnodes(u)) = [0.0, 0.25, 0.5, 0.75]","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"Notice that the first u-node is at x=0, the left end of the grid, but the last u-node is at x=0.75. Because the x-direction is Periodic, the XFaceField u has 4 cells in x â€“ the cell just right of x=0.75 is the same as the cell at x=0.","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"Because the vertical direction is Bounded, however, vertically-staggered fields have more vertical cells than CenterFields:","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"w = Field{Center, Center, Face}(grid)\n\n@show collect(znodes(c))\n@show collect(znodes(w))\nnothing\n\n# output\ncollect(znodes(c)) = [0.05, 0.2, 0.44999999999999996, 0.8]\ncollect(znodes(w)) = [0.0, 0.1, 0.3, 0.6, 1.0]","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"Fields at Center, Center, Face are also called ZFaceField, and the vertical velocity is a ZFaceField on the C-grid. Let's visualize the situation:","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"using CairoMakie\n\nfig = Figure(size=(600, 180))\nax = Axis(fig[1, 1], xlabel=\"x\")\n\n# Visualize the domain\nlines!(ax, [0, 1], [0, 0], color=:gray)\n\nxc = xnodes(c)\nxu = xnodes(u)\n\nscatter!(ax, xc, 0 * xc, marker=:circle, markersize=10, label=\"Cell centers\")\nscatter!(ax, xu, 0 * xu, marker=:vline, markersize=20, label=\"Cell interfaces\")\n\nylims!(ax, -1, 1)\nxlims!(ax, -0.1, 1.1)\nhideydecorations!(ax)\nhidexdecorations!(ax, ticklabels=false, label=false)\nhidespines!(ax)\n\nLegend(fig[0, 1], ax, nbanks=2, framevisible=false)\n\ncurrent_figure()","category":"page"},{"location":"fields/#Setting-Fields","page":"Fields","title":"Setting Fields","text":"","category":"section"},{"location":"fields/","page":"Fields","title":"Fields","text":"Fields are full of 0's when they are created, which is not very exciting. The situation can be improved using set! to change the values of a field. For example,","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"set!(c, 42)\n\n# output\n4Ã—5Ã—4 Field{Center, Center, Center} on RectilinearGrid on CPU\nâ”œâ”€â”€ grid: 4Ã—5Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1Ã—1Ã—1 halo\nâ”œâ”€â”€ boundary conditions: FieldBoundaryConditions\nâ”‚   â””â”€â”€ west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: Nothing\nâ””â”€â”€ data: 6Ã—7Ã—6 OffsetArray(::Array{Float64, 3}, 0:5, 0:6, 0:5) with eltype Float64 with indices 0:5Ã—0:6Ã—0:5\n    â””â”€â”€ max=42.0, min=42.0, mean=42.0","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"Now c is filled with 42s (for this simple case, we could also have used c .= 42). Let's confirm that:","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"c[1, 1, 1]\n\n# output\n42.0","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"Looks good. And","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"c[1:4, 1:5, 1]\n\n# output\n4Ã—5 Matrix{Float64}:\n 42.0  42.0  42.0  42.0  42.0\n 42.0  42.0  42.0  42.0  42.0\n 42.0  42.0  42.0  42.0  42.0\n 42.0  42.0  42.0  42.0  42.0","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"Note that indexing into c is the same as indexing into c.data.","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"c[:, :, :] == c.data\n\n# output\ntrue","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"We can also set! with arrays,","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"random_stuff = rand(size(c)...)\nset!(c, random_stuff)\n\nheatmap(view(c, :, :, 1))","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"or even use functions to set,","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"fun_stuff(x, y, z) = 2x\nset!(c, fun_stuff)\n\n# output\n4Ã—5Ã—4 Field{Center, Center, Center} on RectilinearGrid on CPU\nâ”œâ”€â”€ grid: 4Ã—5Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1Ã—1Ã—1 halo\nâ”œâ”€â”€ boundary conditions: FieldBoundaryConditions\nâ”‚   â””â”€â”€ west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: Nothing\nâ””â”€â”€ data: 6Ã—7Ã—6 OffsetArray(::Array{Float64, 3}, 0:5, 0:6, 0:5) with eltype Float64 with indices 0:5Ã—0:6Ã—0:5\n    â””â”€â”€ max=1.75, min=0.25, mean=1.0","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"and plot it","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"heatmap(view(c, :, :, 1))","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"For Fields on three-dimensional grids, set! functions must have arguments x, y, z for RectilinearGrid, or Î», Ï†, z for LatitudeLongitudeGrid and OrthogonalSphericalShellGrid. But for Fields on one- and two-dimensional grids, only the arguments that correspond to the non-Flat directions must be included. For example, to set! on a one-dimensional grid we write","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"# Make a field on a one-dimensional grid\none_d_grid = RectilinearGrid(size=7, x=(0, 7), topology=(Periodic, Flat, Flat))\none_d_c = CenterField(one_d_grid)\n\n# The one-dimensional grid varies only in `x`\nstill_pretty_fun(x) = 3x\nset!(one_d_c, still_pretty_fun)\n\n# output\n7Ã—1Ã—1 Field{Center, Center, Center} on RectilinearGrid on CPU\nâ”œâ”€â”€ grid: 7Ã—1Ã—1 RectilinearGrid{Float64, Periodic, Flat, Flat} on CPU with 3Ã—0Ã—0 halo\nâ”œâ”€â”€ boundary conditions: FieldBoundaryConditions\nâ”‚   â””â”€â”€ west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: Nothing\nâ””â”€â”€ data: 13Ã—1Ã—1 OffsetArray(::Array{Float64, 3}, -2:10, 1:1, 1:1) with eltype Float64 with indices -2:10Ã—1:1Ã—1:1\n    â””â”€â”€ max=19.5, min=1.5, mean=10.5","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"note: Note\nField data is always stored in three-dimensional arrays â€“- even when they have Nothing locations, or on grids with Flat directions. As a result, Fields are indexed with three indices i, j, k, with Flat directions indexed with 1.","category":"page"},{"location":"fields/#A-bit-more-about-setting-with-functions","page":"Fields","title":"A bit more about setting with functions","text":"","category":"section"},{"location":"fields/","page":"Fields","title":"Fields","text":"Let's return to the three-dimensional fun_stuff case to investigate in more detail how set! works with functions. The xnodes of c â€“ the coordinates of the center of c's finite volumes â€“ are:","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"xc = xnodes(c)\n@show collect(xc)\nnothing # hide\n\n# output\ncollect(xc) = [0.125, 0.375, 0.625, 0.875]","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"To set! the values of c we evaluate fun_stuff at c's nodes, producing","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"c[1:4, 1, 1]\n\n# output\n4-element Vector{Float64}:\n 0.25\n 0.75\n 1.25\n 1.75","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"note: Note\nThis function-setting method is a first-order method for computing the finite volume of c to fun_stuff. Higher-order algorithms could be implemented â€“ have a crack if you're keen.","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"As a result set! can evaluate differently on Fields at different locations:","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"u = XFaceField(grid)\nset!(u, fun_stuff)\nu[1:4, 1, 1]\n\n# output\n4-element Vector{Float64}:\n 0.0\n 0.5\n 1.0\n 1.5","category":"page"},{"location":"fields/#Halo-regions-and-boundary-conditions","page":"Fields","title":"Halo regions and boundary conditions","text":"","category":"section"},{"location":"fields/","page":"Fields","title":"Fields","text":"We built grid with halo = (1, 1, 1), which means that the \"interior\" cells of the grid are surrounded by a \"halo region\" of cells that's one cell thick. The number of halo cells in each direction are stored in the properties Hx, Hy, Hz, so,","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"(grid.Hx, grid.Hy, grid.Hz)\n\n# output\n(1, 1, 1)","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"set! doesn't touch halo cells. Check out one of the two-dimensional slices of c showing both the interior and the halo regions:","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"c[:, :, 1]\n\n# output\n6Ã—7 OffsetArray(::Matrix{Float64}, 0:5, 0:6) with eltype Float64 with indices 0:5Ã—0:6:\n 0.0  0.0   0.0   0.0   0.0   0.0   0.0\n 0.0  0.25  0.25  0.25  0.25  0.25  0.0\n 0.0  0.75  0.75  0.75  0.75  0.75  0.0\n 0.0  1.25  1.25  1.25  1.25  1.25  0.0\n 0.0  1.75  1.75  1.75  1.75  1.75  0.0\n 0.0  0.0   0.0   0.0   0.0   0.0   0.0","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"The interior region is populated, but the surrounding halo regions are all 0. To remedy this situation we need to fill_halo_regions!:","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"using Oceananigans.BoundaryConditions: fill_halo_regions!\n\nfill_halo_regions!(c)\n\nc[:, :, 1]\n\n# output\n6Ã—7 OffsetArray(::Matrix{Float64}, 0:5, 0:6) with eltype Float64 with indices 0:5Ã—0:6:\n 1.75  1.75  1.75  1.75  1.75  1.75  1.75\n 0.25  0.25  0.25  0.25  0.25  0.25  0.25\n 0.75  0.75  0.75  0.75  0.75  0.75  0.75\n 1.25  1.25  1.25  1.25  1.25  1.25  1.25\n 1.75  1.75  1.75  1.75  1.75  1.75  1.75\n 0.25  0.25  0.25  0.25  0.25  0.25  0.25","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"The way the halo regions are filled depends on c.boundary_conditions:","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"c.boundary_conditions\n\n# output\nOceananigans.FieldBoundaryConditions, with boundary conditions\nâ”œâ”€â”€ west: PeriodicBoundaryCondition\nâ”œâ”€â”€ east: PeriodicBoundaryCondition\nâ”œâ”€â”€ south: PeriodicBoundaryCondition\nâ”œâ”€â”€ north: PeriodicBoundaryCondition\nâ”œâ”€â”€ bottom: FluxBoundaryCondition: Nothing\nâ”œâ”€â”€ top: FluxBoundaryCondition: Nothing\nâ””â”€â”€ immersed: Nothing","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"Specifically for c above, x and y are Periodic while z has been assigned the default \"no-flux\" boundary conditions for a Field with Center location in a Bounded direction. For no-flux boundary conditions, the halo regions of c are filled so that derivatives evaluated on the boundary return 0. To view only the interior cells of c we use the function interior,","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"interior(c, :, :, 1)\n\n# output\n4Ã—5 view(::Array{Float64, 3}, 2:5, 2:6, 2) with eltype Float64:\n 0.25  0.25  0.25  0.25  0.25\n 0.75  0.75  0.75  0.75  0.75\n 1.25  1.25  1.25  1.25  1.25\n 1.75  1.75  1.75  1.75  1.75","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"Note that the indices of c (and the indices of c.data) are \"offset\" so that index 1 corresponds to the first interior cell. As a result,","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"c[1:4, 1:5, 1] == interior(c, :, :, 1)\n\n# output\ntrue","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"and more generally","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"typeof(c.data)\n\n# output\nOffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"Thus, for example, the x-indices of c.data vary from 1 - Hx to Nx + Hx â€“ in this case, from 0 to 5. The underlying array can be accessed with parent(c). But note that the \"parent\" array does not have offset indices, so","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"@show parent(c)[1:2, 2, 2]\n@show c.data[1:2, 1, 1]\nnothing\n\n# output\n(parent(c))[1:2, 2, 2] = [1.75, 0.25]\nc.data[1:2, 1, 1] = [0.25, 0.75]","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/#gpu_example","page":"Ocean wind mixing and convection","title":"Wind- and convection-driven mixing in an ocean surface boundary layer","text":"","category":"section"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"This example simulates mixing by three-dimensional turbulence in an ocean surface boundary layer driven by atmospheric winds and convection. It demonstrates:","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"How to set-up a grid with varying spacing in the vertical direction\nHow to use the SeawaterBuoyancy model for buoyancy with TEOS10EquationOfState.\nHow to use a turbulence closure for large eddy simulation.\nHow to use a function to impose a boundary condition.","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/#Install-dependencies","page":"Ocean wind mixing and convection","title":"Install dependencies","text":"","category":"section"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"using Pkg\npkg\"add Oceananigans, CairoMakie, SeawaterPolynomials, CUDA\"","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We start by importing all of the packages and functions that we'll need for this example.","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"using Oceananigans\nusing Oceananigans.Units\n\nusing CUDA\nusing Random\nusing Printf\nusing CairoMakie\nusing SeawaterPolynomials.TEOS10: TEOS10EquationOfState","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/#The-grid","page":"Ocean wind mixing and convection","title":"The grid","text":"","category":"section"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We use 128Â²Ã—64 grid points with 1 m grid spacing in the horizontal and varying spacing in the vertical, with higher resolution closer to the surface. Here we use a stretching function for the vertical nodes that maintains relatively constant vertical spacing in the mixed layer, which is desirable from a numerical standpoint:","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Nx = Ny = 128    # number of points in each of horizontal directions\nNz = 64          # number of points in the vertical direction\n\nLx = Ly = 128    # (m) domain horizontal extents\nLz = 64          # (m) domain depth\n\nrefinement = 1.2 # controls spacing near surface (higher means finer spaced)\nstretching = 12  # controls rate of stretching at bottom\n\n# Normalized height ranging from 0 to 1\nh(k) = (k - 1) / Nz\n\n# Linear near-surface generator\nÎ¶â‚€(k) = 1 + (h(k) - 1) / refinement\n\n# Bottom-intensified stretching function\nÎ£(k) = (1 - exp(-stretching * h(k))) / (1 - exp(-stretching))\n\n# Generating function\nz_interfaces(k) = Lz * (Î¶â‚€(k) * Î£(k) - 1)\n\ngrid = RectilinearGrid(GPU(),\n                       size = (Nx, Nx, Nz),\n                       x = (0, Lx),\n                       y = (0, Ly),\n                       z = z_interfaces)","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"128Ã—128Ã—64 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CUDAGPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ Periodic x âˆˆ [0.0, 128.0) regularly spaced with Î”x=1.0\nâ”œâ”€â”€ Periodic y âˆˆ [0.0, 128.0) regularly spaced with Î”y=1.0\nâ””â”€â”€ Bounded  z âˆˆ [-64.0, 0.0] variably spaced with min(Î”z)=0.833413, max(Î”z)=1.96618","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We plot vertical spacing versus depth to inspect the prescribed grid stretching:","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"fig = Figure(size=(1200, 800))\nax = Axis(fig[1, 1], ylabel = \"z (m)\", xlabel = \"Vertical spacing (m)\")\n\nlines!(ax, zspacings(grid, Center()))\nscatter!(ax, zspacings(grid, Center()))\n\nfig","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"(Image: )","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/#Buoyancy-that-depends-on-temperature-and-salinity","page":"Ocean wind mixing and convection","title":"Buoyancy that depends on temperature and salinity","text":"","category":"section"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We use the SeawaterBuoyancy model with the TEOS10 equation of state,","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Ïâ‚’ = 1026 # kg mâ»Â³, average density at the surface of the world ocean\nequation_of_state = TEOS10EquationOfState(reference_density=Ïâ‚’)\nbuoyancy = SeawaterBuoyancy(; equation_of_state)","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"SeawaterBuoyancy{Float64}:\nâ”œâ”€â”€ gravitational_acceleration: 9.80665\nâ””â”€â”€ equation_of_state: BoussinesqEquationOfState{Float64}","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/#Boundary-conditions","page":"Ocean wind mixing and convection","title":"Boundary conditions","text":"","category":"section"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We calculate the surface temperature flux associated with surface cooling of 200 W mâ»Â², reference density Ïâ‚’, and heat capacity cá´¾,","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Q = 200   # W mâ»Â², surface _heat_ flux\ncá´¾ = 3991 # J Kâ»Â¹ kgâ»Â¹, typical heat capacity for seawater\n\nJáµ€ = Q / (Ïâ‚’ * cá´¾) # K m sâ»Â¹, surface _temperature_ flux","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"4.884283985946938e-5","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Finally, we impose a temperature gradient dTdz both initially (see \"Initial conditions\" section below) and at the bottom of the domain, culminating in the boundary conditions on temperature,","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"dTdz = 0.01 # K mâ»Â¹\n\nT_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Jáµ€),\n                                bottom = GradientBoundaryCondition(dTdz))","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Oceananigans.FieldBoundaryConditions, with boundary conditions\nâ”œâ”€â”€ west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ bottom: GradientBoundaryCondition: 0.01\nâ”œâ”€â”€ top: FluxBoundaryCondition: 4.88428e-5\nâ””â”€â”€ immersed: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Note that a positive temperature flux at the surface of the ocean implies cooling. This is because a positive temperature flux implies that temperature is fluxed upwards, out of the ocean.","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"For the velocity field, we imagine a wind blowing over the ocean surface with an average velocity at 10 meters uâ‚â‚€, and use a drag coefficient cá´° to estimate the kinematic stress (that is, stress divided by density) exerted by the wind on the ocean:","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"uâ‚â‚€ = 10  # m sâ»Â¹, average wind velocity 10 meters above the ocean\ncá´° = 2e-3 # dimensionless drag coefficient\nÏâ‚ = 1.2  # kg mâ»Â³, approximate average density of air at sea-level\nÏ„x = - Ïâ‚ / Ïâ‚’ * cá´° * uâ‚â‚€ * abs(uâ‚â‚€) # mÂ² sâ»Â²","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"-0.00023391812865497074","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"The boundary conditions on u are thus","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"u_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Ï„x))","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Oceananigans.FieldBoundaryConditions, with boundary conditions\nâ”œâ”€â”€ west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ bottom: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ top: FluxBoundaryCondition: -0.000233918\nâ””â”€â”€ immersed: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"For salinity, S, we impose an evaporative flux of the form","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"@inline JË¢(x, y, t, S, evaporation_rate) = - evaporation_rate * S # [salinity unit] m sâ»Â¹","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"where S is salinity. We use an evaporation rate of 1 millimeter per hour,","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"evaporation_rate = 1e-3 / hour # m sâ»Â¹","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"2.7777777777777776e-7","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We build the Flux evaporation BoundaryCondition with the function JË¢, indicating that JË¢ depends on salinity S and passing the parameter evaporation_rate,","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"evaporation_bc = FluxBoundaryCondition(JË¢, field_dependencies=:S, parameters=evaporation_rate)","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"FluxBoundaryCondition: ContinuousBoundaryFunction JË¢ at (Nothing, Nothing, Nothing)","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"The full salinity boundary conditions are","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"S_bcs = FieldBoundaryConditions(top=evaporation_bc)","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Oceananigans.FieldBoundaryConditions, with boundary conditions\nâ”œâ”€â”€ west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ bottom: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ top: FluxBoundaryCondition: ContinuousBoundaryFunction JË¢ at (Nothing, Nothing, Nothing)\nâ””â”€â”€ immersed: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/#Model-instantiation","page":"Ocean wind mixing and convection","title":"Model instantiation","text":"","category":"section"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We fill in the final details of the model here, i.e., Coriolis forces, and the AnisotropicMinimumDissipation closure for large eddy simulation to model the effect of turbulent motions at scales smaller than the grid scale that are not explicitly resolved.","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"model = NonhydrostaticModel(; grid, buoyancy,\n                            tracers = (:T, :S),\n                            coriolis = FPlane(f=1e-4),\n                            closure = AnisotropicMinimumDissipation(),\n                            boundary_conditions = (u=u_bcs, T=T_bcs, S=S_bcs))","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"NonhydrostaticModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 128Ã—128Ã—64 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CUDAGPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ timestepper: RungeKutta3TimeStepper\nâ”œâ”€â”€ advection scheme: Centered(order=2)\nâ”œâ”€â”€ tracers: (T, S)\nâ”œâ”€â”€ closure: AnisotropicMinimumDissipation{ExplicitTimeDiscretization, @NamedTuple{T::Float64, S::Float64}, Float64, Nothing}\nâ”œâ”€â”€ buoyancy: SeawaterBuoyancy with g=9.80665 and BoussinesqEquationOfState{Float64} with gÌ‚ = NegativeZDirection()\nâ””â”€â”€ coriolis: FPlane{Float64}(f=0.0001)","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Note: To use the Smagorinsky-Lilly turbulence closure (with a constant model coefficient) rather than AnisotropicMinimumDissipation, use closure = SmagorinskyLilly() in the model constructor.","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/#Initial-conditions","page":"Ocean wind mixing and convection","title":"Initial conditions","text":"","category":"section"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Our initial condition for temperature consists of a linear stratification superposed with random noise damped at the walls, while our initial condition for velocity consists only of random noise.","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"# Random noise damped at top and bottom\nÎ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz) # noise\n\n# Temperature initial condition: a stable density gradient with random noise superposed.\nTáµ¢(x, y, z) = 20 + dTdz * z + dTdz * model.grid.Lz * 1e-6 * Î(z)\n\n# Velocity initial condition: random noise scaled by the friction velocity.\nuáµ¢(x, y, z) = sqrt(abs(Ï„x)) * 1e-3 * Î(z)\n\n# `set!` the `model` fields using functions or constants:\nset!(model, u=uáµ¢, w=uáµ¢, T=Táµ¢, S=35)","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/#Setting-up-a-simulation","page":"Ocean wind mixing and convection","title":"Setting up a simulation","text":"","category":"section"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We set-up a simulation with an initial time-step of 10 seconds that stops at 2 hours, with adaptive time-stepping and progress printing.","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"simulation = Simulation(model, Î”t=10, stop_time=2hours)","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Simulation of NonhydrostaticModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ Next time step: 10 seconds\nâ”œâ”€â”€ Elapsed wall time: 0 seconds\nâ”œâ”€â”€ Wall time per iteration: NaN days\nâ”œâ”€â”€ Stop time: 2 hours\nâ”œâ”€â”€ Stop iteration: Inf\nâ”œâ”€â”€ Wall time limit: Inf\nâ”œâ”€â”€ Minimum relative step: 0.0\nâ”œâ”€â”€ Callbacks: OrderedDict with 4 entries:\nâ”‚   â”œâ”€â”€ stop_time_exceeded => 4\nâ”‚   â”œâ”€â”€ stop_iteration_exceeded => -\nâ”‚   â”œâ”€â”€ wall_time_limit_exceeded => e\nâ”‚   â””â”€â”€ nan_checker => }\nâ”œâ”€â”€ Output writers: OrderedDict with no entries\nâ””â”€â”€ Diagnostics: OrderedDict with no entries","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"The TimeStepWizard helps ensure stable time-stepping with a Courant-Freidrichs-Lewy (CFL) number of 1.0.","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"wizard = TimeStepWizard(cfl=1, max_change=1.1, max_Î”t=1minute)\nsimulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10))","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Callback of TimeStepWizard(cfl=1.0, max_Î”t=60.0, min_Î”t=0.0) on IterationInterval(10)","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Nice progress messaging is helpful:","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"# Print a progress message\nprogress_message(sim) = @printf(\"Iteration: %04d, time: %s, Î”t: %s, max(|w|) = %.1e msâ»Â¹, wall time: %s\\n\",\n                                iteration(sim), prettytime(sim), prettytime(sim.Î”t),\n                                maximum(abs, sim.model.velocities.w), prettytime(sim.run_wall_time))\n\nadd_callback!(simulation, progress_message, IterationInterval(40))","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We then set up the simulation:","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/#Output","page":"Ocean wind mixing and convection","title":"Output","text":"","category":"section"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We use the JLD2Writer to save x z slices of the velocity fields, tracer fields, and eddy diffusivities. The prefix keyword argument to JLD2Writer indicates that output will be saved in ocean_wind_mixing_and_convection.jld2.","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"# Create a NamedTuple with eddy viscosity\neddy_viscosity = (; Î½â‚‘ = model.diffusivity_fields.Î½â‚‘)\n\nfilename = \"ocean_wind_mixing_and_convection\"\n\nsimulation.output_writers[:slices] =\n    JLD2Writer(model, merge(model.velocities, model.tracers, eddy_viscosity),\n               filename = filename * \".jld2\",\n               indices = (:, grid.Ny/2, :),\n               schedule = TimeInterval(1minute),\n               overwrite_existing = true)","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"JLD2Writer scheduled on TimeInterval(1 minute):\nâ”œâ”€â”€ filepath: ocean_wind_mixing_and_convection.jld2\nâ”œâ”€â”€ 6 outputs: (u, v, w, T, S, Î½â‚‘)\nâ”œâ”€â”€ array_type: Array{Float32}\nâ”œâ”€â”€ including: [:grid, :coriolis, :buoyancy, :closure]\nâ”œâ”€â”€ file_splitting: NoFileSplitting\nâ””â”€â”€ file size: 63.7 KiB","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We're ready:","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"run!(simulation)","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"[ Info: Initializing simulation...\nIteration: 0000, time: 0 seconds, Î”t: 11 seconds, max(|w|) = 1.2e-05 msâ»Â¹, wall time: 0 seconds\n[ Info:     ... simulation initialization complete (13.190 seconds)\n[ Info: Executing initial time step...\n[ Info:     ... initial time step complete (4.896 seconds).\nIteration: 0040, time: 7 minutes, Î”t: 8.310 seconds, max(|w|) = 2.8e-05 msâ»Â¹, wall time: 18.742 seconds\nIteration: 0080, time: 11.183 minutes, Î”t: 4.840 seconds, max(|w|) = 7.4e-03 msâ»Â¹, wall time: 19.223 seconds\nIteration: 0120, time: 14 minutes, Î”t: 4.082 seconds, max(|w|) = 2.4e-02 msâ»Â¹, wall time: 19.642 seconds\nIteration: 0160, time: 16.672 minutes, Î”t: 4.148 seconds, max(|w|) = 3.3e-02 msâ»Â¹, wall time: 20.079 seconds\nIteration: 0200, time: 19.349 minutes, Î”t: 3.989 seconds, max(|w|) = 3.4e-02 msâ»Â¹, wall time: 20.517 seconds\nIteration: 0240, time: 21.890 minutes, Î”t: 3.850 seconds, max(|w|) = 2.4e-02 msâ»Â¹, wall time: 20.927 seconds\nIteration: 0280, time: 24.322 minutes, Î”t: 3.753 seconds, max(|w|) = 3.1e-02 msâ»Â¹, wall time: 21.389 seconds\nIteration: 0320, time: 26.688 minutes, Î”t: 3.195 seconds, max(|w|) = 3.0e-02 msâ»Â¹, wall time: 21.807 seconds\nIteration: 0360, time: 28.942 minutes, Î”t: 3.358 seconds, max(|w|) = 2.6e-02 msâ»Â¹, wall time: 22.243 seconds\nIteration: 0400, time: 31.111 minutes, Î”t: 3.300 seconds, max(|w|) = 2.8e-02 msâ»Â¹, wall time: 22.700 seconds\nIteration: 0440, time: 33.219 minutes, Î”t: 3.326 seconds, max(|w|) = 4.1e-02 msâ»Â¹, wall time: 23.157 seconds\nIteration: 0480, time: 35.267 minutes, Î”t: 3.213 seconds, max(|w|) = 5.0e-02 msâ»Â¹, wall time: 23.652 seconds\nIteration: 0520, time: 37.372 minutes, Î”t: 3.310 seconds, max(|w|) = 3.4e-02 msâ»Â¹, wall time: 24.099 seconds\nIteration: 0560, time: 39.481 minutes, Î”t: 3.213 seconds, max(|w|) = 3.3e-02 msâ»Â¹, wall time: 24.543 seconds\nIteration: 0600, time: 41.579 minutes, Î”t: 3.121 seconds, max(|w|) = 4.4e-02 msâ»Â¹, wall time: 24.963 seconds\nIteration: 0640, time: 43.550 minutes, Î”t: 3.043 seconds, max(|w|) = 3.5e-02 msâ»Â¹, wall time: 25.451 seconds\nIteration: 0680, time: 45.491 minutes, Î”t: 3.012 seconds, max(|w|) = 4.7e-02 msâ»Â¹, wall time: 25.886 seconds\nIteration: 0720, time: 47.390 minutes, Î”t: 2.896 seconds, max(|w|) = 4.7e-02 msâ»Â¹, wall time: 26.346 seconds\nIteration: 0760, time: 49.291 minutes, Î”t: 2.821 seconds, max(|w|) = 4.6e-02 msâ»Â¹, wall time: 26.770 seconds\nIteration: 0800, time: 51.143 minutes, Î”t: 2.861 seconds, max(|w|) = 4.8e-02 msâ»Â¹, wall time: 27.212 seconds\nIteration: 0840, time: 53 minutes, Î”t: 2.724 seconds, max(|w|) = 4.6e-02 msâ»Â¹, wall time: 27.657 seconds\nIteration: 0880, time: 54.833 minutes, Î”t: 2.727 seconds, max(|w|) = 4.2e-02 msâ»Â¹, wall time: 28.131 seconds\nIteration: 0920, time: 56.645 minutes, Î”t: 2.633 seconds, max(|w|) = 4.4e-02 msâ»Â¹, wall time: 28.644 seconds\nIteration: 0960, time: 58.366 minutes, Î”t: 2.801 seconds, max(|w|) = 4.8e-02 msâ»Â¹, wall time: 29.126 seconds\nIteration: 1000, time: 1.003 hours, Î”t: 2.746 seconds, max(|w|) = 5.0e-02 msâ»Â¹, wall time: 29.628 seconds\nIteration: 1040, time: 1.033 hours, Î”t: 2.730 seconds, max(|w|) = 4.3e-02 msâ»Â¹, wall time: 30.096 seconds\nIteration: 1080, time: 1.062 hours, Î”t: 2.588 seconds, max(|w|) = 4.7e-02 msâ»Â¹, wall time: 30.603 seconds\nIteration: 1120, time: 1.090 hours, Î”t: 2.573 seconds, max(|w|) = 4.5e-02 msâ»Â¹, wall time: 31.112 seconds\nIteration: 1160, time: 1.117 hours, Î”t: 2.500 seconds, max(|w|) = 4.5e-02 msâ»Â¹, wall time: 31.641 seconds\nIteration: 1200, time: 1.145 hours, Î”t: 2.383 seconds, max(|w|) = 5.1e-02 msâ»Â¹, wall time: 32.138 seconds\nIteration: 1240, time: 1.171 hours, Î”t: 2.533 seconds, max(|w|) = 5.9e-02 msâ»Â¹, wall time: 32.656 seconds\nIteration: 1280, time: 1.200 hours, Î”t: 2.609 seconds, max(|w|) = 6.3e-02 msâ»Â¹, wall time: 33.173 seconds\nIteration: 1320, time: 1.227 hours, Î”t: 2.538 seconds, max(|w|) = 5.7e-02 msâ»Â¹, wall time: 33.661 seconds\nIteration: 1360, time: 1.256 hours, Î”t: 2.663 seconds, max(|w|) = 5.0e-02 msâ»Â¹, wall time: 34.158 seconds\nIteration: 1400, time: 1.285 hours, Î”t: 2.639 seconds, max(|w|) = 5.8e-02 msâ»Â¹, wall time: 34.632 seconds\nIteration: 1440, time: 1.314 hours, Î”t: 2.651 seconds, max(|w|) = 6.6e-02 msâ»Â¹, wall time: 35.125 seconds\nIteration: 1480, time: 1.343 hours, Î”t: 2.649 seconds, max(|w|) = 6.7e-02 msâ»Â¹, wall time: 35.610 seconds\nIteration: 1520, time: 1.372 hours, Î”t: 2.518 seconds, max(|w|) = 5.7e-02 msâ»Â¹, wall time: 36.136 seconds\nIteration: 1560, time: 1.400 hours, Î”t: 2.482 seconds, max(|w|) = 5.9e-02 msâ»Â¹, wall time: 36.644 seconds\nIteration: 1600, time: 1.426 hours, Î”t: 2.513 seconds, max(|w|) = 5.9e-02 msâ»Â¹, wall time: 37.109 seconds\nIteration: 1640, time: 1.454 hours, Î”t: 2.473 seconds, max(|w|) = 6.7e-02 msâ»Â¹, wall time: 37.644 seconds\nIteration: 1680, time: 1.482 hours, Î”t: 2.577 seconds, max(|w|) = 6.7e-02 msâ»Â¹, wall time: 38.117 seconds\nIteration: 1720, time: 1.510 hours, Î”t: 2.563 seconds, max(|w|) = 6.9e-02 msâ»Â¹, wall time: 38.660 seconds\nIteration: 1760, time: 1.538 hours, Î”t: 2.526 seconds, max(|w|) = 6.5e-02 msâ»Â¹, wall time: 39.196 seconds\nIteration: 1800, time: 1.565 hours, Î”t: 2.551 seconds, max(|w|) = 5.9e-02 msâ»Â¹, wall time: 39.719 seconds\nIteration: 1840, time: 1.593 hours, Î”t: 2.596 seconds, max(|w|) = 5.3e-02 msâ»Â¹, wall time: 40.199 seconds\nIteration: 1880, time: 1.621 hours, Î”t: 2.470 seconds, max(|w|) = 5.8e-02 msâ»Â¹, wall time: 40.699 seconds\nIteration: 1920, time: 1.648 hours, Î”t: 2.382 seconds, max(|w|) = 5.6e-02 msâ»Â¹, wall time: 41.254 seconds\nIteration: 1960, time: 1.674 hours, Î”t: 2.369 seconds, max(|w|) = 5.2e-02 msâ»Â¹, wall time: 41.762 seconds\nIteration: 2000, time: 1.700 hours, Î”t: 2.371 seconds, max(|w|) = 5.5e-02 msâ»Â¹, wall time: 42.288 seconds\nIteration: 2040, time: 1.726 hours, Î”t: 2.457 seconds, max(|w|) = 6.0e-02 msâ»Â¹, wall time: 42.776 seconds\nIteration: 2080, time: 1.753 hours, Î”t: 2.459 seconds, max(|w|) = 5.4e-02 msâ»Â¹, wall time: 43.299 seconds\nIteration: 2120, time: 1.780 hours, Î”t: 2.442 seconds, max(|w|) = 5.9e-02 msâ»Â¹, wall time: 43.770 seconds\nIteration: 2160, time: 1.806 hours, Î”t: 2.440 seconds, max(|w|) = 5.9e-02 msâ»Â¹, wall time: 44.279 seconds\nIteration: 2200, time: 1.833 hours, Î”t: 2.416 seconds, max(|w|) = 5.3e-02 msâ»Â¹, wall time: 44.770 seconds\nIteration: 2240, time: 1.860 hours, Î”t: 2.428 seconds, max(|w|) = 6.6e-02 msâ»Â¹, wall time: 45.276 seconds\nIteration: 2280, time: 1.885 hours, Î”t: 2.311 seconds, max(|w|) = 6.4e-02 msâ»Â¹, wall time: 45.819 seconds\nIteration: 2320, time: 1.910 hours, Î”t: 2.417 seconds, max(|w|) = 5.9e-02 msâ»Â¹, wall time: 46.260 seconds\nIteration: 2360, time: 1.936 hours, Î”t: 2.353 seconds, max(|w|) = 5.7e-02 msâ»Â¹, wall time: 46.791 seconds\nIteration: 2400, time: 1.962 hours, Î”t: 2.356 seconds, max(|w|) = 6.1e-02 msâ»Â¹, wall time: 47.251 seconds\nIteration: 2440, time: 1.987 hours, Î”t: 2.399 seconds, max(|w|) = 5.5e-02 msâ»Â¹, wall time: 47.782 seconds\n[ Info: Simulation is stopping after running for 48.010 seconds.\n[ Info: Simulation time 2 hours equals or exceeds stop time 2 hours.\n","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/#Turbulence-visualization","page":"Ocean wind mixing and convection","title":"Turbulence visualization","text":"","category":"section"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We animate the data saved in ocean_wind_mixing_and_convection.jld2. We prepare for animating the flow by loading the data into FieldTimeSeries and defining functions for computing colorbar limits.","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"filepath = filename * \".jld2\"\n\ntime_series = (w = FieldTimeSeries(filepath, \"w\"),\n               T = FieldTimeSeries(filepath, \"T\"),\n               S = FieldTimeSeries(filepath, \"S\"),\n               Î½â‚‘ = FieldTimeSeries(filepath, \"Î½â‚‘\"))","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"(w = 128Ã—1Ã—65Ã—121 FieldTimeSeries{InMemory} located at (Center, Center, Face) of w at ocean_wind_mixing_and_convection.jld2\nâ”œâ”€â”€ grid: 128Ã—128Ã—64 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ indices: (:, 64:64, :)\nâ”œâ”€â”€ time_indexing: Linear()\nâ”œâ”€â”€ backend: InMemory()\nâ”œâ”€â”€ path: ocean_wind_mixing_and_convection.jld2\nâ”œâ”€â”€ name: w\nâ””â”€â”€ data: 134Ã—1Ã—71Ã—121 OffsetArray(::Array{Float64, 4}, -2:131, 64:64, -2:68, 1:121) with eltype Float64 with indices -2:131Ã—64:64Ã—-2:68Ã—1:121\n    â””â”€â”€ max=0.0569034, min=-0.0584658, mean=-2.53428e-5, T = 128Ã—1Ã—64Ã—121 FieldTimeSeries{InMemory} located at (Center, Center, Center) of T at ocean_wind_mixing_and_convection.jld2\nâ”œâ”€â”€ grid: 128Ã—128Ã—64 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ indices: (:, 64:64, :)\nâ”œâ”€â”€ time_indexing: Linear()\nâ”œâ”€â”€ backend: InMemory()\nâ”œâ”€â”€ path: ocean_wind_mixing_and_convection.jld2\nâ”œâ”€â”€ name: T\nâ””â”€â”€ data: 134Ã—1Ã—70Ã—121 OffsetArray(::Array{Float64, 4}, -2:131, 64:64, -2:67, 1:121) with eltype Float64 with indices -2:131Ã—64:64Ã—-2:67Ã—1:121\n    â””â”€â”€ max=19.9958, min=0.0, mean=18.5886, S = 128Ã—1Ã—64Ã—121 FieldTimeSeries{InMemory} located at (Center, Center, Center) of S at ocean_wind_mixing_and_convection.jld2\nâ”œâ”€â”€ grid: 128Ã—128Ã—64 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ indices: (:, 64:64, :)\nâ”œâ”€â”€ time_indexing: Linear()\nâ”œâ”€â”€ backend: InMemory()\nâ”œâ”€â”€ path: ocean_wind_mixing_and_convection.jld2\nâ”œâ”€â”€ name: S\nâ””â”€â”€ data: 134Ã—1Ã—70Ã—121 OffsetArray(::Array{Float64, 4}, -2:131, 64:64, -2:67, 1:121) with eltype Float64 with indices -2:131Ã—64:64Ã—-2:67Ã—1:121\n    â””â”€â”€ max=35.0135, min=0.0, mean=33.0007, Î½â‚‘ = 128Ã—1Ã—64Ã—121 FieldTimeSeries{InMemory} located at (Center, Center, Center) of Î½â‚‘ at ocean_wind_mixing_and_convection.jld2\nâ”œâ”€â”€ grid: 128Ã—128Ã—64 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ indices: (:, 64:64, :)\nâ”œâ”€â”€ time_indexing: Linear()\nâ”œâ”€â”€ backend: InMemory()\nâ”œâ”€â”€ path: ocean_wind_mixing_and_convection.jld2\nâ”œâ”€â”€ name: Î½â‚‘\nâ””â”€â”€ data: 134Ã—1Ã—70Ã—121 OffsetArray(::Array{Float64, 4}, -2:131, 64:64, -2:67, 1:121) with eltype Float64 with indices -2:131Ã—64:64Ã—-2:67Ã—1:121\n    â””â”€â”€ max=0.0189381, min=0.0, mean=0.000438569)","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We start the animation at t = 10 minutes since things are pretty boring till then:","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"times = time_series.w.times\nintro = searchsortedfirst(times, 10minutes)","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"11","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We are now ready to animate using Makie. We use Makie's Observable to animate the data. To dive into how Observables work we refer to Makie.jl's Documentation.","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"n = Observable(intro)\n\n wâ‚™ = @lift time_series.w[$n]\n Tâ‚™ = @lift time_series.T[$n]\n Sâ‚™ = @lift time_series.S[$n]\nÎ½â‚‘â‚™ = @lift time_series.Î½â‚‘[$n]\n\nfig = Figure(size = (1800, 900))\n\naxis_kwargs = (xlabel=\"x (m)\",\n               ylabel=\"z (m)\",\n               aspect = AxisAspect(grid.Lx/grid.Lz),\n               limits = ((0, grid.Lx), (-grid.Lz, 0)))\n\nax_w  = Axis(fig[2, 1]; title = \"Vertical velocity\", axis_kwargs...)\nax_T  = Axis(fig[2, 3]; title = \"Temperature\", axis_kwargs...)\nax_S  = Axis(fig[3, 1]; title = \"Salinity\", axis_kwargs...)\nax_Î½â‚‘ = Axis(fig[3, 3]; title = \"Eddy viscocity\", axis_kwargs...)\n\ntitle = @lift @sprintf(\"t = %s\", prettytime(times[$n]))\n\n wlims = (-0.05, 0.05)\n Tlims = (19.7, 19.99)\n Slims = (35, 35.005)\nÎ½â‚‘lims = (1e-6, 5e-3)\n\nhm_w = heatmap!(ax_w, wâ‚™; colormap = :balance, colorrange = wlims)\nColorbar(fig[2, 2], hm_w; label = \"m sâ»Â¹\")\n\nhm_T = heatmap!(ax_T, Tâ‚™; colormap = :thermal, colorrange = Tlims)\nColorbar(fig[2, 4], hm_T; label = \"áµ’C\")\n\nhm_S = heatmap!(ax_S, Sâ‚™; colormap = :haline, colorrange = Slims)\nColorbar(fig[3, 2], hm_S; label = \"g / kg\")\n\nhm_Î½â‚‘ = heatmap!(ax_Î½â‚‘, Î½â‚‘â‚™; colormap = :thermal, colorrange = Î½â‚‘lims)\nColorbar(fig[3, 4], hm_Î½â‚‘; label = \"m sâ»Â²\")\n\nfig[1, 1:4] = Label(fig, title, fontsize=24, tellwidth=false)\n\nfig","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"(Image: )","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"And now record a movie.","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"frames = intro:length(times)\n\n@info \"Making a motion picture of ocean wind mixing and convection...\"\n\nCairoMakie.record(fig, filename * \".mp4\", frames, framerate=8) do i\n    n[] = i\nend","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"[ Info: Making a motion picture of ocean wind mixing and convection...\n","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"(Image: )","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"This page was generated using Literate.jl.","category":"page"},{"location":"simulation_tips/#simulation_tips","page":"Simulation tips","title":"Simulation tips","text":"","category":"section"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Oceananigans attempts to optimize computations as much as possible \"behind the scenes\". Yet Oceananigans' flexibility places some responsibility on users to ensure high performance simulations, especially for complex setups with user-defined forcing functions, boundary condition functions, and diagnostics. Furthermore, in case of more complex GPU runs, some details could sometimes prevent your simulation from running altogether. While Julia knowledge is obviously desirable here, a user that is unfamiliar with Julia can get away with efficient simulations by learning a few rules of thumb. It is nonetheless recommended that users go through Julia's performance tips, which contains more in-depth explanations of some of the aspects discussed here.","category":"page"},{"location":"simulation_tips/#General-(CPU/GPU)-simulation-tips","page":"Simulation tips","title":"General (CPU/GPU) simulation tips","text":"","category":"section"},{"location":"simulation_tips/#Avoid-global-variables-whenever-possible","page":"Simulation tips","title":"Avoid global variables whenever possible","text":"","category":"section"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"In general using a global variable (which can be loosely defined as a variable defined in the main script) inside functions slows down the code. One way to circumvent this is to always use local variables or pass them as arguments to functions. This helps the compiler optimize the code.","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Another way around this is to define global variables as constants whenever possible. One thing to keep in mind when doing this is that when a const is defined, its value can't be changed until you restart the Julia session. So this latter approach is good for production-ready code, but may be undesirable in the early stages of development while you still have to change the parameters of the simulation for exploration.","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"It is especially important to avoid global variables in functions that are meant to be executed in GPU kernels (such as functions defining boundary conditions and forcings). Otherwise the Julia GPU compiler can fail with obscure errors. This is explained in more detail in the GPU simulation tips section below.","category":"page"},{"location":"simulation_tips/#Consider-inlining-small-functions","page":"Simulation tips","title":"Consider inlining small functions","text":"","category":"section"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Inlining is when the compiler replaces a function call with the body of the function that is being called before compiling. The advantage of inlining (which in julia can be done with the @inline macro) is that gets rid of the time spent calling the function. The Julia compiler automatically makes some calls as to what functions it should or shouldn't inline, but you can force a function to be inlined by including the macro @inline before its definition. This is more suited for small functions that are called often. Here's an example of an implementation of the Heaviside function that forces it to be inlined:","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"@inline heaviside(x) = ifelse(x < 0, zero(x), one(x))","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"In practice it's hard to say whether inlining a function will bring runtime benefits with certainty, since Julia and KernelAbstractions.jl (needed for GPU runs) already inline some functions automatically. However, it is generally a good idea to at least investigate this aspect in your code as the benefits can potentially be significant.","category":"page"},{"location":"simulation_tips/#GPU-simulation-tips","page":"Simulation tips","title":"GPU simulation tips","text":"","category":"section"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Running on GPUs can be very different from running on CPUs. Oceananigans makes most of the necessary changes in the background, so that for very simple simulations changing between CPUs and GPUs is just a matter of changing the architecture argument in the grid constructor from CPU() to GPU(). However, for more complex simulations some care needs to be taken on the part of the user. While knowledge of GPU computing (and Julia) is again desirable, an inexperienced user can also achieve high efficiency in GPU simulations by following a few simple principles.","category":"page"},{"location":"simulation_tips/#Global-variables-that-need-to-be-used-in-GPU-computations-need-to-be-defined-as-constants-or-passed-as-parameters","page":"Simulation tips","title":"Global variables that need to be used in GPU computations need to be defined as constants or passed as parameters","text":"","category":"section"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Any global variable that needs to be accessed by the GPU needs to be a constant or the simulation will crash. This includes any variables that are referenced as global variables in functions used for forcing of boundary conditions. For example,","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Tâ‚€ = 20 # áµ’C\nsurface_temperature(x, y, t) = Tâ‚€ * sin(2Ï€ / 86400 * t)\nT_bcs = FieldBoundaryConditions(bottom = GradientBoundaryCondition(surface_temperature))","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"will throw an error if run on the GPU (and will run more slowly than it should on the CPU). Replacing the first line above with","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"const Tâ‚€ = 20 # áµ’C","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"fixes the issue by indicating to the compiler that Tâ‚€ will not change.","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Note that the literal 2Ï€ / 86400 is not an issue â€“ it's only the variable Tâ‚€ that must be declared const.","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Alternatively, we can pass the variable as a parameter to GradientBoundaryCondition. To do that we need to pass a named tuple as parameter keyword argument:","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Tâ‚€ = 20 # áµ’C\nsurface_temperature(x, y, t, p) = p.Tâ‚€ * sin(2Ï€ / 86400 * t)\nT_bcs = FieldBoundaryConditions(bottom = GradientBoundaryCondition(surface_temperature, parameters=(; Tâ‚€)))","category":"page"},{"location":"simulation_tips/#Complex-diagnostics-using-computed-Fields-may-not-work-on-GPUs","page":"Simulation tips","title":"Complex diagnostics using computed Fields may not work on GPUs","text":"","category":"section"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Fields are the most convenient way to calculate diagnostics for your simulation. They will always work on CPUs, but when their complexity is high (in terms of number of abstract operations) the compiler can't translate them into GPU code and they fail for GPU runs. (This limitation is summarized in this Github issue and contributions are welcome.) For example, in the example below, calculating uÂ² works in both CPUs and GPUs, but calculating Îµ will not compile on GPUs when we call compute!:","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"using Oceananigans\n\ngrid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1))\nmodel = NonhydrostaticModel(; grid, closure=ScalarDiffusivity(Î½=1e-6))\n\nu, v, w = model.velocities\nÎ½ = model.closure.Î½\n\nuÂ² = Field(u^2)\nÎµ = Field(Î½*(âˆ‚x(u)^2 + âˆ‚x(v)^2 + âˆ‚x(w)^2 + âˆ‚y(u)^2 + âˆ‚y(v)^2 + âˆ‚y(w)^2 + âˆ‚z(u)^2 + âˆ‚z(v)^2 + âˆ‚z(w)^2))\n\ncompute!(uÂ²)\ncompute!(Îµ)","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"There are a few ways to work around this issue. One is to compute Îµ in steps by nesting computed Fields,","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"ddxÂ² = Field(âˆ‚x(u)^2 + âˆ‚x(v)^2 + âˆ‚x(w)^2)\nddyÂ² = Field(âˆ‚y(u)^2 + âˆ‚y(v)^2 + âˆ‚y(w)^2)\nddzÂ² = Field(âˆ‚z(u)^2 + âˆ‚z(v)^2 + âˆ‚z(w)^2)\nÎµ = Field(Î½ * (ddxÂ² + ddyÂ² + ddzÂ²))\ncompute!(Îµ)","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"This method increases the computational cost since it requires computing and storing 3 intermediate terms. Îµ may also be calculated via KernelFunctionOperationss, which requires explicitly building a \"kernel function\" from low-level Oceananigans operators.","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"using Oceananigans.Operators\nusing Oceananigans.AbstractOperations: KernelFunctionOperation\n\n@inline fÏˆ_plus_gÏ†Â²(i, j, k, grid, f, Ïˆ, g, Ï†) = (f(i, j, k, grid, Ïˆ) + g(i, j, k, grid, Ï†))^2\n\nfunction isotropic_viscous_dissipation_rate_ccc(i, j, k, grid, u, v, w, Î½)\n    Î£Ë£Ë£Â² = âˆ‚xá¶œá¶œá¶œ(i, j, k, grid, u)^2\n    Î£Ê¸Ê¸Â² = âˆ‚yá¶œá¶œá¶œ(i, j, k, grid, v)^2\n    Î£á¶»á¶»Â² = âˆ‚zá¶œá¶œá¶œ(i, j, k, grid, w)^2\n\n    Î£Ë£Ê¸Â² = â„‘xyá¶œá¶œáµƒ(i, j, k, grid, fÏˆ_plus_gÏ†Â², âˆ‚yá¶ á¶ á¶œ, u, âˆ‚xá¶ á¶ á¶œ, v) / 4\n    Î£Ë£á¶»Â² = â„‘xzá¶œáµƒá¶œ(i, j, k, grid, fÏˆ_plus_gÏ†Â², âˆ‚zá¶ á¶œá¶ , u, âˆ‚xá¶ á¶œá¶ , w) / 4\n    Î£Ê¸á¶»Â² = â„‘yzáµƒá¶œá¶œ(i, j, k, grid, fÏˆ_plus_gÏ†Â², âˆ‚zá¶œá¶ á¶ , v, âˆ‚yá¶œá¶ á¶ , w) / 4\n\n    return 2Î½ * (Î£Ë£Ë£Â² + Î£Ê¸Ê¸Â² + Î£á¶»á¶»Â² + 2 * (Î£Ë£Ê¸Â² + Î£Ë£á¶»Â² + Î£Ê¸á¶»Â²))\nend\n\nÎµ_op = KernelFunctionOperation{Center, Center, Center}(isotropic_viscous_dissipation_rate_ccc,\n                                                       grid, u, v, w, Î½)\n\nÎµ = Field(Îµ_op)\n\ncompute!(Îµ)","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Writing kernel functions like isotropic_viscous_dissipation_rate_ccc requires understanding the C-grid, but incurs only one iteration over the domain.","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"KernelFunctionOperations for some diagnostics common to large eddy simulation are defined in Oceanostics.jl,","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"using Oceanostics: IsotropicPseudoViscousDissipationRate\n\nÎµ = IsotropicViscousDissipationRate(model, u, v, w, Î½)\ncompute!(Îµ)","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Start an issue on Github if more help is needed.","category":"page"},{"location":"simulation_tips/#Try-to-decrease-the-memory-use-of-your-runs","page":"Simulation tips","title":"Try to decrease the memory-use of your runs","text":"","category":"section"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"GPU runs are sometimes memory-limited. For example, an Nvidia Tesla V100 GPU has 32GB of memory â€“ enough memory for simulations with about 100 million points, or grids a bit smaller than 512 Ã— 512 Ã— 512. (The maximum grid size depends on some user-specified factors, like the number of passive tracers or computed diagnostics.) For large simulations on the GPU, careful management of memory allocation may be required:","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Use the nvidia-smi command line utility to monitor the memory usage of the GPU. It should tell you how much memory there is on your GPU and how much of it you're using and you can run it from Julia via\njulia> ;\nshell> run(`nvidia-smi`)\nTry to use higher-order advection schemes. In general when you use a higher-order scheme you need fewer grid points to achieve the same accuracy that you would with a lower-order one. Refer to the documentation for available advection schemes.\nManually define scratch space to be reused in diagnostics. By default, every time a user-defined diagnostic is calculated the compiler reserves a new chunk of memory for that calculation, usually called scratch space. In general, the more diagnostics, the more scratch space needed and the bigger the memory requirements. However, if you explicitly create a scratch space and pass that same scratch space for as many diagnostics as you can, you minimize the memory requirements of your calculations by reusing the same chunk of memory. Have a look at an example for how to create scratch space and how it can be used in calculations.","category":"page"},{"location":"simulation_tips/#Arrays-in-GPUs-are-usually-different-from-arrays-in-CPUs","page":"Simulation tips","title":"Arrays in GPUs are usually different from arrays in CPUs","text":"","category":"section"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Oceananigans enables GPU functionality when loaded with packages like CUDA.jl (most tested and supported), AMDGPU.jl, or Metal.jl","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"We focus here on CUDA-enabled GPUs; but the discussion applies to any GPU architecture.","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"The data for GPU computations are stored in GPUArrays, which for CUDA-enabled devices are called CUDA.CuArray. One limitation of GPUArrays compared to the Arrays used for CPU computations is that GPUArray elements in general cannot be accessed outside kernels launched through, e.g., CUDA.jl or KernelAbstractions.jl. (You can learn more about GPU kernels here and here.) Doing so requires individual elements to be copied from or to the GPU for processing, which is very slow and can result in huge slowdowns. To avoid such unintentional slowdowns, Oceananigans disables scalar indexing by default. See the scalar indexing section of the CUDA.jl documentation for more information on scalar indexing.","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"For example, if can be difficult to just view a CuArray since Julia needs to access its elements to do that. Consider the example below:","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"using Oceananigans, CUDA\n\ngrid = RectilinearGrid(GPU(); size=(1, 1, 1), extent=(1, 1, 1), halo=(1, 1, 1))\nmodel = NonhydrostaticModel(; grid)\ntypeof(model.velocities.u.data)","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"If we try to view the CuArray that stores values for u we hit a wall:","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"julia> model.velocities.u.data\n3Ã—3Ã—3 OffsetArray(::CuArray{Float64, 3, CUDA.DeviceMemory}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2Ã—0:2Ã—0:2:\n[:, :, 0] =\nError showing value of type OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.DeviceMemory}}:\nERROR: Scalar indexing is disallowed.\nInvocation of getindex resulted in scalar indexing of a GPU array.\nThis is typically caused by calling an iterating implementation of a method.\nSuch implementations *do not* execute on the GPU, but very slowly on the CPU,\nand therefore should be avoided.\n\nIf you want to allow scalar iteration, use `allowscalar` or `@allowscalar`\nto enable scalar iteration globally or for the operations in question.","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"To view the CuArray we first need to transform it into a regular Array using Adapt.adapt.","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"using Adapt\n\nadapt(Array, model.velocities.u.data)","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Above, when we tried naÃ¯vely to view the CuArray, CUDA.jl threw an error because scalar getindex is not allowed. There are ways to overcome this limitation and allow scalar indexing (more about that in the CUDA.jl documentation), but this option can be very slow on GPUs, so it is advised to only use this last method when using the REPL or prototyping â€“ never in production-ready scripts.","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"You might also need to keep these differences in mind when using arrays to define initial conditions, boundary conditions or forcing functions on a GPU. To learn more about working with CuArrays, see the array programming section of the CUDA.jl documentation.","category":"page"},{"location":"physics/surface_gravity_waves/#Surface-gravity-waves-and-the-Craik-Leibovich-approximation","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"","category":"section"},{"location":"physics/surface_gravity_waves/","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"Users can model the effects of surface waves by specifying spatial and temporal gradients of the Stokes drift velocity field. At the moment, only uniform unidirectional Stokes drift fields are supported, in which case","category":"page"},{"location":"physics/surface_gravity_waves/","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"    boldsymbolu^S = u^S(z t) hatboldsymbolx + v^S(z t) hatboldsymboly  ","category":"page"},{"location":"physics/surface_gravity_waves/","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"Surface waves are modeled in the NonhydrostaticModel by the Craik-Leibovich approximation, which governs interior motions under a surface gravity wave field that have been time- or phase-averaged over the rapid oscillations of the surface waves. The oscillatory vertical and horizontal motions associated with surface waves themselves, therefore, are not present in the resolved velocity field boldsymbolv, and only the steady, averaged effect of surface waves that manifests over several or more wave oscillations are modeled.","category":"page"},{"location":"physics/surface_gravity_waves/","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"When surface waves are included, the resolved velocity field boldsymbolv is the Lagrangian-mean velocity field. The Lagrangian-mean velocity field at a particular location (x y z) is average velocity of a fluid particle whose average position is (x y z) at time t. The average position of a fluid particle boldsymbolxi(t) = (xi eta zeta) is thus governed by","category":"page"},{"location":"physics/surface_gravity_waves/","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"    partial_t boldsymbolxi + boldsymbolv(boldsymbolxi t) boldsymbolcdot boldsymbolnabla boldsymbolxi = boldsymbolv(boldsymbolxi t)  ","category":"page"},{"location":"physics/surface_gravity_waves/","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"which is the same relationship that holds when surface waves are not present and boldsymbolv ceases to be an averaged velocity field. The simplicity of the governing equations for Lagrangian-mean momentum is the main reason we use a Lagrangian-mean formulation in Oceananigans.jl, rather than an Eulerian-mean formulation: for example, the tracer conservation equation is unchanged by the inclusion of surface wave effects. Moreover, because the effect of surface waves manifests either as a bulk forcing of Lagrangian-mean momentum or as a modification to the effective background rotation rate of the interior fluid similar to any bulk forcing or Coriolis force, we do not explicitly include the effects of surface waves in turbulence closures that model the effects of subgrid turbulence. More specifically, the effect of steady surface waves does not effect the conservation of Lagrangian-mean turbulent kinetic energy.","category":"page"},{"location":"physics/surface_gravity_waves/","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"The Lagrangian-mean velocity field boldsymbolv contrasts with the Eulerian-mean velocity field boldsymbolv^E, which is the fluid velocity averaged at the fixed Eulerian position (x y z). The surface wave Stokes drift field supplied by the user is, in fact, defined by the difference between the Eulerian- and Lagrangian-mean velocity:","category":"page"},{"location":"physics/surface_gravity_waves/","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"    boldsymbolu^S equiv boldsymbolv - boldsymbolv^E  ","category":"page"},{"location":"physics/surface_gravity_waves/","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"The Stokes drift velocity field is typically prescribed for idealized scenarios, or determined from a wave model for the evolution of surface waves under time-dependent atmospheric winds in more realistic cases.","category":"page"},{"location":"#Oceananigans.jl","page":"Home","title":"Oceananigans.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ğŸŒŠ Fast and friendly fluid dynamics on CPUs and GPUs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Oceananigans is a fast, friendly, flexible software package for finite volume simulations of the nonhydrostatic and hydrostatic Boussinesq equations on CPUs and GPUs. It runs on GPUs (wow, fast!), though we believe Oceananigans makes the biggest waves with its ultra-flexible user interface that makes simple simulations easy, and complex, creative simulations possible.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Oceananigans is written in Julia by the Climate Modeling Alliance and heroic external collaborators.","category":"page"},{"location":"#Quick-install","page":"Home","title":"Quick install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Oceananigans is a registered Julia package. So to install it,","category":"page"},{"location":"","page":"Home","title":"Home","text":"Download Julia.\nLaunch Julia and type","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\n\njulia> Pkg.add(\"Oceananigans\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"compat: Julia 1.9 or later is required\nOceananigans requires Julia 1.9 or later.","category":"page"},{"location":"","page":"Home","title":"Home","text":"info: Tested Julia versions\nOceananigans is currently tested on Julia 1.10.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you're new to Julia and its wonderful Pkg manager, the Oceananigans wiki provides more detailed installation instructions.","category":"page"},{"location":"#The-Oceananigans-\"knowledge-base\"","page":"Home","title":"The Oceananigans \"knowledge base\"","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"It's deep and includes:","category":"page"},{"location":"","page":"Home","title":"Home","text":"This documentation, which provides\nexample Oceananigans scripts,\ntutorials that describe key Oceananigans objects and functions,\nexplanations of Oceananigans finite-volume-based numerical methods,\ndetails of the dynamical equations solved by Oceananigans models, and\na library documenting all user-facing Oceananigans objects and functions.\nDiscussions on the Oceananigans github, covering topics like\n\"Computational science\", or how to science and set up numerical simulations in Oceananigans, and\n\"Experimental features\", which covers new and sparsely-documented features for those who like to live dangerously.\nIf you've got a question or something to talk about, don't hesitate to start a new discussion!\nThe Oceananigans wiki, which contains practical tips for getting started with Julia, accessing and using GPUs, and productive workflows when using Oceananigans.\nIssues and pull requests also contain lots of information about problems we've found, solutions we're trying to implement, and dreams we're dreaming to make tomorrow better ğŸŒˆ.","category":"page"},{"location":"#Getting-in-touch","page":"Home","title":"Getting in touch","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Whether you need help getting started with Oceananigans, found a bug, want Oceananigans to be more awesome, or just want to chat about computational oceanography, you've got a few options for getting in touch:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Start a discussion. This is great for general questions about numerics, science, experimental or under-documented features, and for getting help setting up a neat new numerical experiment.\nOpen an issue. Issues are best if you think the Oceananigans source code needs attention: a bug, a sign error (ğŸ˜±), an important missing feature, or a typo in this documentation ğŸ‘€.\nSign up for the Julia Slack and join the #oceananigans channel because we love to chat.","category":"page"},{"location":"#Citing-and-otherwise-spreading-the-word","page":"Home","title":"Citing and otherwise spreading the word","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use Oceananigans for your research, teaching, or fun ğŸ¤©, everyone in our community will be grateful if you credit Oceananigans by name.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The community has published a number of articles describing the development of Oceananigans, including a recent preprint submitted to the Journal of Advances in Modeling Earth Systems that presents an overview of all the things that make Oceananigans unique:","category":"page"},{"location":"","page":"Home","title":"Home","text":"\"High-level, high-resolution ocean modeling at all scales with Oceananigans\"by Gregory L. Wagner, Simone Silvestri, Navid C. Constantinou, Ali Ramadhan, Jean-Michel Campin, Chris Hill, Tomas Chor, Jago Strong-Wright, Xin Kai Lee, Francis Poulin, Andre Souza, Keaton J. Burns, John Marshall, Raffaele Ferrarisubmitted to the Journal of Advances in Modeling Earth Systems, arXiv:2502.14148","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please cite this overview paper if you use Oceananigans in published work.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We've also submitted a number of model development papers. Please cite these if you use the features they describe! Also, if you have developed a new feature in Oceananigans and describe it in a paper, make sure to open a pull request to add it to this list:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Silvestri et al., \"A new WENO-Based momentum advection scheme for simulations of ocean mesoscale turbulence\".\nThis paper describes the development of WENOVectorInvariant() advection scheme, which can be used as the momentum_advection scheme for HydrostaticFreeSurfaceModel.\nSilvestri et al., \"A GPU-based ocean dynamic core for routine mesoscale-resolving climate simulations\".\nThis paper describes the optimization of the HydrostaticFreeSurfaceModel algorithm, including the implementation of a new SplitExplicitFreeSurface algorithm for Distributed architectures for multiple GPUs. As a result of this work, global simulations with O(10 km) grid spacing can be run on 16-20 nodes, achieving 10 simulated years per day (SYPD).\nWagner et al., \"Formulation and calibration of CATKE, a one-equation parameterization for microscale ocean mixing\".\nThis paper describes the development of CATKEVerticalDiffusivity(), including how it was automatically calibrated to a suite of 35 large eddy simulations (also run with Oceananigans). It additionally features solutions from TKEDissipationVerticalDiffusivity (also known as \"k-epsilon\").\nRamadhan et al., \"Oceananigans.jl: Fast and friendly geophysical fluid dynamics on GPUs\".\nThis Journal of Open Source Software article describes an early version of Oceananigans' NonhydrostaticModel.","category":"page"},{"location":"#Papers-and-preprints-using-Oceananigans","page":"Home","title":"Papers and preprints using Oceananigans","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you have work using Oceananigans that you would like to have listed here, please open a pull request to add it or let us know!","category":"page"},{"location":"","page":"Home","title":"Home","text":"Wang S., Kang W., Zhang Y., and Marshall J. (2025) The fate of rotating point plumes in an unstratified environment: from free growth to boundary interactions, Journal of Fluid Mechanics, 1018, A19. DOI:10.1017/jfm.2025.10533\nShikanian, A. and Parfenyev, V. (2025) The effects of no-slip boundaries and external force torque on two-dimensional turbulence in a square domain, arXiv preprint, arXiv:2508.13590. DOI: 10.48550/arXiv.2508.13590\nSouza, A. N., Silvestri, S., Deck, K., Bischoff, T., Ferrari, R. and Flierl, G. R. (2025) Surface to seafloor: A generative AI framework for decoding the ocean interior state, arXiv preprint, arXiv:2504.15308. DOI: 10.48550/arXiv.2503.12845\nJohnston, D. R., Shakespeare, C. J., and Constantinou, N. C. (2025) Evaluating and improving wave and non-wave stress parametrisations for oceanic flows, arXiv preprint, arXiv:2503.12845 (submitted to the Journal of Physical Oceanography). DOI: 10.48550/arXiv.2503.12845\nBhadouriya, A., Gayen, B., Naveira Garabato, A., and Silvano, A. (2025) Overshooting convection drives winter mixed layer under Antarctic sea ice, preprint (Version 1), available at Research Square. DOI: 10.21203/rs.3.rs-5932119/v1\nBisits, J. I., Zika, J. D. and Sohail, T. (2025) Cabbeling as a catalyst and driver of turbulent mixing, Journal of Fluid Mechanics, 1011, A17. DOI:10.1017/jfm.2025.349\nWhitley V. and Wenegrat, J. O. (2025) Breaking internal waves on sloping topography: connecting parcel displacements to overturn size, interior-boundary exchanges, and mixing, Journal of Physical Oceanography, 55(6), 645-661. DOI: 10.1175/JPO-D-24-0052.1\nChor, T. and Wenegrat, J. (2025). The turbulent dynamics of anticyclonic submesoscale headland wakes, Journal of Physical Oceanography, 55(6), 737â€“759. DOI: 10.1175/JPO-D-24-0139.1\nSilvestri, S., Wagner, G. L., Constantinou, N. C., Hill, C., Campin, J.-M., Souza, A., Bishnu, S., Churavy, V., Marshall, J., and Ferrari, R. (2025) A GPU-based ocean dynamical core for routine mesoscale-resolving climate simulations, Journal of Advances in Modeling Earth Systems, 16(7), e2024MS004465. DOI: 10.1029/2024MS004465\nWagner, G. L., Hillier, A., Constantinou, N. C., Silvestri, S., Souza, A., Burns, K., Hill, C., Campin, J.-M., Marshall, J., and Ferrari, R. (2025). Formulation and calibration of CATKE, a one-equation parameterization for microscale ocean mixing, Journal of Advances in Modeling Earth Systems, 16(7), e2024MS004522. DOI: 10.1029/2024MS004522\nAllred, T., Li, X., Wiersdorf, A., Greenman, B., and Gopalakrishnan, G. (2025). FlowFPX: Nimble tools for debugging floating-point exceptions, The Proceedings of the JuliaCon Conferences, 7(67), 148. DOI: 10.21105/jcon.00148\nAtkinson, E., McWilliams, J., and Grisouard, N. (2025) Near-inertial echoes of ageostrophic instability in submesoscale filaments, Journal of Fluid Mechanics, 1015, A17. DOI: 10.1017/jfm.2025.10348\nFan, X., Fox-Kemper, B., Suzuki, N., Li, Q., Marchesiello, P., Sullivan, P. P., and Hall, P. S. (2024) Comparison of the Coastal and Regional Ocean COmmunity model (CROCO) and NCAR-LES in non-hydrostatic simulations, Geoscientific Model Development, 17, 4095-4113. DOI: 10.5194/gmd-17-4095-2024\nAbbott, K. and Mahadevan, A. (2024). Why is the monsoon coastal upwelling signal subdued in the Bay of Bengal?, Journal of Geophysical Research: Oceans, 129, e2024JC022023. DOI: 10.1029/2024JC022023\nBisits, J. I., Zika, J. D., and Evans, D. G. (2024) Does cabbeling shape the thermohaline structure of high-latitude oceans?, Journal of Physical Oceanography, 54(12), 2419â€“2430. DOI: 10.1175/JPO-D-24-0061.1\nStrong-Wright J. and Taylor, J. R. (2024) A model of tidal flow and tracer release in a giant kelp forest, Flow, 4, E21. DOI: 10.1017/flo.2024.13\nSilvestri, S., Wagner, G. L., Campin, J.-M., Constantinou, N. C., Hill, C., Souza, A., and Ferrari, R. (2024). A new WENO-based momentum advection scheme for simulations of ocean mesoscale turbulence, Journal of Advances in Modeling Earth Systems, 16(7), e2023MS004130. DOI: 10.1029/2023MS004130\nChen S., Strong-Wright J., and Taylor, J. R. (2024) Modeling carbon dioxide removal via sinking of particulate organic carbon from macroalgae cultivation, Frontiers in Marine Science, 11, 1359614. DOI: 10.3389/fmars.2024.1359614\nGupta, M., GÃ¼rcan, E., and Thompson, A. F. (2024). Eddy-induced dispersion of sea ice floes at the marginal ice zone, Geophysical Research Letters, 51, e2023GL105656. DOI: 10.1029/2023GL105656\nWagner, G. L., Pizzo, N. E., Lenain, L., and Veron, F. (2023) Transition to turbulence in wind-drift layers, Journal of Fluid Mechanics, 976, A8. DOI: 10.1017/jfm.2023.920\nJimÃ©nez-Urias, M. A. and Haine T. W. N. (2023) On the non-self-adjoint and multiscale character of passive scalar mixing under laminar advection, Journal of Fluid Mechanics, 973, A44. DOI: 10.1017/jfm.2023.748\nStrong-Wright, J, Chen, S., Constantinou, N. C., Silvestri, S., Wagner, G. L., and Taylor, J. R. (2023). OceanBioME.jl: A flexible environment for modelling the coupled interactions between ocean biogeochemistry and physics, Journal of Open Source Software, 90(8), 5669. DOI: 10.21105/joss.05669\nRamadhan, A., Marshall, J. C., Souza, A. N., Lee, X. K., Piterbarg, U., Hillier, A., Wagner, G. L., Rackauckas, C., Hill, C., Campin, J.-M., and Ferrari, R. (2022). Capturing missing physics in climate model parameterizations using neural differential equations, ESS Open Archive. DOI: 10.1002/essoar.10512533.1\nGupta, M. and Thompson, A. F. (2022). Regimes of sea-ice floe melt: Ice-ocean coupling at the submesoscales, Journal of Geophysical Research: Oceans, 127, e2022JC018894. DOI: 10.1029/2022JC018894\nSimoes-Sousa, I. T., Tandon, A., Pereira, F., Lazaneo, C. Z., and Mahadevan, A. (2022). Mixed layer eddies supply nutrients to enhance the spring phytoplankton bloom, Frontiers in Marine Sciences, 9, 825027. DOI: 10.3389/fmars.2022.825027\nChor, T., Wenegrat, J. O., and Taylor, J. (2022). Insights into the mixing efficiency of submesoscale Centrifugal-Symmetric instabilities., Journal of Physical Oceanography, 52(10), 2273-2287. DOI: 10.1175/JPO-D-21-0259.1\nBire, S., Kang, W., Ramadhan, A., Campin, J.-M., and Marshall, J. (2022). Exploring ocean circulation on icy moons heated from below., Journal of Geophysical Research: Planets, 127, e2021JE007025. DOI: 10.1029/2021JE007025\nRackauckas, C., Ma, Y., Martensen, J., Warner, C., Zubov, K., Supekar, R., Skinner, D., Ramadhan, A., and Edelman, A. (2021) Universal differential equations for scientific machine learning, arXiv, arXiv.2001.04385. DOI: 10.48550/arXiv.2001.04385\nCoakley, S., Miles, T. N., Glenn, S., and Lim, H. S. (2021). Observation-Large eddy simulation comparison of ocean mixing under Typhoon Soulik (2018), OCEANS 2021: San Diego â€“ Porto, 2021, pp. 1-7. DOI: 10.23919/OCEANS44145.2021.9705670\nArnscheidt, C. W., Marshall, J., Dutrieux, P., Rye, C. D., and Ramadhan, A. (2021). On the settling depth of meltwater escaping from beneath Antarctic ice shelves, Journal of Physical Oceanography, 51(7), 2257â€“2270. DOI: 10.1175/JPO-D-20-0178.1\nWagner, G. L., Chini, G. P., Ramadhan, A., Gallet, B., and Ferrari, R. (2021). Near-inertial waves and turbulence driven by the growth of swell, Journal of Physical Oceanography, 51(5), 1337-1351. DOI: 10.1175/JPO-D-20-0178.1\nBuffett, B. A. (2021). Conditions for turbulent Ekman layers in precessionally driven flow, Geophysical Journal International, 226(1), 56â€“65. DOI: 10.1093/gji/ggab088\nBhamidipati, N., Souza, A.N., and Flierl, G.R. (2020). Turbulent mixing of a passive scalar in the ocean mixed layer, Ocean Modelling, 149, 101615. DOI: 10.1016/j.ocemod.2020.101615\nSouza, A. N., Wagner, G. L., Ramadhan, A., Allen, B., Churavy, V., Schloss, J., Campin, J. M., Hill, C., Edelman, A., Marshall, J., Flierl, G., and Ferrari, R. (2020). Uncertainty quantification of ocean parameterizations: Application to the Kâ€Profileâ€Parameterization for penetrative convection, Journal of Advances in Modeling Earth Systems, 12, e2020MS002108. DOI: 10.1029/2020MS002108","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Abkar,Â M.; Bae,Â H.Â J. and Moin,Â P. (2016). Minimum-dissipation scalar transport model for large-eddy simulation of turbulent flows. PhysicalÂ ReviewÂ Fluids 1.\n\n\n\nAbkar,Â M. and Moin,Â P. (2017). Large-eddy simulation of thermally stratified atmospheric boundary-layer flow using a minimum dissipation model. Boundary-LayerÂ Meteorology 165, 405â€“419.\n\n\n\nAdcroft,Â A. and Campin,Â J.-M. (2004). Rescaled height coordinates for accurate representation of free-surface flows in ocean circulation models. OceanÂ Modelling 7, 269â€“284.\n\n\n\nArakawa,Â A. and Lamb,Â V.Â R. (1977). Computational design of the basic dynamical processes of the UCLA General Circulation Model. In: Methods in Computational Physics: Advances in Research and Applications, Vol.Â 17 (Elsevier); pp.Â 173â€“265.\n\n\n\nAscher,Â U.; Ruuth,Â S. and Wetton,Â B. (1995). Implicit-explicit methods for time-dependent partial differential equations. SIAMÂ JournalÂ onÂ NumericalÂ Analysis 32, 797â€“823.\n\n\n\nBoussinesq,Â J. (1877). Essai sur la thÃ©orie des eaux courantes. MÃ©moires prÃ©sentÃ©s par divers savants Ã  l'AcadÃ©mie des sciences de l'Institut national de France (Impr. Nationale).\n\n\n\nBrown,Â D.Â L.; Cortez,Â R. and Minion,Â M.Â L. (2001). Accurate projection methods for the incompressible Navierâ€“Stokes equations. JournalÂ ofÂ ComputationalÂ Physics 168, 464â€“499.\n\n\n\nBurchard,Â H. and Bolding,Â K. (2001). Comparative analysis of four second-moment turbulence closure models for the oceanic mixed layer. JournalÂ ofÂ PhysicalÂ Oceanography 31, 1943â€“1968.\n\n\n\nBuzbee,Â B.; Golub,Â G. and Nielson,Â C. (1970). On direct methods for solving Poissonâ€™s equations. SIAMÂ JournalÂ onÂ NumericalÂ Analysis 7, 627â€“656.\n\n\n\nChou,Â P.Â Y. (1945). On velocity correlations and the solutions of the equations of turbulent fluctuation. QuarterlyÂ ofÂ AppliedÂ Mathematics 3, 38â€“54.\n\n\n\nCorrsin,Â S. (1961). Turbulent flow. AmericanÂ Scientist 49, 300â€“325.\n\n\n\nDeardorff,Â J.Â W. (1970). A numerical study of three-dimensional turbulent channel flow at large Reynolds numbers. JournalÂ ofÂ FluidÂ Mechanics 41, 453â€“480.\n\n\n\nDeardorff,Â J.Â W. (1974). Three-dimensional numerical study of the height and mean structure of a heated planetary boundary layer. Boundary-LayerÂ Meteorology 7, 81â€“106.\n\n\n\nDellar,Â P.Â J. (2011). Variations on a beta-plane: derivation of non-traditional beta-plane equations from Hamilton's principle on a sphere. JournalÂ ofÂ FluidÂ Mechanics 674, 174.\n\n\n\nFox-Kemper,Â B. and Menemenlis,Â D. (2008). Can large eddy simulation techniques improve mesoscale rich ocean models? In: Ocean Modeling in an Eddying Regime (American Geophysical Union (AGU)); pp.Â 319â€“337.\n\n\n\nFrigo,Â M. and Johnson,Â S. (1998). FFTW: an adaptive software architecture for the FFT. In: Proceedings of the 1998 IEEE International Conference on Acoustics, Speech and Signal Processing, ICASSP '98 (Cat. No.98CH36181), Vol.Â 3 (IEEE, Seattle, WA, USA); pp.Â 1381â€“1384.\n\n\n\nFrigo,Â M. and Johnson,Â S. (2005). The design and implementation of FFTW3. ProceedingsÂ ofÂ theÂ IEEE 93, 216â€“231.\n\n\n\nHarlow,Â F.Â H. and Welch,Â J.Â E. (1965). Numerical calculation of time-dependent viscous incompressible flow of fluid with free surface. PhysicsÂ ofÂ Fluids 8, 2182â€“89.\n\n\n\nHockney,Â R.Â W. (1965). A fast direct solution of Poisson's equation using Fourier analysis. JournalÂ ofÂ theÂ ACM 12, 95â€“113.\n\n\n\nHockney,Â R.Â W. (1969). The potential calculation and some applications. In: Methods of Computational Physics, Vol.Â 9, edited by Adler,Â B.; Fernback,Â S. and Rotenberg,Â M. (Academic Press, New York and London); pp.Â 136â€“211.\n\n\n\nKnoth,Â O. and Wensch,Â J. (2014). Generalized split-explicit Rungeâ€“Kutta methods for the compressible Euler equations. MonthlyÂ WeatherÂ Review 142, 2067â€“2081.\n\n\n\nKolmogorov,Â A. (1941). The local structure of turbulence in incompressible viscous fluid for very large Reynolds' numbers. C.Â R.Â AkademiiaÂ U.R.S.S.Â (Doklady) 30, 301â€“305.\n\n\n\nKundu,Â P.Â K.; Cohen,Â I.Â M. and Dowling,Â D.Â R. (2015). Fluid mechanics. 6Â Edition (Academic Press).\n\n\n\nLan,Â R.; Ju,Â L.; Wanh,Â Z.; Gunzburger,Â M. and Jones,Â P. (2022). High-order multirate explicit time-stepping schemes for the baroclinic-barotropic split dynamics in primitive equations. JournalÂ ofÂ ComputationalÂ Physics 457, 111050.\n\n\n\nLe,Â H. and Moin,Â P. (1991). An improvement of fractional step methods for the incompressible Navierâ€“Stokes equations. JournalÂ ofÂ ComputationalÂ Physics 92, 369â€“379.\n\n\n\nLeith,Â C.Â E. (1968). Diffusion approximation for two-dimensional turbulence. PhysicsÂ ofÂ Fluids 11, 671â€“672.\n\n\n\nLeonard,Â A. (1975). Energy cascade in large-eddy simulations of turbulent fluid flows. In: Advances in Geophysics, Vol.Â 18 (Elsevier); pp.Â 237â€“248.\n\n\n\nLilly,Â D.Â K. (1962). On the numerical simulation of buoyant convection. Tellus 14, 148â€“172.\n\n\n\nLilly,Â D.Â K. (1966). The representation of small-scale turbulence in numerical simulation experiments. NCARÂ ManuscriptÂ No.Â 281 0.\n\n\n\nMakhoul,Â J. (1980). A fast cosine transform in one and two dimensions. IEEEÂ TransactionsÂ onÂ Acoustics,Â Speech,Â andÂ SignalÂ Processing 28, 27â€“34.\n\n\n\nMarshall,Â J.; Adcroft,Â A.; Hill,Â C.; Perelman,Â L. and Heisey,Â C. (1997). A finite-volume, incompressible Navierâ€“Stokes model for studies of the ocean on parallel computers. JournalÂ ofÂ GeophysicalÂ Research:Â Oceans 102, 5753â€“5766.\n\n\n\nMurray,Â R.Â J. (1996). Explicit generation of orthogonal grids for ocean models. JournalÂ ofÂ ComputationalÂ Physics 126, 251â€“273.\n\n\n\nOrszag,Â S.Â A.; Israeli,Â M. and Deville,Â M.Â O. (1986). Boundary conditions for incompressible flows. JournalÂ ofÂ ScientificÂ Computing 1, 75â€“111.\n\n\n\nPatankar,Â S. (1980). Numerical heat transfer and fluid flow (CRC Press).\n\n\n\nPope,Â S.Â B. (2000). Turbulent flows (Cambridge University Press).\n\n\n\nPress William,Â H.; Teukolsky Saul,Â A.; Vetterling William,Â T. and Flannery Brian,Â P. (1992). Numerical recipes: the art of scientific computing (Cambridge University Press, Cambridge, UK).\n\n\n\nReynolds,Â O. (1895). On the dynamical theory of incompressible viscous fluids and the determination of the criterion. PhilosophicalÂ TransactionsÂ ofÂ theÂ RoyalÂ SocietyÂ ofÂ LondonÂ A 186, 123â€“164.\n\n\n\nRoquet,Â F.; Madec,Â G.; McDougall,Â T.Â J. and Barker,Â P.Â M. (2015). Accurate polynomial expressions for the density and specific volume of seawater using the TEOS-10 standard. OceanÂ Modeling 90, 29â€“43.\n\n\n\nRoquet,Â F.; Madec,Â G.; Brodeau,Â L. and Nycander,Â J. (2015). Defining a simplified yet â€œrealisticâ€ equation of state for seawater. JournalÂ ofÂ PhysicalÂ Oceanography 45, 2564â€“2579.\n\n\n\nRozema,Â W.; Bae,Â H.Â J.; Moin,Â P. and Verstappen,Â R. (2015). Minimum-dissipation models for large-eddy simulation. PhysicsÂ ofÂ Fluids 27, 085107.\n\n\n\nSagaut,Â P. and Meneveau,Â C. (2006). Large eddy simulation for incompressible flows: An introduction. Scientific Computation (Springer).\n\n\n\nSani,Â R.Â L.; Gresho,Â P.Â M.; Lee,Â R.Â L. and Griffiths,Â D.Â F. (1981). The cause and cure (?) of the spurious pressures generated by certain FEM solutions of the incompressible Navierâ€“Stokes equations: Part 1. InternationalÂ JournalÂ forÂ NumericalÂ MethodsÂ inÂ Fluids 1, 17â€“43.\n\n\n\nSchumann,Â U. and Sweet,Â R.Â A. (1988). Fast Fourier transforms for direct solution of Poisson's equation with staggered boundary conditions. JournalÂ ofÂ ComputationalÂ Physics 75, 123â€“137.\n\n\n\nShchepetkin,Â A.Â F. and McWilliams,Â J.Â C. (2005). The regional oceanic modeling system (ROMS): a split-explicit, free-surface, topography-following-coordinate oceanic model. OceanÂ modelling 9, 347â€“404.\n\n\n\nSmagorinsky,Â J. (1963). General circulation experiments with the primitive equations I. The basic experiment. MonthlyÂ WeatherÂ Review 91, 99â€“164.\n\n\n\nSwarztrauber,Â P.Â N. (1977). The methods of cyclic reduction, Fourier analysis and the FACR algorithm for the discrete solution of Poissonâ€™s equation on a rectangle. SIAMÂ Review 19, 490â€“501.\n\n\n\nTemperton,Â C. (1979). Direct methods for the solution of the discrete Poisson equation: Some comparisons. JournalÂ ofÂ ComputationalÂ Physics 31, 1â€“20.\n\n\n\nTemperton,Â C. (1980). On the FACR(ell) algorithm for the discrete Poisson equation. JournalÂ ofÂ ComputationalÂ Physics 34, 314â€“329.\n\n\n\nUmlauf,Â L. and Burchard,Â H. (2003). A generic length-scale equation for geophysical turbulence models. JournalÂ ofÂ MarineÂ Research 61.\n\n\n\nUmlauf,Â L. and Burchard,Â H. (2005). Second-order turbulence closure models for geophysical boundary layers. A review of recent work. ContinentalÂ ShelfÂ Research 25, 795â€“827.\n\n\n\nVerstappen,Â R. (2018). How much eddy dissipation is needed to counterbalance the nonlinear production of small, unresolved scales in a large-eddy simulation of turbulence? ComputersÂ &Â Fluids 176, 276â€“284.\n\n\n\nVerstappen,Â R.; Rozema,Â W. and Bae,Â H.Â J. (2014). Numerical scale separation in large-eddy simulation. In: Proceedings of the Summer Program; pp.Â 417â€“426.\n\n\n\nVreugdenhil,Â C.Â A. and Taylor,Â J.Â R. (2018). Large-eddy simulations of stratified plane Couette flow using the anisotropic minimum-dissipation model. PhysicsÂ ofÂ Fluids 30, 085104.\n\n\n\nWagner,Â G.Â L.; Hillier,Â A.; Constantinou,Â N.Â C.; Silvestri,Â S.; Souza,Â A.; Burns,Â K.; Hill,Â C.; Campin,Â J.-M.; Marshall,Â J. and Ferrari,Â R. (2025). Formulation and calibration of CATKE, a one-equation parameterization for microscale ocean mixing. JournalÂ ofÂ AdvancesÂ inÂ ModelingÂ EarthÂ Systems 17, e2024MS004522.\n\n\n\n","category":"page"},{"location":"literated/internal_tide/#Internal-tide-over-a-seamount","page":"Internal tide by a seamount","title":"Internal tide over a seamount","text":"","category":"section"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"In this example, we show how internal tide is generated from a barotropic tidal flow sloshing back and forth over a sea mount.","category":"page"},{"location":"literated/internal_tide/#Install-dependencies","page":"Internal tide by a seamount","title":"Install dependencies","text":"","category":"section"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"using Pkg\npkg\"add Oceananigans, CairoMakie\"","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"using Oceananigans\nusing Oceananigans.Units","category":"page"},{"location":"literated/internal_tide/#Grid","page":"Internal tide by a seamount","title":"Grid","text":"","category":"section"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"We create an ImmersedBoundaryGrid wrapped around an underlying two-dimensional RectilinearGrid that is periodic in x and bounded in z.","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"Nx, Nz = 256, 128\nH, L = 2kilometers, 1000kilometers\n\nunderlying_grid = RectilinearGrid(size = (Nx, Nz), halo = (4, 4),\n                                  x = (-L, L), z = (-H, 0),\n                                  topology = (Periodic, Flat, Bounded))","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"256Ã—1Ã—128 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 4Ã—0Ã—4 halo\nâ”œâ”€â”€ Periodic x âˆˆ [-1.0e6, 1.0e6) regularly spaced with Î”x=7812.5\nâ”œâ”€â”€ Flat y                       \nâ””â”€â”€ Bounded  z âˆˆ [-2000.0, 0.0]  regularly spaced with Î”z=15.625","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"Now we can create the non-trivial bathymetry. We use GridFittedBottom that gets as input either (i) a two-dimensional function whose arguments are the grid's native horizontal coordinates and it returns the z of the bottom, or (ii) a two-dimensional array with the values of z at the bottom cell centers.","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"In this example we'd like to have a Gaussian hill at the center of the domain.","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"h(x) = -H + h_0 exp(-x^2  2Ïƒ^2)","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"hâ‚€ = 250meters\nwidth = 20kilometers\nhill(x) = hâ‚€ * exp(-x^2 / 2width^2)\nbottom(x) = - H + hill(x)\n\ngrid = ImmersedBoundaryGrid(underlying_grid, PartialCellBottom(bottom))","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"256Ã—1Ã—128 ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded} on CPU with 4Ã—0Ã—4 halo:\nâ”œâ”€â”€ immersed_boundary: PartialCellBottom(mean(zb)=-1993.92, min(zb)=-2000.0, max(zb)=-1754.72, Ïµ=0.2)\nâ”œâ”€â”€ underlying_grid: 256Ã—1Ã—128 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 4Ã—0Ã—4 halo\nâ”œâ”€â”€ Periodic x âˆˆ [-1.0e6, 1.0e6) regularly spaced with Î”x=7812.5\nâ”œâ”€â”€ Flat y                       \nâ””â”€â”€ Bounded  z âˆˆ [-2000.0, 0.0]  regularly spaced with Î”z=15.625","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"Let's see how the domain with the bathymetry is.","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"x = xnodes(grid, Center())\nbottom_boundary = interior(grid.immersed_boundary.bottom_height, :, 1, 1)\ntop_boundary = 0 * x\n\nusing CairoMakie\n\nfig = Figure(size = (700, 200))\nax = Axis(fig[1, 1],\n          xlabel=\"x [km]\",\n          ylabel=\"z [m]\",\n          limits=((-grid.Lx/2e3, grid.Lx/2e3), (-grid.Lz, 0)))\n\nband!(ax, x/1e3, bottom_boundary, top_boundary, color = :mediumblue)\n\nfig","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"(Image: )","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"Now we want to add a barotropic tide forcing. For example, to add the lunar semi-diurnal M_2 tide we need to add forcing in the u-momentum equation of the form:","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"F_0 sin(omega_2 t)","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"where omega_2 = 2Ï€  T_2, with T_2 = 12421 mathrmhours the period of the M_2 tide.","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"The excursion parameter is a nondimensional number that expresses the ratio of the flow movement due to the tide compared to the size of the width of the hill.","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"epsilon = fracU_mathrmtidal  omega_2sigma","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"We prescribe the excursion parameter which, in turn, implies a tidal velocity U_mathrmtidal which then allows us to determing the tidal forcing amplitude F_0. For the last step, we use Fourier decomposition on the inviscid, linearized momentum equations to determine the flow response for a given tidal forcing. Doing so we get that for the sinusoidal forcing above, the tidal velocity and tidal forcing amplitudes are related via:","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"U_mathrmtidal = fracomega_2omega_2^2 - f^2 F_0","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"Now we have the way to find the value of the tidal forcing amplitude that would correspond to a given excursion parameter. The Coriolis frequency is needed, so we start by constructing a Coriolis on an f-plane at the mid-latitudes.","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"coriolis = FPlane(latitude = -45)","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"FPlane{Float64}(f=-0.000103126)","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"Now we have everything we require to construct the tidal forcing given a value of the excursion parameter.","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"Tâ‚‚ = 12.421hours\nÏ‰â‚‚ = 2Ï€ / Tâ‚‚ # radians/sec\nÏµ = 0.1 # excursion parameter\nUâ‚‚ = Ïµ * Ï‰â‚‚ * width\nAâ‚‚ = Uâ‚‚ * (Ï‰â‚‚^2 - coriolis.f^2) / Ï‰â‚‚\n\n@inline tidal_forcing(x, z, t, p) = p.Aâ‚‚ * sin(p.Ï‰â‚‚ * t)\nu_forcing = Forcing(tidal_forcing, parameters=(; Aâ‚‚, Ï‰â‚‚))","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"ContinuousForcing{@NamedTuple{Aâ‚‚::Float64, Ï‰â‚‚::Float64}}\nâ”œâ”€â”€ func: tidal_forcing (generic function with 1 method)\nâ”œâ”€â”€ parameters: (Aâ‚‚ = 1.8218611749508242e-5, Ï‰â‚‚ = 0.00014051439111137024)\nâ””â”€â”€ field dependencies: ()","category":"page"},{"location":"literated/internal_tide/#Model","page":"Internal tide by a seamount","title":"Model","text":"","category":"section"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"We built a HydrostaticFreeSurfaceModel:","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"model = HydrostaticFreeSurfaceModel(; grid, coriolis,\n                                      buoyancy = BuoyancyTracer(),\n                                      tracers = :b,\n                                      momentum_advection = WENO(),\n                                      tracer_advection = WENO(),\n                                      forcing = (; u = u_forcing))","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"HydrostaticFreeSurfaceModel{CPU, ImmersedBoundaryGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 256Ã—1Ã—128 ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded} on CPU with 4Ã—0Ã—4 halo\nâ”œâ”€â”€ timestepper: QuasiAdamsBashforth2TimeStepper\nâ”œâ”€â”€ tracers: b\nâ”œâ”€â”€ closure: Nothing\nâ”œâ”€â”€ buoyancy: BuoyancyTracer with gÌ‚ = NegativeZDirection()\nâ”œâ”€â”€ free surface: SplitExplicitFreeSurface with gravitational acceleration 9.80665 m sâ»Â²\nâ”‚   â””â”€â”€ substepping: FixedTimeStepSize(39.049 seconds)\nâ”œâ”€â”€ advection scheme: \nâ”‚   â”œâ”€â”€ momentum: WENO{3, Float64, Float32}(order=5)\nâ”‚   â””â”€â”€ b: WENO{3, Float64, Float32}(order=5)\nâ”œâ”€â”€ vertical_coordinate: ZCoordinate\nâ””â”€â”€ coriolis: FPlane{Float64}","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"We initialize the model with the tidal flow and a linear stratification.","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"Náµ¢Â² = 1e-4  # [sâ»Â²] initial buoyancy frequency / stratification\nbáµ¢(x, z) = Náµ¢Â² * z\nset!(model, u=Uâ‚‚, b=báµ¢)","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"Now let's build a Simulation.","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"Î”t = 5minutes\nstop_time = 4days\nsimulation = Simulation(model; Î”t, stop_time)","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"Simulation of HydrostaticFreeSurfaceModel{CPU, ImmersedBoundaryGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ Next time step: 5 minutes\nâ”œâ”€â”€ Elapsed wall time: 0 seconds\nâ”œâ”€â”€ Wall time per iteration: NaN days\nâ”œâ”€â”€ Stop time: 4 days\nâ”œâ”€â”€ Stop iteration: Inf\nâ”œâ”€â”€ Wall time limit: Inf\nâ”œâ”€â”€ Minimum relative step: 0.0\nâ”œâ”€â”€ Callbacks: OrderedDict with 4 entries:\nâ”‚   â”œâ”€â”€ stop_time_exceeded => 4\nâ”‚   â”œâ”€â”€ stop_iteration_exceeded => -\nâ”‚   â”œâ”€â”€ wall_time_limit_exceeded => e\nâ”‚   â””â”€â”€ nan_checker => }\nâ”œâ”€â”€ Output writers: OrderedDict with no entries\nâ””â”€â”€ Diagnostics: OrderedDict with no entries","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"We add a callback to print a message about how the simulation is going,","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"using Printf\n\nwall_clock = Ref(time_ns())\n\nfunction progress(sim)\n    elapsed = 1e-9 * (time_ns() - wall_clock[])\n\n    msg = @sprintf(\"Iter: %d, time: %s, wall time: %s, max|w|: %6.3e, m sâ»Â¹\\n\",\n                   iteration(sim), prettytime(sim), prettytime(elapsed),\n                   maximum(abs, sim.model.velocities.w))\n\n    wall_clock[] = time_ns()\n\n    @info msg\n\n    return nothing\nend\n\nadd_callback!(simulation, progress, name=:progress, IterationInterval(200))","category":"page"},{"location":"literated/internal_tide/#Diagnostics/Output","page":"Internal tide by a seamount","title":"Diagnostics/Output","text":"","category":"section"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"Add some diagnostics. Instead of u we save the deviation of u from its instantaneous domain average, u = u - (L_x H)^-1 int u  mathrmdx mathrmdz. We also save the stratification N^2 = partial_z b.","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"b = model.tracers.b\nu, v, w = model.velocities\nU = Field(Average(u))\nuâ€² = u - U\nNÂ² = âˆ‚z(b)\n\nfilename = \"internal_tide\"\nsave_fields_interval = 30minutes\n\nsimulation.output_writers[:fields] = JLD2Writer(model, (; u, uâ€², w, b, NÂ²); filename,\n                                                schedule = TimeInterval(save_fields_interval),\n                                                overwrite_existing = true)","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"JLD2Writer scheduled on TimeInterval(30 minutes):\nâ”œâ”€â”€ filepath: internal_tide.jld2\nâ”œâ”€â”€ 5 outputs: (u, uâ€², w, b, NÂ²)\nâ”œâ”€â”€ array_type: Array{Float32}\nâ”œâ”€â”€ including: [:grid, :coriolis, :buoyancy, :closure]\nâ”œâ”€â”€ file_splitting: NoFileSplitting\nâ””â”€â”€ file size: 70.9 KiB","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"We are ready â€“ let's run!","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"run!(simulation)","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"[ Info: Initializing simulation...\n[ Info: Iter: 0, time: 0 seconds, wall time: 2.313 minutes, max|w|: 2.089e-03, m sâ»Â¹\n[ Info:     ... simulation initialization complete (20.001 seconds)\n[ Info: Executing initial time step...\n[ Info:     ... initial time step complete (15.886 seconds).\n[ Info: Iter: 200, time: 16.667 hours, wall time: 24.503 seconds, max|w|: 5.068e-03, m sâ»Â¹\n[ Info: Iter: 400, time: 1.389 days, wall time: 3.522 seconds, max|w|: 5.142e-03, m sâ»Â¹\n[ Info: Iter: 600, time: 2.083 days, wall time: 3.140 seconds, max|w|: 1.964e-03, m sâ»Â¹\n[ Info: Iter: 800, time: 2.778 days, wall time: 3.167 seconds, max|w|: 4.267e-03, m sâ»Â¹\n[ Info: Iter: 1000, time: 3.472 days, wall time: 2.656 seconds, max|w|: 3.553e-03, m sâ»Â¹\n[ Info: Simulation is stopping after running for 52.969 seconds.\n[ Info: Simulation time 4 days equals or exceeds stop time 4 days.\n","category":"page"},{"location":"literated/internal_tide/#Load-output","page":"Internal tide by a seamount","title":"Load output","text":"","category":"section"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"First, we load the saved velocities and stratification output as FieldTimeSerieses.","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"saved_output_filename = filename * \".jld2\"\n\nuâ€²_t = FieldTimeSeries(saved_output_filename, \"uâ€²\")\n w_t = FieldTimeSeries(saved_output_filename, \"w\")\nNÂ²_t = FieldTimeSeries(saved_output_filename, \"NÂ²\")\n\numax = maximum(abs, uâ€²_t[end])\nwmax = maximum(abs, w_t[end])\n\ntimes = uâ€²_t.times","category":"page"},{"location":"literated/internal_tide/#Visualize","page":"Internal tide by a seamount","title":"Visualize","text":"","category":"section"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"Now we can visualize our resutls! We use CairoMakie here. On a system with OpenGL using GLMakie is more convenient as figures will be displayed on the screen.","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"We use Makie's Observable to animate the data. To dive into how Observables work we refer to Makie.jl's Documentation.","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"using CairoMakie\n\nn = Observable(1)\n\ntitle = @lift @sprintf(\"t = %1.2f days = %1.2f Tâ‚‚\",\n                       round(times[$n] / day, digits=2) , round(times[$n] / Tâ‚‚, digits=2))\n\nuâ€²â‚™ = @lift uâ€²_t[$n]\n wâ‚™ = @lift  w_t[$n]\nNÂ²â‚™ = @lift NÂ²_t[$n]\n\naxis_kwargs = (xlabel = \"x [m]\",\n               ylabel = \"z [m]\",\n               limits = ((-grid.Lx/2, grid.Lx/2), (-grid.Lz, 0)),\n               titlesize = 20)\n\nfig = Figure(size = (700, 900))\n\nfig[1, :] = Label(fig, title, fontsize=24, tellwidth=false)\n\nax_u = Axis(fig[2, 1]; title = \"u'-velocity\", axis_kwargs...)\nhm_u = heatmap!(ax_u, uâ€²â‚™; nan_color=:gray, colorrange=(-umax, umax), colormap=:balance)\nColorbar(fig[2, 2], hm_u, label = \"m sâ»Â¹\")\n\nax_w = Axis(fig[3, 1]; title = \"w-velocity\", axis_kwargs...)\nhm_w = heatmap!(ax_w, wâ‚™; nan_color=:gray, colorrange=(-wmax, wmax), colormap=:balance)\nColorbar(fig[3, 2], hm_w, label = \"m sâ»Â¹\")\n\nax_NÂ² = Axis(fig[4, 1]; title = \"stratification NÂ²\", axis_kwargs...)\nhm_NÂ² = heatmap!(ax_NÂ², NÂ²â‚™; nan_color=:gray, colorrange=(0.9Náµ¢Â², 1.1Náµ¢Â²), colormap=:magma)\nColorbar(fig[4, 2], hm_NÂ², label = \"sâ»Â²\")\n\nfig","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"(Image: )","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"Finally, we can record a movie.","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"@info \"Making an animation from saved data...\"\n\nframes = 1:length(times)\n\nrecord(fig, filename * \".mp4\", frames, framerate=16) do i\n    @info string(\"Plotting frame \", i, \" of \", frames[end])\n    n[] = i\nend","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"[ Info: Making an animation from saved data...\n[ Info: Plotting frame 1 of 193\n[ Info: Plotting frame 2 of 193\n[ Info: Plotting frame 3 of 193\n[ Info: Plotting frame 4 of 193\n[ Info: Plotting frame 5 of 193\n[ Info: Plotting frame 6 of 193\n[ Info: Plotting frame 7 of 193\n[ Info: Plotting frame 8 of 193\n[ Info: Plotting frame 9 of 193\n[ Info: Plotting frame 10 of 193\n[ Info: Plotting frame 11 of 193\n[ Info: Plotting frame 12 of 193\n[ Info: Plotting frame 13 of 193\n[ Info: Plotting frame 14 of 193\n[ Info: Plotting frame 15 of 193\n[ Info: Plotting frame 16 of 193\n[ Info: Plotting frame 17 of 193\n[ Info: Plotting frame 18 of 193\n[ Info: Plotting frame 19 of 193\n[ Info: Plotting frame 20 of 193\n[ Info: Plotting frame 21 of 193\n[ Info: Plotting frame 22 of 193\n[ Info: Plotting frame 23 of 193\n[ Info: Plotting frame 24 of 193\n[ Info: Plotting frame 25 of 193\n[ Info: Plotting frame 26 of 193\n[ Info: Plotting frame 27 of 193\n[ Info: Plotting frame 28 of 193\n[ Info: Plotting frame 29 of 193\n[ Info: Plotting frame 30 of 193\n[ Info: Plotting frame 31 of 193\n[ Info: Plotting frame 32 of 193\n[ Info: Plotting frame 33 of 193\n[ Info: Plotting frame 34 of 193\n[ Info: Plotting frame 35 of 193\n[ Info: Plotting frame 36 of 193\n[ Info: Plotting frame 37 of 193\n[ Info: Plotting frame 38 of 193\n[ Info: Plotting frame 39 of 193\n[ Info: Plotting frame 40 of 193\n[ Info: Plotting frame 41 of 193\n[ Info: Plotting frame 42 of 193\n[ Info: Plotting frame 43 of 193\n[ Info: Plotting frame 44 of 193\n[ Info: Plotting frame 45 of 193\n[ Info: Plotting frame 46 of 193\n[ Info: Plotting frame 47 of 193\n[ Info: Plotting frame 48 of 193\n[ Info: Plotting frame 49 of 193\n[ Info: Plotting frame 50 of 193\n[ Info: Plotting frame 51 of 193\n[ Info: Plotting frame 52 of 193\n[ Info: Plotting frame 53 of 193\n[ Info: Plotting frame 54 of 193\n[ Info: Plotting frame 55 of 193\n[ Info: Plotting frame 56 of 193\n[ Info: Plotting frame 57 of 193\n[ Info: Plotting frame 58 of 193\n[ Info: Plotting frame 59 of 193\n[ Info: Plotting frame 60 of 193\n[ Info: Plotting frame 61 of 193\n[ Info: Plotting frame 62 of 193\n[ Info: Plotting frame 63 of 193\n[ Info: Plotting frame 64 of 193\n[ Info: Plotting frame 65 of 193\n[ Info: Plotting frame 66 of 193\n[ Info: Plotting frame 67 of 193\n[ Info: Plotting frame 68 of 193\n[ Info: Plotting frame 69 of 193\n[ Info: Plotting frame 70 of 193\n[ Info: Plotting frame 71 of 193\n[ Info: Plotting frame 72 of 193\n[ Info: Plotting frame 73 of 193\n[ Info: Plotting frame 74 of 193\n[ Info: Plotting frame 75 of 193\n[ Info: Plotting frame 76 of 193\n[ Info: Plotting frame 77 of 193\n[ Info: Plotting frame 78 of 193\n[ Info: Plotting frame 79 of 193\n[ Info: Plotting frame 80 of 193\n[ Info: Plotting frame 81 of 193\n[ Info: Plotting frame 82 of 193\n[ Info: Plotting frame 83 of 193\n[ Info: Plotting frame 84 of 193\n[ Info: Plotting frame 85 of 193\n[ Info: Plotting frame 86 of 193\n[ Info: Plotting frame 87 of 193\n[ Info: Plotting frame 88 of 193\n[ Info: Plotting frame 89 of 193\n[ Info: Plotting frame 90 of 193\n[ Info: Plotting frame 91 of 193\n[ Info: Plotting frame 92 of 193\n[ Info: Plotting frame 93 of 193\n[ Info: Plotting frame 94 of 193\n[ Info: Plotting frame 95 of 193\n[ Info: Plotting frame 96 of 193\n[ Info: Plotting frame 97 of 193\n[ Info: Plotting frame 98 of 193\n[ Info: Plotting frame 99 of 193\n[ Info: Plotting frame 100 of 193\n[ Info: Plotting frame 101 of 193\n[ Info: Plotting frame 102 of 193\n[ Info: Plotting frame 103 of 193\n[ Info: Plotting frame 104 of 193\n[ Info: Plotting frame 105 of 193\n[ Info: Plotting frame 106 of 193\n[ Info: Plotting frame 107 of 193\n[ Info: Plotting frame 108 of 193\n[ Info: Plotting frame 109 of 193\n[ Info: Plotting frame 110 of 193\n[ Info: Plotting frame 111 of 193\n[ Info: Plotting frame 112 of 193\n[ Info: Plotting frame 113 of 193\n[ Info: Plotting frame 114 of 193\n[ Info: Plotting frame 115 of 193\n[ Info: Plotting frame 116 of 193\n[ Info: Plotting frame 117 of 193\n[ Info: Plotting frame 118 of 193\n[ Info: Plotting frame 119 of 193\n[ Info: Plotting frame 120 of 193\n[ Info: Plotting frame 121 of 193\n[ Info: Plotting frame 122 of 193\n[ Info: Plotting frame 123 of 193\n[ Info: Plotting frame 124 of 193\n[ Info: Plotting frame 125 of 193\n[ Info: Plotting frame 126 of 193\n[ Info: Plotting frame 127 of 193\n[ Info: Plotting frame 128 of 193\n[ Info: Plotting frame 129 of 193\n[ Info: Plotting frame 130 of 193\n[ Info: Plotting frame 131 of 193\n[ Info: Plotting frame 132 of 193\n[ Info: Plotting frame 133 of 193\n[ Info: Plotting frame 134 of 193\n[ Info: Plotting frame 135 of 193\n[ Info: Plotting frame 136 of 193\n[ Info: Plotting frame 137 of 193\n[ Info: Plotting frame 138 of 193\n[ Info: Plotting frame 139 of 193\n[ Info: Plotting frame 140 of 193\n[ Info: Plotting frame 141 of 193\n[ Info: Plotting frame 142 of 193\n[ Info: Plotting frame 143 of 193\n[ Info: Plotting frame 144 of 193\n[ Info: Plotting frame 145 of 193\n[ Info: Plotting frame 146 of 193\n[ Info: Plotting frame 147 of 193\n[ Info: Plotting frame 148 of 193\n[ Info: Plotting frame 149 of 193\n[ Info: Plotting frame 150 of 193\n[ Info: Plotting frame 151 of 193\n[ Info: Plotting frame 152 of 193\n[ Info: Plotting frame 153 of 193\n[ Info: Plotting frame 154 of 193\n[ Info: Plotting frame 155 of 193\n[ Info: Plotting frame 156 of 193\n[ Info: Plotting frame 157 of 193\n[ Info: Plotting frame 158 of 193\n[ Info: Plotting frame 159 of 193\n[ Info: Plotting frame 160 of 193\n[ Info: Plotting frame 161 of 193\n[ Info: Plotting frame 162 of 193\n[ Info: Plotting frame 163 of 193\n[ Info: Plotting frame 164 of 193\n[ Info: Plotting frame 165 of 193\n[ Info: Plotting frame 166 of 193\n[ Info: Plotting frame 167 of 193\n[ Info: Plotting frame 168 of 193\n[ Info: Plotting frame 169 of 193\n[ Info: Plotting frame 170 of 193\n[ Info: Plotting frame 171 of 193\n[ Info: Plotting frame 172 of 193\n[ Info: Plotting frame 173 of 193\n[ Info: Plotting frame 174 of 193\n[ Info: Plotting frame 175 of 193\n[ Info: Plotting frame 176 of 193\n[ Info: Plotting frame 177 of 193\n[ Info: Plotting frame 178 of 193\n[ Info: Plotting frame 179 of 193\n[ Info: Plotting frame 180 of 193\n[ Info: Plotting frame 181 of 193\n[ Info: Plotting frame 182 of 193\n[ Info: Plotting frame 183 of 193\n[ Info: Plotting frame 184 of 193\n[ Info: Plotting frame 185 of 193\n[ Info: Plotting frame 186 of 193\n[ Info: Plotting frame 187 of 193\n[ Info: Plotting frame 188 of 193\n[ Info: Plotting frame 189 of 193\n[ Info: Plotting frame 190 of 193\n[ Info: Plotting frame 191 of 193\n[ Info: Plotting frame 192 of 193\n[ Info: Plotting frame 193 of 193\n","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"(Image: )","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"This page was generated using Literate.jl.","category":"page"},{"location":"numerical_implementation/spatial_operators/#Spatial-operators","page":"Spatial operators","title":"Spatial operators","text":"","category":"section"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"To calculate the various terms and perform the time-stepping, discrete difference and interpolation operators must be designed from which all the terms, such as momentum advection and Laplacian diffusion, may be constructed. Much of the material in this section is derived from Marshall et al. (1997).","category":"page"},{"location":"numerical_implementation/spatial_operators/#Differences","page":"Spatial operators","title":"Differences","text":"","category":"section"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"Difference operators act as the discrete form of the derivative operator. Care must be taken when calculating differences on a staggered grid. For example, the the difference of a cell-centered variable such as temperature T lies on the faces  in the direction of the difference, and vice versa. In principle, there are three difference operators, one for each  direction","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"  delta_x f = f_E - f_W  quad\n  delta_y f = f_N - f_S  quad\n  delta_z f = f_T - f_B ","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"where the E and W subscripts indicate that the value is evaluated the eastern or western wall of the cell, N and S indicate the northern and southern walls, and T and B indicate the top and bottom walls.","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"Additionally, two delta operators must be defined for each direction to account for the staggered nature of the grid. One for taking the difference of a cell-centered variable and projecting it onto the cell faces","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"beginalign\n    delta_x^faa f_i j k = f_i j k - f_i-1 j k   \n    delta_y^afa f_i j k = f_i j k - f_i j-1 k   \n    delta_z^aaf f_i j k = f_i j k - f_i j k-1  \nendalign","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"and another for taking the difference of a face-centered variable and projecting it onto the cell centers","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"beginalign\n    delta_x^caa f_i j k = f_i+1 j k - f_i j k   \n    delta_y^aca f_i j k = f_i j+1 k - f_i j k   \n    delta_z^aac f_i j k = f_i j k+1 - f_i j k  \nendalign","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"The three superscript characters indicate the cell location of the output in the x, y, and z dimensions. \"f\" stands for \"face\", \"c\" for \"center\", and \"a\" for \"any\". For example, \"faa\" in delta_x^faa indicates that the output lies on the cell face in the x dimension but remains at their original positions (\"any\") in the y and z dimensions.","category":"page"},{"location":"numerical_implementation/spatial_operators/#Interpolation","page":"Spatial operators","title":"Interpolation","text":"","category":"section"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"In order to add or multiply variables that are defined at different points they are interpolated. In our case, linear interpolation or averaging is employed. Once again, there are two averaging operators, one for each direction,","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"beginequation\n  overlinef^x = fracf_E + f_W2   quad\n  overlinef^y = fracf_N + f_S2   quad\n  overlinef^z = fracf_T + f_B2  \nendequation","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"Additionally, three averaging operators must be defined for each direction. One for taking the average of a cell-centered  variable and projecting it onto the cell faces","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"beginalign\n    overlinef_i j k^faa = fracf_i j k + f_i-1 j k2   \n    overlinef_i j k^afa = fracf_i j k + f_i j-1 k2   \n    overlinef_i j k^aaf = fracf_i j k + f_i j k-12  \nendalign","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"and another for taking the average of a face-centered variable and projecting it onto the cell centers","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"beginalign\n    overlinef_i j k^caa = fracf_i+1 j k + f_i j k2   \n    overlinef_i j k^aca = fracf_i j+1 k + f_i j k2   \n    overlinef_i j k^aac = fracf_i j k+1 + f_i j k2  \nendalign","category":"page"},{"location":"numerical_implementation/spatial_operators/#Divergence-and-flux-divergence","page":"Spatial operators","title":"Divergence and flux divergence","text":"","category":"section"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"The divergence of the flux of a cell-centered quantity over the cell can be calculated as","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"boldsymbolnabla boldsymbolcdot boldsymbolf\n= frac1V left delta_x^faa (A_x f_x)\n                   + delta_y^afa (A_y f_y)\n                   + delta_z^aaf (A_z f_z) right  ","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"where boldsymbolf = (f_x f_y f_z) is the flux with components defined normal to the faces, and V is the volume of the cell. The presence of a solid boundary is indicated by setting the appropriate flux normal to the boundary to zero.","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"A similar divergence operator can be defined for a face-centered quantity. The divergence of, e.g., the flux of T over a cell, boldsymbolnabla boldsymbolcdot (boldsymbolv T), is then","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"renewcommanddiv1 boldsymbolnabla boldsymbolcdot left ( 1 right )\ndivboldsymbolv T\n= frac1V left delta_x^caa (A_x u overlineT^faa)\n                   + delta_y^aca (A_y v overlineT^afa)\n                   + delta_z^aac (A_z w overlineT^aaf) right  ","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"where T is interpolated onto the cell faces where it can be multiplied by the velocities, which are then differenced and projected onto the cell centers where they added together.","category":"page"},{"location":"numerical_implementation/spatial_operators/#Momentum-advection","page":"Spatial operators","title":"Momentum advection","text":"","category":"section"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"The advection terms that appear in model equations can be rewritten using the incompressibility (boldsymbolnabla boldsymbolcdot boldsymbolv = 0) as, e.g,","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"renewcommanddiv1 boldsymbolnabla boldsymbolcdot left ( 1 right )\nbeginalign\nboldsymbolv boldsymbolcdot boldsymbolnabla u  = divu boldsymbolv - u ( boldsymbolnabla boldsymbolcdot boldsymbolv ) nonumber \n     = divu boldsymbolv  \nendalign","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"which can then be discretized similarly to the flux divergence operator, however, they must be discretized differently for each direction.","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"For example, the x-momentum advection operator is discretized as","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"boldsymbolv boldsymbolcdot boldsymbolnabla u\n= frac1overlineV^x left\n    delta_x^faa left( overlineA_x u^caa overlineu^caa right)\n  + delta_y^afa left( overlineA_y v^aca overlineu^aca right)\n  + delta_z^aaf left( overlineA_z w^aac overlineu^aac right)\nright  ","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"where overlineV^x is the average of the volumes of the cells on either side of the face in question. Calculating partial_x (uu) can be performed by interpolating A_x u and u onto the cell centers then multiplying them and differencing them back onto the faces. However, in the case of the the two other terms, partial_y (vu) and partial_z (wu), the two variables must be interpolated onto the cell edges to be multiplied then differenced back onto the cell faces.","category":"page"},{"location":"numerical_implementation/spatial_operators/#Discretization-of-isotropic-diffusion-operators","page":"Spatial operators","title":"Discretization of isotropic diffusion operators","text":"","category":"section"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"An isotropic viscosity operator acting on vertical momentum is discretized via","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"    boldsymbolnabla boldsymbolcdot left ( nu boldsymbolnabla w right )\n    = frac1V left\n          delta_x^faa ( nu overlineA_x^caa partial_x^caa w )\n        + delta_y^afa ( nu overlineA_y^aca partial_y^aca w )\n        + delta_z^aaf ( nu overlineA_z^aac partial_z^aac w )\n    right   ","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"where nu is the kinematic viscosity.","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"An isotropic diffusion operator acting on a tracer c, on the other hand, is discretized via","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"   boldsymbolnabla boldsymbolcdot left ( kappa boldsymbolnabla c right )\n    = frac1V left vphantomoverlineA_x^caa\n        delta_x^caa ( kappa A_x partial_x^faa c )\n      + delta_y^aca ( kappa A_y partial_y^afa c )\n      + delta_z^aac ( kappa A_z partial_z^aaf c )\n    right  ","category":"page"},{"location":"numerical_implementation/spatial_operators/#Vertical-integrals","page":"Spatial operators","title":"Vertical integrals","text":"","category":"section"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"Vertical integrals are converted into sums along each column. For example, the hydrostatic pressure anomaly is","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"    p_HY^prime = int_-L_z^0 b^prime  mathrmd z  ","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"where b^prime is the buoyancy perturbation. Converting it into a sum that we compute from the top downwards we get","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"    beginequation\n    p_HY^prime(k) =\n        begincases\n            - overlineb_N_z^prime^aaf Delta z^F_N_z                quad k = N_z   \n            p_HY^prime(k+1) - overlineb_k+1^prime^aaf Delta z^F_k  quad 1 le k le N_z - 1  \n        endcases\n    endequation","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"where we converted the sum into a recursive definition for p_HY^prime(k) in terms of p_HY^prime(k+1) so that the integral may be computed with mathcalO(N_z) operations by a single thread.","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"The vertical velocity w may be computed from u and v via the continuity equation","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"    w = - int_-L_z^0 (partial_x u + partial_y v)  mathrmd z  ","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"to satisfy the incompressibility condition boldsymbolnabla boldsymbolcdot boldsymbolv = 0 to numerical precision. This also involves computing a vertical integral, in this case evaluated from the bottom up","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"    beginequation\n    w_k =\n        begincases\n            0  quad k = 1   \n            w_k-1 - left( partial_x^caa u + partial_y^aca v right) Delta z^C_k  quad 2 le k le N_z  \n        endcases\n    endequation","category":"page"},{"location":"contributing/#Contributors-Guide","page":"Contributor's guide","title":"Contributors Guide","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Thank you for considering contributions to Oceananigans! We hope this guide helps you make a contribution.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Feel free to ask us questions and chat with us at any time about any topic at all by:","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Opening a GitHub issue\nCreating a GitHub discussion\nSending a message to the #oceananigans channel on Julia Slack.","category":"page"},{"location":"contributing/#Creating-issues","page":"Contributor's guide","title":"Creating issues","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"The simplest way to contribute to Oceananigans is to create or comment on issues and discussions.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"The most useful bug reports:","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Provide an explicit code snippet â€“ not just a link â€“ that reproduces the bug in the latest tagged version of Oceananigans. This is sometimes called the \"minimal working example\". Reducing bug-producing code to a minimal example can dramatically decrease the time it takes to resolve an issue.\nPaste the entire error received when running the code snippet, even if it's unbelievably long.\nUse triple backticks (e.g., ```some_code; and_some_more_code;```) to enclose code snippets, and other markdown formatting syntax to make your issue easy and quick to read.\nReport the Oceananigans version, Julia version, machine (especially if using a GPU) and any other possibly useful details of the computational environment in which the bug was created.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Discussions are recommended for asking questions about (for example) the user interface, implementation details, science, and life in general.","category":"page"},{"location":"contributing/#But-I-want-to-*code*!","page":"Contributor's guide","title":"But I want to code!","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"New users help write Oceananigans code and documentation by forking the Oceananigans repository, using git to edit code and docs, and then creating a pull request. Pull requests are reviewed by Oceananigans collaborators.\nA pull request can be merged once it is reviewed and approved by collaborators. If the pull request author has write access, they have the responsibility of merging their pull request. Otherwise, Oceananigans.jl collaborators will execute the merge with permission from the pull request author.\nNote: for small or minor changes (such as fixing a typo in documentation), the GitHub editor is super useful for forking and opening a pull request with a single click.\nWrite your code with love and care. In particular, conform to existing Oceananigans style and formatting conventions. For example, we love verbose and explicit variable names, use TitleCase for types, snake_case for objects, and always,put,spaces.after.commas,or.periods. For formatting decisions we loosely follow the YASGuide. It's worth few extra minutes of our time to leave future generations with well-written, readable code.","category":"page"},{"location":"contributing/#What-is-a-\"collaborator\"-and-how-can-I-become-one?","page":"Contributor's guide","title":"What is a \"collaborator\" and how can I become one?","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Collaborators have permissions to review pull requests and status allows a contributor to review pull requests in addition to opening them. Collaborators can also create branches in the main Oceananigans repository.\nWe ask that new contributors try their hand at forking Oceananigans, and opening and merging a pull request before requesting collaborator status.","category":"page"},{"location":"contributing/#What's-a-good-way-to-start-developing-Oceananigans?","page":"Contributor's guide","title":"What's a good way to start developing Oceananigans?","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Tackle an existing issue. We keep a list of good first issues that are self-contained and suitable for a newcomer to try and work on.\nTry to run Oceananigans and play around with it to simulate your favorite fluids and ocean physics. If you run into any problems or find it difficult to use or understand, please open an issue!\nWrite up an example or tutorial on how to do something useful with Oceananigans, like how to set up a new physical configuration.\nImprove documentation or comments if you found something hard to use.\nImplement a new feature if you need it to use Oceananigans.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"If you're interested in working on something, let us know by commenting on existing issues or by opening a new issue. This is to make sure no one else is working on the same issue and so we can help and guide you in case there is anything you need to know beforehand.","category":"page"},{"location":"contributing/#Ground-Rules","page":"Contributor's guide","title":"Ground Rules","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Each pull request should consist of a logical collection of changes. You can include multiple bug fixes in a single pull request, but they should be related. For unrelated changes, please submit multiple pull requests.\nDo not commit changes to files that are irrelevant to your feature or bugfix (eg: .gitignore).\nBe willing to accept criticism and work on improving your code; we don't want to break other users' code, so care must be taken not to introduce bugs. We discuss pull requests and keep working on them until we believe we've done a good job.\nBe aware that the pull request review process is not immediate, and is generally proportional to the size of the pull request.","category":"page"},{"location":"contributing/#Reporting-a-bug","page":"Contributor's guide","title":"Reporting a bug","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"The easiest way to get involved is to report issues you encounter when using Oceananigans or by requesting something you think is missing.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Head over to the issues page.\nSearch to see if your issue already exists or has even been solved previously.\nIf you indeed have a new issue or request, click the \"New Issue\" button.\nPlease be as specific as possible. Include the version of the code you were using, as well as what operating system you are running. The output of Julia's versioninfo() and ] status is helpful to include. Try your best to include a complete, \"minimal working example\" that reproduces the issue.","category":"page"},{"location":"contributing/#Setting-up-your-development-environment","page":"Contributor's guide","title":"Setting up your development environment","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Install Julia on your system.\nInstall git on your system if it is not already there (install XCode command line tools on a Mac or git bash on Windows).\nLogin to your GitHub account and make a fork of the Oceananigans repository by clicking the \"Fork\" button.\nClone your fork of the Oceananigans repository (in terminal on Mac/Linux or git shell/ GUI on Windows) in the location you'd like to keep it.\ngit clone https://github.com/your-user-name/Oceananigans.jl.git\nNavigate to that folder in the terminal or in Anaconda Prompt if you're on Windows.\nConnect your repository to the upstream (main project).\ngit remote add oceananigans https://github.com/CLiMA/Oceananigans.jl.git\nCreate the development environment by opening Julia via julia --project then typing in ] instantiate. This will install all the dependencies in the Project.toml file. Your development environment is now ready!\nYou can test to make sure Oceananigans works by typing in ] test. (This is equivalent to using Pkg; Pkg.test().) Doing so will run all the tests (and this can take a while). Alternatively, you can run only one test script file by providing its name as an environment variable. For example, to run the tests only from the test_coriolis.jl file we call:\n$ TEST_FILE=test_coriolis.jl julia --project -e\"using Pkg; Pkg.test()\"","category":"page"},{"location":"contributing/#Pull-Requests","page":"Contributor's guide","title":"Pull Requests","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"We follow the ColPrac guide for collaborative practices. We ask that new contributors read that guide before submitting a pull request.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Changes and contributions should be made via GitHub pull requests against the main branch.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"When you're done making changes, commit the changes you made. Chris Beams has written a guide on how to write good commit messages.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"When you think your changes are ready to be merged into the main repository, push to your fork and submit a pull request.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Working on your first Pull Request? You can learn how from this free video series How to Contribute to an Open Source Project on GitHub, Aaron Meurer's tutorial on the git workflow, or the guide â€œHow to Contribute to Open Source\".","category":"page"},{"location":"contributing/#Documentation","page":"Contributor's guide","title":"Documentation","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Now that you've made your awesome contribution, it's time to tell the world how to use it. Writing documentation strings is really important to make sure others use your functionality properly. Didn't write new functions? That's fine, but be sure that the documentation for the code you touched is still in great shape. It is not uncommon to find some strange wording or clarification that you can take care of while you are here.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"You can preview how the Documentation will look like after merging by building the documentation locally. From the main directory of your local repository call","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"julia --project=docs/ -e 'using Pkg; Pkg.develop(PackageSpec(path=pwd())); Pkg.instantiate()'","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"to instantiate the documentation environment and then","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"JULIA_DEBUG=Documenter julia --project=docs/ docs/make.jl","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"If the documentation built is successful, you can open docs/build/index.html in your favorite browser.Providing the environment variable JULIA_DEBUG=Documenter will provide with more information in the documentation build process and thus help figuring out a potential bug.","category":"page"},{"location":"contributing/#Credits","page":"Contributor's guide","title":"Credits","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"This contributor's guide is heavily based on the excellent MetPy contributor's guide.","category":"page"},{"location":"literated/shallow_water_Bickley_jet/#An-unstable-Bickley-jet-in-Shallow-Water-model","page":"Shallow water Bickley jet","title":"An unstable Bickley jet in Shallow Water model","text":"","category":"section"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"This example uses Oceananigans.jl's ShallowWaterModel to simulate the evolution of an unstable, geostrophically balanced, Bickley jet The example is periodic in x with flat bathymetry and uses the conservative formulation of the shallow water equations. The initial conditions superpose the Bickley jet with small-amplitude perturbations. See \"The nonlinear evolution of barotropically unstable jets,\" J. Phys. Oceanogr. (2003) for more details on this problem.","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"The mass transport (uh vh) is the prognostic momentum variable in the conservative formulation of the shallow water equations, where (u v) are the horizontal velocity components and h is the layer height.","category":"page"},{"location":"literated/shallow_water_Bickley_jet/#Install-dependencies","page":"Shallow water Bickley jet","title":"Install dependencies","text":"","category":"section"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"First we make sure that we have all of the packages that are required to run the simulation.","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"using Pkg\npkg\"add Oceananigans, NCDatasets, Polynomials, CairoMakie\"","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"using Oceananigans\nusing Oceananigans.Models: ShallowWaterModel","category":"page"},{"location":"literated/shallow_water_Bickley_jet/#Two-dimensional-domain","page":"Shallow water Bickley jet","title":"Two-dimensional domain","text":"","category":"section"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"The shallow water model is two-dimensional and uses grids that are Flat in the vertical direction. We use length scales non-dimensionalized by the width of the Bickley jet.","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"grid = RectilinearGrid(size = (48, 128),\n                       x = (0, 2Ï€),\n                       y = (-10, 10),\n                       topology = (Periodic, Bounded, Flat))","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"48Ã—128Ã—1 RectilinearGrid{Float64, Periodic, Bounded, Flat} on CPU with 3Ã—3Ã—0 halo\nâ”œâ”€â”€ Periodic x âˆˆ [-1.67581e-17, 6.28319) regularly spaced with Î”x=0.1309\nâ”œâ”€â”€ Bounded  y âˆˆ [-10.0, 10.0]           regularly spaced with Î”y=0.15625\nâ””â”€â”€ Flat z                               ","category":"page"},{"location":"literated/shallow_water_Bickley_jet/#Building-a-ShallowWaterModel","page":"Shallow water Bickley jet","title":"Building a ShallowWaterModel","text":"","category":"section"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"We build a ShallowWaterModel with the WENO advection scheme, 3rd-order Runge-Kutta time-stepping, non-dimensional Coriolis, and gravitational acceleration","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"gravitational_acceleration = 1\ncoriolis = FPlane(f=1)\n\nmodel = ShallowWaterModel(; grid, coriolis, gravitational_acceleration,\n                          timestepper = :RungeKutta3,\n                          momentum_advection = WENO())","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"ShallowWaterModel{typename(CPU), Float64}(time = 0 seconds, iteration = 0) \nâ”œâ”€â”€ grid: 48Ã—128Ã—1 RectilinearGrid{Float64, Periodic, Bounded, Flat} on CPU with 3Ã—3Ã—0 halo\nâ”œâ”€â”€ timestepper: RungeKutta3TimeStepper\nâ”œâ”€â”€ advection scheme: \nâ”‚   â”œâ”€â”€ momentum: WENO{3, Float64, Float32}(order=5)\nâ”‚   â””â”€â”€ mass: WENO{3, Float64, Float32}(order=5)\nâ”œâ”€â”€ tracers: ()\nâ””â”€â”€ coriolis: FPlane{Float64}","category":"page"},{"location":"literated/shallow_water_Bickley_jet/#Background-state-and-perturbation","page":"Shallow water Bickley jet","title":"Background state and perturbation","text":"","category":"section"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"The background velocity u and free-surface Î· correspond to a geostrophically balanced Bickely jet with maximum speed of U and maximum free-surface deformation of Î”Î·,","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"U = 1  # Maximum jet velocity\nH = 10 # Reference depth\nf = coriolis.f\ng = gravitational_acceleration\nÎ”Î· = f * U / g  # Maximum free-surface deformation as dictated by geostrophy\n\nhÌ„(x, y) = H - Î”Î· * tanh(y)\nuÌ„(x, y) = U * sech(y)^2","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Å« (generic function with 1 method)","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"The total height of the fluid is h = L_z + eta. Linear stability theory predicts that for the parameters we consider here, the growth rate for the most unstable mode that fits our domain is approximately 0139.","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"The vorticity of the background state is","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Ï‰Ì„(x, y) = 2 * U * sech(y)^2 * tanh(y)","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Ï‰Ì„ (generic function with 1 method)","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"The initial conditions include a small-amplitude perturbation that decays away from the center of the jet.","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"small_amplitude = 1e-4\n\n uâ±(x, y) = uÌ„(x, y) + small_amplitude * exp(-y^2) * randn()\nuhâ±(x, y) = uâ±(x, y) * hÌ„(x, y)","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"uhâ± (generic function with 1 method)","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"We first set a \"clean\" initial condition without noise for the purpose of discretely calculating the initial 'mean' vorticity,","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"uÌ„Ì„h(x, y) = uÌ„(x, y) * hÌ„(x, y)\n\nset!(model, uh = uÌ„Ì„h, h = hÌ„)","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"We next compute the initial vorticity and perturbation vorticity,","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"uh, vh, h = model.solution\n\n# Build velocities\nu = uh / h\nv = vh / h\n\n# Build mean vorticity discretely\nÏ‰ = Field(âˆ‚x(v) - âˆ‚y(u))\n\n# Copy mean vorticity to a new field\nÏ‰â± = Field{Face, Face, Nothing}(model.grid)\nÏ‰â± .= Ï‰\n\n# Use this new field to compute the perturbation vorticity\nÏ‰â€² = Field(Ï‰ - Ï‰â±)","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"48Ã—129Ã—1 Field{Face, Face, Center} on RectilinearGrid on CPU\nâ”œâ”€â”€ grid: 48Ã—128Ã—1 RectilinearGrid{Float64, Periodic, Bounded, Flat} on CPU with 3Ã—3Ã—0 halo\nâ”œâ”€â”€ boundary conditions: FieldBoundaryConditions\nâ”‚   â””â”€â”€ west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: Nothing\nâ”œâ”€â”€ operand: BinaryOperation at (Face, Face, Center)\nâ”œâ”€â”€ status: time=0.0\nâ””â”€â”€ data: 54Ã—135Ã—1 OffsetArray(::Array{Float64, 3}, -2:51, -2:132, 1:1) with eltype Float64 with indices -2:51Ã—-2:132Ã—1:1\n    â””â”€â”€ max=0.0, min=0.0, mean=0.0","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"and finally set the \"true\" initial condition with noise,","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"set!(model, uh = uhâ±)","category":"page"},{"location":"literated/shallow_water_Bickley_jet/#Running-a-Simulation","page":"Shallow water Bickley jet","title":"Running a Simulation","text":"","category":"section"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"We pick the time-step so that we make sure we resolve the surface gravity waves, which propagate with speed of the order sqrtg H. That is, with Î”t = 1e-2 we ensure that sqrtg H Î”t  Î”x  sqrtg H Î”t  Î”y  07.","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"simulation = Simulation(model, Î”t = 1e-2, stop_time = 100)","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Simulation of ShallowWaterModel{RectilinearGrid{Float64, Periodic, Bounded, Flat, Oceananigans.Grids.StaticVerticalDiscretization{Nothing, Nothing, Float64, Float64}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, CPU, Float64, Float64, @NamedTuple{momentum::WENO{3, Float64, Float32, Nothing, WENO{2, Float64, Float32, Nothing, UpwindBiased{1, Float64, Nothing, Centered{1, Float64, Nothing}}, Centered{1, Float64, Nothing}}, Centered{2, Float64, Centered{1, Float64, Nothing}}}, mass::WENO{3, Float64, Float32, Nothing, WENO{2, Float64, Float32, Nothing, UpwindBiased{1, Float64, Nothing, Centered{1, Float64, Nothing}}, Centered{1, Float64, Nothing}}, Centered{2, Float64, Centered{1, Float64, Nothing}}}}, @NamedTuple{u::Field{Face, Center, Center, BinaryOperation{Face, Center, Center, typeof(/), Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Flat, Oceananigans.Grids.StaticVerticalDiscretization{Nothing, Nothing, Float64, Float64}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.NoFluxBoundaryCondition, Oceananigans.BoundaryConditions.NoFluxBoundaryCondition, Nothing, Nothing, Nothing, @NamedTuple{bottom_and_top::Nothing, south_and_north::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, KernelAbstractions.NDIteration.StaticSize{(48, 1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_south_and_north_halo!)}, west_and_east::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(134, 1)}, Oceananigans.Utils.OffsetStaticSize{(1:134, 1:1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_periodic_west_and_east_halo!)}}, @NamedTuple{bottom_and_top::Tuple{Nothing, Nothing}, south_and_north::Tuple{Oceananigans.BoundaryConditions.NoFluxBoundaryCondition, Oceananigans.BoundaryConditions.NoFluxBoundaryCondition}, west_and_east::Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}}}, Nothing, Nothing}, Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Flat, Oceananigans.Grids.StaticVerticalDiscretization{Nothing, Nothing, Float64, Float64}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.NoFluxBoundaryCondition, Oceananigans.BoundaryConditions.NoFluxBoundaryCondition, Nothing, Nothing, Nothing, @NamedTuple{bottom_and_top::Nothing, south_and_north::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, KernelAbstractions.NDIteration.StaticSize{(48, 1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_south_and_north_halo!)}, west_and_east::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(134, 1)}, Oceananigans.Utils.OffsetStaticSize{(1:134, 1:1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_periodic_west_and_east_halo!)}}, @NamedTuple{bottom_and_top::Tuple{Nothing, Nothing}, south_and_north::Tuple{Oceananigans.BoundaryConditions.NoFluxBoundaryCondition, Oceananigans.BoundaryConditions.NoFluxBoundaryCondition}, west_and_east::Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}}}, Nothing, Nothing}, typeof(Oceananigans.Operators.identity2), typeof(â„‘xá¶ áµƒáµƒ), RectilinearGrid{Float64, Periodic, Bounded, Flat, Oceananigans.Grids.StaticVerticalDiscretization{Nothing, Nothing, Float64, Float64}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}, RectilinearGrid{Float64, Periodic, Bounded, Flat, Oceananigans.Grids.StaticVerticalDiscretization{Nothing, Nothing, Float64, Float64}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.NoFluxBoundaryCondition, Oceananigans.BoundaryConditions.NoFluxBoundaryCondition, Nothing, Nothing, Nothing, @NamedTuple{bottom_and_top::Nothing, south_and_north::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, KernelAbstractions.NDIteration.StaticSize{(48, 1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_south_and_north_halo!)}, west_and_east::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(134, 1)}, Oceananigans.Utils.OffsetStaticSize{(1:134, 1:1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_periodic_west_and_east_halo!)}}, @NamedTuple{bottom_and_top::Tuple{Nothing, Nothing}, south_and_north::Tuple{Oceananigans.BoundaryConditions.NoFluxBoundaryCondition, Oceananigans.BoundaryConditions.NoFluxBoundaryCondition}, west_and_east::Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}}}, Oceananigans.Fields.FieldStatus{Float64}, Nothing}, v::Field{Center, Face, Center, BinaryOperation{Center, Face, Center, typeof(/), Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Flat, Oceananigans.Grids.StaticVerticalDiscretization{Nothing, Nothing, Float64, Float64}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Open{Nothing}, Nothing}, BoundaryCondition{Open{Nothing}, Nothing}, Nothing, Nothing, Nothing, @NamedTuple{bottom_and_top::Nothing, south_and_north::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, KernelAbstractions.NDIteration.StaticSize{(48, 1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_south_and_north_halo!)}, west_and_east::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(135, 1)}, Oceananigans.Utils.OffsetStaticSize{(1:135, 1:1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_periodic_west_and_east_halo!)}}, @NamedTuple{bottom_and_top::Tuple{Nothing, Nothing}, south_and_north::Tuple{BoundaryCondition{Open{Nothing}, Nothing}, BoundaryCondition{Open{Nothing}, Nothing}}, west_and_east::Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}}}, Nothing, Nothing}, Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Flat, Oceananigans.Grids.StaticVerticalDiscretization{Nothing, Nothing, Float64, Float64}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.NoFluxBoundaryCondition, Oceananigans.BoundaryConditions.NoFluxBoundaryCondition, Nothing, Nothing, Nothing, @NamedTuple{bottom_and_top::Nothing, south_and_north::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, KernelAbstractions.NDIteration.StaticSize{(48, 1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_south_and_north_halo!)}, west_and_east::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(134, 1)}, Oceananigans.Utils.OffsetStaticSize{(1:134, 1:1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_periodic_west_and_east_halo!)}}, @NamedTuple{bottom_and_top::Tuple{Nothing, Nothing}, south_and_north::Tuple{Oceananigans.BoundaryConditions.NoFluxBoundaryCondition, Oceananigans.BoundaryConditions.NoFluxBoundaryCondition}, west_and_east::Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}}}, Nothing, Nothing}, typeof(Oceananigans.Operators.identity3), typeof(â„‘yáµƒá¶ áµƒ), RectilinearGrid{Float64, Periodic, Bounded, Flat, Oceananigans.Grids.StaticVerticalDiscretization{Nothing, Nothing, Float64, Float64}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}, RectilinearGrid{Float64, Periodic, Bounded, Flat, Oceananigans.Grids.StaticVerticalDiscretization{Nothing, Nothing, Float64, Float64}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, Nothing, @NamedTuple{bottom_and_top::Nothing, south_and_north::Nothing, west_and_east::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(135, 1)}, Oceananigans.Utils.OffsetStaticSize{(1:135, 1:1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_periodic_west_and_east_halo!)}}, @NamedTuple{bottom_and_top::Tuple{Nothing, Nothing}, south_and_north::Tuple{Nothing, Nothing}, west_and_east::Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}}}, Oceananigans.Fields.FieldStatus{Float64}, Nothing}, w::Nothing}, FPlane{Float64}, @NamedTuple{uh::typeof(Oceananigans.Forcings.zeroforcing), vh::typeof(Oceananigans.Forcings.zeroforcing), h::typeof(Oceananigans.Forcings.zeroforcing)}, Nothing, Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Flat, Oceananigans.Grids.StaticVerticalDiscretization{Nothing, Nothing, Float64, Float64}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.NoFluxBoundaryCondition, Oceananigans.BoundaryConditions.NoFluxBoundaryCondition, Nothing, Nothing, Nothing, @NamedTuple{bottom_and_top::Nothing, south_and_north::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, KernelAbstractions.NDIteration.StaticSize{(48, 1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_south_and_north_halo!)}, west_and_east::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(134, 1)}, Oceananigans.Utils.OffsetStaticSize{(1:134, 1:1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_periodic_west_and_east_halo!)}}, @NamedTuple{bottom_and_top::Tuple{Nothing, Nothing}, south_and_north::Tuple{Oceananigans.BoundaryConditions.NoFluxBoundaryCondition, Oceananigans.BoundaryConditions.NoFluxBoundaryCondition}, west_and_east::Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}}}, Nothing, Nothing}, @NamedTuple{uh::Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Flat, Oceananigans.Grids.StaticVerticalDiscretization{Nothing, Nothing, Float64, Float64}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.NoFluxBoundaryCondition, Oceananigans.BoundaryConditions.NoFluxBoundaryCondition, Nothing, Nothing, Nothing, @NamedTuple{bottom_and_top::Nothing, south_and_north::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, KernelAbstractions.NDIteration.StaticSize{(48, 1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_south_and_north_halo!)}, west_and_east::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(134, 1)}, Oceananigans.Utils.OffsetStaticSize{(1:134, 1:1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_periodic_west_and_east_halo!)}}, @NamedTuple{bottom_and_top::Tuple{Nothing, Nothing}, south_and_north::Tuple{Oceananigans.BoundaryConditions.NoFluxBoundaryCondition, Oceananigans.BoundaryConditions.NoFluxBoundaryCondition}, west_and_east::Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}}}, Nothing, Nothing}, vh::Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Flat, Oceananigans.Grids.StaticVerticalDiscretization{Nothing, Nothing, Float64, Float64}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Open{Nothing}, Nothing}, BoundaryCondition{Open{Nothing}, Nothing}, Nothing, Nothing, Nothing, @NamedTuple{bottom_and_top::Nothing, south_and_north::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, KernelAbstractions.NDIteration.StaticSize{(48, 1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_south_and_north_halo!)}, west_and_east::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(135, 1)}, Oceananigans.Utils.OffsetStaticSize{(1:135, 1:1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_periodic_west_and_east_halo!)}}, @NamedTuple{bottom_and_top::Tuple{Nothing, Nothing}, south_and_north::Tuple{BoundaryCondition{Open{Nothing}, Nothing}, BoundaryCondition{Open{Nothing}, Nothing}}, west_and_east::Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}}}, Nothing, Nothing}, h::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Flat, Oceananigans.Grids.StaticVerticalDiscretization{Nothing, Nothing, Float64, Float64}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.NoFluxBoundaryCondition, Oceananigans.BoundaryConditions.NoFluxBoundaryCondition, Nothing, Nothing, Nothing, @NamedTuple{bottom_and_top::Nothing, south_and_north::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, KernelAbstractions.NDIteration.StaticSize{(48, 1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_south_and_north_halo!)}, west_and_east::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(134, 1)}, Oceananigans.Utils.OffsetStaticSize{(1:134, 1:1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_periodic_west_and_east_halo!)}}, @NamedTuple{bottom_and_top::Tuple{Nothing, Nothing}, south_and_north::Tuple{Oceananigans.BoundaryConditions.NoFluxBoundaryCondition, Oceananigans.BoundaryConditions.NoFluxBoundaryCondition}, west_and_east::Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}}}, Nothing, Nothing}}, @NamedTuple{}, Nothing, RungeKutta3TimeStepper{Float64, @NamedTuple{uh::Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Flat, Oceananigans.Grids.StaticVerticalDiscretization{Nothing, Nothing, Float64, Float64}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.NoFluxBoundaryCondition, Oceananigans.BoundaryConditions.NoFluxBoundaryCondition, Nothing, Nothing, Nothing, @NamedTuple{bottom_and_top::Nothing, south_and_north::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, KernelAbstractions.NDIteration.StaticSize{(48, 1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_south_and_north_halo!)}, west_and_east::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(134, 1)}, Oceananigans.Utils.OffsetStaticSize{(1:134, 1:1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_periodic_west_and_east_halo!)}}, @NamedTuple{bottom_and_top::Tuple{Nothing, Nothing}, south_and_north::Tuple{Oceananigans.BoundaryConditions.NoFluxBoundaryCondition, Oceananigans.BoundaryConditions.NoFluxBoundaryCondition}, west_and_east::Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}}}, Nothing, Nothing}, vh::Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Flat, Oceananigans.Grids.StaticVerticalDiscretization{Nothing, Nothing, Float64, Float64}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, Nothing, @NamedTuple{bottom_and_top::Nothing, south_and_north::Nothing, west_and_east::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(135, 1)}, Oceananigans.Utils.OffsetStaticSize{(1:135, 1:1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_periodic_west_and_east_halo!)}}, @NamedTuple{bottom_and_top::Tuple{Nothing, Nothing}, south_and_north::Tuple{Nothing, Nothing}, west_and_east::Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}}}, Nothing, Nothing}, h::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Flat, Oceananigans.Grids.StaticVerticalDiscretization{Nothing, Nothing, Float64, Float64}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.NoFluxBoundaryCondition, Oceananigans.BoundaryConditions.NoFluxBoundaryCondition, Nothing, Nothing, Nothing, @NamedTuple{bottom_and_top::Nothing, south_and_north::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, KernelAbstractions.NDIteration.StaticSize{(48, 1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_south_and_north_halo!)}, west_and_east::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(134, 1)}, Oceananigans.Utils.OffsetStaticSize{(1:134, 1:1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_periodic_west_and_east_halo!)}}, @NamedTuple{bottom_and_top::Tuple{Nothing, Nothing}, south_and_north::Tuple{Oceananigans.BoundaryConditions.NoFluxBoundaryCondition, Oceananigans.BoundaryConditions.NoFluxBoundaryCondition}, west_and_east::Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}}}, Nothing, Nothing}}, Nothing}, ConservativeFormulation}\nâ”œâ”€â”€ Next time step: 10 ms\nâ”œâ”€â”€ Elapsed wall time: 0 seconds\nâ”œâ”€â”€ Wall time per iteration: NaN days\nâ”œâ”€â”€ Stop time: 1.667 minutes\nâ”œâ”€â”€ Stop iteration: Inf\nâ”œâ”€â”€ Wall time limit: Inf\nâ”œâ”€â”€ Minimum relative step: 0.0\nâ”œâ”€â”€ Callbacks: OrderedDict with 4 entries:\nâ”‚   â”œâ”€â”€ stop_time_exceeded => 4\nâ”‚   â”œâ”€â”€ stop_iteration_exceeded => -\nâ”‚   â”œâ”€â”€ wall_time_limit_exceeded => e\nâ”‚   â””â”€â”€ nan_checker => }\nâ”œâ”€â”€ Output writers: OrderedDict with no entries\nâ””â”€â”€ Diagnostics: OrderedDict with no entries","category":"page"},{"location":"literated/shallow_water_Bickley_jet/#Prepare-output-files","page":"Shallow water Bickley jet","title":"Prepare output files","text":"","category":"section"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Define a function to compute the norm of the perturbation on the cross channel velocity. We obtain the norm function from LinearAlgebra.","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"using LinearAlgebra: norm\n\nperturbation_norm(args...) = norm(v)","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"perturbation_norm (generic function with 1 method)","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Build the output_writer for the two-dimensional fields to be output. Output every t = 1.0. Note that we need NCDatasets to be able to use the NetCDFWriter.","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"using NCDatasets\n\nfields_filename = joinpath(@__DIR__, \"shallow_water_Bickley_jet_fields.nc\")\nsimulation.output_writers[:fields] = NetCDFWriter(model, (; Ï‰, Ï‰â€²),\n                                                  filename = fields_filename,\n                                                  schedule = TimeInterval(2),\n                                                  overwrite_existing = true)","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"NetCDFWriter scheduled on TimeInterval(2 seconds):\nâ”œâ”€â”€ filepath: shallow_water_Bickley_jet_fields.nc\nâ”œâ”€â”€ dimensions: time(0), y_afa(129), x_faa(48), x_caa(48), y_aca(128)\nâ”œâ”€â”€ 2 outputs: (Ï‰, Ï‰â€²)\nâ”œâ”€â”€ array_type: Array{Float32}\nâ”œâ”€â”€ file_splitting: NoFileSplitting\nâ””â”€â”€ file size: 27.7 KiB","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Build the output_writer for the growth rate, which is a scalar field. Output every time step.","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"growth_filename = joinpath(@__DIR__, \"shallow_water_Bickley_jet_perturbation_norm.nc\")\nsimulation.output_writers[:growth] = NetCDFWriter(model, (; perturbation_norm),\n                                                  filename = growth_filename,\n                                                  schedule = IterationInterval(1),\n                                                  dimensions = (; perturbation_norm = ()),\n                                                  overwrite_existing = true)","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"NetCDFWriter scheduled on IterationInterval(1):\nâ”œâ”€â”€ filepath: shallow_water_Bickley_jet_perturbation_norm.nc\nâ”œâ”€â”€ dimensions: time(0), y_afa(129), x_faa(48), x_caa(48), y_aca(128)\nâ”œâ”€â”€ 1 outputs: perturbation_norm\nâ”œâ”€â”€ array_type: Array{Float32}\nâ”œâ”€â”€ file_splitting: NoFileSplitting\nâ””â”€â”€ file size: 26.8 KiB","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"And finally run the simulation.","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"run!(simulation)","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"[ Info: Initializing simulation...\n[ Info:     ... simulation initialization complete (5.849 seconds)\n[ Info: Executing initial time step...\n[ Info:     ... initial time step complete (3.543 seconds).\n[ Info: Simulation is stopping after running for 1.051 minutes.\n[ Info: Simulation time 1.667 minutes equals or exceeds stop time 1.667 minutes.\n","category":"page"},{"location":"literated/shallow_water_Bickley_jet/#Visualize-the-results","page":"Shallow water Bickley jet","title":"Visualize the results","text":"","category":"section"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Load required packages to read output and plot.","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"using NCDatasets, Printf, CairoMakie","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Define the coordinates for plotting.","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"x, y = xnodes(Ï‰), ynodes(Ï‰)","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Read in the output_writer for the two-dimensional fields and then create an animation showing both the total and perturbation vorticities.","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"fig = Figure(size = (1200, 660))\n\naxis_kwargs = (xlabel = \"x\", ylabel = \"y\")\nax_Ï‰  = Axis(fig[2, 1]; title = \"Total vorticity, Ï‰\", axis_kwargs...)\nax_Ï‰â€² = Axis(fig[2, 3]; title = \"Perturbation vorticity, Ï‰ - Ï‰Ì„\", axis_kwargs...)\n\nn = Observable(1)\n\nds = NCDataset(simulation.output_writers[:fields].filepath, \"r\")\n\ntimes = ds[\"time\"][:]\n\nÏ‰ = @lift ds[\"Ï‰\"][:, :, $n]\nhm_Ï‰ = heatmap!(ax_Ï‰, x, y, Ï‰, colorrange = (-1, 1), colormap = :balance)\nColorbar(fig[2, 2], hm_Ï‰)\n\nÏ‰â€² = @lift ds[\"Ï‰â€²\"][:, :, $n]\nhm_Ï‰â€² = heatmap!(ax_Ï‰â€², x, y, Ï‰â€², colormap = :balance)\nColorbar(fig[2, 4], hm_Ï‰â€²)\n\ntitle = @lift @sprintf(\"t = %.1f\", times[$n])\nfig[1, 1:4] = Label(fig, title, fontsize=24, tellwidth=false)\n\nfig","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"(Image: )","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Finally, we record a movie.","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"frames = 1:length(times)\n\nrecord(fig, \"shallow_water_Bickley_jet.mp4\", frames, framerate=12) do i\n    n[] = i\nend","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"(Image: )","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"It's always good practice to close the NetCDF files when we are done.","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"close(ds)","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"closed Dataset","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Read in the output_writer for the scalar field (the norm of v-velocity).","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"ds2 = NCDataset(simulation.output_writers[:growth].filepath, \"r\")\n\n     t = ds2[\"time\"][:]\nnorm_v = ds2[\"perturbation_norm\"][:]\n\nclose(ds2)","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"We import the fit function from Polynomials.jl to compute the best-fit slope of the perturbation norm on a logarithmic plot. This slope corresponds to the growth rate.","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"using Polynomials: fit\n\nI = 5000:6000\n\ndegree = 1\nlinear_fit_polynomial = fit(t[I], log.(norm_v[I]), degree, var = :t)","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"&#45;9.524905950800612 &#43; 0.1381142317529374&#8729;t","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"We can get the coefficient of the n-th power from the fitted polynomial by using n as an index, e.g.,","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"constant, slope = linear_fit_polynomial[0], linear_fit_polynomial[1]","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"(-9.524905950800612, 0.1381142317529374)","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"We then use the computed linear fit coefficients to construct the best fit and plot it together with the time-series for the perturbation norm for comparison.","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"best_fit = @. exp(constant + slope * t)\n\nlines(t, norm_v;\n      linewidth = 4,\n      label = \"norm(v)\",\n      axis = (yscale = log10,\n              limits = (nothing, (1e-3, 30)),\n              xlabel = \"time\",\n              ylabel = \"norm(v)\",\n               title = \"growth of perturbation norm\"))\n\nlines!(t[I], 2 * best_fit[I]; # factor 2 offsets fit from curve for better visualization\n       linewidth = 4,\n       label = \"best fit\")\n\naxislegend(position = :rb)\n","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"(Image: )","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"The slope of the best-fit curve on a logarithmic scale approximates the rate at which instability grows in the simulation. Let's see how this compares with the theoretical growth rate.","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"println(\"Numerical growth rate is approximated to be \", round(slope, digits=3), \",\\n\",\n        \"which is very close to the theoretical value of 0.139.\")","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Numerical growth rate is approximated to be 0.138,\nwhich is very close to the theoretical value of 0.139.\n","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"This page was generated using Literate.jl.","category":"page"},{"location":"physics/turbulence_closures/#Turbulence-closures","page":"Turbulence closures","title":"Turbulence closures","text":"","category":"section"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"The turbulence closure selected by the user determines the form of stress divergence boldsymbolnabla boldsymbolcdot boldsymboltau and diffusive flux divergence boldsymbolnabla boldsymbolcdot boldsymbolq_c in the momentum and tracer conservation equations.","category":"page"},{"location":"physics/turbulence_closures/#Constant-isotropic-diffusivity","page":"Turbulence closures","title":"Constant isotropic diffusivity","text":"","category":"section"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"In a constant isotropic diffusivity model, the kinematic stress tensor is defined","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"tau_ij = - nu Sigma_ij  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"where nu is a constant viscosity and Sigma_ij equiv tfrac12 left ( v_i j + v_j i right ) is the strain-rate tensor. The divergence of boldsymboltau is then","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"boldsymbolnabla boldsymbolcdot boldsymboltau = -nu nabla^2 boldsymbolv  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"Similarly, the diffusive tracer flux is boldsymbolq_c = - kappa boldsymbolnabla c for tracer diffusivity kappa, and the diffusive tracer flux divergence is","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"boldsymbolnabla boldsymbolcdot boldsymbolq_c = - kappa nabla^2 c  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"Each tracer may have a unique diffusivity kappa.","category":"page"},{"location":"physics/turbulence_closures/#Constant-anisotropic-diffusivity","page":"Turbulence closures","title":"Constant anisotropic diffusivity","text":"","category":"section"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"A constant anisotropic diffusivity implies a constant tensor diffusivity nu_j k and stress boldsymboltau_ij = nu_j k u_i k with non-zero components nu_11 = nu_22 = nu_h and nu_33 = nu_z. With this form the kinematic stress divergence becomes","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"boldsymbolnabla boldsymbolcdot boldsymboltau = - left  nu_h left ( partial_x^2 + partial_y^2 right )\n                                    + nu_v partial_z^2 right  boldsymbolv  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"and diffusive flux divergence","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"boldsymbolnabla boldsymbolcdot boldsymbolq_c = - left  kappa_h left ( partial_x^2 + partial_y^2 right )\n                                    + kappa_v partial_z^2 right  c  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"in terms of the horizontal viscosities and diffusivities, nu_h and kappa_h, and the vertical viscosity and diffusivities, nu_z and kappa_z. Each tracer may have a unique diffusivity components kappa_h and kappa_v.","category":"page"},{"location":"physics/turbulence_closures/#Scalar-biharmonic-diffusivity","page":"Turbulence closures","title":"Scalar biharmonic diffusivity","text":"","category":"section"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"A constant biharmonic diffusivity implies a constant tensor diffusivity nu_j k and stressboldsymboltau_ij = nu_j k partial_k^3 u_i with non-zero components nu_11 = nu_22 = nu_h and nu_33 = nu_z.","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"With this form the kinematic stress divergence becomes","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"boldsymbolnabla boldsymbolcdot boldsymboltau = - left  nu_h left ( partial_x^2 + partial_y^2 right )^2\n                                    + nu_v partial_z^4 right  boldsymbolv  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"and diffusive flux divergence","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"boldsymbolnabla boldsymbolcdot boldsymbolq_c = - left  kappa_h left ( partial_x^2 + partial_y^2 right )^2\n                                    + kappa_v partial_z^4 right  c  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"in terms of the horizontal biharmonic viscosities and diffusivities, nu_h and kappa_h, and the vertical biharmonic viscosity and diffusivities, nu_z and kappa_z. Each tracer may have a unique diffusivity components kappa_h and kappa_z.","category":"page"},{"location":"physics/turbulence_closures/#Smagorinsky-Lilly-turbulence-closure","page":"Turbulence closures","title":"Smagorinsky-Lilly turbulence closure","text":"","category":"section"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"In the turbulence closure proposed by Lilly (1962) and Smagorinsky (1963), the subgrid stress associated with unresolved turbulent motions is modeled diffusively via","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"tau_ij = - 2 nu_e Sigma_ij  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"where Sigma_ij = tfrac12 left ( v_i j + v_j i right ) is the resolved strain rate. The eddy viscosity is given by","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"    beginalign\n    nu_e = left ( C Delta_f right )^2 sqrt Sigma^2   varsigma(N^2  Sigma^2)  \n    labeleqsmagorinsky-viscosity\n    endalign","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"where Delta_f is the \"filter width\" associated with the finite volume grid spacing and C is a user-specified model constant, Sigma^2 equiv Sigma_ij Sigma_ij. The factor varsigma(N^2  Sigma^2) reduces nu_e in regions of strong stratification via","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"    varsigma(N^2  Sigma^2) = sqrt1 - min left ( 1 C_b N^2  Sigma^2 right )  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"where N^2 = max left (0 partial_z b right ) is the squared buoyancy frequency for stable stratification with partial_z b  0 and C_b is a user-specified constant.  Lilly (1962) proposed C_b = 1Pr, where Pr is a turbulent Prandtl number. The filter width for the Smagorinsky-Lilly closure is","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"Delta_f(boldsymbolx) = left ( Delta x Delta y Delta z right)^13  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"where Delta x, Delta y, and Delta z are the grid spacing in the boldsymbolhat x, boldsymbolhat y, and boldsymbolhat z directions at location boldsymbolx = (x y z).","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"The effect of subgrid turbulence on tracer mixing is also modeled diffusively via","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"boldsymbolq_c = - kappa_e boldsymbolnabla c  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"where the eddy diffusivity kappa_e is","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"kappa_e = fracnu_ePr + kappa  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"Both Pr and kappa may be set independently for each tracer.","category":"page"},{"location":"physics/turbulence_closures/#Anisotropic-minimum-dissipation-(AMD)-turbulence-closure","page":"Turbulence closures","title":"Anisotropic minimum dissipation (AMD) turbulence closure","text":"","category":"section"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"The anisotropic minimum dissipation (AMD) model proposed by Verstappen (2018) and was described and tested by Vreugdenhil and Taylor (2018). The AMD model uses an eddy diffusivity hypothesis similar the Smagorinsky-Lilly model. In the AMD model, the eddy viscosity and diffusivity for each tracer are defined in terms of eddy viscosity and diffusivity predictors nu_e^dagger and kappa_e^dagger, such that","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"    nu_e = max left ( 0 nu_e^dagger right ) + nu\n    quad textand quad\n    kappa_e = max left ( 0 kappa_e^dagger right ) + kappa  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"to ensure that nu_e ge 0 and kappa_e ge 0, where nu and kappa are the constant isotropic background viscosity and diffusivities for each tracer. The eddy viscosity predictor is","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"    beginequation\n    nu_e^dagger = C Delta_f^2\n    frac\n        (hatpartial_k hatv_i) (hatpartial_k hatv_j) hatSigma_ij\n        + C_b hatdelta_i3 (hatpartial_k hatv_i) (hatpartial_k b)\n        (hatpartial_l hatv_m) (hatpartial_l hatv_m)  \n    labeleqnu-dagger\n    endequation","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"while the eddy diffusivity predictor for tracer c is","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"    beginequation\n    labeleqkappa-dagger\n    kappa_e^dagger = C Delta_f^2\n    frac\n        (hatpartial_k hatv_i) (hatpartial_k c) (hatpartial_i c)\n        (hatpartial_l c) (hatpartial_l c)  \n    endequation","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"In the definitions of the eddy viscosity and eddy diffusivity predictor, C and C_b are user-specified model constants, Delta_f is a \"filter width\" associated with the finite volume grid spacing, and the hat decorators on partial derivatives, velocities, and the Kronecker delta hat delta_i3 are defined such that","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"    hat partial_i equiv Delta_i partial_i qquad\n    hatv_i(x t) equiv fracv_i(x t)Delta_i quad textand quad\n    hatdelta_i3 equiv fracdelta_i3Delta_3  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"A velocity gradient, for example, is therefore hatpartial_i hatv_j(x t) = fracDelta_iDelta_j partial_i v_j(x t), while the normalized strain tensor is","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"    hatSigma_ij =\n        frac12 left hatpartial_i hatv_j(x t) + hatpartial_j hatv_i(x t) right  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"The filter width Delta_f in that appears in the viscosity and diffusivity predictors is taken as the square root of the harmonic mean of the squares of the filter widths in each direction:","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"    frac1Delta_f^2 = frac13 left(   frac1Delta x^2\n                                              + frac1Delta y^2\n                                              + frac1Delta z^2 right)  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"The constant C_b permits the \"buoyancy modification\" term it multiplies to be omitted from a calculation. By default we use the model constants C = 112 and C_b = 0.","category":"page"},{"location":"physics/turbulence_closures/#Convective-adjustment-vertical-diffusivity","page":"Turbulence closures","title":"Convective adjustment vertical diffusivity","text":"","category":"section"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"This closure aims to model the enhanced mixing that occurs due to convection. At every point and for every time instance, the closure diagnoses the gravitational stability of the fluid and applies the vertical diffusivities (i) background_Î½z to u, v and background_Îºz to all tracers if the fluid is gravitationally neutral or stable with bz  0, or (ii) convective_Î½z and convective_Îºz if bz  0.","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"This closure is a plausible model for convection if convective_Îºz gg background_Îºz and convective_Î½z gg background_Î½z.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#numerical_les","page":"Large eddy simulation","title":"Large eddy simulation","text":"","category":"section"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"The idea behind large eddy simulation (LES) is to resolve the \"large eddies\" while modeling the effect of unresolved sub-grid scale motions. This is done usually be assuming eddy viscosity and eddy diffusivity models and providing an estimate for the eddy viscosity nu_e and diffusivity kappa_e.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"Much of the early work on LES was motivated by the study of atmospheric boundary layer turbulence, being developed by Smagorinsky (1963) and Lilly (1966), then first implemented by Deardorff (1970) and Deardorff (1974).","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"In the LES framework, the Navier-Stokes equations are averaged in the same way as Reynolds (1895) except that the mean field overlineboldsymbolv is obtained via convolution with a filter convolution kernel G","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"overlineboldsymbolv(boldsymbolx t) = G star boldsymbolv =\n  int_-infty^infty int_-infty^infty\n  boldsymbolv(boldsymbolx^prime t) G(boldsymbolx - boldsymbolx^prime t - tau)  mathrmdboldsymbolx^prime  mathrmd tau  ","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"as described by Leonard (1975) who introduced the general filtering formalism.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"The overlinev_i^prime v_j^prime terms are now components of what is called the sub-grid scale (SGS) stress tensor tau^textSGS_ij, which looks the same as the Reynolds stress tensor so we will drop the SGS superscript.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"It is probably important to note that the large eddy simulation filtering operation does not satisfy the properties of a Reynolds operator (Â§2.1) (Sagaut and Meneveau, 2006) and that in general, the filtered residual is not zero: overlineboldsymbolv^prime(boldsymbolx t) ne 0.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"Â§13.2 of Pope (2000) lists a number of popular choices for the filter function G. For practical reasons we simply employ the box kernel","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"  beginequation\n  labeleqbox-kernel\n  G_Delta = G(boldsymbolx t) = frac1Delta H left( frac12Delta - boldsymbolx right) delta(t - t_n)  \n  endequation","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"where H is the Heaviside function, Delta is the grid spacing, and t_n is the current time step. With \\eqref{eq:box-kernel} we get back the averaging operator originally used by Deardorff (1970)","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"overlineboldsymbolv(x y z t) =\n  frac1Delta x Delta y Delta z\n  int_x - frac12Delta x^x + frac12Delta x\n  int_y - frac12Delta y^y + frac12Delta y\n  int_z - frac12Delta z^z + frac12Delta z\n  boldsymbolv(xi eta zeta t)  mathrmd xi  mathrmd eta  mathrmd zeta  ","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"which if evaluated at the cell centers just returns the cell averages we already compute in the finite volume method.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#Smagorinsky-Lilly-model","page":"Large eddy simulation","title":"Smagorinsky-Lilly model","text":"","category":"section"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"Smagorinsky (1963) estimated the eddy viscosity nu_e via a characteristic length scale Delta times a velocity scale given by Delta overlineS where overlineS = sqrt2overlineS_ijoverlineS_ij. Thus the SGS stress tensor is given by","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"tau_ij = -2 nu_e overlineS_ij = -2 (C_s Delta)^2 overlineS overlineS_ij  ","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"where C_s is a dimensionless constant. The grid spacing is usually used for the characteristic length scale Delta. The eddy diffusivities are calculated via kappa_e = nu_e  textPr_t where the turbulent Prandtl number textPr_t is usually chosen to be mathcalO(1) from experimental observations.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"Assuming that the SGS energy cascade is equal to the overall dissipation rate varepsilon from the Kolmogorov (1941) theory, Lilly (1966) was able to derive a value of","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"C_s = left( frac32C_Kpi^frac43 right)^-frac34 approx 016  ","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"using an empirical value of C_K approx 16 for the Kolmogorov constant. This seems reasonable for isotropic turbulence if the grid spacing Delta falls in the inertial range. In practice, C_s is a tunable parameter.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"Due to the presence of the constant C_s, the model is sometimes referred to as the constant Smagorinsky model in contrast to dynamic Smagorinsky models that dynamically compute C_s to account for effects such as buoyant convection.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#Anisotropic-minimum-dissipation-models","page":"Large eddy simulation","title":"Anisotropic minimum dissipation models","text":"","category":"section"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"Minimum-dissipation eddy-viscosity models are a class of LES closures that use the minimum eddy dissipation required to dissipate the energy of sub-grid scale motion. Rozema et al. (2015) proposed the first minimum-dissipation model appropriate for use on anisotropic grids, termed the anisotropic minimum dissipation (AMD) model.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"It has a number of desirable properties over Smagorinsky-type closures: it is more cost-effective than dynamic Smagorinsky, it appropriately switches off in laminar and transitional flows, and it is consistent with the exact SGS stress tensor on both isotropic and anisotropic grids. Abkar et al. (2016) extended the AMD model to model SGS scalar fluxes for tracer transport. Abkar and Moin (2017) further extended the model to include a buoyancy term that accounts for the contribution of buoyant forces to the production and suppression of turbulence.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"Vreugdenhil and Taylor (2018) derive a modified AMD model by following the requirement suggested by Verstappen (2018), which entail normalising the displacement, the velocity, and the velocity gradient by the filter width to ensure that the resulting eddy dissipation properly counteracts the spurious kinetic energy transferred by convective nonlinearity, to derive a modified AMD model.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"The eddy viscosity and diffusivity are defined in terms of eddy viscosity and diffusivity predictors nu_e^dagger and kappa_e^dagger, such that","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"nu_e = max lbrace 0 nu_e^dagger rbrace\nquad textand quad\nkappa_e = max lbrace 0 kappa_e^dagger rbrace  ","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"to ensure that nu_e ge 0 and kappa_e ge 0. Leaving out the overlines and understanding that all variables represent the resolved/filtered variables, the eddy viscosity predictor is given by","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"    beginequation\n    labeleqnu-dagger\n    nu_e^dagger = -(CDelta)^2\n      frac\n        left( hatpartial_k hatv_i right) left( hatpartial_k hatv_j right) hatS_ij\n        + C_bhatdelta_i3 alpha g left( hatpartial_k hatv_i right) hatpartial_k theta\n        left( hatpartial_l hatv_m right) left( hatpartial_l hatv_m right)  \n    endequation","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"and the eddy diffusivity predictor by","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"    beginequation\n    kappa_e^dagger = -(CDelta)^2\n    frac\n        left( hatpartial_k hatv_i right) left( hatpartial_k hattheta right) hatpartial_i theta\n        left( hatpartial_l hattheta right) left( hatpartial_l hattheta right)  \n    endequation","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"where","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"  beginequation\n  hatx_i = fracx_iDelta_i quad\n  hatv_i(hatx t) = fracv_i(x t)Delta_i quad\n  hatpartial_i hatv_j(hatx t) = fracDelta_iDelta_j partial_i v_j(x t) quad\n  hatdelta_i3 = fracdelta_i3Delta_3  \n  endequation","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"so that the normalized rate of strain tensor is","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"    beginequation\n    labeleqS-hat\n    hatS_ij =\n      frac12 left hatpartial_i hatv_j(hatx t) + hatpartial_j hatv_i(hatx t) right  \n    endequation","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"In equations \\eqref{eq:nu-dagger}â€“\\eqref{eq:S-hat}, C is a modified PoincarÃ© \"constant\" that is independent from the filter width Delta but does depend on the accuracy of the discretization method used. Abkar et al. (2016) cite C^2 = frac112 for a spectral method and C^2 = frac13 for a second-order accurate scheme. Delta_i is the filter width in the x_i-direction, and Delta is given by the square root of the harmonic mean of the squares of the filter widths in each direction","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"    frac1Delta^2 = frac13 left( frac1Delta x^2 + frac1Delta y^2 + frac1Delta z^2 right)  ","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"The term multiplying C_b is the buoyancy modification introduced by Abkar and Moin (2017) and is small for weakly stratified flows. We have introduced the C_b constant so that the buoyancy modification term may be turned on and off.","category":"page"},{"location":"literated/two_dimensional_turbulence/#Two-dimensional-turbulence-example","page":"Two-dimensional turbulence","title":"Two dimensional turbulence example","text":"","category":"section"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"In this example, we initialize a random velocity field and observe its turbulent decay in a two-dimensional domain. This example demonstrates:","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"How to run a model with no tracers and no buoyancy model.\nHow to use computed Fields to generate output.","category":"page"},{"location":"literated/two_dimensional_turbulence/#Install-dependencies","page":"Two-dimensional turbulence","title":"Install dependencies","text":"","category":"section"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"using Pkg\npkg\"add Oceananigans, CairoMakie\"","category":"page"},{"location":"literated/two_dimensional_turbulence/#Model-setup","page":"Two-dimensional turbulence","title":"Model setup","text":"","category":"section"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"We instantiate the model with an isotropic diffusivity. We use a grid with 128Â² points, a fifth-order advection scheme, third-order Runge-Kutta time-stepping, and a small isotropic viscosity.  Note that we assign Flat to the z direction.","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"using Oceananigans\n\ngrid = RectilinearGrid(size=(128, 128), extent=(2Ï€, 2Ï€), topology=(Periodic, Periodic, Flat))\n\nmodel = NonhydrostaticModel(; grid,\n                            advection = UpwindBiased(order=5),\n                            closure = ScalarDiffusivity(Î½=1e-5))","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 128Ã—128Ã—1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3Ã—3Ã—0 halo\nâ”œâ”€â”€ timestepper: RungeKutta3TimeStepper\nâ”œâ”€â”€ advection scheme: UpwindBiased(order=5)\nâ”œâ”€â”€ tracers: ()\nâ”œâ”€â”€ closure: ScalarDiffusivity{ExplicitTimeDiscretization}(Î½=1.0e-5)\nâ”œâ”€â”€ buoyancy: Nothing\nâ””â”€â”€ coriolis: Nothing","category":"page"},{"location":"literated/two_dimensional_turbulence/#Random-initial-conditions","page":"Two-dimensional turbulence","title":"Random initial conditions","text":"","category":"section"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Our initial condition randomizes model.velocities.u and model.velocities.v. We ensure that both have zero mean for aesthetic reasons.","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"using Statistics\n\nu, v, w = model.velocities\n\nuáµ¢ = rand(size(u)...)\nváµ¢ = rand(size(v)...)\n\nuáµ¢ .-= mean(uáµ¢)\nváµ¢ .-= mean(váµ¢)\n\nset!(model, u=uáµ¢, v=váµ¢)","category":"page"},{"location":"literated/two_dimensional_turbulence/#Setting-up-a-simulation","page":"Two-dimensional turbulence","title":"Setting up a simulation","text":"","category":"section"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"We set-up a simulation that stops at 50 time units, with an initial time-step of 0.1, and with adaptive time-stepping and progress printing.","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"simulation = Simulation(model, Î”t=0.2, stop_time=50)","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Simulation of NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ Next time step: 200 ms\nâ”œâ”€â”€ Elapsed wall time: 0 seconds\nâ”œâ”€â”€ Wall time per iteration: NaN days\nâ”œâ”€â”€ Stop time: 50 seconds\nâ”œâ”€â”€ Stop iteration: Inf\nâ”œâ”€â”€ Wall time limit: Inf\nâ”œâ”€â”€ Minimum relative step: 0.0\nâ”œâ”€â”€ Callbacks: OrderedDict with 4 entries:\nâ”‚   â”œâ”€â”€ stop_time_exceeded => 4\nâ”‚   â”œâ”€â”€ stop_iteration_exceeded => -\nâ”‚   â”œâ”€â”€ wall_time_limit_exceeded => e\nâ”‚   â””â”€â”€ nan_checker => }\nâ”œâ”€â”€ Output writers: OrderedDict with no entries\nâ””â”€â”€ Diagnostics: OrderedDict with no entries","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"The TimeStepWizard helps ensure stable time-stepping with a Courant-Freidrichs-Lewy (CFL) number of 0.7.","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"wizard = TimeStepWizard(cfl=0.7, max_change=1.1, max_Î”t=0.5)\nsimulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10))","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Callback of TimeStepWizard(cfl=0.7, max_Î”t=0.5, min_Î”t=0.0) on IterationInterval(10)","category":"page"},{"location":"literated/two_dimensional_turbulence/#Logging-simulation-progress","page":"Two-dimensional turbulence","title":"Logging simulation progress","text":"","category":"section"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"We set up a callback that logs the simulation iteration and time every 100 iterations.","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"using Printf\n\nfunction progress_message(sim)\n    max_abs_u = maximum(abs, sim.model.velocities.u)\n    walltime = prettytime(sim.run_wall_time)\n\n    return @info @sprintf(\"Iteration: %04d, time: %1.3f, Î”t: %.2e, max(|u|) = %.1e, wall time: %s\\n\",\n                          iteration(sim), time(sim), sim.Î”t, max_abs_u, walltime)\nend\n\nadd_callback!(simulation, progress_message, IterationInterval(100))","category":"page"},{"location":"literated/two_dimensional_turbulence/#Output","page":"Two-dimensional turbulence","title":"Output","text":"","category":"section"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"We set up an output writer for the simulation that saves vorticity and speed every 20 iterations.","category":"page"},{"location":"literated/two_dimensional_turbulence/#Computing-vorticity-and-speed","page":"Two-dimensional turbulence","title":"Computing vorticity and speed","text":"","category":"section"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"To make our equations prettier, we unpack u, v, and w from the NamedTuple model.velocities:","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"u, v, w = model.velocities","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"NamedTuple with 3 Fields on 128Ã—128Ã—1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3Ã—3Ã—0 halo:\nâ”œâ”€â”€ u: 128Ã—128Ã—1 Field{Face, Center, Center} on RectilinearGrid on CPU\nâ”œâ”€â”€ v: 128Ã—128Ã—1 Field{Center, Face, Center} on RectilinearGrid on CPU\nâ””â”€â”€ w: 128Ã—128Ã—1 Field{Center, Center, Face} on RectilinearGrid on CPU","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Next we create two Fields that calculate (i) vorticity that measures the rate at which the fluid rotates and is defined as","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Ï‰ = _x v - _y u  ","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Ï‰ = âˆ‚x(v) - âˆ‚y(u)","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"BinaryOperation at (Face, Face, Center)\nâ”œâ”€â”€ grid: 128Ã—128Ã—1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3Ã—3Ã—0 halo\nâ””â”€â”€ tree: \n    - at (Face, Face, Center)\n Â Â  â”œâ”€â”€ âˆ‚xá¶ á¶ á¶œ at (Face, Face, Center) via identity\n Â Â  â”‚Â Â  â””â”€â”€ 128Ã—128Ã—1 Field{Center, Face, Center} on RectilinearGrid on CPU\n Â Â  â””â”€â”€ âˆ‚yá¶ á¶ á¶œ at (Face, Face, Center) via identity\n Â Â   Â Â  â””â”€â”€ 128Ã—128Ã—1 Field{Face, Center, Center} on RectilinearGrid on CPU","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"We also calculate (ii) the speed of the flow,","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"s = sqrtu^2 + v^2  ","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"s = sqrt(u^2 + v^2)","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"UnaryOperation at (Face, Center, Center)\nâ”œâ”€â”€ grid: 128Ã—128Ã—1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3Ã—3Ã—0 halo\nâ””â”€â”€ tree: \n    sqrt at (Face, Center, Center) via identity\n Â Â  â””â”€â”€ + at (Face, Center, Center)\n Â Â   Â Â  â”œâ”€â”€ ^ at (Face, Center, Center)\n Â Â   Â Â  â”‚Â Â  â”œâ”€â”€ 128Ã—128Ã—1 Field{Face, Center, Center} on RectilinearGrid on CPU\n Â Â   Â Â  â”‚Â Â  â””â”€â”€ 2\n Â Â   Â Â  â””â”€â”€ ^ at (Center, Face, Center)\n Â Â   Â Â   Â Â  â”œâ”€â”€ 128Ã—128Ã—1 Field{Center, Face, Center} on RectilinearGrid on CPU\n Â Â   Â Â   Â Â  â””â”€â”€ 2","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"We pass these operations to an output writer below to calculate and output them during the simulation.","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"filename = \"two_dimensional_turbulence\"\n\nsimulation.output_writers[:fields] = JLD2Writer(model, (; Ï‰, s),\n                                                schedule = TimeInterval(0.6),\n                                                filename = filename * \".jld2\",\n                                                overwrite_existing = true)","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"JLD2Writer scheduled on TimeInterval(600 ms):\nâ”œâ”€â”€ filepath: two_dimensional_turbulence.jld2\nâ”œâ”€â”€ 2 outputs: (Ï‰, s)\nâ”œâ”€â”€ array_type: Array{Float32}\nâ”œâ”€â”€ including: [:grid, :coriolis, :buoyancy, :closure]\nâ”œâ”€â”€ file_splitting: NoFileSplitting\nâ””â”€â”€ file size: 29.3 KiB","category":"page"},{"location":"literated/two_dimensional_turbulence/#Running-the-simulation","page":"Two-dimensional turbulence","title":"Running the simulation","text":"","category":"section"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Pretty much just","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"run!(simulation)","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"[ Info: Initializing simulation...\n[ Info: Iteration: 0000, time: 0.000, Î”t: 1.00e-01, max(|u|) = 7.1e-01, wall time: 0 seconds\n[ Info:     ... simulation initialization complete (5.687 seconds)\n[ Info: Executing initial time step...\n[ Info:     ... initial time step complete (3.287 seconds).\n[ Info: Iteration: 0100, time: 6.822, Î”t: 7.06e-02, max(|u|) = 3.2e-01, wall time: 9.837 seconds\n[ Info: Iteration: 0200, time: 13.596, Î”t: 8.67e-02, max(|u|) = 3.2e-01, wall time: 10.359 seconds\n[ Info: Iteration: 0300, time: 20.791, Î”t: 7.59e-02, max(|u|) = 2.7e-01, wall time: 10.874 seconds\n[ Info: Iteration: 0400, time: 28.630, Î”t: 8.65e-02, max(|u|) = 2.4e-01, wall time: 11.433 seconds\n[ Info: Iteration: 0500, time: 36.691, Î”t: 9.59e-02, max(|u|) = 2.4e-01, wall time: 11.918 seconds\n[ Info: Iteration: 0600, time: 44.768, Î”t: 9.25e-02, max(|u|) = 2.6e-01, wall time: 12.429 seconds\n[ Info: Simulation is stopping after running for 12.746 seconds.\n[ Info: Simulation time 50 seconds equals or exceeds stop time 50 seconds.\n","category":"page"},{"location":"literated/two_dimensional_turbulence/#Visualizing-the-results","page":"Two-dimensional turbulence","title":"Visualizing the results","text":"","category":"section"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"We load the output.","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Ï‰_timeseries = FieldTimeSeries(filename * \".jld2\", \"Ï‰\")\ns_timeseries = FieldTimeSeries(filename * \".jld2\", \"s\")\n\ntimes = Ï‰_timeseries.times","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"and animate the vorticity and fluid speed.","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"using CairoMakie\nset_theme!(Theme(fontsize = 20))\n\nfig = Figure(size = (800, 500))\n\naxis_kwargs = (xlabel = \"x\",\n               ylabel = \"y\",\n               limits = ((0, 2Ï€), (0, 2Ï€)),\n               aspect = AxisAspect(1))\n\nax_Ï‰ = Axis(fig[2, 1]; title = \"Vorticity\", axis_kwargs...)\nax_s = Axis(fig[2, 2]; title = \"Speed\", axis_kwargs...)","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"We use Makie's Observable to animate the data. To dive into how Observables work we refer to Makie.jl's Documentation.","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"n = Observable(1)","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Observable(1)\n","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Now let's plot the vorticity and speed.","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Ï‰ = @lift Ï‰_timeseries[$n]\ns = @lift s_timeseries[$n]\n\nheatmap!(ax_Ï‰, Ï‰; colormap = :balance, colorrange = (-2, 2))\nheatmap!(ax_s, s; colormap = :speed, colorrange = (0, 0.2))\n\ntitle = @lift \"t = \" * string(round(times[$n], digits=2))\nLabel(fig[1, 1:2], title, fontsize=24, tellwidth=false)\n\nfig","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"(Image: )","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Finally, we record a movie.","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"frames = 1:length(times)\n\n@info \"Making a neat animation of vorticity and speed...\"\n\nrecord(fig, filename * \".mp4\", frames, framerate=24) do i\n    n[] = i\nend","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"[ Info: Making a neat animation of vorticity and speed...\n","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"(Image: )","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"This page was generated using Literate.jl.","category":"page"},{"location":"physics/boundary_conditions/#Boundary-conditions","page":"Boundary conditions","title":"Boundary conditions","text":"","category":"section"},{"location":"physics/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Users may impose no-penetration, flux, gradient (Neumann), and value (Dirichlet) boundary conditions in bounded, non-periodic directions. Note that the only boundary condition available for a velocity field normal to the bounded direction is no-penetration.","category":"page"},{"location":"physics/boundary_conditions/#Flux-boundary-conditions","page":"Boundary conditions","title":"Flux boundary conditions","text":"","category":"section"},{"location":"physics/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"A flux boundary condition prescribes flux of a quantity normal to the boundary.   For a tracer c this corresponds to prescribing","category":"page"},{"location":"physics/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"q_c  _b equiv boldsymbolq_c boldsymbolcdot hatboldsymboln  _partial Omega_b  ","category":"page"},{"location":"physics/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"where partial Omega_b is an external boundary.","category":"page"},{"location":"physics/boundary_conditions/#Gradient-(Neumann)-boundary-condition","page":"Boundary conditions","title":"Gradient (Neumann) boundary condition","text":"","category":"section"},{"location":"physics/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"A gradient boundary condition prescribes the gradient of a field normal to the boundary. For a tracer c this prescribes","category":"page"},{"location":"physics/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"gamma equiv boldsymbolnabla c boldsymbolcdot hatboldsymboln  _partial Omega_b  ","category":"page"},{"location":"physics/boundary_conditions/#Value-(Dirichlet)-boundary-condition","page":"Boundary conditions","title":"Value (Dirichlet) boundary condition","text":"","category":"section"},{"location":"physics/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"A value boundary condition prescribes the value of a field on a boundary; for a tracer this prescribes","category":"page"},{"location":"physics/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"c_b equiv c  _partial Omega_b  ","category":"page"},{"location":"physics/boundary_conditions/#No-penetration-boundary-condition","page":"Boundary conditions","title":"No penetration boundary condition","text":"","category":"section"},{"location":"physics/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"A no penetration boundary condition prescribes the velocity component normal to a boundary to be 0, so that","category":"page"},{"location":"physics/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"boldsymbolhatn boldsymbolcdot boldsymbolv  _partial Omega_b = 0  ","category":"page"},{"location":"appendix/fractional_step/#fractional_step_method","page":"Fractional step method","title":"Fractional step method","text":"","category":"section"},{"location":"appendix/fractional_step/","page":"Fractional step method","title":"Fractional step method","text":"In some models (e.g., NonhydrostaticModel or HydrostaticFreeSurfaceModel) solving the momentum coupled with the continuity equation can be cumbersome so instead we employ a fractional step method. To approximate the solution of the coupled system we first solve an approximation to the discretized momentum equation for an intermediate velocity field boldsymbolv^star without worrying about satisfying the incompressibility constraint. We then project boldsymbolv^star onto the space of divergence-free velocity fields to obtain a value for boldsymbolv^n+1 that satisfies continuity.","category":"page"},{"location":"appendix/fractional_step/","page":"Fractional step method","title":"Fractional step method","text":"For example, for the NonhydrostaticModel, if we ignore the background velocity fields and the surface waves, we thus discretize the momentum equation as","category":"page"},{"location":"appendix/fractional_step/","page":"Fractional step method","title":"Fractional step method","text":"  fracboldsymbolv^star - boldsymbolv^nDelta t\n    = - left boldsymbolv boldsymbolcdot boldsymbolnabla boldsymbolv right^n+frac12\n      - boldsymbolf times boldsymbolv^n+frac12\n      + boldsymbolnabla boldsymbolcdot left ( nu boldsymbolnabla boldsymbolv^n+frac12 right )\n      + boldsymbolF_boldsymbolv^n+frac12  ","category":"page"},{"location":"appendix/fractional_step/","page":"Fractional step method","title":"Fractional step method","text":"where the superscript n + frac12 indicates that these terms are evaluated at time step n + frac12, which we compute explicitly (see Time-stepping section).","category":"page"},{"location":"appendix/fractional_step/","page":"Fractional step method","title":"Fractional step method","text":"The projection is then performed","category":"page"},{"location":"appendix/fractional_step/","page":"Fractional step method","title":"Fractional step method","text":"   boldsymbolv^n+1 = boldsymbolv^star - Delta t  boldsymbolnabla p^n+1  ","category":"page"},{"location":"appendix/fractional_step/","page":"Fractional step method","title":"Fractional step method","text":"to obtain a divergence-free velocity field boldsymbolv^n+1. Here the projection is performed by solving an elliptic problem for the pressure p^n+1 with the boundary condition","category":"page"},{"location":"appendix/fractional_step/","page":"Fractional step method","title":"Fractional step method","text":"  boldsymbolhatn boldsymbolcdot boldsymbolnabla p^n+1 _partialOmega = 0  ","category":"page"},{"location":"appendix/fractional_step/","page":"Fractional step method","title":"Fractional step method","text":"Orszag et al. (1986) and Brown et al. (2001) raise an important issue regarding these fractional step methods, which is that \"while the velocity can be reliably computed to second-order accuracy in time and space, the pressure is typically only first-order accurate in the L_infty-norm.\" The numerical boundary conditions must be carefully accounted for to ensure the second-order accuracy promised by the fractional step methods.","category":"page"},{"location":"literated/baroclinic_adjustment/#Baroclinic-adjustment","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"","category":"section"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"In this example, we simulate the evolution and equilibration of a baroclinically unstable front.","category":"page"},{"location":"literated/baroclinic_adjustment/#Install-dependencies","page":"Baroclinic adjustment","title":"Install dependencies","text":"","category":"section"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"using Pkg\npkg\"add Oceananigans, CairoMakie\"","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"using Oceananigans\nusing Oceananigans.Units","category":"page"},{"location":"literated/baroclinic_adjustment/#Grid","page":"Baroclinic adjustment","title":"Grid","text":"","category":"section"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"We use a three-dimensional channel that is periodic in the x direction:","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"Lx = 1000kilometers # east-west extent [m]\nLy = 1000kilometers # north-south extent [m]\nLz = 1kilometers    # depth [m]\n\ngrid = RectilinearGrid(size = (48, 48, 8),\n                       x = (0, Lx),\n                       y = (-Ly/2, Ly/2),\n                       z = (-Lz, 0),\n                       topology = (Periodic, Bounded, Bounded))","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"48Ã—48Ã—8 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ Periodic x âˆˆ [0.0, 1.0e6)          regularly spaced with Î”x=20833.3\nâ”œâ”€â”€ Bounded  y âˆˆ [-500000.0, 500000.0] regularly spaced with Î”y=20833.3\nâ””â”€â”€ Bounded  z âˆˆ [-1000.0, 0.0]        regularly spaced with Î”z=125.0","category":"page"},{"location":"literated/baroclinic_adjustment/#Model","page":"Baroclinic adjustment","title":"Model","text":"","category":"section"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"We built a HydrostaticFreeSurfaceModel with an ImplicitFreeSurface solver. Regarding Coriolis, we use a beta-plane centered at 45Â° South.","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"model = HydrostaticFreeSurfaceModel(; grid,\n                                    coriolis = BetaPlane(latitude = -45),\n                                    buoyancy = BuoyancyTracer(),\n                                    tracers = :b,\n                                    momentum_advection = WENO(),\n                                    tracer_advection = WENO())","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"HydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 48Ã—48Ã—8 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ timestepper: QuasiAdamsBashforth2TimeStepper\nâ”œâ”€â”€ tracers: b\nâ”œâ”€â”€ closure: Nothing\nâ”œâ”€â”€ buoyancy: BuoyancyTracer with gÌ‚ = NegativeZDirection()\nâ”œâ”€â”€ free surface: ImplicitFreeSurface with gravitational acceleration 9.80665 m sâ»Â²\nâ”‚   â””â”€â”€ solver: FFTImplicitFreeSurfaceSolver\nâ”œâ”€â”€ advection scheme: \nâ”‚   â”œâ”€â”€ momentum: WENO{3, Float64, Float32}(order=5)\nâ”‚   â””â”€â”€ b: WENO{3, Float64, Float32}(order=5)\nâ”œâ”€â”€ vertical_coordinate: ZCoordinate\nâ””â”€â”€ coriolis: BetaPlane{Float64}","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"We start our simulation from rest with a baroclinically unstable buoyancy distribution. We use ramp(y, Î”y), defined below, to specify a front with width Î”y and horizontal buoyancy gradient MÂ². We impose the front on top of a vertical buoyancy gradient NÂ² and a bit of noise.","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"\"\"\"\n    ramp(y, Î”y)\n\nLinear ramp from 0 to 1 between -Î”y/2 and +Î”y/2.\n\nFor example:\n```\n            y < -Î”y/2 => ramp = 0\n    -Î”y/2 < y < -Î”y/2 => ramp = y / Î”y\n            y >  Î”y/2 => ramp = 1\n```\n\"\"\"\nramp(y, Î”y) = min(max(0, y/Î”y + 1/2), 1)\n\nNÂ² = 1e-5 # [sâ»Â²] buoyancy frequency / stratification\nMÂ² = 1e-7 # [sâ»Â²] horizontal buoyancy gradient\n\nÎ”y = 100kilometers # width of the region of the front\nÎ”b = Î”y * MÂ²       # buoyancy jump associated with the front\nÏµb = 1e-2 * Î”b     # noise amplitude\n\nbáµ¢(x, y, z) = NÂ² * z + Î”b * ramp(y, Î”y) + Ïµb * randn()\n\nset!(model, b=báµ¢)","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"Let's visualize the initial buoyancy distribution.","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"using CairoMakie\nset_theme!(Theme(fontsize = 20))\n\n# Build coordinates with units of kilometers\nx, y, z = 1e-3 .* nodes(grid, (Center(), Center(), Center()))\n\nb = model.tracers.b\n\nfig, ax, hm = heatmap(view(b, 1, :, :),\n                      colormap = :deep,\n                      axis = (xlabel = \"y [km]\",\n                              ylabel = \"z [km]\",\n                              title = \"b(x=0, y, z, t=0)\",\n                              titlesize = 24))\n\nColorbar(fig[1, 2], hm, label = \"[m sâ»Â²]\")\n\nfig","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"(Image: )","category":"page"},{"location":"literated/baroclinic_adjustment/#Simulation","page":"Baroclinic adjustment","title":"Simulation","text":"","category":"section"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"Now let's build a Simulation.","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"simulation = Simulation(model, Î”t=20minutes, stop_time=20days)","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"Simulation of HydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ Next time step: 20 minutes\nâ”œâ”€â”€ Elapsed wall time: 0 seconds\nâ”œâ”€â”€ Wall time per iteration: NaN days\nâ”œâ”€â”€ Stop time: 20 days\nâ”œâ”€â”€ Stop iteration: Inf\nâ”œâ”€â”€ Wall time limit: Inf\nâ”œâ”€â”€ Minimum relative step: 0.0\nâ”œâ”€â”€ Callbacks: OrderedDict with 4 entries:\nâ”‚   â”œâ”€â”€ stop_time_exceeded => 4\nâ”‚   â”œâ”€â”€ stop_iteration_exceeded => -\nâ”‚   â”œâ”€â”€ wall_time_limit_exceeded => e\nâ”‚   â””â”€â”€ nan_checker => }\nâ”œâ”€â”€ Output writers: OrderedDict with no entries\nâ””â”€â”€ Diagnostics: OrderedDict with no entries","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"We add a TimeStepWizard callback to adapt the simulation's time-step,","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"conjure_time_step_wizard!(simulation, IterationInterval(20), cfl=0.2, max_Î”t=20minutes)","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"Also, we add a callback to print a message about how the simulation is going,","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"using Printf\n\nwall_clock = Ref(time_ns())\n\nfunction print_progress(sim)\n    u, v, w = model.velocities\n    progress = 100 * (time(sim) / sim.stop_time)\n    elapsed = (time_ns() - wall_clock[]) / 1e9\n\n    @printf(\"[%05.2f%%] i: %d, t: %s, wall time: %s, max(u): (%6.3e, %6.3e, %6.3e) m/s, next Î”t: %s\\n\",\n            progress, iteration(sim), prettytime(sim), prettytime(elapsed),\n            maximum(abs, u), maximum(abs, v), maximum(abs, w), prettytime(sim.Î”t))\n\n    wall_clock[] = time_ns()\n\n    return nothing\nend\n\nadd_callback!(simulation, print_progress, IterationInterval(100))","category":"page"},{"location":"literated/baroclinic_adjustment/#Diagnostics/Output","page":"Baroclinic adjustment","title":"Diagnostics/Output","text":"","category":"section"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"Here, we save the buoyancy, b, at the edges of our domain as well as the zonal (x) average of buoyancy.","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"u, v, w = model.velocities\nÎ¶ = âˆ‚x(v) - âˆ‚y(u)\nB = Average(b, dims=1)\nU = Average(u, dims=1)\nV = Average(v, dims=1)\n\nfilename = \"baroclinic_adjustment\"\nsave_fields_interval = 0.5day\n\nslicers = (east = (grid.Nx, :, :),\n           north = (:, grid.Ny, :),\n           bottom = (:, :, 1),\n           top = (:, :, grid.Nz))\n\nfor side in keys(slicers)\n    indices = slicers[side]\n\n    simulation.output_writers[side] = JLD2Writer(model, (; b, Î¶);\n                                                 filename = filename * \"_$(side)_slice\",\n                                                 schedule = TimeInterval(save_fields_interval),\n                                                 overwrite_existing = true,\n                                                 indices)\nend\n\nsimulation.output_writers[:zonal] = JLD2Writer(model, (; b=B, u=U, v=V);\n                                               filename = filename * \"_zonal_average\",\n                                               schedule = TimeInterval(save_fields_interval),\n                                               overwrite_existing = true)","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"JLD2Writer scheduled on TimeInterval(12 hours):\nâ”œâ”€â”€ filepath: baroclinic_adjustment_zonal_average.jld2\nâ”œâ”€â”€ 3 outputs: (b, u, v)\nâ”œâ”€â”€ array_type: Array{Float32}\nâ”œâ”€â”€ including: [:grid, :coriolis, :buoyancy, :closure]\nâ”œâ”€â”€ file_splitting: NoFileSplitting\nâ””â”€â”€ file size: 32.5 KiB","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"Now we're ready to run.","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"@info \"Running the simulation...\"\n\nrun!(simulation)\n\n@info \"Simulation completed in \" * prettytime(simulation.run_wall_time)","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"[ Info: Running the simulation...\n[ Info: Initializing simulation...\n[00.00%] i: 0, t: 0 seconds, wall time: 20.430 seconds, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Î”t: 20 minutes\n[ Info:     ... simulation initialization complete (14.376 seconds)\n[ Info: Executing initial time step...\n[ Info:     ... initial time step complete (9.291 seconds).\n[06.94%] i: 100, t: 1.389 days, wall time: 20.462 seconds, max(u): (1.284e-01, 1.227e-01, 1.563e-03) m/s, next Î”t: 20 minutes\n[13.89%] i: 200, t: 2.778 days, wall time: 1.851 seconds, max(u): (2.155e-01, 1.674e-01, 1.764e-03) m/s, next Î”t: 20 minutes\n[20.83%] i: 300, t: 4.167 days, wall time: 2.244 seconds, max(u): (2.813e-01, 2.280e-01, 1.809e-03) m/s, next Î”t: 20 minutes\n[27.78%] i: 400, t: 5.556 days, wall time: 1.970 seconds, max(u): (3.593e-01, 3.025e-01, 1.842e-03) m/s, next Î”t: 20 minutes\n[34.72%] i: 500, t: 6.944 days, wall time: 1.907 seconds, max(u): (4.373e-01, 4.624e-01, 1.951e-03) m/s, next Î”t: 20 minutes\n[41.67%] i: 600, t: 8.333 days, wall time: 1.923 seconds, max(u): (5.818e-01, 7.891e-01, 2.814e-03) m/s, next Î”t: 20 minutes\n[48.61%] i: 700, t: 9.722 days, wall time: 1.998 seconds, max(u): (8.124e-01, 1.235e+00, 3.451e-03) m/s, next Î”t: 20 minutes\n[55.56%] i: 800, t: 11.111 days, wall time: 1.997 seconds, max(u): (1.222e+00, 1.180e+00, 4.798e-03) m/s, next Î”t: 20 minutes\n[62.50%] i: 900, t: 12.500 days, wall time: 2.146 seconds, max(u): (1.312e+00, 1.229e+00, 5.190e-03) m/s, next Î”t: 20 minutes\n[69.44%] i: 1000, t: 13.889 days, wall time: 2.205 seconds, max(u): (1.333e+00, 1.121e+00, 5.026e-03) m/s, next Î”t: 20 minutes\n[76.39%] i: 1100, t: 15.278 days, wall time: 2.240 seconds, max(u): (1.326e+00, 1.144e+00, 4.886e-03) m/s, next Î”t: 20 minutes\n[83.33%] i: 1200, t: 16.667 days, wall time: 2.255 seconds, max(u): (1.223e+00, 1.245e+00, 3.073e-03) m/s, next Î”t: 20 minutes\n[90.28%] i: 1300, t: 18.056 days, wall time: 2.265 seconds, max(u): (1.304e+00, 1.091e+00, 3.441e-03) m/s, next Î”t: 20 minutes\n[97.22%] i: 1400, t: 19.444 days, wall time: 2.283 seconds, max(u): (1.439e+00, 1.228e+00, 3.533e-03) m/s, next Î”t: 20 minutes\n[ Info: Simulation is stopping after running for 56.031 seconds.\n[ Info: Simulation time 20 days equals or exceeds stop time 20 days.\n[ Info: Simulation completed in 56.050 seconds\n","category":"page"},{"location":"literated/baroclinic_adjustment/#Visualization","page":"Baroclinic adjustment","title":"Visualization","text":"","category":"section"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"All that's left is to make a pretty movie. Actually, we make two visualizations here. First, we illustrate how to make a 3D visualization with Makie's Axis3 and Makie.surface. Then we make a movie in 2D. We use CairoMakie in this example, but note that using GLMakie is more convenient on a system with OpenGL, as figures will be displayed on the screen.","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"using CairoMakie","category":"page"},{"location":"literated/baroclinic_adjustment/#Three-dimensional-visualization","page":"Baroclinic adjustment","title":"Three-dimensional visualization","text":"","category":"section"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"We load the saved buoyancy output on the top, north, and east surface as FieldTimeSerieses.","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"filename = \"baroclinic_adjustment\"\n\nsides = keys(slicers)\n\nslice_filenames = NamedTuple(side => filename * \"_$(side)_slice.jld2\" for side in sides)\n\nb_timeserieses = (east   = FieldTimeSeries(slice_filenames.east, \"b\"),\n                  north  = FieldTimeSeries(slice_filenames.north, \"b\"),\n                  top    = FieldTimeSeries(slice_filenames.top, \"b\"))\n\nB_timeseries = FieldTimeSeries(filename * \"_zonal_average.jld2\", \"b\")\n\ntimes = B_timeseries.times\ngrid = B_timeseries.grid","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"48Ã—48Ã—8 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ Periodic x âˆˆ [0.0, 1.0e6)          regularly spaced with Î”x=20833.3\nâ”œâ”€â”€ Bounded  y âˆˆ [-500000.0, 500000.0] regularly spaced with Î”y=20833.3\nâ””â”€â”€ Bounded  z âˆˆ [-1000.0, 0.0]        regularly spaced with Î”z=125.0","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"We build the coordinates. We rescale horizontal coordinates to kilometers.","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"xb, yb, zb = nodes(b_timeserieses.east)\n\nxb = xb ./ 1e3 # convert m -> km\nyb = yb ./ 1e3 # convert m -> km\n\nNx, Ny, Nz = size(grid)\n\nx_xz = repeat(x, 1, Nz)\ny_xz_north = y[end] * ones(Nx, Nz)\nz_xz = repeat(reshape(z, 1, Nz), Nx, 1)\n\nx_yz_east = x[end] * ones(Ny, Nz)\ny_yz = repeat(y, 1, Nz)\nz_yz = repeat(reshape(z, 1, Nz), grid.Ny, 1)\n\nx_xy = x\ny_xy = y\nz_xy_top = z[end] * ones(grid.Nx, grid.Ny)","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"Then we create a 3D axis. We use zonal_slice_displacement to control where the plot of the instantaneous zonal average flow is located.","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"fig = Figure(size = (1600, 800))\n\nzonal_slice_displacement = 1.2\n\nax = Axis3(fig[2, 1],\n           aspect=(1, 1, 1/5),\n           xlabel = \"x (km)\",\n           ylabel = \"y (km)\",\n           zlabel = \"z (m)\",\n           xlabeloffset = 100,\n           ylabeloffset = 100,\n           zlabeloffset = 100,\n           limits = ((x[1], zonal_slice_displacement * x[end]), (y[1], y[end]), (z[1], z[end])),\n           elevation = 0.45,\n           azimuth = 6.8,\n           xspinesvisible = false,\n           zgridvisible = false,\n           protrusions = 40,\n           perspectiveness = 0.7)","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"Axis3()","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"We use data from the final savepoint for the 3D plot. Note that this plot can easily be animated by using Makie's Observable. To dive into Observables, check out Makie.jl's Documentation.","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"n = length(times)","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"41","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"Now let's make a 3D plot of the buoyancy and in front of it we'll use the zonally-averaged output to plot the instantaneous zonal-average of the buoyancy.","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"b_slices = (east   = interior(b_timeserieses.east[n], 1, :, :),\n            north  = interior(b_timeserieses.north[n], :, 1, :),\n            top    = interior(b_timeserieses.top[n], :, :, 1))\n\n# Zonally-averaged buoyancy\nB = interior(B_timeseries[n], 1, :, :)\n\nclims = 1.1 .* extrema(b_timeserieses.top[n][:])\n\nkwargs = (colorrange=clims, colormap=:deep, shading=NoShading)\n\nsurface!(ax, x_yz_east, y_yz, z_yz;  color = b_slices.east, kwargs...)\nsurface!(ax, x_xz, y_xz_north, z_xz; color = b_slices.north, kwargs...)\nsurface!(ax, x_xy, y_xy, z_xy_top;   color = b_slices.top, kwargs...)\n\nsf = surface!(ax, zonal_slice_displacement .* x_yz_east, y_yz, z_yz; color = B, kwargs...)\n\ncontour!(ax, y, z, B; transformation = (:yz, zonal_slice_displacement * x[end]),\n         levels = 15, linewidth = 2, color = :black)\n\nColorbar(fig[2, 2], sf, label = \"m sâ»Â²\", height = Relative(0.4), tellheight=false)\n\ntitle = \"Buoyancy at t = \" * string(round(times[n] / day, digits=1)) * \" days\"\nfig[1, 1:2] = Label(fig, title; fontsize = 24, tellwidth = false, padding = (0, 0, -120, 0))\n\nrowgap!(fig.layout, 1, Relative(-0.2))\ncolgap!(fig.layout, 1, Relative(-0.1))\n\nsave(\"baroclinic_adjustment_3d.png\", fig)","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"(Image: )","category":"page"},{"location":"literated/baroclinic_adjustment/#Two-dimensional-movie","page":"Baroclinic adjustment","title":"Two-dimensional movie","text":"","category":"section"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"We make a 2D movie that shows buoyancy b and vertical vorticity Î¶ at the surface, as well as the zonally-averaged zonal and meridional velocities U and V in the (y z) plane. First we load the FieldTimeSeries and extract the additional coordinates we'll need for plotting","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"Î¶_timeseries = FieldTimeSeries(slice_filenames.top, \"Î¶\")\nU_timeseries = FieldTimeSeries(filename * \"_zonal_average.jld2\", \"u\")\nB_timeseries = FieldTimeSeries(filename * \"_zonal_average.jld2\", \"b\")\nV_timeseries = FieldTimeSeries(filename * \"_zonal_average.jld2\", \"v\")\n\nxÎ¶, yÎ¶, zÎ¶ = nodes(Î¶_timeseries)\nyv = ynodes(V_timeseries)\n\nxÎ¶ = xÎ¶ ./ 1e3 # convert m -> km\nyÎ¶ = yÎ¶ ./ 1e3 # convert m -> km\nyv = yv ./ 1e3 # convert m -> km","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"-500.0:20.833333333333332:500.0","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"Next, we set up a plot with 4 panels. The top panels are large and square, while the bottom panels get a reduced aspect ratio through rowsize!.","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"fig = Figure(size=(1800, 1000))\n\naxb = Axis(fig[1, 2], xlabel=\"x (km)\", ylabel=\"y (km)\", aspect=1)\naxÎ¶ = Axis(fig[1, 3], xlabel=\"x (km)\", ylabel=\"y (km)\", aspect=1, yaxisposition=:right)\n\naxu = Axis(fig[2, 2], xlabel=\"y (km)\", ylabel=\"z (m)\")\naxv = Axis(fig[2, 3], xlabel=\"y (km)\", ylabel=\"z (m)\", yaxisposition=:right)\n\nrowsize!(fig.layout, 2, Relative(0.3))","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"To prepare a plot for animation, we index the timeseries with an Observable,","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"n = Observable(1)\n\nb_top = @lift interior(b_timeserieses.top[$n], :, :, 1)\nÎ¶_top = @lift interior(Î¶_timeseries[$n], :, :, 1)\nU = @lift interior(U_timeseries[$n], 1, :, :)\nV = @lift interior(V_timeseries[$n], 1, :, :)\nB = @lift interior(B_timeseries[$n], 1, :, :)","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"Observable([-0.009359532035887241 -0.008101513609290123 -0.006863062269985676 -0.00561874732375145 -0.004381408914923668 -0.0031316138338297606 -0.001891045249067247 -0.0006315717473626137; -0.00939029548317194 -0.008123303763568401 -0.006869222037494183 -0.00562577648088336 -0.004358251113444567 -0.00313223316334188 -0.001874998095445335 -0.00064238061895594; -0.009372878819704056 -0.008128659799695015 -0.006877056322991848 -0.0056500560604035854 -0.004379544407129288 -0.003121863817796111 -0.001886257086880505 -0.0006406665197573602; -0.009386779740452766 -0.00814926065504551 -0.006868869066238403 -0.005628490354865789 -0.004368131514638662 -0.0031174025498330593 -0.0018550818786025047 -0.0006141873309388757; -0.009398477151989937 -0.008104234002530575 -0.006877472624182701 -0.00562161672860384 -0.0044114915654063225 -0.0031414092518389225 -0.0018766727298498154 -0.0006285614217631519; -0.009380477480590343 -0.00813201442360878 -0.0068948292173445225 -0.005619887728244066 -0.004377733450382948 -0.0031223988626152277 -0.0018749033333733678 -0.0006256545311771333; -0.009344516322016716 -0.008134948089718819 -0.006878961343318224 -0.005620104726403952 -0.004355887416750193 -0.0031088150572031736 -0.0018993954872712493 -0.000636213575489819; -0.009376521222293377 -0.008137703873217106 -0.006876274477690458 -0.005627898965030909 -0.004359574057161808 -0.0031290831975638866 -0.0018759211525321007 -0.0006307516014203429; -0.009406140074133873 -0.008122733794152737 -0.00688971858471632 -0.005621298216283321 -0.004385485779494047 -0.003141903318464756 -0.0018932801904156804 -0.0006193392910063267; -0.009369262494146824 -0.00810937862843275 -0.006884425412863493 -0.005643214099109173 -0.004378374200314283 -0.0031342455185949802 -0.0018738068174570799 -0.0006117667653597891; -0.009395601227879524 -0.008109654299914837 -0.006880421191453934 -0.0056300899013876915 -0.004397653508931398 -0.0031099573243409395 -0.0018667463446035981 -0.000649328576400876; -0.009339183568954468 -0.008133879862725735 -0.006886505521833897 -0.005595856346189976 -0.0043735262006521225 -0.003130786120891571 -0.0018742148531600833 -0.0006024560425430536; -0.00936803873628378 -0.008140364661812782 -0.006887377239763737 -0.005634474102407694 -0.00437832111492753 -0.0031197897624224424 -0.0018988576484844089 -0.0006142727797850966; -0.00936865247786045 -0.008129401132464409 -0.006864346098154783 -0.005643409676849842 -0.004368585534393787 -0.0031313621439039707 -0.0018790604081004858 -0.0006361797568388283; -0.009369753301143646 -0.008123183622956276 -0.006849075201898813 -0.005603473633527756 -0.004402667284011841 -0.0031195031479001045 -0.0018606066005304456 -0.0006373743526637554; -0.009373041801154613 -0.00810928363353014 -0.0068895695731043816 -0.005627333652228117 -0.0043799616396427155 -0.0031324794981628656 -0.0018758100923150778 -0.000645565043669194; -0.00938807800412178 -0.008119145408272743 -0.006887809373438358 -0.005624744575470686 -0.004389675334095955 -0.00313111231662333 -0.0018936680862680078 -0.0006186607643030584; -0.009384317323565483 -0.008132114075124264 -0.006866136100143194 -0.00563832325860858 -0.004376459401100874 -0.0031129252165555954 -0.0019058339530602098 -0.0006224632961675525; -0.0093443738296628 -0.00810230802744627 -0.006889118812978268 -0.005621494725346565 -0.004383707419037819 -0.00311881466768682 -0.0018690561410039663 -0.0006185796810314059; -0.009383821859955788 -0.008133377879858017 -0.006890852935612202 -0.0056276749819517136 -0.004359766840934753 -0.00311725540086627 -0.0018670271383598447 -0.0006251370650716126; -0.009380771778523922 -0.008155223913490772 -0.0068942042998969555 -0.005623057018965483 -0.004366980399936438 -0.003135624108836055 -0.0018649293342605233 -0.0006185973179526627; -0.00936891045421362 -0.008132195100188255 -0.006874395534396172 -0.005616688169538975 -0.004385065287351608 -0.0031162153463810682 -0.0018769435118883848 -0.0006339780520647764; -0.007517942693084478 -0.0062324111349880695 -0.0049775708466768265 -0.0037558728363364935 -0.0024882310535758734 -0.0012594389263540506 -1.3198464330343995e-5 0.001265635946765542; -0.005428691394627094 -0.004157098941504955 -0.002928743604570627 -0.0016824575141072273 -0.0004106539417989552 0.0008261467446573079 0.0020888582803308964 0.003340734401717782; -0.0033301839139312506 -0.0020871483720839024 -0.0008549640187993646 0.0003832023066934198 0.001686501782387495 0.0029335126746445894 0.004134793765842915 0.005393906030803919; -0.0012390721822157502 1.3235008736955933e-5 0.001254584058187902 0.0024868538603186607 0.003745787311345339 0.005007773172110319 0.006235376466065645 0.007483731489628553; 0.0006208490231074393 0.0018817153759300709 0.0031262545380741358 0.004393790382891893 0.00561087392270565 0.006874429527670145 0.008131032809615135 0.00935783889144659; 0.0006471374654211104 0.0018698236672207713 0.0031159238424152136 0.004390180576592684 0.005647376179695129 0.006868797354400158 0.008136725053191185 0.009367212653160095; 0.000622146762907505 0.0018716638442128897 0.0030927779152989388 0.004377598874270916 0.005617094226181507 0.0068785762414336205 0.008119015023112297 0.009367387741804123; 0.0006494564586319029 0.0018703717505559325 0.00313582899980247 0.004380052909255028 0.005617443006485701 0.006906361319124699 0.008124662563204765 0.009363740682601929; 0.0006165403756313026 0.0018658570479601622 0.0031237194780260324 0.00436850730329752 0.00562477158382535 0.006882566958665848 0.008129943162202835 0.009377485141158104; 0.0006347098387777805 0.001865974860265851 0.003115585772320628 0.004360533785074949 0.005642404779791832 0.006882866844534874 0.008098552003502846 0.009375503286719322; 0.0006392209324985743 0.001898042974062264 0.0031276466324925423 0.004369329661130905 0.005638863425701857 0.006862959824502468 0.008121266961097717 0.009402132593095303; 0.000650014728307724 0.0018962286412715912 0.003115343861281872 0.004393198527395725 0.00564442528411746 0.006822181865572929 0.008123054169118404 0.00935195479542017; 0.0005987053737044334 0.001865170313976705 0.003117118263617158 0.004354181699454784 0.005604691803455353 0.0068665980361402035 0.008104125037789345 0.009362541139125824; 0.0006315899081528187 0.0018669620621949434 0.003128760727122426 0.004371308721601963 0.005642280913889408 0.006856830324977636 0.008108939975500107 0.009367277845740318; 0.0006367109599523246 0.001883984892629087 0.003117408137768507 0.004363596439361572 0.0056457226164639 0.006868309807032347 0.008141659200191498 0.009358122944831848; 0.0006317346706055105 0.0018299079965800047 0.003107598749920726 0.004343767650425434 0.00563536211848259 0.006887560710310936 0.00814279355108738 0.009390917606651783; 0.000616207136772573 0.0018536944407969713 0.003138139843940735 0.00437161372974515 0.0056198337115347385 0.006864386610686779 0.008122162893414497 0.00938320066779852; 0.0006215142202563584 0.0018745207926258445 0.0031269723549485207 0.004363144747912884 0.005632559768855572 0.0068894061259925365 0.008125483989715576 0.009395316243171692; 0.0006327720475383103 0.0018991627730429173 0.003113212063908577 0.004369068890810013 0.0056138476356863976 0.006854471750557423 0.00812370516359806 0.00938444584608078; 0.0006185932434163988 0.0018700746586546302 0.003124990500509739 0.004366231616586447 0.005625012796372175 0.0068899341858923435 0.00812065415084362 0.009375043213367462; 0.0006054224795661867 0.0018755728378891945 0.003126292722299695 0.004377155099064112 0.005632318090647459 0.00688549829646945 0.008104179054498672 0.00938663724809885; 0.0006340185645967722 0.0018777569057419896 0.003132587531581521 0.00438104011118412 0.005606234073638916 0.006871852558106184 0.008131005801260471 0.009372350759804249; 0.0006230343715287745 0.0018594141583889723 0.0031316434033215046 0.004414197523146868 0.005624419543892145 0.006879940163344145 0.008147452026605606 0.009340791031718254; 0.0006138967582955956 0.00185201910790056 0.00311297201551497 0.004415769595652819 0.005632753949612379 0.006863643880933523 0.00812464114278555 0.009409594349563122; 0.0006213949527591467 0.0018763614352792501 0.003141403431072831 0.00438103498890996 0.005617129150778055 0.006877362262457609 0.00812510959804058 0.009383869357407093; 0.0006639084313064814 0.0018821185221895576 0.0031332666985690594 0.0043749879114329815 0.005620921030640602 0.006883847527205944 0.008112814277410507 0.009372491389513016])\n","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"and then build our plot:","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"hm = heatmap!(axb, xb, yb, b_top, colorrange=(0, Î”b), colormap=:thermal)\nColorbar(fig[1, 1], hm, flipaxis=false, label=\"Surface b(x, y) (m sâ»Â²)\")\n\nhm = heatmap!(axÎ¶, xÎ¶, yÎ¶, Î¶_top, colorrange=(-5e-5, 5e-5), colormap=:balance)\nColorbar(fig[1, 4], hm, label=\"Surface Î¶(x, y) (sâ»Â¹)\")\n\nhm = heatmap!(axu, yb, zb, U; colorrange=(-5e-1, 5e-1), colormap=:balance)\nColorbar(fig[2, 1], hm, flipaxis=false, label=\"Zonally-averaged U(y, z) (m sâ»Â¹)\")\ncontour!(axu, yb, zb, B; levels=15, color=:black)\n\nhm = heatmap!(axv, yv, zb, V; colorrange=(-1e-1, 1e-1), colormap=:balance)\nColorbar(fig[2, 4], hm, label=\"Zonally-averaged V(y, z) (m sâ»Â¹)\")\ncontour!(axv, yb, zb, B; levels=15, color=:black)","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"Finally, we're ready to record the movie.","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"frames = 1:length(times)\n\nrecord(fig, filename * \".mp4\", frames, framerate=8) do i\n    n[] = i\nend","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"(Image: )","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"This page was generated using Literate.jl.","category":"page"},{"location":"operations/#Operations-and-averaging","page":"Operations","title":"Operations and averaging","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"Fields are more than mere vessels for data. They come equipped with a powerful infrastructure for assembling expression trees that represent arithmetic and discrete calculus operations. We also supply a system for computing reductions (averages, integrals, and cumulative integrals) of Fields. This infrastructure can be used to construct initial conditions, set up diagnostic calculations that are performed and saved to disk while a simulation runs, and also for post-processing.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"We start by constructing a CenterField on a simple grid,","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"using Oceananigans\n\ngrid = RectilinearGrid(topology = (Periodic, Flat, Bounded),\n                       size = (4, 4),\n                       x = (0, 2Ï€),\n                       z = (-4, 0))\n\nc = CenterField(grid)\n\nperiodic_but_decaying(x, z) = sin(x) * exp(z)\nset!(c, periodic_but_decaying)\n\n# output\n4Ã—1Ã—4 Field{Center, Center, Center} on RectilinearGrid on CPU\nâ”œâ”€â”€ grid: 4Ã—1Ã—4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo\nâ”œâ”€â”€ boundary conditions: FieldBoundaryConditions\nâ”‚   â””â”€â”€ west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: ZeroFlux, top: ZeroFlux, immersed: Nothing\nâ””â”€â”€ data: 10Ã—1Ã—10 OffsetArray(::Array{Float64, 3}, -2:7, 1:1, -2:7) with eltype Float64 with indices -2:7Ã—1:1Ã—-2:7\n    â””â”€â”€ max=0.428882, min=-0.428882, mean=1.04083e-17","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"An AbstractOperation (or operation for short) differs from a Field in that only represents a computation. Unlike Fields, AbstractOperations do not have any data, and are associated only with minimal memory allocation. AbstractOperations are generated by inflicting Fields with ordinary arithmetic expressions,","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"two_c = 2 * c\n\n# output\nBinaryOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 4Ã—1Ã—4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo\nâ””â”€â”€ tree:\n    * at (Center, Center, Center)\n Â Â  â”œâ”€â”€ 2\n Â Â  â””â”€â”€ 4Ã—1Ã—4 Field{Center, Center, Center} on RectilinearGrid on CPU","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"and even by chaining expressions together, which may themselves include AbstractOperations,","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"quadratic = c^2 + two_c + 1\n\n# output\nBinaryOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 4Ã—1Ã—4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo\nâ””â”€â”€ tree:\n    + at (Center, Center, Center)\n Â Â  â”œâ”€â”€ + at (Center, Center, Center)\n Â Â  â”‚Â Â  â”œâ”€â”€ ^ at (Center, Center, Center)\n Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 4Ã—1Ã—4 Field{Center, Center, Center} on RectilinearGrid on CPU\n Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 2\n Â Â  â”‚Â Â  â””â”€â”€ * at (Center, Center, Center)\n Â Â   Â Â  â”‚Â Â  â”œâ”€â”€ 2\n Â Â   Â Â  â”‚Â Â  â””â”€â”€ 4Ã—1Ã—4 Field{Center, Center, Center} on RectilinearGrid on CPU\n Â Â  â””â”€â”€ 1","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Like Fields, AbstractOperations have a location and a grid. In addition to BinaryOperations like the kind above, UnaryOperations and MultiaryOperations are also supported,","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"cos_c = cos(c)\n\n# output\nUnaryOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 4Ã—1Ã—4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo\nâ””â”€â”€ tree:\n    cos at (Center, Center, Center) via identity\n Â Â  â””â”€â”€ 4Ã—1Ã—4 Field{Center, Center, Center} on RectilinearGrid on CPU","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"four_c = c + c + c + c\n\n# output\nMultiaryOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 4Ã—1Ã—4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo\nâ””â”€â”€ tree:\n    + at (Center, Center, Center)\n Â Â  â”œâ”€â”€ 4Ã—1Ã—4 Field{Center, Center, Center} on RectilinearGrid on CPU\n Â Â  â”œâ”€â”€ 4Ã—1Ã—4 Field{Center, Center, Center} on RectilinearGrid on CPU\n Â Â  â”œâ”€â”€ 4Ã—1Ã—4 Field{Center, Center, Center} on RectilinearGrid on CPU\n Â Â  â””â”€â”€ 4Ã—1Ã—4 Field{Center, Center, Center} on RectilinearGrid on CPU","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"UnaryOperation, BinaryOperation and MultiaryOperation all have both an \"operator\", and between 1 and many. Last, and definitely not least, the fourth flavor of AbstractOperation represents a derivative,","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"dx_c = âˆ‚x(c)\n\n# output\nDerivative at (Face, Center, Center)\nâ”œâ”€â”€ grid: 4Ã—1Ã—4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo\nâ””â”€â”€ tree:\n    âˆ‚xá¶ á¶œá¶œ at (Face, Center, Center) via identity\n Â Â  â””â”€â”€ 4Ã—1Ã—4 Field{Center, Center, Center} on RectilinearGrid on CPU","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"note: Note\nThe x-derivative of c is computed by invoking the function âˆ‚xá¶ á¶œá¶œ, where the superscript á¶ á¶œá¶œ indicates that the result of this function is located at (Face, Center, Center). This convention is used throughout Oceananigans source code. A third superscripted letter áµƒ stands for \"any\" location and applies to operators that are location-agnostic in the given direction.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Like Fields, AbstractOperations are evaluated by indexing,","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"@show c[1, 1, 1]\n@show quadratic[1, 1, 1]\nnothing\n\n# output\nc[1, 1, 1] = 0.02135277459201165\nquadratic[1, 1, 1] = 1.0431614901668005","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Also like Fields, AbstractOperations have a location. For example,","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"using Oceananigans: location\n\n@show location(c)\n@show location(dx_c)\nnothing\n\n# output\nlocation(c) = (Center, Center, Center)\nlocation(dx_c) = (Face, Center, Center)","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Notice that the location of dx_c is shifted in x relative to c. Likewise, y-derivatives are shifted in y and z-derivatives are shifted in z.","category":"page"},{"location":"operations/#Locations-and-interpolation","page":"Operations","title":"Locations and interpolation","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"Reconstruction of Fields from one location to another is intrinsic to arithmetic on the staggered grid. Consider the magnitude of the gradient of c:","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"âˆ‡cÂ² = âˆ‚x(c)^2 + âˆ‚z(c)^2\n\n# output\nBinaryOperation at (Face, Center, Center)\nâ”œâ”€â”€ grid: 4Ã—1Ã—4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo\nâ””â”€â”€ tree:\n    + at (Face, Center, Center)\n Â Â  â”œâ”€â”€ ^ at (Face, Center, Center)\n Â Â  â”‚Â Â  â”œâ”€â”€ âˆ‚xá¶ á¶œá¶œ at (Face, Center, Center) via identity\n Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 4Ã—1Ã—4 Field{Center, Center, Center} on RectilinearGrid on CPU\n Â Â  â”‚Â Â  â””â”€â”€ 2\n Â Â  â””â”€â”€ ^ at (Center, Center, Face)\n Â Â   Â Â  â”œâ”€â”€ âˆ‚zá¶œá¶œá¶  at (Center, Center, Face) via identity\n Â Â   Â Â  â”‚Â Â  â””â”€â”€ 4Ã—1Ã—4 Field{Center, Center, Center} on RectilinearGrid on CPU\n Â Â   Â Â  â””â”€â”€ 2","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Because âˆ‚x(c)^2 is located at (Face, Center, Center) and âˆ‚z(c)^2 is located at (Center, Center, Face), a decision has to be made to compute âˆ‡cÂ². By default, AbstractOperations are reconstructed at the location of the first object in the expression. So","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"âˆ‡cÂ²_ccf = âˆ‚z(c)^2 + âˆ‚x(c)^2\n\n# output\nBinaryOperation at (Center, Center, Face)\nâ”œâ”€â”€ grid: 4Ã—1Ã—4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo\nâ””â”€â”€ tree:\n    + at (Center, Center, Face)\n Â Â  â”œâ”€â”€ ^ at (Center, Center, Face)\n Â Â  â”‚Â Â  â”œâ”€â”€ âˆ‚zá¶œá¶œá¶  at (Center, Center, Face) via identity\n Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 4Ã—1Ã—4 Field{Center, Center, Center} on RectilinearGrid on CPU\n Â Â  â”‚Â Â  â””â”€â”€ 2\n Â Â  â””â”€â”€ ^ at (Face, Center, Center)\n Â Â   Â Â  â”œâ”€â”€ âˆ‚xá¶ á¶œá¶œ at (Face, Center, Center) via identity\n Â Â   Â Â  â”‚Â Â  â””â”€â”€ 4Ã—1Ã—4 Field{Center, Center, Center} on RectilinearGrid on CPU\n Â Â   Â Â  â””â”€â”€ 2","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"ends up at (Center, Center, Face). To control the location of an operation we use the macro @at,","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"âˆ‡cÂ²_ccc = @at (Center, Center, Center) âˆ‚x(c)^2 + âˆ‚z(c)^2\n\n# output\nBinaryOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 4Ã—1Ã—4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo\nâ””â”€â”€ tree:\n    + at (Center, Center, Center)\n Â Â  â”œâ”€â”€ ^ at (Center, Center, Center)\n Â Â  â”‚Â Â  â”œâ”€â”€ âˆ‚xá¶ á¶œá¶œ at (Center, Center, Center) via â„‘xá¶œáµƒáµƒ\n Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 4Ã—1Ã—4 Field{Center, Center, Center} on RectilinearGrid on CPU\n Â Â  â”‚Â Â  â””â”€â”€ 2\n Â Â  â””â”€â”€ ^ at (Center, Center, Center)\n Â Â   Â Â  â”œâ”€â”€ âˆ‚zá¶œá¶œá¶  at (Center, Center, Center) via â„‘záµƒáµƒá¶œ\n Â Â   Â Â  â”‚Â Â  â””â”€â”€ 4Ã—1Ã—4 Field{Center, Center, Center} on RectilinearGrid on CPU\n Â Â   Â Â  â””â”€â”€ 2","category":"page"},{"location":"operations/#Averages-and-integrals","page":"Operations","title":"Averages and integrals","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"An operation that reduces one or more dimensions of a field is called a Reduction; some reductions include Average, Integral, and CumulativeIntegral.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Let's demonstrate now how we can compute the average or the integral of a field over the grid or over some part of the grid. We start by creating a latitude-longitude grid that only goes up to 30 degrees latitude. Conveniently, with this latitude extent that grid covers half the total area of the sphere, i.e., 2Ï€ * grid.radius^2.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Let's try to estimate this area using Integral operation. We create a Field, we fill it with ones and we integrate it over the whole grid. We use a CenterField for the example below, but all location combinations work similarly.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"using Oceananigans\n\ngrid = LatitudeLongitudeGrid(size=(60, 10, 5),\n                             latitude = (-30, 30),\n                             longitude = (0, 360),\n                             z = (-1000, 0))\n\nc = CenterField(grid)\nset!(c, 1)\n\nâˆ«c = Field(Integral(c, dims=(1, 2)))\n\n# output\n1Ã—1Ã—5 Field{Nothing, Nothing, Center} reduced over dims = (1, 2) on LatitudeLongitudeGrid on CPU\nâ”œâ”€â”€ data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 1, 5)\nâ”œâ”€â”€ grid: 60Ã—10Ã—5 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3Ã—3Ã—3 halo and with precomputed metrics\nâ”œâ”€â”€ operand: Integral of BinaryOperation at (Center, Center, Center) over dims (1, 2)\nâ”œâ”€â”€ status: time=0.0\nâ””â”€â”€ data: 1Ã—1Ã—11 OffsetArray(::Array{Float64, 3}, 1:1, 1:1, -2:8) with eltype Float64 with indices 1:1Ã—1:1Ã—-2:8\n    â””â”€â”€ max=2.55032e14, min=2.55032e14, mean=2.55032e14","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"A few remarks: note that the âˆ«c has locations Nothing, Nothing, Center; this is because we have integrated in the first two dimensions and thus it's reduced over dims = (1, 2).","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Above we see that the max, min and mean of the field are all the same. Let's check that these values are what we expect:","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"âˆ«c[1, 1, 1] â‰ˆ 2Ï€ * grid.radius^2 # area of spherical zone with |Ï†| â‰¤ 30áµ’\n\n# output\n\ntrue","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"We can further have conditional reduced operations. Let's compute the above integral but only for North hemisphere.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"First we need to define a condition which is a function with arguments (i, j, k, grid, field) that returns true or false. In this example we use Oceananigans.Grids.Ï†node to check whether the latitude is within the range we'd like.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"using Oceananigans.Grids: Ï†node\n\ncond(i, j, k, grid, c) = Ï†node(j, grid, Center()) â‰¥ 0\n\nconditional_âˆ«c = Field(Integral(c, dims=(1, 2), condition=cond)) # integrate only when condition is true\n\n# output\n1Ã—1Ã—5 Field{Nothing, Nothing, Center} reduced over dims = (1, 2) on LatitudeLongitudeGrid on CPU\nâ”œâ”€â”€ data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 1, 5)\nâ”œâ”€â”€ grid: 60Ã—10Ã—5 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3Ã—3Ã—3 halo and with precomputed metrics\nâ”œâ”€â”€ operand: Integral of ConditionalOperation of BinaryOperation at (Center, Center, Center) with condition cond (generic function with 1 method) over dims (1, 2)\nâ”œâ”€â”€ status: time=0.0\nâ””â”€â”€ data: 1Ã—1Ã—11 OffsetArray(::Array{Float64, 3}, 1:1, 1:1, -2:8) with eltype Float64 with indices 1:1Ã—1:1Ã—-2:8\n    â””â”€â”€ max=1.27516e14, min=1.27516e14, mean=1.27516e14","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Above we have attached a condition to the operand. Now the operand is applied only when the condition is true. Let's see if that is 1/4 of the area of the sphere","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"conditional_âˆ«c[1, 1, 1] â‰ˆ Ï€ * grid.radius^2 # area of spherical zone with 0áµ’ â‰¤ Ï† â‰¤ 30áµ’\n\n# output\ntrue","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Another way to do the above is to provide the condition keyword argument with an array of booleans.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"cond_array = trues(size(grid))\ncond_array[:, 1:5, :] .= false # set the first half of the latitude range to false\n\nconditional_âˆ«c = Field(Integral(c, dims=(1, 2), condition=cond_array))\n\nconditional_âˆ«c[1, 1, 1] â‰ˆ Ï€ * grid.radius^2 # area of spherical zone with 0áµ’ â‰¤ Ï† â‰¤ 30áµ’\n\n# output\ntrue","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#Buoyancy-models-and-equations-of-state","page":"Buoyancy models and equation of state","title":"Buoyancy models and equations of state","text":"","category":"section"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"The buoyancy option selects how buoyancy is treated in NonhydrostaticModels and HydrostaticFreeSurfaceModels (ShallowWaterModels do not have that option given the physics of the model). There are currently three alternatives:","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"No buoyancy (and no gravity).\nEvolve buoyancy as a tracer.\nSeawater buoyancy: evolve temperature T and salinity S as tracers with a value for the gravitational acceleration g and an equation of state of your choosing.","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#No-buoyancy","page":"Buoyancy models and equation of state","title":"No buoyancy","text":"","category":"section"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"To turn off buoyancy (and gravity) you can simply pass buoyancy = nothing to the model constructor. For example to create a NonhydrostaticModel:","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> grid = RectilinearGrid(size=(8, 8, 8), extent=(1, 1, 1));\n\njulia> model = NonhydrostaticModel(; grid, buoyancy=nothing)\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 8Ã—8Ã—8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ timestepper: RungeKutta3TimeStepper\nâ”œâ”€â”€ advection scheme: Centered(order=2)\nâ”œâ”€â”€ tracers: ()\nâ”œâ”€â”€ closure: Nothing\nâ”œâ”€â”€ buoyancy: Nothing\nâ””â”€â”€ coriolis: Nothing","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"The option buoyancy = nothing is the default for NonhydrostaticModel, so omitting the buoyancy keyword argument from the NonhydrostaticModel constructor yields the same:","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> model = NonhydrostaticModel(; grid)\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 8Ã—8Ã—8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ timestepper: RungeKutta3TimeStepper\nâ”œâ”€â”€ advection scheme: Centered(order=2)\nâ”œâ”€â”€ tracers: ()\nâ”œâ”€â”€ closure: Nothing\nâ”œâ”€â”€ buoyancy: Nothing\nâ””â”€â”€ coriolis: Nothing","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"The same is true for HydrostaticFreeSurfaceModel,","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> model = HydrostaticFreeSurfaceModel(; grid)\nHydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 8Ã—8Ã—8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ timestepper: QuasiAdamsBashforth2TimeStepper\nâ”œâ”€â”€ tracers: ()\nâ”œâ”€â”€ closure: Nothing\nâ”œâ”€â”€ buoyancy: Nothing\nâ”œâ”€â”€ free surface: ImplicitFreeSurface with gravitational acceleration 9.80665 m sâ»Â²\nâ”‚   â””â”€â”€ solver: FFTImplicitFreeSurfaceSolver\nâ”œâ”€â”€ advection scheme:\nâ”‚   â””â”€â”€ momentum: VectorInvariant\nâ”œâ”€â”€ vertical_coordinate: ZCoordinate\nâ””â”€â”€ coriolis: Nothing","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#Buoyancy-as-a-tracer","page":"Buoyancy models and equation of state","title":"Buoyancy as a tracer","text":"","category":"section"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"Both NonhydrostaticModel and HydrostaticFreeSurfaceModel support evolving a buoyancy tracer by including :b in tracers and specifying  buoyancy = BuoyancyTracer():","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> model = NonhydrostaticModel(; grid, buoyancy=BuoyancyTracer(), tracers=:b)\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 8Ã—8Ã—8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ timestepper: RungeKutta3TimeStepper\nâ”œâ”€â”€ advection scheme: Centered(order=2)\nâ”œâ”€â”€ tracers: b\nâ”œâ”€â”€ closure: Nothing\nâ”œâ”€â”€ buoyancy: BuoyancyTracer with gÌ‚ = NegativeZDirection()\nâ””â”€â”€ coriolis: Nothing","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"Similarly for a HydrostaticFreeSurfaceModel with buoyancy as a tracer:","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> model = HydrostaticFreeSurfaceModel(; grid, buoyancy=BuoyancyTracer(), tracers=:b)\nHydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 8Ã—8Ã—8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ timestepper: QuasiAdamsBashforth2TimeStepper\nâ”œâ”€â”€ tracers: b\nâ”œâ”€â”€ closure: Nothing\nâ”œâ”€â”€ buoyancy: BuoyancyTracer with gÌ‚ = NegativeZDirection()\nâ”œâ”€â”€ free surface: ImplicitFreeSurface with gravitational acceleration 9.80665 m sâ»Â²\nâ”‚   â””â”€â”€ solver: FFTImplicitFreeSurfaceSolver\nâ”œâ”€â”€ advection scheme:\nâ”‚   â”œâ”€â”€ momentum: VectorInvariant\nâ”‚   â””â”€â”€ b: Centered(order=2)\nâ”œâ”€â”€ vertical_coordinate: ZCoordinate\nâ””â”€â”€ coriolis: Nothing","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#Seawater-buoyancy","page":"Buoyancy models and equation of state","title":"Seawater buoyancy","text":"","category":"section"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"NonhydrostaticModel and HydrostaticFreeSurfaceModel support modeling the buoyancy of seawater as a function of the gravitational acceleration, the conservative temperature T, and the absolute salinity S. The relationship between T, S, the geopotential height, and the density perturbation from a reference value is called the equation_of_state.","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"Specifying buoyancy = SeawaterBuoyancy() returns a buoyancy model with a linear equation of state, Earth standard gravitational_acceleration = 9.80665 (in S.I. units textmtexts^-2) and requires to add :T and :S as tracers:","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> model = NonhydrostaticModel(; grid, buoyancy=SeawaterBuoyancy(), tracers=(:T, :S))\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 8Ã—8Ã—8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ timestepper: RungeKutta3TimeStepper\nâ”œâ”€â”€ advection scheme: Centered(order=2)\nâ”œâ”€â”€ tracers: (T, S)\nâ”œâ”€â”€ closure: Nothing\nâ”œâ”€â”€ buoyancy: SeawaterBuoyancy with g=9.80665 and LinearEquationOfState(thermal_expansion=0.000167, haline_contraction=0.00078) with gÌ‚ = NegativeZDirection()\nâ””â”€â”€ coriolis: Nothing","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"and the same is true for HydrostaticFreeSurfaceModel,","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> model = HydrostaticFreeSurfaceModel(; grid, buoyancy=SeawaterBuoyancy(), tracers=(:T, :S))\nHydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 8Ã—8Ã—8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ timestepper: QuasiAdamsBashforth2TimeStepper\nâ”œâ”€â”€ tracers: (T, S)\nâ”œâ”€â”€ closure: Nothing\nâ”œâ”€â”€ buoyancy: SeawaterBuoyancy with g=9.80665 and LinearEquationOfState(thermal_expansion=0.000167, haline_contraction=0.00078) with gÌ‚ = NegativeZDirection()\nâ”œâ”€â”€ free surface: ImplicitFreeSurface with gravitational acceleration 9.80665 m sâ»Â²\nâ”‚   â””â”€â”€ solver: FFTImplicitFreeSurfaceSolver\nâ”œâ”€â”€ advection scheme:\nâ”‚   â”œâ”€â”€ momentum: VectorInvariant\nâ”‚   â”œâ”€â”€ T: Centered(order=2)\nâ”‚   â””â”€â”€ S: Centered(order=2)\nâ”œâ”€â”€ vertical_coordinate: ZCoordinate\nâ””â”€â”€ coriolis: Nothing","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"To model flows near the surface of Europa where gravitational_acceleration = 1.3 textmtexts^-2, we might alternatively specify","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> buoyancy = SeawaterBuoyancy(gravitational_acceleration=1.3)\nSeawaterBuoyancy{Float64}:\nâ”œâ”€â”€ gravitational_acceleration: 1.3\nâ””â”€â”€ equation_of_state: LinearEquationOfState(thermal_expansion=0.000167, haline_contraction=0.00078)\n\njulia> model = NonhydrostaticModel(; grid, buoyancy, tracers=(:T, :S))\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 8Ã—8Ã—8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ timestepper: RungeKutta3TimeStepper\nâ”œâ”€â”€ advection scheme: Centered(order=2)\nâ”œâ”€â”€ tracers: (T, S)\nâ”œâ”€â”€ closure: Nothing\nâ”œâ”€â”€ buoyancy: SeawaterBuoyancy with g=1.3 and LinearEquationOfState(thermal_expansion=0.000167, haline_contraction=0.00078) with gÌ‚ = NegativeZDirection()\nâ””â”€â”€ coriolis: Nothing","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"for example.","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#Linear-equation-of-state","page":"Buoyancy models and equation of state","title":"Linear equation of state","text":"","category":"section"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"To specify the thermal expansion and haline contraction coefficients alpha = 2 times 10^-3  textK^-1 and beta = 5 times 10^-4 textpsu^-1,","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> buoyancy = SeawaterBuoyancy(equation_of_state=LinearEquationOfState(thermal_expansion=2e-3, haline_contraction=5e-4))\nSeawaterBuoyancy{Float64}:\nâ”œâ”€â”€ gravitational_acceleration: 9.80665\nâ””â”€â”€ equation_of_state: LinearEquationOfState(thermal_expansion=0.002, haline_contraction=0.0005)","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#Idealized-nonlinear-equations-of-state","page":"Buoyancy models and equation of state","title":"Idealized nonlinear equations of state","text":"","category":"section"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"Instead of a linear equation of state, six idealized (second-order) nonlinear equations of state as described by Roquet et al. (2015) may be used. These equations of state are provided via the SeawaterPolynomials.jl package.","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> using SeawaterPolynomials.SecondOrderSeawaterPolynomials\n\njulia> eos = RoquetEquationOfState(:Freezing)\nBoussinesqEquationOfState{Float64}:\nâ”œâ”€â”€ seawater_polynomial: SecondOrderSeawaterPolynomial{Float64}\nâ””â”€â”€ reference_density: 1024.6\n\njulia> eos.seawater_polynomial # the density anomaly\nÏ' = 0.7718 Sá´¬ - 0.0491 Î˜ - 0.005027 Î˜Â² - 2.5681e-5 Î˜ Z + 0.0 Sá´¬Â² + 0.0 Sá´¬ Z + 0.0 Sá´¬ Î˜\n\njulia> buoyancy = SeawaterBuoyancy(equation_of_state=eos)\nSeawaterBuoyancy{Float64}:\nâ”œâ”€â”€ gravitational_acceleration: 9.80665\nâ””â”€â”€ equation_of_state: BoussinesqEquationOfState{Float64}","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#TEOS-10-equation-of-state","page":"Buoyancy models and equation of state","title":"TEOS-10 equation of state","text":"","category":"section"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"A high-accuracy 55-term polynomial approximation to the TEOS-10 equation of state suitable for use in Boussinesq models as described by Roquet et al. (2015) is implemented in the SeawaterPolynomials.jl package and may be used.","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> using SeawaterPolynomials.TEOS10\n\njulia> eos = TEOS10EquationOfState()\nBoussinesqEquationOfState{Float64}:\nâ”œâ”€â”€ seawater_polynomial: TEOS10SeawaterPolynomial{Float64}\nâ””â”€â”€ reference_density: 1020.0","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#The-direction-of-gravitational-acceleration","page":"Buoyancy models and equation of state","title":"The direction of gravitational acceleration","text":"","category":"section"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"To simulate gravitational accelerations that don't align with the vertical (z) coordinate, we use BuoyancyForce(formulation; gravity_unit_vector), wherein the buoyancy formulation can be BuoyancyTracer, SeawaterBuoyancy, etc, in addition to the gravity_unit_vector. For example,","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> grid = RectilinearGrid(size=(8, 8, 8), extent=(1, 1, 1));\n\njulia> Î¸ = 45; # degrees\n\njulia> gÌƒ = (0, sind(Î¸), cosd(Î¸));\n\njulia> buoyancy = BuoyancyForce(BuoyancyTracer(), gravity_unit_vector=gÌƒ)\nBuoyancyForce:\nâ”œâ”€â”€ formulation: BuoyancyTracer\nâ””â”€â”€ gravity_unit_vector: (0.0, 0.707107, 0.707107)\n\njulia> model = NonhydrostaticModel(; grid, buoyancy, tracers=:b)\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 8Ã—8Ã—8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ timestepper: RungeKutta3TimeStepper\nâ”œâ”€â”€ advection scheme: Centered(order=2)\nâ”œâ”€â”€ tracers: b\nâ”œâ”€â”€ closure: Nothing\nâ”œâ”€â”€ buoyancy: BuoyancyTracer with gÌ‚ = (0.0, 0.707107, 0.707107)\nâ””â”€â”€ coriolis: Nothing","category":"page"},{"location":"appendix/staggered_grid/#Staggered-grid","page":"Staggered grid","title":"Staggered grid","text":"","category":"section"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"Velocities u, v, and w are defined on the faces of the cells, which are coincident with three orthogonal coordinate axes (the Cartesian axes in the case of Oceananigans). Pressure p and tracers c are stored at the cell  centers as cell averages. See schematic below of the different control volumes. Other quantities may be defined at other locations. For example, vorticity boldsymbolomega = boldsymbolnabla times boldsymbolv is defined at the cell edges.[1]","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"[1]: In 2D it would more correct to say the cell corners. In 3D, variables like vorticity lie at the same vertical levels as the cell-centered variables and so they really lie at the cell edges.","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"(Image: Schematic of control volumes) A schematic of Oceananigans.jl finite volumes for a two-dimensional staggered grid in (x z). Tracers c and pressure p are defined at the center of the control volume. The u control volumes are centered on the left and right edges of the pressure control volume while the w control volumes are centered on the top and bottom edges of the pressure control volumes. The indexing convention places the i^rmth u-node on cell x-faces to the left of the i tracer point at cell centers.","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"This staggered arrangement of variables is more complicated than the collocated grid arrangement but is greatly beneficial as it avoids the odd-even decoupling between the pressure and velocity if they are stored at the same positions. Â§6.1 of Patankar (1980) discusses this problem in the presence of a zigzag pressure field: on a 1D collocated grid the velocity at the point i is influenced by the pressure at points i-1 and i+1, and a zigzag pressure field will be felt as a uniform pressure, which is obviously wrong and would reduce the accuracy of the solution. The pressure is effectively taken from a coarser grid than what is actually used. The basic problem is that the momentum equations will use the pressure difference between two alternate points when it should be using two adjacent points.","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"From the viewpoint of linear algebra, these spurious pressure modes correspond to solutions in the null space of the pressure projection operator with eigenvalue zero and are thus indistinguishable from a uniform pressure field (Sani et al., 1981).","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"The staggered grid was first introduced by Harlow and Welch (1965) with their marker and cell method. In meteorology and oceanography, this particular staggered grid configuration is referred to as the Arakawa C-grid after Arakawa and Lamb (1977), who investigated four different staggered grids and the unstaggered A-grid for use in an atmospheric model.","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"Arakawa and Lamb (1977) investigated the dispersion relation of inertia-gravity waves[2] traveling in the x-direction","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"  omega^2 = f^2 + gHk^2  ","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"in the linearized rotating shallow-water equations for five grids. Here omega is the angular frequency, H is the height of the fluid and k is the wavenumber in the x-direction. Looking at the effect of spatial discretization error on the frequency of these waves they find that the B and C-grids reproduce the dispersion relation most closely out of the five Arakawa and Lamb (1977) (Figure 5). In particular, the dispersion relation for the C-grid is given by","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"  omega^2 = f^2 left cos^2 left( frackDelta2 right)\n             + 4 left( fraclambdaDelta right)^2 sin^2 left( frackDelta2 right) right  ","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"where lambda is the wavelength and Delta is the grid spacing. Paraphrasing p. 184 of Arakawa and Lamb (1977): The wavelength of the shortest resolvable wave is 2Delta with corresponding wavenumber k = piDelta so it is sufficient to evaluate the dispersion relation over the range 0  k Delta  pi. The frequency is monotonically increasing for lambda  Delta  frac12 and monotonically decreasing for lambda  Delta  frac12. For the fourth smallest wave lambda  Delta = frac12 we get omega^2 = f^2 which matches the k = 0 wave. Furthermore, the group velocity is zero for all k. On the other grids, waves with k Delta = pi can behave like pure inertial oscillations or stationary waves, which is bad.","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"The B and C-grids are less oscillatory than the others and quite faithfully simulate geostrophic adjustment. However, the C-grid is the only one that faithfully reproduces the two-dimensional dispersion relation omega^2(k ell), all the other grids have false maxima, and so Arakawa and Lamb (1977) conclude that the C-grid is best for simulating geostrophic adjustment except for abnormal situations in which lambda  Delta is less than or close to 1. This seems to have held true for most atmospheric and oceanographic simulations as the C-grid is popular and widely used.","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"[2]: Apparently also called PoincarÃ© waves, Sverdrup waves, and rotational gravity waves Â§13.9 of Kundu et al. (2015).","category":"page"},{"location":"numerical_implementation/elliptic_solvers/#Elliptic-solvers","page":"Elliptic solvers","title":"Elliptic solvers","text":"","category":"section"},{"location":"numerical_implementation/elliptic_solvers/#The-elliptic-problem-for-the-pressure","page":"Elliptic solvers","title":"The elliptic problem for the pressure","text":"","category":"section"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"The 3D non-hydrostatic pressure field is obtained by taking the divergence of the horizontal component of the momentum equations and invoking the vertical component to yield an elliptic Poisson equation for the non-hydrostatic kinematic pressure","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"   beginequation\n   labeleqpoisson-pressure\n   nabla^2 p_NH = fracboldsymbolnabla boldsymbolcdot boldsymbolv^nDelta t + boldsymbolnabla boldsymbolcdot boldsymbolG_boldsymbolv equiv mathscrF  \n   endequation","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"along with homogenous Neumann boundary conditions boldsymbolv cdot boldsymbolhatn = 0 (Neumann on p for wall-bounded directions and periodic otherwise) and where mathscrF denotes the source term for the Poisson equation.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"note: Dividing small timesteps\nIn practice, in order to avoid division by extremely small numbers when Delta t lesssim epsilon,  we solve the Poisson equation for p_NH Delta t instead. Delta t is then removed from the pressure field after the elliptic solve routine.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"note: Hydrostatic approximation\nFor problems in which the hydrostatic approximation is invoked, the Poisson equation for pressure above only needs to be solved for the vertically integrated flow and the pressure field is a two dimensional term p_S(x y t).","category":"page"},{"location":"numerical_implementation/elliptic_solvers/#Direct-method","page":"Elliptic solvers","title":"Direct method","text":"","category":"section"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"Discretizing elliptic problems that can be solved via a classical separation-of-variables approach, such as Poisson's equation, results in a linear system of equations M boldsymbolx = boldsymboly where M is a real symmetric matrix of block tridiagonal form. This allows for the matrix to be decomposed and solved efficiently, provided that the eigenvalues and eigenvectors of the blocks are known (Â§2) (Buzbee et al., 1970). In the case of Poisson's equation on a rectangle, Hockney (1965) has taken advantage of the fact that the fast Fourier transform can be used to perform the matrix multiplication steps resulting in an even more efficient method. Schumann and Sweet (1988) describe the implementation of such an algorithm for Poisson's equation on a staggered grid with Dirichlet, Neumann, and periodic boundary conditions.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"The method can be explained easily by taking the Fourier transform of both sides of \\eqref{eq:poisson-pressure} to yield","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"    beginequation\n    labeleqpoisson-spectral\n    -(k_x^2 + k_y^2 + k_z^2) widehatp_NH = widehatmathscrF\n    quad implies quad\n    widehatp_NH = - fracwidehatmathscrFk_x^2 + k_y^2 + k_z^2  \n    endequation","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"where widehatcdot denotes the Fourier component. Here k_x, k_y, and k_z are the wavenumbers. However, when solving the equation on a staggered grid we require a solution for p_NH that is second-order accurate such that when when its Laplacian is computed, nabla^2 p_NH matches mathscrF to machine precision. This is crucial to ensure that the projection step in the fractional time-step works (see Time-stepping section and Fractional step method appendix). To do this, the wavenumbers are replaced by eigenvalues lambda^x, lambda^y, and lambda^z satisfying the discrete form of Poisson's equation with appropriate boundary conditions. Thus, Poisson's equation is diagonalized in Fourier space and the Fourier coefficients of the solution are easily solved for","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"widehatp_NH(i j k) = - fracwidehatmathscrF(i j k)lambda^x_i + lambda^y_j + lambda^z_k  ","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"The eigenvalues are given by Schumann and Sweet (1988) and can also be tediously derived by plugging in the definition of the discrete Fourier transform into \\eqref{eq:poisson-spectral}:","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"beginalign\n    lambda^x_i = 4fracN_x^2L_x^2 sin^2 left  frac(i-1) piN_x  right  quad i=0 1 dots N_x-1   \n    lambda^y_j = 4fracN_y^2L_y^2 sin^2 left  frac(j-1) piN_y  right  quad j=0 1 dots N_y-1   \n    lambda^z_k = 4fracN_z^2L_z^2 sin^2 left  frac(k-1) pi2N_z right  quad k=0 1 dots N_z-1  \nendalign","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"where lambda^x and lambda^y correspond to periodic boundary conditions in the horizontal and lambda^z to Neumann boundary conditions in the vertical.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"There is also an ambiguity in the solution to Poisson's equation as it's only defined up to a constant. To resolve this ambiguity we choose the solution with zero mean by setting the zeroth Fourier coefficient p_000 (corresponding to k_x = k_y = k_z = 0) to zero. This also has the added benefit of discarding the zero eigenvalue so we don't divide by it.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"The Fast Fourier transforms are computed using FFTW.jl [(Frigo and Johnson, 1998) and (Frigo and Johnson, 2005)] on the CPU and using the cuFFT library on the GPU. Along wall-bounded dimensions, the cosine transform is used. In particular, as the transforms are performed on a staggered grid, DCT-II (REDFT10) is used to perform the forward cosine transform and DCT-III (REDFT01) is used to perform the inverse cosine transform.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/#Direct-method-with-a-vertically-stretched-grid","page":"Elliptic solvers","title":"Direct method with a vertically stretched grid","text":"","category":"section"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"Using Fourier transforms for all three dimensions results in a method requiring mathcalO(N log_2 N) operations where N is the total number of grid points. This algorithm can be made even more efficient by solving a tridiagonal system along one of the dimensions and utilizing cyclic reduction. This results in the Fourier analysis cyclic reduction or textFACR(ell) algorithm (with ell cyclic reduction steps) which requires only mathcalO(N log_2log_2 N) operations provided the optimal number of cyclic reduction steps is taken, which is ell = log_2 log_2 n where n is the number of grid points in the cyclic reduction dimension. The FACR algorithm was first developed by Hockney (1969) and is well reviewed by Swarztrauber (1977) then further benchmarked and extended by Temperton (1979) and Temperton (1980).","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"Furthermore, the FACR algorithm removes the restriction that the grid is uniform in one of the dimensions so it can be utilized to implement a fast Poisson solver for vertically stretched grids if the cyclic reduction is applied in the along the vertical dimension.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"Expanding p_NH and mathscrF into Fourier modes along the x and y directions","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"p_ijk = sum_m=1^N_x sum_n=1^N_y tildep_mnk  e^-mathrmi 2pi i m  N_x   e^-mathrmi 2pi j n  N_y  ","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"and recalling that Fourier transforms do partial_x rightarrow mathrmi k_x and partial_y rightarrow mathrmi k_y we can write \\eqref{eq:poisson-pressure} as","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"sum_m=1^N_x sum_n=1^N_y\nleftlbrace\n    partial_z^2 tildep_mnk - (k_x^2 + k_y^2) tildep_mnk - tildemathscrF_mnk\nrightrbrace e^-mathrmi 2 pi i m  N_x  e^-mathrmi 2 pi j n  N_y = 0  ","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"Discretizing the partial_z^2 derivative and equating the term inside the brackets to zero we arrive at N_xtimes N_y symmetric tridiagonal systems of N_z linear equations for the Fourier modes:","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"fractildep_mn k-1Delta z^C_k\n- leftlbrace frac1Delta z^C_k + frac1Delta z^C_k+1 + Delta z^F_k (k_x^2 + k_y^2) rightrbrace\n  tildep_mnk\n+ fractildep_mn k+1Delta z^C_k+1\n= Delta z^F_k tildemathscrF_mnk  ","category":"page"},{"location":"numerical_implementation/elliptic_solvers/#Cosine-transforms-on-the-GPU","page":"Elliptic solvers","title":"Cosine transforms on the GPU","text":"","category":"section"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"Unfortunately cuFFT does not provide cosine transforms and so we must write our own fast cosine transforms for the GPU. We implemented the fast 1D and 2D cosine transforms described by Makhoul (1980) which compute it by applying the regular Fourier transform to a permuted version of the array.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"In this section we will be using the DCT-II as the definition of the forward cosine transform for a real signal of length N","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"    beginequation\n    labeleqFCT\n    textDCT(X) quad Y_k = 2 sum_j=0^N-1 cos left fracpi(j + frac12)kN right X_j  \n    endequation","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"and the DCT-III as the definition of the inverse cosine transform","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"    beginequation\n    labeleqIFCT\n    textIDCT(X) quad Y_k = X_0 + 2 sum_j=1^N-1 cos left fracpi j (k + frac12)N right X_j  \n    endequation","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"and will use omega_M = e^-2 pi mathrmi  M to denote the M^textth root of unity, sometimes called the twiddle factors in the context of FFT algorithms.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/#1D-fast-cosine-transform","page":"Elliptic solvers","title":"1D fast cosine transform","text":"","category":"section"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"To calculate \\eqref{eq:FCT} using the fast Fourier transform, we first permute the input signal along the appropriate dimension by ordering the odd elements first followed by the even elements to produce a permuted signal","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"    X^prime_n =\n    begincases\n        displaystyle X_2N quad 0 le n le left fracN-12 right   \n        displaystyle X_2N - 2n - 1 quad left fracN+12 right le n le N-1  \n    endcases","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"where a indicates the integer part of a. This should produce, for example,","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"    beginequation\n    labeleqpermutation\n    (a b c d e f g h) quad rightarrow quad (a c e g h f d b)  \n    endequation","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"after which \\eqref{eq:FCT} is computed using","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"  Y = textDCT(X) = 2 textRe leftlbrace omega_4N^k textFFT lbrace X^prime rbrace rightrbrace  ","category":"page"},{"location":"numerical_implementation/elliptic_solvers/#1D-fast-inverse-cosine-transform","page":"Elliptic solvers","title":"1D fast inverse cosine transform","text":"","category":"section"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"The inverse \\eqref{eq:IFCT} can be computed using","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"  Y = textIDCT(X) = textRe leftlbrace omega_4N^-k textIFFT lbrace X rbrace rightrbrace  ","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"after which the inverse permutation of \\eqref{eq:permutation} must be applied.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/#2D-fast-cosine-transform","page":"Elliptic solvers","title":"2D fast cosine transform","text":"","category":"section"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"Unfortunately, the 1D algorithm cannot be applied dimension-wise so the 2D algorithm is more complicated. Thankfully, the permutation \\eqref{eq:permutation} can be applied dimension-wise. The forward cosine transform for a real signal of length N_1 times N_2 is then given by","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"Y_k_1 k_2 = textDCT(X_n_1 n_2) =\n2 textRe leftlbrace\n    omega_4N_1^k left( omega_4N_2^k tildeX + omega_4N_2^-k tildeX^- right)\nrightrbrace  ","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"where tildeX = textFFT(X^prime) and tildeX^- indicates that tildeX is indexed in reverse.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/#2D-fast-inverse-cosine-transform","page":"Elliptic solvers","title":"2D fast inverse cosine transform","text":"","category":"section"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"The inverse can be computed using","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"Y_k_1 k_2 = textIDCT(X_n_1 n_2) =\nfrac14 textRe leftlbrace\n    omega_4N_1^-k omega_4N_2^-k\n    left( tildeX - M_1 M_2 tildeX^-- right)\n    - mathrmi left( M_1 tildeX^-+ + M_2 tildeX^+- right)\nrightrbrace  ","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"where tildeX = textIFFT(X) here, tildeX^-+ is indexed in reverse along the first dimension, tildeX^-+ along the second dimension, and tildeX^-- along both. M_1 and M_2 are masks of lengths N_1 and N_2 respectively, both containing ones except at the first element where M_0 = 0. Afterwards, the inverse permutation of \\eqref{eq:permutation} must be applied.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"Due to the extra steps involved in calculating the cosine transform in 2D, running with two wall-bounded dimensions typically slows the model down by a factor of 2. Switching to the FACR algorithm may help here as a 2D cosine transform won't be necessary anymore.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/#Iterative-Solvers","page":"Elliptic solvers","title":"Iterative Solvers","text":"","category":"section"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"For problems with irregular grids the eigenvectors of the discrete Poisson operator are no longer simple Fourier series sines and cosines. This means discrete Fast Fourier Transforms can't be used to generate the projection of the equation right hand side onto eigenvectors. So an eigenvector based approach to solving the Poisson equation is not computationally efficient.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"For problems with grids that are non uniform in multiple directions, we use instead a pre-conditioned conjugate gradient iterative solver. Such cases include curvilinear grids on the sphere and also telescoping cartesian grids that stretch along more than one dimension. There are two forms of the pressure operator in this approach. One is rigid lid form and one is an implicit free-surface form.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/#Rigid-lid-pressure-operator","page":"Elliptic solvers","title":"Rigid lid pressure operator","text":"","category":"section"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"The rigid lid operator is based on the same continuous form as is used in the Direct Method solver.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/#Implicit-free-surface-pressure-operator","page":"Elliptic solvers","title":"Implicit free surface pressure operator","text":"","category":"section"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"The implicit free surface solver solves for the free-surface, eta(x y t), in the vertically integrated continuity equation:","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"    beginequation\n    labeleqvertically-integrated-continuity\n    partial_t eta + partial_x left ( int_-H^0 u  mathrmdz right ) + partial_y left ( int_-H^0 v  mathrmdz right ) = M  \n    endequation","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"where H(x y) is the depth of the water column (to first order with respect to the free surface elevation) and M is some surface volume flux (e.g., terms such as precipitation, evaporation and runoff); currently Oceananigans.jl assumes M = 0. Note that in deriving \\eqref{eq:vertically-integrated-continuity}, we used the bottom boundary condition w_rm bottom = boldsymbolu_rm bottom boldsymbolcdot boldsymbolnabla_h H.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"To form a linear system that can be solved implicitly we recast the vertically-integrated continuity equation \\eqref{eq:vertically-integrated-continuity} into a discrete integral form. The best way to do so is by starting from the discrete version of the continuity equation (in this case without any surface volume flux, M = 0)","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"    beginalign\n    labeleqcontinuity-discrete\n    delta_x (A_x u) + delta_y (A_y v) + delta_z (A_z w) = 0  \n    endalign","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"and summing it vertically to get:","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"    beginalign\n    labeleqvertically-integrated-continuity-discrete\n    delta_x sum_k (A_x u) + delta_y sum_k (A_y v) + A_z underbracew(k = N_z + 1)_w_rm top = 0  \n    endalign","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"In equations \\eqref{eq:continuity-discrete} and \\eqref{eq:vertically-integrated-continuity-discrete} and here after, we have abused notation and used, e.g., u and v to denote the volume averages over grid cells of the quantities u and v respectively. Using w_rm top = partial_t eta and being a bit more explicit on the locations the difference operators act on, \\eqref{eq:vertically-integrated-continuity-discrete} becomes:","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"    beginequation\n    labeleqsemi-discrete-integral-continuity\n    A_z partial_t eta + delta_x^caa sum_k (A_x u) + delta_y^aca sum_k (A_y v) = 0  \n    endequation","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"We can now apply the velocity fractional step equation (discussed in the Time-stepping section) for the hydrostatic model:","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"    beginequation\n    labeleqhydrostatic-fractional-step\n    boldsymbolu^n+1 = boldsymbolu^star - g Delta t  boldsymbolnabla eta^n+1  \n    endequation","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"We impose that the n+1-th time step velocity is consistent with \\eqref{eq:semi-discrete-integral-continuity}","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"    beginequation\n    A_z fraceta^n+1 - eta^nDelta t = - delta_x^caa sum_k (A_x u^n+1) - delta_y^aca sum_k (A_y v^n+1)  \n    endequation","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"Substituting u^n+1 and v^n+1 from the discrete form of the right-hand-side of \\eqref{eq:hydrostatic-fractional-step} then gives us an implicit equation for eta^n+1:","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"beginalign\n    delta_x^caasum_k A_x partial_x^faa eta^n+1  + delta_y^aca sum_k A_y partial_y^afa eta^n+1 - frac1g  Delta t^2 A_z eta^n+1 = nonumber \n     = frac1g  Delta t left( delta_x^caa sum_k A_x u^star + delta_y^aca sum_k A_y v^star right ) - frac1g  Delta t^2 A_z eta^n   labeleqimplicit-free-surface\nendalign","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"The left-hand-side of \\eqref{eq:implicit-free-surface} is nothing else than a linear operator acting on eta^n+1. Formulated in this way, the linear operator is symmetric and therefore \\eqref{eq:implicit-free-surface} can be solved using a preconditioned conjugate gradient algorithm.","category":"page"},{"location":"appendix/benchmarks/#performance_benchmarks","page":"Performance benchmarks","title":"Performance benchmarks","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"The performance benchmarking scripts in the benchmarks directory of the git repository can be run to benchmark Oceananigans.jl on your machine. They use BenchmarkTools.jl to collect data and PrettyTables.jl  to nicely format the benchmark results.","category":"page"},{"location":"appendix/benchmarks/#Shallow-Water-Model","page":"Performance benchmarks","title":"Shallow Water Model","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"This benchmark tests the performance of the shallow water model run in a doubly periodic domain (topology = (Periodic, Periodic, Flat)) on a CPU versus a GPU.  We find that with the WENO advection scheme we get a maximum speedup of more than 400 times on a 16384^2 grid.","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Oceananigans v0.58.1\nJulia Version 1.6.0\nCommit f9720dc2eb (2021-03-24 12:55 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake)\nEnvironment:\n  EBVERSIONJULIA = 1.6.0\n  JULIA_DEPOT_PATH = :\n  EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0\n  EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel\n  JULIA_LOAD_PATH = :\n  GPU: Tesla V100-SXM2-32GB\n\n                                              Shallow water model benchmarks\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Architectures â”‚ Float_types â”‚    Ns â”‚        min â”‚     median â”‚       mean â”‚        max â”‚    memory â”‚ allocs â”‚ samples â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚           CPU â”‚     Float64 â”‚    32 â”‚   2.677 ms â”‚   2.876 ms â”‚   3.047 ms â”‚   4.806 ms â”‚  1.36 MiB â”‚   2253 â”‚      10 â”‚\nâ”‚           CPU â”‚     Float64 â”‚    64 â”‚   5.795 ms â”‚   5.890 ms â”‚   6.073 ms â”‚   7.770 ms â”‚  1.36 MiB â”‚   2255 â”‚      10 â”‚\nâ”‚           CPU â”‚     Float64 â”‚   128 â”‚  16.979 ms â”‚  17.350 ms â”‚  17.578 ms â”‚  19.993 ms â”‚  1.36 MiB â”‚   2255 â”‚      10 â”‚\nâ”‚           CPU â”‚     Float64 â”‚   256 â”‚  62.543 ms â”‚  63.222 ms â”‚  63.544 ms â”‚  67.347 ms â”‚  1.36 MiB â”‚   2255 â”‚      10 â”‚\nâ”‚           CPU â”‚     Float64 â”‚   512 â”‚ 250.149 ms â”‚ 251.023 ms â”‚ 251.092 ms â”‚ 252.389 ms â”‚  1.36 MiB â”‚   2315 â”‚      10 â”‚\nâ”‚           CPU â”‚     Float64 â”‚  1024 â”‚ 990.901 ms â”‚ 993.115 ms â”‚ 993.360 ms â”‚ 996.091 ms â”‚  1.36 MiB â”‚   2315 â”‚       6 â”‚\nâ”‚           CPU â”‚     Float64 â”‚  2048 â”‚    4.002 s â”‚    4.004 s â”‚    4.004 s â”‚    4.007 s â”‚  1.36 MiB â”‚   2315 â”‚       2 â”‚\nâ”‚           CPU â”‚     Float64 â”‚  4096 â”‚   16.371 s â”‚   16.371 s â”‚   16.371 s â”‚   16.371 s â”‚  1.36 MiB â”‚   2315 â”‚       1 â”‚\nâ”‚           CPU â”‚     Float64 â”‚  8192 â”‚   64.657 s â”‚   64.657 s â”‚   64.657 s â”‚   64.657 s â”‚  1.36 MiB â”‚   2315 â”‚       1 â”‚\nâ”‚           CPU â”‚     Float64 â”‚ 16384 â”‚  290.423 s â”‚  290.423 s â”‚  290.423 s â”‚  290.423 s â”‚  1.36 MiB â”‚   2315 â”‚       1 â”‚\nâ”‚           GPU â”‚     Float64 â”‚    32 â”‚   3.468 ms â”‚   3.656 ms â”‚   3.745 ms â”‚   4.695 ms â”‚  1.82 MiB â”‚   5687 â”‚      10 â”‚\nâ”‚           GPU â”‚     Float64 â”‚    64 â”‚   3.722 ms â”‚   3.903 ms â”‚   4.050 ms â”‚   5.671 ms â”‚  1.82 MiB â”‚   5687 â”‚      10 â”‚\nâ”‚           GPU â”‚     Float64 â”‚   128 â”‚   3.519 ms â”‚   3.808 ms â”‚   4.042 ms â”‚   6.372 ms â”‚  1.82 MiB â”‚   5687 â”‚      10 â”‚\nâ”‚           GPU â”‚     Float64 â”‚   256 â”‚   3.822 ms â”‚   4.153 ms â”‚   4.288 ms â”‚   5.810 ms â”‚  1.82 MiB â”‚   5687 â”‚      10 â”‚\nâ”‚           GPU â”‚     Float64 â”‚   512 â”‚   4.637 ms â”‚   4.932 ms â”‚   4.961 ms â”‚   5.728 ms â”‚  1.82 MiB â”‚   5765 â”‚      10 â”‚\nâ”‚           GPU â”‚     Float64 â”‚  1024 â”‚   3.240 ms â”‚   3.424 ms â”‚   3.527 ms â”‚   4.553 ms â”‚  1.82 MiB â”‚   5799 â”‚      10 â”‚\nâ”‚           GPU â”‚     Float64 â”‚  2048 â”‚  10.783 ms â”‚  10.800 ms â”‚  11.498 ms â”‚  17.824 ms â”‚  1.98 MiB â”‚  16305 â”‚      10 â”‚\nâ”‚           GPU â”‚     Float64 â”‚  4096 â”‚  41.880 ms â”‚  41.911 ms â”‚  42.485 ms â”‚  47.627 ms â”‚  2.67 MiB â”‚  61033 â”‚      10 â”‚\nâ”‚           GPU â”‚     Float64 â”‚  8192 â”‚ 166.751 ms â”‚ 166.800 ms â”‚ 166.847 ms â”‚ 167.129 ms â”‚  5.21 MiB â”‚ 227593 â”‚      10 â”‚\nâ”‚           GPU â”‚     Float64 â”‚ 16384 â”‚ 681.129 ms â”‚ 681.249 ms â”‚ 681.301 ms â”‚ 681.583 ms â”‚ 16.59 MiB â”‚ 973627 â”‚       8 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n        Shallow water model CPU to GPU speedup\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Float_types â”‚    Ns â”‚  speedup â”‚  memory â”‚  allocs â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚     Float64 â”‚    32 â”‚ 0.786715 â”‚ 1.33777 â”‚ 2.52419 â”‚\nâ”‚     Float64 â”‚    64 â”‚  1.50931 â”‚ 1.33774 â”‚ 2.52195 â”‚\nâ”‚     Float64 â”‚   128 â”‚  4.55587 â”‚ 1.33774 â”‚ 2.52195 â”‚\nâ”‚     Float64 â”‚   256 â”‚  15.2238 â”‚ 1.33774 â”‚ 2.52195 â”‚\nâ”‚     Float64 â”‚   512 â”‚  50.8995 â”‚ 1.33771 â”‚ 2.49028 â”‚\nâ”‚     Float64 â”‚  1024 â”‚  290.085 â”‚ 1.33809 â”‚ 2.50497 â”‚\nâ”‚     Float64 â”‚  2048 â”‚  370.777 â”‚ 1.45575 â”‚  7.0432 â”‚\nâ”‚     Float64 â”‚  4096 â”‚  390.617 â”‚ 1.95667 â”‚ 26.3641 â”‚\nâ”‚     Float64 â”‚  8192 â”‚  387.632 â”‚ 3.82201 â”‚ 98.3123 â”‚\nâ”‚     Float64 â”‚ 16384 â”‚   426.31 â”‚  12.177 â”‚ 420.573 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"As shown in the graph below, speedups increase sharply starting at grid size 512^2 and then plateau off at around 400 times at grid size 4096^2 and beyond.","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"(Image: shallow_water_speedup)","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"The time graph below shows that execution times on GPU are negligibly small up until grid size 1024^2 where it starts to scale similarly to times on CPU.","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"(Image: shallow_water_times)","category":"page"},{"location":"appendix/benchmarks/#Nonhydrostatic-Model","page":"Performance benchmarks","title":"Nonhydrostatic Model","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Similar to to shallow water model, the nonhydrostatic model benchmark tests for its performance on both a CPU and a GPU. It was also benchmarked with the WENO advection scheme. The nonhydrostatic model is 3-dimensional unlike the 2-dimensional shallow water model. Total number of grid points is Ns cubed.","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Oceananigans v0.58.8\nJulia Version 1.6.1\nCommit 6aaedecc44 (2021-04-23 05:59 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake)\nEnvironment:\n  EBVERSIONJULIA = 1.6.1\n  JULIA_DEPOT_PATH = :\n  EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1\n  EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1/easybuild/avx2-Core-julia-1.6.1-easybuild-devel\n  JULIA_LOAD_PATH = :\n  GPU: Tesla V100-SXM2-32GB\n\n                                            Nonhydrostatic model benchmarks\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Architectures â”‚ Float_types â”‚  Ns â”‚        min â”‚     median â”‚       mean â”‚        max â”‚   memory â”‚ allocs â”‚ samples â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚           CPU â”‚     Float32 â”‚  32 â”‚  34.822 ms â”‚  34.872 ms â”‚  35.278 ms â”‚  38.143 ms â”‚ 1.38 MiB â”‚   2302 â”‚      10 â”‚\nâ”‚           CPU â”‚     Float32 â”‚  64 â”‚ 265.408 ms â”‚ 265.571 ms â”‚ 265.768 ms â”‚ 267.765 ms â”‚ 1.38 MiB â”‚   2302 â”‚      10 â”‚\nâ”‚           CPU â”‚     Float32 â”‚ 128 â”‚    2.135 s â”‚    2.135 s â”‚    2.136 s â”‚    2.138 s â”‚ 1.38 MiB â”‚   2302 â”‚       3 â”‚\nâ”‚           CPU â”‚     Float32 â”‚ 256 â”‚   17.405 s â”‚   17.405 s â”‚   17.405 s â”‚   17.405 s â”‚ 1.38 MiB â”‚   2302 â”‚       1 â”‚\nâ”‚           CPU â”‚     Float64 â”‚  32 â”‚  37.022 ms â”‚  37.179 ms â”‚  37.335 ms â”‚  39.017 ms â”‚ 1.77 MiB â”‚   2302 â”‚      10 â”‚\nâ”‚           CPU â”‚     Float64 â”‚  64 â”‚ 287.944 ms â”‚ 288.154 ms â”‚ 288.469 ms â”‚ 290.838 ms â”‚ 1.77 MiB â”‚   2302 â”‚      10 â”‚\nâ”‚           CPU â”‚     Float64 â”‚ 128 â”‚    2.326 s â”‚    2.326 s â”‚    2.326 s â”‚    2.327 s â”‚ 1.77 MiB â”‚   2302 â”‚       3 â”‚\nâ”‚           CPU â”‚     Float64 â”‚ 256 â”‚   19.561 s â”‚   19.561 s â”‚   19.561 s â”‚   19.561 s â”‚ 1.77 MiB â”‚   2302 â”‚       1 â”‚\nâ”‚           GPU â”‚     Float32 â”‚  32 â”‚   4.154 ms â”‚   4.250 ms â”‚   4.361 ms â”‚   5.557 ms â”‚ 2.13 MiB â”‚   6033 â”‚      10 â”‚\nâ”‚           GPU â”‚     Float32 â”‚  64 â”‚   3.383 ms â”‚   3.425 ms â”‚   3.889 ms â”‚   8.028 ms â”‚ 2.13 MiB â”‚   6077 â”‚      10 â”‚\nâ”‚           GPU â”‚     Float32 â”‚ 128 â”‚   5.564 ms â”‚   5.580 ms â”‚   6.095 ms â”‚  10.725 ms â”‚ 2.15 MiB â”‚   7477 â”‚      10 â”‚\nâ”‚           GPU â”‚     Float32 â”‚ 256 â”‚  38.685 ms â”‚  38.797 ms â”‚  39.548 ms â”‚  46.442 ms â”‚ 2.46 MiB â”‚  27721 â”‚      10 â”‚\nâ”‚           GPU â”‚     Float64 â”‚  32 â”‚   3.309 ms â”‚   3.634 ms â”‚   3.802 ms â”‚   5.844 ms â”‚ 2.68 MiB â”‚   6033 â”‚      10 â”‚\nâ”‚           GPU â”‚     Float64 â”‚  64 â”‚   3.330 ms â”‚   3.648 ms â”‚   4.008 ms â”‚   7.808 ms â”‚ 2.68 MiB â”‚   6071 â”‚      10 â”‚\nâ”‚           GPU â”‚     Float64 â”‚ 128 â”‚   7.209 ms â”‚   7.323 ms â”‚   8.313 ms â”‚  17.259 ms â”‚ 2.71 MiB â”‚   8515 â”‚      10 â”‚\nâ”‚           GPU â”‚     Float64 â”‚ 256 â”‚  46.614 ms â”‚  56.444 ms â”‚  55.461 ms â”‚  56.563 ms â”‚ 3.17 MiB â”‚  38253 â”‚      10 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n      Nonhydrostatic model CPU to GPU speedup\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Float_types â”‚  Ns â”‚ speedup â”‚  memory â”‚  allocs â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚     Float32 â”‚  32 â”‚ 8.20434 â”‚ 1.53786 â”‚ 2.62076 â”‚\nâ”‚     Float32 â”‚  64 â”‚ 77.5308 â”‚ 1.53835 â”‚ 2.63988 â”‚\nâ”‚     Float32 â”‚ 128 â”‚ 382.591 â”‚ 1.55378 â”‚ 3.24805 â”‚\nâ”‚     Float32 â”‚ 256 â”‚ 448.619 â”‚ 1.77688 â”‚ 12.0421 â”‚\nâ”‚     Float64 â”‚  32 â”‚ 10.2308 â”‚ 1.51613 â”‚ 2.62076 â”‚\nâ”‚     Float64 â”‚  64 â”‚ 78.9952 â”‚ 1.51646 â”‚ 2.63727 â”‚\nâ”‚     Float64 â”‚ 128 â”‚ 317.663 â”‚ 1.53759 â”‚ 3.69896 â”‚\nâ”‚     Float64 â”‚ 256 â”‚ 346.554 â”‚ 1.79466 â”‚ 16.6173 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Like the shallow water model, it can be seen at grid size 64^3 that the GPU is beginning to be saturated as speedups rapidly increase. At grid sizes 128^3 and 256^3 we see the speedup stabilize to around 400 times.","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"(Image: incompressible_speedup)","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"For both float types, the benchmarked GPU times of the nonhydrostatic model starts to scale like its CPU times when grid size reaches 128^3.","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"(Image: incompressible_times)","category":"page"},{"location":"appendix/benchmarks/#Distributed-Shallow-Water-Model","page":"Performance benchmarks","title":"Distributed Shallow Water Model","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"By using MPI.jl the shallow water model can be run on multiple CPUs and multiple GPUs. For the benchmark results shown below, each rank is run on one CPU core and each uses a distinct GPU if applicable.","category":"page"},{"location":"appendix/benchmarks/#Weak-Scaling-Shallow-Water-Model","page":"Performance benchmarks","title":"Weak Scaling Shallow Water Model","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Oceananigans v0.58.2\nJulia Version 1.6.0\nCommit f9720dc2eb (2021-03-24 12:55 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, broadwell)\nEnvironment:\n  EBVERSIONJULIA = 1.6.0\n  JULIA_DEPOT_PATH = :\n  EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0\n  EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel\n  JULIA_LOAD_PATH = :\n\n                                  Shallow water model weak scaling benchmark\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚          size â”‚    ranks â”‚        min â”‚     median â”‚       mean â”‚        max â”‚   memory â”‚ allocs â”‚ samples â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚   (4096, 256) â”‚   (1, 1) â”‚ 363.885 ms â”‚ 364.185 ms â”‚ 364.911 ms â”‚ 370.414 ms â”‚ 1.60 MiB â”‚   2774 â”‚      10 â”‚\nâ”‚   (4096, 512) â”‚   (1, 2) â”‚ 370.782 ms â”‚ 375.032 ms â”‚ 375.801 ms â”‚ 394.781 ms â”‚ 1.49 MiB â”‚   3116 â”‚      20 â”‚\nâ”‚  (4096, 1024) â”‚   (1, 4) â”‚ 369.648 ms â”‚ 369.973 ms â”‚ 371.613 ms â”‚ 399.526 ms â”‚ 1.49 MiB â”‚   3116 â”‚      40 â”‚\nâ”‚  (4096, 2048) â”‚   (1, 8) â”‚ 377.386 ms â”‚ 379.982 ms â”‚ 382.732 ms â”‚ 432.787 ms â”‚ 1.49 MiB â”‚   3116 â”‚      80 â”‚\nâ”‚  (4096, 4096) â”‚  (1, 16) â”‚ 388.336 ms â”‚ 395.473 ms â”‚ 400.079 ms â”‚ 496.598 ms â”‚ 1.49 MiB â”‚   3116 â”‚     160 â”‚\nâ”‚  (4096, 8192) â”‚  (1, 32) â”‚ 403.565 ms â”‚ 447.136 ms â”‚ 449.138 ms â”‚ 545.945 ms â”‚ 1.49 MiB â”‚   3116 â”‚     320 â”‚\nâ”‚ (4096, 16384) â”‚  (1, 64) â”‚ 397.965 ms â”‚ 441.627 ms â”‚ 453.465 ms â”‚ 619.493 ms â”‚ 1.49 MiB â”‚   3125 â”‚     640 â”‚\nâ”‚ (4096, 32768) â”‚ (1, 128) â”‚ 400.481 ms â”‚ 447.789 ms â”‚ 448.692 ms â”‚ 590.028 ms â”‚ 1.49 MiB â”‚   3125 â”‚    1280 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n                Shallow water model weak scaling speedup\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚          size â”‚    ranks â”‚ slowdown â”‚ efficiency â”‚   memory â”‚  allocs â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚   (4096, 256) â”‚   (1, 1) â”‚      1.0 â”‚        1.0 â”‚      1.0 â”‚     1.0 â”‚\nâ”‚   (4096, 512) â”‚   (1, 2) â”‚  1.02978 â”‚   0.971077 â”‚ 0.930602 â”‚ 1.12329 â”‚\nâ”‚  (4096, 1024) â”‚   (1, 4) â”‚  1.01589 â”‚   0.984355 â”‚ 0.930602 â”‚ 1.12329 â”‚\nâ”‚  (4096, 2048) â”‚   (1, 8) â”‚  1.04338 â”‚   0.958427 â”‚ 0.930602 â”‚ 1.12329 â”‚\nâ”‚  (4096, 4096) â”‚  (1, 16) â”‚  1.08591 â”‚   0.920886 â”‚ 0.930602 â”‚ 1.12329 â”‚\nâ”‚  (4096, 8192) â”‚  (1, 32) â”‚  1.22777 â”‚   0.814484 â”‚ 0.930602 â”‚ 1.12329 â”‚\nâ”‚ (4096, 16384) â”‚  (1, 64) â”‚  1.21264 â”‚   0.824644 â”‚ 0.930687 â”‚ 1.12653 â”‚\nâ”‚ (4096, 32768) â”‚ (1, 128) â”‚  1.22957 â”‚   0.813296 â”‚ 0.930687 â”‚ 1.12653 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"As seen in the tables above and in the graph below, efficiency drops off to around 80% and remains as such from 16 to 128 ranks. GPUs are not used in this or the next benchmark setup.","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"(Image: ws_shallow_water_efficiency)","category":"page"},{"location":"appendix/benchmarks/#Strong-Scaling-Shallow-Water-Model","page":"Performance benchmarks","title":"Strong Scaling Shallow Water Model","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Oceananigans v0.58.2\nJulia Version 1.6.0\nCommit f9720dc2eb (2021-03-24 12:55 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, broadwell)\nEnvironment:\n  EBVERSIONJULIA = 1.6.0\n  JULIA_DEPOT_PATH = :\n  EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0\n  EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel\n  JULIA_LOAD_PATH = :\n\n                                Shallow water model strong scaling benchmark\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚         size â”‚    ranks â”‚        min â”‚     median â”‚       mean â”‚        max â”‚   memory â”‚ allocs â”‚ samples â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ (4096, 4096) â”‚   (1, 1) â”‚    5.694 s â”‚    5.694 s â”‚    5.694 s â”‚    5.694 s â”‚ 1.60 MiB â”‚   2804 â”‚       1 â”‚\nâ”‚ (4096, 4096) â”‚   (1, 2) â”‚    2.865 s â”‚    2.865 s â”‚    2.866 s â”‚    2.869 s â”‚ 1.49 MiB â”‚   3146 â”‚       4 â”‚\nâ”‚ (4096, 4096) â”‚   (1, 4) â”‚    1.435 s â”‚    1.437 s â”‚    1.441 s â”‚    1.475 s â”‚ 1.49 MiB â”‚   3146 â”‚      16 â”‚\nâ”‚ (4096, 4096) â”‚   (1, 8) â”‚ 732.711 ms â”‚ 736.394 ms â”‚ 738.930 ms â”‚ 776.773 ms â”‚ 1.49 MiB â”‚   3146 â”‚      56 â”‚\nâ”‚ (4096, 4096) â”‚  (1, 16) â”‚ 389.211 ms â”‚ 395.749 ms â”‚ 396.813 ms â”‚ 433.332 ms â”‚ 1.49 MiB â”‚   3116 â”‚     160 â”‚\nâ”‚ (4096, 4096) â”‚  (1, 32) â”‚ 197.894 ms â”‚ 219.211 ms â”‚ 236.780 ms â”‚ 367.188 ms â”‚ 1.49 MiB â”‚   3116 â”‚     320 â”‚\nâ”‚ (4096, 4096) â”‚  (1, 64) â”‚ 101.520 ms â”‚ 112.606 ms â”‚ 116.809 ms â”‚ 221.497 ms â”‚ 1.49 MiB â”‚   3125 â”‚     640 â”‚\nâ”‚ (4096, 4096) â”‚ (1, 128) â”‚  51.452 ms â”‚  60.256 ms â”‚  70.959 ms â”‚ 232.309 ms â”‚ 1.49 MiB â”‚   3125 â”‚    1280 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n              Shallow water model strong scaling speedup\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚         size â”‚    ranks â”‚ speedup â”‚ efficiency â”‚   memory â”‚  allocs â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ (4096, 4096) â”‚   (1, 1) â”‚     1.0 â”‚        1.0 â”‚      1.0 â”‚     1.0 â”‚\nâ”‚ (4096, 4096) â”‚   (1, 2) â”‚ 1.98728 â”‚   0.993641 â”‚ 0.930621 â”‚ 1.12197 â”‚\nâ”‚ (4096, 4096) â”‚   (1, 4) â”‚ 3.96338 â”‚   0.990845 â”‚ 0.930621 â”‚ 1.12197 â”‚\nâ”‚ (4096, 4096) â”‚   (1, 8) â”‚ 7.73237 â”‚   0.966547 â”‚ 0.930621 â”‚ 1.12197 â”‚\nâ”‚ (4096, 4096) â”‚  (1, 16) â”‚ 14.3881 â”‚   0.899255 â”‚ 0.930336 â”‚ 1.11127 â”‚\nâ”‚ (4096, 4096) â”‚  (1, 32) â”‚ 25.9754 â”‚   0.811731 â”‚ 0.930336 â”‚ 1.11127 â”‚\nâ”‚ (4096, 4096) â”‚  (1, 64) â”‚ 50.5666 â”‚   0.790102 â”‚ 0.930421 â”‚ 1.11448 â”‚\nâ”‚ (4096, 4096) â”‚ (1, 128) â”‚ 94.4984 â”‚   0.738269 â”‚ 0.930421 â”‚ 1.11448 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Slightly differing from the weak scaling results, efficiencies drop below 80% to around 74% at 128 ranks for the strong scaling distributed shallow water model benchmark. This is likely caused by the 128 CPU cores not being sufficiently saturated anymore by the constant 4096^2 grid size thus losing some efficiency overheads.","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"(Image: ss_shallow_water_efficiency)","category":"page"},{"location":"appendix/benchmarks/#Multi-GPU-Shallow-Water-Model","page":"Performance benchmarks","title":"Multi-GPU Shallow Water Model","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"While still a work in progress, it is possible to use CUDA-aware MPI to run the shallow water model on multiple GPUs. Though efficiencies may not be as high as multi-CPU, the multi-GPU architecture is still worthwhile when keeping in mind the baseline speedups generated by using a single GPU. Note that though it is possible for multiple ranks to share the use of a single GPU, efficiencies would significantly decrease and memory may be insufficient. The results below show up to three ranks each using a separate GPU.","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Julia Version 1.6.2\nCommit 1b93d53fc4 (2021-07-14 15:36 UTC)\nPlatform Info:\n  OS: Linux (powerpc64le-unknown-linux-gnu)\n  CPU: unknown\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, pwr9)\nEnvironment:\n  JULIA_MPI_PATH = /home/software/spack/openmpi/3.1.4-nhjzelonyovxks5ydtrxehceqxsbf7ik\n  JULIA_CUDA_USE_BINARYBUILDER = false\n  JULIA_DEPOT_PATH = /nobackup/users/henryguo/projects/henry-test/Oceananigans.jl/benchmark/.julia\n  GPU: Tesla V100-SXM2-32GB\n\n                              Shallow water model weak scaling benchmark\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚          size â”‚    ranks â”‚     min â”‚  median â”‚    mean â”‚     max â”‚   memory â”‚ allocs â”‚ samples â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚   (4096, 256) â”‚   (1, 1) â”‚ 2.702 msâ”‚ 2.728 msâ”‚ 2.801 msâ”‚ 3.446 msâ”‚ 2.03 MiB â”‚   5535 â”‚      10 â”‚\nâ”‚   (4096, 512) â”‚   (1, 2) â”‚ 3.510 msâ”‚ 3.612 msâ”‚ 4.287 msâ”‚16.546 msâ”‚ 2.03 MiB â”‚   5859 â”‚      20 â”‚\nâ”‚   (4096, 768) â”‚   (1, 3) â”‚ 3.553 msâ”‚ 3.653 msâ”‚ 5.195 msâ”‚39.152 msâ”‚ 2.03 MiB â”‚   5859 â”‚      30 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n                Shallow water model weak scaling speedup\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚          size â”‚    ranks â”‚ slowdown â”‚ efficiency â”‚   memory â”‚  allocs â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚   (4096, 256) â”‚   (1, 1) â”‚      1.0 â”‚        1.0 â”‚      1.0 â”‚     1.0 â”‚\nâ”‚   (4096, 512) â”‚   (1, 2) â”‚  1.32399 â”‚   0.755293 â”‚  1.00271 â”‚ 1.05854 â”‚\nâ”‚   (4096, 768) â”‚   (1, 3) â”‚  1.33901 â”‚   0.746818 â”‚  1.00271 â”‚ 1.05854 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜","category":"page"},{"location":"appendix/benchmarks/#Distributed-Nonhydrostatic-Model","page":"Performance benchmarks","title":"Distributed Nonhydrostatic Model","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Similar to the distributed shallow water model benchmark results shown above, the distributed nonhydrostatic model was also benchmarked with the strong and weak scaling methods.","category":"page"},{"location":"appendix/benchmarks/#Weak-Scaling-Nonhydrostatic-Model","page":"Performance benchmarks","title":"Weak Scaling Nonhydrostatic Model","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Weak scaling efficiencies can be improved for the nonhydrostatic model.","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Oceananigans v0.60.1\nJulia Version 1.6.1\nCommit 6aaedecc44 (2021-04-23 05:59 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, broadwell)\nEnvironment:\n  JULIA_MPI_PATH = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Compiler/intel2020/openmpi/4.0.3\n  EBVERSIONJULIA = 1.6.1\n  JULIA_DEPOT_PATH = :\n  JULIA_MPI_BINARY = system\n  JULIA_MPI_LIBRARY = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Compiler/intel2020/openmpi/4.0.3/lib64/libmpi.so\n  EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1\n  JULIA_MPI_ABI = OpenMPI\n  EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1/easybuild/avx2-Core-julia-1.6.1-easybuild-devel\n  JULIA_LOAD_PATH = :\n  JULIA_MPIEXEC = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Compiler/intel2020/openmpi/4.0.3/bin/mpiexec\n\n                                    Nonhydrostatic model weak scaling benchmark\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚             size â”‚       ranks â”‚        min â”‚     median â”‚       mean â”‚        max â”‚   memory â”‚ allocs â”‚ samples â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚   (128, 128, 16) â”‚   (1, 1, 1) â”‚  33.568 ms â”‚  34.087 ms â”‚  34.173 ms â”‚  34.894 ms â”‚ 2.05 MiB â”‚   2762 â”‚      10 â”‚\nâ”‚   (128, 128, 32) â”‚   (1, 2, 1) â”‚  36.650 ms â”‚  37.161 ms â”‚  37.393 ms â”‚  42.411 ms â”‚ 1.99 MiB â”‚   3096 â”‚      20 â”‚\nâ”‚   (128, 128, 64) â”‚   (1, 4, 1) â”‚  41.861 ms â”‚  43.440 ms â”‚  46.176 ms â”‚  97.578 ms â”‚ 1.99 MiB â”‚   3136 â”‚      40 â”‚\nâ”‚  (128, 128, 128) â”‚   (1, 8, 1) â”‚  59.995 ms â”‚  64.110 ms â”‚  68.021 ms â”‚ 138.422 ms â”‚ 1.99 MiB â”‚   3216 â”‚      80 â”‚\nâ”‚  (128, 128, 256) â”‚  (1, 16, 1) â”‚  62.633 ms â”‚  71.266 ms â”‚  74.775 ms â”‚ 164.206 ms â”‚ 2.01 MiB â”‚   3376 â”‚     160 â”‚\nâ”‚  (128, 128, 512) â”‚  (1, 32, 1) â”‚ 108.253 ms â”‚ 135.611 ms â”‚ 139.384 ms â”‚ 225.336 ms â”‚ 2.04 MiB â”‚   3722 â”‚     320 â”‚\nâ”‚ (128, 128, 1024) â”‚  (1, 64, 1) â”‚ 138.504 ms â”‚ 181.043 ms â”‚ 186.386 ms â”‚ 335.170 ms â”‚ 2.12 MiB â”‚   4372 â”‚     640 â”‚\nâ”‚ (128, 128, 2048) â”‚ (1, 128, 1) â”‚ 218.592 ms â”‚ 285.293 ms â”‚ 290.989 ms â”‚ 434.878 ms â”‚ 2.39 MiB â”‚   5652 â”‚    1280 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n                   Nonhydrostatic model weak scaling speedup\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚             size â”‚       ranks â”‚  speedup â”‚ efficiency â”‚   memory â”‚  allocs â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚   (128, 128, 16) â”‚   (1, 1, 1) â”‚      1.0 â”‚        1.0 â”‚      1.0 â”‚     1.0 â”‚\nâ”‚   (128, 128, 32) â”‚   (1, 2, 1) â”‚ 0.917292 â”‚   0.917292 â”‚ 0.968543 â”‚ 1.12093 â”‚\nâ”‚   (128, 128, 64) â”‚   (1, 4, 1) â”‚ 0.784698 â”‚   0.784698 â”‚ 0.969719 â”‚ 1.13541 â”‚\nâ”‚  (128, 128, 128) â”‚   (1, 8, 1) â”‚ 0.531697 â”‚   0.531697 â”‚ 0.972279 â”‚ 1.16437 â”‚\nâ”‚  (128, 128, 256) â”‚  (1, 16, 1) â”‚ 0.478315 â”‚   0.478315 â”‚ 0.978143 â”‚  1.2223 â”‚\nâ”‚  (128, 128, 512) â”‚  (1, 32, 1) â”‚ 0.251361 â”‚   0.251361 â”‚ 0.992878 â”‚ 1.34757 â”‚\nâ”‚ (128, 128, 1024) â”‚  (1, 64, 1) â”‚ 0.188283 â”‚   0.188283 â”‚  1.03539 â”‚ 1.58291 â”‚\nâ”‚ (128, 128, 2048) â”‚ (1, 128, 1) â”‚ 0.119482 â”‚   0.119482 â”‚  1.16791 â”‚ 2.04634 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"(Image: ws_nonhydrostatic_efficiency)","category":"page"},{"location":"appendix/benchmarks/#Strong-Scaling-Nonhydrostatic-Model","page":"Performance benchmarks","title":"Strong Scaling Nonhydrostatic Model","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Strong scaling efficiencies can also be improved for the nonhydrostatic model.","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Oceananigans v0.60.1\nJulia Version 1.6.1\nCommit 6aaedecc44 (2021-04-23 05:59 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, broadwell)\nEnvironment:\n  JULIA_MPI_PATH = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Compiler/intel2020/openmpi/4.0.3\n  EBVERSIONJULIA = 1.6.1\n  JULIA_DEPOT_PATH = :\n  JULIA_MPI_BINARY = system\n  JULIA_MPI_LIBRARY = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Compiler/intel2020/openmpi/4.0.3/lib64/libmpi.so\n  EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1\n  JULIA_MPI_ABI = OpenMPI\n  EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1/easybuild/avx2-Core-julia-1.6.1-easybuild-devel\n  JULIA_LOAD_PATH = :\n  JULIA_MPIEXEC = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Compiler/intel2020/openmpi/4.0.3/bin/mpiexec\n\n                                   Nonhydrostatic model strong scaling benchmark\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚            size â”‚       ranks â”‚        min â”‚     median â”‚       mean â”‚        max â”‚   memory â”‚ allocs â”‚ samples â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ (256, 256, 256) â”‚   (1, 1, 1) â”‚    3.049 s â”‚    3.053 s â”‚    3.053 s â”‚    3.057 s â”‚ 2.05 MiB â”‚   2762 â”‚       2 â”‚\nâ”‚ (256, 256, 256) â”‚   (1, 2, 1) â”‚    1.609 s â”‚    1.610 s â”‚    1.611 s â”‚    1.620 s â”‚ 1.99 MiB â”‚   3096 â”‚       8 â”‚\nâ”‚ (256, 256, 256) â”‚   (1, 4, 1) â”‚ 814.290 ms â”‚ 817.305 ms â”‚ 818.685 ms â”‚ 833.792 ms â”‚ 1.99 MiB â”‚   3136 â”‚      28 â”‚\nâ”‚ (256, 256, 256) â”‚   (1, 8, 1) â”‚ 434.521 ms â”‚ 439.352 ms â”‚ 443.049 ms â”‚ 508.913 ms â”‚ 1.99 MiB â”‚   3216 â”‚      80 â”‚\nâ”‚ (256, 256, 256) â”‚  (1, 16, 1) â”‚ 251.632 ms â”‚ 272.364 ms â”‚ 277.555 ms â”‚ 370.059 ms â”‚ 2.01 MiB â”‚   3376 â”‚     160 â”‚\nâ”‚ (256, 256, 256) â”‚  (1, 32, 1) â”‚ 182.380 ms â”‚ 233.322 ms â”‚ 247.325 ms â”‚ 441.971 ms â”‚ 2.04 MiB â”‚   3696 â”‚     320 â”‚\nâ”‚ (256, 256, 256) â”‚  (1, 64, 1) â”‚ 119.546 ms â”‚ 178.933 ms â”‚ 204.036 ms â”‚ 564.097 ms â”‚ 2.12 MiB â”‚   4346 â”‚     640 â”‚\nâ”‚ (256, 256, 256) â”‚ (1, 128, 1) â”‚  73.802 ms â”‚ 120.147 ms â”‚ 136.395 ms â”‚ 378.697 ms â”‚ 2.39 MiB â”‚   5626 â”‚    1280 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n                 Nonhydrostatic model strong scaling speedup\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚            size â”‚       ranks â”‚ speedup â”‚ efficiency â”‚   memory â”‚  allocs â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ (256, 256, 256) â”‚   (1, 1, 1) â”‚     1.0 â”‚        1.0 â”‚      1.0 â”‚     1.0 â”‚\nâ”‚ (256, 256, 256) â”‚   (1, 2, 1) â”‚ 1.89655 â”‚   0.948276 â”‚ 0.968543 â”‚ 1.12093 â”‚\nâ”‚ (256, 256, 256) â”‚   (1, 4, 1) â”‚ 3.73522 â”‚   0.933804 â”‚ 0.969719 â”‚ 1.13541 â”‚\nâ”‚ (256, 256, 256) â”‚   (1, 8, 1) â”‚ 6.94845 â”‚   0.868556 â”‚ 0.972279 â”‚ 1.16437 â”‚\nâ”‚ (256, 256, 256) â”‚  (1, 16, 1) â”‚ 11.2086 â”‚   0.700536 â”‚ 0.978143 â”‚  1.2223 â”‚\nâ”‚ (256, 256, 256) â”‚  (1, 32, 1) â”‚ 13.0841 â”‚   0.408879 â”‚ 0.992685 â”‚ 1.33816 â”‚\nâ”‚ (256, 256, 256) â”‚  (1, 64, 1) â”‚ 17.0612 â”‚   0.266582 â”‚  1.03519 â”‚  1.5735 â”‚\nâ”‚ (256, 256, 256) â”‚ (1, 128, 1) â”‚  25.409 â”‚   0.198508 â”‚  1.16772 â”‚ 2.03693 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"(Image: ss_nonhydrostatic_efficiency)","category":"page"},{"location":"appendix/benchmarks/#Multithreading","page":"Performance benchmarks","title":"Multithreading","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Oceananigans can also achieve parallelism via multithreading. Though its efficiencies are less than that of the MPI distributed architectures, its simple setup still makes it a viable option for achieving speedups on simple systems.","category":"page"},{"location":"appendix/benchmarks/#Weak-Scaling-Multithreaded-Shallow-Water-Model","page":"Performance benchmarks","title":"Weak Scaling Multithreaded Shallow Water Model","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"The initial drop and then rise in efficiencies going from 1 to 2 to 4 threads is likely caused by the 2 threads being automatically allocated onto only one physical CPU core. Though one physical CPU core may contain 2 logical cores each capable of running a separate thread, having 2 threads run on one core will still reduce efficiencies as many resources such as caches and buses must be shared by both threads. Note that there are as many CPU cores allocated as the maximum number of threads.","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Oceananigans v0.58.9\nJulia Version 1.6.0\nCommit f9720dc2eb (2021-03-24 12:55 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, broadwell)\nEnvironment:\n  EBVERSIONJULIA = 1.6.0\n  JULIA_DEPOT_PATH = :\n  EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0\n  EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel\n  JULIA_LOAD_PATH = :\n\n                  Shallow water model weak scaling with multithreading benchmark\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚          size â”‚ threads â”‚     min â”‚  median â”‚    mean â”‚     max â”‚    memory â”‚  allocs â”‚ samples â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚   (8192, 512) â”‚       1 â”‚ 1.458 s â”‚ 1.458 s â”‚ 1.458 s â”‚ 1.458 s â”‚  1.37 MiB â”‚    2318 â”‚       4 â”‚\nâ”‚  (8192, 1024) â”‚       2 â”‚ 2.925 s â”‚ 2.989 s â”‚ 2.989 s â”‚ 3.052 s â”‚ 18.06 MiB â”‚ 1076944 â”‚       2 â”‚\nâ”‚  (8192, 2048) â”‚       4 â”‚ 2.296 s â”‚ 2.381 s â”‚ 2.397 s â”‚ 2.515 s â”‚ 13.60 MiB â”‚  760190 â”‚       3 â”‚\nâ”‚  (8192, 4096) â”‚       8 â”‚ 2.347 s â”‚ 2.369 s â”‚ 2.377 s â”‚ 2.415 s â”‚ 16.36 MiB â”‚  891860 â”‚       3 â”‚\nâ”‚  (8192, 8192) â”‚      16 â”‚ 2.407 s â”‚ 2.548 s â”‚ 2.517 s â”‚ 2.595 s â”‚ 17.44 MiB â”‚  863941 â”‚       3 â”‚\nâ”‚ (8192, 16384) â”‚      32 â”‚ 3.023 s â”‚ 3.069 s â”‚ 3.069 s â”‚ 3.115 s â”‚ 23.03 MiB â”‚ 1034063 â”‚       2 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n        Shallow water model weak multithreading scaling speedup\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚          size â”‚ threads â”‚ slowdown â”‚ efficiency â”‚  memory â”‚  allocs â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚   (8192, 512) â”‚       1 â”‚      1.0 â”‚        1.0 â”‚     1.0 â”‚     1.0 â”‚\nâ”‚  (8192, 1024) â”‚       2 â”‚  2.04972 â”‚   0.487872 â”‚ 13.2156 â”‚ 464.601 â”‚\nâ”‚  (8192, 2048) â”‚       4 â”‚  1.63302 â”‚   0.612363 â”‚ 9.95278 â”‚ 327.951 â”‚\nâ”‚  (8192, 4096) â”‚       8 â”‚  1.62507 â”‚   0.615359 â”‚ 11.9706 â”‚ 384.754 â”‚\nâ”‚  (8192, 8192) â”‚      16 â”‚  1.74747 â”‚   0.572257 â”‚  12.755 â”‚  372.71 â”‚\nâ”‚ (8192, 16384) â”‚      32 â”‚  2.10486 â”‚    0.47509 â”‚  16.846 â”‚ 446.101 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜","category":"page"},{"location":"appendix/benchmarks/#Strong-Scaling-Multithreaded-Nonhydrostatic-Model","page":"Performance benchmarks","title":"Strong Scaling Multithreaded Nonhydrostatic Model","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"The notable and continuous decrease in efficiencies for the strong scaling nonhydrostatic model is likely caused by the 256^3 grid not sufficiently saturating 32 threads running on 32 CPUs. At the time this benchmark was produced, multithreading for both nonhydrostatic and shallow water models is still an active area of improvement. Please use the appropriate scripts found in benchmarks to obtain more recent and hopefully ameliorated benchmark results.","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Oceananigans v0.58.9\nJulia Version 1.6.1\nCommit 6aaedecc44 (2021-04-23 05:59 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, broadwell)\nEnvironment:\n  EBVERSIONJULIA = 1.6.1\n  JULIA_DEPOT_PATH = :\n  EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1\n  EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1/easybuild/avx2-Core-julia-1.6.1-easybuild-devel\n  JULIA_LOAD_PATH = :\n\n                                     Multithreading benchmarks\nâ”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ size â”‚ threads â”‚        min â”‚     median â”‚       mean â”‚        max â”‚   memory â”‚ allocs â”‚ samples â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  256 â”‚       1 â”‚    2.496 s â”‚    2.637 s â”‚    2.637 s â”‚    2.777 s â”‚ 1.70 MiB â”‚   2251 â”‚       2 â”‚\nâ”‚  256 â”‚       2 â”‚    2.385 s â”‚    2.618 s â”‚    2.618 s â”‚    2.851 s â”‚ 7.03 MiB â”‚ 342397 â”‚       2 â”‚\nâ”‚  256 â”‚       4 â”‚    1.320 s â”‚    1.321 s â”‚    1.333 s â”‚    1.371 s â”‚ 3.69 MiB â”‚ 113120 â”‚       4 â”‚\nâ”‚  256 â”‚       8 â”‚ 850.438 ms â”‚ 855.292 ms â”‚ 855.952 ms â”‚ 861.966 ms â”‚ 3.31 MiB â”‚  65709 â”‚       6 â”‚\nâ”‚  256 â”‚      16 â”‚ 642.225 ms â”‚ 645.458 ms â”‚ 648.685 ms â”‚ 674.259 ms â”‚ 3.60 MiB â”‚  40992 â”‚       8 â”‚\nâ”‚  256 â”‚      32 â”‚ 680.938 ms â”‚ 694.376 ms â”‚ 701.272 ms â”‚ 746.599 ms â”‚ 4.88 MiB â”‚  36729 â”‚       8 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n     Nonhydrostatic Strong Scaling Multithreading speedup\nâ”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ size â”‚ threads â”‚ slowdown â”‚ efficiency â”‚  memory â”‚  allocs â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  256 â”‚       1 â”‚      1.0 â”‚        1.0 â”‚     1.0 â”‚     1.0 â”‚\nâ”‚  256 â”‚       2 â”‚ 0.992966 â”‚   0.503542 â”‚ 4.14014 â”‚ 152.109 â”‚\nâ”‚  256 â”‚       4 â”‚ 0.501089 â”‚   0.498913 â”‚ 2.17724 â”‚ 50.2532 â”‚\nâ”‚  256 â”‚       8 â”‚ 0.324366 â”‚   0.385367 â”‚ 1.94899 â”‚  29.191 â”‚\nâ”‚  256 â”‚      16 â”‚ 0.244788 â”‚   0.255323 â”‚ 2.12262 â”‚ 18.2106 â”‚\nâ”‚  256 â”‚      32 â”‚ 0.263339 â”‚   0.118668 â”‚ 2.87624 â”‚ 16.3167 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜","category":"page"},{"location":"appendix/benchmarks/#Tracers","page":"Performance benchmarks","title":"Tracers","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"This benchmark tests the performance impacts of running with various amounts of active and passive tracers and compares the difference in speedup going from CPU to GPU. Number of tracers are listed in the tracers column as (active, passive).","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Oceananigans v0.58.1\nJulia Version 1.6.0\nCommit f9720dc2eb (2021-03-24 12:55 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake)\nEnvironment:\n  EBVERSIONJULIA = 1.6.0\n  JULIA_DEPOT_PATH = :\n  EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0\n  EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel\n  JULIA_LOAD_PATH = :\n  GPU: Tesla V100-SXM2-32GB\n\n                                       Arbitrary tracers benchmarks\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Architectures â”‚ tracers â”‚       min â”‚    median â”‚      mean â”‚       max â”‚     memory â”‚ allocs â”‚ samples â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚           CPU â”‚  (0, 0) â”‚   1.439 s â”‚   1.440 s â”‚   1.440 s â”‚   1.441 s â”‚ 908.03 KiB â”‚   1656 â”‚       4 â”‚\nâ”‚           CPU â”‚  (0, 1) â”‚   1.539 s â”‚   1.574 s â”‚   1.575 s â”‚   1.613 s â”‚   1.24 MiB â”‚   1942 â”‚       4 â”‚\nâ”‚           CPU â”‚  (0, 2) â”‚   1.668 s â”‚   1.669 s â”‚   1.670 s â”‚   1.671 s â”‚   1.76 MiB â”‚   2291 â”‚       3 â”‚\nâ”‚           CPU â”‚  (1, 0) â”‚   1.527 s â”‚   1.532 s â”‚   1.532 s â”‚   1.536 s â”‚   1.24 MiB â”‚   1942 â”‚       4 â”‚\nâ”‚           CPU â”‚  (2, 0) â”‚   1.690 s â”‚   1.697 s â”‚   1.695 s â”‚   1.698 s â”‚   1.77 MiB â”‚   2301 â”‚       3 â”‚\nâ”‚           CPU â”‚  (2, 3) â”‚   2.234 s â”‚   2.239 s â”‚   2.241 s â”‚   2.251 s â”‚   3.59 MiB â”‚   3928 â”‚       3 â”‚\nâ”‚           CPU â”‚  (2, 5) â”‚   2.755 s â”‚   2.838 s â”‚   2.838 s â”‚   2.921 s â”‚   5.18 MiB â”‚   4908 â”‚       2 â”‚\nâ”‚           CPU â”‚ (2, 10) â”‚   3.588 s â”‚   3.748 s â”‚   3.748 s â”‚   3.908 s â”‚  10.39 MiB â”‚   7682 â”‚       2 â”‚\nâ”‚           GPU â”‚  (0, 0) â”‚  9.702 ms â”‚ 12.755 ms â”‚ 12.458 ms â”‚ 12.894 ms â”‚   1.59 MiB â”‚  12321 â”‚      10 â”‚\nâ”‚           GPU â”‚  (0, 1) â”‚ 13.863 ms â”‚ 13.956 ms â”‚ 14.184 ms â”‚ 16.297 ms â”‚   2.20 MiB â”‚  14294 â”‚      10 â”‚\nâ”‚           GPU â”‚  (0, 2) â”‚ 15.166 ms â”‚ 15.230 ms â”‚ 15.700 ms â”‚ 19.893 ms â”‚   2.93 MiB â”‚  15967 â”‚      10 â”‚\nâ”‚           GPU â”‚  (1, 0) â”‚ 13.740 ms â”‚ 13.838 ms â”‚ 14.740 ms â”‚ 22.940 ms â”‚   2.20 MiB â”‚  14278 â”‚      10 â”‚\nâ”‚           GPU â”‚  (2, 0) â”‚ 15.103 ms â”‚ 15.199 ms â”‚ 16.265 ms â”‚ 25.906 ms â”‚   2.93 MiB â”‚  15913 â”‚      10 â”‚\nâ”‚           GPU â”‚  (2, 3) â”‚ 13.981 ms â”‚ 18.856 ms â”‚ 18.520 ms â”‚ 20.519 ms â”‚   5.56 MiB â”‚  17974 â”‚      10 â”‚\nâ”‚           GPU â”‚  (2, 5) â”‚ 15.824 ms â”‚ 21.211 ms â”‚ 21.064 ms â”‚ 24.897 ms â”‚   7.86 MiB â”‚  23938 â”‚      10 â”‚\nâ”‚           GPU â”‚ (2, 10) â”‚ 22.085 ms â”‚ 27.236 ms â”‚ 28.231 ms â”‚ 38.295 ms â”‚  15.02 MiB â”‚  31086 â”‚      10 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n  Arbitrary tracers CPU to GPU speedup\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ tracers â”‚ speedup â”‚  memory â”‚  allocs â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  (0, 0) â”‚ 112.881 â”‚ 1.78792 â”‚ 7.44022 â”‚\nâ”‚  (0, 1) â”‚ 112.761 â”‚ 1.77743 â”‚ 7.36045 â”‚\nâ”‚  (0, 2) â”‚ 109.618 â”‚  1.6627 â”‚ 6.96945 â”‚\nâ”‚  (1, 0) â”‚ 110.717 â”‚ 1.77723 â”‚ 7.35221 â”‚\nâ”‚  (2, 0) â”‚ 111.678 â”‚ 1.66267 â”‚ 6.91569 â”‚\nâ”‚  (2, 3) â”‚ 118.737 â”‚ 1.55043 â”‚ 4.57587 â”‚\nâ”‚  (2, 5) â”‚ 133.803 â”‚  1.5155 â”‚ 4.87734 â”‚\nâ”‚ (2, 10) â”‚ 137.615 â”‚ 1.44535 â”‚  4.0466 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n       Arbitrary tracers relative performance (CPU)\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Architectures â”‚ tracers â”‚ slowdown â”‚  memory â”‚  allocs â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚           CPU â”‚  (0, 0) â”‚      1.0 â”‚     1.0 â”‚     1.0 â”‚\nâ”‚           CPU â”‚  (0, 1) â”‚  1.09293 â”‚ 1.39873 â”‚ 1.17271 â”‚\nâ”‚           CPU â”‚  (0, 2) â”‚  1.15948 â”‚ 1.99019 â”‚ 1.38345 â”‚\nâ”‚           CPU â”‚  (1, 0) â”‚  1.06409 â”‚ 1.39873 â”‚ 1.17271 â”‚\nâ”‚           CPU â”‚  (2, 0) â”‚  1.17887 â”‚ 1.99054 â”‚ 1.38949 â”‚\nâ”‚           CPU â”‚  (2, 3) â”‚  1.55493 â”‚ 4.04677 â”‚ 2.37198 â”‚\nâ”‚           CPU â”‚  (2, 5) â”‚  1.97115 â”‚ 5.84537 â”‚ 2.96377 â”‚\nâ”‚           CPU â”‚ (2, 10) â”‚   2.6031 â”‚ 11.7179 â”‚ 4.63889 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n       Arbitrary tracers relative performance (GPU)\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Architectures â”‚ tracers â”‚ slowdown â”‚  memory â”‚  allocs â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚           GPU â”‚  (0, 0) â”‚      1.0 â”‚     1.0 â”‚     1.0 â”‚\nâ”‚           GPU â”‚  (0, 1) â”‚   1.0941 â”‚ 1.39053 â”‚ 1.16013 â”‚\nâ”‚           GPU â”‚  (0, 2) â”‚  1.19399 â”‚ 1.85081 â”‚ 1.29592 â”‚\nâ”‚           GPU â”‚  (1, 0) â”‚  1.08489 â”‚ 1.39037 â”‚ 1.15883 â”‚\nâ”‚           GPU â”‚  (2, 0) â”‚  1.19157 â”‚ 1.85109 â”‚ 1.29153 â”‚\nâ”‚           GPU â”‚  (2, 3) â”‚  1.47824 â”‚ 3.50924 â”‚ 1.45881 â”‚\nâ”‚           GPU â”‚  (2, 5) â”‚  1.66293 â”‚ 4.95474 â”‚ 1.94286 â”‚\nâ”‚           GPU â”‚ (2, 10) â”‚  2.13524 â”‚ 9.47276 â”‚ 2.52301 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜","category":"page"},{"location":"appendix/benchmarks/#Turbulence-closures","page":"Performance benchmarks","title":"Turbulence closures","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"This benchmark tests the performance impacts of various turbulent diffusivity closures and large eddy simulation (LES) models as well as how much speedup they experience going from CPU to GPU.","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Oceananigans v0.58.1\nJulia Version 1.6.0\nCommit f9720dc2eb (2021-03-24 12:55 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake)\nEnvironment:\n  EBVERSIONJULIA = 1.6.0\n  JULIA_DEPOT_PATH = :\n  EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0\n  EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel\n  JULIA_LOAD_PATH = :\n  GPU: Tesla V100-SXM2-32GB\n\n                                                  Turbulence closure benchmarks\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Architectures â”‚                         Closures â”‚       min â”‚    median â”‚      mean â”‚       max â”‚   memory â”‚ allocs â”‚ samples â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚           CPU â”‚ AnisotropicBiharmonicDiffusivity â”‚   3.634 s â”‚   3.637 s â”‚   3.637 s â”‚   3.639 s â”‚ 1.77 MiB â”‚   2316 â”‚       2 â”‚\nâ”‚           CPU â”‚           AnisotropicDiffusivity â”‚   2.045 s â”‚   2.052 s â”‚   2.059 s â”‚   2.079 s â”‚ 1.77 MiB â”‚   2316 â”‚       3 â”‚\nâ”‚           CPU â”‚    AnisotropicMinimumDissipation â”‚   3.240 s â”‚   3.240 s â”‚   3.240 s â”‚   3.241 s â”‚ 2.09 MiB â”‚   2763 â”‚       2 â”‚\nâ”‚           CPU â”‚             IsotropicDiffusivity â”‚   2.342 s â”‚   2.344 s â”‚   2.344 s â”‚   2.345 s â”‚ 1.77 MiB â”‚   2316 â”‚       3 â”‚\nâ”‚           CPU â”‚                 SmagorinskyLilly â”‚   3.501 s â”‚   3.504 s â”‚   3.504 s â”‚   3.507 s â”‚ 2.03 MiB â”‚   2486 â”‚       2 â”‚\nâ”‚           CPU â”‚              TwoDimensionalLeith â”‚   4.813 s â”‚   4.820 s â”‚   4.820 s â”‚   4.828 s â”‚ 1.88 MiB â”‚   2481 â”‚       2 â”‚\nâ”‚           GPU â”‚ AnisotropicBiharmonicDiffusivity â”‚ 24.699 ms â”‚ 24.837 ms â”‚ 26.946 ms â”‚ 46.029 ms â”‚ 3.16 MiB â”‚  29911 â”‚      10 â”‚\nâ”‚           GPU â”‚           AnisotropicDiffusivity â”‚ 16.115 ms â”‚ 16.184 ms â”‚ 16.454 ms â”‚ 18.978 ms â”‚ 2.97 MiB â”‚  17169 â”‚      10 â”‚\nâ”‚           GPU â”‚    AnisotropicMinimumDissipation â”‚ 15.858 ms â”‚ 25.856 ms â”‚ 24.874 ms â”‚ 26.014 ms â”‚ 3.57 MiB â”‚  24574 â”‚      10 â”‚\nâ”‚           GPU â”‚             IsotropicDiffusivity â”‚ 14.442 ms â”‚ 17.415 ms â”‚ 17.134 ms â”‚ 17.513 ms â”‚ 2.99 MiB â”‚  19135 â”‚      10 â”‚\nâ”‚           GPU â”‚                 SmagorinskyLilly â”‚ 16.315 ms â”‚ 23.969 ms â”‚ 23.213 ms â”‚ 24.059 ms â”‚ 3.86 MiB â”‚  24514 â”‚      10 â”‚\nâ”‚           GPU â”‚              TwoDimensionalLeith â”‚ 34.470 ms â”‚ 34.628 ms â”‚ 35.535 ms â”‚ 43.798 ms â”‚ 3.56 MiB â”‚  45291 â”‚      10 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n              Turbulence closure CPU to GPU speedup\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                         Closures â”‚ speedup â”‚  memory â”‚  allocs â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ AnisotropicBiharmonicDiffusivity â”‚ 146.428 â”‚ 1.78781 â”‚ 12.9149 â”‚\nâ”‚           AnisotropicDiffusivity â”‚ 126.804 â”‚ 1.67787 â”‚ 7.41321 â”‚\nâ”‚    AnisotropicMinimumDissipation â”‚ 125.324 â”‚ 1.70856 â”‚ 8.89396 â”‚\nâ”‚             IsotropicDiffusivity â”‚ 134.607 â”‚ 1.69269 â”‚ 8.26209 â”‚\nâ”‚                 SmagorinskyLilly â”‚ 146.187 â”‚ 1.89602 â”‚ 9.86082 â”‚\nâ”‚              TwoDimensionalLeith â”‚ 139.196 â”‚ 1.89218 â”‚ 18.2551 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"This example simulates a two-dimensional oceanic bottom boundary layer in a domain that's tilted with respect to gravity. We simulate the perturbation away from a constant along-slope (y-direction) velocity constant density stratification. This perturbation develops into a turbulent bottom boundary layer due to momentum loss at the bottom boundary modeled with a quadratic drag law.","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"This example illustrates","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"changing the direction of gravitational acceleration in the buoyancy model;\nchanging the axis of rotation for Coriolis forces.","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/#Install-dependencies","page":"Tilted bottom boundary layer","title":"Install dependencies","text":"","category":"section"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"using Pkg\npkg\"add Oceananigans, NCDatasets, CairoMakie\"","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/#The-domain","page":"Tilted bottom boundary layer","title":"The domain","text":"","category":"section"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"We create a grid with finer resolution near the bottom,","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"using Oceananigans\nusing Oceananigans.Units\n\nLx = 200meters\nLz = 100meters\nNx = 64\nNz = 64\n\n# Creates a grid with near-constant spacing `refinement * Lz / Nz`\n# near the bottom:\nrefinement = 1.8 # controls spacing near surface (higher means finer spaced)\nstretching = 10  # controls rate of stretching at bottom\n\n# \"Warped\" height coordinate\nh(k) = (Nz + 1 - k) / Nz\n\n# Linear near-surface generator\nÎ¶(k) = 1 + (h(k) - 1) / refinement\n\n# Bottom-intensified stretching function\nÎ£(k) = (1 - exp(-stretching * h(k))) / (1 - exp(-stretching))\n\n# Generating function\nz_faces(k) = - Lz * (Î¶(k) * Î£(k) - 1)\n\ngrid = RectilinearGrid(topology = (Periodic, Flat, Bounded),\n                       size = (Nx, Nz),\n                       x = (0, Lx),\n                       z = z_faces)","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"64Ã—1Ã—64 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo\nâ”œâ”€â”€ Periodic x âˆˆ [0.0, 200.0)  regularly spaced with Î”x=3.125\nâ”œâ”€â”€ Flat y                     \nâ””â”€â”€ Bounded  z âˆˆ [-0.0, 100.0] variably spaced with min(Î”z)=0.868817, max(Î”z)=6.55496","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Let's make sure the grid spacing is both finer and near-uniform at the bottom,","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"using CairoMakie\n\nscatterlines(zspacings(grid, Center()),\n             axis = (ylabel = \"Depth (m)\",\n                     xlabel = \"Vertical spacing (m)\"))\n","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"(Image: )","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/#Tilting-the-domain","page":"Tilted bottom boundary layer","title":"Tilting the domain","text":"","category":"section"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"We use a domain that's tilted with respect to gravity by","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Î¸ = 3 # degrees","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"3","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"so that x is the along-slope direction, z is the across-slope direction that is perpendicular to the bottom, and the unit vector anti-aligned with gravity is","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"zÌ‚ = (sind(Î¸), 0, cosd(Î¸))","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"(0.052335956242943835, 0, 0.9986295347545738)","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Changing the vertical direction impacts both the gravity_unit_vector for BuoyancyForce as well as the rotation_axis for Coriolis forces,","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"buoyancy = BuoyancyForce(BuoyancyTracer(), gravity_unit_vector = .-zÌ‚)\ncoriolis = ConstantCartesianCoriolis(f = 1e-4, rotation_axis = zÌ‚)","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"ConstantCartesianCoriolis{Float64}: fx = 5.23e-06, fy = 0.00e+00, fz = 9.99e-05","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"where above we used a constant Coriolis parameter f = 10^-4  rms^-1. The tilting also affects the kind of density stratified flows we can model. In particular, a constant density stratification in the tilted coordinate system","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"@inline constant_stratification(x, z, t, p) = p.NÂ² * (x * p.zÌ‚[1] + z * p.zÌ‚[3])","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"constant_stratification (generic function with 1 method)","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"is not periodic in x. Thus we cannot explicitly model a constant stratification on an x-periodic grid such as the one used here. Instead, we simulate periodic perturbations away from the constant density stratification by imposing a constant stratification as a BackgroundField,","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"NÂ² = 1e-5 # sâ»Â² # background vertical buoyancy gradient\nBâˆ_field = BackgroundField(constant_stratification, parameters=(; zÌ‚, NÂ² = NÂ²))","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"BackgroundField{typeof(Main.var\"##2572\".constant_stratification), @NamedTuple{áº‘::Tuple{Float64, Int64, Float64}, NÂ²::Float64}}\nâ”œâ”€â”€ func: constant_stratification (generic function with 1 method)\nâ””â”€â”€ parameters: (áº‘ = (0.052335956242943835, 0, 0.9986295347545738), NÂ² = 1.0e-5)","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"We choose to impose a bottom boundary condition of zero total diffusive buoyancy flux across the seafloor,","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"_z B = _z b + N^2 costheta = 0","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"This shows that to impose a no-flux boundary condition on the total buoyancy field B, we must apply a boundary condition to the perturbation buoyancy b,","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"_z b = - N^2 costheta","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"âˆ‚z_b_bottom = - NÂ² * cosd(Î¸)\nnegative_background_diffusive_flux = GradientBoundaryCondition(âˆ‚z_b_bottom)\nb_bcs = FieldBoundaryConditions(bottom = negative_background_diffusive_flux)","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Oceananigans.FieldBoundaryConditions, with boundary conditions\nâ”œâ”€â”€ west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ bottom: GradientBoundaryCondition: -9.9863e-6\nâ”œâ”€â”€ top: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ””â”€â”€ immersed: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/#Bottom-drag-and-along-slope-interior-velocity","page":"Tilted bottom boundary layer","title":"Bottom drag and along-slope interior velocity","text":"","category":"section"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"We impose bottom drag that follows Moninâ€“Obukhov theory:","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Vâˆ = 0.1 # m sâ»Â¹\nzâ‚€ = 0.1 # m (roughness length)\nÎº = 0.4  # von Karman constant\n\nzâ‚ = first(znodes(grid, Center())) # Closest grid center to the bottom\ncá´° = (Îº / log(zâ‚ / zâ‚€))^2 # Drag coefficient\n\n@inline drag_u(x, t, u, v, p) = - p.cá´° * âˆš(u^2 + (v + p.Vâˆ)^2) * u\n@inline drag_v(x, t, u, v, p) = - p.cá´° * âˆš(u^2 + (v + p.Vâˆ)^2) * (v + p.Vâˆ)\n\ndrag_bc_u = FluxBoundaryCondition(drag_u, field_dependencies=(:u, :v), parameters=(; cá´°, Vâˆ))\ndrag_bc_v = FluxBoundaryCondition(drag_v, field_dependencies=(:u, :v), parameters=(; cá´°, Vâˆ))\n\nu_bcs = FieldBoundaryConditions(bottom = drag_bc_u)\nv_bcs = FieldBoundaryConditions(bottom = drag_bc_v)","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Oceananigans.FieldBoundaryConditions, with boundary conditions\nâ”œâ”€â”€ west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ bottom: FluxBoundaryCondition: ContinuousBoundaryFunction drag_v at (Nothing, Nothing, Nothing)\nâ”œâ”€â”€ top: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ””â”€â”€ immersed: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Note that, similar to the buoyancy boundary conditions, we had to include the background flow in the drag calculation.","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Let us also create BackgroundField for the along-slope interior velocity:","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Vâˆ_field = BackgroundField(Vâˆ)","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"BackgroundField{Float64, Nothing}\nâ”œâ”€â”€ func: 0.1\nâ””â”€â”€ parameters: nothing","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/#Create-the-NonhydrostaticModel","page":"Tilted bottom boundary layer","title":"Create the NonhydrostaticModel","text":"","category":"section"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"We are now ready to create the model. We create a NonhydrostaticModel with a fifth-order UpwindBiased advection scheme and a constant viscosity and diffusivity. Here we use a smallish value of 10^-4  rmm^2 rms^-1.","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Î½ = 1e-4\nÎº = 1e-4\nclosure = ScalarDiffusivity(; Î½, Îº)\n\nmodel = NonhydrostaticModel(; grid, buoyancy, coriolis, closure,\n                            advection = UpwindBiased(order=5),\n                            tracers = :b,\n                            boundary_conditions = (u=u_bcs, v=v_bcs, b=b_bcs),\n                            background_fields = (; b=Bâˆ_field, v=Vâˆ_field))","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 64Ã—1Ã—64 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo\nâ”œâ”€â”€ timestepper: RungeKutta3TimeStepper\nâ”œâ”€â”€ advection scheme: UpwindBiased(order=5)\nâ”œâ”€â”€ tracers: b\nâ”œâ”€â”€ closure: ScalarDiffusivity{ExplicitTimeDiscretization}(Î½=0.0001, Îº=(b=0.0001,))\nâ”œâ”€â”€ buoyancy: BuoyancyTracer with gÌ‚ = (-0.052336, 0.0, -0.99863)\nâ””â”€â”€ coriolis: ConstantCartesianCoriolis{Float64}","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Let's introduce a bit of random noise at the bottom of the domain to speed up the onset of turbulence:","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"noise(x, z) = 1e-3 * randn() * exp(-(10z)^2 / grid.Lz^2)\nset!(model, u=noise, w=noise)","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/#Create-and-run-a-simulation","page":"Tilted bottom boundary layer","title":"Create and run a simulation","text":"","category":"section"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"We are now ready to create the simulation. We begin by setting the initial time step conservatively, based on the smallest grid size of our domain and either an advective or diffusive time scaling, depending on which is shorter.","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Î”tâ‚€ = 0.5 * minimum([minimum_zspacing(grid) / Vâˆ, minimum_zspacing(grid)^2/Îº])\nsimulation = Simulation(model, Î”t = Î”tâ‚€, stop_time = 1day)","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Simulation of NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ Next time step: 4.344 seconds\nâ”œâ”€â”€ Elapsed wall time: 0 seconds\nâ”œâ”€â”€ Wall time per iteration: NaN days\nâ”œâ”€â”€ Stop time: 1 day\nâ”œâ”€â”€ Stop iteration: Inf\nâ”œâ”€â”€ Wall time limit: Inf\nâ”œâ”€â”€ Minimum relative step: 0.0\nâ”œâ”€â”€ Callbacks: OrderedDict with 4 entries:\nâ”‚   â”œâ”€â”€ stop_time_exceeded => 4\nâ”‚   â”œâ”€â”€ stop_iteration_exceeded => -\nâ”‚   â”œâ”€â”€ wall_time_limit_exceeded => e\nâ”‚   â””â”€â”€ nan_checker => }\nâ”œâ”€â”€ Output writers: OrderedDict with no entries\nâ””â”€â”€ Diagnostics: OrderedDict with no entries","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"We use a TimeStepWizard to adapt our time-step,","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"wizard = TimeStepWizard(max_change=1.1, cfl=0.7)\nsimulation.callbacks[:wizard] = Callback(wizard, IterationInterval(4))","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Callback of TimeStepWizard(cfl=0.7, max_Î”t=Inf, min_Î”t=0.0) on IterationInterval(4)","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"and also we add another callback to print a progress message,","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"using Printf\n\nstart_time = time_ns() # so we can print the total elapsed wall time\n\nprogress_message(sim) =\n    @printf(\"Iteration: %04d, time: %s, Î”t: %s, max|w|: %.1e m sâ»Â¹, wall time: %s\\n\",\n            iteration(sim), prettytime(time(sim)),\n            prettytime(sim.Î”t), maximum(abs, sim.model.velocities.w),\n            prettytime((time_ns() - start_time) * 1e-9))\n\nsimulation.callbacks[:progress] = Callback(progress_message, IterationInterval(200))","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Callback of progress_message on IterationInterval(200)","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/#Add-outputs-to-the-simulation","page":"Tilted bottom boundary layer","title":"Add outputs to the simulation","text":"","category":"section"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"We add outputs to our model using the NetCDFWriter, which needs NCDatasets to be loaded:","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"u, v, w = model.velocities\nb = model.tracers.b\nBâˆ = model.background_fields.tracers.b\n\nB = b + Bâˆ\nV = v + Vâˆ\nÏ‰y = âˆ‚z(u) - âˆ‚x(w)\n\noutputs = (; u, V, w, B, Ï‰y)\n\nusing NCDatasets\n\nsimulation.output_writers[:fields] = NetCDFWriter(model, outputs;\n                                                  filename = joinpath(@__DIR__, \"tilted_bottom_boundary_layer.nc\"),\n                                                  schedule = TimeInterval(20minutes),\n                                                  overwrite_existing = true)","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"NetCDFWriter scheduled on TimeInterval(20 minutes):\nâ”œâ”€â”€ filepath: tilted_bottom_boundary_layer.nc\nâ”œâ”€â”€ dimensions: time(0), x_faa(64), x_caa(64), z_aaf(65), z_aac(64)\nâ”œâ”€â”€ 5 outputs: (B, w, Ï‰y, V, u)\nâ”œâ”€â”€ array_type: Array{Float32}\nâ”œâ”€â”€ file_splitting: NoFileSplitting\nâ””â”€â”€ file size: 30.9 KiB","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Now we just run it!","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"run!(simulation)","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"[ Info: Initializing simulation...\nIteration: 0000, time: 0 seconds, Î”t: 4.778 seconds, max|w|: 1.0e-03 m sâ»Â¹, wall time: 14.356 seconds\n[ Info:     ... simulation initialization complete (5.489 seconds)\n[ Info: Executing initial time step...\n[ Info:     ... initial time step complete (4.545 seconds).\nIteration: 0200, time: 3.554 hours, Î”t: 1.431 minutes, max|w|: 5.1e-03 m sâ»Â¹, wall time: 21.908 seconds\nIteration: 0400, time: 8.641 hours, Î”t: 59.252 seconds, max|w|: 9.4e-03 m sâ»Â¹, wall time: 22.755 seconds\nIteration: 0600, time: 12.964 hours, Î”t: 1.248 minutes, max|w|: 5.3e-03 m sâ»Â¹, wall time: 23.620 seconds\nIteration: 0800, time: 16.316 hours, Î”t: 56.663 seconds, max|w|: 8.7e-03 m sâ»Â¹, wall time: 24.425 seconds\nIteration: 1000, time: 19.804 hours, Î”t: 1.133 minutes, max|w|: 6.1e-03 m sâ»Â¹, wall time: 25.265 seconds\nIteration: 1200, time: 23.174 hours, Î”t: 1.035 minutes, max|w|: 9.2e-03 m sâ»Â¹, wall time: 26.075 seconds\n[ Info: Simulation is stopping after running for 15.566 seconds.\n[ Info: Simulation time 1 day equals or exceeds stop time 1 day.\n","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/#Visualize-the-results","page":"Tilted bottom boundary layer","title":"Visualize the results","text":"","category":"section"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"First we load the required package to load NetCDF output files and define the coordinates for plotting using existing objects:","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"using NCDatasets, CairoMakie\n\nxb, yb, zb = nodes(B)\nxÏ‰, yÏ‰, zÏ‰ = nodes(Ï‰y)\nxv, yv, zv = nodes(V)","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"(1.5625:3.125:198.4375, nothing, [0.4344083608847693, 1.303282217470314, 2.1722793473188617, 3.041419168936904, 3.9107241431416084, 4.780220246692868, 5.649937519111903, 6.519910693894487, 7.390179927024476, 8.26079163764491, 9.131799477986252, 10.00326545222724, 10.875261206921866, 11.747869519021842, 12.621186011421164, 13.495321130420056, 14.370402424632783, 15.24657717074116, 16.124015398230675, 17.00291337296054, 17.88349760825156, 18.766029482284154, 19.650810552161538, 20.538188668213625, 21.428565007224726, 22.322402160523495, 23.22023343257072, 24.122673528152244, 25.030430831905008, 25.944321513097137, 26.865285721823064, 27.794406180595843, 28.732929518320184, 29.682290742481506, 30.64414130083751, 31.62038124678409, 32.61319609381579, 33.62509902514256, 34.65897921569778, 35.71815712673464, 36.80644774933731, 37.92823290397964, 39.08854385039015, 40.29315562720595, 41.548694726134066, 42.86276191262984, 44.24407223660885, 45.702614534695954, 47.24983301231516, 48.89883381190526, 50.66461982505285, 52.56435739360966, 54.61767896995204, 56.84702627115933, 59.27803896724765, 61.93999449018695, 64.86630513774502, 68.09507927238374, 71.66975407682737, 75.63980801853194, 80.06156188607441, 84.99907797852119, 90.52516773625328, 96.72251877439135])","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Read in the simulation's output_writer for the two-dimensional fields and then create an animation showing the y-component of vorticity.","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"ds = NCDataset(simulation.output_writers[:fields].filepath, \"r\")\n\nfig = Figure(size = (800, 600))\n\naxis_kwargs = (xlabel = \"Across-slope distance (m)\",\n               ylabel = \"Slope-normal\\ndistance (m)\",\n               limits = ((0, Lx), (0, Lz)),\n               )\n\nax_Ï‰ = Axis(fig[2, 1]; title = \"Along-slope vorticity\", axis_kwargs...)\nax_v = Axis(fig[3, 1]; title = \"Along-slope velocity (v)\", axis_kwargs...)\n\nn = Observable(1)\n\nÏ‰y = @lift ds[\"Ï‰y\"][:, :, $n]\nB = @lift ds[\"B\"][:, :, $n]\nhm_Ï‰ = heatmap!(ax_Ï‰, xÏ‰, zÏ‰, Ï‰y, colorrange = (-0.015, +0.015), colormap = :balance)\nColorbar(fig[2, 2], hm_Ï‰; label = \"sâ»Â¹\")\nct_b = contour!(ax_Ï‰, xb, zb, B, levels=-1e-3:0.5e-4:1e-3, color=:black)\n\nV = @lift ds[\"V\"][:, :, $n]\nV_max = @lift maximum(abs, ds[\"V\"][:, :, $n])\n\nhm_v = heatmap!(ax_v, xv, zv, V, colorrange = (-Vâˆ, +Vâˆ), colormap = :balance)\nColorbar(fig[3, 2], hm_v; label = \"m sâ»Â¹\")\nct_b = contour!(ax_v, xb, zb, B, levels=-1e-3:0.5e-4:1e-3, color=:black)\n\ntimes = collect(ds[\"time\"])\ntitle = @lift \"t = \" * string(prettytime(times[$n]))\nfig[1, :] = Label(fig, title, fontsize=20, tellwidth=false)\n\nfig","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"(Image: )","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Finally, we record a movie.","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"frames = 1:length(times)\n\nrecord(fig, \"tilted_bottom_boundary_layer.mp4\", frames, framerate=12) do i\n    n[] = i\nend","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"(Image: )","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Don't forget to close the NetCDF file!","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"close(ds)","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"closed Dataset","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literated/convecting_plankton/#Plankton-mixing-and-blooming","page":"Convecting plankton","title":"Plankton mixing and blooming","text":"","category":"section"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"In this example, we simulate the mixing of phytoplankton by convection that decreases in time and eventually shuts off, thereby precipitating a phytoplankton bloom. A similar scenario was simulated by Taylor and Ferrari (2011), providing evidence that the \"critical turbulence hypothesis\" explains the explosive bloom of oceanic phytoplankton observed in spring.","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"The phytoplankton in our model are advected, diffuse, grow, and die according to","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"_t P + boldsymbolv cdot nabla P - Îº Â²P = Î¼â‚€ exp(z  Î») - m  P  ","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"where boldsymbolv is the turbulent velocity field, Îº is an isotropic diffusivity,  Î¼â‚€ is the phytoplankton growth rate at the surface, Î» is the scale over which sunlight attenuates away from the surface, and m is the mortality rate of phytoplankton due to viruses and grazing by zooplankton. We use Oceananigans' Forcing abstraction to implement the phytoplankton dynamics described by the right side of the phytoplankton equation above.","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"This example demonstrates","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"How to use a user-defined forcing function to simulate the dynamics of phytoplankton growth in sunlight and grazing by zooplankton.\nHow to set time-dependent boundary conditions.\nHow to use the TimeStepWizard to adapt the simulation time-step.\nHow to use Average to diagnose spatial averages of model fields.","category":"page"},{"location":"literated/convecting_plankton/#Install-dependencies","page":"Convecting plankton","title":"Install dependencies","text":"","category":"section"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"using Pkg\npkg\"add Oceananigans, CairoMakie\"","category":"page"},{"location":"literated/convecting_plankton/#The-grid","page":"Convecting plankton","title":"The grid","text":"","category":"section"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"We use a two-dimensional grid with 64Â² points, 3Â² halo points for high-order advection, 1 m grid spacing, and a Flat y-direction:","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"using Oceananigans\nusing Oceananigans.Units: minutes, hour, hours, day\n\ngrid = RectilinearGrid(size=(64, 64), extent=(64, 64), halo=(3, 3), topology=(Periodic, Flat, Bounded))","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"64Ã—1Ã—64 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo\nâ”œâ”€â”€ Periodic x âˆˆ [0.0, 64.0)  regularly spaced with Î”x=1.0\nâ”œâ”€â”€ Flat y                    \nâ””â”€â”€ Bounded  z âˆˆ [-64.0, 0.0] regularly spaced with Î”z=1.0","category":"page"},{"location":"literated/convecting_plankton/#Boundary-conditions","page":"Convecting plankton","title":"Boundary conditions","text":"","category":"section"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"We impose a surface buoyancy flux that's initially constant and then decays to zero,","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"buoyancy_flux(x, t, params) = params.initial_buoyancy_flux * exp(-t^4 / (24 * params.shut_off_time^4))\n\nbuoyancy_flux_parameters = (initial_buoyancy_flux = 1e-8, # mÂ² sâ»Â³\n                                    shut_off_time = 2hours)\n\nbuoyancy_flux_bc = FluxBoundaryCondition(buoyancy_flux, parameters = buoyancy_flux_parameters)","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"FluxBoundaryCondition: ContinuousBoundaryFunction buoyancy_flux at (Nothing, Nothing, Nothing)","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"The fourth power in the argument of exp above helps keep the buoyancy flux relatively constant during the first phase of the simulation. We produce a plot of this time-dependent buoyancy flux for the visually-oriented,","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"using CairoMakie\nset_theme!(Theme(fontsize = 20, linewidth=3))\n\ntimes = range(0, 12hours, length=100)\n\nfig = Figure(size = (800, 300))\nax = Axis(fig[1, 1]; xlabel = \"Time (hours)\", ylabel = \"Surface buoyancy flux (mÂ² sâ»Â³)\")\n\nflux_time_series = [buoyancy_flux(0, t, buoyancy_flux_parameters) for t in times]\nlines!(ax, times ./ hour, flux_time_series)\n\nfig","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"(Image: )","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"The buoyancy flux effectively shuts off after 6 hours of simulation time.","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"info: The flux convention in Oceananigans.jl\nFluxes are defined by the direction a quantity is carried: positive velocities produce positive fluxes, while negative velocities produce negative fluxes. Diffusive fluxes are defined with the same convention. A positive flux at the top boundary transports buoyancy upwards, out of the domain. This means that a positive flux of buoyancy at the top boundary reduces the buoyancy of near-surface fluid, causing convection.","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"The initial condition and bottom boundary condition impose the constant buoyancy gradient","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"NÂ² = 1e-4 # sâ»Â²\n\nbuoyancy_gradient_bc = GradientBoundaryCondition(NÂ²)","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"GradientBoundaryCondition: 0.0001","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"In summary, the buoyancy boundary conditions impose a destabilizing flux at the top and a stable buoyancy gradient at the bottom:","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"buoyancy_bcs = FieldBoundaryConditions(top = buoyancy_flux_bc, bottom = buoyancy_gradient_bc)","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"Oceananigans.FieldBoundaryConditions, with boundary conditions\nâ”œâ”€â”€ west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ bottom: GradientBoundaryCondition: 0.0001\nâ”œâ”€â”€ top: FluxBoundaryCondition: ContinuousBoundaryFunction buoyancy_flux at (Nothing, Nothing, Nothing)\nâ””â”€â”€ immersed: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)","category":"page"},{"location":"literated/convecting_plankton/#Phytoplankton-dynamics:-light-dependent-growth-and-uniform-mortality","page":"Convecting plankton","title":"Phytoplankton dynamics: light-dependent growth and uniform mortality","text":"","category":"section"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"We use a simple model for the growth of phytoplankton in sunlight and decay due to viruses and grazing by zooplankton,","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"growing_and_grazing(x, z, t, P, params) = (params.Î¼â‚€ * exp(z / params.Î») - params.m) * P","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"with parameters","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"plankton_dynamics_parameters = (Î¼â‚€ = 1/day,   # surface growth rate\n                                 Î» = 5,       # sunlight attenuation length scale (m)\n                                 m = 0.1/day) # mortality rate due to virus and zooplankton grazing","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"(Î¼â‚€ = 1.1574074074074073e-5, Î» = 5, m = 1.1574074074074074e-6)","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"We tell Forcing that our plankton model depends on the plankton concentration P and the chosen parameters,","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"plankton_dynamics = Forcing(growing_and_grazing, field_dependencies = :P,\n                            parameters = plankton_dynamics_parameters)","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"ContinuousForcing{@NamedTuple{Î¼â‚€::Float64, Î»::Int64, m::Float64}}\nâ”œâ”€â”€ func: growing_and_grazing (generic function with 1 method)\nâ”œâ”€â”€ parameters: (Î¼â‚€ = 1.1574074074074073e-5, Î» = 5, m = 1.1574074074074074e-6)\nâ””â”€â”€ field dependencies: (:P,)","category":"page"},{"location":"literated/convecting_plankton/#The-model","page":"Convecting plankton","title":"The model","text":"","category":"section"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"The name \"P\" for phytoplankton is specified in the constructor for NonhydrostaticModel. We additionally specify a fifth-order advection scheme, third-order Runge-Kutta time-stepping, isotropic viscosity and diffusivities, and Coriolis forces appropriate for planktonic convection at mid-latitudes on Earth.","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"model = NonhydrostaticModel(; grid,\n                            advection = UpwindBiased(order=5),\n                            closure = ScalarDiffusivity(Î½=1e-4, Îº=1e-4),\n                            coriolis = FPlane(f=1e-4),\n                            tracers = (:b, :P), # P for Plankton\n                            buoyancy = BuoyancyTracer(),\n                            forcing = (; P=plankton_dynamics),\n                            boundary_conditions = (; b=buoyancy_bcs))","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 64Ã—1Ã—64 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo\nâ”œâ”€â”€ timestepper: RungeKutta3TimeStepper\nâ”œâ”€â”€ advection scheme: UpwindBiased(order=5)\nâ”œâ”€â”€ tracers: (b, P)\nâ”œâ”€â”€ closure: ScalarDiffusivity{ExplicitTimeDiscretization}(Î½=0.0001, Îº=(b=0.0001, P=0.0001))\nâ”œâ”€â”€ buoyancy: BuoyancyTracer with gÌ‚ = NegativeZDirection()\nâ””â”€â”€ coriolis: FPlane{Float64}(f=0.0001)","category":"page"},{"location":"literated/convecting_plankton/#Initial-condition","page":"Convecting plankton","title":"Initial condition","text":"","category":"section"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"We set the initial phytoplankton at P = 1  rmÎ¼M. For buoyancy, we use a stratification that's mixed near the surface and linearly stratified below, superposed with surface-concentrated random noise.","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"mixed_layer_depth = 32 # m\n\nstratification(z) = z < -mixed_layer_depth ? NÂ² * z : - NÂ² * mixed_layer_depth\nnoise(z) = 1e-4 * NÂ² * grid.Lz * randn() * exp(z / 4)\ninitial_buoyancy(x, z) = stratification(z) + noise(z)\n\nset!(model, b=initial_buoyancy, P=1)","category":"page"},{"location":"literated/convecting_plankton/#Simulation-with-adaptive-time-stepping,-logging,-and-output","page":"Convecting plankton","title":"Simulation with adaptive time-stepping, logging, and output","text":"","category":"section"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"We build a simulation","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"simulation = Simulation(model, Î”t=2minutes, stop_time=24hours)","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"Simulation of NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ Next time step: 2 minutes\nâ”œâ”€â”€ Elapsed wall time: 0 seconds\nâ”œâ”€â”€ Wall time per iteration: NaN days\nâ”œâ”€â”€ Stop time: 1 day\nâ”œâ”€â”€ Stop iteration: Inf\nâ”œâ”€â”€ Wall time limit: Inf\nâ”œâ”€â”€ Minimum relative step: 0.0\nâ”œâ”€â”€ Callbacks: OrderedDict with 4 entries:\nâ”‚   â”œâ”€â”€ stop_time_exceeded => 4\nâ”‚   â”œâ”€â”€ stop_iteration_exceeded => -\nâ”‚   â”œâ”€â”€ wall_time_limit_exceeded => e\nâ”‚   â””â”€â”€ nan_checker => }\nâ”œâ”€â”€ Output writers: OrderedDict with no entries\nâ””â”€â”€ Diagnostics: OrderedDict with no entries","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"with a TimeStepWizard that limits the time-step to 2 minutes, and adapts the time-step such that CFL (Courant-Freidrichs-Lewy) number hovers around 1.0,","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"conjure_time_step_wizard!(simulation, cfl=1.0, max_Î”t=2minutes)","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"We also add a callback that prints the progress of the simulation,","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"using Printf\n\nprogress(sim) = @printf(\"Iteration: %d, time: %s, Î”t: %s\\n\",\n                        iteration(sim), prettytime(sim), prettytime(sim.Î”t))\n\nadd_callback!(simulation, progress, IterationInterval(100))","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"and a basic JLD2Writer that writes velocities and both the two-dimensional and horizontally-averaged plankton concentration,","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"outputs = (w = model.velocities.w,\n           P = model.tracers.P,\n           avg_P = Average(model.tracers.P, dims=(1, 2)))\n\nsimulation.output_writers[:simple_output] =\n    JLD2Writer(model, outputs,\n               schedule = TimeInterval(20minutes),\n               filename = \"convecting_plankton.jld2\",\n               overwrite_existing = true)","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"JLD2Writer scheduled on TimeInterval(20 minutes):\nâ”œâ”€â”€ filepath: convecting_plankton.jld2\nâ”œâ”€â”€ 3 outputs: (w, P, avg_P)\nâ”œâ”€â”€ array_type: Array{Float32}\nâ”œâ”€â”€ including: [:grid, :coriolis, :buoyancy, :closure]\nâ”œâ”€â”€ file_splitting: NoFileSplitting\nâ””â”€â”€ file size: 35.3 KiB","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"info: Using multiple output writers\nBecause each output writer is associated with a single output schedule, it often makes sense to use different output writers for different types of output. For example, smaller outputs that consume less disk space may be written more frequently without threatening the capacity of your hard drive. An arbitrary number of output writers may be added to simulation.output_writers.","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"The simulation is set up. Let there be plankton:","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"run!(simulation)","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"[ Info: Initializing simulation...\nIteration: 0, time: 0 seconds, Î”t: 2 minutes\n[ Info:     ... simulation initialization complete (4.350 seconds)\n[ Info: Executing initial time step...\n[ Info:     ... initial time step complete (2.541 seconds).\nIteration: 100, time: 2.454 hours, Î”t: 58.581 seconds\nIteration: 200, time: 3.658 hours, Î”t: 35.753 seconds\nIteration: 300, time: 4.678 hours, Î”t: 43.134 seconds\nIteration: 400, time: 5.825 hours, Î”t: 42.848 seconds\nIteration: 500, time: 7.056 hours, Î”t: 47.596 seconds\nIteration: 600, time: 8.348 hours, Î”t: 49.045 seconds\nIteration: 700, time: 9.872 hours, Î”t: 59.181 seconds\nIteration: 800, time: 11.333 hours, Î”t: 1.072 minutes\nIteration: 900, time: 13.271 hours, Î”t: 1.320 minutes\nIteration: 1000, time: 16.133 hours, Î”t: 2 minutes\nIteration: 1100, time: 19.467 hours, Î”t: 2 minutes\nIteration: 1200, time: 22.800 hours, Î”t: 2 minutes\n[ Info: Simulation is stopping after running for 31.716 seconds.\n[ Info: Simulation time 1 day equals or exceeds stop time 1 day.\n","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"Notice how the time-step is reduced at early times, when turbulence is strong, and increases again towards the end of the simulation when turbulence fades.","category":"page"},{"location":"literated/convecting_plankton/#Visualizing-the-solution","page":"Convecting plankton","title":"Visualizing the solution","text":"","category":"section"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"We'd like to a make a plankton movie. First we load the output file and build a time-series of the buoyancy flux,","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"filepath = simulation.output_writers[:simple_output].filepath\n\nw_timeseries = FieldTimeSeries(filepath, \"w\")\nP_timeseries = FieldTimeSeries(filepath, \"P\")\navg_P_timeseries = FieldTimeSeries(filepath, \"avg_P\")\n\ntimes = w_timeseries.times\nbuoyancy_flux_time_series = [buoyancy_flux(0, t, buoyancy_flux_parameters) for t in times]\nnothing # hide","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"Now, we animate plankton mixing and blooming,","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"using CairoMakie\n\n@info \"Making a movie about plankton...\"\n\nn = Observable(1)\n\ntitle = @lift @sprintf(\"t = %s\", prettytime(times[$n]))\n\nwn = @lift w_timeseries[$n]\nPn = @lift P_timeseries[$n]\navg_Pn = @lift avg_P_timeseries[$n]\n\nw_lim = maximum(abs, interior(w_timeseries))\nw_lims = (-w_lim, w_lim)\n\nP_lims = (0.95, 1.1)\n\nfig = Figure(size = (1200, 1000))\n\nax_w = Axis(fig[2, 2]; xlabel = \"x (m)\", ylabel = \"z (m)\", aspect = 1)\nax_P = Axis(fig[3, 2]; xlabel = \"x (m)\", ylabel = \"z (m)\", aspect = 1)\nax_b = Axis(fig[2, 3]; xlabel = \"Time (hours)\", ylabel = \"Buoyancy flux (mÂ² sâ»Â³)\", yaxisposition = :right)\n\nax_avg_P = Axis(fig[3, 3]; xlabel = \"Plankton concentration (Î¼M)\", ylabel = \"z (m)\", yaxisposition = :right)\nxlims!(ax_avg_P, 0.85, 1.3)\n\nfig[1, 1:3] = Label(fig, title, tellwidth=false)\n\nhm_w = heatmap!(ax_w, wn; colormap = :balance, colorrange = w_lims)\nColorbar(fig[2, 1], hm_w; label = \"Vertical velocity (m sâ»Â¹)\", flipaxis = false)\n\nhm_P = heatmap!(ax_P, Pn; colormap = :matter, colorrange = P_lims)\nColorbar(fig[3, 1], hm_P; label = \"Plankton 'concentration'\", flipaxis = false)\n\nlines!(ax_b, times ./ hour, buoyancy_flux_time_series; linewidth = 1, color = :black, alpha = 0.4)\n\nb_flux_point = @lift Point2(times[$n] / hour, buoyancy_flux_time_series[$n])\nscatter!(ax_b, b_flux_point; marker = :circle, markersize = 16, color = :black)\nlines!(ax_avg_P, avg_Pn)\n\nfig","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"(Image: )","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"And, finally, we record a movie.","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"frames = 1:length(times)\n\n@info \"Making an animation of convecting plankton...\"\n\nrecord(fig, \"convecting_plankton.mp4\", frames, framerate=8) do i\n    n[] = i\nend","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"[ Info: Making an animation of convecting plankton...\n","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"(Image: )","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"This page was generated using Literate.jl.","category":"page"},{"location":"model_setup/lagrangian_particles/#Lagrangian-particle-tracking","page":"Lagrangian particles","title":"Lagrangian particle tracking","text":"","category":"section"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"Models can keep track of the location and properties of neutrally buoyant particles. Particles are advected with the flow field using forward Euler time-stepping at every model iteration.","category":"page"},{"location":"model_setup/lagrangian_particles/#Simple-particles","page":"Lagrangian particles","title":"Simple particles","text":"","category":"section"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"If you just need to keep of particle locations (x y z) then you can construct some Lagrangian particles using the regular LagrangianParticles constructor","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"grid = RectilinearGrid(size=(10, 10, 10), extent=(1, 1, 1))\n\nNparticles = 10\n\nxâ‚€ = zeros(Nparticles)\n\nyâ‚€ = rand(Nparticles)\n\nzâ‚€ = -0.5 * ones(Nparticles)\n\nlagrangian_particles = LagrangianParticles(x=xâ‚€, y=yâ‚€, z=zâ‚€)\n\n# output\n10 LagrangianParticles with eltype Particle:\nâ”œâ”€â”€ 3 properties: (:x, :y, :z)\nâ”œâ”€â”€ particle-wall restitution coefficient: 1.0\nâ”œâ”€â”€ 0 tracked fields: ()\nâ””â”€â”€ dynamics: no_dynamics","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"then pass it to a model constructor","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"model = NonhydrostaticModel(grid=grid, particles=lagrangian_particles)\n\n# output\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 10Ã—10Ã—10 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ timestepper: RungeKutta3TimeStepper\nâ”œâ”€â”€ advection scheme: Centered(order=2)\nâ”œâ”€â”€ tracers: ()\nâ”œâ”€â”€ closure: Nothing\nâ”œâ”€â”€ buoyancy: Nothing\nâ”œâ”€â”€ coriolis: Nothing\nâ””â”€â”€ particles: 10 LagrangianParticles with eltype Particle and properties (:x, :y, :z)","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"warn: Lagrangian particles on GPUs\nRemember to use CuArray instead of regular Array when storing particle locations and properties on the GPU.","category":"page"},{"location":"model_setup/lagrangian_particles/#Custom-particles","page":"Lagrangian particles","title":"Custom particles","text":"","category":"section"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"If you want to keep track of custom properties, such as the species or DNA of a Lagrangian particle representing a microbe in an agent-based model, then you can create your own custom particle type and pass a StructArray to the LagrangianParticles constructor.","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"using Oceananigans\nusing StructArrays\n\nstruct LagrangianMicrobe{T, S, D}\n    x :: T\n    y :: T\n    z :: T\n    species :: S\n    dna :: D\nend\n\nNparticles = 3\n\nxâ‚€ = zeros(Nparticles)\n\nyâ‚€ = rand(Nparticles)\n\nzâ‚€ = -0.5 * ones(Nparticles)\n\nspecies = [:rock, :paper, :scissors]\n\ndna = [\"TATACCCC\", \"CCTAGGAC\", \"CGATTTAA\"]\n\nparticles = StructArray{LagrangianMicrobe}((xâ‚€, yâ‚€, zâ‚€, species, dna));\n\nlagrangian_particles = LagrangianParticles(particles)\n\n# output\n3 LagrangianParticles with eltype LagrangianMicrobe:\nâ”œâ”€â”€ 5 properties: (:x, :y, :z, :species, :dna)\nâ”œâ”€â”€ particle-wall restitution coefficient: 1.0\nâ”œâ”€â”€ 0 tracked fields: ()\nâ””â”€â”€ dynamics: no_dynamics","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"warn: Custom properties on GPUs\nNot all data types can be passed to GPU kernels. If you intend to advect particles on the GPU make sure particle properties consist of only simple data types. The symbols and strings in this example won't work on the GPU.","category":"page"},{"location":"model_setup/lagrangian_particles/#Writing-particle-properties-to-disk","page":"Lagrangian particles","title":"Writing particle properties to disk","text":"","category":"section"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"Particle properties can be written to disk using JLD2 or NetCDF.","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"When writing to JLD2 you can pass model.particles as part of the named tuple of outputs.","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"JLD2Writer(model, (; model.particles), filename=\"particles\", schedule=TimeInterval(15))","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"When writing to NetCDF you should write particles to a separate file as the NetCDF dimensions differ for particle trajectories. You can just pass model.particles straight to NetCDFWriter:","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"NetCDFWriter(model, (; model.particles), filename=\"particles.nc\", schedule=TimeInterval(15))","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"warn: Outputting custom particle properties to NetCDF\nNetCDF does not support arbitrary data types. If you need to write custom particle properties to disk that are not supported by NetCDF then you should use JLD2 (which should support almost any Julia data type).","category":"page"},{"location":"quick_start/#quick_start","page":"Quick start","title":"Quick start","text":"","category":"section"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"This code:","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"using Oceananigans\n\ngrid = RectilinearGrid(size = (128, 128),\n                       x = (0, 2Ï€),\n                       y = (0, 2Ï€),\n                       topology = (Periodic, Periodic, Flat))\n\nmodel = NonhydrostaticModel(; grid, advection=WENO())\n\nÏµ(x, y) = 2rand() - 1\nset!(model, u=Ïµ, v=Ïµ)\n\nsimulation = Simulation(model; Î”t=0.01, stop_iteration=100)\nrun!(simulation)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"runs 100 time steps of a two-dimensional turbulence simulation with 128Â² finite volume cells and a fifth-order upwinded WENO advection scheme. It's quite similar to the two-dimensional turbulence example.","category":"page"},{"location":"quick_start/#Visualization","page":"Quick start","title":"Visualization","text":"","category":"section"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"They say that a Makie visualization is worth a thousand Unicode characters, so let's plot vorticity,","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"using CairoMakie\n\nu, v, w = model.velocities\nÎ¶ = Field(âˆ‚x(v) - âˆ‚y(u))\n\nheatmap(Î¶, axis=(; aspect=1))","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"A few more time-steps, and it's starting to get a little diffuse!","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"simulation.stop_iteration += 400\nrun!(simulation)\n\nheatmap(Î¶, axis=(; aspect=1))","category":"page"},{"location":"quick_start/#They-always-cheat-with-too-simple-\"quick\"-starts","page":"Quick start","title":"They always cheat with too-simple \"quick\" starts","text":"","category":"section"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"Fine, we'll re-run this code on the GPU. But we're a little greedy, so we'll also crank up the resolution, throw in a TimeStepWizard to update simulation.Î”t adaptively, and add a passive tracer initially concentrated in the center of the domain which will make for an even prettier figure of the final state:","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"using Oceananigans\nusing CairoMakie\nusing CUDA\n\ngrid = RectilinearGrid(GPU(),\n                       size = (1024, 1024),\n                       x = (-Ï€, Ï€),\n                       y = (-Ï€, Ï€),\n                       topology = (Periodic, Periodic, Flat))\n\nmodel = NonhydrostaticModel(; grid, advection=WENO(), tracers=:c)\n\nÎ´ = 0.5\ncáµ¢(x, y) = exp(-(x^2 + y^2) / 2Î´^2)\nÏµ(x, y) = 2rand() - 1\nset!(model, u=Ïµ, v=Ïµ, c=cáµ¢)\n\nsimulation = Simulation(model; Î”t=1e-3, stop_time=10)\nconjure_time_step_wizard!(simulation, cfl=0.2, IterationInterval(10))\nrun!(simulation)\n\nu, v, w = model.velocities\nÎ¶ = Field(âˆ‚x(v) - âˆ‚y(u))\n\nfig = Figure(size=(1200, 600))\naxÎ¶ = Axis(fig[1, 1], aspect=1, title=\"vorticity\")\naxc = Axis(fig[1, 2], aspect=1, title=\"tracer\")\nheatmap!(axÎ¶, Î¶, colormap=:balance)\nheatmap!(axc, model.tracers.c)\ncurrent_figure()","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"See how we did that? We passed the positional argument GPU() to RectilinearGrid. (This only works if a GPU is available, of course, and CUDA.jl is configured.)","category":"page"},{"location":"quick_start/#Well,-that-was-tantalizing","page":"Quick start","title":"Well, that was tantalizing","text":"","category":"section"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"But you'll need to know a lot more to become a productive, Oceananigans-wielding computational scientist (spherical grids, forcing, boundary conditions, turbulence closures, output writing, actually labeling your axes... ğŸ¤¯). It'd be best to move on to the one-dimensional diffusion example.","category":"page"},{"location":"physics/nonhydrostatic_model/#Nonhydrostatic-model","page":"Nonhydrostatic model","title":"Nonhydrostatic model","text":"","category":"section"},{"location":"physics/nonhydrostatic_model/","page":"Nonhydrostatic model","title":"Nonhydrostatic model","text":"The NonhydrostaticModel solves the incompressible Navier-Stokes equations under the Boussinesq approximation and an arbitrary number of tracer conservation equations. Physics associated with individual terms in the momentum and tracer conservation equations â€“ the background rotation rate of the equation's reference frame, gravitational effects associated with buoyant tracers under the Boussinesq approximation, generalized stresses and tracer fluxes associated with viscous and diffusive physics, and arbitrary \"forcing functions\" â€“ are determined by the whims of the user.","category":"page"},{"location":"physics/nonhydrostatic_model/#The-momentum-conservation-equation","page":"Nonhydrostatic model","title":"The momentum conservation equation","text":"","category":"section"},{"location":"physics/nonhydrostatic_model/","page":"Nonhydrostatic model","title":"Nonhydrostatic model","text":"The equations governing the conservation of momentum in a rotating fluid, including buoyancy via the Boussinesq approximation and including the averaged effects of surface gravity waves at the top of the domain via the Craik-Leibovich approximation are","category":"page"},{"location":"physics/nonhydrostatic_model/","page":"Nonhydrostatic model","title":"Nonhydrostatic model","text":"    beginalign\n    partial_t boldsymbolv  = - left ( boldsymbolv boldsymbolcdot boldsymbolnabla right ) boldsymbolv\n                        - left ( boldsymbolV boldsymbolcdot boldsymbolnabla right ) boldsymbolv\n                        - left ( boldsymbolv boldsymbolcdot boldsymbolnabla right ) boldsymbolV nonumber \n                         qquad\n                        - left ( boldsymbolf - boldsymbolnabla times boldsymbolu^S right ) times boldsymbolv\n                        - boldsymbolnabla p\n                        + b boldsymbolhat g\n                        - boldsymbolnabla boldsymbolcdot boldsymboltau\n                        + partial_t boldsymbolu^S\n                        + boldsymbolF_v  \n    labeleqmomentum\n    endalign","category":"page"},{"location":"physics/nonhydrostatic_model/","page":"Nonhydrostatic model","title":"Nonhydrostatic model","text":"where b boldsymbolhat g the is the buoyancy (a vector whose default direction is upward), boldsymboltau is the kinematic stress tensor, boldsymbolF_v denotes an internal forcing of the velocity field boldsymbolv, p is the kinematic pressure, boldsymbolu^S is the horizontal, two-dimensional 'Stokes drift' velocity field associated with surface gravity waves, and boldsymbolf is the Coriolis parameter, or the background vorticity associated with the specified rate of rotation of the frame of reference.","category":"page"},{"location":"physics/nonhydrostatic_model/","page":"Nonhydrostatic model","title":"Nonhydrostatic model","text":"The terms that appear on the right-hand side of the momentum conservation equation are (in order):","category":"page"},{"location":"physics/nonhydrostatic_model/","page":"Nonhydrostatic model","title":"Nonhydrostatic model","text":"momentum advection: left ( boldsymbolv boldsymbolcdot boldsymbolnabla right ) boldsymbolv,\nadvection of resolved momentum by the background velocity field boldsymbolV: left ( boldsymbolV boldsymbolcdot boldsymbolnabla right ) boldsymbolv,\nadvection of background momentum by resolved velocity: left ( boldsymbolv boldsymbolcdot boldsymbolnabla right ) boldsymbolV,\nCoriolis: boldsymbolf times boldsymbolv,\nthe effective background rotation rate due to surface waves: - left ( boldsymbolnabla times boldsymbolu^S right ) times boldsymbolv,\nkinematic pressure gradient: boldsymbolnabla p,\nbuoyant acceleration: b,\nvertical unit vector (pointing to the direction opposite to gravity): boldsymbolhat g,\nmolecular or turbulence viscous stress: boldsymbolnabla boldsymbolcdot boldsymboltau,\na source of momentum due to forcing or damping of surface waves: partial_t boldsymbolu^S, and\nan arbitrary internal source of momentum: boldsymbolF_v.","category":"page"},{"location":"physics/nonhydrostatic_model/#The-tracer-conservation-equation","page":"Nonhydrostatic model","title":"The tracer conservation equation","text":"","category":"section"},{"location":"physics/nonhydrostatic_model/","page":"Nonhydrostatic model","title":"Nonhydrostatic model","text":"The conservation law for tracers is","category":"page"},{"location":"physics/nonhydrostatic_model/","page":"Nonhydrostatic model","title":"Nonhydrostatic model","text":"    beginalign\n    partial_t c = - boldsymbolv boldsymbolcdot boldsymbolnabla c\n                   - boldsymbolV boldsymbolcdot boldsymbolnabla c\n                   - boldsymbolv boldsymbolcdot boldsymbolnabla C\n                   - boldsymbolnabla boldsymbolcdot boldsymbolq_c\n                   + F_c  \n    labeleqtracer\n    endalign","category":"page"},{"location":"physics/nonhydrostatic_model/","page":"Nonhydrostatic model","title":"Nonhydrostatic model","text":"where boldsymbolq_c is the diffusive flux of c and F_c is an arbitrary source term. An arbitrary tracers are permitted and thus an arbitrary number of tracer equations can be solved simultaneously alongside with the momentum equations.","category":"page"},{"location":"physics/nonhydrostatic_model/","page":"Nonhydrostatic model","title":"Nonhydrostatic model","text":"From left to right, the terms that appear on the right-hand side of the tracer conservation equation are","category":"page"},{"location":"physics/nonhydrostatic_model/","page":"Nonhydrostatic model","title":"Nonhydrostatic model","text":"tracer advection: boldsymbolv boldsymbolcdot boldsymbolnabla c,\ntracer advection by the background velocity field, boldsymbolV: boldsymbolV boldsymbolcdot boldsymbolnabla c,\nadvection of the background tracer field, C, by the resolved velocity field: boldsymbolv boldsymbolcdot boldsymbolnabla C,\nmolecular or turbulent diffusion: boldsymbolnabla boldsymbolcdot boldsymbolq_c, and\nan arbitrary internal source of tracer: F_c.","category":"page"},{"location":"model_setup/overview/#Models","page":"Overview","title":"Models","text":"","category":"section"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"In general in Oceananigans, the \"model\" object serves two main purposes:","category":"page"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"models store the configuration of a set of discrete equations. The discrete equations imply rules for evolving prognostic variables, and computing diagnostic variables from the prognostic state.\nmodels provide a container for the prognostic and diagnostic state of those discrete equations at a particular time.","category":"page"},{"location":"model_setup/overview/#Two-Oceananigans-models-for-ocean-simulations","page":"Overview","title":"Two Oceananigans models for ocean simulations","text":"","category":"section"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"In addition to defining the abstract concept of a \"model\" that can be used with Simulation, Oceananigans provides two mature model implementations for simulating ocean-flavored fluid dynamics. Both of these integrate the Navier-Stokes equations within the Boussinesq approximation (we call these the \"Boussinesq equations\" for short): the NonhydrostaticModel and the HydrostaticFreeSurfaceModel.","category":"page"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"The NonhydrostaticModel integrates the Boussinesq equations without making the hydrostatic approximation, and therefore possessing a prognostic vertical momentum equation. The NonhydrostaticModel is useful for simulations that resolve three-dimensional turbulence, such as large eddy simulations on RectilinearGrid with grid spacings of O(1 m), as well as direct numerical simulation. The NonhydrostaticModel may also be used for idealized classroom problems, as in the two-dimensional turbulence example.","category":"page"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"The HydrostaticFreeSurfaceModel integrates the hydrostatic or \"primitive\" Boussinesq equations with a free surface on its top boundary. The hydrostatic approximation allosw the HydrostaticFreeSurfaceModel to achieve much higher efficiency in simulations on curvilinear grids used for large-scale regional or global simulations such as LatitudeLongitudeGrid, TripolarGrid, ConformalCubedSphereGrid, and other OrthogonalSphericalShellGrids such as RotatedLatitudeLongitudeGrid. Because they span larger domains, simulations with the HydrostaticFreeSurfaceModel also usually involve coarser grid spacings of O(30 m) up to O(100 km). Such coarse-grained simulations are usually paired with more elaborate turbulence closures or \"parameterizations\" than small-scale simulations with NonhydrostaticModel, such as the vertical mixing schemes CATKEVerticalDiffusivity, RiBasedVerticalDiffusivity, and TKEDissipationVerticalDiffusivity, and the mesoscale turbulence closure IsopycnalSkewSymmetricDiffusivity (a.k.a. \"Gent-McWilliams plus Redi\").","category":"page"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"A third, experimental ShallowWaterModel solves the shallow water equations.","category":"page"},{"location":"model_setup/overview/#Configuring-NonhydrostaticModel-with-keyword-arguments","page":"Overview","title":"Configuring NonhydrostaticModel with keyword arguments","text":"","category":"section"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"To illustrate the specification of discrete equations, consider first the docstring for NonhydrostaticModel,","category":"page"},{"location":"model_setup/overview/#Oceananigans.Models.NonhydrostaticModels.NonhydrostaticModel","page":"Overview","title":"Oceananigans.Models.NonhydrostaticModels.NonhydrostaticModel","text":"NonhydrostaticModel(;           grid,\n                                clock = Clock{eltype(grid)}(time = 0),\n                            advection = Centered(),\n                             buoyancy = nothing,\n                             coriolis = nothing,\n                         stokes_drift = nothing,\n                  forcing::NamedTuple = NamedTuple(),\n                              closure = nothing,\n      boundary_conditions::NamedTuple = NamedTuple(),\n                              tracers = (),\n                          timestepper = :RungeKutta3,\n        background_fields::NamedTuple = NamedTuple(),\n        particles::ParticlesOrNothing = nothing,\nbiogeochemistry::AbstractBGCOrNothing = nothing,\n                           velocities = nothing,\n              nonhydrostatic_pressure = CenterField(grid),\n         hydrostatic_pressure_anomaly = DefaultHydrostaticPressureAnomaly(),\n                   diffusivity_fields = nothing,\n                      pressure_solver = nothing,\n                     auxiliary_fields = NamedTuple())\n\nConstruct a model for a non-hydrostatic, incompressible fluid on grid, using the Boussinesq approximation when buoyancy != nothing. By default, all Bounded directions are rigid and impenetrable.\n\nKeyword arguments\n\ngrid: (required) The resolution and discrete geometry on which the model is solved. The         architecture (CPU/GPU) that the model is solved on is inferred from the architecture         of the grid. Note that the grid needs to be regularly spaced in the horizontal         dimensions, x and y.\nadvection: The scheme that advects velocities and tracers. See Oceananigans.Advection.\nbuoyancy: The buoyancy model. See Oceananigans.BuoyancyFormulations.\ncoriolis: Parameters for the background rotation rate of the model.\nstokes_drift: Parameters for Stokes drift fields associated with surface waves. Default: nothing.\nforcing: NamedTuple of user-defined forcing functions that contribute to solution tendencies.\nclosure: The turbulence closure for model. See Oceananigans.TurbulenceClosures.\nboundary_conditions: NamedTuple containing field boundary conditions.\ntracers: A tuple of symbols defining the names of the modeled tracers, or a NamedTuple of            preallocated CenterFields.\ntimestepper: A symbol that specifies the time-stepping method. Either :QuasiAdamsBashforth2 or                :RungeKutta3 (default).\nbackground_fields: NamedTuple with background fields (e.g., background flow). Default: nothing.\nparticles: Lagrangian particles to be advected with the flow. Default: nothing.\nbiogeochemistry: Biogeochemical model for tracers.\nvelocities: The model velocities. Default: nothing.\nnonhydrostatic_pressure: The nonhydrostatic pressure field. Default: CenterField(grid).\nhydrostatic_pressure_anomaly: An optional field that stores the part of the nonhydrostatic pressure                                 in hydrostatic balance with the buoyancy field. If CenterField(grid) (default), the anomaly is precomputed by                                 vertically integrating the buoyancy field. In this case, the nonhydrostatic_pressure represents                                 only the part of pressure that deviates from the hydrostatic anomaly. If nothing, the anomaly                                 is not computed.\ndiffusivity_fields: Diffusivity fields. Default: nothing.\npressure_solver: Pressure solver to be used in the model. If nothing (default), the model constructor chooses the default based on the grid provide.\nauxiliary_fields: NamedTuple of auxiliary fields. Default: nothing\n\n\n\n\n\n","category":"type"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"The configuration operations for NonhydrostaticModel include \"discretization choices\", such as the advection scheme, as well as aspects of the continuous underlying equations, such as the formulation of the buoyancy force.","category":"page"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"For our first example, we build  the default NonhydrostaticModel (which is quite boring):","category":"page"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"using Oceananigans\ngrid = RectilinearGrid(size=(8, 8, 8), extent=(8, 8, 8))\nnh = NonhydrostaticModel(; grid)","category":"page"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"The default NonhydrostaticModel has no tracers, no buoyancy force, no Coriolis force, and a second-order advection scheme. We next consider a slightly more exciting NonhydrostaticModel configured with a WENO advection scheme, the temperature/salinity-based SeawaterBuoyancy, a boundary condition on the zonal momentum, and a passive tracer forced by a cooked-up surface flux called \"c\":","category":"page"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"using Oceananigans\n\ngrid = RectilinearGrid(size=(128, 128), halo=(5, 5), x=(0, 256), z=(-128, 0),\n                       topology = (Periodic, Flat, Bounded))\n\n# Numerical method and physics choices\nadvection = WENO(order=9) # ninthâ€‘order upwind for momentum and tracers\nbuoyancy = BuoyancyTracer()\ncoriolis = FPlane(f=1e-4)\n\nÏ„x = - 8e-5 # mÂ² sâ»Â² (Ï„â‚“ < 0 âŸ¹ eastward wind stress)\nu_bcs = FieldBoundaryConditions(top=FluxBoundaryCondition(Ï„x))\n\n@inline Jc(x, t, Lx) = cos(2Ï€ / Lx * x)\nc_bcs = FieldBoundaryConditions(top=FluxBoundaryCondition(Jc, parameters=grid.Lx))\n\nmodel = NonhydrostaticModel(; grid, advection, buoyancy, coriolis,\n                            tracers = (:b, :c),\n                            boundary_conditions = (; u=u_bcs, c=c_bcs))","category":"page"},{"location":"model_setup/overview/#Mutation-of-the-model-state","page":"Overview","title":"Mutation of the model state","text":"","category":"section"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"In addition to providing an interface for configuring equations, models also store the prognostic and diagnostic state associated with the solution to those equations. Models thus also provide an interface for \"setting\" or fixing the prognostic state, which is typically invoked to determine the initial conditions of a simulation. To illustrate this we consider setting the above model to a stably-stratified and noisy condition:","category":"page"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"NÂ² = 1e-5\nbáµ¢(x, z) = NÂ² * z + 1e-6 * randn()\nuáµ¢(x, z) = 1e-3 * randn()\nset!(model, b=báµ¢, u=uáµ¢, w=uáµ¢)\n\nmodel.tracers.b","category":"page"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"Invoking set! above determine the model tracer b and the velocity components u and w. set! also computes the diagnostic state of a model, which in the case of NonhydrostaticModel includes the nonhydrostatic component of pressure,","category":"page"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"model.pressures.pNHS","category":"page"},{"location":"model_setup/overview/#Evolving-models-in-time","page":"Overview","title":"Evolving models in time","text":"","category":"section"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"Model may be integrated or \"stepped forward\" in time by calling time_step!(model, Î”t), where Î”t is the time step and thus advancing the model.clock:","category":"page"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"time_step!(model, 1)\nmodel.clock","category":"page"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"However, users are strongly encouraged to use the Simulation interface to manage time-stepping along with other activities, like monitoring progress, writing output to disk, and more.","category":"page"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"simulation = Simulation(model, Î”t=1, stop_iteration=10)\nrun!(simulation)\n\nsimulation","category":"page"},{"location":"model_setup/overview/#Using-the-HydrostaticFreeSurfaceModel","page":"Overview","title":"Using the HydrostaticFreeSurfaceModel","text":"","category":"section"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"The HydrostaticFreeSurfaceModel has a similar interface as the NonhydrostaticModel,","category":"page"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"using Oceananigans\ngrid = RectilinearGrid(size=(8, 8, 8), extent=(1, 1, 1))\nmodel = HydrostaticFreeSurfaceModel(; grid) # default free surface, no tracers","category":"page"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"The full array of keyword arguments used to configure a HydrostaticFreeSurfaceModel are detailed in the docstring for HydrostaticFreeSurfaceModel,","category":"page"},{"location":"model_setup/overview/#Oceananigans.Models.HydrostaticFreeSurfaceModels.HydrostaticFreeSurfaceModel","page":"Overview","title":"Oceananigans.Models.HydrostaticFreeSurfaceModels.HydrostaticFreeSurfaceModel","text":"HydrostaticFreeSurfaceModel(; grid,\n                            clock = Clock{Float64}(time = 0),\n                            momentum_advection = VectorInvariant(),\n                            tracer_advection = Centered(),\n                            buoyancy = SeawaterBuoyancy(eltype(grid)),\n                            coriolis = nothing,\n                            free_surface = [default_free_surface],\n                            forcing::NamedTuple = NamedTuple(),\n                            closure = nothing,\n                            timestepper = :QuasiAdamsBashforth2,\n                            boundary_conditions::NamedTuple = NamedTuple(),\n                            tracers = (:T, :S),\n                            particles::ParticlesOrNothing = nothing,\n                            biogeochemistry::AbstractBGCOrNothing = nothing,\n                            velocities = nothing,\n                            pressure = nothing,\n                            diffusivity_fields = nothing,\n                            auxiliary_fields = NamedTuple(),\n                            vertical_coordinate = default_vertical_coordinate(grid))\n\nConstruct a hydrostatic model with a free surface on grid.\n\nKeyword arguments\n\ngrid: (required) The resolution and discrete geometry on which model is solved. The         architecture (CPU/GPU) that the model is solved is inferred from the architecture         of the grid.\nmomentum_advection: The scheme that advects velocities. See Oceananigans.Advection.\ntracer_advection: The scheme that advects tracers. See Oceananigans.Advection.\nbuoyancy: The buoyancy model. See Oceananigans.BuoyancyFormulations.\ncoriolis: Parameters for the background rotation rate of the model.\nfree_surface: The free surface model. The default free-surface solver depends on the                 geometry of the grid. If the grid is a RectilinearGrid that is                 regularly spaced in the horizontal the default is an ImplicitFreeSurface                 solver with solver_method = :FFTBasedPoissonSolver. In all other cases,                 the default is a SplitExplicitFreeSurface.\ntracers: A tuple of symbols defining the names of the modeled tracers, or a NamedTuple of            preallocated CenterFields.\nforcing: NamedTuple of user-defined forcing functions that contribute to solution tendencies.\nclosure: The turbulence closure for model. See Oceananigans.TurbulenceClosures.\ntimestepper: A symbol that specifies the time-stepping method.                Either :QuasiAdamsBashforth2 (default) or :SplitRungeKutta3.\nboundary_conditions: NamedTuple containing field boundary conditions.\nparticles: Lagrangian particles to be advected with the flow. Default: nothing.\nbiogeochemistry: Biogeochemical model for tracers.\nvelocities: The model velocities. Default: nothing.\npressure: Hydrostatic pressure field. Default: nothing.\ndiffusivity_fields: Diffusivity fields. Default: nothing.\nauxiliary_fields: NamedTuple of auxiliary fields. Default: nothing.\nvertical_coordinate: Algorithm for grid evolution: ZStarCoordinate() or ZCoordinate(grid).                        Default: default_vertical_coordinate(grid), which returns ZStarCoordinate(grid)                        for grids with MutableVerticalDiscretization otherwise returns                        ZCoordinate().\n\n\n\n\n\n","category":"type"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"A bit more involved HydrostaticFreeSurfaceModel example:","category":"page"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"using Oceananigans\nusing SeawaterPolynomials: TEOS10EquationOfState\n\ngrid = LatitudeLongitudeGrid(size = (180, 80, 10),\n                             longitude = (0, 360),\n                             latitude = (-80, 80),\n                             z = (-1000, 0),\n                             halo = (6, 6, 3))\n\nmomentum_advection = WENOVectorInvariant()\ncoriolis = HydrostaticSphericalCoriolis()\nequation_of_state = TEOS10EquationOfState()\nbuoyancy = SeawaterBuoyancy(; equation_of_state)\nclosure = CATKEVerticalDiffusivity()\n\n# Generate a zonal wind stress that mimics Earth's mean winds\n# with westerlies in mid-latitudes and easterlies near equator and poles\nfunction zonal_wind_stress(Î», Ï†, t)\n    # Parameters\n    Ï„â‚€ = 1e-4  # Maximum wind stress magnitude (N/mÂ²)\n    Ï†â‚€ = 30   # Latitude of maximum westerlies (degrees)\n    dÏ† = 10\n\n    # Approximate wind stress pattern\n    return - Ï„â‚€ * (+ exp(-(Ï† - Ï†â‚€)^2 / 2dÏ†^2)\n                   - exp(-(Ï† + Ï†â‚€)^2 / 2dÏ†^2)\n                   - 0.3 * exp(-Ï†^2 / dÏ†^2))\nend\n\nu_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(zonal_wind_stress))\n\nmodel = HydrostaticFreeSurfaceModel(; grid, momentum_advection, coriolis, closure, buoyancy,\n                                    boundary_conditions = (; u=u_bcs), tracers=(:T, :S, :e))","category":"page"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"Mutating the state of the HydrostaticFreeSurfaceModel works similarly as for the NonhydrostaticModel â€“- except that the vertical velocity cannot be set!, because vertical velocity is not prognostic in the hydrostatic equations.","category":"page"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"using SeawaterPolynomials\n\nNÂ² = 1e-5\nTâ‚€ = 20\nSâ‚€ = 35\neos = model.buoyancy.formulation.equation_of_state\nÎ± = SeawaterPolynomials.thermal_expansion(Tâ‚€, Sâ‚€, 0, eos)\ng = model.buoyancy.formulation.gravitational_acceleration\ndTdz = NÂ² / (Î± * g)\nTáµ¢(Î», Ï†, z) = Tâ‚€ + dTdz * z + 1e-3 * Tâ‚€ * randn()\nuáµ¢(Î», Ï†, z) = 1e-3 * randn()\nset!(model, T=Táµ¢, S=Sâ‚€, u=uáµ¢, v=uáµ¢)\n\nmodel.tracers.T","category":"page"},{"location":"model_setup/overview/#Where-to-go-next","page":"Overview","title":"Where to go next","text":"","category":"section"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"See Quick start for a compact, end-to-end workflow\nSee the Examples gallery for longer tutorials covering specific cases, including large eddy simulation, Kelvinâ€“Helmholtz instability and baroclinic instability.\nOther pages in the Models section: inâ€‘depth pages on buoyancy, forcing, boundary conditions, closures, diagnostics, and output.\nPhysics: governing equations and numerical forms for NonhydrostaticModel and HydrostaticFreeSurfaceModel.","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/#Buoyancy-model-and-equations-of-state","page":"Buoyancy models and equations of state","title":"Buoyancy model and equations of state","text":"","category":"section"},{"location":"physics/buoyancy_and_equations_of_state/","page":"Buoyancy models and equations of state","title":"Buoyancy models and equations of state","text":"The buoyancy model determines the relationship between tracers and the buoyancy b in the momentum equation.","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/#Buoyancy-tracer","page":"Buoyancy models and equations of state","title":"Buoyancy tracer","text":"","category":"section"},{"location":"physics/buoyancy_and_equations_of_state/","page":"Buoyancy models and equations of state","title":"Buoyancy models and equations of state","text":"The simplest buoyancy model uses buoyancy b itself as a tracer: b obeys the tracer conservation equation and is used directly in the momentum equations.","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/#Seawater-buoyancy","page":"Buoyancy models and equations of state","title":"Seawater buoyancy","text":"","category":"section"},{"location":"physics/buoyancy_and_equations_of_state/","page":"Buoyancy models and equations of state","title":"Buoyancy models and equations of state","text":"For seawater buoyancy is, in general, modeled as a function of conservative temperature T, absolute salinity S, and depth below the ocean surface d via","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/","page":"Buoyancy models and equations of state","title":"Buoyancy models and equations of state","text":"    beginequation\n    b = - fracgrho_0 rho left (T S d right )  \n    labeleqseawater-buoyancy\n    endequation","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/","page":"Buoyancy models and equations of state","title":"Buoyancy models and equations of state","text":"where g is gravitational acceleration, rho_0 is the reference density. The function rho(T S d) in the seawater buoyancy relationship that links conservative temperature, salinity, and depth to the density perturbation is called the equation of state. Both T and S obey the tracer conservation equation.","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/#Linear-equation-of-state","page":"Buoyancy models and equations of state","title":"Linear equation of state","text":"","category":"section"},{"location":"physics/buoyancy_and_equations_of_state/","page":"Buoyancy models and equations of state","title":"Buoyancy models and equations of state","text":"Buoyancy is determined from a linear equation of state via","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/","page":"Buoyancy models and equations of state","title":"Buoyancy models and equations of state","text":"    b = g left ( alpha T - beta S right )  ","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/","page":"Buoyancy models and equations of state","title":"Buoyancy models and equations of state","text":"where g is gravitational acceleration, alpha is the thermal expansion coefficient, and beta is the haline contraction coefficient.","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/#Nonlinear-equation-of-state","page":"Buoyancy models and equations of state","title":"Nonlinear equation of state","text":"","category":"section"},{"location":"physics/buoyancy_and_equations_of_state/","page":"Buoyancy models and equations of state","title":"Buoyancy models and equations of state","text":"Buoyancy is determined by the simplified equations of state introduced by Roquet et al. (2015).","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/#generalized_vertical_coordinates","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"","category":"section"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"Often the numerics benefit from using a vertical coordinate that is different than z and which, in general, even be moving (vary in time).","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"We denote any such generalized vertical coordinate that evolves with space and time as r(x y z t). The generalized vertical coordinate must vary monotonically with z.","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"Transforming the equations of motions (including their discrete analogues) in this new generalized coordinate involves a series of chain rules for partial differentiation. We have that for any field phi:","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"beginalign\n    fracpartial phipartial z  = fracpartial rpartial z fracpartial phipartial r labeldphidz \n    fracpartial phipartial r  = fracpartial zpartial r fracpartial phipartial z\nendalign","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"The quantity partial zpartial r plays a central role in what follows. We refer to it as \"specific thickness\" and denote it sigma:","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"sigma equiv fracpartial zpartial r biggrvert_x y t = left(fracpartial rpartial z biggrvert_x y tright)^-1","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"where the subscripts next to vert denote the quantities that remain constant in the differentiation.","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"The chain rules for differentiation with respect of x, y, or t become:","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"beginalign\n    fracpartial phipartial s biggrvert_z  = fracpartial phipartial sbiggrvert_r + fracpartial phipartial r fracpartial rpartial s labeldphids\nendalign","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"The horizontal spatial derivatives of the r-coordinate are then rewritten, e.g.,","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"beginequation\n    fracpartial rpartial x biggrvert_y z t = - fracpartial zpartial x biggrvert_y r t frac1sigma labeldrdx\nendequation","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"so that the chain rule \\eqref{dphids} above becomes","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"beginalign\n    fracpartial phipartial x biggrvert_z  = fracpartial phipartial xbiggrvert_r - frac1sigmafracpartial phipartial r fracpartial zpartial x labeldphidx\nendalign","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"Similarly, we get equivalent expressions for y derivatives as in \\eqref{drdx} and \\eqref{dphidx}.","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/#Mass-conservation","page":"Generalized vertical coordinates","title":"Mass conservation","text":"","category":"section"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"With the Boussinesq approximation, the mass conservation reduces to the flow  being divergence-less, i.e., boldsymbolnabla boldsymbolcdot boldsymbolv = boldsymbolnabla_h boldsymbolcdot boldsymbolu + partial_z w = 0.","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"Using the chair rules above, the divergence of the flow in r-coordinates becomes:","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"beginalign\n    boldsymbolnabla boldsymbolcdot boldsymbolv  = fracpartial upartial x biggrvert_z + fracpartial vpartial y biggrvert_z + fracpartial wpartial z nonumber \n     = fracpartial upartial x biggrvert_r + fracpartial vpartial y biggrvert_r - frac1sigma left( fracpartial upartial r fracpartial zpartial x + fracpartial vpartial r fracpartial zpartial y - fracpartial wpartial r right) nonumber \n     = frac1sigma left( fracpartial sigma upartial x biggrvert_r + fracpartial sigma vpartial y biggrvert_r - u fracpartial sigmapartial x biggrvert_r - v fracpartial sigmapartial y biggrvert_r right)- frac1sigma left( fracpartial upartial r fracpartial zpartial x + fracpartial vpartial y fracpartial zpartial y - fracpartial wpartial r right)\nendalign","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"We can rewrite partial_x sigma rvert_r = partial_r(partial_x z) and similarly for the y direction. After a bit of reordering the above yields","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"beginequation\n    boldsymbolnabla boldsymbolcdot boldsymbolv = frac1sigma left( fracpartial sigma upartial x biggrvert_r + fracpartial sigma vpartial ybiggrvert_r right) + frac1sigma fracpartialpartial r left( u fracpartial zpartial x + v fracpartial zpartial y + w right) labeldiv1\nendequation","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"Note that w above is the vertical velocity referenced to the z coordinate. The vertical velocity w_r of the r surface referenced to the z coordinate as","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"w_r equiv fracpartial zpartial t biggrvert_r + u fracpartial zpartial x + v fracpartial zpartial y","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"Then, the vertical velocity across the r surfaces is the difference between w and w_r","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"beginalign\n    omega  equiv w - w_r nonumber \n            = w - fracpartial zpartial t biggrvert_r - u fracpartial zpartial x - v fracpartial zpartial y labeldef_omega\nendalign","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"With the definition of omega in \\eqref{div1} we get","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"beginalign\n    boldsymbolnabla boldsymbolcdot boldsymbolv  = frac1sigma left( fracpartial sigma upartial x biggrvert_r + fracpartial sigma vpartial ybiggrvert_r right) + frac1sigma fracpartialpartial r left( omega + fracpartial zpartial tbiggrvert_r right) nonumber \n     = frac1sigma left( fracpartial sigma upartial x biggrvert_r + fracpartial sigma vpartial ybiggrvert_r right) + frac1sigma fracpartial omegapartial r + frac1sigma fracpartial sigmapartial t\nendalign","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"which implies that the mass conservation is equivalent to:","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"beginequation\n    fracpartial sigmapartial t + fracpartial sigma upartial x biggrvert_r + fracpartial sigma vpartial ybiggrvert_r + fracpartial omegapartial r = 0 labelmassconservationr\nendequation","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/#Tracer-equation","page":"Generalized vertical coordinates","title":"Tracer equation","text":"","category":"section"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"The evolution equation for a tracer c, which also includes vertical diffusion, reads","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"beginequation\n    fracpartial cpartial tbiggrvert_z + boldsymbolnabla boldsymbolcdot (boldsymbolu c) = fracpartialpartial z left( kappa fracpartial cpartial z right) labeltracereq\nendequation","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"Using the same procedure we followed for the continuity equation, the left-hand-side of \\eqref{tracereq} yields:","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"beginalign\n    fracpartial cpartial tbiggrvert_z  + boldsymbolnabla boldsymbolcdot (boldsymbolu c) = nonumber \n     = fracpartial cpartial tbiggrvert_z + frac1sigma left( fracpartial sigma u cpartial x biggrvert_r + fracpartial sigma v Tpartial ybiggrvert_r right) + frac1sigma fracpartialpartial rleft(c omega + c fracpartial zpartial tbiggrvert_r right) nonumber \n     = fracpartial cpartial tbiggrvert_z + frac1sigma left( fracpartial sigma u cpartial x biggrvert_r + fracpartial sigma v cpartial ybiggrvert_r right) + fraccsigma left( fracpartial omegapartial r + fracpartial sigmapartial tbiggrvert_r right) + frac1sigma left( omega + fracpartial zpartial tbiggrvert_r right)fracpartial cpartial r nonumber\n     = fracpartial cpartial tbiggrvert_z + frac1sigma left( fracpartial sigma u cpartial x biggrvert_r + fracpartial sigma v cpartial ybiggrvert_r right) + frac1sigma fracpartial omega cpartial r + fraccsigma fracpartial sigmapartial tbiggrvert_r + frac1sigma fracpartial zpartial tbiggrvert_r fracpartial cpartial r\nendalign","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"We recover the time derivative of the tracer at constant r by rewriting the last term using the chain rule for a time derivatives:","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"frac1sigma  fracpartial zpartial tbiggrvert_r fracpartial cpartial r = fracpartial rpartial t fracpartial cpartial r = fracpartial cpartial tbiggrvert_r - fracpartial cpartial tbiggrvert_z","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"As such, the left-hand-side of \\eqref{tracereq} can be rewritten in r-coordinates as","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"    frac1sigmafracpartial sigma cpartial tbiggrvert_r + frac1sigma left( fracpartial sigma u cpartial x biggrvert_r + fracpartial sigma v cpartial ybiggrvert_r right) + frac1sigma fracpartial omega cpartial r","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"Including the vertical diffusion to the right-hand side we recover the tracer equation:","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"beginequation\n    frac1sigmafracpartial sigma cpartial t biggrvert_r + frac1sigma left( fracpartial sigma u cpartial x biggrvert_r + fracpartial sigma v cpartial ybiggrvert_r right) + frac1sigma fracpartial c omegapartial r = frac1sigmafracpartialpartial r left( kappa fracpartial cpartial z right) labeltracerrcoord\nendequation","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/#Momentum-equations-in-vector-invariant-form","page":"Generalized vertical coordinates","title":"Momentum equations in vector invariant form","text":"","category":"section"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"The horizontal momentum equations under the hydrostatic approximation read","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"beginequation\n    fracmathrmD boldsymbolumathrmDt biggrvert_z + f hatboldsymbolz times boldsymbolu = - boldsymbolnabla p rvert_z - g boldsymbolnabla eta rvert_z + fracpartialpartial z  left(nu fracpartial boldsymbolu_hpartial zright) labelmomentumh\nendequation","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"where boldsymbolu = u hatboldsymbolx + v hatboldsymboly is the horizontal velocity, boldsymbolv = boldsymbolu + w hatboldsymbolz is the three-dimensional velocity, and mathrmD  mathrmDt equiv partial_t + boldsymbolv cdot nabla is the material derivative.","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"The above is complemented by the hydrostatic relation","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"beginequation\n    fracpartial ppartial z = b labelhydrostatic\nendequation","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"Of the above, the Coriolis term is independent of the vertical frame of reference and the viscous stress is treated similarly to the diffusion of a tracer. In this derivation we focus on:","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"the hydrostatic relation \\eqref{hydrostatic},\nthe material derivative in the momentum equation \\eqref{momentumh}, and\nthe horizontal pressure gradient terms in \\eqref{momentumh}.","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/#Hydrostatic-relation","page":"Generalized vertical coordinates","title":"Hydrostatic relation","text":"","category":"section"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"Using the definition \\eqref{dphidz} of the z-derivative in r-coordinates","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"beginequation\n    fracpartial ppartial r = sigma b labelhydrostaticrcoord\nendequation","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/#Material-derivative-in-vector-invariant-form","page":"Generalized vertical coordinates","title":"Material derivative in vector invariant form","text":"","category":"section"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"We set out to transform in r-coordinates the material derivative of the horizontal velocity in vector invariant form","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"fracmathrmD boldsymbolumathrmD t biggrvert_z = fracpartial boldsymbolupartial t biggrvert_z + zeta hatboldsymbolz times boldsymbolu + boldsymbolnabla_h K + w fracpartial boldsymbolupartial z","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"where zeta = partial_x v - partial_y u is the vertical vorticity, and K equiv (u^2 + v^2)2 is the horizontal kinetic energy.","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"Here, we focus on the u component of the velocity; the derivation of the v component follows the same steps. Thus, we are transforming","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"beginalign*\n    fracmathrmDumathrmDt biggrvert_z  = fracpartial upartial t biggrvert_z - zeta rvert_z v + fracpartial Kpartial xbiggrvert_z + w fracpartial upartial z \n\n     = fracpartial upartial t biggrvert_z - left(fracpartial vpartial xbiggrvert_z - fracpartial upartial ybiggrvert_z right) v + fracpartial Kpartial xbiggrvert_z + w fracpartial upartial z \n\n     = fracpartial upartial t biggrvert_z - bigg(underbracefracpartial vpartial xbiggrvert_r - fracpartial upartial ybiggrvert_r_zeta_r - frac1sigma fracpartial vpartial r fracpartial zpartial x + frac1sigma fracpartial upartial r fracpartial zpartial y bigg) v + fracpartial Kpartial xbiggrvert_r - frac1sigma fracpartial Kpartial rfracpartial zpartial x + w fracpartial upartial z \n\n      = fracpartial upartial t biggrvert_z - zetarvert_r v - frac1sigma left(fracpartial upartial r fracpartial zpartial y - fracpartial vpartial r fracpartial zpartial x right) v + fracpartial Kpartial xbiggrvert_z + w fracpartial upartial z \n\n      = fracpartial upartial t biggrvert_z - zetarvert_r v - frac1sigma left(fracpartial upartial r fracpartial zpartial y - fracpartial vpartial r fracpartial zpartial x   right)  v + fracpartial Kpartial xbiggrvert_r - frac1sigma fracpartial Kpartial rfracpartial zpartial x + w fracpartial upartial z\nendalign*","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"Above, we utilized \\eqref{dphids} and \\eqref{drdx} repeatedly, e.g., for partial_y u rvert_z, partial_x v rvert_z, and partial_x K rvert_z. Further expanding partial_r K = u partial_r u + v partial_r v, a few terms cancel out and we end up with:","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"beginalign\n    fracmathrmDumathrmDt biggrvert_z\n      = fracpartial upartial t biggrvert_z - zetarvert_r v + fracpartial Kpartial xbiggrvert_r + frac1sigma left( w fracpartial upartial r - vfracpartial upartial r fracpartial zpartial y + vfracpartial vpartial r fracpartial zpartial x - u fracpartial upartial rfracpartial zpartial x- v fracpartial vpartial rfracpartial zpartial xright) \n      = fracpartial upartial t biggrvert_z - zetarvert_r v + fracpartial Kpartial xbiggrvert_r + frac1sigma left( w fracpartial upartial r - v fracpartial upartial r fracpartial zpartial y - u fracpartial upartial rfracpartial zpartial xright) nonumber \n     = fracpartial upartial t biggrvert_z - zetarvert_r v + fracpartial Kpartial xbiggrvert_r + frac1sigma left( w - v fracpartial zpartial y - u fracpartial zpartial xright)  fracpartial upartial r labelexpr1\nendalign","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"Using the definition of omega in \\eqref{def_omega}, we can rewrite \\eqref{expr1} as","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"beginalign\n    fracmathrmDumathrmDt biggrvert_z  = fracpartial upartial t biggrvert_z - zetarvert_r v + fracpartial Kpartial xbiggrvert_r + frac1sigma left( omega + fracpartial zpartial tbiggrvert_r right)  fracpartial upartial r\nendalign","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"As done above for the tracer, the last term on the right-hand side, using the chain rule for the time derivative yields","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"frac1sigma left( omega + fracpartial zpartial tbiggrvert_r right)  fracpartial upartial r = fracomegasigmafracpartial upartial r + fracpartial upartial tbiggrvert_r - fracpartial upartial tbiggrvert_z","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"Which completes the derivation of the u-momentum equations in r-coordinates","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"fracmathrmDumathrmDt biggrvert_z = fracpartial upartial t biggrvert_r - zetarvert_r v + fracpartial Kpartial xbiggrvert_r + fracomegasigmafracpartial upartial r","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"We can further split the vertical advection term into a conservative vertical advection and a horizontal divergence term:","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"fracmathrmDumathrmDt biggrvert_z = fracpartial upartial t biggrvert_r - zetarvert_r v + fracpartial Kpartial xbiggrvert_r + frac1sigmafracpartial omega upartial r - fracusigma fracpartial omegapartial r","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"and last using the continuity equation \\eqref{massconservationr} to obtain","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"beginequation\n    fracmathrmDumathrmDt biggrvert_z = fracpartial upartial t biggrvert_r - zetarvert_r v + fracpartial Kpartial xbiggrvert_r + frac1sigmafracpartial omega upartial r + fracusigma left( fracpartial sigmapartial t + fracpartial sigma upartial x biggrvert_r + fracpartial sigma vpartial ybiggrvert_rright)\nendequation","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/#Horizontal-pressure-gradient","page":"Generalized vertical coordinates","title":"Horizontal pressure gradient","text":"","category":"section"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"The horizontal pressure gradients, e.g., partial_x p, can be transformed using the chain rule \\eqref{dphidx}:","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"beginequation\n    fracpartial ppartial x biggrvert_z = fracpartial ppartial xbiggrvert_r - frac1sigmafracpartial ppartial rfracpartial zpartial x\nendequation","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"and combined with the hydrostatic relation \\eqref{hydrostaticrcoord}:","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"beginequation\n    fracpartial ppartial xbiggrvert_z = fracpartial ppartial xbiggrvert_r - b fracpartial zpartial x\nendequation","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"The last term on the right hand side above describes the pressure gradient associated with the horizontal tilting of the grid. Similarly, the gradient of the free surface transforms to","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"beginalign\n    fracpartial etapartial x biggrvert_z  = fracpartial etapartial xbiggrvert_r - frac1sigma fracpartial etapartial rfracpartial zpartial x\nendalign","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/#Finite-volume-discretization","page":"Generalized vertical coordinates","title":"Finite volume discretization","text":"","category":"section"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"It is useful to describe how the above equations translate into discrete form in a finite volume staggered C-grid framework.","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"To do so, we integrate over the cell volume V_r = Delta x Delta y Delta r remembering that in the discrete Delta z = sigma Delta r. Indices i, j, k below correspond to the x, y, and the vertical directions respectively.","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/#Mass-conservation-2","page":"Generalized vertical coordinates","title":"Mass conservation","text":"","category":"section"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"The mass conservation \\eqref{massconservationr} gives:","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"beginequation\n    frac1V_rint_V_r fracpartial sigmapartial t  mathrmdV + frac1V_r int_V_r left(fracpartial sigma upartial x biggrvert_r + fracpartial sigma vpartial ybiggrvert_r + fracpartial omegapartial rright)  mathrmdV = 0 labelmassdiscr1\nendequation","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"Using the notation for cell-averages overlinephi equiv V_r^-1 int_V_r phi mathrmdV and also the divergence theorem, we can rewrite \\eqref{massdiscr1} to:","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"beginequation\n    fracpartial overlinesigmapartial t + frac1Delta x Delta y Delta r left( Delta y Delta r  sigma u rvert_i-12^i+12 + Delta x Delta r  sigma v rvert_j-12^j+12 right ) + fracoverlineomega_k+12 - overlineomega_k-12Delta r = 0 labelmassdiscr2\nendequation","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"We use \\eqref{massdiscr2} diagnose the vertical velocity (in r space) given the grid velocity and the horizontal velocity divergence:","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"overlineomega_k+12 = overlineomega_k-12 + Delta r fracpartial overlinesigmapartial t + frac1A_z left( mathcalUrvert_i-12^i+12 + mathcalVrvert_j-12^j+12 right )","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"where mathcalU = A_x  u, mathcalV = A_y  v, A_x = Delta y  Delta z, A_y = Delta x  Delta z, and A_z = Delta x  Delta y.","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/#Tracer-equation-2","page":"Generalized vertical coordinates","title":"Tracer equation","text":"","category":"section"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"The tracer equation \\eqref{tracerrcoord} in discrete form becomes:","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"frac1V_rint_V_r frac1sigmafracpartial sigma cpartial t  mathrmdV + frac1V_r int_V_r left frac1sigma left( fracpartial sigma u cpartial x biggrvert_r + fracpartial sigma v cpartial ybiggrvert_r right) + frac1sigma fracpartial omega cpartial rright  mathrmdV = frac1V_rint_V_r frac1sigmafracpartialpartial r left( kappa fracpartial cpartial z right)  mathrmdV","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"leading to","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"frac1sigmafracpartial sigma overlinecpartial t + fracmathcalUc rvert_i-12^i+12 + mathcalVc rvert_j-12^j+12 + mathcalW c rvert_k-12^k+12V = frac1V left(mathcalK fracpartial cpartial zbiggrvert_k-12^k+12 right)","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"where V = sigma V_r = Delta x  Delta y  Delta z, mathcalW = A_z  omega, and mathcalK = A_z  kappa.","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"For an explicit formulation of the diffusive fluxes and a time-discretization using forward Euler scheme, imply:","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"beginequation\n    c^n+1 = fracsigma^nsigma^n+1left(c^n + Delta t  G^n right)\nendequation","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"where G^n is tendency computed on the z-grid.","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"Note that in case of a multi-step method, e.g., second-order Adams-Bashforth, the grid at different time-steps must be accounted for, and the time-discretization becomes","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"beginequation\n    c^n+1 = frac1sigma^n+1 leftsigma^n c^n + Delta t left(frac32 sigma^n G^n - frac12 sigma^n-1 G^n-1right)right\nendequation","category":"page"},{"location":"numerical_implementation/generalized_vertical_coordinates/","page":"Generalized vertical coordinates","title":"Generalized vertical coordinates","text":"For this reason, we store the tendencies pre-multiplied by sigma at their current time-level. In case of an implicit discretization of the diffusive fluxes we first compute c^n+1 as in the above equation (where G^n does not contain the diffusive fluxes). Then the implicit step is done on a z-grid as if the grid was static, using the grid at n+1 which includes sigma^n+1.","category":"page"},{"location":"model_setup/boundary_conditions/#model_step_bcs","page":"Boundary conditions","title":"Boundary conditions","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Boundary conditions are intimately related to the grid topology, and only need to be considered in directions with Bounded topology or across immersed boundaries. In Bounded directions, tracer and momentum fluxes are conservative or \"zero flux\" by default. Non-default boundary conditions are therefore required to specify non-zero fluxes of tracers and momentum across Bounded directions, and across immersed boundaries when using ImmersedBoundaryGrid.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"See Numerical implementation of boundary conditions for more details.","category":"page"},{"location":"model_setup/boundary_conditions/#Example:-no-slip-conditions-on-every-boundary","page":"Boundary conditions","title":"Example: no-slip conditions on every boundary","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> using Oceananigans\n\njulia> grid = RectilinearGrid(size=(16, 16, 16), x=(0, 2Ï€), y=(0, 1), z=(0, 1), topology=(Periodic, Bounded, Bounded))\n16Ã—16Ã—16 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ Periodic x âˆˆ [0.0, 6.28319) regularly spaced with Î”x=0.392699\nâ”œâ”€â”€ Bounded  y âˆˆ [0.0, 1.0]     regularly spaced with Î”y=0.0625\nâ””â”€â”€ Bounded  z âˆˆ [0.0, 1.0]     regularly spaced with Î”z=0.0625\n\njulia> no_slip_bc = ValueBoundaryCondition(0.0)\nValueBoundaryCondition: 0.0","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"A \"no-slip\" BoundaryCondition specifies that velocity components tangential to Bounded directions decay to 0 at the boundary, leading to a viscous loss of momentum.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> no_slip_field_bcs = FieldBoundaryConditions(no_slip_bc);\n\njulia> model = NonhydrostaticModel(; grid, boundary_conditions=(u=no_slip_field_bcs, v=no_slip_field_bcs, w=no_slip_field_bcs))\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 16Ã—16Ã—16 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ timestepper: RungeKutta3TimeStepper\nâ”œâ”€â”€ advection scheme: Centered(order=2)\nâ”œâ”€â”€ tracers: ()\nâ”œâ”€â”€ closure: Nothing\nâ”œâ”€â”€ buoyancy: Nothing\nâ””â”€â”€ coriolis: Nothing\n\njulia> model.velocities.u.boundary_conditions\nOceananigans.FieldBoundaryConditions, with boundary conditions\nâ”œâ”€â”€ west: PeriodicBoundaryCondition\nâ”œâ”€â”€ east: PeriodicBoundaryCondition\nâ”œâ”€â”€ south: ValueBoundaryCondition: 0.0\nâ”œâ”€â”€ north: ValueBoundaryCondition: 0.0\nâ”œâ”€â”€ bottom: ValueBoundaryCondition: 0.0\nâ”œâ”€â”€ top: ValueBoundaryCondition: 0.0\nâ””â”€â”€ immersed: Nothing","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Boundary conditions are passed to FieldBoundaryCondition to build boundary conditions for each field individually, and then onto the model constructor (here NonhydrotaticModel) via the keyword argument boundary_conditions. The model constructor then \"interprets\" the input and builds appropriate boundary conditions for the grid topology, given the user-specified no_slip default boundary condition for Bounded directions. In the above example, note that the west and east boundary conditions are PeriodicBoundaryCondition because the x-topology of the grid is Periodic.","category":"page"},{"location":"model_setup/boundary_conditions/#Example:-specifying-boundary-conditions-on-individual-boundaries","page":"Boundary conditions","title":"Example: specifying boundary conditions on individual boundaries","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"To specify no-slip boundary conditions on every Bounded direction except the surface, we write","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> free_slip_surface_bcs = FieldBoundaryConditions(no_slip_bc, top=FluxBoundaryCondition(nothing));\n\njulia> model = NonhydrostaticModel(; grid, boundary_conditions=(u=free_slip_surface_bcs, v=free_slip_surface_bcs, w=no_slip_field_bcs));\n\njulia> model.velocities.u.boundary_conditions\nOceananigans.FieldBoundaryConditions, with boundary conditions\nâ”œâ”€â”€ west: PeriodicBoundaryCondition\nâ”œâ”€â”€ east: PeriodicBoundaryCondition\nâ”œâ”€â”€ south: ValueBoundaryCondition: 0.0\nâ”œâ”€â”€ north: ValueBoundaryCondition: 0.0\nâ”œâ”€â”€ bottom: ValueBoundaryCondition: 0.0\nâ”œâ”€â”€ top: FluxBoundaryCondition: Nothing\nâ””â”€â”€ immersed: Nothing\n\njulia> model.velocities.v.boundary_conditions\nOceananigans.FieldBoundaryConditions, with boundary conditions\nâ”œâ”€â”€ west: PeriodicBoundaryCondition\nâ”œâ”€â”€ east: PeriodicBoundaryCondition\nâ”œâ”€â”€ south: OpenBoundaryCondition{Nothing}: Nothing\nâ”œâ”€â”€ north: OpenBoundaryCondition{Nothing}: Nothing\nâ”œâ”€â”€ bottom: ValueBoundaryCondition: 0.0\nâ”œâ”€â”€ top: FluxBoundaryCondition: Nothing\nâ””â”€â”€ immersed: Nothing","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Now both u and v have FluxBoundaryCondition(nothing) at the top boundary, which is Oceananigans lingo for \"no-flux boundary condition\".","category":"page"},{"location":"model_setup/boundary_conditions/#Boundary-condition-classifications","page":"Boundary conditions","title":"Boundary condition classifications","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"There are three primary boundary condition classifications:","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"FluxBoundaryCondition specifies fluxes directly.\nSome applications of FluxBoundaryCondition are:\nsurface momentum fluxes due to wind, or \"wind stress\";\nlinear or quadratic bottom drag;\nsurface temperature fluxes due to heating or cooling;\nsurface salinity fluxes due to precipitation and evaporation;\nrelaxation boundary conditions that restores a field to some boundary distribution over a given time-scale.\nValueBoundaryCondition (Dirichlet) specifies the value of a field on the given boundary, which when used in combination with a turbulence closure results in a flux across the boundary.\nNote: Do not use ValueBoundaryCondition on a wall-normal velocity component (see the note below about ImpenetrableBoundaryCondition).\nSome applications of ValueBoundaryCondition are:\nno-slip boundary condition for wall-tangential velocity components via ValueBoundaryCondition(0);\nsurface temperature distribution, where heat fluxes in and out of the domain at a rate controlled by the near-surface temperature gradient and the temperature diffusivity;\nconstant velocity tangential to a boundary as in a driven-cavity flow (for example), where the top boundary is moving. Momentum will flux into the domain do the difference between the top boundary velocity and the interior velocity, and the prescribed viscosity.\nGradientBoundaryCondition (Neumann) specifies the gradient of a field on a boundary. For example, if there is a known diffusivity, we can express FluxBoundaryCondition(flux) using GradientBoundaryCondition(-flux / diffusivity) (aka \"Neumann\" boundary condition).","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"In addition to these primary boundary conditions, ImpenetrableBoundaryCondition applies to velocity components in wall-normal directions.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"warn: `ImpenetrableBoundaryCondition`\nImpenetrableBoundaryCondition is internally enforced for fields created inside the model constructor. As a result, ImpenetrableBoundaryCondition is only used for additional velocity components that are not evolved by a model, such as a velocity component used for (AdvectiveForcing)[@ref].","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Finally, note that Periodic boundary conditions are internally enforced for Periodic directions, and DefaultBoundaryConditions may exist before boundary conditions are \"materialized\" by a model.","category":"page"},{"location":"model_setup/boundary_conditions/#Default-boundary-conditions","page":"Boundary conditions","title":"Default boundary conditions","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"The default boundary condition in Bounded directions is no-flux, or FluxBoundaryCondition(nothing). The default boundary condition can be changed by passing a positional argument to FieldBoundaryConditions, as in","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> no_slip_bc = ValueBoundaryCondition(0.0)\nValueBoundaryCondition: 0.0\n\njulia> free_slip_surface_bcs = FieldBoundaryConditions(no_slip_bc, top=FluxBoundaryCondition(nothing))\nOceananigans.FieldBoundaryConditions, with boundary conditions\nâ”œâ”€â”€ west: DefaultBoundaryCondition (ValueBoundaryCondition: 0.0)\nâ”œâ”€â”€ east: DefaultBoundaryCondition (ValueBoundaryCondition: 0.0)\nâ”œâ”€â”€ south: DefaultBoundaryCondition (ValueBoundaryCondition: 0.0)\nâ”œâ”€â”€ north: DefaultBoundaryCondition (ValueBoundaryCondition: 0.0)\nâ”œâ”€â”€ bottom: DefaultBoundaryCondition (ValueBoundaryCondition: 0.0)\nâ”œâ”€â”€ top: FluxBoundaryCondition: Nothing\nâ””â”€â”€ immersed: DefaultBoundaryCondition (ValueBoundaryCondition: 0.0)","category":"page"},{"location":"model_setup/boundary_conditions/#Boundary-condition-structures","page":"Boundary conditions","title":"Boundary condition structures","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Oceananigans uses a hierarchical structure to express boundary conditions:","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Each boundary of each field has one BoundaryCondition\nEach field has seven BoundaryCondition (west, east, south, north, bottom, top and immersed)\nA set of FieldBoundaryConditions, up to one for each field, are grouped into a NamedTuple and passed to the model constructor.","category":"page"},{"location":"model_setup/boundary_conditions/#Specifying-boundary-conditions-for-a-model","page":"Boundary conditions","title":"Specifying boundary conditions for a model","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Boundary conditions are defined at model construction time by passing a NamedTuple of FieldBoundaryConditions specifying non-default boundary conditions for fields such as velocities and tracers.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Fields for which boundary conditions are not specified are assigned a default boundary conditions.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"A few illustrations are provided below. See the examples for further illustrations of boundary condition specification.","category":"page"},{"location":"model_setup/boundary_conditions/#Creating-individual-boundary-conditions-with-BoundaryCondition","page":"Boundary conditions","title":"Creating individual boundary conditions with BoundaryCondition","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Boundary conditions may be specified with constants, functions, or arrays. In this section we illustrate usage of the different BoundaryCondition constructors.","category":"page"},{"location":"model_setup/boundary_conditions/#1.-Constant-Value-(Dirchlet)-boundary-condition","page":"Boundary conditions","title":"1. Constant Value (Dirchlet) boundary condition","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> constant_T_bc = ValueBoundaryCondition(20.0)\nValueBoundaryCondition: 20.0","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"A constant Value boundary condition can be used to specify constant tracer (such as temperature), or a constant tangential velocity component at a boundary. Note that boundary conditions on the normal velocity component must use the Open boundary condition type.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Finally, note that ValueBoundaryCondition(condition) is an alias for BoundaryCondition(Value, condition).","category":"page"},{"location":"model_setup/boundary_conditions/#2.-Constant-Flux-boundary-condition","page":"Boundary conditions","title":"2. Constant Flux boundary condition","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> Ïâ‚€ = 1027;  # Reference density [kg/mÂ³]\n\njulia> Ï„â‚“ = 0.08;  # Wind stress [N/mÂ²]\n\njulia> wind_stress_bc = FluxBoundaryCondition(-Ï„â‚“/Ïâ‚€)\nFluxBoundaryCondition: -7.78968e-5","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"A constant Flux boundary condition can be imposed on tracers and tangential velocity components that can be used, for example, to specify cooling, heating, evaporation, or wind stress at the ocean surface.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"info: The flux convention in Oceananigans\nOceananigans uses the convention that positive fluxes produce transport in the positive direction (east, north, and up for x, y, z). This means, for example, that a negative flux of momentum or velocity at a top boundary, such as in the above example, produces currents in the positive direction, because it prescribes a downwards flux of momentum into the domain from the top. Likewise, a positive temperature flux at the top boundary causes cooling, because it transports heat upwards, out of the domain. Conversely, a positive flux at a bottom boundary acts to increase the interior values of a quantity.","category":"page"},{"location":"model_setup/boundary_conditions/#3.-Spatially-and-temporally-varying-flux","page":"Boundary conditions","title":"3. Spatially- and temporally-varying flux","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Boundary conditions may be specified by functions,","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> @inline surface_flux(x, y, t) = cos(2Ï€ * x) * cos(t);\n\njulia> top_tracer_bc = FluxBoundaryCondition(surface_flux)\nFluxBoundaryCondition: ContinuousBoundaryFunction surface_flux at (Nothing, Nothing, Nothing)","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"info: Boundary condition functions\nBy default, a function boundary condition is called with the signaturef(Î¾, Î·, t)where t is time and Î¾, Î· are spatial coordinates that vary along the boundary:f(y, z, t) on x-boundaries;\nf(x, z, t) on y-boundaries;\nf(x, y, t) on z-boundaries.Alternative function signatures are specified by keyword arguments to BoundaryCondition, as illustrated in subsequent examples.","category":"page"},{"location":"model_setup/boundary_conditions/#4.-Spatially-and-temporally-varying-flux-with-parameters","page":"Boundary conditions","title":"4. Spatially- and temporally-varying flux with parameters","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Boundary condition functions may be 'parameterized',","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> @inline wind_stress(x, y, t, p) = - p.Ï„ * cos(p.k * x) * cos(p.Ï‰ * t); # function with parameters\n\njulia> top_u_bc = FluxBoundaryCondition(wind_stress, parameters=(k=4Ï€, Ï‰=3.0, Ï„=1e-4))\nFluxBoundaryCondition: ContinuousBoundaryFunction wind_stress at (Nothing, Nothing, Nothing)","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"info: Boundary condition functions with parameters\nThe keyword argument parameters above specifies that wind_stress is called with the signature wind_stress(x, y, t, parameters). In principle, parameters is arbitrary. However, relatively simple objects such as floating point numbers or NamedTuples must be used when running on the GPU.","category":"page"},{"location":"model_setup/boundary_conditions/#5.-'Field-dependent'-boundary-conditions","page":"Boundary conditions","title":"5. 'Field-dependent' boundary conditions","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Boundary conditions may also depend on model fields. For example, a linear drag boundary condition is implemented with","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> @inline linear_drag(x, y, t, u) = - 0.2 * u\nlinear_drag (generic function with 1 method)\n\njulia> u_bottom_bc = FluxBoundaryCondition(linear_drag, field_dependencies=:u)\nFluxBoundaryCondition: ContinuousBoundaryFunction linear_drag at (Nothing, Nothing, Nothing)","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"field_dependencies specifies the name of the dependent fields either with a Symbol or Tuple of Symbols.","category":"page"},{"location":"model_setup/boundary_conditions/#6.-'Field-dependent'-boundary-conditions-with-parameters","page":"Boundary conditions","title":"6. 'Field-dependent' boundary conditions with parameters","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"When boundary conditions depends on fields and parameters, their functions take the form","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> @inline quadratic_drag(x, y, t, u, v, drag_coeff) = - drag_coeff * u * sqrt(u^2 + v^2)\nquadratic_drag (generic function with 1 method)\n\njulia> u_bottom_bc = FluxBoundaryCondition(quadratic_drag, field_dependencies=(:u, :v), parameters=1e-3)\nFluxBoundaryCondition: ContinuousBoundaryFunction quadratic_drag at (Nothing, Nothing, Nothing)","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Put differently, Î¾, Î·, t come first in the function signature, followed by field dependencies, followed by parameters is !isnothing(parameters).","category":"page"},{"location":"model_setup/boundary_conditions/#7.-Discrete-form-boundary-condition-with-parameters","page":"Boundary conditions","title":"7. Discrete-form boundary condition with parameters","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Discrete field data may also be accessed directly from boundary condition functions using the discrete_form. For example:","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"@inline filtered_drag(i, j, grid, clock, model_fields) =\n    @inbounds - 0.05 * (model_fields.u[i-1, j, 1] + 2 * model_fields.u[i, j, 1] + model_fields.u[i-1, j, 1])\n\nu_bottom_bc = FluxBoundaryCondition(filtered_drag, discrete_form=true)\n\n# output\nFluxBoundaryCondition: DiscreteBoundaryFunction with filtered_drag","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"info: The 'discrete form' for boundary condition functions\nThe argument discrete_form=true indicates to BoundaryCondition that filtered_drag uses the 'discrete form'. Boundary condition functions that use the 'discrete form' are called with the signaturef(i, j, grid, clock, model_fields)where i, j are grid indices that vary along the boundary, grid is model.grid, clock is the model.clock, and model_fields is a NamedTuple containing u, v, w and the fields in model.tracers. The signature is similar for x and y boundary conditions expect that i, j is replaced with j, k and i, k respectively.","category":"page"},{"location":"model_setup/boundary_conditions/#8.-Discrete-form-boundary-condition-with-parameters","page":"Boundary conditions","title":"8. Discrete-form boundary condition with parameters","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> Cd = 0.2; # drag coefficient\n\njulia> @inline linear_drag(i, j, grid, clock, model_fields, Cd) = @inbounds - Cd * model_fields.u[i, j, 1];\n\njulia> u_bottom_bc = FluxBoundaryCondition(linear_drag, discrete_form=true, parameters=Cd)\nFluxBoundaryCondition: DiscreteBoundaryFunction linear_drag with parameters 0.2","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"info: Inlining and avoiding bounds-checking in boundary condition functions\nBoundary condition functions should be decorated with @inline when running on CPUs for performance reasons. On the GPU, all functions are force-inlined by default. In addition, the annotation @inbounds should be used when accessing the elements of an array in a boundary condition function (such as model_fields.u[i, j, 1] in the above example). Using @inbounds will avoid a relatively expensive check that the index i, j, 1 is 'in bounds'.","category":"page"},{"location":"model_setup/boundary_conditions/#9.-A-random,-spatially-varying,-constant-in-time-temperature-flux-specified-by-an-array","page":"Boundary conditions","title":"9. A random, spatially-varying, constant-in-time temperature flux specified by an array","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> Nx = Ny = 16;  # Number of grid points.\n\njulia> Q = randn(Nx, Ny); # temperature flux\n\njulia> white_noise_T_bc = FluxBoundaryCondition(Q)\nFluxBoundaryCondition: 16Ã—16 Matrix{Float64}","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"When running on the GPU, Q must be converted to a CuArray.","category":"page"},{"location":"model_setup/boundary_conditions/#Building-boundary-conditions-on-a-field","page":"Boundary conditions","title":"Building boundary conditions on a field","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"To create a set of FieldBoundaryConditions for a temperature field, we write","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> T_bcs = FieldBoundaryConditions(top = ValueBoundaryCondition(20.0),\n                                       bottom = GradientBoundaryCondition(0.01))\nOceananigans.FieldBoundaryConditions, with boundary conditions\nâ”œâ”€â”€ west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ bottom: GradientBoundaryCondition: 0.01\nâ”œâ”€â”€ top: ValueBoundaryCondition: 20.0\nâ””â”€â”€ immersed: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"If the grid is, e.g., horizontally-periodic, then each horizontal DefaultBoundaryCondition is converted to PeriodicBoundaryCondition inside the model's constructor, before assigning the boundary conditions to temperature T.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"In general, boundary condition defaults are inferred from the field location and topology(grid).","category":"page"},{"location":"model_setup/boundary_conditions/#Specifying-model-boundary-conditions","page":"Boundary conditions","title":"Specifying model boundary conditions","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"To specify non-default boundary conditions, a named tuple of FieldBoundaryConditions objects is passed to the keyword argument boundary_conditions in the NonhydrostaticModel constructor. The keys of boundary_conditions indicate the field to which the boundary condition is applied. Below, non-default boundary conditions are imposed on the u-velocity and tracer c.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> topology = (Periodic, Periodic, Bounded);\n\njulia> grid = RectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1), topology=topology);\n\njulia> u_bcs = FieldBoundaryConditions(top = ValueBoundaryCondition(+0.1),\n                                       bottom = ValueBoundaryCondition(-0.1));\n\njulia> c_bcs = FieldBoundaryConditions(top = ValueBoundaryCondition(20.0),\n                                       bottom = GradientBoundaryCondition(0.01));\n\njulia> model = NonhydrostaticModel(grid=grid, boundary_conditions=(u=u_bcs, c=c_bcs), tracers=:c)\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 16Ã—16Ã—16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ timestepper: RungeKutta3TimeStepper\nâ”œâ”€â”€ advection scheme: Centered(order=2)\nâ”œâ”€â”€ tracers: c\nâ”œâ”€â”€ closure: Nothing\nâ”œâ”€â”€ buoyancy: Nothing\nâ””â”€â”€ coriolis: Nothing\n\njulia> model.velocities.u\n16Ã—16Ã—16 Field{Face, Center, Center} on RectilinearGrid on CPU\nâ”œâ”€â”€ grid: 16Ã—16Ã—16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ boundary conditions: FieldBoundaryConditions\nâ”‚   â””â”€â”€ west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Value, top: Value, immersed: Nothing\nâ””â”€â”€ data: 22Ã—22Ã—22 OffsetArray(::Array{Float64, 3}, -2:19, -2:19, -2:19) with eltype Float64 with indices -2:19Ã—-2:19Ã—-2:19\n    â””â”€â”€ max=0.0, min=0.0, mean=0.0\n\njulia> model.tracers.c\n16Ã—16Ã—16 Field{Center, Center, Center} on RectilinearGrid on CPU\nâ”œâ”€â”€ grid: 16Ã—16Ã—16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ boundary conditions: FieldBoundaryConditions\nâ”‚   â””â”€â”€ west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Gradient, top: Value, immersed: Nothing\nâ””â”€â”€ data: 22Ã—22Ã—22 OffsetArray(::Array{Float64, 3}, -2:19, -2:19, -2:19) with eltype Float64 with indices -2:19Ã—-2:19Ã—-2:19\n    â””â”€â”€ max=0.0, min=0.0, mean=0.0","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Notice that the specified non-default boundary conditions have been applied at top and bottom of both model.velocities.u and model.tracers.c.","category":"page"},{"location":"model_setup/boundary_conditions/#Immersed-boundary-conditions","page":"Boundary conditions","title":"Immersed boundary conditions","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Immersed boundary conditions are supported experimentally. A no-slip boundary condition is specified with","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"# Generate a simple ImmersedBoundaryGrid\nhill(x, y) = 0.1 + 0.1 * exp(-x^2 - y^2)\nunderlying_grid = RectilinearGrid(size=(32, 32, 16), x=(-3, 3), y=(-3, 3), z=(0, 1), topology=(Periodic, Periodic, Bounded))\ngrid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(hill))\n\n# Create a no-slip boundary condition for velocity fields.\n# Note that the no-slip boundary condition is _only_ applied on immersed boundaries.\nvelocity_bcs = FieldBoundaryConditions(immersed=ValueBoundaryCondition(0))\nmodel = NonhydrostaticModel(; grid, boundary_conditions=(u=velocity_bcs, v=velocity_bcs, w=velocity_bcs))\n\n# Inspect the boundary condition on the vertical velocity:\nmodel.velocities.w.boundary_conditions.immersed\n\n# output\nâ”Œ Warning: The FFT-based pressure_solver for NonhydrostaticModels on ImmersedBoundaryGrid\nâ”‚ is approximate and will probably produce velocity fields that are divergent\nâ”‚ adjacent to the immersed boundary. An experimental but improved pressure_solver\nâ”‚ is available which may be used by writing\nâ”‚\nâ”‚     using Oceananigans.Solvers: ConjugateGradientPoissonSolver\nâ”‚     pressure_solver = ConjugateGradientPoissonSolver(grid)\nâ”‚\nâ”‚ Please report issues to https://github.com/CliMA/Oceananigans.jl/issues.\nâ”” @ Oceananigans.Models.NonhydrostaticModels ~/Oceananigans.jl/src/Models/NonhydrostaticModels/NonhydrostaticModels.jl:55\nImmersedBoundaryCondition:\nâ”œâ”€â”€ west: ValueBoundaryCondition: 0.0\nâ”œâ”€â”€ east: ValueBoundaryCondition: 0.0\nâ”œâ”€â”€ south: ValueBoundaryCondition: 0.0\nâ”œâ”€â”€ north: ValueBoundaryCondition: 0.0\nâ”œâ”€â”€ bottom: Nothing\nâ””â”€â”€ top: Nothing","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"warning: `NonhydrostaticModel` on `ImmersedBoundaryGrid`\nThe pressure solver for NonhydrostaticModel is approximate, and is unable to produce a velocity field that is simultaneously divergence-free while also satisfying impenetrability on the immersed boundary. As a result, simulated dynamics with NonhydrostaticModel can exhibit egregiously unphysical errors and should be interpreted with caution.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"hill(x, y) = 0.1 + 0.1 * exp(-x^2 - y^2)\nunderlying_grid = RectilinearGrid(size=(32, 32, 16), x=(-3, 3), y=(-3, 3), z=(0, 1), topology=(Periodic, Periodic, Bounded))\ngrid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(hill))\n\n# Create a no-slip boundary condition for velocity fields.\n# Note that the no-slip boundary condition is _only_ applied on immersed boundaries.\nvelocity_bcs = FieldBoundaryConditions(immersed=ValueBoundaryCondition(0))\nmodel = NonhydrostaticModel(; grid, boundary_conditions=(u=velocity_bcs, v=velocity_bcs, w=velocity_bcs))\n\n# output\nâ”Œ Warning: The FFT-based pressure_solver for NonhydrostaticModels on ImmersedBoundaryGrid\nâ”‚ is approximate and will probably produce velocity fields that are divergent\nâ”‚ adjacent to the immersed boundary. An experimental but improved pressure_solver\nâ”‚ is available which may be used by writing\nâ”‚\nâ”‚     using Oceananigans.Solvers: ConjugateGradientPoissonSolver\nâ”‚     pressure_solver = ConjugateGradientPoissonSolver(grid)\nâ”‚\nâ”‚ Please report issues to https://github.com/CliMA/Oceananigans.jl/issues.\nâ”” @ Oceananigans.Models.NonhydrostaticModels ~/Oceananigans.jl/src/Models/NonhydrostaticModels/NonhydrostaticModels.jl:55\nNonhydrostaticModel{CPU, ImmersedBoundaryGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 32Ã—32Ã—16 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ timestepper: RungeKutta3TimeStepper\nâ”œâ”€â”€ advection scheme: Centered(order=2)\nâ”œâ”€â”€ tracers: ()\nâ”œâ”€â”€ closure: Nothing\nâ”œâ”€â”€ buoyancy: Nothing\nâ””â”€â”€ coriolis: Nothing","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"An ImmersedBoundaryCondition encapsulates boundary conditions on each potential boundary-facet of a boundary-adjacent cell. Boundary conditions on specific faces of immersed-boundary-adjacent cells may also be specified by manually building an ImmersedBoundaryCondition:","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"bottom_drag_bc = ImmersedBoundaryCondition(bottom=ValueBoundaryCondition(0))\n\n# output\nImmersedBoundaryCondition:\nâ”œâ”€â”€ west: Nothing\nâ”œâ”€â”€ east: Nothing\nâ”œâ”€â”€ south: Nothing\nâ”œâ”€â”€ north: Nothing\nâ”œâ”€â”€ bottom: ValueBoundaryCondition: 0\nâ””â”€â”€ top: Nothing","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"The ImmersedBoundaryCondition may then be incorporated into the boundary conditions for a Field by prescribing it to the immersed boundary label,","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"velocity_bcs = FieldBoundaryConditions(immersed=bottom_drag_bc)\n\n# output\nOceananigans.FieldBoundaryConditions, with boundary conditions\nâ”œâ”€â”€ west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ bottom: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ top: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ””â”€â”€ immersed: ImmersedBoundaryCondition with west=Nothing, east=Nothing, south=Nothing, north=Nothing, bottom=Value, top=Nothing","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"warning: `ImmersedBoundaryCondition`\nImmersedBoundaryCondition is experimental. Therefore, one should use it only when a finer level of control over the boundary conditions at the immersed boundary is required, and the user is familiar with the implementation of boundary conditions on staggered grids. For all other cases , using the immersed argument of FieldBoundaryConditions is preferred.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"A boundary condition that depends on the fields may be prescribed using the immersed keyword argument in FieldBoundaryConditions. We illustrate field-dependent boundary conditions with an example that imposes linear bottom drag on u on both the bottom facets of cells adjacent to an immersed boundary, and the bottom boundary of the underlying grid.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"First we create the boundary condition for the grid's bottom:","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"@inline linear_drag(x, y, t, u) = - 0.2 * u\ndrag_u = FluxBoundaryCondition(linear_drag, field_dependencies=:u)\n\n# output\nFluxBoundaryCondition: ContinuousBoundaryFunction linear_drag at (Nothing, Nothing, Nothing)","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Next, we create the immersed boundary condition by adding the argument z to linear_drag and imposing drag only on \"bottom\" facets of cells that neighbor immersed cells:","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"@inline immersed_linear_drag(x, y, z, t, u) = - 0.2 * u\nimmersed_drag_u = FluxBoundaryCondition(immersed_linear_drag, field_dependencies=:u)\n\nu_immersed_bc = ImmersedBoundaryCondition(bottom = immersed_drag_u)\n\n# output\nImmersedBoundaryCondition:\nâ”œâ”€â”€ west: Nothing\nâ”œâ”€â”€ east: Nothing\nâ”œâ”€â”€ south: Nothing\nâ”œâ”€â”€ north: Nothing\nâ”œâ”€â”€ bottom: FluxBoundaryCondition: ContinuousBoundaryFunction immersed_linear_drag at (Nothing, Nothing, Nothing)\nâ””â”€â”€ top: Nothing","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Finally, we combine the two:","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"u_bcs = FieldBoundaryConditions(bottom = drag_u, immersed = u_immersed_bc)\n\n# output\nOceananigans.FieldBoundaryConditions, with boundary conditions\nâ”œâ”€â”€ west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ”œâ”€â”€ bottom: FluxBoundaryCondition: ContinuousBoundaryFunction linear_drag at (Nothing, Nothing, Nothing)\nâ”œâ”€â”€ top: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\nâ””â”€â”€ immersed: ImmersedBoundaryCondition with west=Nothing, east=Nothing, south=Nothing, north=Nothing, bottom=Flux, top=Nothing","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"warning: Positional argument requirements\nNote the difference between the arguments required for the function within the bottom boundary condition versus the arguments for the function within the immersed boundary condition. E.g., x, y, t in linear_drag() versus x, y, z, t in immersed_linear_drag().","category":"page"},{"location":"gallery/#Gallery","page":"Gallery","title":"Gallery","text":"","category":"section"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"Collection of cool movies!","category":"page"},{"location":"gallery/#[Deep-convection](https://www.youtube.com/watch?vkpUrxnKKMjI)","page":"Gallery","title":"Deep convection","text":"","category":"section"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"An idealized simulation of deep convection in the ocean. The simulation employs a resolution of 256x256x128 volumes in a 2x2x1 km horizontally periodic domain. Heat is sucked out of the ocean surface within a cooling disk of radius 600 m at a rate of 800 W/mÂ² which cools the surface water and making it denser. This cold dense water then sinks into the ocean interior, initiating a convective process that penetrates deep into the ocean.","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"This deep convection process can happen when a cold storm passes through warmer waters, which happens for example in the Labrador Sea.","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"The video shows the temperature field and the domain is sliced in half so the convection happening under the cooling disk is clear.","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"(Image: Watch deep convection in action)","category":"page"},{"location":"gallery/#[Free-convection](https://www.youtube.com/watch?vyq4op9h3xcU)","page":"Gallery","title":"Free convection","text":"","category":"section"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"An idealized simulation of free convection in the ocean. The simulation employs a resolution of 256x256x256 volumes in a 100x100x100 m horizontally periodic domain. Heat is sucked out of the ocean surface at a rate of 75 W/mÂ² which cools the surface water and making it denser. This cold dense water then sinks into the ocean interior, initiating a convective process that keeps mixing the upper layer of the ocean. This \"mixed layer\" has a relatively constant temperature and keeps deepening as the surface is cooled.","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"The video shows the temperature field and the domain is sliced in half.","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"(Image: Watch free convection in action)","category":"page"},{"location":"gallery/#[Winds-blowing-over-the-ocean](https://www.youtube.com/watch?vIRncfbvuiy8)","page":"Gallery","title":"Winds blowing over the ocean","text":"","category":"section"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"An idealized simulation of a strong wind stress acting on the surface of a stratified ocean. The simulation employs a resolution of 256x256x256 volumes in a 100x100x100 m horizontally periodic domain. A pretty strong wind stress of 0.1 N/mÂ² is applied in the x direction which mechanically mixes the upper layer of the ocean. This leads to a \"mixed layer\" of constant temperature near the surface of the ocean. You can also see the onset of Kelvin-Helmholtz instabilities as the mechanical mixing sets in.","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"The video shows the temperature field in the top 25 meters and the domain is sliced in half for visualization. The line plots show the horizontally averaged temperature profile (top right), horizontally averaged turbulent kinetic energy (middle right), and the horizontally averaged buoyancy flux (or temperature flux).","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"(Image: Watch winds blowing over the ocean)","category":"page"},{"location":"gallery/#[Free-convection-with-wind-stress](https://www.youtube.com/watch?vob6OMQgPfI4)","page":"Gallery","title":"Free convection with wind stress","text":"","category":"section"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"An idealized simulation of a strong wind stress acting on the surface of a stratified ocean along with a cooling flux that sucks heat out of the surface. The simulation employs a resolution of 256x256x256 volumes in a 100x100x100 m horizontally periodic domain. A pretty strong wind stress of 0.1 N/mÂ² is applied in the x direction which mechanically mixes the upper layer of the ocean. Also, heat is sucked out of the ocean surface at a rate of 75 W/mÂ² which cools the surface water and making it denser. This cold dense water then sinks into the ocean interior, initiating a convective process that keeps mixing the upper layer of the ocean. This leads to a \"mixed layer\" of constant temperature near the surface of the ocean. You can also see the onset of Kelvin-Helmholtz instabilities as the mechanical mixing sets in.","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"The video shows the temperature field and the domain is sliced in half for visualization. The line plots show the horizontally averaged temperature profile (top right), horizontally averaged turbulent kinetic energy (middle right), and the horizontally averaged buoyancy flux (or temperature flux). The unusual periodic prism colormap is used to show the fine details at the surface as it cools and the layers of different temperatures (the isopycnals) being perturbed by internal waves.","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"(Image: Watch free convection with wind stress in action)","category":"page"},{"location":"physics/shallow_water_model/#Shallow-water-model","page":"Shallow water model","title":"Shallow water model","text":"","category":"section"},{"location":"physics/shallow_water_model/","page":"Shallow water model","title":"Shallow water model","text":"The ShallowWaterModel simulates the shallow water dynamics for a fluid of constant density but with varying fluid depth h(x y t) and whose velocity only varies in the horizontal, boldsymbolu(x y t) = u(x y t) boldsymbolhat x + v(x y t) boldsymbolhat y.","category":"page"},{"location":"physics/shallow_water_model/","page":"Shallow water model","title":"Shallow water model","text":"ShallowWaterModel allows users to prescribe the shallow water dynamics using two different formulations: VectorInvariantFormulation() and ConservativeFormulation().","category":"page"},{"location":"physics/shallow_water_model/","page":"Shallow water model","title":"Shallow water model","text":"The VectorInvariantFormulation uses the horizontal velocity boldsymbolu and the total depth of the fluid, h, as the dynamical variables. Furthermore, the advective terms are rewritten via the vector identity:","category":"page"},{"location":"physics/shallow_water_model/","page":"Shallow water model","title":"Shallow water model","text":"boldsymbolu boldsymbolcdot boldsymbolnabla boldsymbolu = (boldsymbolnabla times boldsymbolu) times boldsymbolu + boldsymbolnabla left( frac12 boldsymbolu boldsymbolcdot boldsymbolu right )  ","category":"page"},{"location":"physics/shallow_water_model/","page":"Shallow water model","title":"Shallow water model","text":"Thus, the shallow water dynamics in vector-invariant form become:","category":"page"},{"location":"physics/shallow_water_model/","page":"Shallow water model","title":"Shallow water model","text":"beginalign\n  partial_t boldsymbolu + (zeta boldsymbolhat z + boldsymbolf)  timesboldsymbolu  =\n  - boldsymbolnabla left  g (h +b) + frac12 boldsymbolu cdot boldsymbolu right    \n  partial_t h + boldsymbolnabla boldsymbolcdot (boldsymbolu h)  = 0  \nendalign","category":"page"},{"location":"physics/shallow_water_model/","page":"Shallow water model","title":"Shallow water model","text":"where zeta(x y t) =  partial_x v - partial_y u is the vertical component of the relative vorticity.","category":"page"},{"location":"physics/shallow_water_model/","page":"Shallow water model","title":"Shallow water model","text":"The elevation of the bottom bathymetry, measured with respect to the free-surface at rest, is b(x y). The free-surface elevation eta is then:","category":"page"},{"location":"physics/shallow_water_model/","page":"Shallow water model","title":"Shallow water model","text":"eta(x y t) = h(x y t) + b(x y)  ","category":"page"},{"location":"physics/shallow_water_model/","page":"Shallow water model","title":"Shallow water model","text":"The ConservativeFormulation() uses the volume transport along each direction boldsymbolu h = (u h v h) and the total depth of the fluid h as the dynamical variables.  The shallow water dynamics in conservative form is:","category":"page"},{"location":"physics/shallow_water_model/","page":"Shallow water model","title":"Shallow water model","text":"beginalign\n  partial_t (boldsymbolu h) + boldsymbolnabla boldsymbolcdot left ( boldsymbolu boldsymbolu h right ) + boldsymbolf times (boldsymbolu h)  = - g h boldsymbolnabla left ( h + b right )  \n  partial_t h + boldsymbolnabla boldsymbolcdot (boldsymbolu h)  = 0  \nendalign","category":"page"},{"location":"physics/shallow_water_model/","page":"Shallow water model","title":"Shallow water model","text":"where boldsymbolnabla boldsymbolcdot left ( boldsymbolu boldsymbolu h right ) denotes a vector whose components are boldsymbolnabla boldsymbolcdot (boldsymbolu boldsymbolu h)_i = boldsymbolnabla boldsymbolcdot (u_i boldsymbolu h). We can retrieve the flow velocities by dividing the corresponding transport by the fluid's height, e.g., v = vh / h.","category":"page"},{"location":"model_setup/background_fields/#Background-fields","page":"Background fields","title":"Background fields","text":"","category":"section"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"BackgroundFields are velocity and tracer fields around which the resolved velocity and tracer fields evolve. Only the advective terms associated with the interaction between background and resolved fields are included. For example, tracer advection is described by","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"boldsymbolnabla boldsymbolcdot left ( boldsymbolv c right )  ","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"where boldsymbolv is the resolved velocity field and c is the resolved tracer field corresponding to model.tracers.c.","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"When a background field C is provided, the tracer advection term becomes","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"boldsymbolnabla boldsymbolcdot left ( boldsymbolv c right )\n    + boldsymbolnabla boldsymbolcdot left ( boldsymbolv C right )  ","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"When both a background field velocity field boldsymbolU and a background tracer field C are provided, then the tracer advection term becomes","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"boldsymbolnabla boldsymbolcdot left ( boldsymbolv c right )\n    + boldsymbolnabla boldsymbolcdot left ( boldsymbolv C right )\n    + boldsymbolnabla boldsymbolcdot left ( boldsymbolU c right )  ","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"Notice that the term boldsymbolnabla boldsymbolcdot left ( boldsymbolU C right ) is neglected: only the terms describing the advection of resolved tracer by the background velocity field and the advection of background tracer by the resolved velocity field are included. An analogous statement holds for the advection of background momentum by the resolved velocity field. Other possible terms associated with the Coriolis force, buoyancy, turbulence closures, and surface waves acting on background fields are neglected.","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"compat: Model compatibility\nBackgroundFields are only supported by NonhydrostaticModel.","category":"page"},{"location":"model_setup/background_fields/#Specifying-background-fields","page":"Background fields","title":"Specifying background fields","text":"","category":"section"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"BackgroundFields are defined by functions of (x y z t) and optional parameters. A simple example is","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"using Oceananigans\n\nU(x, y, z, t) = 0.2 * z\n\ngrid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))\n\nmodel = NonhydrostaticModel(grid = grid, background_fields = (u=U,))\n\nmodel.background_fields.velocities.u\n\n# output\nFunctionField located at (Face, Center, Center)\nâ”œâ”€â”€ func: U (generic function with 1 method)\nâ”œâ”€â”€ grid: 1Ã—1Ã—1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1Ã—1Ã—1 halo\nâ”œâ”€â”€ clock: Clock{Float64, Float64}(time=0 seconds, iteration=0, last_Î”t=Inf days)\nâ””â”€â”€ parameters: nothing","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"BackgroundFields are specified by passing them to the kwarg background_fields in the NonhydrostaticModel constructor. The kwarg background_fields expects a NamedTuple of fields, which are internally sorted into velocities and tracers, wrapped in FunctionFields, and assigned their appropriate locations.","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"BackgroundFields with parameters require using the BackgroundField wrapper:","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"using Oceananigans\n\nparameters = (Î±=3.14, N=1.0, f=0.1)\n\n# Background fields are defined via function of x, y, z, t, and optional parameters\nU(x, y, z, t, Î±) = Î± * z\nB(x, y, z, t, p) = - p.Î± * p.f * y + p.N^2 * z\n\nU_field = BackgroundField(U, parameters=parameters.Î±)\nB_field = BackgroundField(B, parameters=parameters)\n\n# output\nBackgroundField{typeof(B), @NamedTuple{Î±::Float64, N::Float64, f::Float64}}\nâ”œâ”€â”€ func: B (generic function with 1 method)\nâ””â”€â”€ parameters: (Î± = 3.14, N = 1.0, f = 0.1)","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"When inserted into NonhydrostaticModel, we get","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))\n\nmodel = NonhydrostaticModel(grid = grid, background_fields = (u=U_field, b=B_field),\n                            tracers=:b, buoyancy=BuoyancyTracer())\n\nmodel.background_fields.tracers.b\n\n# output\nFunctionField located at (Center, Center, Center)\nâ”œâ”€â”€ func: B (generic function with 1 method)\nâ”œâ”€â”€ grid: 1Ã—1Ã—1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1Ã—1Ã—1 halo\nâ”œâ”€â”€ clock: Clock{Float64, Float64}(time=0 seconds, iteration=0, last_Î”t=Inf days)\nâ””â”€â”€ parameters: (Î± = 3.14, N = 1.0, f = 0.1)","category":"page"},{"location":"model_setup/callbacks/#Callbacks","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"A Callback can be used to execute an arbitrary user-defined function on the simulation at user-defined times.","category":"page"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"For example, we can specify a callback which displays the run time every 2 iterations:","category":"page"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"using Oceananigans\n\nmodel = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)))\n\nsimulation = Simulation(model, Î”t=1, stop_iteration=10)\n\nshow_time(sim) = @info \"Time is $(prettytime(sim.model.clock.time))\"\n\nsimulation.callbacks[:total_A] = Callback(show_time, IterationInterval(2))\n\nsimulation","category":"page"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"Now when simulation runs the simulation the callback is called.","category":"page"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"run!(simulation)","category":"page"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"We can also use the convenience add_callback!:","category":"page"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"add_callback!(simulation, show_time, name=:total_A_via_convenience, IterationInterval(2))\n\nsimulation","category":"page"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"The keyword argument callsite determines the moment at which the callback is executed. By default, callsite = TimeStepCallsite(), indicating execution after the completion of a timestep. The other options are callsite = TendencyCallsite() that executes the callback after the tendencies are computed but before taking a timestep and callsite = UpdateStateCallsite() that executes the callback within update_state!, after auxiliary variables have been computed (for multi-stage time-steppers, update_state! may be called multiple times per timestep).","category":"page"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"As an example of a callback with callsite = TendencyCallsite() , we show below how we can manually add to the tendency field of one of the velocity components. Here we've chosen the :u field using parameters:","category":"page"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"using Oceananigans\nusing Oceananigans: TendencyCallsite\n\nmodel = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)))\n\nsimulation = Simulation(model, Î”t=1, stop_iteration=10)\n\nfunction modify_tendency!(model, params)\n    model.timestepper.Gâ¿[params.c] .+= params.Î´\n    return nothing\nend\n\nsimulation.callbacks[:modify_u] = Callback(modify_tendency!, IterationInterval(1),\n                                           callsite = TendencyCallsite(),\n                                           parameters = (c = :u, Î´ = 1))\n\nrun!(simulation)","category":"page"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"Above there is no forcing at all, but due to the callback the u-velocity is increased.","category":"page"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"@info model.velocities.u","category":"page"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"note: Example only for illustration purposes\nThe above is a redundant example since it could be implemented better with a simple forcing function. We include it here though for illustration purposes of how one can use callbacks.","category":"page"},{"location":"model_setup/callbacks/#Functions","page":"Callbacks","title":"Functions","text":"","category":"section"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"Callback functions can only take one or two parameters sim - a simulation, or model for state callbacks, and optionally may also accept a NamedTuple of parameters.","category":"page"},{"location":"model_setup/callbacks/#Scheduling","page":"Callbacks","title":"Scheduling","text":"","category":"section"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"The time that callbacks are called at are specified by schedule functions which can be:","category":"page"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"IterationInterval : runs every n iterations\nTimeInterval : runs every ns of model run time\nSpecifiedTimes : runs at the specified times\nWallTimeInterval : runs every ns of wall time","category":"page"},{"location":"physics/coriolis_forces/#Coriolis-forces","page":"Coriolis forces","title":"Coriolis forces","text":"","category":"section"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"The Coriolis model controls the manifestation of the term boldsymbolf times boldsymbolv in the momentum equation.","category":"page"},{"location":"physics/coriolis_forces/#f-plane-approximation","page":"Coriolis forces","title":"f-plane approximation","text":"","category":"section"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"Under an f-plane approximation[3] the reference frame in which the momentum and tracer equations are solved rotates at a constant rate.","category":"page"},{"location":"physics/coriolis_forces/#The-traditional-f-plane-approximation","page":"Coriolis forces","title":"The traditional f-plane approximation","text":"","category":"section"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"In the traditional f-plane approximation, the coordinate system rotates around a vertical axis such that","category":"page"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"    boldsymbolf = f boldsymbolhat z  ","category":"page"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"where f is constant and determined by the user.","category":"page"},{"location":"physics/coriolis_forces/#The-arbitrary-axis-constant-Coriolis-approximation","page":"Coriolis forces","title":"The arbitrary-axis constant-Coriolis approximation","text":"","category":"section"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"In this approximation, the coordinate system rotates around an axis in the xyz-plane, such that","category":"page"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"    boldsymbolf = f_x boldsymbolhat x + f_y boldsymbolhat y + f_z boldsymbolhat z  ","category":"page"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"where f_x, f_y, and f_z are constants determined by the user.","category":"page"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"[3]: The f-plane approximation is used to model the effects of Earth's rotation on anisotropic   fluid motion in a plane tangent to the Earth's surface. In this case, the projection of   the Earth's rotation vector at latitude varphi and onto a coordinate system in which   x y z correspond to the directions east, north, and up is   boldsymbolf approx frac4 pitextday left ( cos varphi boldsymbolhat y + sin varphi boldsymbolhat z right )     where the Earth's rotation rate is approximately 2 pi  textday. The traditional   f-plane approximation neglects the y-component of this projection, which is appropriate   for fluid motions with large horizontal-to-vertical aspect ratios.","category":"page"},{"location":"physics/coriolis_forces/#\\beta-plane-approximation","page":"Coriolis forces","title":"beta-plane approximation","text":"","category":"section"},{"location":"physics/coriolis_forces/#The-traditional-\\beta-plane-approximation","page":"Coriolis forces","title":"The traditional beta-plane approximation","text":"","category":"section"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"Under the traditional beta-plane approximation, the rotation axis is vertical as for the f-plane approximation, but f is expanded in a Taylor series around a central latitude such that","category":"page"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"    boldsymbolf = left ( f_0 + beta y right ) boldsymbolhat z  ","category":"page"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"where f_0 is the planetary vorticity at some central latitude, and beta is the planetary vorticity gradient. The beta-plane model is not periodic in y and thus can be used only in domains that are bounded in the y-direction.","category":"page"},{"location":"physics/coriolis_forces/#The-non-traditional-\\beta-plane-approximation","page":"Coriolis forces","title":"The non-traditional beta-plane approximation","text":"","category":"section"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"The non-traditional beta-plane approximation accounts for the latitudinal variation of both the locally vertical and the locally horizontal components of the rotation vector","category":"page"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"    boldsymbolf = left 2Omegacosvarphi_0 left( 1 -  fraczR right) + gamma y right boldsymbolhat y\n           + left 2Omegasinvarphi_0 left( 1 + 2fraczR right) + beta  y right boldsymbolhat z  ","category":"page"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"as can be found in the paper by Dellar (2011), where beta = 2 Omega cos varphi_0  R and gamma = -4 Omega sin varphi_0  R.","category":"page"},{"location":"model_setup/coriolis/#Coriolis","page":"Coriolis (rotation)","title":"Coriolis","text":"","category":"section"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"The Coriolis option determines whether the fluid experiences the effect of the Coriolis force, or rotation. Currently three options are available: no rotation, f-plane, and beta-plane.","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"info: Coriolis vs. rotation\nIf you are wondering why this option is called \"Coriolis\" it is because rotational effects could include the Coriolis and centripetal forces, both of which arise in non-inertial reference frames. But here the model only considers the Coriolis force.","category":"page"},{"location":"model_setup/coriolis/#No-rotation","page":"Coriolis (rotation)","title":"No rotation","text":"","category":"section"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"By default there is no rotation. This can be made explicit by passing coriolis = nothing to a model constructor.","category":"page"},{"location":"model_setup/coriolis/#Traditional-f-plane","page":"Coriolis (rotation)","title":"Traditional f-plane","text":"","category":"section"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"To set up an f-plane with, for example, Coriolis parameter f = 10^-4 texts^-1","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"julia> coriolis = FPlane(f=1e-4)\nFPlane{Float64}(f=0.0001)","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"An f-plane can also be specified at some latitude on a spherical planet with a planetary rotation rate. For example, to specify an f-plane at a latitude of varphi = 45textN on Earth which has a rotation rate of Omega = 7292115 times 10^-5 texts^-1","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"julia> coriolis = FPlane(rotation_rate=7.292115e-5, latitude=45)\nFPlane{Float64}(f=0.000103126)","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"in which case the value of f is given by 2Omegasinvarphi.","category":"page"},{"location":"model_setup/coriolis/#Coriolis-term-for-constant-rotation-in-a-Cartesian-coordinate-system","page":"Coriolis (rotation)","title":"Coriolis term for constant rotation in a Cartesian coordinate system","text":"","category":"section"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"One can use ConstantCartesianCoriolis to set up a Coriolis acceleration term where the Coriolis parameter is constant and the rotation axis is arbitrary. For example, with boldsymbolf = (0 f_y f_z) = (0 2 1) times 10^-4 texts^-1,","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"julia> coriolis = ConstantCartesianCoriolis(fx=0, fy=2e-4, fz=1e-4)\nConstantCartesianCoriolis{Float64}: fx = 0.00e+00, fy = 2.00e-04, fz = 1.00e-04","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"Or alternatively, the same result can be achieved by specifying the magnitude of the Coriolis frequency f and the rotation_axis. So another way to get a Coriolis acceleration with the same values is:","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"julia> rotation_axis = (0, 2e-4, 1e-4)./âˆš(2e-4^2 + 1e-4^2) # rotation_axis has to be a unit vector\n(0.0, 0.8944271909999159, 0.4472135954999579)\n\njulia> coriolis = ConstantCartesianCoriolis(f=âˆš(2e-4^2+1e-4^2), rotation_axis=rotation_axis)\nConstantCartesianCoriolis{Float64}: fx = 0.00e+00, fy = 2.00e-04, fz = 1.00e-04","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"An f-plane with non-traditional Coriolis terms can also be specified at some latitude on a spherical planet with a planetary rotation rate. For example, to specify an f-plane at a latitude of varphi = 45textN on Earth which has a rotation rate of Omega = 7292115 times 10^-5 texts^-1","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"julia> coriolis = ConstantCartesianCoriolis(rotation_rate=7.292115e-5, latitude=45)\nConstantCartesianCoriolis{Float64}: fx = 0.00e+00, fy = 1.03e-04, fz = 1.03e-04","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"in which case f_z = 2Omegasinvarphi and f_y = 2Omegacosvarphi.","category":"page"},{"location":"model_setup/coriolis/#Traditional-\\beta-plane","page":"Coriolis (rotation)","title":"Traditional beta-plane","text":"","category":"section"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"To set up a beta-plane the background rotation rate f_0 and the beta parameter must be specified. For example, a beta-plane with f_0 = 10^-4 texts^-1 and beta = 15 times 10^-11 texts^-1textm^-1 can be set up with","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"julia> coriolis = BetaPlane(fâ‚€=1e-4, Î²=1.5e-11)\nBetaPlane{Float64}(fâ‚€=0.0001, Î²=1.5e-11)","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"Alternatively, a beta-plane can also be set up at some latitude on a spherical planet with a planetary rotation rate and planetary radius. For example, to specify a beta-plane at a latitude of varphi = 10^circS on Earth which has a rotation rate of Omega = 7292115 times 10^-5 texts^-1 and a radius of R = 6371 textkm","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"julia> coriolis = BetaPlane(rotation_rate=7.292115e-5, latitude=-10, radius=6371e3)\nBetaPlane{Float64}(fâ‚€=-2.53252e-5, Î²=2.25438e-11)","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"in which case f_0 = 2Omegasinvarphi and beta = 2Omegacosvarphi  R.","category":"page"},{"location":"model_setup/coriolis/#Non-traditional-\\beta-plane","page":"Coriolis (rotation)","title":"Non-traditional beta-plane","text":"","category":"section"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"A non-traditional beta-plane requires either 5 parameters (by default Earth's radius and rotation rate are used):","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"julia> NonTraditionalBetaPlane(fz=1e-4, fy=2e-4, Î²=4e-11, Î³=-8e-11)\nNonTraditionalBetaPlane{Float64}(fz = 1.00e-04, fy = 2.00e-04, Î² = 4.00e-11, Î³ = -8.00e-11, R = 6.37e+06)","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"or the rotation rate, radius, and latitude:","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"julia> NonTraditionalBetaPlane(rotation_rate=5.31e-5, radius=252.1e3, latitude=10)\nNonTraditionalBetaPlane{Float64}(fz = 1.84e-05, fy = 1.05e-04, Î² = 4.15e-10, Î³ = -1.46e-10, R = 2.52e+05)","category":"page"},{"location":"numerical_implementation/boundary_conditions/#numerical_bcs","page":"Boundary conditions","title":"Numerical implementation of boundary conditions","text":"","category":"section"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"We adopt a mixed approach for implementing boundary conditions that uses both halo regions and \"direct\" imposition of boundary conditions, depending on the condition prescribed.","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"We illustrate how boundary conditions are implemented by considering the tracer equation","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"    beginalign\n    partial_t c = - boldsymbolv boldsymbolcdot boldsymbolnabla c\n                   - boldsymbolnabla boldsymbolcdot boldsymbolq_c\n                   + F_c  \n    labeleqtracer\n    endalign","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"where boldsymbolq_c is the diffusive flux of c and F_c is an arbitrary source term.","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"See Model setup: boundary conditions for how to create and use these boundary conditions in Oceananigans.","category":"page"},{"location":"numerical_implementation/boundary_conditions/#Gradient-boundary-conditions","page":"Boundary conditions","title":"Gradient boundary conditions","text":"","category":"section"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Users impose gradient boundary conditions by prescribing the gradient gamma of a field c across an external boundary partial Omega_b. The prescribed gradient gamma may be a constant, discrete array of values, or an arbitrary function. The gradient boundary condition is enforced setting the value of halo points located outside the domain interior such that","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"    beginequation\n    labeleqgradient-bc\n    hatboldsymboln boldsymbolcdot boldsymbolnabla c _partial Omega_b = gamma  \n    endequation","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"where hatboldsymboln is the vector normal to partial Omega_b.","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Across the bottom boundary in z, for example, this requires that","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"    beginequation\n    labeleqlinear-extrapolation\n    c_i j 0 = c_i j 1 + gamma_i j 1 tfrac12 left ( Delta z_i j 1 + Delta z_i j 0 right )  \n    endequation","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"where Delta z_i j 1 = Delta z_i j 0 are the heights of the finite volume at i j and k=1 and k=0. This prescription implies that the z-derivative of c across the boundary at k=1 is","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"    beginequation\n    partial_z c  _i j 1 equiv\n        fracc_i j 1 - c_i j 0tfrac12 left ( Delta z_i j 1 + Delta z_i j 0 right )\n            = gamma_i j 1  \n    endequation","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"as prescribed by the user.","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Gradient boundary conditions are represented by the Gradient type.","category":"page"},{"location":"numerical_implementation/boundary_conditions/#Value-boundary-conditions","page":"Boundary conditions","title":"Value boundary conditions","text":"","category":"section"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Users impose value boundary conditions by prescribing c^b, the value of c on the external boundary partial Omega_b. The value c^b may be a constant, array of discrete values, or an arbitrary function. To enforce a value boundary condition, the gradient associated with the difference between c^b and c at boundary-adjacent nodes is diagnosed and used to set the value of the c halo point located outside the boundary.","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"At the bottom boundary in z, for example, this means that the gradient of c is determined by","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"    beginequation\n    gamma = fracc_i j 1 - c^b_i j 1tfrac12 Delta z_i j 1  \n    endequation","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"which is then used to set the halo point c_i j 0 via linear extrapolation.","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Value boundary conditions are represented by the Value type.","category":"page"},{"location":"numerical_implementation/boundary_conditions/#Flux-boundary-conditions","page":"Boundary conditions","title":"Flux boundary conditions","text":"","category":"section"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Users impose flux boundary conditions by prescribing the flux q_c  _b of c across the external boundary partial Omega_b. The flux q_c  _b may be a constant, array of discrete values, or arbitrary function. To explain how flux boundary conditions are imposed in Oceananigans.jl, we note that the average of the tracer conservation equation over a finite volume yields","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"    beginequation\n    labeleqdcdt\n    partial_t c_i j k = - frac1V_i j k oint_partial Omega_i j k (boldsymbolv c + boldsymbolq_c)\n                                                     boldsymbolcdot hatboldsymboln   mathrmd S\n                             + frac1V_i j k int_V_i j k F_c  mathrmd V  \n    endequation","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"where the surface integral over partial Omega_i j k averages the flux of c across the six faces of the finite volume. The right-hand-side of \\eqref{eq:dc/dt} above is denoted as G_c _i j k.","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"An external boundary of a finite volume is associated with a no-penetration condition such that hatboldsymboln boldsymbolcdot boldsymbolv  _partial Omega_b = 0, where hatboldsymboln is the vector normal to partial Omega_b. Furthermore, the closures currently available in Oceananigans.jl have the property that boldsymbolq_c propto boldsymbolnabla c. Thus setting hatboldsymboln boldsymbolcdot boldsymbolnabla c  _partial Omega_b = 0 on the external boundary implies that the total flux of c across the external boundary is","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"    beginequation\n    hatboldsymboln boldsymbolcdot left ( boldsymbolv c + boldsymbolq_c right ) _partial Omega_b = 0  \n    endequation","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Oceananigans.jl exploits this fact to define algorithm that prescribe fluxes across external boundaries partial Omega_b:","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Impose a constant gradient hatboldsymboln boldsymbolcdot boldsymbolnabla c  _partial Omega_b = 0 across external boundaries via using halo points (similar to \\eqref{eq:gradient-bc}), which ensures that the evaluation of G_c in boundary-adjacent cells does not include fluxes across the external boundary, and;\nAdd the prescribed flux to the boundary-adjacent volumes prior to calculating G_c: G_c  _b = G_c  _b - fracA_bV_b q_c  _b  textsign(hatboldsymboln), where G_c  _b denotes values of G_c in boundary-adjacent volumes, q_c  _b is the flux prescribed along the boundary, V_b is the volume of the boundary-adjacent cell, and A_b is the area of the external boundary of the boundary-adjacent cell.\nThe factor textsign(hatboldsymboln) is -1 and +1 on \"left\" and \"right\" boundaries, and accounts for the fact that a positive flux on a left boundary where textsign(hatboldsymboln) = -1 implies an \"inward\" flux of c that increases interior values of c, whereas a positive flux on a right boundary where textsign(hatboldsymboln) = 1 implies an \"outward\" flux that decreases interior values of c.","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Flux boundary conditions are represented by the Flux type.","category":"page"},{"location":"numerical_implementation/boundary_conditions/#Open-boundary-conditions","page":"Boundary conditions","title":"Open boundary conditions","text":"","category":"section"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Open boundary conditions directly specify the value of the halo points. Typically this is used to impose no penetration boundary conditions, i.e. setting wall normal velocity components on to zero on the boundary.","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"The nuance here is that open boundaries behave differently for fields on face points in the boundary direction due to the staggered grid. For example, the u-component of velocity lies on (Face, Center, Center) points so for open west or east boundaries the point specified by the boundary condition is the point lying on the boundary, where as for a tracer on (Center, Center, Center) points the open boundary condition specifies a point outside of the domain (hence the difference with Value boundary conditions).","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"The other important detail is that open (including no-penetration) boundary conditions are the only conditions used on wall normal velocities when the domain is not periodic. This means that their value affects the pressure calculation for nonhydrostatic models as it is involved in calculating the divergence in the boundary adjacent center point (as described in the fractional step method documentation). Usually boundary points are filled for the predictor velocity (i.e. before the pressure is calculated), and on the corrected field (i.e. after the pressure correction is applied), but for open boundaries this would result in the boundary adjacent center point becoming divergent so open boundaries are only filled for the predictor velocity and stay the same after the pressure correction (so the boundary point is filled with the final corrected velocity at the predictor step).","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"The restriction arrises as the boundary condition is specifying the wall normal velocity, hatboldsymbolncdotboldsymbolu, which leads to the pressure boundary condition","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"    beginequation\n    labeleqpressure_boundary_condition\n    Delta t  hatboldsymbolncdotboldsymbolnablap^n+1big _partialOmega = leftDelta t  hatboldsymbolncdotboldsymbolu^star - hatboldsymbolncdotboldsymbolu^n+1right\n    endequation","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"implying that there is a pressure gradient across the boundary. Since we solve the pressure poisson equation (nabla^2p^n+1=fracboldsymbolnablacdotboldsymbolu^starDelta t) using the method described by Schumann and Sweet (1988) we have to move inhomogeneus boundary conditions on the pressure to the right hand side. In order to do this we define a new field phi where","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"    beginequation\n    labeleqmodified_pressure_field\n    phi = p^n+1 quad textinside quad Omega quad textbut quad boldsymbolnabla cdot boldsymbolnabla phi  big _partialOmega = 0\n    endequation","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"This moves the boundary condition to the right hand side as phi becomes","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"    beginequation\n    labeleqmodified_pressure_poisson\n    boldsymbolnabla^2phi^n+1 = boldsymbolnablacdotleftfracboldsymbolu^starDelta t - deltaleft(boldsymbolx - boldsymbolx_Omegaright)boldsymbolnablapright\n    endequation","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Given the boundary condition on pressure given above, we can define a new modified predictor velocity which is equal to the predictor velocity within the domain but shares boundary conditions with the corrected field,","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"    beginequation\n    labeleqquasi_predictor_velocity\n    tildeboldsymbolu^star=boldsymbolu^star + deltaleft(boldsymbolx - boldsymbolx_Omegaright)(boldsymbolu^n+1 - boldsymbolu^star)\n    endequation","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"The modified pressure poisson equation becomes nabla^2p^n+1=fracboldsymbolnablacdottildeboldsymbolu^starDelta t which can easily be solved.","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Perhaps a more intuitive way to consider this is to recall that the corrector step projects boldsymbolu^star to the space of divergenece free velocity by applying","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"    beginequation\n    labeleqpressure_correction_step\n    boldsymbolu^n+1 = boldsymbolu^star - Delta tboldsymbolnablap^n+1\n    endequation","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"but we have changed p^n+1 to phi and boldsymbolu^star to tildeboldsymbolu^star so for boldsymbolnablaphi big _partialOmega = 0 the modified predictor velocity must equal the corrected velocity on the boundary.","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"For simple open boundary conditions such as no penetration or a straight forward prescription of a known velocity at t^n+1 this is simple to implement as we just set the boundary condition on the predictor velocity and don't change it after the correction. But some open boundary methods calculate the boundary value based on the interior solution. As a simple example, if we wanted to set the wall normal veloicty gradient to zero at the west boundary then we would set the boundary point to","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"    beginequation\n    labeleqzero_wall_normal_velocity_gradient\n    u^star_1jk approx u^star_3jk + (u^star_2jk - u^star_jk4)  2 + mathcalO(Delta x^2)\n    endequation","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"but we then pressure correct the interior so a new mathcalO(Delta t) error is introduced as","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"    beginalign\n    u^n+1_1jk approx u^n+1_3jk + (u^n+1_2jk - u^n+1_jk4)  2 + mathcalO(Delta x^2)\n    = u^star_1jk - Delta t left(boldsymbolnablap^n+1_3jk + (boldsymbolnablap^n+1_2jk - boldsymbolnablap^n+1_4jk)  2right) + mathcalO(Delta x^2)\n    approx u^star_1jk + mathcalO(Delta x^2) + mathcalO(Delta t)\n    endalign","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"This is prefered to a divergent interior solution as open boundary conditions (except no penetration) are typlically already unphysical and only used in an attempt to allow information to enter or exit the domain.","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Open boundary conditions are represented by the Open type.","category":"page"},{"location":"numerical_implementation/pressure_decomposition/#pressure_decomposition","page":"Pressure decomposition","title":"Pressure decomposition","text":"","category":"section"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"In the numerical implementation of the momentum equations in the NonhydrostaticModel, the kinematic pressure p is split into \"background\" and \"dynamic\" parts via","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"    beginequation\n    labeleqpressure\n    p(boldsymbolx t) = p_textbackground(boldsymbolx t) + p(boldsymbolx t)  \n    endequation","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"The background pressure component in \\eqref{eq:pressure} is defined so that the vertical component of its gradient balances the background density field:","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"    beginalign\n    partial_z p_texttotal hydrostatic  = - g left ( 1 + fracrho_*rho_0 right )  \n    endalign","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"Above, we use the notation introduced in the Boussinesq approximation section.","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"Optionally, we may further decompose the dynamic pressure perturbation p into a \"hydrostatic anomaly\" and \"nonhydrostatic\" part:","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"    beginalign\n    p(boldsymbolx t) = p_rmhyd(boldsymbol(x) t) + p_rmnon(boldsymbolx t)  \n    endalign","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"where","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"    beginalign\n    partial_z p_rmhyd equiv underbrace- g fracrhorho_0_= b  \n    endalign","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"With this pressure decomposition, the kinematic pressure gradient that appears in the momentum equations (after we've employed the the Boussinesq approximation) becomes","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"    beginalign\n    boldsymbolnabla p = - g fracrhorho_0 hat boldsymbolz + boldsymbolnabla p\n                          = - g fracrhorho_0 hat boldsymbolz + boldsymbolnabla p_rmnon + boldsymbolnabla_h p_rmhyd  \n    endalign","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"where boldsymbolnabla_h equiv boldsymbolhat x partial_x +  boldsymbolhat y partial_y.","category":"page"}]
}

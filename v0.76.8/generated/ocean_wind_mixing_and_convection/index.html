<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Ocean wind mixing and convection Â· Oceananigans.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://clima.github.io/OceananigansDocumentation/stable/generated/ocean_wind_mixing_and_convection/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Oceananigans.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../quick_start/">Quick start</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../one_dimensional_diffusion/">One-dimensional diffusion</a></li><li><a class="tocitem" href="../two_dimensional_turbulence/">Two-dimensional turbulence</a></li><li><a class="tocitem" href="../internal_wave/">Internal wave</a></li><li><a class="tocitem" href="../convecting_plankton/">Convecting plankton</a></li><li class="is-active"><a class="tocitem" href>Ocean wind mixing and convection</a><ul class="internal"><li><a class="tocitem" href="#Install-dependencies"><span>Install dependencies</span></a></li><li><a class="tocitem" href="#The-grid"><span>The grid</span></a></li><li><a class="tocitem" href="#Buoyancy-that-depends-on-temperature-and-salinity"><span>Buoyancy that depends on temperature and salinity</span></a></li><li><a class="tocitem" href="#Boundary-conditions"><span>Boundary conditions</span></a></li><li><a class="tocitem" href="#Model-instantiation"><span>Model instantiation</span></a></li><li><a class="tocitem" href="#Initial-conditions"><span>Initial conditions</span></a></li><li><a class="tocitem" href="#Setting-up-a-simulation"><span>Setting up a simulation</span></a></li><li><a class="tocitem" href="#Output"><span>Output</span></a></li><li><a class="tocitem" href="#Turbulence-visualization"><span>Turbulence visualization</span></a></li></ul></li><li><a class="tocitem" href="../langmuir_turbulence/">Langmuir turbulence</a></li><li><a class="tocitem" href="../baroclinic_adjustment/">Baroclinic adjustment</a></li><li><a class="tocitem" href="../kelvin_helmholtz_instability/">Kelvin-Helmholtz instability</a></li><li><a class="tocitem" href="../shallow_water_Bickley_jet/">Shallow water Bickley jet</a></li><li><a class="tocitem" href="../horizontal_convection/">Horizontal convection</a></li><li><a class="tocitem" href="../tilted_bottom_boundary_layer/">Tilted bottom boundary layer</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Physics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../physics/notation/">Coordinate system and notation</a></li><li><a class="tocitem" href="../../physics/boussinesq/">Boussinesq approximation</a></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label"><code>NonhydrostaticModel</code></span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../physics/nonhydrostatic_model/">Nonhydrostatic model</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label"><code>HydrostaticFreeSurfaceModel</code></span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../physics/hydrostatic_free_surface_model/">Hydrostatic model with a free surface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label"><code>ShallowWaterModel</code></span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../physics/shallow_water_model/">Shallow water model</a></li></ul></li><li><a class="tocitem" href="../../physics/boundary_conditions/">Boundary conditions</a></li><li><a class="tocitem" href="../../physics/buoyancy_and_equations_of_state/">Buoyancy models and equations of state</a></li><li><a class="tocitem" href="../../physics/coriolis_forces/">Coriolis forces</a></li><li><a class="tocitem" href="../../physics/turbulence_closures/">Turbulence closures</a></li><li><a class="tocitem" href="../../physics/surface_gravity_waves/">Surface gravity waves and the Craik-Leibovich approximation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Numerical implementation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../numerical_implementation/finite_volume/">Finite volume method</a></li><li><a class="tocitem" href="../../numerical_implementation/spatial_operators/">Spatial operators</a></li><li><a class="tocitem" href="../../numerical_implementation/pressure_decomposition/">Pressure decomposition</a></li><li><a class="tocitem" href="../../numerical_implementation/time_stepping/">Time stepping</a></li><li><a class="tocitem" href="../../numerical_implementation/boundary_conditions/">Boundary conditions</a></li><li><a class="tocitem" href="../../numerical_implementation/elliptic_solvers/">Elliptic solvers</a></li><li><a class="tocitem" href="../../numerical_implementation/large_eddy_simulation/">Large eddy simulation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Model setup</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_setup/overview/">Overview</a></li><li><a class="tocitem" href="../../model_setup/architecture/">Architecture</a></li><li><a class="tocitem" href="../../model_setup/number_type/">Number type</a></li><li><a class="tocitem" href="../../model_setup/grids/">Grid</a></li><li><a class="tocitem" href="../../model_setup/clock/">Clock</a></li><li><a class="tocitem" href="../../model_setup/coriolis/">Coriolis (rotation)</a></li><li><a class="tocitem" href="../../model_setup/tracers/">Tracers</a></li><li><a class="tocitem" href="../../model_setup/buoyancy_and_equation_of_state/">Buoyancy models and equation of state</a></li><li><a class="tocitem" href="../../model_setup/boundary_conditions/">Boundary conditions</a></li><li><a class="tocitem" href="../../model_setup/forcing_functions/">Forcing functions</a></li><li><a class="tocitem" href="../../model_setup/background_fields/">Background fields</a></li><li><a class="tocitem" href="../../model_setup/turbulent_diffusivity_closures_and_les_models/">Turbulent diffusivity closures and LES models</a></li><li><a class="tocitem" href="../../model_setup/lagrangian_particles/">Lagrangian particles</a></li><li><a class="tocitem" href="../../model_setup/diagnostics/">Diagnostics</a></li><li><a class="tocitem" href="../../model_setup/output_writers/">Output writers</a></li><li><a class="tocitem" href="../../model_setup/checkpointing/">Checkpointing</a></li><li><a class="tocitem" href="../../model_setup/setting_initial_conditions/">Setting initial conditions</a></li></ul></li><li><a class="tocitem" href="../../simulation_tips/">Simulation tips</a></li><li><a class="tocitem" href="../../contributing/">Contributor&#39;s guide</a></li><li><a class="tocitem" href="../../gallery/">Gallery</a></li><li><a class="tocitem" href="../../references/">References</a></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">Appendix</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../appendix/staggered_grid/">Staggered grid</a></li><li><a class="tocitem" href="../../appendix/fractional_step/">Fractional step method</a></li><li><a class="tocitem" href="../../appendix/convergence_tests/">Convergence tests</a></li><li><a class="tocitem" href="../../appendix/benchmarks/">Performance benchmarks</a></li><li><a class="tocitem" href="../../appendix/library/">Library</a></li><li><a class="tocitem" href="../../appendix/function_index/">Function index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Ocean wind mixing and convection</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Ocean wind mixing and convection</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="gpu_example"><a class="docs-heading-anchor" href="#gpu_example">Wind- and convection-driven mixing in an ocean surface boundary layer</a><a id="gpu_example-1"></a><a class="docs-heading-anchor-permalink" href="#gpu_example" title="Permalink"></a></h1><p>This example simulates mixing by three-dimensional turbulence in an ocean surface boundary layer driven by atmospheric winds and convection. It demonstrates:</p><ul><li>How to set-up a grid with varying spacing in the vertical direction</li><li>How to use the <code>SeawaterBuoyancy</code> model for buoyancy with a linear equation of state.</li><li>How to use a turbulence closure for large eddy simulation.</li><li>How to use a function to impose a boundary condition.</li></ul><h2 id="Install-dependencies"><a class="docs-heading-anchor" href="#Install-dependencies">Install dependencies</a><a id="Install-dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#Install-dependencies" title="Permalink"></a></h2><p>First let&#39;s make sure we have all required packages installed.</p><pre><code class="language-julia hljs">using Pkg
pkg&quot;add Oceananigans, CairoMakie&quot;</code></pre><p>We start by importing all of the packages and functions that we&#39;ll need for this example.</p><pre><code class="language-julia hljs">using Random
using Printf
using CairoMakie

using Oceananigans
using Oceananigans.Units: minute, minutes, hour</code></pre><h2 id="The-grid"><a class="docs-heading-anchor" href="#The-grid">The grid</a><a id="The-grid-1"></a><a class="docs-heading-anchor-permalink" href="#The-grid" title="Permalink"></a></h2><p>We use 32Â²Ã24 grid points with 2 m grid spacing in the horizontal and varying spacing in the vertical, with higher resolution closer to the surface. Here we use a stretching function for the vertical nodes that maintains relatively constant vertical spacing in the mixed layer, which is desirable from a numerical standpoint:</p><pre><code class="language-julia hljs">Nz = 24          # number of points in the vertical direction
Lz = 32          # (m) domain depth

refinement = 1.2 # controls spacing near surface (higher means finer spaced)
stretching = 12  # controls rate of stretching at bottom

# Normalized height ranging from 0 to 1
h(k) = (k - 1) / Nz

# Linear near-surface generator
Î¶â(k) = 1 + (h(k) - 1) / refinement

# Bottom-intensified stretching function
Î£(k) = (1 - exp(-stretching * h(k))) / (1 - exp(-stretching))

# Generating function
z_faces(k) = Lz * (Î¶â(k) * Î£(k) - 1)

grid = RectilinearGrid(CPU();
                       size = (32, 32, Nz),
                          x = (0, 64),
                          y = (0, 64),
                          z = z_faces)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">32Ã32Ã24 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã3Ã3 halo
âââ Periodic x â [0.0, 64.0)  regularly spaced with Îx=2.0
âââ Periodic y â [0.0, 64.0)  regularly spaced with Îy=2.0
âââ Bounded  z â [-32.0, 0.0] variably spaced with min(Îz)=1.11123, max(Îz)=2.53571</code></pre><p>We plot vertical spacing versus depth to inspect the prescribed grid stretching:</p><pre><code class="language-julia hljs">fig = Figure(resolution=(1200, 800))
ax = Axis(fig[1, 1], ylabel = &quot;Depth (m)&quot;, xlabel = &quot;Vertical spacing (m)&quot;)
lines!(ax, grid.Îzáµáµá¶[1:grid.Nz], grid.záµáµá¶[1:grid.Nz])
scatter!(ax, grid.Îzáµáµá¶[1:Nz], grid.záµáµá¶[1:Nz])

save(&quot;ocean_wind_mixing_convection_grid_spacing.svg&quot;, fig)</code></pre><p><img src="../ocean_wind_mixing_convection_grid_spacing.svg" alt/></p><h2 id="Buoyancy-that-depends-on-temperature-and-salinity"><a class="docs-heading-anchor" href="#Buoyancy-that-depends-on-temperature-and-salinity">Buoyancy that depends on temperature and salinity</a><a id="Buoyancy-that-depends-on-temperature-and-salinity-1"></a><a class="docs-heading-anchor-permalink" href="#Buoyancy-that-depends-on-temperature-and-salinity" title="Permalink"></a></h2><p>We use the <code>SeawaterBuoyancy</code> model with a linear equation of state,</p><pre><code class="language-julia hljs">buoyancy = SeawaterBuoyancy(equation_of_state=LinearEquationOfState(thermal_expansion = 2e-4,
                                                                    haline_contraction = 8e-4))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SeawaterBuoyancy{Float64}:
âââ gravitational_acceleration: 9.80665
âââ equation of state: LinearEquationOfState(thermal_expansion=0.0002, haline_contraction=0.0008)</code></pre><h2 id="Boundary-conditions"><a class="docs-heading-anchor" href="#Boundary-conditions">Boundary conditions</a><a id="Boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-conditions" title="Permalink"></a></h2><p>We calculate the surface temperature flux associated with surface heating of 200 W mâ»Â², reference density <code>Ïâ</code>, and heat capacity <code>cá´¾</code>,</p><pre><code class="language-julia hljs">QÊ° = 200.0  # W mâ»Â², surface _heat_ flux
Ïâ = 1026.0 # kg mâ»Â³, average density at the surface of the world ocean
cá´¾ = 3991.0 # J Kâ»Â¹ kgâ»Â¹, typical heat capacity for seawater

Qáµ = QÊ° / (Ïâ * cá´¾) # K m sâ»Â¹, surface _temperature_ flux</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4.884283985946938e-5</code></pre><p>Finally, we impose a temperature gradient <code>dTdz</code> both initially and at the bottom of the domain, culminating in the boundary conditions on temperature,</p><pre><code class="language-julia hljs">dTdz = 0.01 # K mâ»Â¹

T_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qáµ),
                                bottom = GradientBoundaryCondition(dTdz))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Oceananigans.FieldBoundaryConditions, with boundary conditions
âââ west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
âââ east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
âââ south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
âââ north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
âââ bottom: GradientBoundaryCondition: 0.01
âââ top: FluxBoundaryCondition: 4.88428e-5
âââ immersed: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)</code></pre><p>Note that a positive temperature flux at the surface of the ocean implies cooling. This is because a positive temperature flux implies that temperature is fluxed upwards, out of the ocean.</p><p>For the velocity field, we imagine a wind blowing over the ocean surface with an average velocity at 10 meters <code>uââ</code>, and use a drag coefficient <code>cá´°</code> to estimate the kinematic stress (that is, stress divided by density) exerted by the wind on the ocean:</p><pre><code class="language-julia hljs">uââ = 10    # m sâ»Â¹, average wind velocity 10 meters above the ocean
cá´° = 2.5e-3 # dimensionless drag coefficient
Ïâ = 1.225  # kg mâ»Â³, average density of air at sea-level

Qáµ = - Ïâ / Ïâ * cá´° * uââ * abs(uââ) # mÂ² sâ»Â²</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-0.0002984892787524367</code></pre><p>The boundary conditions on <code>u</code> are thus</p><pre><code class="language-julia hljs">u_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qáµ))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Oceananigans.FieldBoundaryConditions, with boundary conditions
âââ west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
âââ east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
âââ south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
âââ north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
âââ bottom: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
âââ top: FluxBoundaryCondition: -0.000298489
âââ immersed: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)</code></pre><p>For salinity, <code>S</code>, we impose an evaporative flux of the form</p><pre><code class="language-julia hljs">@inline QË¢(x, y, t, S, evaporation_rate) = - evaporation_rate * S # [salinity unit] m sâ»Â¹</code></pre><p>where <code>S</code> is salinity. We use an evporation rate of 1 millimeter per hour,</p><pre><code class="language-julia hljs">evaporation_rate = 1e-3 / hour # m sâ»Â¹</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2.7777777777777776e-7</code></pre><p>We build the <code>Flux</code> evaporation <code>BoundaryCondition</code> with the function <code>QË¢</code>, indicating that <code>QË¢</code> depends on salinity <code>S</code> and passing the parameter <code>evaporation_rate</code>,</p><pre><code class="language-julia hljs">evaporation_bc = FluxBoundaryCondition(QË¢, field_dependencies=:S, parameters=evaporation_rate)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">FluxBoundaryCondition: ContinuousBoundaryFunction QË¢ at (Nothing, Nothing, Nothing)</code></pre><p>The full salinity boundary conditions are</p><pre><code class="language-julia hljs">S_bcs = FieldBoundaryConditions(top=evaporation_bc)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Oceananigans.FieldBoundaryConditions, with boundary conditions
âââ west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
âââ east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
âââ south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
âââ north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
âââ bottom: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
âââ top: FluxBoundaryCondition: ContinuousBoundaryFunction QË¢ at (Nothing, Nothing, Nothing)
âââ immersed: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)</code></pre><h2 id="Model-instantiation"><a class="docs-heading-anchor" href="#Model-instantiation">Model instantiation</a><a id="Model-instantiation-1"></a><a class="docs-heading-anchor-permalink" href="#Model-instantiation" title="Permalink"></a></h2><p>We fill in the final details of the model here: upwind-biased 5th-order advection for momentum and tracers, 3rd-order Runge-Kutta time-stepping, Coriolis forces, and the <code>AnisotropicMinimumDissipation</code> closure for large eddy simulation to model the effect of turbulent motions at scales smaller than the grid scale that we cannot explicitly resolve.</p><pre><code class="language-julia hljs">model = NonhydrostaticModel(; grid, buoyancy,
                            advection = UpwindBiasedFifthOrder(),
                            timestepper = :RungeKutta3,
                            tracers = (:T, :S),
                            coriolis = FPlane(f=1e-4),
                            closure = AnisotropicMinimumDissipation(),
                            boundary_conditions = (u=u_bcs, T=T_bcs, S=S_bcs))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)
âââ grid: 32Ã32Ã24 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã3Ã3 halo
âââ timestepper: RungeKutta3TimeStepper
âââ tracers: (T, S)
âââ closure: AnisotropicMinimumDissipation{ExplicitTimeDiscretization, NamedTuple{(:T, :S), Tuple{Float64, Float64}}, Float64, Nothing}
âââ buoyancy: SeawaterBuoyancy with g=9.80665 and LinearEquationOfState(thermal_expansion=0.0002, haline_contraction=0.0008) with -gÌ = ZDirection
âââ coriolis: FPlane{Float64}(f=0.0001)</code></pre><p>Notes:</p><ul><li><p>To use the Smagorinsky-Lilly turbulence closure (with a constant model coefficient) rather than <code>AnisotropicMinimumDissipation</code>, use <code>closure = SmagorinskyLilly()</code> in the model constructor.</p></li><li><p>To change the architecture to <code>GPU</code>, replace <code>CPU()</code> with <code>GPU()</code> inside the <code>grid</code> constructor.</p></li></ul><h2 id="Initial-conditions"><a class="docs-heading-anchor" href="#Initial-conditions">Initial conditions</a><a id="Initial-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Initial-conditions" title="Permalink"></a></h2><p>Our initial condition for temperature consists of a linear stratification superposed with random noise damped at the walls, while our initial condition for velocity consists only of random noise.</p><pre><code class="language-julia hljs"># Random noise damped at top and bottom
Î(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz) # noise

# Temperature initial condition: a stable density gradient with random noise superposed.
Táµ¢(x, y, z) = 20 + dTdz * z + dTdz * model.grid.Lz * 1e-6 * Î(z)

# Velocity initial condition: random noise scaled by the friction velocity.
uáµ¢(x, y, z) = sqrt(abs(Qáµ)) * 1e-3 * Î(z)

# `set!` the `model` fields using functions or constants:
set!(model, u=uáµ¢, w=uáµ¢, T=Táµ¢, S=35)</code></pre><h2 id="Setting-up-a-simulation"><a class="docs-heading-anchor" href="#Setting-up-a-simulation">Setting up a simulation</a><a id="Setting-up-a-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-up-a-simulation" title="Permalink"></a></h2><p>We set-up a simulation with an initial time-step of 10 seconds that stops at 40 minutes, with adaptive time-stepping and progress printing.</p><pre><code class="language-julia hljs">simulation = Simulation(model, Ît=10.0, stop_time=40minutes)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Simulation of NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)
âââ Next time step: 10 seconds
âââ Elapsed wall time: 0 seconds
âââ Wall time per iteration: NaN years
âââ Stop time: 40 minutes
âââ Stop iteration : Inf
âââ Wall time limit: Inf
âââ Callbacks: OrderedDict with 4 entries:
â   âââ stop_time_exceeded =&gt; Callback of stop_time_exceeded on IterationInterval(1)
â   âââ stop_iteration_exceeded =&gt; Callback of stop_iteration_exceeded on IterationInterval(1)
â   âââ wall_time_limit_exceeded =&gt; Callback of wall_time_limit_exceeded on IterationInterval(1)
â   âââ nan_checker =&gt; Callback of NaNChecker for u on IterationInterval(100)
âââ Output writers: OrderedDict with no entries
âââ Diagnostics: OrderedDict with no entries</code></pre><p>The <code>TimeStepWizard</code> helps ensure stable time-stepping with a Courant-Freidrichs-Lewy (CFL) number of 1.0.</p><pre><code class="language-julia hljs">wizard = TimeStepWizard(cfl=1.0, max_change=1.1, max_Ît=1minute)
simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Callback of TimeStepWizard(cfl=1.0, max_Ît=60.0, min_Ît=0.0) on IterationInterval(10)</code></pre><p>Nice progress messaging is helpful:</p><pre><code class="language-julia hljs"># Print a progress message
progress_message(sim) = @printf(&quot;Iteration: %04d, time: %s, Ît: %s, max(|w|) = %.1e msâ»Â¹, wall time: %s\n&quot;,
                                iteration(sim), prettytime(sim), prettytime(sim.Ît),
                                maximum(abs, sim.model.velocities.w), prettytime(sim.run_wall_time))

simulation.callbacks[:progress] = Callback(progress_message, IterationInterval(20))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Callback of progress_message on IterationInterval(20)</code></pre><p>We then set up the simulation:</p><h2 id="Output"><a class="docs-heading-anchor" href="#Output">Output</a><a id="Output-1"></a><a class="docs-heading-anchor-permalink" href="#Output" title="Permalink"></a></h2><p>We use the <code>JLD2OutputWriter</code> to save <span>$x, z$</span> slices of the velocity fields, tracer fields, and eddy diffusivities. The <code>prefix</code> keyword argument to <code>JLD2OutputWriter</code> indicates that output will be saved in <code>ocean_wind_mixing_and_convection.jld2</code>.</p><pre><code class="language-julia hljs"># Create a NamedTuple with eddy viscosity
eddy_viscosity = (; Î½â = model.diffusivity_fields.Î½â)

filename = &quot;ocean_wind_mixing_and_convection&quot;

simulation.output_writers[:slices] =
    JLD2OutputWriter(model, merge(model.velocities, model.tracers, eddy_viscosity),
                     filename = filename * &quot;.jld2&quot;,
                     indices = (:, grid.Ny/2, :),
                     schedule = TimeInterval(1minute),
                     overwrite_existing = true)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">JLD2OutputWriter scheduled on TimeInterval(1 minute):
âââ filepath: ./ocean_wind_mixing_and_convection.jld2
âââ 6 outputs: (u, v, w, T, S, Î½â)
âââ array type: Array{Float32}
âââ including: [:grid, :coriolis, :buoyancy, :closure]
âââ max filesize: Inf YiB</code></pre><p>We&#39;re ready:</p><pre><code class="language-julia hljs">run!(simulation)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[ Info: Initializing simulation...
Iteration: 0000, time: 0 seconds, Ît: 11 seconds, max(|w|) = 1.2e-05 msâ»Â¹, wall time: 0 seconds
[ Info:     ... simulation initialization complete (6.184 seconds)
[ Info: Executing initial time step...
[ Info:     ... initial time step complete (1.790 minutes).
Iteration: 0020, time: 3.403 minutes, Ît: 13.310 seconds, max(|w|) = 9.4e-06 msâ»Â¹, wall time: 1.922 minutes
Iteration: 0040, time: 7.488 minutes, Ît: 16.105 seconds, max(|w|) = 6.4e-06 msâ»Â¹, wall time: 1.944 minutes
Iteration: 0060, time: 12 minutes, Ît: 10.350 seconds, max(|w|) = 1.1e-05 msâ»Â¹, wall time: 1.970 minutes
Iteration: 0080, time: 15 minutes, Ît: 8.282 seconds, max(|w|) = 3.7e-05 msâ»Â¹, wall time: 1.996 minutes
Iteration: 0100, time: 17.509 minutes, Ît: 7.084 seconds, max(|w|) = 2.6e-04 msâ»Â¹, wall time: 2.017 minutes
Iteration: 0120, time: 19.665 minutes, Ît: 6.246 seconds, max(|w|) = 1.8e-03 msâ»Â¹, wall time: 2.041 minutes
Iteration: 0140, time: 21.587 minutes, Ît: 5.422 seconds, max(|w|) = 1.1e-02 msâ»Â¹, wall time: 2.062 minutes
Iteration: 0160, time: 23.255 minutes, Ît: 4.811 seconds, max(|w|) = 4.1e-02 msâ»Â¹, wall time: 2.090 minutes
Iteration: 0180, time: 24.773 minutes, Ît: 4.927 seconds, max(|w|) = 6.8e-02 msâ»Â¹, wall time: 2.117 minutes
Iteration: 0200, time: 26.359 minutes, Ît: 5.638 seconds, max(|w|) = 8.1e-02 msâ»Â¹, wall time: 2.142 minutes
Iteration: 0220, time: 28.199 minutes, Ît: 6.563 seconds, max(|w|) = 7.2e-02 msâ»Â¹, wall time: 2.166 minutes
Iteration: 0240, time: 30.348 minutes, Ît: 7.325 seconds, max(|w|) = 8.9e-02 msâ»Â¹, wall time: 2.189 minutes
Iteration: 0260, time: 32.789 minutes, Ît: 7.870 seconds, max(|w|) = 6.9e-02 msâ»Â¹, wall time: 2.217 minutes
Iteration: 0280, time: 35.272 minutes, Ît: 7.530 seconds, max(|w|) = 6.8e-02 msâ»Â¹, wall time: 2.245 minutes
Iteration: 0300, time: 37.806 minutes, Ît: 7.213 seconds, max(|w|) = 6.1e-02 msâ»Â¹, wall time: 2.268 minutes
[ Info: Simulation is stopping. Model time 40.000 minutes has hit or exceeded simulation stop time 40 minutes.
Iteration: 0320, time: 40.000 minutes, Ît: 7.052 seconds, max(|w|) = 7.3e-02 msâ»Â¹, wall time: 2.293 minutes</code></pre><h2 id="Turbulence-visualization"><a class="docs-heading-anchor" href="#Turbulence-visualization">Turbulence visualization</a><a id="Turbulence-visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Turbulence-visualization" title="Permalink"></a></h2><p>We animate the data saved in <code>ocean_wind_mixing_and_convection.jld2</code>. We prepare for animating the flow by loading the data into FieldTimeSeries and defining functions for computing colorbar limits.</p><pre><code class="language-julia hljs">filepath = filename * &quot;.jld2&quot;

time_series = (w = FieldTimeSeries(filepath, &quot;w&quot;),
               T = FieldTimeSeries(filepath, &quot;T&quot;),
               S = FieldTimeSeries(filepath, &quot;S&quot;),
               Î½â = FieldTimeSeries(filepath, &quot;Î½â&quot;))

# Coordinate arrays
xw, yw, zw = nodes(time_series.w)
xT, yT, zT = nodes(time_series.T)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([1.0, 3.0, 5.0, 7.0, 9.0, 11.0, 13.0, 15.0, 17.0, 19.0  â¦  45.0, 47.0, 49.0, 51.0, 53.0, 55.0, 57.0, 59.0, 61.0, 63.0], [1.0, 3.0, 5.0, 7.0, 9.0, 11.0, 13.0, 15.0, 17.0, 19.0  â¦  45.0, 47.0, 49.0, 51.0, 53.0, 55.0, 57.0, 59.0, 61.0, 63.0], [-30.73214655800215, -28.344120885446316, -26.245517670529452, -24.406267643406927, -22.77515636448867, -21.301119444298777, -19.9410533865803, -18.66145654635607, -17.43754626408272, -16.251584220508228  â¦  -10.57103192002591, -9.45426630377412, -8.339528643431164, -7.226097424980429, -6.1135049573687645, -5.001449332843377, -3.889736372710594, -2.7782415919634484, -1.666885417004453, -0.5556171156552487])</code></pre><p>We start the animation at <span>$t = 10minutes$</span> since things are pretty boring till then:</p><pre><code class="language-julia hljs">times = time_series.w.times
intro = searchsortedfirst(times, 10minutes)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">11</code></pre><p>We are now ready to animate using Makie. We use Makie&#39;s <code>Observable</code> to animate the data. To dive into how <code>Observable</code>s work we refer to <a href="https://makie.juliaplots.org/stable/documentation/nodes/index.html">Makie.jl&#39;s Documentation</a>.</p><pre><code class="language-julia hljs">n = Observable(intro)

 wâ = @lift interior(time_series.w[$n],  :, 1, :)
 Tâ = @lift interior(time_series.T[$n],  :, 1, :)
 Sâ = @lift interior(time_series.S[$n],  :, 1, :)
Î½ââ = @lift interior(time_series.Î½â[$n], :, 1, :)

fig = Figure(resolution = (1000, 500))

axis_kwargs = (xlabel=&quot;x (m)&quot;,
               ylabel=&quot;z (m)&quot;,
               aspect = AxisAspect(grid.Lx/grid.Lz),
               limits = ((0, grid.Lx), (-grid.Lz, 0)))

ax_w  = Axis(fig[2, 1]; title = &quot;Vertical velocity&quot;, axis_kwargs...)
ax_T  = Axis(fig[2, 3]; title = &quot;Temperature&quot;, axis_kwargs...)
ax_S  = Axis(fig[3, 1]; title = &quot;Salinity&quot;, axis_kwargs...)
ax_Î½â = Axis(fig[3, 3]; title = &quot;Eddy viscocity&quot;, axis_kwargs...)

title = @lift @sprintf(&quot;t = %s&quot;, prettytime(times[$n]))

wlims = (-0.05, 0.05)
Tlims = (19.7, 19.99)
Slims = (35, 35.005)
Î½âlims = (1e-6, 5e-3)

hm_w = heatmap!(ax_w, xw, zw, wâ; colormap = :balance, colorrange = wlims)
Colorbar(fig[2, 2], hm_w; label = &quot;m sâ»Â¹&quot;)

hm_T = heatmap!(ax_T, xT, zT, Tâ; colormap = :thermal, colorrange = Tlims)
Colorbar(fig[2, 4], hm_T; label = &quot;áµC&quot;)

hm_S = heatmap!(ax_S, xT, zT, Sâ; colormap = :haline, colorrange = Slims)
Colorbar(fig[3, 2], hm_S; label = &quot;g / kg&quot;)

hm_Î½â = heatmap!(ax_Î½â, xT, zT, Î½ââ; colormap = :thermal, colorrange = Î½âlims)
Colorbar(fig[3, 4], hm_Î½â; label = &quot;m sâ»Â²&quot;)

fig[1, 1:4] = Label(fig, title, textsize=24, tellwidth=false)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Label()</code></pre><p>And now record a movie.</p><pre><code class="language-julia hljs">frames = intro:length(times)

@info &quot;Making a motion picture of ocean wind mixing and convection...&quot;

record(fig, filename * &quot;.mp4&quot;, frames, framerate=8) do i
    msg = string(&quot;Plotting frame &quot;, i, &quot; of &quot;, frames[end])
    print(msg * &quot; \r&quot;)
    n[] = i
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[ Info: Making a motion picture of ocean wind mixing and convection...
Plotting frame 11 of 41 Plotting frame 12 of 41 Plotting frame 13 of 41 Plotting frame 14 of 41 Plotting frame 15 of 41 Plotting frame 16 of 41 Plotting frame 17 of 41 Plotting frame 18 of 41 Plotting frame 19 of 41 Plotting frame 20 of 41 Plotting frame 21 of 41 Plotting frame 22 of 41 Plotting frame 23 of 41 Plotting frame 24 of 41 Plotting frame 25 of 41 Plotting frame 26 of 41 Plotting frame 27 of 41 Plotting frame 28 of 41 Plotting frame 29 of 41 Plotting frame 30 of 41 Plotting frame 31 of 41 Plotting frame 32 of 41 Plotting frame 33 of 41 Plotting frame 34 of 41 Plotting frame 35 of 41 Plotting frame 36 of 41 Plotting frame 37 of 41 Plotting frame 38 of 41 Plotting frame 39 of 41 Plotting frame 40 of 41 Plotting frame 41 of 41</code></pre><p><video src="../ocean_wind_mixing_and_convection.mp4" controls="true" title><a href="../ocean_wind_mixing_and_convection.mp4"></a></video></p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../convecting_plankton/">Â« Convecting plankton</a><a class="docs-footer-nextpage" href="../langmuir_turbulence/">Langmuir turbulence Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Thursday 21 July 2022 14:35">Thursday 21 July 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

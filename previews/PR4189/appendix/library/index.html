<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · Oceananigans.jl</title><meta name="title" content="Library · Oceananigans.jl"/><meta property="og:title" content="Library · Oceananigans.jl"/><meta property="twitter:title" content="Library · Oceananigans.jl"/><meta name="description" content="Documentation for Oceananigans.jl."/><meta property="og:description" content="Documentation for Oceananigans.jl."/><meta property="twitter:description" content="Documentation for Oceananigans.jl."/><meta property="og:url" content="https://clima.github.io/OceananigansDocumentation/stable/appendix/library/"/><meta property="twitter:url" content="https://clima.github.io/OceananigansDocumentation/stable/appendix/library/"/><link rel="canonical" href="https://clima.github.io/OceananigansDocumentation/stable/appendix/library/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Oceananigans.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../quick_start/">Quick start</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../literated/one_dimensional_diffusion/">One-dimensional diffusion</a></li><li><a class="tocitem" href="../../literated/two_dimensional_turbulence/">Two-dimensional turbulence</a></li><li><a class="tocitem" href="../../literated/internal_wave/">Internal wave</a></li><li><a class="tocitem" href="../../literated/internal_tide/">Internal tide by a seamount</a></li><li><a class="tocitem" href="../../literated/convecting_plankton/">Convecting plankton</a></li><li><a class="tocitem" href="../../literated/ocean_wind_mixing_and_convection/">Ocean wind mixing and convection</a></li><li><a class="tocitem" href="../../literated/langmuir_turbulence/">Langmuir turbulence</a></li><li><a class="tocitem" href="../../literated/baroclinic_adjustment/">Baroclinic adjustment</a></li><li><a class="tocitem" href="../../literated/kelvin_helmholtz_instability/">Kelvin-Helmholtz instability</a></li><li><a class="tocitem" href="../../literated/shallow_water_Bickley_jet/">Shallow water Bickley jet</a></li><li><a class="tocitem" href="../../literated/horizontal_convection/">Horizontal convection</a></li><li><a class="tocitem" href="../../literated/tilted_bottom_boundary_layer/">Tilted bottom boundary layer</a></li></ul></li><li><a class="tocitem" href="../../grids/">Grids</a></li><li><a class="tocitem" href="../../fields/">Fields</a></li><li><a class="tocitem" href="../../operations/">Operations</a></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Models</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../models/models_overview/">Overview</a></li><li><a class="tocitem" href="../../models/coriolis/">Coriolis forces</a></li><li><a class="tocitem" href="../../models/buoyancy_and_equation_of_state/">Buoyancy and equations of state</a></li><li><a class="tocitem" href="../../models/turbulence_closures/">Turbulence closures</a></li><li><a class="tocitem" href="../../models/boundary_conditions/">Boundary conditions</a></li><li><a class="tocitem" href="../../models/forcing_functions/">Forcings</a></li><li><a class="tocitem" href="../../models/lagrangian_particles/">Lagrangian particles</a></li><li><a class="tocitem" href="../../models/background_fields/">Background fields</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Simulations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../simulations/simulations_overview/">Overview</a></li><li><a class="tocitem" href="../../simulations/schedules/">Schedules</a></li><li><a class="tocitem" href="../../simulations/output_writers/">Output writers</a></li><li><a class="tocitem" href="../../simulations/checkpointing/">Checkpointing</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Physics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../physics/notation/">Coordinate system and notation</a></li><li><a class="tocitem" href="../../physics/boussinesq/">Boussinesq approximation</a></li><li><input class="collapse-toggle" id="menuitem-9-3" type="checkbox"/><label class="tocitem" for="menuitem-9-3"><span class="docs-label"><code>NonhydrostaticModel</code></span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../physics/nonhydrostatic_model/">Nonhydrostatic model</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-4" type="checkbox"/><label class="tocitem" for="menuitem-9-4"><span class="docs-label"><code>HydrostaticFreeSurfaceModel</code></span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../physics/hydrostatic_free_surface_model/">Hydrostatic model with a free surface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-5" type="checkbox"/><label class="tocitem" for="menuitem-9-5"><span class="docs-label"><code>ShallowWaterModel</code></span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../physics/shallow_water_model/">Shallow water model</a></li></ul></li><li><a class="tocitem" href="../../physics/boundary_conditions/">Boundary conditions</a></li><li><a class="tocitem" href="../../physics/buoyancy_and_equations_of_state/">Buoyancy models and equations of state</a></li><li><a class="tocitem" href="../../physics/coriolis_forces/">Coriolis forces</a></li><li><a class="tocitem" href="../../physics/turbulence_closures/">Turbulence closures</a></li><li><a class="tocitem" href="../../physics/surface_gravity_waves/">Surface gravity waves and the Craik-Leibovich approximation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Numerical implementation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../numerical_implementation/finite_volume/">Finite volume method</a></li><li><a class="tocitem" href="../../numerical_implementation/spatial_operators/">Spatial operators</a></li><li><a class="tocitem" href="../../numerical_implementation/generalized_vertical_coordinates/">Generalized vertical coordinates</a></li><li><a class="tocitem" href="../../numerical_implementation/pressure_decomposition/">Pressure decomposition</a></li><li><a class="tocitem" href="../../numerical_implementation/time_stepping/">Time stepping</a></li><li><a class="tocitem" href="../../numerical_implementation/boundary_conditions/">Boundary conditions</a></li><li><a class="tocitem" href="../../numerical_implementation/elliptic_solvers/">Elliptic solvers</a></li><li><a class="tocitem" href="../../numerical_implementation/large_eddy_simulation/">Large eddy simulation</a></li></ul></li><li><a class="tocitem" href="../../simulation_tips/">Simulation tips</a></li><li><a class="tocitem" href="../../contributing/">Contributor&#39;s guide</a></li><li><a class="tocitem" href="../../gallery/">Gallery</a></li><li><a class="tocitem" href="../../references/">References</a></li><li><input class="collapse-toggle" id="menuitem-15" type="checkbox" checked/><label class="tocitem" for="menuitem-15"><span class="docs-label">Appendix</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../staggered_grid/">Staggered grid</a></li><li><a class="tocitem" href="../fractional_step/">Fractional step method</a></li><li><a class="tocitem" href="../convergence_tests/">Convergence tests</a></li><li><a class="tocitem" href="../benchmarks/">Performance benchmarks</a></li><li class="is-active"><a class="tocitem" href>Library</a><ul class="internal"><li><a class="tocitem" href="#Oceananigans.jl"><span>Oceananigans.jl</span></a></li><li><a class="tocitem" href="#Abstract-operations"><span>Abstract operations</span></a></li><li><a class="tocitem" href="#Advection"><span>Advection</span></a></li><li><a class="tocitem" href="#Architectures"><span>Architectures</span></a></li><li><a class="tocitem" href="#Boundary-conditions"><span>Boundary conditions</span></a></li><li><a class="tocitem" href="#Buoyancy-models"><span>Buoyancy models</span></a></li><li><a class="tocitem" href="#Coriolis"><span>Coriolis</span></a></li><li><a class="tocitem" href="#Diagnostics"><span>Diagnostics</span></a></li><li><a class="tocitem" href="#Distributed"><span>Distributed</span></a></li><li><a class="tocitem" href="#Fields"><span>Fields</span></a></li><li><a class="tocitem" href="#Forcings"><span>Forcings</span></a></li><li><a class="tocitem" href="#Grids"><span>Grids</span></a></li><li><a class="tocitem" href="#OrthogonalSphericalShellGrids"><span>OrthogonalSphericalShellGrids</span></a></li><li><a class="tocitem" href="#Immersed-boundaries"><span>Immersed boundaries</span></a></li><li><a class="tocitem" href="#Logger"><span>Logger</span></a></li><li><a class="tocitem" href="#Models"><span>Models</span></a></li><li><a class="tocitem" href="#MultiRegion"><span>MultiRegion</span></a></li><li><a class="tocitem" href="#Operators"><span>Operators</span></a></li><li><a class="tocitem" href="#Output-readers"><span>Output readers</span></a></li><li><a class="tocitem" href="#Output-writers"><span>Output writers</span></a></li><li><a class="tocitem" href="#Simulations"><span>Simulations</span></a></li><li><a class="tocitem" href="#Solvers"><span>Solvers</span></a></li><li><a class="tocitem" href="#Stokes-drift"><span>Stokes drift</span></a></li><li><a class="tocitem" href="#Time-steppers"><span>Time steppers</span></a></li><li><a class="tocitem" href="#Turbulence-closures"><span>Turbulence closures</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li><li><a class="tocitem" href="#Units"><span>Units</span></a></li></ul></li><li><a class="tocitem" href="../function_index/">Function index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Appendix</a></li><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/CliMA/Oceananigans.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/CliMA/Oceananigans.jl/blob/main/docs/src/appendix/library.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><p>Documenting the public user interface.</p><h2 id="Oceananigans.jl"><a class="docs-heading-anchor" href="#Oceananigans.jl">Oceananigans.jl</a><a id="Oceananigans.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Oceananigans.jl" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Oceananigans.Oceananigans"><a class="docstring-binding" href="#Oceananigans.Oceananigans"><code>Oceananigans.Oceananigans</code></a> — <span class="docstring-category">Module</span></summary><section><div><p>Main module for <code>Oceananigans.jl</code> – a Julia software for fast, friendly, flexible, data-driven, ocean-flavored fluid dynamics on CPUs and GPUs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Oceananigans.jl#L1-L4">source</a></section></details></article><h2 id="Abstract-operations"><a class="docs-heading-anchor" href="#Abstract-operations">Abstract operations</a><a id="Abstract-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-operations" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Oceananigans.AbstractOperations.Average-Tuple{Oceananigans.Fields.AbstractField}"><a class="docstring-binding" href="#Oceananigans.AbstractOperations.Average-Tuple{Oceananigans.Fields.AbstractField}"><code>Oceananigans.AbstractOperations.Average</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Average(field::AbstractField; dims=:, condition=nothing, mask=0)</code></pre><p>Return <code>Reduction</code> representing a spatial average of <code>field</code> over <code>dims</code>.</p><p>Over regularly-spaced dimensions this is equivalent to a numerical <code>mean!</code>.</p><p>Over dimensions of variable spacing, <code>field</code> is multiplied by the appropriate &quot;averaging metric&quot; (length, area or volume for 1D, 2D, or 3D averages), and divided by the sum of the metric over the averaging region.</p><p>See <a href="#Oceananigans.AbstractOperations.ConditionalOperation-Tuple{Oceananigans.Fields.AbstractField}"><code>ConditionalOperation</code></a> for information and examples using <code>condition</code> and <code>mask</code> kwargs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/AbstractOperations/metric_field_reductions.jl#L49-L62">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.AbstractOperations.BinaryOperation-Union{Tuple{G}, Tuple{IB}, Tuple{IA}, Tuple{B}, Tuple{A}, Tuple{O}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{O, A, B, IA, IB, G}} where {LX, LY, LZ, O, A, B, IA, IB, G}"><a class="docstring-binding" href="#Oceananigans.AbstractOperations.BinaryOperation-Union{Tuple{G}, Tuple{IB}, Tuple{IA}, Tuple{B}, Tuple{A}, Tuple{O}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{O, A, B, IA, IB, G}} where {LX, LY, LZ, O, A, B, IA, IB, G}"><code>Oceananigans.AbstractOperations.BinaryOperation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">BinaryOperation{LX, LY, LZ}(op, a, b, ▶a, ▶b, grid)</code></pre><p>Return an abstract representation of the binary operation <code>op(▶a(a), ▶b(b))</code> on <code>grid</code>, where <code>▶a</code> and <code>▶b</code> interpolate <code>a</code> and <code>b</code> to locations <code>(LX, LY, LZ)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/AbstractOperations/binary_operations.jl#L11-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.AbstractOperations.ConditionalOperation-Tuple{Oceananigans.Fields.AbstractField}"><a class="docstring-binding" href="#Oceananigans.AbstractOperations.ConditionalOperation-Tuple{Oceananigans.Fields.AbstractField}"><code>Oceananigans.AbstractOperations.ConditionalOperation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ConditionalOperation(operand::AbstractField;
                     func = nothing,
                     condition = nothing,
                     mask = 0)</code></pre><p>Return an abstract representation of a masking procedure applied when <code>condition</code> is satisfied on a field described by <code>func(operand)</code>.</p><p><strong>Positional arguments</strong></p><ul><li><code>operand</code>: The <code>AbstractField</code> to be masked.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>func</code>: A unary transformation applied element-wise to the field <code>operand</code> at locations where         <code>condition == true</code>. Default is <code>nothing</code> which applies no transformation.</p></li><li><p><code>condition</code>: either a function of <code>(i, j, k, grid, operand)</code> returning a Boolean,              or a 3-dimensional Boolean <code>AbstractArray</code>. At locations where <code>condition == false</code>,              operand will be masked by <code>mask</code>.</p></li><li><p><code>mask</code>: the scalar mask. Default: 0.</p></li></ul><p><code>condition_operand</code> is a convenience function used to construct a <code>ConditionalOperation</code>, e.g.,</p><pre><code class="language-julia hljs">condition_operand(func::Function, operand::AbstractField, condition, mask) =
    ConditionalOperation(operand; func, condition, mask)</code></pre><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; using Oceananigans.Fields: condition_operand

julia&gt; c = CenterField(RectilinearGrid(size=(2, 1, 1), extent=(1, 1, 1)));

julia&gt; add_2(c) = c + 2
add_2 (generic function with 1 method)

julia&gt; f(i, j, k, grid, c) = i &lt; 2; d = condition_operand(add_2, c, f, 10.0)
ConditionalOperation at (Center, Center, Center)
├── operand: 2×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU
├── grid: 2×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 2×1×1 halo
├── func: add_2 (generic function with 1 method)
├── condition: f (generic function with 1 method)
└── mask: 10.0

julia&gt; d[1, 1, 1]
2.0

julia&gt; d[2, 1, 1]
10.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/AbstractOperations/conditional_operations.jl#L31-L91">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.AbstractOperations.CumulativeIntegral-Tuple{Oceananigans.Fields.AbstractField}"><a class="docstring-binding" href="#Oceananigans.AbstractOperations.CumulativeIntegral-Tuple{Oceananigans.Fields.AbstractField}"><code>Oceananigans.AbstractOperations.CumulativeIntegral</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">CumulativeIntegral(field::AbstractField; dims, reverse=false, condition=nothing, mask=0)</code></pre><p>Return an <code>Accumulation</code> representing the cumulative spatial integral of <code>field</code> over <code>dims</code>.</p><p>See <a href="#Oceananigans.AbstractOperations.ConditionalOperation-Tuple{Oceananigans.Fields.AbstractField}"><code>ConditionalOperation</code></a> for information and examples using <code>condition</code> and <code>mask</code> kwargs.</p><p><strong>Example</strong></p><p>Compute the cumulative integral of <span>$f(z) = z$</span> over z ∈ [0, 1].</p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = RectilinearGrid(size=8, z=(0, 1), topology=(Flat, Flat, Bounded));

julia&gt; c = CenterField(grid);

julia&gt; set!(c, z -&gt; z)
1×1×8 Field{Center, Center, Center} on RectilinearGrid on CPU
├── grid: 1×1×8 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo
├── boundary conditions: FieldBoundaryConditions
│   └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: ZeroFlux, top: ZeroFlux, immersed: Nothing
└── data: 1×1×14 OffsetArray(::Array{Float64, 3}, 1:1, 1:1, -2:11) with eltype Float64 with indices 1:1×1:1×-2:11
    └── max=0.9375, min=0.0625, mean=0.5

julia&gt; C_op = CumulativeIntegral(c, dims=3)
CumulativeIntegral of BinaryOperation at (Center, Center, Center) over dims 3
└── operand: BinaryOperation at (Center, Center, Center)
    └── grid: 1×1×8 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo

julia&gt; C = compute!(Field(C_op))
1×1×8 Field{Center, Center, Center} on RectilinearGrid on CPU
├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 1, 8)
├── grid: 1×1×8 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo
├── operand: CumulativeIntegral of BinaryOperation at (Center, Center, Center) over dims 3
├── status: time=0.0
└── data: 1×1×14 OffsetArray(::Array{Float64, 3}, 1:1, 1:1, -2:11) with eltype Float64 with indices 1:1×1:1×-2:11
    └── max=0.5, min=0.0078125, mean=0.199219

julia&gt; C[1, 1, 8]
0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/AbstractOperations/metric_field_reductions.jl#L158-L203">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.AbstractOperations.Derivative-Union{Tuple{G}, Tuple{AD}, Tuple{IN}, Tuple{A}, Tuple{D}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{D, A, IN, AD, G}} where {LX, LY, LZ, D, A, IN, AD, G}"><a class="docstring-binding" href="#Oceananigans.AbstractOperations.Derivative-Union{Tuple{G}, Tuple{AD}, Tuple{IN}, Tuple{A}, Tuple{D}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{D, A, IN, AD, G}} where {LX, LY, LZ, D, A, IN, AD, G}"><code>Oceananigans.AbstractOperations.Derivative</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Derivative{LX, LY, LZ}(∂, arg, ▶, grid)</code></pre><p>Return an abstract representation of the derivative <code>∂</code> on <code>arg</code>, and subsequent interpolation by <code>▶</code> on <code>grid</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/AbstractOperations/derivatives.jl#L10-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.AbstractOperations.Integral-Tuple{Oceananigans.Fields.AbstractField}"><a class="docstring-binding" href="#Oceananigans.AbstractOperations.Integral-Tuple{Oceananigans.Fields.AbstractField}"><code>Oceananigans.AbstractOperations.Integral</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Integral(field::AbstractField; dims=:, condition=nothing, mask=0)</code></pre><p>Return a <code>Reduction</code> representing a spatial integral of <code>field</code> over <code>dims</code>.</p><p>See <a href="#Oceananigans.AbstractOperations.ConditionalOperation-Tuple{Oceananigans.Fields.AbstractField}"><code>ConditionalOperation</code></a> for information and examples using <code>condition</code> and <code>mask</code> kwargs.</p><p><strong>Example</strong></p><p>Compute the integral of <span>$f(x, y, z) = x y z$</span> over the domain <span>$(x, y, z) ∈ [0, 1] × [0, 1] × [0, 1]$</span>. The analytical answer is <span>$∭ x y z \, dx \, dy \, dz = 1/8$</span>.</p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = RectilinearGrid(size=(8, 8, 8), x=(0, 1), y=(0, 1), z=(0, 1));

julia&gt; f = CenterField(grid);

julia&gt; set!(f, (x, y, z) -&gt; x * y * z)
8×8×8 Field{Center, Center, Center} on RectilinearGrid on CPU
├── grid: 8×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo
├── boundary conditions: FieldBoundaryConditions
│   └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: Nothing
└── data: 14×14×14 OffsetArray(::Array{Float64, 3}, -2:11, -2:11, -2:11) with eltype Float64 with indices -2:11×-2:11×-2:11
    └── max=0.823975, min=0.000244141, mean=0.125

julia&gt; ∫f = Integral(f)
Integral of BinaryOperation at (Center, Center, Center) over dims (1, 2, 3)
└── operand: BinaryOperation at (Center, Center, Center)
    └── grid: 8×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo

julia&gt; ∫f = Field(Integral(f));

julia&gt; compute!(∫f);

julia&gt; ∫f[1, 1, 1]
0.125</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/AbstractOperations/metric_field_reductions.jl#L98-L141">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.AbstractOperations.KernelFunctionOperation-Union{Tuple{G}, Tuple{K}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{K, G, Vararg{Any}}} where {LX, LY, LZ, K, G}"><a class="docstring-binding" href="#Oceananigans.AbstractOperations.KernelFunctionOperation-Union{Tuple{G}, Tuple{K}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{K, G, Vararg{Any}}} where {LX, LY, LZ, K, G}"><code>Oceananigans.AbstractOperations.KernelFunctionOperation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">KernelFunctionOperation{LX, LY, LZ}(kernel_function, grid, arguments...)</code></pre><p>Construct a <code>KernelFunctionOperation</code> at location <code>(LX, LY, LZ)</code> on <code>grid</code> with <code>arguments</code>.</p><p><code>kernel_function</code> is called with</p><pre><code class="language-julia hljs">kernel_function(i, j, k, grid, arguments...)</code></pre><p>Note that <code>compute!(kfo::KernelFunctionOperation)</code> calls <code>compute!</code> on all <code>kfo.arguments</code>.</p><p><strong>Examples</strong></p><p>Construct a <code>KernelFunctionOperation</code> that returns random numbers:</p><pre><code class="language-julia hljs">using Oceananigans

grid = RectilinearGrid(size=(1, 8, 8), extent=(1, 1, 1));

random_kernel_function(i, j, k, grid) = rand();
kernel_op = KernelFunctionOperation{Center, Center, Center}(random_kernel_function, grid)

# output
KernelFunctionOperation at (Center, Center, Center)
├── grid: 1×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×3×3 halo
├── kernel_function: random_kernel_function (generic function with 1 method)
└── arguments: ()</code></pre><p>Construct a <code>KernelFunctionOperation</code> using the vertical vorticity operator used internally to compute vertical vorticity on all grids:</p><pre><code class="language-julia hljs">using Oceananigans.Operators: ζ₃ᶠᶠᶜ # called with signature ζ₃ᶠᶠᶜ(i, j, k, grid, u, v)

model = HydrostaticFreeSurfaceModel(; grid);
u, v, w = model.velocities;
ζ_op = KernelFunctionOperation{Face, Face, Center}(ζ₃ᶠᶠᶜ, grid, u, v)

# output
KernelFunctionOperation at (Face, Face, Center)
├── grid: 1×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×3×3 halo
├── kernel_function: ζ₃ᶠᶠᶜ (generic function with 1 method)
└── arguments: (&quot;Field&quot;, &quot;Field&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/AbstractOperations/kernel_function_operation.jl#L8-L57">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.AbstractOperations.UnaryOperation-Union{Tuple{G}, Tuple{IN}, Tuple{A}, Tuple{O}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{O, A, IN, G}} where {LX, LY, LZ, O, A, IN, G}"><a class="docstring-binding" href="#Oceananigans.AbstractOperations.UnaryOperation-Union{Tuple{G}, Tuple{IN}, Tuple{A}, Tuple{O}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{O, A, IN, G}} where {LX, LY, LZ, O, A, IN, G}"><code>Oceananigans.AbstractOperations.UnaryOperation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">UnaryOperation{LX, LY, LZ}(op, arg, ▶, grid)</code></pre><p>Returns an abstract <code>UnaryOperation</code> representing the action of <code>op</code> on <code>arg</code>, and subsequent interpolation by <code>▶</code> on <code>grid</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/AbstractOperations/unary_operations.jl#L12-L17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.AbstractOperations.∂x-Tuple{Union{Nothing, Center, Face}, Union{Nothing, Center, Face}, Union{Nothing, Center, Face}}"><a class="docstring-binding" href="#Oceananigans.AbstractOperations.∂x-Tuple{Union{Nothing, Center, Face}, Union{Nothing, Center, Face}, Union{Nothing, Center, Face}}"><code>Oceananigans.AbstractOperations.∂x</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Return the <span>$x$</span>-derivative function acting at (<code>X</code>, <code>Y</code>, <code>Any</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/AbstractOperations/derivatives.jl#L47">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.AbstractOperations.∂x-Union{Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Tuple{Union{Nothing, Center, Face}, Union{Nothing, Center, Face}, Union{Nothing, Center, Face}}, Oceananigans.Fields.AbstractField{LX, LY, LZ}}} where {LX, LY, LZ}"><a class="docstring-binding" href="#Oceananigans.AbstractOperations.∂x-Union{Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Tuple{Union{Nothing, Center, Face}, Union{Nothing, Center, Face}, Union{Nothing, Center, Face}}, Oceananigans.Fields.AbstractField{LX, LY, LZ}}} where {LX, LY, LZ}"><code>Oceananigans.AbstractOperations.∂x</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">∂x(L::Tuple, arg::AbstractField)</code></pre><p>Return an abstract representation of an <span>$x$</span>-derivative acting on field <code>arg</code> followed by interpolation to <code>L</code>, where <code>L</code> is a 3-tuple of instantiated <code>Face</code>s and <code>Center</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/AbstractOperations/derivatives.jl#L59-L64">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.AbstractOperations.∂x-Union{Tuple{Oceananigans.Fields.AbstractField{LX, LY, LZ}}, Tuple{LZ}, Tuple{LY}, Tuple{LX}} where {LX, LY, LZ}"><a class="docstring-binding" href="#Oceananigans.AbstractOperations.∂x-Union{Tuple{Oceananigans.Fields.AbstractField{LX, LY, LZ}}, Tuple{LZ}, Tuple{LY}, Tuple{LX}} where {LX, LY, LZ}"><code>Oceananigans.AbstractOperations.∂x</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">∂x(arg::AbstractField)</code></pre><p>Return an abstract representation of a <span>$x$</span>-derivative acting on field <code>arg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/AbstractOperations/derivatives.jl#L93-L97">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.AbstractOperations.∂y-Tuple{Union{Nothing, Center, Face}, Union{Nothing, Center, Face}, Union{Nothing, Center, Face}}"><a class="docstring-binding" href="#Oceananigans.AbstractOperations.∂y-Tuple{Union{Nothing, Center, Face}, Union{Nothing, Center, Face}, Union{Nothing, Center, Face}}"><code>Oceananigans.AbstractOperations.∂y</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Return the <span>$y$</span>-derivative function acting at (<code>X</code>, <code>Y</code>, <code>Any</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/AbstractOperations/derivatives.jl#L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.AbstractOperations.∂y-Union{Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Tuple{Union{Nothing, Center, Face}, Union{Nothing, Center, Face}, Union{Nothing, Center, Face}}, Oceananigans.Fields.AbstractField{LX, LY, LZ}}} where {LX, LY, LZ}"><a class="docstring-binding" href="#Oceananigans.AbstractOperations.∂y-Union{Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Tuple{Union{Nothing, Center, Face}, Union{Nothing, Center, Face}, Union{Nothing, Center, Face}}, Oceananigans.Fields.AbstractField{LX, LY, LZ}}} where {LX, LY, LZ}"><code>Oceananigans.AbstractOperations.∂y</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">∂y(L::Tuple, arg::AbstractField)</code></pre><p>Return an abstract representation of a <span>$y$</span>-derivative acting on field <code>arg</code> followed by interpolation to <code>L</code>, where <code>L</code> is a 3-tuple of instantiated <code>Face</code>s and <code>Center</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/AbstractOperations/derivatives.jl#L68-L73">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.AbstractOperations.∂y-Union{Tuple{Oceananigans.Fields.AbstractField{LX, LY, LZ}}, Tuple{LZ}, Tuple{LY}, Tuple{LX}} where {LX, LY, LZ}"><a class="docstring-binding" href="#Oceananigans.AbstractOperations.∂y-Union{Tuple{Oceananigans.Fields.AbstractField{LX, LY, LZ}}, Tuple{LZ}, Tuple{LY}, Tuple{LX}} where {LX, LY, LZ}"><code>Oceananigans.AbstractOperations.∂y</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">∂y(arg::AbstractField)</code></pre><p>Return an abstract representation of a <span>$y$</span>-derivative acting on field <code>arg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/AbstractOperations/derivatives.jl#L100-L104">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.AbstractOperations.∂z-Tuple{Union{Nothing, Center, Face}, Union{Nothing, Center, Face}, Union{Nothing, Center, Face}}"><a class="docstring-binding" href="#Oceananigans.AbstractOperations.∂z-Tuple{Union{Nothing, Center, Face}, Union{Nothing, Center, Face}, Union{Nothing, Center, Face}}"><code>Oceananigans.AbstractOperations.∂z</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Return the <span>$z$</span>-derivative function acting at (<code>Any</code>, <code>Any</code>, <code>Z</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/AbstractOperations/derivatives.jl#L53">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.AbstractOperations.∂z-Union{Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Tuple{Union{Nothing, Center, Face}, Union{Nothing, Center, Face}, Union{Nothing, Center, Face}}, Oceananigans.Fields.AbstractField{LX, LY, LZ}}} where {LX, LY, LZ}"><a class="docstring-binding" href="#Oceananigans.AbstractOperations.∂z-Union{Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Tuple{Union{Nothing, Center, Face}, Union{Nothing, Center, Face}, Union{Nothing, Center, Face}}, Oceananigans.Fields.AbstractField{LX, LY, LZ}}} where {LX, LY, LZ}"><code>Oceananigans.AbstractOperations.∂z</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">∂z(L::Tuple, arg::AbstractField)</code></pre><p>Return an abstract representation of a <span>$z$</span>-derivative acting on field <code>arg</code> followed by  interpolation to <code>L</code>, where <code>L</code> is a 3-tuple of instantiated <code>Face</code>s and <code>Center</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/AbstractOperations/derivatives.jl#L77-L82">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.AbstractOperations.∂z-Union{Tuple{Oceananigans.Fields.AbstractField{LX, LY, LZ}}, Tuple{LZ}, Tuple{LY}, Tuple{LX}} where {LX, LY, LZ}"><a class="docstring-binding" href="#Oceananigans.AbstractOperations.∂z-Union{Tuple{Oceananigans.Fields.AbstractField{LX, LY, LZ}}, Tuple{LZ}, Tuple{LY}, Tuple{LX}} where {LX, LY, LZ}"><code>Oceananigans.AbstractOperations.∂z</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">∂z(arg::AbstractField)</code></pre><p>Return an abstract representation of a <span>$z$</span>-derivative acting on field <code>arg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/AbstractOperations/derivatives.jl#L107-L111">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.AbstractOperations.@at-Tuple{Any, Any}"><a class="docstring-binding" href="#Oceananigans.AbstractOperations.@at-Tuple{Any, Any}"><code>Oceananigans.AbstractOperations.@at</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@at location abstract_operation</code></pre><p>Modify the <code>abstract_operation</code> so that it returns values at <code>location</code>, where <code>location</code> is a 3-tuple of <code>Face</code>s and <code>Center</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/AbstractOperations/at.jl#L55-L60">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.AbstractOperations.@binary-Tuple"><a class="docstring-binding" href="#Oceananigans.AbstractOperations.@binary-Tuple"><code>Oceananigans.AbstractOperations.@binary</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@binary op1 op2 op3...</code></pre><p>Turn each binary function in the list <code>(op1, op2, op3...)</code> into a binary operator on <code>Oceananigans.Fields</code> for use in <code>AbstractOperations</code>.</p><p>Note: a binary function is a function with two arguments: for example, <code>+(x, y)</code> is a binary function.</p><p>Also note: a binary function in <code>Base</code> must be imported to be extended: use <code>import Base: op; @binary op</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans, Oceananigans.AbstractOperations

julia&gt; using Oceananigans.AbstractOperations: BinaryOperation, GridMetric, choose_location

julia&gt; plus_or_times(x, y) = x &lt; 0 ? x + y : x * y
plus_or_times (generic function with 1 method)

julia&gt; @binary plus_or_times
Set{Any} with 6 elements:
  :+
  :/
  :^
  :-
  :*
  :plus_or_times

julia&gt; c, d = (CenterField(RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))) for i = 1:2);

julia&gt; plus_or_times(c, d)
BinaryOperation at (Center, Center, Center)
├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo
└── tree:
    plus_or_times at (Center, Center, Center)
    ├── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU
    └── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/AbstractOperations/binary_operations.jl#L152-L192">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.AbstractOperations.@multiary-Tuple"><a class="docstring-binding" href="#Oceananigans.AbstractOperations.@multiary-Tuple"><code>Oceananigans.AbstractOperations.@multiary</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@multiary op1 op2 op3...</code></pre><p>Turn each multiary operator in the list <code>(op1, op2, op3...)</code> into a multiary operator on <code>Oceananigans.Fields</code> for use in <code>AbstractOperations</code>.</p><p>Note that a multiary operator:</p><ul><li>is a function with two or more arguments: for example, <code>+(x, y, z)</code> is a multiary function;</li><li>must be imported to be extended if part of <code>Base</code>: use <code>import Base: op; @multiary op</code>;</li><li>can only be called on <code>Oceananigans.Field</code>s if the &quot;location&quot; is noted explicitly; see example.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans, Oceananigans.AbstractOperations

julia&gt; harmonic_plus(a, b, c) = 1/3 * (1/a + 1/b + 1/c)
harmonic_plus (generic function with 1 method)

julia&gt; c, d, e = Tuple(CenterField(RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))) for i = 1:3);

julia&gt; harmonic_plus(c, d, e) # before magic @multiary transformation
BinaryOperation at (Center, Center, Center)
├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo
└── tree:
    * at (Center, Center, Center)
    ├── 0.3333333333333333
    └── + at (Center, Center, Center)
        ├── / at (Center, Center, Center)
        │   ├── 1
        │   └── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU
        ├── / at (Center, Center, Center)
        │   ├── 1
        │   └── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU
        └── / at (Center, Center, Center)
            ├── 1
            └── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU

julia&gt; @multiary harmonic_plus
Set{Any} with 3 elements:
  :+
  :harmonic_plus
  :*

julia&gt; harmonic_plus(c, d, e)
MultiaryOperation at (Center, Center, Center)
├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo
└── tree:
    harmonic_plus at (Center, Center, Center)
    ├── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU
    ├── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU
    └── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/AbstractOperations/multiary_operations.jl#L101-L155">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.AbstractOperations.@unary-Tuple"><a class="docstring-binding" href="#Oceananigans.AbstractOperations.@unary-Tuple"><code>Oceananigans.AbstractOperations.@unary</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@unary op1 op2 op3...</code></pre><p>Turn each unary function in the list <code>(op1, op2, op3...)</code> into a unary operator on <code>Oceananigans.Fields</code> for use in <code>AbstractOperations</code>.</p><p>Note: a unary function is a function with one argument: for example, <code>sin(x)</code> is a unary function.</p><p>Also note: a unary function in <code>Base</code> must be imported to be extended: use <code>import Base: op; @unary op</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans, Oceananigans.Grids, Oceananigans.AbstractOperations

julia&gt; square_it(x) = x^2
square_it (generic function with 1 method)

julia&gt; @unary square_it
Set{Any} with 15 elements:
  :+
  :log10
  :interpolate_identity
  :cos
  :exp
  :tanh
  :abs
  :log
  :cosh
  :square_it
  :-
  :sqrt
  :tan
  :sinh
  :sin

julia&gt; c = CenterField(RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)));

julia&gt; square_it(c)
UnaryOperation at (Center, Center, Center)
├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo
└── tree:
    square_it at (Center, Center, Center) via identity
    └── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/AbstractOperations/unary_operations.jl#L42-L88">source</a></section></details></article><h2 id="Advection"><a class="docs-heading-anchor" href="#Advection">Advection</a><a id="Advection-1"></a><a class="docs-heading-anchor-permalink" href="#Advection" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Oceananigans.Advection.FluxFormAdvection-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#Oceananigans.Advection.FluxFormAdvection-Tuple{Any, Any, Any}"><code>Oceananigans.Advection.FluxFormAdvection</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">FluxFormAdvection(x_advection, y_advection, z_advection)</code></pre><p>Return a <code>FluxFormAdvection</code> type with reconstructions schemes <code>x_advection</code>, <code>y_advection</code>, and <code>z_advection</code> to be applied in the <span>$x$</span>, <span>$y$</span>, and <span>$z$</span> directions, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Advection/flux_form_advection.jl#L12-L17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Advection.VectorInvariant"><a class="docstring-binding" href="#Oceananigans.Advection.VectorInvariant"><code>Oceananigans.Advection.VectorInvariant</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">VectorInvariant(; vorticity_scheme = EnstrophyConserving(),
                  vorticity_stencil = VelocityStencil(),
                  vertical_advection_scheme = EnergyConserving(),
                  divergence_scheme = vertical_advection_scheme,
                  kinetic_energy_gradient_scheme = divergence_scheme,
                  upwinding  = OnlySelfUpwinding(; cross_scheme = divergence_scheme),
                  multi_dimensional_stencil = false)</code></pre><p>Return a vector-invariant momentum advection scheme.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>vorticity_scheme</code>: Scheme used for <code>Center</code> reconstruction of vorticity. Default: <code>EnstrophyConserving()</code>. Options:</p><ul><li><code>UpwindBiased()</code></li><li><code>WENO()</code></li><li><code>EnergyConserving()</code></li><li><code>EnstrophyConserving()</code></li></ul></li><li><p><code>vorticity_stencil</code>: Stencil used for smoothness indicators for <code>WENO</code> schemes. Default: <code>VelocityStencil()</code>. Options:</p><ul><li><code>VelocityStencil()</code> (smoothness based on horizontal velocities)</li><li><code>DefaultStencil()</code> (smoothness based on variable being reconstructed)</li></ul></li><li><p><code>vertical_advection_scheme</code>: Scheme used for vertical advection of horizontal momentum. Default: <code>EnergyConserving()</code>.</p></li><li><p><code>kinetic_energy_gradient_scheme</code>: Scheme used for kinetic energy gradient reconstruction. Default: <code>vertical_advection_scheme</code>.</p></li><li><p><code>divergence_scheme</code>: Scheme used for divergence flux. Only upwinding schemes are supported. Default: <code>vorticity_scheme</code>.</p></li><li><p><code>upwinding</code>: Treatment of upwinded reconstruction of divergence and kinetic energy gradient. Default: <code>OnlySelfUpwinding()</code>. Options:</p><ul><li><code>CrossAndSelfUpwinding()</code></li><li><code>OnlySelfUpwinding()</code></li></ul></li><li><p><code>multi_dimensional_stencil</code>: whether or not to use a horizontal two-dimensional stencil for the reconstruction                              of vorticity, divergence and kinetic energy gradient. Currently the &quot;tangential&quot;                              direction uses 5th-order centered WENO reconstruction. Default: false</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; VectorInvariant()
VectorInvariant
├── vorticity_scheme: Oceananigans.Advection.EnstrophyConserving{Float64}
└── vertical_advection_scheme: Oceananigans.Advection.EnergyConserving{Float64}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Advection/vector_invariant_advection.jl#L32-L81">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Advection.WENO"><a class="docstring-binding" href="#Oceananigans.Advection.WENO"><code>Oceananigans.Advection.WENO</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">WENO([FT=Float64, FT2=Float32;]
     order = 5,
     bounds = nothing,
     minimum_buffer_upwind_order = 3)</code></pre><p>Construct a weighted essentially non-oscillatory advection scheme of order <code>order</code> with precision <code>FT</code>.</p><p><strong>Arguments</strong></p><ul><li><code>FT</code>: The floating point type used in the scheme. Default: <code>Oceananigans.defaults.FloatType</code></li><li><code>FT2</code>: The floating point type used in some performance-critical parts of the scheme. Default: <code>Float32</code></li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>order</code>: The order of the WENO advection scheme. Default: 5</li><li><code>bounds</code> (experimental): Whether to use bounds-preserving WENO, which produces a reconstruction                          that attempts to restrict a quantity to lie between a <code>bounds</code> tuple.                          Default: <code>nothing</code>, which does not use a boundary-preserving scheme.</li><li><code>minimum_buffer_upwind_order</code>: The minimum upwind order for buffer schemes. When the buffer                                scheme order reaches this value, subsequent buffers use                                <code>Centered(order=2)</code> instead of continuing to decrease the                                upwind order. Default: 1 (preserves existing behavior).</li></ul><p><strong>Examples</strong></p><p>To build the default 5th-order scheme:</p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; WENO()
WENO{3, Float64, Float32}(order=5)
├── buffer_scheme: WENO{2, Float64, Float32}(order=3)
│   └── buffer_scheme: Centered(order=2)
└── advecting_velocity_scheme: Centered(order=4)</code></pre><p>To build a 9th-order scheme (often a good choice for a stable yet minimally-dissipative advection scheme):</p><pre><code class="language-julia-repl hljs">julia&gt; WENO(order=9)
WENO{5, Float64, Float32}(order=9)
├── buffer_scheme: WENO{4, Float64, Float32}(order=7)
│   └── buffer_scheme: WENO{3, Float64, Float32}(order=5)
│       └── buffer_scheme: WENO{2, Float64, Float32}(order=3)
│           └── buffer_scheme: Centered(order=2)
└── advecting_velocity_scheme: Centered(order=8)</code></pre><p>To build a 9th-order scheme with <code>minimum_buffer_upwind_order=5</code>, which uses <code>Centered(order=2)</code> as the innermost buffer scheme:</p><pre><code class="language-julia-repl hljs">julia&gt; WENO(order=9, minimum_buffer_upwind_order=5)
WENO{5, Float64, Float32}(order=9)
├── buffer_scheme: WENO{4, Float64, Float32}(order=7)
│   └── buffer_scheme: WENO{3, Float64, Float32}(order=5)
│       └── buffer_scheme: Centered(order=2)
└── advecting_velocity_scheme: Centered(order=8)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; WENO(order=9, bounds=(0, 1))
WENO{5, Float64, Float32}(order=9, bounds=(0.0, 1.0))
├── buffer_scheme: WENO{4, Float64, Float32}(order=7, bounds=(0.0, 1.0))
│   └── buffer_scheme: WENO{3, Float64, Float32}(order=5, bounds=(0.0, 1.0))
│       └── buffer_scheme: WENO{2, Float64, Float32}(order=3, bounds=(0.0, 1.0))
│           └── buffer_scheme: Centered(order=2)
└── advecting_velocity_scheme: Centered(order=8)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Advection/weno_reconstruction.jl#L19-L94">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Advection.WENOVectorInvariant"><a class="docstring-binding" href="#Oceananigans.Advection.WENOVectorInvariant"><code>Oceananigans.Advection.WENOVectorInvariant</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">WENOVectorInvariant(FT = Float64;
                    upwinding = nothing,
                    vorticity_stencil = VelocityStencil(),
                    order = nothing,
                    vorticity_order = nothing,
                    vertical_order = nothing,
                    divergence_order = nothing,
                    kinetic_energy_gradient_order = nothing,
                    multi_dimensional_stencil = false,
                    minimum_buffer_upwind_order = 1,
                    weno_kw...)</code></pre><p>Return a vector-invariant weighted essentially non-oscillatory (WENO) scheme. See <a href="#Oceananigans.Advection.VectorInvariant"><code>VectorInvariant</code></a> and <a href="#Oceananigans.Advection.WENO"><code>WENO</code></a> for kwargs definitions.</p><p>If <code>multi_dimensional_stencil = true</code> is selected, then a 2D horizontal stencil is implemented for the WENO scheme (instead of a 1D stencil). This 2D horizontal stencil performs a centered 5th-order WENO reconstruction of vorticity, divergence and kinetic energy in the horizontal direction tangential to the upwind direction.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; WENOVectorInvariant()
WENOVectorInvariant{5, Float64, Float32}(vorticity_order=9, vertical_order=5)
├── vorticity_scheme: WENO{5, Float64, Float32}(order=9)
├── vorticity_stencil: Oceananigans.Advection.VelocityStencil
├── vertical_advection_scheme: WENO{3, Float64, Float32}(order=5)
├── kinetic_energy_gradient_scheme: WENO{3, Float64, Float32}(order=5)
├── divergence_scheme: WENO{3, Float64, Float32}(order=5)
└── upwinding: OnlySelfUpwinding</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Advection/vector_invariant_advection.jl#L168-L204">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Advection.div_Uc-NTuple{7, Any}"><a class="docstring-binding" href="#Oceananigans.Advection.div_Uc-NTuple{7, Any}"><code>Oceananigans.Advection.div_Uc</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">div_uc(i, j, k, grid, advection, U, c)</code></pre><p>Calculate the divergence of the flux of a tracer quantity <span>$c$</span> being advected by a velocity field, <span>$𝛁⋅(𝐯 c)$</span>,</p><pre><code class="language-julia hljs">1/V * [δxᶜᵃᵃ(Ax * u * ℑxᶠᵃᵃ(c)) + δyᵃᶜᵃ(Ay * v * ℑyᵃᶠᵃ(c)) + δzᵃᵃᶜ(Az * w * ℑzᵃᵃᶠ(c))]</code></pre><p>which ends up at the location <code>ccc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Advection/tracer_advection_operators.jl#L19-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Advection.div_𝐯u-NTuple{7, Any}"><a class="docstring-binding" href="#Oceananigans.Advection.div_𝐯u-NTuple{7, Any}"><code>Oceananigans.Advection.div_𝐯u</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">div_𝐯u(i, j, k, grid, advection, U, u)</code></pre><p>Calculate the advection of momentum in the <span>$x$</span>-direction using the conservative form, <span>$𝛁⋅(𝐯 u)$</span>,</p><pre><code class="language-julia hljs">1/Vᵘ * [δxᶠᵃᵃ(ℑxᶜᵃᵃ(Ax * u) * ℑxᶜᵃᵃ(u)) + δy_fca(ℑxᶠᵃᵃ(Ay * v) * ℑyᵃᶠᵃ(u)) + δz_fac(ℑxᶠᵃᵃ(Az * w) * ℑzᵃᵃᶠ(u))]</code></pre><p>which ends up at the location <code>fcc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Advection/momentum_advection_operators.jl#L35-L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Advection.div_𝐯v-NTuple{7, Any}"><a class="docstring-binding" href="#Oceananigans.Advection.div_𝐯v-NTuple{7, Any}"><code>Oceananigans.Advection.div_𝐯v</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">div_𝐯v(i, j, k, grid, advection, U, v)</code></pre><p>Calculate the advection of momentum in the <span>$y$</span>-direction using the conservative form, <span>$𝛁⋅(𝐯 v)$</span>,</p><pre><code class="language-julia hljs">1/Vʸ * [δx_cfa(ℑyᵃᶠᵃ(Ax * u) * ℑxᶠᵃᵃ(v)) + δyᵃᶠᵃ(ℑyᵃᶜᵃ(Ay * v) * ℑyᵃᶜᵃ(v)) + δz_afc(ℑxᶠᵃᵃ(Az * w) * ℑzᵃᵃᶠ(w))]</code></pre><p>which ends up at the location <code>cfc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Advection/momentum_advection_operators.jl#L52-L62">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Advection.div_𝐯w-NTuple{7, Any}"><a class="docstring-binding" href="#Oceananigans.Advection.div_𝐯w-NTuple{7, Any}"><code>Oceananigans.Advection.div_𝐯w</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">div_𝐯w(i, j, k, grid, advection, U, w)</code></pre><p>Calculate the advection of momentum in the <span>$z$</span>-direction using the conservative form, <span>$𝛁⋅(𝐯 w)$</span>,</p><pre><code class="language-julia hljs">1/Vʷ * [δx_caf(ℑzᵃᵃᶠ(Ax * u) * ℑxᶠᵃᵃ(w)) + δy_acf(ℑzᵃᵃᶠ(Ay * v) * ℑyᵃᶠᵃ(w)) + δzᵃᵃᶠ(ℑzᵃᵃᶜ(Az * w) * ℑzᵃᵃᶜ(w))]</code></pre><p>which ends up at the location <code>ccf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Advection/momentum_advection_operators.jl#L69-L78">source</a></section></details></article><h2 id="Architectures"><a class="docs-heading-anchor" href="#Architectures">Architectures</a><a id="Architectures-1"></a><a class="docs-heading-anchor-permalink" href="#Architectures" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Oceananigans.Architectures.AbstractArchitecture"><a class="docstring-binding" href="#Oceananigans.Architectures.AbstractArchitecture"><code>Oceananigans.Architectures.AbstractArchitecture</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractArchitecture</code></pre><p>Abstract supertype for architectures supported by Oceananigans.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Architectures.jl#L15-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Architectures.AbstractSerialArchitecture"><a class="docstring-binding" href="#Oceananigans.Architectures.AbstractSerialArchitecture"><code>Oceananigans.Architectures.AbstractSerialArchitecture</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractSerialArchitecture</code></pre><p>Abstract supertype for serial architectures supported by Oceananigans.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Architectures.jl#L22-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Architectures.CPU"><a class="docstring-binding" href="#Oceananigans.Architectures.CPU"><code>Oceananigans.Architectures.CPU</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CPU &lt;: AbstractArchitecture</code></pre><p>Run Oceananigans on one CPU node. Uses multiple threads if the environment variable <code>JULIA_NUM_THREADS</code> is set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Architectures.jl#L29-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Architectures.GPU"><a class="docstring-binding" href="#Oceananigans.Architectures.GPU"><code>Oceananigans.Architectures.GPU</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GPU(device)</code></pre><p>Return a GPU architecture using <code>device</code>. <code>device</code> defauls to CUDA.CUDABackend(always_inline=true) if CUDA is loaded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Architectures.jl#L37-L43">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Architectures.ReactantState"><a class="docstring-binding" href="#Oceananigans.Architectures.ReactantState"><code>Oceananigans.Architectures.ReactantState</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ReactantState &lt;: AbstractArchitecture</code></pre><p>Run Oceananigans on Reactant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Architectures.jl#L48-L52">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Architectures.child_architecture-Tuple{Oceananigans.Architectures.AbstractSerialArchitecture}"><a class="docstring-binding" href="#Oceananigans.Architectures.child_architecture-Tuple{Oceananigans.Architectures.AbstractSerialArchitecture}"><code>Oceananigans.Architectures.child_architecture</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">child_architecture(arch)</code></pre><p>Return <code>arch</code>itecture of child processes. On single-process, non-distributed systems, return <code>arch</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Architectures.jl#L83-L88">source</a></section></details></article><h2 id="Boundary-conditions"><a class="docs-heading-anchor" href="#Boundary-conditions">Boundary conditions</a><a id="Boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-conditions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Oceananigans.BoundaryConditions.BoundaryCondition"><a class="docstring-binding" href="#Oceananigans.BoundaryConditions.BoundaryCondition"><code>Oceananigans.BoundaryConditions.BoundaryCondition</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct BoundaryCondition{C&lt;:AbstractBoundaryConditionClassification, T}</code></pre><p>Container for boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/BoundaryConditions/boundary_condition.jl#L3-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.BoundaryConditions.BoundaryCondition-Tuple{Oceananigans.BoundaryConditions.AbstractBoundaryConditionClassification, Function}"><a class="docstring-binding" href="#Oceananigans.BoundaryConditions.BoundaryCondition-Tuple{Oceananigans.BoundaryConditions.AbstractBoundaryConditionClassification, Function}"><code>Oceananigans.BoundaryConditions.BoundaryCondition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">BoundaryCondition(classification::AbstractBoundaryConditionClassification, condition::Function;
                  parameters = nothing,
                  discrete_form = false,
                  field_dependencies=())</code></pre><p>Construct a boundary condition of type <code>classification</code> with a function boundary <code>condition</code>.</p><p>By default, the function boudnary <code>condition</code> is assumed to have the &#39;continuous form&#39; <code>condition(ξ, η, t)</code>, where <code>t</code> is time and <code>ξ</code> and <code>η</code> vary along the boundary. In particular:</p><ul><li>On <code>x</code>-boundaries, <code>condition(y, z, t)</code>.</li><li>On <code>y</code>-boundaries, <code>condition(x, z, t)</code>.</li><li>On <code>z</code>-boundaries, <code>condition(x, y, t)</code>.</li></ul><p>If <code>parameters</code> is not <code>nothing</code>, then function boundary conditions have the form <code>func(ξ, η, t, parameters)</code>, where <code>ξ</code> and <code>η</code> are spatial coordinates varying along the boundary as explained above.</p><p>If <code>discrete_form = true</code>, the function <code>condition</code> is assumed to have the &quot;discrete form&quot;,</p><pre><code class="language-julia hljs">condition(i, j, grid, clock, model_fields)</code></pre><p>where <code>i</code>, and <code>j</code> are indices that vary along the boundary. If <code>discrete_form = true</code> and <code>parameters</code> is not <code>nothing</code>, the function <code>condition</code> is called with</p><pre><code class="language-julia hljs">condition(i, j, grid, clock, model_fields, parameters)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/BoundaryConditions/boundary_condition.jl#L13-L42">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.BoundaryConditions.FieldBoundaryConditions"><a class="docstring-binding" href="#Oceananigans.BoundaryConditions.FieldBoundaryConditions"><code>Oceananigans.BoundaryConditions.FieldBoundaryConditions</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FieldBoundaryConditions(; kwargs...)</code></pre><p>Return a template for boundary conditions on prognostic fields.</p><p><strong>Keyword arguments</strong></p><p>Keyword arguments specify boundary conditions on the 7 possible boundaries:</p><ul><li><code>west</code>: left end point in the <code>x</code>-direction where <code>i = 1</code></li><li><code>east</code>: right end point in the <code>x</code>-direction where <code>i = grid.Nx</code></li><li><code>south</code>: left end point in the <code>y</code>-direction where <code>j = 1</code></li><li><code>north</code>: right end point in the <code>y</code>-direction where <code>j = grid.Ny</code></li><li><code>bottom</code>: right end point in the <code>z</code>-direction where <code>k = 1</code></li><li><code>top</code>: right end point in the <code>z</code>-direction where <code>k = grid.Nz</code></li><li><code>immersed</code>: boundary between solid and fluid for immersed boundaries</li></ul><p>If a boundary condition is unspecified, the default for prognostic fields and the topology in the boundary-normal direction is used:</p><ul><li><code>PeriodicBoundaryCondition</code> for <code>Periodic</code> directions</li><li><code>NoFluxBoundaryCondition</code> for <code>Bounded</code> directions and <code>Centered</code>-located fields</li><li><code>ImpenetrableBoundaryCondition</code> for <code>Bounded</code> directions and <code>Face</code>-located fields</li><li><code>nothing</code> for <code>Flat</code> directions and/or <code>Nothing</code>-located fields</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/BoundaryConditions/field_boundary_conditions.jl#L104-L129">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.BoundaryConditions.FieldBoundaryConditions"><a class="docstring-binding" href="#Oceananigans.BoundaryConditions.FieldBoundaryConditions"><code>Oceananigans.BoundaryConditions.FieldBoundaryConditions</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FieldBoundaryConditions(grid, location, indices=(:, :, :);
                        west     = default_auxiliary_bc(grid, boundary, loc),
                        east     = default_auxiliary_bc(grid, boundary, loc),
                        south    = default_auxiliary_bc(grid, boundary, loc),
                        north    = default_auxiliary_bc(grid, boundary, loc),
                        bottom   = default_auxiliary_bc(grid, boundary, loc),
                        top      = default_auxiliary_bc(grid, boundary, loc),
                        immersed = NoFluxBoundaryCondition())</code></pre><p>Return boundary conditions for auxiliary fields (fields whose values are derived from a model&#39;s prognostic fields) on <code>grid</code> and at <code>location</code>.</p><p><strong>Keyword arguments</strong></p><p>Keyword arguments specify boundary conditions on the 6 possible boundaries:</p><ul><li><code>west</code>, left end point in the <code>x</code>-direction where <code>i = 1</code></li><li><code>east</code>, right end point in the <code>x</code>-direction where <code>i = grid.Nx</code></li><li><code>south</code>, left end point in the <code>y</code>-direction where <code>j = 1</code></li><li><code>north</code>, right end point in the <code>y</code>-direction where <code>j = grid.Ny</code></li><li><code>bottom</code>, right end point in the <code>z</code>-direction where <code>k = 1</code></li><li><code>top</code>, right end point in the <code>z</code>-direction where <code>k = grid.Nz</code></li><li><code>immersed</code>: boundary between solid and fluid for immersed boundaries</li></ul><p>If a boundary condition is unspecified, the default for auxiliary fields and the topology in the boundary-normal direction is used:</p><ul><li><code>PeriodicBoundaryCondition</code> for <code>Periodic</code> directions</li><li><code>GradientBoundaryCondition(0)</code> for <code>Bounded</code> directions and <code>Centered</code>-located fields</li><li><code>nothing</code> for <code>Bounded</code> directions and <code>Face</code>-located fields</li><li><code>nothing</code> for <code>Flat</code> directions and/or <code>Nothing</code>-located fields</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/BoundaryConditions/field_boundary_conditions.jl#L140-L173">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.BoundaryConditions.Flux"><a class="docstring-binding" href="#Oceananigans.BoundaryConditions.Flux"><code>Oceananigans.BoundaryConditions.Flux</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct Flux &lt;: AbstractBoundaryConditionClassification</code></pre><p>A classification specifying a boundary condition on the flux of a field.</p><p>The sign convention is such that a positive flux represents the flux of a quantity in the positive direction. For example, a positive vertical flux implies a quantity is fluxed upwards, in the <span>$+z$</span> direction.</p><p>Due to this convention, a positive flux applied to the top boundary specifies that a quantity is fluxed upwards across the top boundary and thus out of the domain. As a result, a positive flux applied to a top boundary leads to a reduction of that quantity in the interior of the domain; for example, a positive, upwards flux of heat at the top of the domain acts to cool the interior of the domain. Conversely, a positive flux applied to the bottom boundary leads to an increase of the quantity in the interior of the domain. The same logic holds for east, west, north, and south boundaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/BoundaryConditions/boundary_condition_classifications.jl#L17-L33">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.BoundaryConditions.Gradient"><a class="docstring-binding" href="#Oceananigans.BoundaryConditions.Gradient"><code>Oceananigans.BoundaryConditions.Gradient</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct Gradient &lt;: AbstractBoundaryConditionClassification</code></pre><p>A classification specifying a boundary condition on the derivative or gradient of a field. Also called a Neumann boundary condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/BoundaryConditions/boundary_condition_classifications.jl#L36-L41">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.BoundaryConditions.Open"><a class="docstring-binding" href="#Oceananigans.BoundaryConditions.Open"><code>Oceananigans.BoundaryConditions.Open</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct Open &lt;: AbstractBoundaryConditionClassification</code></pre><p>A classification that specifies the halo regions of a field directly.</p><p>For fields located at <code>Faces</code>, <code>Open</code> also specifies field value <em>on</em> the boundary.</p><p>Open boundary conditions are used to specify the component of a velocity field normal to a boundary and can also be used to describe nested or linked simulation domains.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/BoundaryConditions/boundary_condition_classifications.jl#L60-L69">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.BoundaryConditions.PerturbationAdvection"><a class="docstring-binding" href="#Oceananigans.BoundaryConditions.PerturbationAdvection"><code>Oceananigans.BoundaryConditions.PerturbationAdvection</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PerturbationAdvection(FT = defaults.FloatType;
                      outflow_timescale = Inf,
                      inflow_timescale = 0)</code></pre><p>Create a <code>PerturbationAdvection</code> scheme to be used with an <code>OpenBoundaryCondition</code>. This scheme will nudge the boundary velocity to the OpenBoundaryCondition&#39;s exterior value <code>val</code>, using a time-scale <code>inflow_timescale</code> for inflow and <code>outflow_timescale</code> for outflow.</p><p>For cases where we assume that the internal flow is a small perturbation from an external prescribed or coarser flow, we can split the velocity into background and perturbation components.</p><p>We begin with the equation governing the fluid in the interior:     ∂ₜu + u⋅∇u = −∇P + F, and note that on the boundary the pressure gradient is zero. We can then assume that the flow composes of mean (U⃗) and pertubation (u⃗′) components, and considering the x-component of velocity, we can rewrite the equation as     ∂ₜu₁ = -u₁∂₁u - u₂∂₂u₁ - u₃∂₃u₁ + F₁ ≈ - U₁∂₁u₁′ - U₂∂₂u₁′ - U₃∂₃u₁′ + F.</p><p>Simplify by assuming that U⃗ = Ux̂, an then take a numerical step to find u₁.</p><p>When the boundaries are filled the interior is at time tₙ₊₁ so we can take a backwards euler step (in the case that the mean flow is boundary normal) on a right boundary:     (Uⁿ⁺¹ - Uⁿ) / Δt + (u′ⁿ⁺¹ - u′ⁿ) / Δt = - Uⁿ⁺¹ (u′ⁿ⁺¹ᵢ - u′ⁿ⁺¹ᵢ₋₁) / Δx + Fᵤ.</p><p>This can not be solved for general forcing, but if we assume the dominant forcing is relaxation to the mean velocity (i.e. u′→0) then Fᵤ = -u′ / τ then we can find u′ⁿ⁺¹:     u′ⁿ⁺¹ = (uⁿ + Ũu′ⁿ⁺¹ᵢ₋₁ - Uⁿ⁺¹) / (1 + Ũ + Δt/τ),</p><p>where Ũ = U Δt / Δx, then uⁿ⁺¹ is:     uⁿ⁺¹ = (uᵢⁿ + Ũuᵢ₋₁ⁿ⁺¹ + Uⁿ⁺¹τ̃) / (1 + τ̃ + Ũ)</p><p>where τ̃ = Δt/τ.</p><p>The same operation can be repeated for left boundaries.</p><p>The relaxation timescale <span>$τ$</span> can be set to different values depending on whether <span>$U$</span> points in or out of the domain (<code>inflow_timescale</code>/<code>outflow_timescale</code>). Since the scheme is only valid when the flow is directed out of the domain the boundary condition falls back to relaxation to the prescribed value. By default this happens instantly but if the direction varies this may not be preferable. It is beneficial to relax the outflow (i.e. non-zero <code>outflow_timescale</code>) to reduce the shock when the flow changes direction to point into the domain.</p><p>The ideal value of the timescales probably depend on the grid spacing and details of the boundary flow.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/BoundaryConditions/perturbation_advection.jl#L9-L56">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.BoundaryConditions.Value"><a class="docstring-binding" href="#Oceananigans.BoundaryConditions.Value"><code>Oceananigans.BoundaryConditions.Value</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct Value &lt;: AbstractBoundaryConditionClassification</code></pre><p>A classification specifying a boundary condition on the value of a field. Also called a Dirchlet boundary condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/BoundaryConditions/boundary_condition_classifications.jl#L44-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.BoundaryConditions.compute_x_bcs!-Tuple{Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any, Oceananigans.Architectures.AbstractArchitecture, Vararg{Any}}"><a class="docstring-binding" href="#Oceananigans.BoundaryConditions.compute_x_bcs!-Tuple{Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any, Oceananigans.Architectures.AbstractArchitecture, Vararg{Any}}"><code>Oceananigans.BoundaryConditions.compute_x_bcs!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Apply flux boundary conditions to a field <code>c</code> by adding the associated flux divergence to the source term <code>Gc</code> at the left and right.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/BoundaryConditions/compute_flux_bcs.jl#L31-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.BoundaryConditions.compute_y_bcs!-Tuple{Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any, Oceananigans.Architectures.AbstractArchitecture, Vararg{Any}}"><a class="docstring-binding" href="#Oceananigans.BoundaryConditions.compute_y_bcs!-Tuple{Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any, Oceananigans.Architectures.AbstractArchitecture, Vararg{Any}}"><code>Oceananigans.BoundaryConditions.compute_y_bcs!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Apply flux boundary conditions to a field <code>c</code> by adding the associated flux divergence to the source term <code>Gc</code> at the left and right.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/BoundaryConditions/compute_flux_bcs.jl#L38-L41">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.BoundaryConditions.compute_z_bcs!-Tuple{Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any, Oceananigans.Architectures.AbstractArchitecture, Vararg{Any}}"><a class="docstring-binding" href="#Oceananigans.BoundaryConditions.compute_z_bcs!-Tuple{Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any, Oceananigans.Architectures.AbstractArchitecture, Vararg{Any}}"><code>Oceananigans.BoundaryConditions.compute_z_bcs!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Apply flux boundary conditions to a field <code>c</code> by adding the associated flux divergence to the source term <code>Gc</code> at the top and bottom.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/BoundaryConditions/compute_flux_bcs.jl#L45-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.BoundaryConditions.fill_halo_regions!-Tuple{OffsetArrays.OffsetArray, Any, Any, Any, Any, Vararg{Any}}"><a class="docstring-binding" href="#Oceananigans.BoundaryConditions.fill_halo_regions!-Tuple{OffsetArrays.OffsetArray, Any, Any, Any, Any, Vararg{Any}}"><code>Oceananigans.BoundaryConditions.fill_halo_regions!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Fill halo regions in <span>$x$</span>, <span>$y$</span>, and <span>$z$</span> for a given field&#39;s data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/BoundaryConditions/fill_halo_regions.jl#L24">source</a></section></details></article><h2 id="Buoyancy-models"><a class="docs-heading-anchor" href="#Buoyancy-models">Buoyancy models</a><a id="Buoyancy-models-1"></a><a class="docs-heading-anchor-permalink" href="#Buoyancy-models" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Oceananigans.BuoyancyFormulations.BuoyancyForce-Tuple{Any, Oceananigans.BuoyancyFormulations.AbstractBuoyancyFormulation}"><a class="docstring-binding" href="#Oceananigans.BuoyancyFormulations.BuoyancyForce-Tuple{Any, Oceananigans.BuoyancyFormulations.AbstractBuoyancyFormulation}"><code>Oceananigans.BuoyancyFormulations.BuoyancyForce</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">BuoyancyForce(grid, formulation::AbstractBuoyancyFormulation; gravity_unit_vector=NegativeZDirection(), materialize_gradients=false)</code></pre><p>Construct a <code>buoyancy</code> given a buoyancy <code>formulation</code>. Optional keyword argument <code>gravity_unit_vector</code> can be used to specify the direction of gravity (default <code>NegativeZDirection()</code>). The buoyancy acceleration acts in the direction opposite to gravity. If <code>materialize_gradients</code> is true (default is false), the buoyancy gradients will be precomputed and stored in fields for performance reasons. For <code>materialize_gradients=true</code>, the <code>grid</code> argument must be provided.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Oceananigans

grid = RectilinearGrid(size=(1, 8, 8), extent=(1, 1, 1))

θ = 45 # degrees
g̃ = (0, -sind(θ), -cosd(θ))

buoyancy = BuoyancyForce(BuoyancyTracer(), gravity_unit_vector=g̃)

model = NonhydrostaticModel(; grid, buoyancy, tracers=:b)

# output

NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)
├── grid: 1×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×3×3 halo
├── timestepper: RungeKutta3TimeStepper
├── advection scheme: Centered(order=2)
├── tracers: b
├── closure: Nothing
├── buoyancy: BuoyancyTracer with ĝ = (0.0, -0.707107, -0.707107)
└── coriolis: Nothing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/BuoyancyFormulations/buoyancy_force.jl#L15-L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.BuoyancyFormulations.BuoyancyTracer"><a class="docstring-binding" href="#Oceananigans.BuoyancyFormulations.BuoyancyTracer"><code>Oceananigans.BuoyancyFormulations.BuoyancyTracer</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BuoyancyTracer &lt;: AbstractBuoyancyFormulation{Nothing}</code></pre><p>Type indicating that the tracer <code>b</code> represents buoyancy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/BuoyancyFormulations/buoyancy_tracer.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.BuoyancyFormulations.LinearEquationOfState"><a class="docstring-binding" href="#Oceananigans.BuoyancyFormulations.LinearEquationOfState"><code>Oceananigans.BuoyancyFormulations.LinearEquationOfState</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LinearEquationOfState([FT=Float64;] thermal_expansion=1.67e-4, haline_contraction=7.80e-4)</code></pre><p>Return <code>LinearEquationOfState</code> for <code>SeawaterBuoyancy</code> with <code>thermal_expansion</code> coefficient and <code>haline_contraction</code> coefficient. The buoyancy perturbation <span>$b$</span> for <code>LinearEquationOfState</code> is</p><p class="math-container">\[    b = g (α T - β S),\]</p><p>where <span>$g$</span> is gravitational acceleration, <span>$α$</span> is <code>thermal_expansion</code>, <span>$β$</span> is <code>haline_contraction</code>, <span>$T$</span> is temperature, and <span>$S$</span> is practical salinity units.</p><p>Default constants in units inverse Kelvin and practical salinity units for <code>thermal_expansion</code> and <code>haline_contraction</code>, respectively, are taken from Table 1.2 (page 33) of Vallis, &quot;Atmospheric and Oceanic Fluid Dynamics: Fundamentals and Large-Scale Circulation&quot; (2nd ed, 2017).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/BuoyancyFormulations/linear_equation_of_state.jl#L20-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.BuoyancyFormulations.LinearEquationOfState"><a class="docstring-binding" href="#Oceananigans.BuoyancyFormulations.LinearEquationOfState"><code>Oceananigans.BuoyancyFormulations.LinearEquationOfState</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LinearEquationOfState{FT} &lt;: AbstractEquationOfState</code></pre><p>Linear equation of state for seawater.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/BuoyancyFormulations/linear_equation_of_state.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.BuoyancyFormulations.SeawaterBuoyancy"><a class="docstring-binding" href="#Oceananigans.BuoyancyFormulations.SeawaterBuoyancy"><code>Oceananigans.BuoyancyFormulations.SeawaterBuoyancy</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SeawaterBuoyancy([FT = Float64;]
                 gravitational_acceleration = Oceananigans.defaults.gravitational_acceleration,
                 equation_of_state = LinearEquationOfState(FT),
                 constant_temperature = nothing,
                 constant_salinity = nothing)</code></pre><p>Return parameters for a temperature- and salt-stratified seawater buoyancy model with a <code>gravitational_acceleration</code> constant (typically called <span>$g$</span>), and an <code>equation_of_state</code> that related temperature and salinity (or conservative temperature and absolute salinity) to density anomalies and buoyancy.</p><p>Setting <code>constant_temperature</code> to something that is not <code>nothing</code> indicates that buoyancy depends only on salinity. For a nonlinear equation of state, the value provided <code>constant_temperature</code> is used as the temperature of the system. Vice versa, setting <code>constant_salinity</code> indicates that buoyancy depends only on temperature.</p><p>For a linear equation of state, the values of <code>constant_temperature</code> or <code>constant_salinity</code> are irrelevant.</p><p><strong>Examples</strong></p><p>The &quot;TEOS10&quot; equation of state, see https://www.teos-10.org</p><pre><code class="language-julia-repl hljs">julia&gt; using SeawaterPolynomials.TEOS10: TEOS10EquationOfState

julia&gt; teos10 = TEOS10EquationOfState()
BoussinesqEquationOfState{Float64}:
├── seawater_polynomial: TEOS10SeawaterPolynomial{Float64}
└── reference_density: 1020.0</code></pre><p>Buoyancy that depends on both temperature and salinity</p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; buoyancy = SeawaterBuoyancy(equation_of_state=teos10)
SeawaterBuoyancy{Float64}:
├── gravitational_acceleration: 9.80665
└── equation_of_state: BoussinesqEquationOfState{Float64}</code></pre><p>Buoyancy that depends only on salinity with temperature held at 20 degrees Celsius</p><pre><code class="language-julia-repl hljs">julia&gt; salinity_dependent_buoyancy = SeawaterBuoyancy(equation_of_state=teos10, constant_temperature=20)
SeawaterBuoyancy{Float64}:
├── gravitational_acceleration: 9.80665
├── constant_temperature: 20.0
└── equation_of_state: BoussinesqEquationOfState{Float64}</code></pre><p>Buoyancy that depends only on temperature with salinity held at 35 psu</p><pre><code class="language-julia-repl hljs">julia&gt; temperature_dependent_buoyancy = SeawaterBuoyancy(equation_of_state=teos10, constant_salinity=35)
SeawaterBuoyancy{Float64}:
├── gravitational_acceleration: 9.80665
├── constant_salinity: 35.0
└── equation_of_state: BoussinesqEquationOfState{Float64}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/BuoyancyFormulations/seawater_buoyancy.jl#L42-L105">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.BuoyancyFormulations.SeawaterBuoyancy"><a class="docstring-binding" href="#Oceananigans.BuoyancyFormulations.SeawaterBuoyancy"><code>Oceananigans.BuoyancyFormulations.SeawaterBuoyancy</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SeawaterBuoyancy{FT, EOS, T, S} &lt;: AbstractBuoyancyFormulation{EOS}</code></pre><p>Buoyancy formulation for seawater. <code>T</code> and <code>S</code> are either <code>nothing</code> if both temperature and salinity are active, or of type <code>FT</code> if temperature or salinity are constant, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/BuoyancyFormulations/seawater_buoyancy.jl#L4-L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.BuoyancyFormulations.∂x_b-Tuple{Any, Any, Any, Any, SeawaterBuoyancy, Any}"><a class="docstring-binding" href="#Oceananigans.BuoyancyFormulations.∂x_b-Tuple{Any, Any, Any, Any, SeawaterBuoyancy, Any}"><code>Oceananigans.BuoyancyFormulations.∂x_b</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">∂x_b(i, j, k, grid, b::SeawaterBuoyancy, C)</code></pre><p>Returns the <span>$x$</span>-derivative of buoyancy for temperature and salt-stratified water,</p><p class="math-container">\[∂_x b = g ( α ∂_x T - β ∂_x S ) ,\]</p><p>where <span>$g$</span> is gravitational acceleration, <span>$α$</span> is the thermal expansion coefficient, <span>$β$</span> is the haline contraction coefficient, <span>$T$</span> is conservative temperature, and <span>$S$</span> is absolute salinity.</p><p>Note: In Oceananigans, <code>model.tracers.T</code> is conservative temperature and <code>model.tracers.S</code> is absolute salinity.</p><p>Note that <span>$∂_x T$</span> (<code>∂x_T</code>), <span>$∂_x S$</span> (<code>∂x_S</code>), <span>$α$</span>, and <span>$β$</span> are all evaluated at cell interfaces in <code>x</code> and cell centers in <code>y</code> and <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/BuoyancyFormulations/seawater_buoyancy.jl#L148-L166">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.BuoyancyFormulations.∂y_b-Tuple{Any, Any, Any, Any, SeawaterBuoyancy, Any}"><a class="docstring-binding" href="#Oceananigans.BuoyancyFormulations.∂y_b-Tuple{Any, Any, Any, Any, SeawaterBuoyancy, Any}"><code>Oceananigans.BuoyancyFormulations.∂y_b</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">∂y_b(i, j, k, grid, b::SeawaterBuoyancy, C)</code></pre><p>Returns the <span>$y$</span>-derivative of buoyancy for temperature and salt-stratified water,</p><p class="math-container">\[∂_y b = g ( α ∂_y T - β ∂_y S ) ,\]</p><p>where <span>$g$</span> is gravitational acceleration, <span>$α$</span> is the thermal expansion coefficient, <span>$β$</span> is the haline contraction coefficient, <span>$T$</span> is conservative temperature, and <span>$S$</span> is absolute salinity.</p><p>Note: In Oceananigans, <code>model.tracers.T</code> is conservative temperature and <code>model.tracers.S</code> is absolute salinity.</p><p>Note that <span>$∂_y T$</span> (<code>∂y_T</code>), <span>$∂_y S$</span> (<code>∂y_S</code>), <span>$α$</span>, and <span>$β$</span> are all evaluated at cell interfaces in <code>y</code> and cell centers in <code>x</code> and <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/BuoyancyFormulations/seawater_buoyancy.jl#L174-L192">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.BuoyancyFormulations.∂z_b-Tuple{Any, Any, Any, Any, SeawaterBuoyancy, Any}"><a class="docstring-binding" href="#Oceananigans.BuoyancyFormulations.∂z_b-Tuple{Any, Any, Any, Any, SeawaterBuoyancy, Any}"><code>Oceananigans.BuoyancyFormulations.∂z_b</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">∂z_b(i, j, k, grid, b::SeawaterBuoyancy, C)</code></pre><p>Returns the vertical derivative of buoyancy for temperature and salt-stratified water,</p><p class="math-container">\[∂_z b = N^2 = g ( α ∂_z T - β ∂_z S ) ,\]</p><p>where <span>$g$</span> is gravitational acceleration, <span>$α$</span> is the thermal expansion coefficient, <span>$β$</span> is the haline contraction coefficient, <span>$T$</span> is conservative temperature, and <span>$S$</span> is absolute salinity.</p><p>Note: In Oceananigans, <code>model.tracers.T</code> is conservative temperature and <code>model.tracers.S</code> is absolute salinity.</p><p>Note that <span>$∂_z T$</span> (<code>∂z_T</code>), <span>$∂_z S$</span> (<code>∂z_S</code>), <span>$α$</span>, and <span>$β$</span> are all evaluated at cell interfaces in <code>z</code> and cell centers in <code>x</code> and <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/BuoyancyFormulations/seawater_buoyancy.jl#L200-L218">source</a></section></details></article><h2 id="Coriolis"><a class="docs-heading-anchor" href="#Coriolis">Coriolis</a><a id="Coriolis-1"></a><a class="docs-heading-anchor-permalink" href="#Coriolis" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Oceananigans.Coriolis.BetaPlane"><a class="docstring-binding" href="#Oceananigans.Coriolis.BetaPlane"><code>Oceananigans.Coriolis.BetaPlane</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BetaPlane([FT=Float64;] f₀=nothing, β=nothing,
          rotation_rate=Oceananigans.defaults.planet_rotation_rate,
          latitude=nothing, radius=Oceananigans.defaults.planet_radius)</code></pre><p>Return a <span>$β$</span>-plane Coriolis parameter, <span>$f = f₀ + β y$</span> with floating-point type <code>FT</code>.</p><p>The user may specify both <code>f₀</code> and <code>β</code>, or the three parameters <code>rotation_rate</code>, <code>latitude</code> (in degrees), and <code>radius</code> that specify the rotation rate and radius of a planet, and the central latitude (where <span>$y = 0$</span>) at which the <code>β</code>-plane approximation is to be made.</p><p>If <code>f₀</code> and <code>β</code> are not specified, they are calculated from <code>rotation_rate</code>, <code>latitude</code>, and <code>radius</code> according to the relations <code>f₀ = 2 * rotation_rate * sind(latitude)</code> and <code>β = 2 * rotation_rate * cosd(latitude) / radius</code>.</p><p>By default, the <code>rotation_rate</code> and planet <code>radius</code> are assumed to be Earth&#39;s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Coriolis/beta_plane.jl#L6-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Coriolis.ConstantCartesianCoriolis"><a class="docstring-binding" href="#Oceananigans.Coriolis.ConstantCartesianCoriolis"><code>Oceananigans.Coriolis.ConstantCartesianCoriolis</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ConstantCartesianCoriolis([FT=Float64;] fx=nothing, fy=nothing, fz=nothing,
                          f=nothing, rotation_axis=ZDirection(),
                          rotation_rate=Oceananigans.defaults.planet_rotation_rate,
                          latitude=nothing)</code></pre><p>Return a parameter object for a constant rotation decomposed into the <code>x</code>, <code>y</code>, and <code>z</code> directions. In oceanography the components <code>x</code>, <code>y</code>, <code>z</code> correspond to the directions east, north, and up. This constant rotation can be specified in three different ways:</p><ul><li>Specifying all components <code>fx</code>, <code>fy</code> and <code>fz</code> directly.</li><li>Specifying the Coriolis parameter <code>f</code> and (optionally) a <code>rotation_axis</code> (which defaults to the <code>z</code> direction if not specified).</li><li>Specifying <code>latitude</code> (in degrees) and (optionally) a <code>rotation_rate</code> in radians per second (which defaults to Earth&#39;s rotation rate).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Coriolis/constant_cartesian_coriolis.jl#L16-L31">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Coriolis.ConstantCartesianCoriolis"><a class="docstring-binding" href="#Oceananigans.Coriolis.ConstantCartesianCoriolis"><code>Oceananigans.Coriolis.ConstantCartesianCoriolis</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ConstantCartesianCoriolis{FT} &lt;: AbstractRotation</code></pre><p>A Coriolis implementation that accounts for the locally vertical and possibly both local horizontal components of a constant rotation vector. This is a more general implementation of <a href="#Oceananigans.Coriolis.FPlane"><code>FPlane</code></a>, which only accounts for the locally vertical component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Coriolis/constant_cartesian_coriolis.jl#L3-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Coriolis.FPlane"><a class="docstring-binding" href="#Oceananigans.Coriolis.FPlane"><code>Oceananigans.Coriolis.FPlane</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FPlane([FT = Oceananigans.defaults.FloatType;]
       f = nothing,
       rotation_rate = Oceananigans.defaults.planet_rotation_rate,
       latitude = nothing)</code></pre><p>Return a parameter object for constant rotation at the angular frequency <code>f/2</code>, and therefore with background vorticity <code>f</code>, around a vertical axis. If <code>f</code> is not specified, it is calculated from <code>rotation_rate</code> and <code>latitude</code> (in degrees) according to the relation <code>f = 2 * rotation_rate * sind(latitude)</code>.</p><p>By default, <code>rotation_rate</code> is assumed to be Earth&#39;s.</p><p>Also called <code>FPlane</code>, after the &quot;f-plane&quot; approximation for the local effect of a planet&#39;s rotation in a planar coordinate system tangent to the planet&#39;s surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Coriolis/f_plane.jl#L12-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Coriolis.FPlane"><a class="docstring-binding" href="#Oceananigans.Coriolis.FPlane"><code>Oceananigans.Coriolis.FPlane</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct FPlane{FT} &lt;: AbstractRotation</code></pre><p>A parameter object for constant rotation around a vertical axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Coriolis/f_plane.jl#L3-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Coriolis.NonTraditionalBetaPlane"><a class="docstring-binding" href="#Oceananigans.Coriolis.NonTraditionalBetaPlane"><code>Oceananigans.Coriolis.NonTraditionalBetaPlane</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NonTraditionalBetaPlane([FT = Oceananigans.defaults.FloatType;]
                        fz = nothing,
                        fy = nothing,
                        β = nothing,
                        γ = nothing,
                        rotation_rate = Oceananigans.defaults.planet_rotation_rate,
                        latitude = nothing,
                        radius = Oceananigans.defaults.planet_radius)</code></pre><p>The user may directly specify <code>fz</code>, <code>fy</code>, <code>β</code>, <code>γ</code>, and <code>radius</code> or the three parameters <code>rotation_rate</code>, <code>latitude</code> (in degrees), and <code>radius</code> that specify the rotation rate and radius of a planet, and the central latitude (where <span>$y = 0$</span>) at which the non-traditional <code>β</code>-plane approximation is to be made.</p><p>If <code>fz</code>, <code>fy</code>, <code>β</code>, and <code>γ</code> are not specified, they are calculated from <code>rotation_rate</code>, <code>latitude</code>, and <code>radius</code> according to the relations <code>fz = 2 * rotation_rate * sind(latitude)</code>, <code>fy = 2 * rotation_rate * cosd(latitude)</code>, <code>β = 2 * rotation_rate * cosd(latitude) / radius</code>, and <code>γ = - 4 * rotation_rate * sind(latitude) / radius</code>.</p><p>By default, the <code>rotation_rate</code> and planet <code>radius</code> is assumed to be Earth&#39;s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Coriolis/non_traditional_beta_plane.jl#L29-L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Coriolis.NonTraditionalBetaPlane"><a class="docstring-binding" href="#Oceananigans.Coriolis.NonTraditionalBetaPlane"><code>Oceananigans.Coriolis.NonTraditionalBetaPlane</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct NonTraditionalBetaPlane{FT} &lt;: AbstractRotation</code></pre><p>A Coriolis implementation that accounts for the latitudinal variation of both the locally vertical and the locally horizontal components of the rotation vector. The &quot;traditional&quot; approximation in ocean models accounts for only the locally vertical component of the rotation vector (see <a href="@reface"><code>BetaPlane</code></a>).</p><p>This implementation is based off of section 5 of paper by <a href="../../references/#Dellar2011">Dellar (2011)</a> and it conserves energy, angular momentum, and potential vorticity.</p><p><strong>References</strong></p><p>Dellar, P. (2011). Variations on a beta-plane: Derivation of non-traditional     beta-plane equations from Hamilton&#39;s principle on a sphere. Journal of     Fluid Mechanics, 674, 174-195. doi:10.1017/S0022112010006464</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Coriolis/non_traditional_beta_plane.jl#L3-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Coriolis.SphericalCoriolis"><a class="docstring-binding" href="#Oceananigans.Coriolis.SphericalCoriolis"><code>Oceananigans.Coriolis.SphericalCoriolis</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SphericalCoriolis([FT=Float64;]
                  rotation_rate = Ω_Earth,
                  scheme = EnstrophyConserving())
                  formulation = HydrostaticFormulation()</code></pre><p>Return a parameter object for Coriolis forces on a sphere rotating at <code>rotation_rate</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>rotation_rate</code>: Sphere&#39;s rotation rate; default: <a href="@ref"><code>Ω_Earth</code></a>.</li><li><code>scheme</code>: Either <code>EnergyConserving()</code> or <code>EnstrophyConserving()</code> (default).</li><li><code>formulation</code>: <code>HydrostaticFormulation</code> or <code>NonhydrostaticFormulation</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Coriolis/spherical_coriolis.jl#L17-L31">source</a></section></details></article><h2 id="Diagnostics"><a class="docs-heading-anchor" href="#Diagnostics">Diagnostics</a><a id="Diagnostics-1"></a><a class="docs-heading-anchor-permalink" href="#Diagnostics" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Oceananigans.Diagnostics.CFL"><a class="docstring-binding" href="#Oceananigans.Diagnostics.CFL"><code>Oceananigans.Diagnostics.CFL</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct CFL{D, S}</code></pre><p>An object for computing the Courant-Freidrichs-Lewy (CFL) number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Diagnostics/cfl.jl#L3-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Diagnostics.CFL-Tuple{Any}"><a class="docstring-binding" href="#Oceananigans.Diagnostics.CFL-Tuple{Any}"><code>Oceananigans.Diagnostics.CFL</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">CFL(Δt [, timescale = Oceananigans.Advection.cell_advection_timescale])</code></pre><p>Return an object for computing the Courant-Freidrichs-Lewy (CFL) number associated with time step <code>Δt</code> or <code>TimeStepWizard</code> and <code>timescale</code>.</p><p>See also <a href="#Oceananigans.Diagnostics.AdvectiveCFL-Tuple{Any}"><code>AdvectiveCFL</code></a> and <a href="Oceananigans.Diagnostics.DiffusiveCFL"><code>DiffusiveCFL</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Diagnostics/cfl.jl#L13-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Diagnostics.StateChecker-Tuple{Any}"><a class="docstring-binding" href="#Oceananigans.Diagnostics.StateChecker-Tuple{Any}"><code>Oceananigans.Diagnostics.StateChecker</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">StateChecker(; schedule, fields)</code></pre><p>Returns a <code>StateChecker</code> that logs field information (minimum, maximum, mean) for each field in a named tuple of <code>fields</code> when <code>schedule</code> actuates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Diagnostics/state_checker.jl#L9-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Diagnostics.AdvectiveCFL-Tuple{Any}"><a class="docstring-binding" href="#Oceananigans.Diagnostics.AdvectiveCFL-Tuple{Any}"><code>Oceananigans.Diagnostics.AdvectiveCFL</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">AdvectiveCFL(Δt)</code></pre><p>Return an object for computing the Courant-Freidrichs-Lewy (CFL) number associated with time step <code>Δt</code> or <code>TimeStepWizard</code> and the time scale for advection across a cell. The advective CFL is, e.g., <span>$U Δt / Δx$</span>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; model = NonhydrostaticModel(grid = RectilinearGrid(size=(16, 16, 16), extent=(8, 8, 8)));

julia&gt; Δt = 1.0;

julia&gt; cfl = AdvectiveCFL(Δt);

julia&gt; model.velocities.u .= π;

julia&gt; cfl(model)
6.283185307179586</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Diagnostics/cfl.jl#L26-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Diagnostics.DiffusiveCFL-Tuple{Any}"><a class="docstring-binding" href="#Oceananigans.Diagnostics.DiffusiveCFL-Tuple{Any}"><code>Oceananigans.Diagnostics.DiffusiveCFL</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">DiffusiveCFL(Δt)</code></pre><p>Returns an object for computing the diffusive Courant-Freidrichs-Lewy (CFL) number associated with time step <code>Δt</code> or <code>TimeStepWizard</code> and the time scale for diffusion across a cell associated with <code>model.closure</code>.  The diffusive CFL, e.g., for viscosity is <span>$ν Δt / Δx²$</span>.</p><p>The maximum diffusive CFL number among viscosity and all tracer diffusivities is returned.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; model = NonhydrostaticModel(grid = RectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1)),
                                   closure = ScalarDiffusivity(; ν = 1e-2));

julia&gt; Δt = 0.1;

julia&gt; dcfl = DiffusiveCFL(Δt);

julia&gt; dcfl(model)
0.256</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Diagnostics/cfl.jl#L52-L78">source</a></section></details></article><h2 id="Distributed"><a class="docs-heading-anchor" href="#Distributed">Distributed</a><a id="Distributed-1"></a><a class="docs-heading-anchor-permalink" href="#Distributed" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Oceananigans.DistributedComputations.Distributed"><a class="docstring-binding" href="#Oceananigans.DistributedComputations.Distributed"><code>Oceananigans.DistributedComputations.Distributed</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Distributed(child_architecture = CPU();
            partition = Partition(MPI.Comm_size(communicator)),
            devices = nothing,
            communicator = MPI.COMM_WORLD,
            synchronized_communication = false)</code></pre><p>Return a distributed architecture that uses MPI for communications.</p><p><strong>Positional arguments</strong></p><ul><li><code>child_architecture</code>: Specifies whether the computation is performed on CPUs or GPUs.                       Default: <code>CPU()</code>.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>partition</code>: A <a href="#Oceananigans.DistributedComputations.Partition-Tuple{Any}"><code>Partition</code></a> specifying the total processors in the <code>x</code>, <code>y</code>, and <code>z</code> direction.              Note that support for distributed <code>z</code> direction is  limited; we strongly suggest              using partition with <code>z = 1</code> kwarg.</p></li><li><p><code>devices</code>: <code>GPU</code> device linked to local rank. The GPU will be assigned based on the            local node rank as such <code>devices[node_rank]</code>. Make sure to run <code>--ntasks-per-node</code> &lt;= <code>--gres=gpu</code>.            If <code>nothing</code>, the devices will be assigned automatically based on the available resources.            This argument is irrelevant if <code>child_architecture = CPU()</code>.</p></li><li><p><code>communicator</code>: the MPI communicator that orchestrates data transfer between nodes.                 Default: <code>MPI.COMM_WORLD</code>.</p></li><li><p><code>synchronized_communication</code>: This keyword argument can be used to control downstream code behavior.                               If <code>true</code>, then downstream code may use this tag to toggle between an algorithm                               that permits communication between nodes &quot;asynchronously&quot; with other computations,                               and an alternative serial algorithm in which communication and computation are                               &quot;synchronous&quot; (that is, performed one after the other).                               Default: <code>false</code>, specifying the use of asynchronous algorithms where supported,                               which may result in faster time-to-solution.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/DistributedComputations/distributed_architectures.jl#L204-L241">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.DistributedComputations.DistributedFFTBasedPoissonSolver"><a class="docstring-binding" href="#Oceananigans.DistributedComputations.DistributedFFTBasedPoissonSolver"><code>Oceananigans.DistributedComputations.DistributedFFTBasedPoissonSolver</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DistributedFFTBasedPoissonSolver(global_grid, local_grid)</code></pre><p>Return an FFT-based solver for the Poisson equation,</p><p class="math-container">\[∇²φ = b\]</p><p>for <code>Distributed</code> architectures.</p><p><strong>Supported configurations</strong></p><p>In the following, <code>Nx</code>, <code>Ny</code>, and <code>Nz</code> are the number of grid points of the <strong>global</strong> grid, in the <code>x</code>, <code>y</code>, and <code>z</code> directions, while <code>Rx</code>, <code>Ry</code>, and <code>Rz</code> are the number of ranks in the <code>x</code>, <code>y</code>, and <code>z</code> directions, respectively. Furthermore, &#39;pencil&#39; decomposition refers to a domain decomposed in two different directions (i.e., with <code>Rx != 1</code> and <code>Ry != 1</code>), while &#39;slab&#39; decomposition refers to a domain decomposed only in one direction, (i.e., with either <code>Rx == 1</code> or <code>Ry == 1</code>). Additionally, <code>storage</code> indicates the <code>TransposableField</code> used for storing intermediate results; see <a href="@ref"><code>TransposableField</code></a>.</p><ol><li>Three dimensional grids with pencil decompositions in <span>$(x, y)$</span> such the:</li></ol><p>the <code>z</code> direction is local, <code>Ny ≥ Rx</code> and <code>Ny % Rx = 0</code>, and <code>Nz ≥ Ry</code> and <code>Nz % Ry = 0</code>.</p><ol><li>Two dimensional grids decomposed in <span>$x$</span> where <code>Ny ≥ Rx</code> and <code>Ny % Rx = 0</code>.</li></ol><div class="admonition is-warning" id="Unsupported-decompositions-5ba3d1534f67a91"><header class="admonition-header">Unsupported decompositions<a class="admonition-anchor" href="#Unsupported-decompositions-5ba3d1534f67a91" title="Permalink"></a></header><div class="admonition-body"><p><em>Any</em> configuration decomposed in <span>$z$</span> direction is <em>not</em> supported. Furthermore, any <span>$(x, y)$</span> decompositions other than the configurations mentioned above are also <em>not</em> supported.</p></div></div><p><strong>Algorithm for pencil decompositions</strong></p><p>For pencil decompositions (useful for three-dimensional problems), there are three forward transforms, three backward transforms, and four transpositions that require MPI communication. In the algorithm below, the first dimension is always the local dimension. In our implementation we require <code>Nz ≥ Ry</code> and <code>Nx ≥ Ry</code> with the additional constraint that <code>Nz % Ry = 0</code> and <code>Ny % Rx = 0</code>.</p><ol><li><code>storage.zfield</code>, partitioned over <span>$(x, y)$</span> is initialized with the <code>rhs</code> that is <span>$b$</span>.</li><li>Transform along <span>$z$</span>.</li></ol><p>3  Transpose <code>storage.zfield</code> + communicate to <code>storage.yfield</code> partitioned into <code>(Rx, Ry)</code> processes in <span>$(x, z)$</span>.</p><ol><li>Transform along <span>$y$</span>.</li><li>Transpose <code>storage.yfield</code> + communicate to <code>storage.xfield</code> partitioned into <code>(Rx, Ry)</code> processes in <span>$(y, z)$</span>.</li><li>Transform in <span>$x$</span>.</li></ol><p>At this point the three in-place forward transforms are complete, and we solve the Poisson equation by updating <code>storage.xfield</code>. Then the process is reversed to obtain <code>storage.zfield</code> in physical space partitioned over <span>$(x, y)$</span>.</p><p><strong>Algorithm for stencil decompositions</strong></p><p>The stecil decomposition algorithm works in the same manner as the pencil decompostion described above while skipping the transposes that are not required. For example if the domain is decomposed in <span>$x$</span>, step 3 in the above algorithm is skipped (and the associated transposition step in the bakward transform)</p><p><strong>Restrictions</strong></p><ol><li><p>Pencil decomopositions:</p><ul><li><code>Ny ≥ Rx</code> and <code>Ny % Rx = 0</code></li><li><code>Nz ≥ Ry</code> and <code>Nz % Ry = 0</code></li><li>If the <span>$z$</span> direction is <code>Periodic</code>, also the <span>$y$</span> and the <span>$x$</span> directions must be <code>Periodic</code></li><li>If the <span>$y$</span> direction is <code>Periodic</code>, also the <span>$x$</span> direction must be <code>Periodic</code></li></ul></li><li><p>Stencil decomposition:</p><ul><li>same as for pencil decompositions with <code>Rx</code> (or <code>Ry</code>) equal to one</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/DistributedComputations/distributed_fft_based_poisson_solver.jl#L22-L91">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.DistributedComputations.Equal"><a class="docstring-binding" href="#Oceananigans.DistributedComputations.Equal"><code>Oceananigans.DistributedComputations.Equal</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Equal()</code></pre><p>Return a type that partitions a direction equally among remaining processes.</p><p><code>Equal()</code> can be used for only one direction. Other directions must either be unspecified, or specifically defined by <code>Int</code>, <code>Fractional</code>, or <code>Sizes</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/DistributedComputations/distributed_architectures.jl#L99-L106">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.DistributedComputations.Fractional-Tuple"><a class="docstring-binding" href="#Oceananigans.DistributedComputations.Fractional-Tuple"><code>Oceananigans.DistributedComputations.Fractional</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Fractional(ϵ₁, ϵ₂, ..., ϵₙ)</code></pre><p>Return a type that partitions a direction unequally. The total work is <code>W = sum(ϵᵢ)</code>, and each process is then allocated <code>ϵᵢ / W</code> of the domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/DistributedComputations/distributed_architectures.jl#L117-L122">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.DistributedComputations.Partition-Tuple{Any}"><a class="docstring-binding" href="#Oceananigans.DistributedComputations.Partition-Tuple{Any}"><code>Oceananigans.DistributedComputations.Partition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Partition(; x = 1, y = 1, z = 1)</code></pre><p>Return <code>Partition</code> representing the division of a domain in the <code>x</code> (first), <code>y</code> (second) and <code>z</code> (third) dimension</p><p><strong>Keyword arguments:</strong></p><ul><li><code>x</code>: partitioning of the first dimension</li><li><code>y</code>: partitioning of the second dimension</li><li><code>z</code>: partitioning of the third dimension</li></ul><p>if supplied as positional arguments <code>x</code> will be the first argument, <code>y</code> the second and <code>z</code> the third</p><p><code>x</code>, <code>y</code> and <code>z</code> can be:</p><ul><li><code>x::Int</code>: allocate <code>x</code> processors to the first dimension</li><li><code>Equal()</code>: divide the domain in <code>x</code> equally among the remaining processes (not supported for multiple directions)</li><li><code>Fractional(ϵ₁, ϵ₂, ..., ϵₙ):</code> divide the domain unequally among <code>N</code> processes. The total work is <code>W = sum(ϵᵢ)</code>,                                and each process is then allocated <code>ϵᵢ / W</code> of the domain.</li><li><code>Sizes(n₁, n₂, ..., nₙ)</code>: divide the domain unequally. The total work is <code>W = sum(nᵢ)</code>,                           and each process is then allocated <code>nᵢ</code>.</li></ul><p><strong>Examples:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans; using Oceananigans.DistributedComputations

julia&gt; Partition(1, 4)
Partition across 4 = 1×4×1 ranks:
└── y: 4

julia&gt; Partition(x = Fractional(1, 2, 3, 4))
Partition across 4 = 4×1×1 ranks:
└── x: Fractional(0.1, 0.2, 0.3, 0.4)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/DistributedComputations/distributed_architectures.jl#L20-L59">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.DistributedComputations.partition-Tuple{AbstractArray, Oceananigans.DistributedComputations.Distributed, Any}"><a class="docstring-binding" href="#Oceananigans.DistributedComputations.partition-Tuple{AbstractArray, Oceananigans.DistributedComputations.Distributed, Any}"><code>Oceananigans.DistributedComputations.partition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">partition(A, arch, local_size)</code></pre><p>Partition the globally-sized <code>A</code> into local arrays with <code>local_size</code> on <code>arch</code>itecture.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/DistributedComputations/partition_assemble.jl#L136-L140">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.DistributedComputations.partition-Tuple{Any, Field}"><a class="docstring-binding" href="#Oceananigans.DistributedComputations.partition-Tuple{Any, Field}"><code>Oceananigans.DistributedComputations.partition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">partition(A, b)</code></pre><p>Partition the globally-sized <code>A</code> into local arrays with the same size as <code>b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/DistributedComputations/partition_assemble.jl#L126-L130">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.DistributedComputations.reconstruct_global_grid-Tuple{RectilinearGrid{FT, TX, TY, TZ, CZ, FX, FY, VX, VY, &lt;:Oceananigans.DistributedComputations.Distributed} where {FT, TX, TY, TZ, CZ, FX, FY, VX, VY}}"><a class="docstring-binding" href="#Oceananigans.DistributedComputations.reconstruct_global_grid-Tuple{RectilinearGrid{FT, TX, TY, TZ, CZ, FX, FY, VX, VY, &lt;:Oceananigans.DistributedComputations.Distributed} where {FT, TX, TY, TZ, CZ, FX, FY, VX, VY}}"><code>Oceananigans.DistributedComputations.reconstruct_global_grid</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">reconstruct_global_grid(grid::DistributedGrid)</code></pre><p>Return the global grid on <code>child_architecture(grid)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/DistributedComputations/distributed_grids.jl#L189-L193">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.DistributedComputations.@distribute-Tuple{Any, Any}"><a class="docstring-binding" href="#Oceananigans.DistributedComputations.@distribute-Tuple{Any, Any}"><code>Oceananigans.DistributedComputations.@distribute</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@distribute communicator for i in iterable
    ...
end</code></pre><p>Distribute a <code>for</code> loop among different ranks in <code>communicator</code>. If <code>communicator</code> is not provided, <code>MPI.COMM_WORLD</code> is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/DistributedComputations/distributed_macros.jl#L77-L84">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.DistributedComputations.@handshake-Tuple{Any, Any}"><a class="docstring-binding" href="#Oceananigans.DistributedComputations.@handshake-Tuple{Any, Any}"><code>Oceananigans.DistributedComputations.@handshake</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@handshake communicator exp...</code></pre><p>Perform <code>exp</code> on all ranks in <code>communicator</code>, but only one rank at a time, that is ranks <code>r2 &gt; r1</code> wait for rank <code>r1</code> to finish before executing <code>exp</code>. If <code>communicator</code> is not provided, <code>MPI.COMM_WORLD</code> is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/DistributedComputations/distributed_macros.jl#L126-L132">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.DistributedComputations.@onrank-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#Oceananigans.DistributedComputations.@onrank-Tuple{Any, Any, Any}"><code>Oceananigans.DistributedComputations.@onrank</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@onrank communicator rank exp...</code></pre><p>Perform <code>exp</code> only on rank <code>rank</code> (0-based index) in <code>communicator</code>. Other ranks will wait for rank <code>rank</code> to finish before continuing. The expression is run anyways if MPI in not initialized. If <code>communicator</code> is not provided, <code>MPI.COMM_WORLD</code> is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/DistributedComputations/distributed_macros.jl#L45-L52">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.DistributedComputations.@root-Tuple{Any, Any}"><a class="docstring-binding" href="#Oceananigans.DistributedComputations.@root-Tuple{Any, Any}"><code>Oceananigans.DistributedComputations.@root</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@root communicator exp...</code></pre><p>Perform <code>exp</code> only on rank 0 in communicator, otherwise known as the &quot;root&quot; rank. Other ranks will wait for the root rank to finish before continuing. If <code>communicator</code> is not provided, <code>MPI.COMM_WORLD</code> is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/DistributedComputations/distributed_macros.jl#L16-L22">source</a></section></details></article><h2 id="Fields"><a class="docs-heading-anchor" href="#Fields">Fields</a><a id="Fields-1"></a><a class="docs-heading-anchor-permalink" href="#Fields" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Oceananigans.Fields.AbstractField"><a class="docstring-binding" href="#Oceananigans.Fields.AbstractField"><code>Oceananigans.Fields.AbstractField</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractField{LX, LY, LZ, G, T, N}</code></pre><p>Abstract supertype for fields located at <code>(LX, LY, LZ)</code> and defined on a grid <code>G</code> with eltype <code>T</code> and <code>N</code> dimensions.</p><p>Note: we need the parameter <code>T</code> to subtype AbstractArray.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Fields/abstract_field.jl#L17-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Fields.Accumulation-Tuple{Any, Any}"><a class="docstring-binding" href="#Oceananigans.Fields.Accumulation-Tuple{Any, Any}"><code>Oceananigans.Fields.Accumulation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Accumulation(accumulate!, operand; dims)</code></pre><p>Return a <code>Accumulation</code> of <code>operand</code> with <code>accumulate!</code>, where <code>accumulate!</code> can be called with</p><pre><code class="language-julia hljs">accumulate!(field, operand; dims)</code></pre><p>to accumulate <code>operand</code> along <code>dims</code> and store in <code>field</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Oceananigans

Nx, Ny, Nz = 3, 3, 3
grid = RectilinearGrid(size=(Nx, Ny, Nz), x=(0, 1), y=(0, 1), z=(0, 1),
                       topology=(Periodic, Periodic, Periodic))

c = CenterField(grid)
set!(c, (x, y, z) -&gt; x + y + z)
cumsum_c² = Field(Accumulation(cumsum!, c^2, dims=3))
cumsum_c²[1:Nx, 1:Ny, 1:Nz]

# output
3×3×3 Array{Float64, 3}:
[:, :, 1] =
 0.25      0.694444  1.36111
 0.694444  1.36111   2.25
 1.36111   2.25      3.36111

[:, :, 2] =
 0.944444  2.05556  3.61111
 2.05556   3.61111  5.61111
 3.61111   5.61111  8.05556

[:, :, 3] =
 2.30556   4.30556   6.97222
 4.30556   6.97222  10.3056
 6.97222  10.3056   14.3056</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Fields/scans.jl#L158-L201">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Fields.Field-Union{Tuple{Oceananigans.Grids.AbstractGrid}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Oceananigans.Grids.AbstractGrid, DataType}} where {LX, LY, LZ}"><a class="docstring-binding" href="#Oceananigans.Fields.Field-Union{Tuple{Oceananigans.Grids.AbstractGrid}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Oceananigans.Grids.AbstractGrid, DataType}} where {LX, LY, LZ}"><code>Oceananigans.Fields.Field</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Field{LX, LY, LZ}(grid::AbstractGrid,
                  T::DataType=eltype(grid); kw...) where {LX, LY, LZ}</code></pre><p>Construct a <code>Field</code> on <code>grid</code> with data type <code>T</code> at the location <code>(LX, LY, LZ)</code>. Each of <code>(LX, LY, LZ)</code> is either <code>Center</code> or <code>Face</code> and determines the field&#39;s location in <code>(x, y, z)</code> respectively.</p><p><strong>Keyword arguments</strong></p><ul><li><code>data :: OffsetArray</code>: An offset array with the fields data. If nothing is provided the field is filled with zeros.</li><li><code>boundary_conditions</code>: If nothing is provided, then field is created using the default boundary conditions via <a href="#Oceananigans.BoundaryConditions.FieldBoundaryConditions"><code>FieldBoundaryConditions</code></a>.</li><li><code>indices</code>: Used to prescribe where a reduced field lives on. For example, at which <code>k</code> index does a two-dimensional <span>$x$</span>-<span>$y$</span> field lives on. Default: <code>(:, :, :)</code>.</li></ul><p><strong>Example</strong></p><p>A field at location <code>(Face, Face, Center)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = RectilinearGrid(size=(2, 3, 4), extent=(1, 1, 1));

julia&gt; ω = Field{Face, Face, Center}(grid)
2×3×4 Field{Face, Face, Center} on RectilinearGrid on CPU
├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 2×3×3 halo
├── boundary conditions: FieldBoundaryConditions
│   └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: Nothing
└── data: 6×9×10 OffsetArray(::Array{Float64, 3}, -1:4, -2:6, -2:7) with eltype Float64 with indices -1:4×-2:6×-2:7
    └── max=0.0, min=0.0, mean=0.0</code></pre><p>Now, using <code>indices</code> we can create a two dimensional <span>$x$</span>-<span>$y$</span> field at location <code>(Face, Face, Center)</code> to compute, e.g., the vertical vorticity <span>$∂v/∂x - ∂u/∂y$</span> at the fluid&#39;s surface <span>$z = 0$</span>, which for <code>Center</code> corresponds to <code>k = Nz</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; u = XFaceField(grid); v = YFaceField(grid);

julia&gt; ωₛ = Field(∂x(v) - ∂y(u), indices=(:, :, grid.Nz))
2×3×1 Field{Face, Face, Center} on RectilinearGrid on CPU
├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 2×3×3 halo
├── boundary conditions: FieldBoundaryConditions
│   └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: Nothing
├── indices: (:, :, 4:4)
├── operand: BinaryOperation at (Face, Face, Center)
├── status: time=0.0
└── data: 6×9×1 OffsetArray(::Array{Float64, 3}, -1:4, -2:6, 4:4) with eltype Float64 with indices -1:4×-2:6×4:4
    └── max=0.0, min=0.0, mean=0.0

julia&gt; compute!(ωₛ)
2×3×1 Field{Face, Face, Center} on RectilinearGrid on CPU
├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 2×3×3 halo
├── boundary conditions: FieldBoundaryConditions
│   └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: Nothing
├── indices: (:, :, 4:4)
├── operand: BinaryOperation at (Face, Face, Center)
├── status: time=0.0
└── data: 6×9×1 OffsetArray(::Array{Float64, 3}, -1:4, -2:6, 4:4) with eltype Float64 with indices -1:4×-2:6×4:4
    └── max=0.0, min=0.0, mean=0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Fields/field.jl#L114-L180">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Fields.Reduction-Tuple{Any, Any}"><a class="docstring-binding" href="#Oceananigans.Fields.Reduction-Tuple{Any, Any}"><code>Oceananigans.Fields.Reduction</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Reduction(reduce!, operand; dims)</code></pre><p>Return a <code>Reduction</code> of <code>operand</code> with <code>reduce!</code>, where <code>reduce!</code> can be called with</p><pre><code class="language-julia hljs">reduce!(field, operand)</code></pre><p>to reduce <code>operand</code> along <code>dims</code> and store in <code>field</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Oceananigans

Nx, Ny, Nz = 3, 3, 3
grid = RectilinearGrid(size=(Nx, Ny, Nz), x=(0, 1), y=(0, 1), z=(0, 1),
                       topology=(Periodic, Periodic, Periodic))

c = CenterField(grid)
set!(c, (x, y, z) -&gt; x + y + z)
max_c² = Field(Reduction(maximum!, c^2, dims=3))
max_c²[1:Nx, 1:Ny]

# output
3×3 Matrix{Float64}:
 1.36111  2.25     3.36111
 2.25     3.36111  4.69444
 3.36111  4.69444  6.25</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Fields/scans.jl#L118-L150">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Fields.CenterField"><a class="docstring-binding" href="#Oceananigans.Fields.CenterField"><code>Oceananigans.Fields.CenterField</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">CenterField(grid, T=eltype(grid); kw...)</code></pre><p>Return a <code>Field{Center, Center, Center}</code> on <code>grid</code>. Additional keyword arguments are passed to the <code>Field</code> constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Fields/field.jl#L203-L208">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Fields.TracerFields-Tuple{@NamedTuple{}, Any, Any}"><a class="docstring-binding" href="#Oceananigans.Fields.TracerFields-Tuple{@NamedTuple{}, Any, Any}"><code>Oceananigans.Fields.TracerFields</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Shortcut constructor for empty tracer fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Fields/field_tuples.jl#L173">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Fields.TracerFields-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#Oceananigans.Fields.TracerFields-Tuple{Any, Any, Any}"><code>Oceananigans.Fields.TracerFields</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">TracerFields(tracer_names, grid, user_bcs)</code></pre><p>Return a <code>NamedTuple</code> with tracer fields specified by <code>tracer_names</code> initialized as <code>CenterField</code>s on <code>grid</code>. Boundary conditions <code>user_bcs</code> may be specified via a named tuple of <code>FieldBoundaryCondition</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Fields/field_tuples.jl#L147-L153">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Fields.TracerFields-Tuple{Any, Any}"><a class="docstring-binding" href="#Oceananigans.Fields.TracerFields-Tuple{Any, Any}"><code>Oceananigans.Fields.TracerFields</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">TracerFields(tracer_names, grid; kwargs...)</code></pre><p>Return a <code>NamedTuple</code> with tracer fields specified by <code>tracer_names</code> initialized as <code>CenterField</code>s on <code>grid</code>. Fields may be passed via optional keyword arguments <code>kwargs</code> for each field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Fields/field_tuples.jl#L160-L166">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Fields.TracerFields-Tuple{NamedTuple, Any, Any}"><a class="docstring-binding" href="#Oceananigans.Fields.TracerFields-Tuple{NamedTuple, Any, Any}"><code>Oceananigans.Fields.TracerFields</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">TracerFields(proposed_tracers::NamedTuple, grid, bcs)</code></pre><p>Return a <code>NamedTuple</code> of tracers, overwriting boundary conditions in <code>proposed_tracers</code> with corresponding fields in the <code>NamedTuple</code> <code>bcs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Fields/field_tuples.jl#L199-L204">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Fields.VelocityFields"><a class="docstring-binding" href="#Oceananigans.Fields.VelocityFields"><code>Oceananigans.Fields.VelocityFields</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">VelocityFields(grid, user_bcs = NamedTuple())</code></pre><p>Return a <code>NamedTuple</code> with fields <code>u</code>, <code>v</code>, <code>w</code> initialized on <code>grid</code>. Boundary conditions <code>bcs</code> may be specified via a named tuple of <code>FieldBoundaryCondition</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Fields/field_tuples.jl#L117-L123">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Fields.VelocityFields-Tuple{NamedTuple{(:u, :v, :w)}, Any, Any}"><a class="docstring-binding" href="#Oceananigans.Fields.VelocityFields-Tuple{NamedTuple{(:u, :v, :w)}, Any, Any}"><code>Oceananigans.Fields.VelocityFields</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">VelocityFields(proposed_velocities::NamedTuple{(:u, :v, :w)}, grid, bcs)</code></pre><p>Return a <code>NamedTuple</code> of velocity fields, overwriting boundary conditions in <code>proposed_velocities</code> with corresponding fields in the <code>NamedTuple</code> <code>bcs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Fields/field_tuples.jl#L182-L187">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Fields.XFaceField"><a class="docstring-binding" href="#Oceananigans.Fields.XFaceField"><code>Oceananigans.Fields.XFaceField</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">XFaceField(grid, T=eltype(grid); kw...)</code></pre><p>Return a <code>Field{Face, Center, Center}</code> on <code>grid</code>. Additional keyword arguments are passed to the <code>Field</code> constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Fields/field.jl#L211-L216">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Fields.YFaceField"><a class="docstring-binding" href="#Oceananigans.Fields.YFaceField"><code>Oceananigans.Fields.YFaceField</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">YFaceField(grid, T=eltype(grid); kw...)</code></pre><p>Return a <code>Field{Center, Face, Center}</code> on <code>grid</code>. Additional keyword arguments are passed to the <code>Field</code> constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Fields/field.jl#L219-L224">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Fields.ZFaceField"><a class="docstring-binding" href="#Oceananigans.Fields.ZFaceField"><code>Oceananigans.Fields.ZFaceField</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ZFaceField(grid, T=eltype(grid); kw...)</code></pre><p>Return a <code>Field{Center, Center, Face}</code> on <code>grid</code>. Additional keyword arguments are passed to the <code>Field</code> constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Fields/field.jl#L227-L232">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Fields.compute!"><a class="docstring-binding" href="#Oceananigans.Fields.compute!"><code>Oceananigans.Fields.compute!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">compute!(field)</code></pre><p>Computes <code>field.data</code> from <code>field.operand</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Fields/field.jl#L480-L484">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Fields.field-Tuple{Any, AbstractArray, Any}"><a class="docstring-binding" href="#Oceananigans.Fields.field-Tuple{Any, AbstractArray, Any}"><code>Oceananigans.Fields.field</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">field(loc, a, grid)</code></pre><p>Build a field from array <code>a</code> at <code>loc</code> and on <code>grid</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Fields/Fields.jl#L41-L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Fields.interior-Tuple{Field}"><a class="docstring-binding" href="#Oceananigans.Fields.interior-Tuple{Field}"><code>Oceananigans.Fields.interior</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">interior(f::Field)</code></pre><p>Return a view of <code>f</code> that excludes halo points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Fields/field.jl#L420-L424">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Fields.interpolate-NTuple{4, Any}"><a class="docstring-binding" href="#Oceananigans.Fields.interpolate-NTuple{4, Any}"><code>Oceananigans.Fields.interpolate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">interpolate(at_node, from_field, from_loc, from_grid)</code></pre><p>Interpolate <code>from_field</code>, <code>at_node</code>, on <code>from_grid</code> and at <code>from_loc</code>ation, where <code>at_node</code> is a tuple of coordinates and and <code>from_loc = (ℓx, ℓy, ℓz)</code>.</p><p>Note that this is a lower-level <code>interpolate</code> method defined for use in CPU/GPU kernels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Fields/interpolate.jl#L263-L270">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Fields.interpolate-Tuple{Any, Any}"><a class="docstring-binding" href="#Oceananigans.Fields.interpolate-Tuple{Any, Any}"><code>Oceananigans.Fields.interpolate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">interpolate(to_node, from_field)</code></pre><p>Interpolate <code>field</code> to the physical point <code>(x, y, z)</code> using trilinear interpolation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Fields/interpolate.jl#L337-L341">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Fields.regrid!-Tuple{Any, Any}"><a class="docstring-binding" href="#Oceananigans.Fields.regrid!-Tuple{Any, Any}"><code>Oceananigans.Fields.regrid!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">regrid!(dst_field, src_field)</code></pre><p>Regrid <code>src_field</code> onto the grid of <code>dst_field</code>.</p><p><strong>Example</strong></p><p>Generate a tracer field on a vertically stretched grid and regrid it on a regular grid.</p><pre><code class="language-julia hljs">using Oceananigans

Nz, Lz = 2, 1.0
topology = (Flat, Flat, Bounded)

input_grid = RectilinearGrid(size=Nz, z = [0, Lz/3, Lz], topology=topology, halo=1)
input_field = CenterField(input_grid)
input_field[1, 1, 1:Nz] = [2, 3]

output_grid = RectilinearGrid(size=Nz, z=(0, Lz), topology=topology, halo=1)
output_field = CenterField(output_grid)

regrid!(output_field, input_field)

output_field[1, 1, :]

# output
4-element OffsetArray(::Vector{Float64}, 0:3) with eltype Float64 with indices 0:3:
 0.0
 2.333333333333333
 3.0
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Fields/regridding_fields.jl#L13-L47">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.location-Tuple{Any}"><a class="docstring-binding" href="#Oceananigans.location-Tuple{Any}"><code>Oceananigans.location</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Return the location <code>(LX, LY, LZ)</code> of an <code>AbstractField{LX, LY, LZ}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Fields/Fields.jl#L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Fields.@compute-Tuple{Any}"><a class="docstring-binding" href="#Oceananigans.Fields.@compute-Tuple{Any}"><code>Oceananigans.Fields.@compute</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@compute(exprs...)</code></pre><p>Call <code>compute!</code> on fields after defining them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Fields/field.jl#L489-L493">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XESMF.Regridder"><a class="docstring-binding" href="#XESMF.Regridder"><code>XESMF.Regridder</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Regridder(src_coordinates::Dict{String, &lt;:AbstractArray},
          dst_coordinates::Dict{String, &lt;:AbstractArray};
          method=&quot;conservative&quot;, periodic=false)</code></pre><p>Return a Regridder from the xESMF Python package to regrid data from <code>src_coordinates</code> to <code>dst_coordinates</code> using the specified <code>method</code>.</p><p>The <code>src_coordinates</code> and <code>dst_coordinates</code> are dictionaries that contain information about the two grids.</p><p>xESMF exposes five different regridding algorithms from the ESMF library, specified with the <code>method</code> keyword argument:</p><ul><li><code>&quot;bilinear&quot;</code>: <code>ESMF.RegridMethod.BILINEAR</code></li><li><code>&quot;conservative&quot;</code>: <code>ESMF.RegridMethod.CONSERVE</code></li><li><code>&quot;conservative_normed&quot;</code>: <code>ESMF.RegridMethod.CONSERVE</code></li><li><code>&quot;patch&quot;</code>: <code>ESMF.RegridMethod.PATCH</code></li><li><code>&quot;nearest_s2d&quot;</code>: <code>ESMF.RegridMethod.NEAREST_STOD</code></li><li><code>&quot;nearest_d2s&quot;</code>: <code>ESMF.RegridMethod.NEAREST_DTOS</code></li></ul><p>where <code>conservative_normed</code> is just the conservative method with the normalization set to <code>ESMF.NormType.FRACAREA</code> instead of the default <code>norm_type = ESMF.NormType.DSTAREA</code>.</p><p>For more information, see the Python xESMF documentation at:</p><blockquote><p>https://xesmf.readthedocs.io/en/latest/notebooks/Compare_algorithms.html</p></blockquote></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NumericalEarth/XESMF.jl/blob/v0.1.6/src/XESMF.jl#L73-L100">source</a></section><section><div><pre><code class="language-julia hljs">Regridder(dst_field::AbstractField, src_field::AbstractField; method=&quot;conservative&quot;)</code></pre><p>Return a regridder from <code>src_field</code> to <code>dst_field</code> using the specified <code>method</code>. The regridder contains a sparse matrix with the regridding weights. The regridding weights are obtained via xESMF Python package. xESMF exposes five different regridding algorithms from the ESMF library, specified with the <code>method</code> keyword argument:</p><ul><li><code>&quot;bilinear&quot;</code>: <code>ESMF.RegridMethod.BILINEAR</code></li><li><code>&quot;conservative&quot;</code>: <code>ESMF.RegridMethod.CONSERVE</code></li><li><code>&quot;conservative_normed&quot;</code>: <code>ESMF.RegridMethod.CONSERVE</code></li><li><code>&quot;patch&quot;</code>: <code>ESMF.RegridMethod.PATCH</code></li><li><code>&quot;nearest_s2d&quot;</code>: <code>ESMF.RegridMethod.NEAREST_STOD</code></li><li><code>&quot;nearest_d2s&quot;</code>: <code>ESMF.RegridMethod.NEAREST_DTOS</code></li></ul><p>where <code>conservative_normed</code> is just the conservative method with the normalization set to <code>ESMF.NormType.FRACAREA</code> instead of the default <code>norm_type = ESMF.NormType.DSTAREA</code>.</p><p>For more information, see the Python xESMF documentation at:</p><blockquote><p>https://xesmf.readthedocs.io/en/latest/notebooks/Compare_algorithms.html</p></blockquote><p><strong>Example</strong></p><p>To create a regridder for two fields that live on different grids.</p><pre><code class="language- hljs">using Oceananigans
using XESMF

z = (-1, 0)
tg = TripolarGrid(; size=(180, 85, 1), z, southernmost_latitude = -80)
llg = LatitudeLongitudeGrid(; size=(170, 80, 1), z,
                            longitude=(0, 360), latitude=(-82, 90))

src_field = CenterField(tg)
dst_field = CenterField(llg)

regridder = XESMF.Regridder(dst_field, src_field, method=&quot;conservative&quot;)</code></pre><p>We can use the above regridder to regrid via <a href="#Oceananigans.Fields.regrid!"><code>regrid!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/ext/OceananigansXESMFExt.jl#L74-L118">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Fields.regrid!"><a class="docstring-binding" href="#Oceananigans.Fields.regrid!"><code>Oceananigans.Fields.regrid!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">regrid!(dst_field, src_field)</code></pre><p>Regrid <code>src_field</code> onto the grid of <code>dst_field</code>.</p><p><strong>Example</strong></p><p>Generate a tracer field on a vertically stretched grid and regrid it on a regular grid.</p><pre><code class="language-julia hljs">using Oceananigans

Nz, Lz = 2, 1.0
topology = (Flat, Flat, Bounded)

input_grid = RectilinearGrid(size=Nz, z = [0, Lz/3, Lz], topology=topology, halo=1)
input_field = CenterField(input_grid)
input_field[1, 1, 1:Nz] = [2, 3]

output_grid = RectilinearGrid(size=Nz, z=(0, Lz), topology=topology, halo=1)
output_field = CenterField(output_grid)

regrid!(output_field, input_field)

output_field[1, 1, :]

# output
4-element OffsetArray(::Vector{Float64}, 0:3) with eltype Float64 with indices 0:3:
 0.0
 2.333333333333333
 3.0
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Fields/regridding_fields.jl#L13-L47">source</a></section><section><div><pre><code class="language-julia hljs">regrid!(dst_field, regrider::XESMF.Regridder, src_field)</code></pre><p>Regrid <code>src_field</code> onto the grid of field <code>dst_field</code> using the regrider <code>r</code>.</p><p><strong>Example</strong></p><pre><code class="language- hljs">using Oceananigans
using XESMF

z = (-1, 0)

tg = TripolarGrid(; size=(360, 170, 1), z, southernmost_latitude = -80)

llg = LatitudeLongitudeGrid(; size=(360, 180, 1), z,
                            longitude=(0, 360), latitude=(-82, 90))

src_field = CenterField(tg)
dst_field = CenterField(llg)

λ₀, φ₀ = 150, 30   # degrees
width = 12         # degrees
set!(src_field, (λ, φ, z) -&gt; exp(-((λ - λ₀)^2 + (φ - φ₀)^2) / 2width^2))

regridder = XESMF.Regridder(dst_field, src_field, method=&quot;conservative&quot;)

regrid!(dst_field, regridder, src_field)

first(Field(Integral(dst_field, dims=(1, 2))))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/ext/OceananigansXESMFExt.jl#L154-L186">source</a></section></details></article><h2 id="Forcings"><a class="docs-heading-anchor" href="#Forcings">Forcings</a><a id="Forcings-1"></a><a class="docs-heading-anchor-permalink" href="#Forcings" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Oceananigans.Forcings.AdvectiveForcing-Tuple{}"><a class="docstring-binding" href="#Oceananigans.Forcings.AdvectiveForcing-Tuple{}"><code>Oceananigans.Forcings.AdvectiveForcing</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">AdvectiveForcing(u=ZeroField(), v=ZeroField(), w=ZeroField())</code></pre><p>Build a forcing term representing advection by the velocity field <code>u, v, w</code>.</p><p><strong>Example</strong></p><p><strong>Using a tracer field to model sinking particles</strong></p><pre><code class="language-julia hljs">using Oceananigans

# Physical parameters
gravitational_acceleration          = 9.81     # m s⁻²
ocean_density                       = 1026     # kg m⁻³
mean_particle_density               = 2000     # kg m⁻³
mean_particle_radius                = 1e-3     # m
ocean_molecular_kinematic_viscosity = 1.05e-6  # m² s⁻¹

# Terminal velocity of a sphere in viscous flow
Δb = gravitational_acceleration * (mean_particle_density - ocean_density) / ocean_density
ν = ocean_molecular_kinematic_viscosity
R = mean_particle_radius

w_Stokes = - 2/9 * Δb / ν * R^2 # m s⁻¹

settling = AdvectiveForcing(w=w_Stokes)

# output
AdvectiveForcing:
├── u: ZeroField{Int64}
├── v: ZeroField{Int64}
└── w: ConstantField(-1.97096)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Forcings/advective_forcing.jl#L14-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Forcings.ContinuousForcing"><a class="docstring-binding" href="#Oceananigans.Forcings.ContinuousForcing"><code>Oceananigans.Forcings.ContinuousForcing</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ContinuousForcing{LX, LY, LZ, P, F, D, I, ℑ}</code></pre><p>A callable object that implements a &quot;continuous form&quot; forcing function on a field at the location <code>LX, LY, LZ</code> with optional parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Forcings/continuous_forcing.jl#L8-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Forcings.ContinuousForcing-Tuple{Any}"><a class="docstring-binding" href="#Oceananigans.Forcings.ContinuousForcing-Tuple{Any}"><code>Oceananigans.Forcings.ContinuousForcing</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ContinuousForcing(func; parameters=nothing, field_dependencies=())</code></pre><p>Construct a &quot;continuous form&quot; forcing with optional <code>parameters</code> and optional <code>field_dependencies</code> on other fields in a model.</p><p>If neither <code>parameters</code> nor <code>field_dependencies</code> are provided, then <code>func</code> must be callable with the signature</p><pre><code class="language-julia hljs">func(X..., t)</code></pre><p>where, on a three-dimensional grid with no <code>Flat</code> directions, <code>X = (x, y, z)</code> is a 3-tuple containing the east-west, north-south, and vertical spatial coordinates, and <code>t</code> is time.</p><p>Dimensions with <code>Flat</code> topology are omitted from the coordinate tuple <code>X</code>. For example, on a grid with topology <code>(Periodic, Periodic, Flat)</code>, and with no <code>parameters</code> or <code>field_dependencies</code>, then <code>func</code> must be callable</p><pre><code class="language-julia hljs">func(x, y, t)</code></pre><p>where <code>x</code> and <code>y</code> are the east-west and north-south coordinates, respectively. For another example, on a grid with topology <code>(Flat, Flat, Bounded)</code> (e.g. a single column), and for a forcing with no <code>parameters</code> or <code>field_dependencies</code>, then <code>func</code> must be callable with</p><pre><code class="language-julia hljs">func(z, t)</code></pre><p>where <code>z</code> is the vertical coordinate.</p><p>If <code>field_dependencies</code> are provided, the signature of <code>func</code> must include them. For example, if <code>field_dependencies=(:u, :S)</code> (and <code>parameters</code> are <em>not</em> provided), and on a three-dimensional grid with no <code>Flat</code> dimensions, then <code>func</code> must be callable with the signature</p><pre><code class="language-julia hljs">func(x, y, z, t, u, S)</code></pre><p>where <code>u</code> is assumed to be the <code>u</code>-velocity component, and <code>S</code> is a tracer. Note that any field which does not have the name <code>u</code>, <code>v</code>, or <code>w</code> is assumed to be a tracer and must be present in <code>model.tracers</code>.</p><p>If <code>parameters</code> are provided, then the <em>last</em> argument to <code>func</code> must be <code>parameters</code>. For example, if <code>func</code> has no <code>field_dependencies</code> but does depend on <code>parameters</code>, then on a three-dimensional grid it must be callable with the signature</p><pre><code class="language-julia hljs">func(x, y, z, t, parameters)</code></pre><p>With <code>field_dependencies=(:u, :v, :w, :c)</code> and <code>parameters</code> and on a three-dimensional grid, then <code>func</code> must be callable with the signature</p><pre><code class="language-julia hljs">func(x, y, z, t, u, v, w, c, parameters)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Forcings/continuous_forcing.jl#L47-L108">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Forcings.DiscreteForcing"><a class="docstring-binding" href="#Oceananigans.Forcings.DiscreteForcing"><code>Oceananigans.Forcings.DiscreteForcing</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct DiscreteForcing{P, F}</code></pre><p>Wrapper for &quot;discrete form&quot; forcing functions with optional <code>parameters</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Forcings/discrete_forcing.jl#L5-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Forcings.DiscreteForcing-Tuple{Any}"><a class="docstring-binding" href="#Oceananigans.Forcings.DiscreteForcing-Tuple{Any}"><code>Oceananigans.Forcings.DiscreteForcing</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">DiscreteForcing(func; parameters=nothing)</code></pre><p>Construct a &quot;discrete form&quot; forcing function with optional parameters. The forcing function is applied at grid point <code>i, j, k</code>.</p><p>When <code>parameters</code> are not specified, <code>func</code> must be callable with the signature</p><pre><code class="language-julia hljs">func(i, j, k, grid, clock, model_fields)</code></pre><p>where <code>grid</code> is <code>model.grid</code>, <code>clock.time</code> is the current simulation time and <code>clock.iteration</code> is the current model iteration, and <code>model_fields</code> is a <code>NamedTuple</code> with <code>u, v, w</code> and the fields in <code>model.tracers</code>.</p><p><em>Note</em> that the index <code>end</code> does <em>not</em> access the final physical grid point of a model field in any direction. The final grid point must be explicitly specified, as in <code>model_fields.u[i, j, grid.Nz]</code>.</p><p>When <code>parameters</code> <em>is</em> specified, <code>func</code> must be callable with the signature.</p><pre><code class="language-julia hljs">func(i, j, k, grid, clock, model_fields, parameters)</code></pre><p>Above, <code>parameters</code> is, in principle, arbitrary. Note, however, that GPU compilation can place constraints on <code>typeof(parameters)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Forcings/discrete_forcing.jl#L15-L43">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Forcings.GaussianMask"><a class="docstring-binding" href="#Oceananigans.Forcings.GaussianMask"><code>Oceananigans.Forcings.GaussianMask</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GaussianMask{D}(center, width)</code></pre><p>Callable object that returns a Gaussian masking function centered on <code>center</code>, with <code>width</code>, and varying along direction <code>D</code>, i.e.,</p><pre><code class="language-julia hljs">exp(-(D - center)^2 / (2 * width^2))</code></pre><p><strong>Example</strong></p><p>Create a Gaussian mask centered on <code>z=0</code> with width <code>1</code> meter.</p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; mask = GaussianMask{:z}(center=0, width=1)
GaussianMask{:z, Int64}(0, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Forcings/relaxation.jl#L117-L138">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Forcings.LinearTarget"><a class="docstring-binding" href="#Oceananigans.Forcings.LinearTarget"><code>Oceananigans.Forcings.LinearTarget</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LinearTarget{D}(intercept, gradient)</code></pre><p>Callable object that returns a Linear target function with <code>intercept</code> and <code>gradient</code>, and varying along direction <code>D</code>, i.e.,</p><pre><code class="language-julia hljs">intercept + D * gradient</code></pre><p><strong>Example</strong></p><p>Create a linear target function varying in <code>z</code>, equal to <code>0</code> at <code>z=0</code> and with gradient 10⁻⁶:</p><pre><code class="language-julia hljs">julia&gt; target = LinearTarget{:z}(intercept=0, gradient=1e-6)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Forcings/relaxation.jl#L221-L240">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Forcings.PiecewiseLinearMask"><a class="docstring-binding" href="#Oceananigans.Forcings.PiecewiseLinearMask"><code>Oceananigans.Forcings.PiecewiseLinearMask</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PiecewiseLinearMask{D}(center, width)</code></pre><p>Callable object that returns a piecewise linear masking function centered on <code>center</code>, with <code>width</code>, and varying along direction <code>D</code>. The mask is:</p><ul><li>0 when |D - center| &gt; width</li><li>1 when D = center</li><li>Linear interpolation between 0 and 1 when |D - center| ≤ width</li></ul><p><strong>Example</strong></p><p>Create a piecewise linear mask centered on <code>z=0</code> with width <code>1</code> meter.</p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; mask = PiecewiseLinearMask{:z}(center=0, width=1)
PiecewiseLinearMask{:z, Int64}(0, 1)

julia&gt; mask(0, 0, 0) == 1
true

julia&gt; mask(0, 0, 1) == mask(0, 0, -1) == 0
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Forcings/relaxation.jl#L161-L187">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Forcings.Relaxation"><a class="docstring-binding" href="#Oceananigans.Forcings.Relaxation"><code>Oceananigans.Forcings.Relaxation</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct Relaxation{R, M, T}</code></pre><p>Callable object for restoring fields to a <code>target</code> at some <code>rate</code> and within a <code>mask</code>ed region in <code>x, y, z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Forcings/relaxation.jl#L11-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Forcings.Relaxation-Tuple{}"><a class="docstring-binding" href="#Oceananigans.Forcings.Relaxation-Tuple{}"><code>Oceananigans.Forcings.Relaxation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Relaxation(; rate, mask=onefunction, target=zerofunction)</code></pre><p>Returns a <code>Forcing</code> that restores a field to <code>target(X..., t)</code> at the specified <code>rate</code>, in the region <code>mask(X...)</code>.</p><p>The functions <code>onefunction</code> and <code>zerofunction</code> always return 1 and 0, respectively. Thus the default <code>mask</code> leaves the whole domain uncovered, and the default <code>target</code> is zero.</p><p><strong>Example</strong></p><ul><li>Restore a field to zero on a timescale of &quot;3600&quot; (equal to one hour if the time units of the simulation are seconds).</li></ul><pre><code class="language-julia hljs">using Oceananigans

damping = Relaxation(rate = 1/3600)

# output
Relaxation{Float64, typeof(Oceananigans.Forcings.onefunction), typeof(Oceananigans.Forcings.zerofunction)}
├── rate: 0.0002777777777777778
├── mask: 1
└── target: 0</code></pre><ul><li>Restore a field to a linear z-gradient within the bottom 1/4 of a domain on a timescale of &quot;60&quot; (equal to one minute if the time units of the simulation are seconds).</li></ul><pre><code class="language-julia hljs">dTdz = 0.001 # ⁰C m⁻¹, temperature gradient

T₀ = 20 # ⁰C, surface temperature at z=0

Lz = 100 # m, depth of domain

bottom_sponge_layer = Relaxation(; rate = 1/60,
                                   target = LinearTarget{:z}(intercept=T₀, gradient=dTdz),
                                   mask = GaussianMask{:z}(center=-Lz, width=Lz/4))

# output
Relaxation{Float64, GaussianMask{:z, Float64}, LinearTarget{:z, Float64}}
├── rate: 0.016666666666666666
├── mask: exp(-(z + 100.0)^2 / (2 * 25.0^2))
└── target: 20.0 + 0.001 * z</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Forcings/relaxation.jl#L23-L71">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Forcings.Forcing-Tuple{AbstractArray}"><a class="docstring-binding" href="#Oceananigans.Forcings.Forcing-Tuple{AbstractArray}"><code>Oceananigans.Forcings.Forcing</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Forcing(array::AbstractArray)</code></pre><p>Return a <code>Forcing</code> by <code>array</code>, which can be added to the tendency of a model field.</p><p>Forcing is computed by calling <code>array[i, j, k]</code>, so <code>array</code> must be 3D with <code>size(grid)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Forcings/forcing.jl#L170-L176">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Forcings.Forcing-Tuple{Any}"><a class="docstring-binding" href="#Oceananigans.Forcings.Forcing-Tuple{Any}"><code>Oceananigans.Forcings.Forcing</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Forcing(func; parameters=nothing, field_dependencies=(), discrete_form=false)</code></pre><p>Return a <code>Forcing</code> <code>func</code>tion, which can be added to the tendency of a model field.</p><p>If <code>discrete_form=false</code> (the default), and neither <code>parameters</code> nor <code>field_dependencies</code> are provided, then <code>func</code> must be callable with the signature</p><pre><code class="language-julia hljs">func(x, y, z, t)</code></pre><p>where <code>x, y, z</code> are the east-west, north-south, and vertical spatial coordinates, and <code>t</code> is time. Note that this form is also default in the constructor for <code>NonhydrostaticModel</code>, so that <code>Forcing</code> is not needed.</p><p>If <code>discrete_form=false</code> (the default), and <code>field_dependencies</code> are provided, the signature of <code>func</code> must include them. For example, if <code>field_dependencies=(:u, :S)</code> (and <code>parameters</code> are <em>not</em> provided), then <code>func</code> must be callable with the signature</p><pre><code class="language-julia hljs">func(x, y, z, t, u, S)</code></pre><p>where <code>u</code> is assumed to be the <code>u</code>-velocity component, and <code>S</code> is a tracer. Note that any field which does not have the name <code>u</code>, <code>v</code>, or <code>w</code> is assumed to be a tracer and must be present in <code>model.tracers</code>.</p><p>If <code>discrete_form=false</code> (the default) and <code>parameters</code> are provided, then the <em>last</em> argument to <code>func</code> must be <code>parameters</code>. For example, if <code>func</code> has no <code>field_dependencies</code> but does depend on <code>parameters</code>, then it must be callable with the signature</p><pre><code class="language-julia hljs">func(x, y, z, t, parameters)</code></pre><p>The object <code>parameters</code> is arbitrary in principle, however GPU compilation can place constraints on <code>typeof(parameters)</code>.</p><p>With <code>field_dependencies=(:u, :v, :w, :c)</code> and <code>parameters</code>, then <code>func</code> must be callable with the signature</p><pre><code class="language-julia hljs">func(x, y, z, t, u, v, w, c, parameters)</code></pre><p>If <code>discrete_form=true</code> then <code>func</code> must be callable with the &quot;discrete form&quot;</p><pre><code class="language-julia hljs">func(i, j, k, grid, clock, model_fields)</code></pre><p>where <code>i, j, k</code> is the grid point at which the forcing is applied, <code>grid</code> is <code>model.grid</code>, <code>clock.time</code> is the current simulation time and <code>clock.iteration</code> is the current model iteration, and <code>model_fields</code> is a <code>NamedTuple</code> with <code>u, v, w</code>, the fields in <code>model.tracers</code>, and the fields in <code>model.closure_fields</code>, each of which is an <code>OffsetArray</code>s (or <code>NamedTuple</code>s of <code>OffsetArray</code>s depending on the turbulence closure) of field data.</p><p>When <code>discrete_form=true</code> and <code>parameters</code> <em>is</em> specified, <code>func</code> must be callable with the signature</p><pre><code class="language-julia hljs">func(i, j, k, grid, clock, model_fields, parameters)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Oceananigans

# Parameterized forcing
parameterized_func(x, y, z, t, p) = p.μ * exp(z / p.λ) * cos(p.ω * t)

v_forcing = Forcing(parameterized_func, parameters = (μ=42, λ=0.1, ω=π))

# output
ContinuousForcing{@NamedTuple{μ::Int64, λ::Float64, ω::Irrational{:π}}}
├── func: parameterized_func (generic function with 1 method)
├── parameters: (μ = 42, λ = 0.1, ω = π)
└── field dependencies: ()</code></pre><p>Note that because forcing locations are regularized within the <code>NonhydrostaticModel</code> constructor:</p><pre><code class="language-julia hljs">grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))
model = NonhydrostaticModel(grid=grid, forcing=(v=v_forcing,))

model.forcing.v

# output
ContinuousForcing{@NamedTuple{μ::Int64, λ::Float64, ω::Irrational{:π}}} at (Center, Face, Center)
├── func: parameterized_func (generic function with 1 method)
├── parameters: (μ = 42, λ = 0.1, ω = π)
└── field dependencies: ()</code></pre><p>After passing through the constructor for <code>NonhydrostaticModel</code>, the <code>v</code>-forcing location information is available and set to <code>Center, Face, Center</code>.</p><pre><code class="language-julia hljs"># Field-dependent forcing
growth_in_sunlight(x, y, z, t, P) = exp(z) * P

plankton_forcing = Forcing(growth_in_sunlight, field_dependencies=:P)

# output
ContinuousForcing{Nothing}
├── func: growth_in_sunlight (generic function with 1 method)
├── parameters: nothing
└── field dependencies: (:P,)</code></pre><pre><code class="language-julia hljs"># Parameterized, field-dependent forcing
tracer_relaxation(x, y, z, t, c, p) = p.μ * exp((z + p.H) / p.λ) * (p.dCdz * z - c)

c_forcing = Forcing(tracer_relaxation,
                    field_dependencies = :c,
                            parameters = (μ=1/60, λ=10, H=1000, dCdz=1))

# output
ContinuousForcing{@NamedTuple{μ::Float64, λ::Int64, H::Int64, dCdz::Int64}}
├── func: tracer_relaxation (generic function with 1 method)
├── parameters: (μ = 0.016666666666666666, λ = 10, H = 1000, dCdz = 1)
└── field dependencies: (:c,)</code></pre><pre><code class="language-julia hljs"># Unparameterized discrete-form forcing function
filtered_relaxation(i, j, k, grid, clock, model_fields) =
    @inbounds - (model_fields.c[i-1, j, k] + model_fields.c[i, j, k] + model_fields.c[i+1, j, k]) / 3

filtered_forcing = Forcing(filtered_relaxation, discrete_form=true)

# output
DiscreteForcing{Nothing}
├── func: filtered_relaxation (generic function with 1 method)
└── parameters: nothing</code></pre><pre><code class="language-julia hljs"># Discrete-form forcing function with parameters
masked_damping(i, j, k, grid, clock, model_fields, parameters) =
    @inbounds - parameters.μ * exp(grid.z.cᵃᵃᶜ[k] / parameters.λ) * model_fields.u[i, j, k]

masked_damping_forcing = Forcing(masked_damping, parameters=(μ=42, λ=π), discrete_form=true)

# output
DiscreteForcing{@NamedTuple{μ::Int64, λ::Irrational{:π}}}
├── func: masked_damping (generic function with 1 method)
└── parameters: (μ = 42, λ = π)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Forcings/forcing.jl#L1-L155">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Forcings.Forcing-Tuple{Union{FieldTimeSeries{LX, LY, LZ, TI, K}, Oceananigans.OutputReaders.GPUAdaptedFieldTimeSeries{LX, LY, LZ, TI, K}} where {LX, LY, LZ, TI, K}}"><a class="docstring-binding" href="#Oceananigans.Forcings.Forcing-Tuple{Union{FieldTimeSeries{LX, LY, LZ, TI, K}, Oceananigans.OutputReaders.GPUAdaptedFieldTimeSeries{LX, LY, LZ, TI, K}} where {LX, LY, LZ, TI, K}}"><code>Oceananigans.Forcings.Forcing</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Forcing(array::FlavorOfFTS)</code></pre><p>Return a <code>Forcing</code> by a <code>FieldTimeSeries</code>, which can be added to the tendency of a model field.</p><p>Forcing is computed by calling <code>fts[i, j, k, Time(clock.time)]</code>, so the <code>FieldTimeSeries</code> must have the spatial dimensions of the <code>grid</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Forcings/forcing.jl#L179-L185">source</a></section></details></article><h2 id="Grids"><a class="docs-heading-anchor" href="#Grids">Grids</a><a id="Grids-1"></a><a class="docs-heading-anchor-permalink" href="#Grids" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Oceananigans.Grids.AbstractCurvilinearGrid"><a class="docstring-binding" href="#Oceananigans.Grids.AbstractCurvilinearGrid"><code>Oceananigans.Grids.AbstractCurvilinearGrid</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractCurvilinearGrid{FT, TX, TY, TZ, CZ, Arch}</code></pre><p>Abstract supertype for curvilinear grids with elements of type <code>FT</code>, topology <code>{TX, TY, TZ}</code>, vertical coordinate <code>CZ</code>, and <code>Arch</code>itecture.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Grids/abstract_grid.jl#L17-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Grids.AbstractGrid"><a class="docstring-binding" href="#Oceananigans.Grids.AbstractGrid"><code>Oceananigans.Grids.AbstractGrid</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractGrid{FT, TX, TY, TZ, Arch}</code></pre><p>Abstract supertype for grids with elements of type <code>FT</code>, topology <code>{TX, TY, TZ}</code>, and <code>Arch</code>itecture.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Grids/abstract_grid.jl#L1-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Grids.AbstractHorizontallyCurvilinearGrid"><a class="docstring-binding" href="#Oceananigans.Grids.AbstractHorizontallyCurvilinearGrid"><code>Oceananigans.Grids.AbstractHorizontallyCurvilinearGrid</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractHorizontallyCurvilinearGrid{FT, TX, TY, TZ, CZ, Arch}</code></pre><p>Abstract supertype for horizontally-curvilinear grids with elements of type <code>FT</code>, topology <code>{TX, TY, TZ}</code>, vertical coordinate <code>CZ</code>, and <code>Arch</code>itecture.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Grids/abstract_grid.jl#L25-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Grids.AbstractTopology"><a class="docstring-binding" href="#Oceananigans.Grids.AbstractTopology"><code>Oceananigans.Grids.AbstractTopology</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractTopology</code></pre><p>Abstract supertype for grid topologies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Grids/Grids.jl#L55-L59">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Grids.AbstractUnderlyingGrid"><a class="docstring-binding" href="#Oceananigans.Grids.AbstractUnderlyingGrid"><code>Oceananigans.Grids.AbstractUnderlyingGrid</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractUnderlyingGrid{FT, TX, TY, TZ, CZ, Arch}</code></pre><p>Abstract supertype for &quot;primary&quot; grids (as opposed to grids with immersed boundaries) with elements of type <code>FT</code>, topology <code>{TX, TY, TZ}</code>, vertical coordinate <code>CZ</code>, and <code>Arch</code>itecture.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Grids/abstract_grid.jl#L9-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Grids.Bounded"><a class="docstring-binding" href="#Oceananigans.Grids.Bounded"><code>Oceananigans.Grids.Bounded</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Bounded</code></pre><p>Grid topology for bounded dimensions, e.g., wall-bounded dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Grids/Grids.jl#L69-L73">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Grids.Center"><a class="docstring-binding" href="#Oceananigans.Grids.Center"><code>Oceananigans.Grids.Center</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Center</code></pre><p>A type describing the location at the center of a grid cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Grids/Grids.jl#L41-L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Grids.ExponentialDiscretization-Tuple{Int64, Any, Any}"><a class="docstring-binding" href="#Oceananigans.Grids.ExponentialDiscretization-Tuple{Int64, Any, Any}"><code>Oceananigans.Grids.ExponentialDiscretization</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ExponentialDiscretization(N::Int, left, right;
                          scale = (right - left) / 5,
                          bias = :right,
                          mutable = false)</code></pre><p>Return a one-dimensional discretization with <code>N</code> cells that are exponentially spaced (or, equivalently, with spacings that grow linearly along the coordinate). The discretization spans the range [<code>left</code>, <code>right</code>]. The exponential e-folding is controlled by <code>scale</code>. The coordinate interfaces are closely stacked on the <code>bias</code>-side of the domain.</p><p><strong>Arguments</strong></p><ul><li><code>N</code>: The number of cells in the discretization.</li><li><code>left</code>: The left-most interface of the discretization.</li><li><code>right</code>: The right-most interface of the discretization.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>scale</code>: The length scale of the exponential e-folding. Default: <code>(right - left) / 5</code></li><li><code>bias :: Symbol</code>: Determine whether left or right biased. Default: <code>:right</code>.</li><li><code>mutable</code>: Whether the discretization is mutable, i.e., the discretization refers to a vertical coordinate that can evolve in time following certain rules. Default: false.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Oceananigans

N = 10
l = -1000
r = 100

x = ExponentialDiscretization(N, l, r)

# output
ExponentialDiscretization
├─ size: 10
├─ faces: [-1000.0, -564.247649441104, -299.95048878528615, -139.64615757253702, -42.41666580727582, 16.55600197663209, 52.324733072619736, 74.0195651413529, 87.17814594835643, 95.15922864611028, 100.0]
├─ left: -1000.0
├─ right: 100.0
├─ scale: 220.0
└─ bias: :right</code></pre><p>To inspect the interfaces of the coordinate we can call:</p><pre><code class="language-julia hljs">[x(i) for i in 1:N+1]

# output

11-element Vector{Float64}:
 -1000.0
  -564.247649441104
  -299.95048878528615
  -139.64615757253702
   -42.41666580727582
    16.55600197663209
    52.324733072619736
    74.0195651413529
    87.17814594835643
    95.15922864611028
   100.0</code></pre><p>Above, the default <code>bias</code> is <code>:right</code> and thus the interfaces are closer on the <code>right = 100</code> side of the domain. We can get a left-biased grid via:</p><pre><code class="language-julia hljs">x = ExponentialDiscretization(N, l, r, bias=:left)

[x(i) for i in 1:N+1]

# output

11-element Vector{Float64}:
 -1000.0
  -995.1592286461103
  -987.1781459483565
  -974.0195651413529
  -952.3247330726198
  -916.556001976632
  -857.5833341927241
  -760.353842427463
  -600.0495112147139
  -335.75235055889596
   100.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Grids/coordinate_utils.jl#L23-L117">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Grids.Face"><a class="docstring-binding" href="#Oceananigans.Grids.Face"><code>Oceananigans.Grids.Face</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Face</code></pre><p>A type describing the location at the face of a grid cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Grids/Grids.jl#L48-L52">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Grids.Flat"><a class="docstring-binding" href="#Oceananigans.Grids.Flat"><code>Oceananigans.Grids.Flat</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Flat</code></pre><p>Grid topology for flat dimensions, generally with one grid point, along which the solution is uniform and does not vary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Grids/Grids.jl#L76-L81">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Grids.FullyConnected"><a class="docstring-binding" href="#Oceananigans.Grids.FullyConnected"><code>Oceananigans.Grids.FullyConnected</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FullyConnected</code></pre><p>Grid topology for dimensions that are connected to other models or domains.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Grids/Grids.jl#L84-L88">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Grids.LatitudeLongitudeGrid"><a class="docstring-binding" href="#Oceananigans.Grids.LatitudeLongitudeGrid"><code>Oceananigans.Grids.LatitudeLongitudeGrid</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LatitudeLongitudeGrid([architecture = CPU(), FT = Oceananigans.defaults.FloatType];
                      size,
                      longitude,
                      latitude,
                      z = nothing,
                      radius = Oceananigans.defaults.planet_radius,
                      topology = nothing,
                      precompute_metrics = true,
                      halo = nothing)</code></pre><p>Creates a <code>LatitudeLongitudeGrid</code> with coordinates <code>(λ, φ, z)</code> denoting longitude, latitude, and vertical coordinate respectively.</p><p><strong>Positional arguments</strong></p><ul><li><p><code>architecture</code>: Specifies whether arrays of coordinates and spacings are stored                 on the CPU or GPU. Default: <code>CPU()</code>.</p></li><li><p><code>FT</code> : Floating point data type. Default: <code>Float64</code>.</p></li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>size</code> (required): A 3-tuple prescribing the number of grid points each direction.</p></li><li><p><code>longitude</code> (required), <code>latitude</code> (required), <code>z</code> (default: <code>nothing</code>): Each is either a:</p><ol><li>2-tuple that specify the end points of the domain,</li><li>one-dimensional array specifying the cell interface locations, or</li><li>single-argument function that takes an index and returns cell interface location.</li></ol><p><strong>Note</strong>: the latitude and longitude coordinates extents are expected in degrees.</p></li><li><p><code>radius</code>: The radius of the sphere the grid lives on. By default is equal to the radius of Earth.</p></li><li><p><code>topology</code>: Tuple of topologies (<code>Flat</code>, <code>Bounded</code>, <code>Periodic</code>) for each direction. The vertical             <code>topology[3]</code> must be <code>Bounded</code>, while the latitude-longitude topologies can be             <code>Bounded</code>, <code>Periodic</code>, or <code>Flat</code>. If no topology is provided then, by default, the             topology is (<code>Periodic</code>, <code>Bounded</code>, <code>Bounded</code>) if the latitudinal extent is 360 degrees             or (<code>Bounded</code>, <code>Bounded</code>, <code>Bounded</code>) otherwise.</p></li><li><p><code>precompute_metrics</code>: Boolean specifying whether to precompute horizontal spacings and areas.                       Default: <code>true</code>. When <code>false</code>, horizontal spacings and areas are computed                       on-the-fly during a simulation.</p></li><li><p><code>halo</code>: A 3-tuple of integers specifying the size of the halo region of cells surrounding         the physical interior. The default is 3 halo cells in every direction.</p></li></ul><p><strong>Examples</strong></p><ul><li>A default grid with <code>Float64</code> type:</li></ul><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = LatitudeLongitudeGrid(size=(36, 34, 25),
                                    longitude = (-180, 180),
                                    latitude = (-85, 85),
                                    z = (-1000, 0))
36×34×25 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3×3×3 halo
├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=10.0
├── latitude:  Bounded  φ ∈ [-85.0, 85.0]   regularly spaced with Δφ=5.0
└── z:         Bounded  z ∈ [-1000.0, 0.0]  regularly spaced with Δz=40.0</code></pre><ul><li>A bounded spherical sector with cell interfaces stretched hyperbolically near the top:</li></ul><pre><code class="language-julia hljs">using Oceananigans

σ = 1.1 # stretching factor
Nz = 24 # vertical resolution
Lz = 1000 # depth (m)
hyperbolically_spaced_faces(k) = - Lz * (1 - tanh(σ * (k - 1) / Nz) / tanh(σ))

grid = LatitudeLongitudeGrid(size=(36, 34, Nz),
                             longitude = (-180, 180),
                             latitude = (-20, 20),
                             z = hyperbolically_spaced_faces,
                             topology = (Bounded, Bounded, Bounded))

# output

36×34×24 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3×3×3 halo
├── longitude: Bounded  λ ∈ [-180.0, 180.0] regularly spaced with Δλ=10.0
├── latitude:  Bounded  φ ∈ [-20.0, 20.0]   regularly spaced with Δφ=1.17647
└── z:         Bounded  z ∈ [-1000.0, -0.0] variably spaced with min(Δz)=21.3342, max(Δz)=57.2159</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Grids/latitude_longitude_grid.jl#L105-L196">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Grids.LatitudeLongitudeGrid-Tuple{RectilinearGrid}"><a class="docstring-binding" href="#Oceananigans.Grids.LatitudeLongitudeGrid-Tuple{RectilinearGrid}"><code>Oceananigans.Grids.LatitudeLongitudeGrid</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">LatitudeLongitudeGrid(rectilinear_grid::RectilinearGrid;
                      radius = Oceananigans.defaults.planet_radius,
                      origin = (0, 0))</code></pre><p>Construct a <code>LatitudeLongitudeGrid</code> from a <code>RectilinearGrid</code>. The horizontal coordinates of the rectilinear grid are transformed to longitude-latitude coordinates in degrees, accounting for spherical Earth geometry. The longitudes are computed approximately using the latitudinal origin.</p><p>The vertical coordinate and architecture are inherited from the input grid.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>radius</code>: The radius of the sphere, defaults to Earth&#39;s mean radius (≈ 6371 km)</li><li><code>origin</code>: Tuple of (longitude, latitude) in degrees specifying the origin of the rectilinear grid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Grids/latitude_longitude_grid.jl#L686-L701">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Grids.LeftConnected"><a class="docstring-binding" href="#Oceananigans.Grids.LeftConnected"><code>Oceananigans.Grids.LeftConnected</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LeftConnected</code></pre><p>Grid topology for dimensions that are connected to other models or domains only on the left (the other direction is bounded)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Grids/Grids.jl#L91-L95">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Grids.LinearStretching"><a class="docstring-binding" href="#Oceananigans.Grids.LinearStretching"><code>Oceananigans.Grids.LinearStretching</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LinearStretching{T}</code></pre><p>Α linear stretching of the form <code>x ↦ (1 + coefficient) * x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Grids/coordinate_utils.jl#L194-L198">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Grids.LinearStretching-Tuple{Any}"><a class="docstring-binding" href="#Oceananigans.Grids.LinearStretching-Tuple{Any}"><code>Oceananigans.Grids.LinearStretching</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">(stretching::LinearStretching)(x)</code></pre><p>Apply linear stretching to <code>x</code> via</p><pre><code class="language-julia hljs">(1 + stretching.coefficient) * x</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Grids/coordinate_utils.jl#L203-L209">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Grids.MutableVerticalDiscretization-Tuple{Any}"><a class="docstring-binding" href="#Oceananigans.Grids.MutableVerticalDiscretization-Tuple{Any}"><code>Oceananigans.Grids.MutableVerticalDiscretization</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MutableVerticalDiscretization(r_faces)</code></pre><p>Construct a <code>MutableVerticalDiscretization</code> from <code>r_faces</code> that can be a <code>Tuple</code>, a function of an index <code>k</code>, or an <code>AbstractArray</code>. A <code>MutableVerticalDiscretization</code> defines a vertical coordinate that can evolve in time following certain rules. Examples of <code>MutableVerticalDiscretization</code>s are the free-surface following coordinates (also known as &quot;zee-star&quot;) or the terrain following coordinates (also known as &quot;sigma&quot; coordinates).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Grids/vertical_discretization.jl#L63-L72">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Grids.OrthogonalSphericalShellGrid"><a class="docstring-binding" href="#Oceananigans.Grids.OrthogonalSphericalShellGrid"><code>Oceananigans.Grids.OrthogonalSphericalShellGrid</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">OrthogonalSphericalShellGrid(arch = CPU(), FT = Oceananigans.defaults.FloatType;
                             size,
                             z,
                             radius = Oceananigans.defaults.planet_radius,
                             conformal_mapping = nothing,
                             halo = (3, 3, 3),
                             topology = (Bounded, Bounded, Bounded))</code></pre><p>Return an OrthogonalSphericalShellGrid with empty horizontal metrics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Grids/orthogonal_spherical_shell_grid.jl#L342-L352">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Grids.Periodic"><a class="docstring-binding" href="#Oceananigans.Grids.Periodic"><code>Oceananigans.Grids.Periodic</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Periodic</code></pre><p>Grid topology for periodic dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Grids/Grids.jl#L62-L66">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Grids.PowerLawStretching"><a class="docstring-binding" href="#Oceananigans.Grids.PowerLawStretching"><code>Oceananigans.Grids.PowerLawStretching</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PowerLawStretching{T}</code></pre><p>Α power-law stretching of the form <code>x ↦ x^power</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Grids/coordinate_utils.jl#L176-L180">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Grids.PowerLawStretching-Tuple{Any}"><a class="docstring-binding" href="#Oceananigans.Grids.PowerLawStretching-Tuple{Any}"><code>Oceananigans.Grids.PowerLawStretching</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">(stretching::PowerLawStretching)(x)</code></pre><p>Apply power-law stretching to <code>x</code> via</p><pre><code class="language-julia hljs">x^stretching.power</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Grids/coordinate_utils.jl#L185-L191">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Grids.RectilinearGrid"><a class="docstring-binding" href="#Oceananigans.Grids.RectilinearGrid"><code>Oceananigans.Grids.RectilinearGrid</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RectilinearGrid([architecture = CPU(), FT = Float64];
                size,
                x = nothing,
                y = nothing,
                z = nothing,
                halo = nothing,
                extent = nothing,
                topology = (Periodic, Periodic, Bounded))</code></pre><p>Create a <code>RectilinearGrid</code> with <code>size = (Nx, Ny, Nz)</code> grid points.</p><p><strong>Positional arguments</strong></p><ul><li><p><code>architecture</code>: Specifies whether arrays of coordinates and spacings are stored                 on the CPU or GPU. Default: <code>CPU()</code>.</p></li><li><p><code>FT</code>: Floating point data type. Default: <code>Float64</code>.</p></li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>size</code> (required): A tuple prescribing the number of grid points in non-<code>Flat</code> directions.                    <code>size</code> is a 3-tuple for 3D models, a 2-tuple for 2D models, and either a                    scalar or 1-tuple for 1D models.</p></li><li><p><code>topology</code>: A 3-tuple <code>(TX, TY, TZ)</code> specifying the topology of the domain.             <code>TX</code>, <code>TY</code>, and <code>TZ</code> specify whether the <code>x</code>-, <code>y</code>-, and <code>z</code> directions are             <code>Periodic</code>, <code>Bounded</code>, or <code>Flat</code>. The topology <code>Flat</code> indicates that a model does             not vary in those directions so that derivatives and interpolation are zero.             The default is <code>topology = (Periodic, Periodic, Bounded)</code>.</p></li><li><p><code>extent</code>: A tuple prescribing the physical extent of the grid in non-<code>Flat</code> directions, e.g.,           <code>(Lx, Ly, Lz)</code>. All directions are constructed with regular grid spacing and the domain           (in the case that no direction is <code>Flat</code>) is <span>$0 ≤ x ≤ L_x$</span>, <span>$0 ≤ y ≤ L_y$</span>, and           <span>$-L_z ≤ z ≤ 0$</span>, which is most appropriate for oceanic applications in which <span>$z = 0$</span>           usually is the ocean&#39;s surface.</p></li><li><p><code>x</code>, <code>y</code>, and <code>z</code>: Each of <code>x, y, z</code> are either (i) 2-tuples that specify the end points of the domain                    in their respect directions (in which case scalar values may be used in <code>Flat</code>                    directions), (ii) arrays that specify the locations of cell faces in the <code>x</code>-, <code>y</code>-,                    or <code>z</code>-direction, or (iii) functions of the corresponding indices <code>i</code>, <code>j</code>, or <code>k</code>                    that specify the locations of cell faces in the <code>x</code>-, <code>y</code>-, or <code>z</code>-direction, respectively.                    For example, to prescribe the cell faces in <code>z</code> we need to provide a function that takes                    <code>k</code> as argument and returns the location of the faces for indices <code>k = 1</code> through <code>k = Nz + 1</code>,                    where <code>Nz</code> is the <code>size</code> of the stretched <code>z</code> dimension.</p><div class="admonition is-info" id="Physical-extent-of-grid-7a2238cc31bd6d5a"><header class="admonition-header">Physical extent of grid<a class="admonition-anchor" href="#Physical-extent-of-grid-7a2238cc31bd6d5a" title="Permalink"></a></header><div class="admonition-body"><p><em>Either</em> <code>extent</code>, or <em>all</em> of <code>x</code>, <code>y</code>, and <code>z</code> must be specified.</p></div></div></li><li><p><code>halo</code>: A tuple of integers that specifies the size of the halo region, that is the number of cells surrounding         the physical interior for each non-<code>Flat</code> direction. The default is 3 halo cells in every direction.</p></li></ul><p>The physical extent of the domain can be specified either via <code>x</code>, <code>y</code>, and <code>z</code> keyword arguments indicating the left and right endpoints of each dimensions, e.g., <code>x = (-π, π)</code> or via the <code>extent</code> argument, e.g., <code>extent = (Lx, Ly, Lz)</code>, which specifies the extent of each dimension in which case <span>$0 ≤ x ≤ L_x$</span>, <span>$0 ≤ y ≤ L_y$</span>, and <span>$-L_z ≤ z ≤ 0$</span>.</p><p>A grid topology may be specified via a tuple assigning one of <code>Periodic</code>, <code>Bounded</code>, and, <code>Flat</code> to each dimension. By default, a horizontally periodic grid topology <code>(Periodic, Periodic, Bounded)</code> is assumed.</p><p>Constants are stored using floating point values of type <code>FT</code>. By default this is <code>Float64</code>. Make sure to specify the desired <code>FT</code> if not using <code>Float64</code>.</p><p><strong>Grid properties</strong></p><ul><li><p><code>architecture</code>: The grid&#39;s architecture.</p></li><li><p><code>(Nx, Ny, Nz) :: Int</code>: Number of physical points in the <span>$(x, y, z)$</span>-direction.</p></li><li><p><code>(Hx, Hy, Hz) :: Int</code>: Number of halo points in the <span>$(x, y, z)$</span>-direction.</p></li><li><p><code>(Lx, Ly, Lz) :: FT</code>: Physical extent of the grid in the <span>$(x, y, z)$</span>-direction.</p></li><li><p><code>(Δxᶜᵃᵃ, Δyᵃᶜᵃ, z.Δcᵃᵃᶜ)</code>: Spacings in the <span>$(x, y, z)$</span>-directions between the cell faces.                            These are the lengths in <span>$x$</span>, <span>$y$</span>, and <span>$z$</span> of <code>Center</code> cells and are                            defined at <code>Center</code> locations.</p></li><li><p><code>(Δxᶠᵃᵃ, Δyᵃᶠᵃ, z.Δcᵃᵃᶠ)</code>: Spacings in the <span>$(x, y, z)$</span>-directions between the cell centers.                            These are the lengths in <span>$x$</span>, <span>$y$</span>, and <span>$z$</span> of <code>Face</code> cells and are                            defined at <code>Face</code> locations.</p></li><li><p><code>(xᶜᵃᵃ, yᵃᶜᵃ, z.cᵃᵃᶜ)</code>: <span>$(x, y, z)$</span> coordinates of cell <code>Center</code>s.</p></li><li><p><code>(xᶠᵃᵃ, yᵃᶠᵃ, z.cᵃᵃᶠ)</code>: <span>$(x, y, z)$</span> coordinates of cell <code>Face</code>s.</p></li></ul><p><strong>Examples</strong></p><ul><li>A grid with the default <code>Float64</code> type:</li></ul><pre><code class="language-julia hljs">using Oceananigans
grid = RectilinearGrid(size=(32, 32, 32), extent=(1, 2, 3))

# output

32×32×32 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo
├── Periodic x ∈ [0.0, 1.0)  regularly spaced with Δx=0.03125
├── Periodic y ∈ [0.0, 2.0)  regularly spaced with Δy=0.0625
└── Bounded  z ∈ [-3.0, 0.0] regularly spaced with Δz=0.09375</code></pre><ul><li>A grid with <code>Float32</code> type:</li></ul><pre><code class="language-julia hljs">using Oceananigans
grid = RectilinearGrid(Float32; size=(32, 32, 16), x=(0, 8), y=(-10, 10), z=(-π, π))

# output

32×32×16 RectilinearGrid{Float32, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo
├── Periodic x ∈ [0.0, 8.0)          regularly spaced with Δx=0.25
├── Periodic y ∈ [-10.0, 10.0)       regularly spaced with Δy=0.625
└── Bounded  z ∈ [-3.14159, 3.14159] regularly spaced with Δz=0.392699</code></pre><ul><li>A two-dimenisional, horizontally-periodic grid:</li></ul><pre><code class="language-julia hljs">using Oceananigans
grid = RectilinearGrid(size=(32, 32), extent=(2π, 4π), topology=(Periodic, Periodic, Flat))

# output

32×32×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo
├── Periodic x ∈ [3.60072e-17, 6.28319) regularly spaced with Δx=0.19635
├── Periodic y ∈ [7.20145e-17, 12.5664) regularly spaced with Δy=0.392699
└── Flat z</code></pre><ul><li>A one-dimensional &quot;column&quot; grid:</li></ul><pre><code class="language-julia hljs">using Oceananigans
grid = RectilinearGrid(size=256, z=(-128, 0), topology=(Flat, Flat, Bounded))

# output

1×1×256 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo
├── Flat x
├── Flat y
└── Bounded  z ∈ [-128.0, 0.0] regularly spaced with Δz=0.5</code></pre><ul><li>A horizontally-periodic regular grid with cell interfaces stretched hyperbolically near the top:</li></ul><pre><code class="language-julia hljs">using Oceananigans

σ = 1.1 # stretching factor
Nz = 24 # vertical resolution
Lz = 32 # depth (m)

hyperbolically_spaced_faces(k) = - Lz * (1 - tanh(σ * (k - 1) / Nz) / tanh(σ))

grid = RectilinearGrid(size = (32, 32, Nz),
                       x = (0, 64), y = (0, 64),
                       z = hyperbolically_spaced_faces)

# output

32×32×24 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo
├── Periodic x ∈ [0.0, 64.0)   regularly spaced with Δx=2.0
├── Periodic y ∈ [0.0, 64.0)   regularly spaced with Δy=2.0
└── Bounded  z ∈ [-32.0, -0.0] variably spaced with min(Δz)=0.682695, max(Δz)=1.83091</code></pre><ul><li>A three-dimensional grid with regular spacing in <span>$x$</span>, cell interfaces at Chebyshev nodes in <span>$y$</span>, and cell interfaces hyperbolically stretched in <span>$z$</span> near the top:</li></ul><pre><code class="language-julia hljs">using Oceananigans

Nx, Ny, Nz = 32, 30, 24
Lx, Ly, Lz = 200, 100, 32 # (m)

chebychev_nodes(j) = - Ly/2 * cos(π * (j - 1) / Ny)

σ = 1.1 # stretching factor
hyperbolically_spaced_faces(k) = - Lz * (1 - tanh(σ * (k - 1) / Nz) / tanh(σ))

grid = RectilinearGrid(size = (Nx, Ny, Nz),
                       topology = (Periodic, Bounded, Bounded),
                       x = (0, Lx),
                       y = chebychev_nodes,
                       z = hyperbolically_spaced_faces)

# output

32×30×24 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3×3×3 halo
├── Periodic x ∈ [0.0, 200.0)  regularly spaced with Δx=6.25
├── Bounded  y ∈ [-50.0, 50.0] variably spaced with min(Δy)=0.273905, max(Δy)=5.22642
└── Bounded  z ∈ [-32.0, -0.0] variably spaced with min(Δz)=0.682695, max(Δz)=1.83091</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Grids/rectilinear_grid.jl#L65-L263">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Grids.ReferenceToStretchedDiscretization-Tuple{}"><a class="docstring-binding" href="#Oceananigans.Grids.ReferenceToStretchedDiscretization-Tuple{}"><code>Oceananigans.Grids.ReferenceToStretchedDiscretization</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ReferenceToStretchedDiscretization(; extent,
                                   bias = :right,
                                   bias_edge = 0,
                                   constant_spacing = extent / 20,
                                   constant_spacing_extent = 5 * constant_spacing,
                                   maximum_stretching_extent = Inf,
                                   maximum_spacing = Inf,
                                   stretching = PowerLawStretching(1.02),
                                   rounding_digits = 2,
                                   mutable = false)</code></pre><p>Return a one-dimensional coordinate that has <code>constant_spacing</code> over a <code>constant_spacing_extent</code> on the <code>bias</code>-side of the domain. The coordinate has constant spacing over a distance</p><pre><code class="language-julia hljs">ceil(constant_spacing_extent / constant_spacing) * constant_spacing &gt; constant_spacing_extent</code></pre><p>from the <code>bias_edge</code>. Beyond the above distance, the interface spacings stretch according the provided <code>stretching</code> law.</p><p><strong>Keyword arguments</strong></p><ul><li><code>extent</code>: The desired extent of the coordinate.</li><li><code>bias :: Symbol</code>: Whether the <code>constant_spacing</code> interfaces are on the left (<code>:left</code>) or right (<code>:right</code>) part of the domain. Default: <code>:right</code>.</li><li><code>bias_edge</code>: The first interface on the <code>bias</code>-side of the domain. Default: 0.</li><li><code>constant_spacing</code>: The constant spacing on the <code>bias</code>-side of the domain. Default: <code>extent / 20</code>.</li><li><code>constant_spacing_extent</code>: The extent of the domain away from the <code>bias_edge</code> for which we have <code>constant_spacing</code>. Default: <code>5 * constant_spacing</code>.</li><li><code>maximum_stretching_extent</code>: The distance away from the <code>bias_edge</code> beyond which there is no more stretching and instead we transition to a uniformly-spaced coordinate. Default: Inf.</li><li><code>maximum_spacing</code>: The maximum spacing between two interfaces. Default: Inf.</li><li><code>stretching</code>: The stretching law. Available options are <a href="#Oceananigans.Grids.PowerLawStretching"><code>PowerLawStretching</code></a> and <a href="#Oceananigans.Grids.LinearStretching"><code>LinearStretching</code></a>.  Default: <code>PowerLawStretching(1.02)</code>.</li><li><code>rounding_digits</code>: the accuracy with which the grid interfaces are saved. Default: 2.</li><li><code>mutable</code>: Whether the discretization is mutable, i.e., the discretization refers to a vertical coordinate that can evolve in time following certain rules. Default: false.</li></ul><p><strong>Examples</strong></p><ul><li><p>A vertical coordinate with constant 20-meter spacing at the top 110 meters. For that, we use the defaults <code>bias = :right</code> and <code>bias_edge = 0</code>.</p><pre><code class="language-julia hljs">using Oceananigans

z = ReferenceToStretchedDiscretization(extent = 200,
                                       constant_spacing = 25,
                                       constant_spacing_extent = 90)
# output
ReferenceToStretchedDiscretization
├─ extent: 200.0
├─ bias: :right
├─ bias_edge: 0.0
├─ constant_spacing: 25.0
├─ constant_spacing_extent: 90.0
├─ maximum_stretching_extent: Inf
├─ maximum_spacing: Inf
├─ stretching: PowerLawStretching{Float64}(1.02)
└─ faces: : 9-element Vector{Float64}</code></pre><p>The <code>z</code> coordinate above has</p><pre><code class="language-julia hljs">N = length(z)

# output
8</code></pre><p>cells. The coordinate&#39;s interfaces are:</p><pre><code class="language-julia hljs">z.faces

# output
9-element Vector{Float64}:
 -218.16
 -185.57
 -155.13
 -126.66
 -100.0
  -75.0
  -50.0
  -25.0
    0.0</code></pre><p>The coordinate has an extent that is longer from what prescribed via the <code>extent</code> keyword argument, namely by:</p><pre><code class="language-julia hljs">(z.faces[end] - z.faces[1]) - z.extent

# output

18.159999999999997</code></pre></li><li><p>A coordinate that that has a 20-meter spacing for 50 meters at the left side of the domain. The left-most interface of the domain is at -50 meters and the coordinate extends for at least 250 meters.</p><pre><code class="language-julia hljs">using Oceananigans

x = ReferenceToStretchedDiscretization(extent = 250,
                                       bias = :left,
                                       bias_edge = -50,
                                       constant_spacing = 20,
                                       constant_spacing_extent = 50)

x.faces

# output

12-element Vector{Float64}:
 -50.0
 -30.0
 -10.0
  10.0
  31.23
  53.8
  77.82
 103.42
 130.74
 159.93
 191.16
 224.62</code></pre><p>that ends up with</p><pre><code class="language-julia hljs">length(x)

# output
11</code></pre><p>cells that span a domain of:</p><pre><code class="language-julia hljs">x.faces[end] - x.faces[1]

# output
274.62</code></pre><p>which is bigger than the desired <code>extent</code>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Grids/coordinate_utils.jl#L293-L446">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Grids.RightConnected"><a class="docstring-binding" href="#Oceananigans.Grids.RightConnected"><code>Oceananigans.Grids.RightConnected</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RightConnected</code></pre><p>Grid topology for dimensions that are connected to other models or domains only on the right (the other direction is bounded)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Grids/Grids.jl#L98-L102">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Architectures.on_architecture-Tuple{Oceananigans.Architectures.AbstractSerialArchitecture, RectilinearGrid}"><a class="docstring-binding" href="#Oceananigans.Architectures.on_architecture-Tuple{Oceananigans.Architectures.AbstractSerialArchitecture, RectilinearGrid}"><code>Oceananigans.Architectures.on_architecture</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">on_architecture(architecture, grid)</code></pre><p>Return a <code>new_grid</code> that&#39;s identical to <code>grid</code> but on <code>architecture</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Grids/rectilinear_grid.jl#L451-L455">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Grids.halo_size-Tuple{Any}"><a class="docstring-binding" href="#Oceananigans.Grids.halo_size-Tuple{Any}"><code>Oceananigans.Grids.halo_size</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">halo_size(grid)</code></pre><p>Return a 3-tuple with the number of halo cells on either side of the domain in (x, y, z).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Grids/abstract_grid.jl#L93-L98">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Grids.minimum_xspacing-Tuple{Any, Vararg{Any}}"><a class="docstring-binding" href="#Oceananigans.Grids.minimum_xspacing-Tuple{Any, Vararg{Any}}"><code>Oceananigans.Grids.minimum_xspacing</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">minimum_xspacing(grid, ℓx, ℓy, ℓz)</code></pre><p>Return the minimum spacing for <code>grid</code> in <span>$x$</span> direction at location <code>ℓx, ℓy, ℓz</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = RectilinearGrid(size=(2, 4, 8), extent=(1, 1, 1));

julia&gt; minimum_xspacing(grid, Center(), Center(), Center())
0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Grids/nodes_and_spacings.jl#L143-L158">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Grids.minimum_yspacing-Tuple{Any, Vararg{Any}}"><a class="docstring-binding" href="#Oceananigans.Grids.minimum_yspacing-Tuple{Any, Vararg{Any}}"><code>Oceananigans.Grids.minimum_yspacing</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">minimum_yspacing(grid, ℓx, ℓy, ℓz)</code></pre><p>Return the minimum spacing for <code>grid</code> in <span>$y$</span> direction at location <code>ℓx, ℓy, ℓz</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = RectilinearGrid(size=(2, 4, 8), extent=(1, 1, 1));

julia&gt; minimum_yspacing(grid, Center(), Center(), Center())
0.25</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Grids/nodes_and_spacings.jl#L162-L177">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Grids.minimum_zspacing-Tuple{Any, Vararg{Any}}"><a class="docstring-binding" href="#Oceananigans.Grids.minimum_zspacing-Tuple{Any, Vararg{Any}}"><code>Oceananigans.Grids.minimum_zspacing</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">minimum_zspacing(grid, ℓx, ℓy, ℓz)
minimum_zspacing(grid) = minimum_zspacing(grid, Center(), Center(), Center())</code></pre><p>Return the minimum spacing for <code>grid</code> in <span>$z$</span> direction at location <code>ℓx, ℓy, ℓz</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = RectilinearGrid(size=(2, 4, 8), extent=(1, 1, 1));

julia&gt; minimum_zspacing(grid, Center(), Center(), Center())
0.125</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Grids/nodes_and_spacings.jl#L181-L197">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Grids.new_data"><a class="docstring-binding" href="#Oceananigans.Grids.new_data"><code>Oceananigans.Grids.new_data</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">new_data(FT, arch, loc, topo, sz, halo_sz, indices)</code></pre><p>Return an <code>OffsetArray</code> of zeros of float type <code>FT</code> on <code>arch</code>itecture, with indices corresponding to a field on a <code>grid</code> of <code>size(grid)</code> and located at <code>loc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Grids/new_data.jl#L60-L65">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Grids.nodes-Tuple{Oceananigans.Grids.AbstractGrid, Any}"><a class="docstring-binding" href="#Oceananigans.Grids.nodes-Tuple{Oceananigans.Grids.AbstractGrid, Any}"><code>Oceananigans.Grids.nodes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">nodes(grid, (ℓx, ℓy, ℓz); reshape=false, with_halos=false)
nodes(grid, ℓx, ℓy, ℓz; reshape=false, with_halos=false)</code></pre><p>Return a 3-tuple of views over the interior nodes of the <code>grid</code>&#39;s native coordinates at the locations in <code>loc=(ℓx, ℓy, ℓz)</code> in <code>x, y, z</code>.</p><p>If <code>reshape=true</code>, the views are reshaped to 3D arrays with non-singleton dimensions 1, 2, 3 for <code>x, y, z</code>, respectively. These reshaped arrays can then be used in broadcast operations with 3D fields or arrays.</p><p>For <code>RectilinearGrid</code>s the native coordinates are <code>x, y, z</code>; for curvilinear grids, like <code>LatitudeLongitudeGrid</code> or <code>OrthogonalSphericalShellGrid</code> the native coordinates are <code>λ, φ, z</code>.</p><p>See <a href="#Oceananigans.Grids.xnodes-NTuple{4, Any}"><code>xnodes</code></a>, <a href="#Oceananigans.Grids.ynodes-NTuple{4, Any}"><code>ynodes</code></a>, <a href="#Oceananigans.Grids.znodes-Tuple{Oceananigans.Grids.AbstractUnderlyingGrid, Any}"><code>znodes</code></a>, <a href="#Oceananigans.Grids.λnodes-Tuple{Oceananigans.Grids.AbstractCurvilinearGrid, Any, Any, Any}"><code>λnodes</code></a>, and <a href="#Oceananigans.Grids.φnodes-Tuple{Oceananigans.Grids.AbstractCurvilinearGrid, Any, Any, Any}"><code>φnodes</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Grids/nodes_and_spacings.jl#L110-L126">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Grids.offset_data"><a class="docstring-binding" href="#Oceananigans.Grids.offset_data"><code>Oceananigans.Grids.offset_data</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">offset_data(underlying_data, grid::AbstractGrid, loc, indices=default_indices(length(loc)))</code></pre><p>Return an <code>OffsetArray</code> that maps to <code>underlying_data</code> in memory, with offset indices appropriate for the <code>data</code> of a field on a <code>grid</code> of <code>size(grid)</code> and located at <code>loc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Grids/new_data.jl#L51-L56">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Grids.topology-Tuple{Any, Any}"><a class="docstring-binding" href="#Oceananigans.Grids.topology-Tuple{Any, Any}"><code>Oceananigans.Grids.topology</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">topology(grid, dim)</code></pre><p>Return the topology of the <code>grid</code> for the <code>dim</code>-th dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Grids/abstract_grid.jl#L56-L60">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Grids.topology-Union{Tuple{Oceananigans.Grids.AbstractGrid{FT, TX, TY, TZ}}, Tuple{TZ}, Tuple{TY}, Tuple{TX}, Tuple{FT}} where {FT, TX, TY, TZ}"><a class="docstring-binding" href="#Oceananigans.Grids.topology-Union{Tuple{Oceananigans.Grids.AbstractGrid{FT, TX, TY, TZ}}, Tuple{TZ}, Tuple{TY}, Tuple{TX}, Tuple{FT}} where {FT, TX, TY, TZ}"><code>Oceananigans.Grids.topology</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">topology(grid)</code></pre><p>Return a tuple with the topology of the <code>grid</code> for each dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Grids/abstract_grid.jl#L49-L53">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Grids.total_size"><a class="docstring-binding" href="#Oceananigans.Grids.total_size"><code>Oceananigans.Grids.total_size</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">total_size(grid, loc)</code></pre><p>Return the &quot;total&quot; size of a <code>grid</code> at <code>loc</code>. This is a 3-tuple of integers corresponding to the number of grid points along <code>x, y, z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Grids/grid_utils.jl#L95-L100">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Grids.xnodes-NTuple{4, Any}"><a class="docstring-binding" href="#Oceananigans.Grids.xnodes-NTuple{4, Any}"><code>Oceananigans.Grids.xnodes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">xnodes(grid, ℓx, ℓy, ℓz, with_halos=false)</code></pre><p>Return the positions over the interior nodes on <code>grid</code> in the <span>$x$</span>-direction for the location <code>ℓx</code>, <code>ℓy</code>, <code>ℓz</code>. For <code>Bounded</code> directions, <code>Face</code> nodes include the boundary points.</p><p>See <a href="#Oceananigans.Grids.znodes-Tuple{Oceananigans.Grids.AbstractUnderlyingGrid, Any}"><code>znodes</code></a> for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Grids/nodes_and_spacings.jl#L70-L77">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Grids.ynodes-NTuple{4, Any}"><a class="docstring-binding" href="#Oceananigans.Grids.ynodes-NTuple{4, Any}"><code>Oceananigans.Grids.ynodes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ynodes(grid, ℓx, ℓy, ℓz, with_halos=false)</code></pre><p>Return the positions over the interior nodes on <code>grid</code> in the <span>$y$</span>-direction for the location <code>ℓx</code>, <code>ℓy</code>, <code>ℓz</code>. For <code>Bounded</code> directions, <code>Face</code> nodes include the boundary points.</p><p>See <a href="#Oceananigans.Grids.znodes-Tuple{Oceananigans.Grids.AbstractUnderlyingGrid, Any}"><code>znodes</code></a> for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Grids/nodes_and_spacings.jl#L80-L87">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Grids.znodes-Tuple{Oceananigans.Grids.AbstractUnderlyingGrid, Any}"><a class="docstring-binding" href="#Oceananigans.Grids.znodes-Tuple{Oceananigans.Grids.AbstractUnderlyingGrid, Any}"><code>Oceananigans.Grids.znodes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">znodes(grid, ℓx, ℓy, ℓz, with_halos=false)</code></pre><p>Return the positions over the interior nodes on <code>grid</code> in the <span>$z$</span>-direction for the location <code>ℓx</code>, <code>ℓy</code>, <code>ℓz</code>. For <code>Bounded</code> directions, <code>Face</code> nodes include the boundary points.</p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; horz_periodic_grid = RectilinearGrid(size=(3, 3, 3), extent=(2π, 2π, 1), halo=(1, 1, 1),
                                            topology=(Periodic, Periodic, Bounded));

julia&gt; z = znodes(horz_periodic_grid, Center())
-0.8333333333333334:0.3333333333333333:-0.16666666666666666

julia&gt; z = znodes(horz_periodic_grid, Center(), Center(), Center())
-0.8333333333333334:0.3333333333333333:-0.16666666666666666

julia&gt; z = znodes(horz_periodic_grid, Center(), Center(), Center(), with_halos=true)
5-element view(OffsetArray(::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, 0:4), :) with eltype Float64 with indices 0:4:
 -1.1666666666666667
 -0.8333333333333334
 -0.5
 -0.16666666666666666
  0.16666666666666666</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Grids/vertical_discretization.jl#L212-L238">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Grids.λnodes-Tuple{Oceananigans.Grids.AbstractCurvilinearGrid, Any, Any, Any}"><a class="docstring-binding" href="#Oceananigans.Grids.λnodes-Tuple{Oceananigans.Grids.AbstractCurvilinearGrid, Any, Any, Any}"><code>Oceananigans.Grids.λnodes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">λnodes(grid::AbstractCurvilinearGrid, ℓx, ℓy, ℓz, with_halos=false)</code></pre><p>Return the positions over the interior nodes on a curvilinear <code>grid</code> in the <span>$λ$</span>-direction for the location <code>ℓλ</code>, <code>ℓφ</code>, <code>ℓz</code>. For <code>Bounded</code> directions, <code>Face</code> nodes include the boundary points.</p><p>See <a href="#Oceananigans.Grids.znodes-Tuple{Oceananigans.Grids.AbstractUnderlyingGrid, Any}"><code>znodes</code></a> for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Grids/nodes_and_spacings.jl#L90-L97">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Grids.φnodes-Tuple{Oceananigans.Grids.AbstractCurvilinearGrid, Any, Any, Any}"><a class="docstring-binding" href="#Oceananigans.Grids.φnodes-Tuple{Oceananigans.Grids.AbstractCurvilinearGrid, Any, Any, Any}"><code>Oceananigans.Grids.φnodes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">φnodes(grid::AbstractCurvilinearGrid, ℓx, ℓy, ℓz, with_halos=false)</code></pre><p>Return the positions over the interior nodes on a curvilinear <code>grid</code> in the <span>$φ$</span>-direction for the location <code>ℓλ</code>, <code>ℓφ</code>, <code>ℓz</code>. For <code>Bounded</code> directions, <code>Face</code> nodes include the boundary points.</p><p>See <a href="#Oceananigans.Grids.znodes-Tuple{Oceananigans.Grids.AbstractUnderlyingGrid, Any}"><code>znodes</code></a> for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Grids/nodes_and_spacings.jl#L100-L107">source</a></section></details></article><h2 id="OrthogonalSphericalShellGrids"><a class="docs-heading-anchor" href="#OrthogonalSphericalShellGrids">OrthogonalSphericalShellGrids</a><a id="OrthogonalSphericalShellGrids-1"></a><a class="docs-heading-anchor-permalink" href="#OrthogonalSphericalShellGrids" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Oceananigans.OrthogonalSphericalShellGrids.ConformalCubedSpherePanelGrid"><a class="docstring-binding" href="#Oceananigans.OrthogonalSphericalShellGrids.ConformalCubedSpherePanelGrid"><code>Oceananigans.OrthogonalSphericalShellGrids.ConformalCubedSpherePanelGrid</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ConformalCubedSpherePanelGrid(architecture::AbstractArchitecture = CPU(),
                              FT::DataType = Float64;
                              size,
                              z,
                              topology = (Bounded, Bounded, Bounded),
                              ξ = (-1, 1),
                              η = (-1, 1),
                              radius = Oceananigans.defaults.planet_radius,
                              halo = (1, 1, 1),
                              rotation = nothing,
                              non_uniform_conformal_mapping = false,
                              spacing = GeometricSpacing(),
                              provided_conformal_mapping = nothing)</code></pre><p>Create a <code>OrthogonalSphericalShellGrid</code> that represents a section of a sphere after it has been conformally mapped from the face of a cube. The cube&#39;s coordinates are <code>ξ</code> and <code>η</code> (which, by default, both take values in the range <span>$[-1, 1]$</span>.</p><p>The mapping from the face of the cube to the sphere is done via the <a href="https://github.com/CliMA/CubedSphere.jl">CubedSphere.jl</a> package.</p><p><strong>Positional arguments</strong></p><ul><li><p><code>architecture</code>: Specifies whether arrays of coordinates and spacings are stored on the CPU or GPU. Default: <code>CPU()</code>.</p></li><li><p><code>FT</code> : Floating point data type. Default: <code>Float64</code>.</p></li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>size</code> (required): A 3-tuple prescribing the number of grid points each direction.</p></li><li><p><code>z</code> (required): Either a</p><ol><li>2-tuple that specify the end points of the <span>$z$</span>-domain,</li><li>one-dimensional array specifying the cell interface locations, or</li><li>a single-argument function that takes an index and returns cell interface location.</li></ol></li><li><p><code>topology</code>: A 3-tuple <code>(TX, TY, TZ)</code> specifying the topology of the domain. <code>TX</code>, <code>TY</code>, and <code>TZ</code> specify whether the             <code>x</code>-, <code>y</code>-, and <code>z</code> directions are <code>Periodic</code>, <code>Bounded</code>, <code>Flat</code> or <code>FullyConnected</code>. The topology <code>Flat</code>             indicates that a model does not vary in those directions so that derivatives and interpolation are zero.             The default is <code>topology = (Bounded, Bounded, Bounded)</code>.</p></li><li><p><code>ξ</code>, <code>η</code>: Tuples specifying the ranges of the one-dimensional computational coordinates of the cubed sphere panel           grid. Defaults to (-1, 1) for both.</p></li><li><p><code>radius</code>: The radius of the sphere the grid lives on. By default this is equal to the radius of Earth.</p></li><li><p><code>halo</code>: A 3-tuple of integers specifying the size of the halo region of cells surrounding the physical interior. The         default is 1 halo cell in every direction.</p></li><li><p><code>rotation :: Rotation</code>: Rotation of the conformal cubed sphere panel about some axis that passes through the center of                         the sphere. If <code>nothing</code> is provided (default), then the panel includes the North Pole of the                         sphere in its center. For example, to construct a grid that includes tha South Pole we can                         pass either <code>rotation = RotX(π)</code> or <code>rotation = RotY(π)</code>.</p></li><li><p><code>non_uniform_conformal_mapping</code>: If <code>true</code>, the cubed sphere panel grid will be generated using a non-uniform                                  conformal mapping. The default is <code>false</code>.</p></li><li><p><code>spacing</code>: Specifies the spacing scheme for the non-uniform conformal mapping. Options are <code>GeometricSpacing()</code>            (default) or <code>ExponentialSpacing()</code>.</p></li><li><p><code>provided_conformal_mapping</code>: The conformal mapping supplied by the user. Defaults to nothing.</p></li></ul><p><strong>Examples</strong></p><ul><li>The default conformal cubed sphere panel grid with <code>Float64</code> type:</li></ul><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans, Oceananigans.OrthogonalSphericalShellGrids

julia&gt; grid = ConformalCubedSpherePanelGrid(size=(36, 34, 25), z=(-1000, 0))
36×34×25 OrthogonalSphericalShellGrid{Float64, Bounded, Bounded, Bounded} on CPU with 1×1×1 halo
├── centered at: North Pole, (λ, φ) = (0.0, 90.0)
├── longitude: Bounded  extent 90.0 degrees variably spaced with min(Δλ)=0.616164, max(Δλ)=2.58892
├── latitude:  Bounded  extent 90.0 degrees variably spaced with min(Δφ)=0.664958, max(Δφ)=2.74119
└── z:         Bounded  z ∈ [-1000.0, 0.0]  regularly spaced with Δz=40.0</code></pre><ul><li>The conformal cubed sphere panel that includes the South Pole with <code>Float32</code> type:</li></ul><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans, Oceananigans.OrthogonalSphericalShellGrids, Rotations

julia&gt; grid = ConformalCubedSpherePanelGrid(Float32, size=(36, 34, 25), z=(-1000, 0), rotation=RotY(π))
36×34×25 OrthogonalSphericalShellGrid{Float32, Bounded, Bounded, Bounded} on CPU with 1×1×1 halo
├── centered at: South Pole, (λ, φ) = (0.0, -90.0)
├── longitude: Bounded  extent 90.0 degrees variably spaced with min(Δλ)=0.616167, max(Δλ)=2.58891
├── latitude:  Bounded  extent 90.0 degrees variably spaced with min(Δφ)=0.664956, max(Δφ)=2.7412
└── z:         Bounded  z ∈ [-1000.0, 0.0]  regularly spaced with Δz=40.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/OrthogonalSphericalShellGrids/conformal_cubed_sphere_panel.jl#L171-L264">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.OrthogonalSphericalShellGrids.RotatedLatitudeLongitudeGrid"><a class="docstring-binding" href="#Oceananigans.OrthogonalSphericalShellGrids.RotatedLatitudeLongitudeGrid"><code>Oceananigans.OrthogonalSphericalShellGrids.RotatedLatitudeLongitudeGrid</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RotatedLatitudeLongitudeGrid(arch::AbstractArchitecture = CPU(),
                             FT::DataType = Oceananigans.defaults.FloatType;
                             size,
                             north_pole,
                             longitude,
                             latitude,
                             z,
                             halo = (3, 3, 3),
                             radius = Oceananigans.defaults.planet_radius,
                             topology = (Bounded, Bounded, Bounded))</code></pre><p>Return a <code>RotatedLatitudeLongitudeGrid</code> with arbitrary <code>north_pole</code>, a 2-tuple giving the longitude and latitude of the &quot;grid north pole&quot;, which may differ from the geographic north pole at <code>(0, 90)</code>.</p><p>Note that <code>longitude</code> and <code>latitude</code> are interpreted as applying to the grid <em>before</em> the pole is rotated.</p><p>All other arguments are the same as for <a href="#Oceananigans.Grids.LatitudeLongitudeGrid"><code>LatitudeLongitudeGrid</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Oceananigans
using Oceananigans.OrthogonalSphericalShellGrids: RotatedLatitudeLongitudeGrid

size = (90, 40, 1)
longitude = (0, 360)
latitude = (-80, 80)
z = (0, 1)
grid = RotatedLatitudeLongitudeGrid(; size, longitude, latitude, z, north_pole=(70, 55))

# output
90×40×1 OrthogonalSphericalShellGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3×3×3 halo
├── centered at (λ, φ) = (-110.0, 35.0)
├── longitude: Periodic  extent 360.0 degrees variably spaced with min(Δλ)=0.694593, max(Δλ)=4.0
├── latitude:  Bounded  extent 160.0 degrees  variably spaced with min(Δφ)=4.0, max(Δφ)=4.0
└── z:         Bounded  z ∈ [0.0, 1.0]        regularly spaced with Δz=1.0</code></pre><p>Note that the center latitude <span>$λ = -110$</span> follows from <span>$180 + 70 - 360 = -110$</span>: a clockwise rotation of 70 degrees modulo 360 degrees. We can also make an ordinary LatitudeLongitudeGrid using <code>north_pole = (0, 90)</code>:</p><pre><code class="language-julia hljs">grid = RotatedLatitudeLongitudeGrid(; size, longitude, latitude, z, north_pole=(0, 90))

# output
90×40×1 OrthogonalSphericalShellGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3×3×3 halo
├── centered at (λ, φ) = (180.0, 0.0)
├── longitude: Periodic  extent 360.0 degrees variably spaced with min(Δλ)=0.694593, max(Δλ)=4.0
├── latitude:  Bounded  extent 160.0 degrees  variably spaced with min(Δφ)=4.0, max(Δφ)=4.0
└── z:         Bounded  z ∈ [0.0, 1.0]        regularly spaced with Δz=1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/OrthogonalSphericalShellGrids/rotated_latitude_longitude_grid.jl#L25-L81">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.OrthogonalSphericalShellGrids.TripolarGrid"><a class="docstring-binding" href="#Oceananigans.OrthogonalSphericalShellGrids.TripolarGrid"><code>Oceananigans.OrthogonalSphericalShellGrids.TripolarGrid</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TripolarGrid(arch::Distributed, FT::DataType = Float64; halo = (4, 4, 4), kwargs...)</code></pre><p>Construct a tripolar grid on a distributed <code>arch</code>itecture.</p><div class="admonition is-compat" id="Supported-partitionings-b9edf6acd974dffa"><header class="admonition-header">Supported partitionings<a class="admonition-anchor" href="#Supported-partitionings-b9edf6acd974dffa" title="Permalink"></a></header><div class="admonition-body"><p>Allowed partitionings include:</p><ul><li>Only partition in <code>y</code>, e.g., <code>Distributed(CPU(), partition=Partition(1, 4))</code>.</li><li>Partition both in <code>x</code> and <code>y</code> with <code>x</code> partition even. For example:<ul><li><code>Distributed(CPU(), partition=Partition(2, 4))</code> is supported</li><li><code>Distributed(CPU(), partition=Partition(3, 4))</code> is <em>not</em> supported</li></ul></li></ul><p>Note that partitioning only in <code>x</code>, e.g., <code>Distributed(CPU(), partition=Partition(4))</code> or <code>Distributed(CPU(), partition=Partition(4, 1))</code> is <em>not</em> supported.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/OrthogonalSphericalShellGrids/distributed_tripolar_grid.jl#L26-L41">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.OrthogonalSphericalShellGrids.TripolarGrid"><a class="docstring-binding" href="#Oceananigans.OrthogonalSphericalShellGrids.TripolarGrid"><code>Oceananigans.OrthogonalSphericalShellGrids.TripolarGrid</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TripolarGrid(arch = CPU(), FT::DataType = Float64;
             size,
             southernmost_latitude = -80,
             halo = (4, 4, 4),
             radius = Oceananigans.defaults.planet_radius,
             z = (0, 1),
             north_poles_latitude = 55,
             first_pole_longitude = 70)</code></pre><p>Return an <code>OrthogonalSphericalShellGrid</code> tripolar grid on the sphere. The tripolar grid replaces the North pole singularity with two other singularities at <code>north_poles_latitude</code> that is <em>less</em> than 90ᵒ.</p><p>The grid is constructed following the formulation by <a href="../../references/#Murray1996">Murray (1996)</a>.</p><p><strong>Positional Arguments</strong></p><ul><li><code>arch</code>: The architecture to use for the grid. Default is <code>CPU()</code>.</li><li><code>FT::DataType</code>: The data type to use for the grid. Default is <code>Float64</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>size</code>: The number of cells in the (longitude, latitude, vertical) dimensions.</li><li><code>southernmost_latitude</code>: The southernmost <code>Center</code> latitude of the grid. Default: -80.</li><li><code>halo</code>: The halo size in the (longitude, latitude, vertical) dimensions. Default: (4, 4, 4).</li><li><code>radius</code>: The radius of the spherical shell. Default: <code>Oceananigans.defaults.planet_radius</code>.</li><li><code>z</code>: The vertical <span>$z$</span>-coordinate range of the grid. Could either be:      (i) 2-tuple that specifies the end points of the coordinate,      (ii) an array with the <span>$z$</span> interfaces, or      (iii) a function of <code>k</code> index that returns the locations of cell interfaces            in <span>$z$</span>-direction. Default: (0, 1).</li><li><code>first_pole_longitude</code>: The longitude of the first &quot;north&quot; singularity.                         The second singularity is located at <code>first_pole_longitude + 180ᵒ</code>.                         Default: 75.</li><li><code>north_poles_latitude</code>: The latitude of the &quot;north&quot; singularities. Default: 55.</li></ul><div class="admonition is-warning" id="Longitude-coordinate-must-have-even-number-of-cells-e7f9d2339afffe26"><header class="admonition-header">Longitude coordinate must have even number of cells<a class="admonition-anchor" href="#Longitude-coordinate-must-have-even-number-of-cells-e7f9d2339afffe26" title="Permalink"></a></header><div class="admonition-body"><p><code>size</code> is a 3-tuple of the grid size in longitude, latitude, and vertical directions. Due to requirements of the folding at the north edge of the domain, the longitude size of the grid (i.e., the first component of <code>size</code>) <em>must</em> be an even number!</p></div></div><div class="admonition is-info" id="North-pole-singularities-ef636c56d06c38d0"><header class="admonition-header">North pole singularities<a class="admonition-anchor" href="#North-pole-singularities-ef636c56d06c38d0" title="Permalink"></a></header><div class="admonition-body"><p>The north singularities are located at: <code>i = 1</code>, <code>j = grid.Ny</code> and <code>i = grid.Nx ÷ 2 + 1</code>, <code>j = grid.Ny</code>.</p></div></div><p><strong>References</strong></p><p>Murray, R. J. (1996). Explicit generation of orthogonal grids for ocean models.     Journal of Computational Physics, 126(2), 251-273.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/OrthogonalSphericalShellGrids/tripolar_grid.jl#L26-L79">source</a></section></details></article><h2 id="Immersed-boundaries"><a class="docs-heading-anchor" href="#Immersed-boundaries">Immersed boundaries</a><a id="Immersed-boundaries-1"></a><a class="docs-heading-anchor-permalink" href="#Immersed-boundaries" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Oceananigans.ImmersedBoundaries.GridFittedBottom-Tuple{Any}"><a class="docstring-binding" href="#Oceananigans.ImmersedBoundaries.GridFittedBottom-Tuple{Any}"><code>Oceananigans.ImmersedBoundaries.GridFittedBottom</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">GridFittedBottom(bottom_height, [immersed_condition=CenterImmersedCondition()])</code></pre><p>Return a bottom immersed boundary.</p><p><strong>Keyword Arguments</strong></p><ul><li><p><code>bottom_height</code>: an array or function that gives the height of the                  bottom in absolute <span>$z$</span> coordinates.</p></li><li><p><code>immersed_condition</code>: Determine whether the part of the domain that is                       immersed are all the cell centers that lie below                       <code>bottom_height</code> (<code>CenterImmersedCondition()</code>; default)                       or all the cell faces that lie below <code>bottom_height</code>                       (<code>InterfaceImmersedCondition()</code>). The only purpose of                       <code>immersed_condition</code> to allow <code>GridFittedBottom</code> and                       <code>PartialCellBottom</code> to have the same behavior when the                       minimum fractional cell height for partial cells is set                       to 0.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/ImmersedBoundaries/grid_fitted_bottom.jl#L26-L46">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.ImmersedBoundaries.GridFittedBoundary"><a class="docstring-binding" href="#Oceananigans.ImmersedBoundaries.GridFittedBoundary"><code>Oceananigans.ImmersedBoundaries.GridFittedBoundary</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GridFittedBoundary(mask)</code></pre><p>Return a immersed boundary with a three-dimensional <code>mask</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/ImmersedBoundaries/grid_fitted_boundary.jl#L4-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.ImmersedBoundaries.ImmersedBoundaryCondition-Tuple{}"><a class="docstring-binding" href="#Oceananigans.ImmersedBoundaries.ImmersedBoundaryCondition-Tuple{}"><code>Oceananigans.ImmersedBoundaries.ImmersedBoundaryCondition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ImmersedBoundaryCondition(; interfaces...)</code></pre><p>Return an <code>ImmersedBoundaryCondition</code> with conditions on individual cell <code>interfaces ∈ (west, east, south, north, bottom, top)</code> between the fluid and the immersed boundary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/ImmersedBoundaries/immersed_boundary_condition.jl#L43-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.ImmersedBoundaries.ImmersedBoundaryGrid-Tuple{Oceananigans.Grids.AbstractUnderlyingGrid, Oceananigans.ImmersedBoundaries.AbstractImmersedBoundary}"><a class="docstring-binding" href="#Oceananigans.ImmersedBoundaries.ImmersedBoundaryGrid-Tuple{Oceananigans.Grids.AbstractUnderlyingGrid, Oceananigans.ImmersedBoundaries.AbstractImmersedBoundary}"><code>Oceananigans.ImmersedBoundaries.ImmersedBoundaryGrid</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ImmersedBoundaryGrid(grid, ib::AbstractImmersedBoundary;
                     active_cells_map=false, active_z_columns=active_cells_map)</code></pre><p>Return a grid with an <code>AbstractImmersedBoundary</code> immersed boundary (<code>ib</code>). If <code>active_cells_map</code> or <code>active_z_columns</code> are <code>true</code>, the grid will populate <code>interior_active_cells</code> and <code>active_z_columns</code> fields – a list of active indices in the interior and on a reduced x-y plane, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/ImmersedBoundaries/immersed_boundary_grid.jl#L37-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.ImmersedBoundaries.PartialCellBottom-Tuple{Any}"><a class="docstring-binding" href="#Oceananigans.ImmersedBoundaries.PartialCellBottom-Tuple{Any}"><code>Oceananigans.ImmersedBoundaries.PartialCellBottom</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PartialCellBottom(bottom_height; minimum_fractional_cell_height=0.2)</code></pre><p>Return <code>PartialCellBottom</code> representing an immersed boundary with &quot;partial&quot; bottom cells. That is, the height of the bottommost cell in each column is reduced to fit the provided <code>bottom_height</code>, which may be a <code>Field</code>, <code>Array</code>, or function of <code>(x, y)</code>.</p><p>The height of partial bottom cells is greater than</p><pre><code class="language-julia hljs">minimum_fractional_cell_height * Δz,</code></pre><p>where <code>Δz</code> is the original height of the bottom cell underlying grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/ImmersedBoundaries/partial_cell_bottom.jl#L46-L61">source</a></section></details></article><h2 id="Logger"><a class="docs-heading-anchor" href="#Logger">Logger</a><a id="Logger-1"></a><a class="docs-heading-anchor-permalink" href="#Logger" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Oceananigans.Logger.OceananigansLogger"><a class="docstring-binding" href="#Oceananigans.Logger.OceananigansLogger"><code>Oceananigans.Logger.OceananigansLogger</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">OceananigansLogger(stream::IO=stdout, level=Logging.Info; show_info_source=false)</code></pre><p>Based on Logging.SimpleLogger, it tries to log all messages in the following format:</p><pre><code class="language-julia hljs">[yyyy/mm/dd HH:MM:SS.sss] log_level message [-@-&gt; source_file:line_number]</code></pre><p>where the source of the message between the square brackets is included only if <code>show_info_source=true</code> or if the message is not an info level message.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Logger.jl#L26-L35">source</a></section></details></article><h2 id="Models"><a class="docs-heading-anchor" href="#Models">Models</a><a id="Models-1"></a><a class="docs-heading-anchor-permalink" href="#Models" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Oceananigans.Models.BoundaryConditionOperation-Tuple{Field, Symbol, Oceananigans.AbstractModel}"><a class="docstring-binding" href="#Oceananigans.Models.BoundaryConditionOperation-Tuple{Field, Symbol, Oceananigans.AbstractModel}"><code>Oceananigans.Models.BoundaryConditionOperation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">BoundaryConditionOperation(field::Field, side::Symbol, model::AbstractModel)</code></pre><p>Returns a <code>KernelFunctionOperation</code> that evaluates a <code>field</code>&#39;s boundary condition on the specified <code>side</code> using the properties of <code>model</code>.</p><p><strong>Example</strong></p><p>Build a <code>BoundaryConditionOperation</code> for a top flux boundary condition:</p><pre><code class="language-julia hljs">using Oceananigans
using Oceananigans.Models: BoundaryConditionOperation

grid = RectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1))

c_flux(x, y, t) = sin(2π * x)
c_top_bc = FluxBoundaryCondition(c_flux)
c_bcs = FieldBoundaryConditions(top=c_top_bc)
model = NonhydrostaticModel(; grid, tracers=:c, boundary_conditions=(; c=c_bcs))

c_flux_op = BoundaryConditionOperation(model.tracers.c, :top, model)

# output
KernelFunctionOperation at (Center, Center, ⋅)
├── grid: 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo
├── kernel_function: BoundaryConditionKernelFunction{top}(Flux)
└── arguments: (&quot;Clock&quot;, &quot;NamedTuple&quot;)</code></pre><p>Next, we build a <code>BoundaryConditionField</code> for the top flux, and compute it:</p><pre><code class="language-julia hljs">using Oceananigans.Models: BoundaryConditionField
c_flux_field = BoundaryConditionField(model.tracers.c, :top, model)
compute!(c_flux_field)

# output
16×16×1 Field{Center, Center, Nothing} reduced over dims = (3,) on RectilinearGrid on CPU
├── grid: 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo
├── boundary conditions: FieldBoundaryConditions
│   └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: Nothing
├── operand: KernelFunctionOperation at (Center, Center, ⋅)
├── status: time=0.0
└── data: 22×22×1 OffsetArray(::Array{Float64, 3}, -2:19, -2:19, 1:1) with eltype Float64 with indices -2:19×-2:19×1:1
    └── max=0.980785, min=-0.980785, mean=1.0842e-19</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Models/boundary_condition_operation.jl#L45-L93">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Models.ForcingOperation-Tuple{Symbol, Oceananigans.AbstractModel}"><a class="docstring-binding" href="#Oceananigans.Models.ForcingOperation-Tuple{Symbol, Oceananigans.AbstractModel}"><code>Oceananigans.Models.ForcingOperation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ForcingOperation(name::Symbol, model::AbstractModel)</code></pre><p>Create a <code>KernelFunctionOperation</code> that evaluates the <code>model.forcing</code> for prognostic variable <code>name</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Oceananigans
using Oceananigans.Models: ForcingOperation

grid = RectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1))

damping(x, y, z, t, c, τ) = - c / τ
c_forcing = Forcing(damping, field_dependencies=:c, parameters=60)
model = NonhydrostaticModel(; grid, tracers=:c, forcing=(; c=c_forcing))

c_forcing_op = ForcingOperation(:c, model)

# output
KernelFunctionOperation at (Center, Center, Center)
├── grid: 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo
├── kernel_function: ForcingKernelFunction
└── arguments: (&quot;Clock&quot;, &quot;NamedTuple&quot;)</code></pre><p>Next, we build a <code>ForcingField</code> for the damping, and compute it:</p><pre><code class="language-julia hljs">using Oceananigans.Models: ForcingField
set!(model, c=1)
c_forcing_field = ForcingField(:c, model)
compute!(c_forcing_field)

# output
16×16×16 Field{Center, Center, Center} on RectilinearGrid on CPU
├── grid: 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo
├── boundary conditions: FieldBoundaryConditions
│   └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: Nothing
├── operand: KernelFunctionOperation at (Center, Center, Center)
├── status: time=0.0
└── data: 22×22×22 OffsetArray(::Array{Float64, 3}, -2:19, -2:19, -2:19) with eltype Float64 with indices -2:19×-2:19×-2:19
    └── max=-0.0166667, min=-0.0166667, mean=-0.0166667</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Models/forcing_operation.jl#L21-L67">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Models.seawater_density-NTuple{5, Any}"><a class="docstring-binding" href="#Oceananigans.Models.seawater_density-NTuple{5, Any}"><code>Oceananigans.Models.seawater_density</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Return a <code>KernelFunctionOperation</code> to compute the in-situ <code>seawater_density</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Models/seawater_density.jl#L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Models.seawater_density-Tuple{Union{HydrostaticFreeSurfaceModel, NonhydrostaticModel}}"><a class="docstring-binding" href="#Oceananigans.Models.seawater_density-Tuple{Union{HydrostaticFreeSurfaceModel, NonhydrostaticModel}}"><code>Oceananigans.Models.seawater_density</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">seawater_density(model;
                 temperature = model_temperature(model.buoyancy.formulation, model),
                 salinity = model_salinity(model.buoyancy.formulation, model),
                 geopotential_height = model_geopotential_height(model)</code></pre><p>Return a <code>KernelFunctionOperation</code> that computes the in-situ density of seawater with (gridded) <code>temperature</code>, <code>salinity</code>, and at <code>geopotential_height</code>. To compute the in-situ density, the 55-term polynomial approximation to the equation of state from <a href="https://www.sciencedirect.com/science/article/pii/S1463500315000566?ref=pdf_download&amp;fr=RR-2&amp;rr=813416acba58557b">Roquet et al. (2015)</a> is used. By default, the <code>seawater_density</code> extracts the geopotential height from the <code>model</code> to compute the in-situ density. To compute a potential density at some user-chosen reference geopotential height, set <code>geopotential_height</code> to a constant for the density computation,</p><pre><code class="language-julia hljs">geopotential_height = 0 # sea-surface height
σ₀ = seawater_density(model; geopotential_height)</code></pre><p><strong>Note:</strong> <code>seawater_density</code> must be passed a <code>BoussinesqEquationOfState</code> to compute the density. See the <a href="https://clima.github.io/OceananigansDocumentation/dev/model_setup/buoyancy_and_equation_of_state/#Idealized-nonlinear-equations-of-state">relevant documentation</a> for how to set <code>SeawaterBuoyancy</code> using a <code>BoussinesqEquationOfState</code>.</p><p><strong>Example</strong></p><p>Compute a density <code>Field</code> using the <code>KernelFunctionOperation</code> returned from <code>seawater_density</code></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans, SeawaterPolynomials.TEOS10

julia&gt; using Oceananigans.Models: seawater_density

julia&gt; grid = RectilinearGrid(size=100, z=(-1000, 0), topology=(Flat, Flat, Bounded))
1×1×100 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo
├── Flat x
├── Flat y
└── Bounded  z ∈ [-1000.0, 0.0] regularly spaced with Δz=10.0

julia&gt; tracers = (:T, :S)
(:T, :S)

julia&gt; eos = TEOS10EquationOfState()
BoussinesqEquationOfState{Float64}:
├── seawater_polynomial: TEOS10SeawaterPolynomial{Float64}
└── reference_density: 1020.0

julia&gt; buoyancy = SeawaterBuoyancy(equation_of_state=eos)
SeawaterBuoyancy{Float64}:
├── gravitational_acceleration: 9.80665
└── equation_of_state: BoussinesqEquationOfState{Float64}

julia&gt; model = NonhydrostaticModel(; grid, buoyancy, tracers)
NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)
├── grid: 1×1×100 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo
├── timestepper: RungeKutta3TimeStepper
├── advection scheme: Centered(order=2)
├── tracers: (T, S)
├── closure: Nothing
├── buoyancy: SeawaterBuoyancy with g=9.80665 and BoussinesqEquationOfState{Float64} with ĝ = NegativeZDirection()
└── coriolis: Nothing

julia&gt; set!(model, S = 34.7, T = 0.5)

julia&gt; density_operation = seawater_density(model)
KernelFunctionOperation at (Center, Center, Center)
├── grid: 1×1×100 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo
├── kernel_function: ρ (generic function with 3 methods)
└── arguments: (&quot;SeawaterPolynomials.BoussinesqEquationOfState&quot;, &quot;Field&quot;, &quot;Field&quot;, &quot;KernelFunctionOperation&quot;)

julia&gt; density_field = Field(density_operation)
1×1×100 Field{Center, Center, Center} on RectilinearGrid on CPU
├── grid: 1×1×100 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo
├── boundary conditions: FieldBoundaryConditions
│   └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: ZeroFlux, top: ZeroFlux, immersed: Nothing
├── operand: KernelFunctionOperation at (Center, Center, Center)
├── status: time=0.0
└── data: 1×1×106 OffsetArray(::Array{Float64, 3}, 1:1, 1:1, -2:103) with eltype Float64 with indices 1:1×1:1×-2:103
    └── max=1032.38, min=1027.73, mean=1030.06</code></pre><p>Values for <code>temperature</code>, <code>salinity</code> and <code>geopotential_height</code> can be passed to <code>seawater_density</code> to override the defaults that are obtained from the <code>model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Models/seawater_density.jl#L32-L115">source</a></section></details></article><h3 id="Non-hydrostatic-models"><a class="docs-heading-anchor" href="#Non-hydrostatic-models">Non-hydrostatic models</a><a id="Non-hydrostatic-models-1"></a><a class="docs-heading-anchor-permalink" href="#Non-hydrostatic-models" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="Oceananigans.Models.NonhydrostaticModels.BackgroundField"><a class="docstring-binding" href="#Oceananigans.Models.NonhydrostaticModels.BackgroundField"><code>Oceananigans.Models.NonhydrostaticModels.BackgroundField</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BackgroundField{F, P}</code></pre><p>Temporary container for storing information about <code>BackgroundFields</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Models/NonhydrostaticModels/background_fields.jl#L66-L70">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Models.NonhydrostaticModels.BackgroundField-Tuple{Any}"><a class="docstring-binding" href="#Oceananigans.Models.NonhydrostaticModels.BackgroundField-Tuple{Any}"><code>Oceananigans.Models.NonhydrostaticModels.BackgroundField</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">BackgroundField(func; parameters=nothing)</code></pre><p>Returns a <code>BackgroundField</code> to be passed to <code>NonhydrostaticModel</code> for use as a background velocity or tracer field.</p><p>If <code>parameters</code> is not provided, <code>func</code> must be callable with the signature</p><pre><code class="language-julia hljs">func(x, y, z, t)</code></pre><p>If <code>parameters</code> is provided, <code>func</code> must be callable with the signature</p><pre><code class="language-julia hljs">func(x, y, z, t, parameters)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Models/NonhydrostaticModels/background_fields.jl#L76-L93">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Models.NonhydrostaticModels.NonhydrostaticModel-Tuple{}"><a class="docstring-binding" href="#Oceananigans.Models.NonhydrostaticModels.NonhydrostaticModel-Tuple{}"><code>Oceananigans.Models.NonhydrostaticModels.NonhydrostaticModel</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">NonhydrostaticModel(;           grid,
                                clock = Clock{eltype(grid)}(time = 0),
                            advection = Centered(),
                             buoyancy = nothing,
                             coriolis = nothing,
                         stokes_drift = nothing,
                  forcing::NamedTuple = NamedTuple(),
                              closure = nothing,
      boundary_conditions::NamedTuple = NamedTuple(),
                              tracers = (),
                          timestepper = :RungeKutta3,
        background_fields::NamedTuple = NamedTuple(),
        particles::ParticlesOrNothing = nothing,
biogeochemistry::AbstractBGCOrNothing = nothing,
                           velocities = nothing,
              nonhydrostatic_pressure = CenterField(grid),
         hydrostatic_pressure_anomaly = DefaultHydrostaticPressureAnomaly(),
                       closure_fields = nothing,
                      pressure_solver = nothing,
                     auxiliary_fields = NamedTuple())</code></pre><p>Construct a model for a non-hydrostatic, incompressible fluid on <code>grid</code>, using the Boussinesq approximation when <code>buoyancy != nothing</code>. By default, all Bounded directions are rigid and impenetrable.</p><p><strong>Keyword arguments</strong></p><ul><li><code>grid</code>: (required) The resolution and discrete geometry on which the <code>model</code> is solved. The         architecture (CPU/GPU) that the model is solved on is inferred from the architecture         of the <code>grid</code>. Note that the grid needs to be regularly spaced in the horizontal         dimensions, <span>$x$</span> and <span>$y$</span>.</li><li><code>advection</code>: The scheme that advects velocities and tracers. See <code>Oceananigans.Advection</code>.</li><li><code>buoyancy</code>: The buoyancy model. See <code>Oceananigans.BuoyancyFormulations</code>.</li><li><code>coriolis</code>: Parameters for the background rotation rate of the model.</li><li><code>stokes_drift</code>: Parameters for Stokes drift fields associated with surface waves. Default: <code>nothing</code>.</li><li><code>forcing</code>: <code>NamedTuple</code> of user-defined forcing functions that contribute to solution tendencies.</li><li><code>closure</code>: The turbulence closure for <code>model</code>. See <code>Oceananigans.TurbulenceClosures</code>.</li><li><code>boundary_conditions</code>: <code>NamedTuple</code> containing field boundary conditions.</li><li><code>tracers</code>: A tuple of symbols defining the names of the modeled tracers, or a <code>NamedTuple</code> of            preallocated <code>CenterField</code>s.</li><li><code>timestepper</code>: A symbol that specifies the time-stepping method. Either <code>:QuasiAdamsBashforth2</code> or                <code>:RungeKutta3</code> (default).</li><li><code>background_fields</code>: <code>NamedTuple</code> with background fields (e.g., background flow). Default: <code>nothing</code>.</li><li><code>particles</code>: Lagrangian particles to be advected with the flow. Default: <code>nothing</code>.</li><li><code>biogeochemistry</code>: Biogeochemical model for <code>tracers</code>.</li><li><code>velocities</code>: The model velocities. Default: <code>nothing</code>.</li><li><code>nonhydrostatic_pressure</code>: The nonhydrostatic pressure field. Default: <code>CenterField(grid)</code>.</li><li><code>hydrostatic_pressure_anomaly</code>: An optional field that stores the part of the nonhydrostatic pressure                                 in hydrostatic balance with the buoyancy field. If <code>CenterField(grid)</code> (default), the anomaly is precomputed by                                 vertically integrating the buoyancy field. In this case, the <code>nonhydrostatic_pressure</code> represents                                 only the part of pressure that deviates from the hydrostatic anomaly. If <code>nothing</code>, the anomaly                                 is not computed. Note: for grids with periodic vertical topology, the hydrostatic pressure anomaly                                  is set to <code>nothing</code> by default.</li><li><code>closure_fields</code>: Diffusivity fields. Default: <code>nothing</code>.</li><li><code>pressure_solver</code>: Pressure solver to be used in the model. If <code>nothing</code> (default), the model constructor chooses the default based on the <code>grid</code> provide.</li><li><code>auxiliary_fields</code>: <code>NamedTuple</code> of auxiliary fields. Default: <code>nothing</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L58-L116">source</a></section></details></article><h3 id="Hydrostatic-free-surface-models"><a class="docs-heading-anchor" href="#Hydrostatic-free-surface-models">Hydrostatic free-surface models</a><a id="Hydrostatic-free-surface-models-1"></a><a class="docs-heading-anchor-permalink" href="#Hydrostatic-free-surface-models" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="Oceananigans.Models.HydrostaticFreeSurfaceModels.ExplicitFreeSurface"><a class="docstring-binding" href="#Oceananigans.Models.HydrostaticFreeSurfaceModels.ExplicitFreeSurface"><code>Oceananigans.Models.HydrostaticFreeSurfaceModels.ExplicitFreeSurface</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ExplicitFreeSurface{E, T}</code></pre><p>The explicit free surface solver.</p><ul><li><p><code>η::Any</code>: free surface elevation</p></li><li><p><code>gravitational_acceleration::Any</code>: gravitational accelerations</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Models/HydrostaticFreeSurfaceModels/explicit_free_surface.jl#L7-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Models.HydrostaticFreeSurfaceModels.HydrostaticFreeSurfaceModel-Tuple{}"><a class="docstring-binding" href="#Oceananigans.Models.HydrostaticFreeSurfaceModels.HydrostaticFreeSurfaceModel-Tuple{}"><code>Oceananigans.Models.HydrostaticFreeSurfaceModels.HydrostaticFreeSurfaceModel</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">HydrostaticFreeSurfaceModel(; grid,
                            clock = Clock{Float64}(time = 0),
                            momentum_advection = VectorInvariant(),
                            tracer_advection = Centered(),
                            buoyancy = nothing,
                            coriolis = nothing,
                            free_surface = [default_free_surface],
                            forcing::NamedTuple = NamedTuple(),
                            closure = nothing,
                            timestepper = :QuasiAdamsBashforth2,
                            boundary_conditions::NamedTuple = NamedTuple(),
                            tracers = (:T, :S),
                            particles::ParticlesOrNothing = nothing,
                            biogeochemistry::AbstractBGCOrNothing = nothing,
                            velocities = nothing,
                            pressure = nothing,
                            closure_fields = nothing,
                            auxiliary_fields = NamedTuple(),
                            vertical_coordinate = default_vertical_coordinate(grid))</code></pre><p>Construct a hydrostatic model with a free surface on <code>grid</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>grid</code>: (required) The resolution and discrete geometry on which <code>model</code> is solved. The         architecture (CPU/GPU) that the model is solved is inferred from the architecture         of the <code>grid</code>.</li><li><code>momentum_advection</code>: The scheme that advects velocities. See <code>Oceananigans.Advection</code>.</li><li><code>tracer_advection</code>: The scheme that advects tracers. See <code>Oceananigans.Advection</code>.</li><li><code>buoyancy</code>: The buoyancy model. See <code>Oceananigans.BuoyancyFormulations</code>.</li><li><code>coriolis</code>: Parameters for the background rotation rate of the model.</li><li><code>free_surface</code>: The free surface model. The default free-surface solver depends on the                 geometry of the <code>grid</code>. If the <code>grid</code> is a <code>RectilinearGrid</code> that is                 regularly spaced in the horizontal the default is an <code>ImplicitFreeSurface</code>                 solver with <code>solver_method = :FFTBasedPoissonSolver</code>. In all other cases,                 the default is a <code>SplitExplicitFreeSurface</code>.</li><li><code>tracers</code>: A tuple of symbols defining the names of the modeled tracers, or a <code>NamedTuple</code> of            preallocated <code>CenterField</code>s.</li><li><code>forcing</code>: <code>NamedTuple</code> of user-defined forcing functions that contribute to solution tendencies.</li><li><code>closure</code>: The turbulence closure for <code>model</code>. See <code>Oceananigans.TurbulenceClosures</code>.</li><li><code>timestepper</code>: A symbol that specifies the time-stepping method.                Either <code>:QuasiAdamsBashforth2</code> (default) or <code>:SplitRungeKutta3</code>.</li><li><code>boundary_conditions</code>: <code>NamedTuple</code> containing field boundary conditions.</li><li><code>particles</code>: Lagrangian particles to be advected with the flow. Default: <code>nothing</code>.</li><li><code>biogeochemistry</code>: Biogeochemical model for <code>tracers</code>.</li><li><code>velocities</code>: The model velocities. Default: <code>nothing</code>.</li><li><code>pressure</code>: Hydrostatic pressure field. Default: <code>nothing</code>.</li><li><code>closure_fields</code>: Closure fields. Default: <code>nothing</code>.</li><li><code>auxiliary_fields</code>: <code>NamedTuple</code> of auxiliary fields. Default: <code>nothing</code>.</li><li><code>vertical_coordinate</code>: Algorithm for grid evolution: <code>ZStarCoordinate()</code> or <code>ZCoordinate(grid)</code>.                        Default: <code>default_vertical_coordinate(grid)</code>, which returns <code>ZStarCoordinate(grid)</code>                        for grids with <code>MutableVerticalDiscretization</code> otherwise returns                        <code>ZCoordinate()</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl#L112-L167">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Models.HydrostaticFreeSurfaceModels.ImplicitFreeSurface-Tuple{}"><a class="docstring-binding" href="#Oceananigans.Models.HydrostaticFreeSurfaceModels.ImplicitFreeSurface-Tuple{}"><code>Oceananigans.Models.HydrostaticFreeSurfaceModels.ImplicitFreeSurface</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ImplicitFreeSurface(; solver_method = :Default,
                    gravitational_acceleration = Oceananigans.defaults.gravitational_acceleration,
                    solver_settings...)</code></pre><p>Return an implicit free-surface solver. The implicit free-surface equation is</p><p class="math-container">\[\left [ 𝛁_h ⋅ (H 𝛁_h) - \frac{1}{g Δt^2} \right ] η^{n+1} = \frac{𝛁_h ⋅ 𝐐_⋆}{g Δt} - \frac{η^{n}}{g Δt^2} ,\]</p><p>where <span>$η^n$</span> is the free-surface elevation at the <span>$n$</span>-th time step, <span>$H$</span> is depth, <span>$g$</span> is the gravitational acceleration, <span>$Δt$</span> is the time step, <span>$𝛁_h$</span> is the horizontal gradient operator, and <span>$𝐐_⋆$</span> is the barotropic volume flux associated with the predictor velocity field <span>$𝐮_⋆$</span>, i.e.,</p><p class="math-container">\[𝐐_⋆ = \int_{-H}^0 𝐮_⋆ \, 𝖽 z ,\]</p><p>where</p><p class="math-container">\[𝐮_⋆ = 𝐮^n + \int_{t_n}^{t_{n+1}} 𝐆ᵤ \, 𝖽t .\]</p><p>This equation can be solved, in general, using the <a href="#Oceananigans.Solvers.ConjugateGradientSolver-Tuple{Any}"><code>ConjugateGradientSolver</code></a> but other solvers can be invoked in special cases.</p><p>If <span>$H$</span> is constant, we divide through out to obtain</p><p class="math-container">\[\left ( ∇^2_h - \frac{1}{g H Δt^2} \right ) η^{n+1}  = \frac{1}{g H Δt} \left ( 𝛁_h ⋅ 𝐐_⋆ - \frac{η^{n}}{Δt} \right ) .\]</p><p>Thus, for constant <span>$H$</span> and on grids with regular spacing in <span>$x$</span> and <span>$y$</span> directions, the free surface can be obtained using the <a href="#Oceananigans.Solvers.FFTBasedPoissonSolver"><code>FFTBasedPoissonSolver</code></a>.</p><p><code>solver_method</code> can be either of:</p><ul><li><code>:FastFourierTransform</code> for <a href="#Oceananigans.Solvers.FFTBasedPoissonSolver"><code>FFTBasedPoissonSolver</code></a></li><li><code>:PreconditionedConjugateGradient</code> for <a href="#Oceananigans.Solvers.ConjugateGradientSolver-Tuple{Any}"><code>ConjugateGradientSolver</code></a></li></ul><p>By default, if the grid has regular spacing in the horizontal directions then the <code>:FastFourierTransform</code> is chosen, otherwise the <code>:PreconditionedConjugateGradient</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl#L30-L73">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Models.HydrostaticFreeSurfaceModels.PrescribedVelocityFields-Tuple{}"><a class="docstring-binding" href="#Oceananigans.Models.HydrostaticFreeSurfaceModels.PrescribedVelocityFields-Tuple{}"><code>Oceananigans.Models.HydrostaticFreeSurfaceModels.PrescribedVelocityFields</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PrescribedVelocityFields(; u = ZeroField(),
                           v = ZeroField(),
                           w = ZeroField(),
                           parameters = nothing)</code></pre><p>Builds <code>PrescribedVelocityFields</code> with prescribed functions <code>u</code>, <code>v</code>, and <code>w</code>.</p><p>If <code>isnothing(parameters)</code>, then <code>u, v, w</code> are called with the signature</p><pre><code class="language-julia hljs">u(x, y, z, t) = # something interesting</code></pre><p>If <code>!isnothing(parameters)</code>, then <code>u, v, w</code> are called with the signature</p><pre><code class="language-julia hljs">u(x, y, z, t, parameters) = # something parameterized and interesting</code></pre><p>In the constructor for <code>HydrostaticFreeSurfaceModel</code>, the functions <code>u, v, w</code> are wrapped in <code>FunctionField</code> and associated with the model&#39;s <code>grid</code> and <code>clock</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Models/HydrostaticFreeSurfaceModels/prescribed_hydrostatic_velocity_fields.jl#L23-L45">source</a></section></details></article><h3 id="Split-explicit-free-surface"><a class="docs-heading-anchor" href="#Split-explicit-free-surface">Split-explicit free-surface</a><a id="Split-explicit-free-surface-1"></a><a class="docs-heading-anchor-permalink" href="#Split-explicit-free-surface" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurfaces.AdamsBashforth3Scheme-Tuple{}"><a class="docstring-binding" href="#Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurfaces.AdamsBashforth3Scheme-Tuple{}"><code>Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurfaces.AdamsBashforth3Scheme</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">AdamsBashforth3Scheme(; β = 0.281105,
                        α = 1.5 + β,
                        θ = -0.5 - 2β,
                        γ = 0.088,
                        δ = 0.614,
                        ϵ = 0.013,
                        μ = 1 - δ - γ - ϵ)</code></pre><p>Create an instance of <code>AdamsBashforth3Scheme</code> with the specified parameters. This scheme is used for substepping in the split-explicit free surface solver, where an AB3 extrapolation is used to evaluate barotropic velocities and free surface at time-step <code>m + 1/2</code>:</p><p>The equations are evolved as follows:</p><p class="math-container">\[\begin{gather}
η^{m+1} = η^m - Δτ g H (∂_x Ũ + ∂y Ṽ), \\
U^{m+1} = U^m - Δτ (∂_x η̃ - G^U), \\
V^{m+1} = V^m - Δτ (∂_y η̃ - G^V),
\end{gather}\]</p><p>where <code>η̃</code>, <code>Ũ</code> and <code>Ṽ</code> are the AB3 time-extrapolated values of free surface, barotropic zonal and meridional velocities, respectively:</p><p class="math-container">\[\begin{gather}
Ũ = α U^m + θ U^{m-1} + β U^{m-2}, \\
Ṽ = α V^m + θ V^{m-1} + β V^{m-2}, \\
η̃ = δ η^{m+1} + μ η^m + γ η^{m-1} + ϵ η^{m-2}.
\end{gather}\]</p><p>The default values for the time-extrapolation coefficients, described by <a href="../../references/#Shchepetkin2005">Shchepetkin and McWilliams (2005)</a>, correspond to the best stability range for the AB3 algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Models/HydrostaticFreeSurfaceModels/SplitExplicitFreeSurfaces/split_explicit_timesteppers.jl#L38-L75">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurfaces.FixedSubstepNumber"><a class="docstring-binding" href="#Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurfaces.FixedSubstepNumber"><code>Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurfaces.FixedSubstepNumber</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>An internal type for the <code>SplitExplicitFreeSurface</code> that allows substepping with a fixed number of substeps with time step size of <code>fractional_step_size * Δt_baroclinic</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Models/HydrostaticFreeSurfaceModels/SplitExplicitFreeSurfaces/split_explicit_free_surface.jl#L278-L280">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurfaces.FixedTimeStepSize"><a class="docstring-binding" href="#Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurfaces.FixedTimeStepSize"><code>Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurfaces.FixedTimeStepSize</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>An internal type for the <code>SplitExplicitFreeSurface</code> that allows substepping with a fixed <code>Δt_barotropic</code> based on a CFL condition </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Models/HydrostaticFreeSurfaceModels/SplitExplicitFreeSurfaces/split_explicit_free_surface.jl#L271-L273">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurfaces.ForwardBackwardScheme"><a class="docstring-binding" href="#Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurfaces.ForwardBackwardScheme"><code>Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurfaces.ForwardBackwardScheme</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ForwardBackwardScheme</code></pre><p>A timestepping scheme used for substepping in the split-explicit free surface solver.</p><p>The equations are evolved as follows:</p><p class="math-container">\[\begin{gather}
η^{m+1} = η^m - Δτ (∂_x U^m + ∂_y V^m), \\
U^{m+1} = U^m - Δτ (∂_x η^{m+1} - G^U), \\
V^{m+1} = V^m - Δτ (∂_y η^{m+1} - G^V).
\end{gather}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Models/HydrostaticFreeSurfaceModels/SplitExplicitFreeSurfaces/split_explicit_timesteppers.jl#L3-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurfaces.SplitExplicitFreeSurface"><a class="docstring-binding" href="#Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurfaces.SplitExplicitFreeSurface"><code>Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurfaces.SplitExplicitFreeSurface</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SplitExplicitFreeSurface(grid = nothing;
                         gravitational_acceleration = Oceananigans.defaults.gravitational_acceleration,
                         substeps = nothing,
                         cfl = nothing,
                         fixed_Δt = nothing,
                         averaging_kernel = averaging_shape_function,
                         timestepper = ForwardBackwardScheme())</code></pre><p>Return a <code>SplitExplicitFreeSurface</code> representing an explicit time discretization of a free surface dynamics with <code>gravitational_acceleration</code>. The free surface dynamics are solved by discretizing:</p><p class="math-container">\[\begin{gather}
∂_t η = - \nabla ⋅ U, \\
∂_t U = - g H \nabla η + G^U,
\end{gather}\]</p><p>where <span>$η$</span> is the free surface displacement, <span>$U$</span> is the barotropic velocity vector, calculated as the vertical integral of the velocity field <span>$u$</span> and <span>$v$</span>, <span>$H$</span> is the column depth, <span>$G^U$</span> is the slow forcing calculated as the integral of the tendency of <span>$u$</span> and <span>$v$</span>, and <span>$g$</span> is the gravitational acceleration.</p><p>The discretized equations are solved within a baroclinic timestep (<span>$Δt$</span>) by substepping with a <span>$Δτ &lt; Δt$</span>. The barotropic velocities are filtered throughout the substepping and, finally, the barotropic mode of the velocities  at the new time step is corrected with the filtered velocities. The complementary filtered transport barotropic velocities,  <code>Ũ</code> and <code>Ṽ</code>, are used as transport barotropic velocities for tracer advection.</p><p><strong>Fields</strong></p><p>When materialized (see <a href="@ref"><code>materialize_free_surface</code></a>), a <code>SplitExplicitFreeSurface</code> contains the following fields:</p><ul><li><p><code>η</code>: Free surface displacement field (<code>ZFaceField</code> at the top of the grid).</p></li><li><p><code>barotropic_velocities</code>: A <code>NamedTuple</code> with <code>U</code> (zonal) and <code>V</code> (meridional) barotropic velocity fields, representing the vertically-integrated horizontal velocities. These are <code>Field{Face, Center, Nothing}</code> and <code>Field{Center, Face, Nothing}</code>, respectively.</p></li><li><p><code>filtered_state</code>: A <code>NamedTuple</code> containing filtered/averaged quantities computed during barotropic substepping:</p><ul><li><code>η̅</code>: Filtered free surface displacement field.</li><li><code>U̅</code>, <code>V̅</code>: Filtered barotropic velocities.</li><li><code>Ũ</code>, <code>Ṽ</code>: complementary filtered transport barotropic velocities, used as transport barotropic velocities for tracer advection.</li></ul></li><li><p><code>gravitational_acceleration</code>: Gravitational acceleration constant (of type <code>FloatType</code>).</p></li><li><p><code>kernel_parameters</code>: Kernel parameters for subcycling kernel launching. For <code>FixedTimeStepSize</code> substepping, this is the symbol <code>:xy</code>. For <code>FixedSubstepNumber</code> substepping with connected topologies, this is a <code>KernelParameters</code> struct that defines the kernel execution ranges.</p></li><li><p><code>substepping</code>: Either <code>FixedSubstepNumber</code> or <code>FixedTimeStepSize</code>, controlling the barotropic substepping strategy. <code>FixedSubstepNumber</code> uses a fixed number of substeps with fractional step sizes, while <code>FixedTimeStepSize</code> uses a fixed barotropic time step size based on a CFL condition.</p></li><li><p><code>timestepper</code>: Time stepping scheme for barotropic advancement. Either <code>ForwardBackwardScheme()</code> (which contains no auxiliary fields) or <code>AdamsBashforth3Scheme</code> (which contains auxiliary fields <code>ηᵐ</code>, <code>ηᵐ⁻¹</code>, <code>ηᵐ⁻²</code>, <code>Uᵐ⁻¹</code>, <code>Uᵐ⁻²</code>, <code>Vᵐ⁻¹</code>, <code>Vᵐ⁻²</code> for storing previous time step values, along with extrapolation coefficients).</p></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>gravitational_acceleration</code>: the gravitational acceleration (default: <code>Oceananigans.defaults.gravitational_acceleration</code>)</p></li><li><p><code>substeps</code>: The number of substeps that divide the range <code>(t, t + 2Δt)</code>, where <code>Δt</code> is the baroclinic             timestep. Note that some averaging functions do not require substepping until <code>2Δt</code>.             The number of substeps is reduced automatically to the last index of <code>averaging_kernel</code>             for which <code>averaging_kernel &gt; 0</code>.</p></li><li><p><code>cfl</code>: If set then the number of <code>substeps</code> are computed based on the advective timescale imposed from        the barotropic gravity-wave speed that corresponds to depth <code>grid.Lz</code>. If <code>fixed_Δt</code> is provided,        then the number of <code>substeps</code> adapts to maintain an exact <code>cfl</code>. If not, the effective cfl will        always be lower than the specified <code>cfl</code> provided that the baroclinic time step satisfies        <code>Δt_baroclinic &lt; fixed_Δt</code>.</p></li></ul><div class="admonition is-info" id="Needed-keyword-arguments-1a286255def69036"><header class="admonition-header">Needed keyword arguments<a class="admonition-anchor" href="#Needed-keyword-arguments-1a286255def69036" title="Permalink"></a></header><div class="admonition-body"><p>Either <code>substeps</code> <em>or</em> <code>cfl</code> need to be prescribed.</p><p>When <code>cfl</code> is prescribed then <code>grid</code> is also required as a positional argument.</p></div></div><ul><li><p><code>fixed_Δt</code>: The maximum baroclinic timestep allowed. If <code>fixed_Δt</code> is a <code>nothing</code> and a cfl is provided,             then the number of substeps will be computed on the fly from the baroclinic time step to             maintain a constant cfl.</p></li><li><p><code>averaging_kernel</code>: A function of <code>τ</code> used to average the barotropic transport <code>U</code> and the free surface                     <code>η</code> within the barotropic advancement. <code>τ</code> is the fractional substep going from 0 to 2                     with the baroclinic time step <code>t + Δt</code> located at <code>τ = 1</code>. The <code>averaging_kernel</code>                     function should be centered at <code>τ = 1</code>, that is, <span>$∑ (aₘ m / M) = 1$</span>, where the                     the summation occurs for <span>$m = 1, ..., M_*$</span>. Here, <span>$m = 0$</span> and <span>$m = M$</span> correspond                     to the two consecutive baroclinic timesteps between which the barotropic timestepping                     occurs and <span>$M_*$</span> corresponds to the last barotropic time step for which the                     <code>averaging_kernel &gt; 0</code>. By default, the averaging kernel described by                     <a href="../../references/#Shchepetkin2005">Shchepetkin and McWilliams (2005)</a> is used.</p></li><li><p><code>timestepper</code>: Time stepping scheme used for the barotropic advancement. Choose one of:</p><ul><li><code>ForwardBackwardScheme()</code> (default): <code>η = f(U)</code>   then <code>U = f(η)</code>,</li><li><code>AdamsBashforth3Scheme()</code>: <code>η = f(U, Uᵐ⁻¹, Uᵐ⁻²)</code> then <code>U = f(η, ηᵐ, ηᵐ⁻¹, ηᵐ⁻²)</code>.</li></ul></li></ul><p><strong>References</strong></p><p>Shchepetkin, A. F., and McWilliams, J. C. (2005). The regional oceanic modeling system (ROMS): a split-explicit, free-surface, topography-following-coordinate oceanic model. Ocean Modelling, 9(4), 347-404.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Models/HydrostaticFreeSurfaceModels/SplitExplicitFreeSurfaces/split_explicit_free_surface.jl#L20-L119">source</a></section></details></article><h3 id="Shallow-water-models"><a class="docs-heading-anchor" href="#Shallow-water-models">Shallow-water models</a><a id="Shallow-water-models-1"></a><a class="docs-heading-anchor-permalink" href="#Shallow-water-models" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="Oceananigans.Models.ShallowWaterModels.ShallowWaterModel-Tuple{}"><a class="docstring-binding" href="#Oceananigans.Models.ShallowWaterModels.ShallowWaterModel-Tuple{}"><code>Oceananigans.Models.ShallowWaterModels.ShallowWaterModel</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ShallowWaterModel(; grid,
                    gravitational_acceleration,
                          clock = Clock{eltype(grid)}(time = 0),
             momentum_advection = UpwindBiased(order=5),
               tracer_advection = WENO(),
                 mass_advection = WENO(),
                       coriolis = nothing,
            forcing::NamedTuple = NamedTuple(),
                        closure = nothing,
                     bathymetry = nothing,
                        tracers = (),
                 closure_fields = nothing,
boundary_conditions::NamedTuple = NamedTuple(),
            timestepper::Symbol = :RungeKutta3,
                    formulation = ConservativeFormulation())</code></pre><p>Construct a shallow water model on <code>grid</code> with <code>gravitational_acceleration</code> constant.</p><p><strong>Keyword arguments</strong></p><ul><li><code>grid</code>: (required) The resolution and discrete geometry on which <code>model</code> is solved. The         architecture (CPU/GPU) that the model is solve is inferred from the architecture         of the grid.</li><li><code>gravitational_acceleration</code>: (required) The gravitational acceleration constant.</li><li><code>clock</code>: The <code>clock</code> for the model.</li><li><code>momentum_advection</code>: The scheme that advects velocities. See <code>Oceananigans.Advection</code>. Default: <code>UpwindBiased(order=5)</code>.</li><li><code>tracer_advection</code>: The scheme that advects tracers. See <code>Oceananigans.Advection</code>. Default: <code>WENO()</code>.</li><li><code>mass_advection</code>: The scheme that advects the mass equation. See <code>Oceananigans.Advection</code>. Default: <code>WENO()</code>.</li><li><code>coriolis</code>: Parameters for the background rotation rate of the model.</li><li><code>forcing</code>: <code>NamedTuple</code> of user-defined forcing functions that contribute to solution tendencies.</li><li><code>closure</code>: The turbulence closure for <code>model</code>. See <code>Oceananigans.TurbulenceClosures</code>.</li><li><code>bathymetry</code>: The bottom bathymetry.</li><li><code>tracers</code>: A tuple of symbols defining the names of the modeled tracers, or a <code>NamedTuple</code> of            preallocated <code>CenterField</code>s.</li><li><code>closure_fields</code>: Stores diffusivity fields when the closures require a diffusivity to be                       calculated at each timestep.</li><li><code>boundary_conditions</code>: <code>NamedTuple</code> containing field boundary conditions.</li><li><code>timestepper</code>: A symbol that specifies the time-stepping method. Either <code>:QuasiAdamsBashforth2</code> or                <code>:RungeKutta3</code> (default).</li><li><code>formulation</code>: Whether the dynamics are expressed in conservative form (<code>ConservativeFormulation()</code>;                default) or in non-conservative form with a vector-invariant formulation for the                non-linear terms (<code>VectorInvariantFormulation()</code>).</li></ul><div class="admonition is-warning" id="Formulation-grid-compatibility-requirements-615bcdd92797ee3d"><header class="admonition-header">Formulation-grid compatibility requirements<a class="admonition-anchor" href="#Formulation-grid-compatibility-requirements-615bcdd92797ee3d" title="Permalink"></a></header><div class="admonition-body"><p>The <code>ConservativeFormulation()</code> requires <code>RectilinearGrid</code>. Use <code>VectorInvariantFormulation()</code> with <code>LatitudeLongitudeGrid</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Models/ShallowWaterModels/shallow_water_model.jl#L60-L110">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Models.ShallowWaterModels.ShallowWaterScalarDiffusivity"><a class="docstring-binding" href="#Oceananigans.Models.ShallowWaterModels.ShallowWaterScalarDiffusivity"><code>Oceananigans.Models.ShallowWaterModels.ShallowWaterScalarDiffusivity</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ShallowWaterScalarDiffusivity([FT::DataType=Float64;]
                              ν=0, ξ=0, discrete_form=false)</code></pre><p>Return a scalar diffusivity for the shallow water model.</p><p>The diffusivity for the shallow water model is calculated as <code>h * ν</code> so that we get a viscous term in the form <span>$h^{-1} 𝛁 ⋅ (h ν t)$</span>, where <span>$t$</span> is the 2D stress tensor plus a trace, i.e., <span>$t = 𝛁𝐮 + (𝛁𝐮)^T - ξ I ⋅ (𝛁 ⋅ 𝐮)$</span>.</p><p>With the <code>VectorInvariantFormulation()</code> (that evolves <span>$u$</span> and <span>$v$</span>) we compute <span>$h^{-1} 𝛁(ν h 𝛁 t)$</span>, while with the <code>ConservativeFormulation()</code> (that evolves <span>$u h$</span> and <span>$v h$</span>) we compute <span>$𝛁 (ν h 𝛁 t)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Models/ShallowWaterModels/shallow_water_diffusion_operators.jl#L26-L39">source</a></section></details></article><h3 id="Lagrangian-particle-tracking"><a class="docs-heading-anchor" href="#Lagrangian-particle-tracking">Lagrangian particle tracking</a><a id="Lagrangian-particle-tracking-1"></a><a class="docs-heading-anchor-permalink" href="#Lagrangian-particle-tracking" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="Oceananigans.Models.LagrangianParticleTracking.DroguedParticleDynamics"><a class="docstring-binding" href="#Oceananigans.Models.LagrangianParticleTracking.DroguedParticleDynamics"><code>Oceananigans.Models.LagrangianParticleTracking.DroguedParticleDynamics</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DroguedParticleDynamics(depths)</code></pre><p><code>DroguedParticleDynamics</code> goes in the <code>dynamics</code> slot of <code>LagrangianParticles</code>  and modifies their behaviour to mimic the behaviour of bouys which are  drogued at <code>depths</code>. The particles remain at the their <code>z</code> position so the &quot;measurment depth can be set&quot;, and then are advected in the <code>x</code> and <code>y</code> directions according to the velocity field at <code>depths</code>.</p><p><code>depths</code> should be an (abstract) array of length <code>length(particles)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; n = 10
10

julia&gt; dynamics = DroguedParticleDynamics(-10:10/n:0)
DroguedParticleDynamics{StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}(-10.0:1.0:0.0)

julia&gt; particles = LagrangianParticles(; x = zeros(n), y = zeros(n), z = zeros(n), dynamics)
10 LagrangianParticles with eltype Particle:
├── 3 properties: (:x, :y, :z)
├── particle-wall restitution coefficient: 1.0
├── 0 tracked fields: ()
└── dynamics: DroguedParticleDynamics{StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Models/LagrangianParticleTracking/drogued_dynamics.jl#L1-L33">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Models.LagrangianParticleTracking.LagrangianParticles-Tuple{StructArrays.StructArray}"><a class="docstring-binding" href="#Oceananigans.Models.LagrangianParticleTracking.LagrangianParticles-Tuple{StructArrays.StructArray}"><code>Oceananigans.Models.LagrangianParticleTracking.LagrangianParticles</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">LagrangianParticles(particles::StructArray;
                    restitution = 1.0,
                    tracked_fields::NamedTuple=NamedTuple(),
                    dynamics = no_dynamics,
                    parameters = nothing)</code></pre><p>Construct some <code>LagrangianParticles</code> that can be passed to a model. The <code>particles</code> should be a <code>StructArray</code> and can contain custom fields. The coefficient of restitution for particle-wall collisions is specified by <code>restitution</code>.</p><p>A number of <code>tracked_fields</code> may be passed in as a <code>NamedTuple</code> of fields. Each particle will track the value of each field. Each tracked field must have a corresponding particle property. So if <code>T</code> is a tracked field, then <code>T</code> must also be a custom particle property.</p><p><code>dynamics</code> is a function of <code>(lagrangian_particles, model, Δt)</code> that is called prior to advecting particles. <code>parameters</code> can be accessed inside the <code>dynamics</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl#L69-L85">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Models.LagrangianParticleTracking.LagrangianParticles-Tuple{}"><a class="docstring-binding" href="#Oceananigans.Models.LagrangianParticleTracking.LagrangianParticles-Tuple{}"><code>Oceananigans.Models.LagrangianParticleTracking.LagrangianParticles</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">LagrangianParticles(; x, y, z, restitution=1.0, dynamics=no_dynamics, parameters=nothing)</code></pre><p>Construct some <code>LagrangianParticles</code> that can be passed to a model. The particles have initial locations <code>x</code>, <code>y</code>, and <code>z</code>. The coefficient of restitution for particle-wall collisions is specified by <code>restitution</code>.</p><p><code>dynamics</code> is a function of <code>(lagrangian_particles, model, Δt)</code> that is called prior to advecting particles. <code>parameters</code> can be accessed inside the <code>dynamics</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl#L48-L56">source</a></section></details></article><h3 id="VarianceDissipationComputations"><a class="docs-heading-anchor" href="#VarianceDissipationComputations">VarianceDissipationComputations</a><a id="VarianceDissipationComputations-1"></a><a class="docs-heading-anchor-permalink" href="#VarianceDissipationComputations" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="Oceananigans.Models.VarianceDissipationComputations.VarianceDissipation-Tuple{Any, Any}"><a class="docstring-binding" href="#Oceananigans.Models.VarianceDissipationComputations.VarianceDissipation-Tuple{Any, Any}"><code>Oceananigans.Models.VarianceDissipationComputations.VarianceDissipation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">VarianceDissipation(tracer_name, grid;
                    Uⁿ⁻¹ = VelocityFields(grid),
                    Uⁿ   = VelocityFields(grid))</code></pre><p>Construct a <code>VarianceDissipation</code> object for a tracer called <code>tracer_name</code> that lives on <code>grid</code>. This function computes the variance dissipation diagnostics for the specified tracer in the model. These include the numerical dissipation implicit to the advection scheme and the explicit dissipation associated to closures.</p><p>This diagnostic is especially useful for models that use a dissipative advection scheme like <a href="#Oceananigans.Advection.WENO"><code>WENO</code></a> or <a href="@ref"><code>UpwindBiased</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>tracer_name</code>: The name of the tracer for which variance dissipation is computed. This should                be a <code>Symbol</code>. When calling <code>ϵ::VarianceDissipation</code> on the model, this name is                used to identify the tracer in the model&#39;s state.</li><li><code>grid</code>: The grid on which the tracer is defined.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>Uⁿ⁻¹</code>: The velocity field at the previous time step. Default: <code>VelocityFields(grid)</code>.</li><li><code>Uⁿ</code>: The velocity field at the current time step. Default: <code>VelocityFields(grid)</code>.</li></ul><div class="admonition is-compat" id="Time-stepper-compatibility-2aa61fc57c0aede"><header class="admonition-header">Time stepper compatibility<a class="admonition-anchor" href="#Time-stepper-compatibility-2aa61fc57c0aede" title="Permalink"></a></header><div class="admonition-body"><p>At the moment, the variance dissipation diagnostic is supported only for a <a href="#Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper-Union{Tuple{IT}, Tuple{Any, Any}, Tuple{Any, Any, Any}} where IT"><code>QuasiAdamsBashforth2TimeStepper</code></a> and a <a href="#Oceananigans.TimeSteppers.SplitRungeKutta3TimeStepper"><code>SplitRungeKutta3TimeStepper</code></a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Models/VarianceDissipationComputations/VarianceDissipationComputations.jl#L47-L77">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Models.VarianceDissipationComputations.flatten_dissipation_fields-Tuple{Oceananigans.Models.VarianceDissipationComputations.VarianceDissipation}"><a class="docstring-binding" href="#Oceananigans.Models.VarianceDissipationComputations.flatten_dissipation_fields-Tuple{Oceananigans.Models.VarianceDissipationComputations.VarianceDissipation}"><code>Oceananigans.Models.VarianceDissipationComputations.flatten_dissipation_fields</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">flatten_dissipation_fields(t::VarianceDissipation)</code></pre><p>Flatten the dissipation fields of a <code>VarianceDissipation</code> object into a named tuple containing:</p><ul><li>The dissipation associated with the advection scheme in fields named <code>A-tracername-dir</code></li><li>The dissipation associated with the closures in fields names <code>D-tracername-dir</code></li><li>The squared gradients (necessary for computing an &quot;effective diffusivity&quot;) in fields named <code>G-tracername-dir</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Models/VarianceDissipationComputations/flatten_dissipation_fields.jl#L1-L9">source</a></section></details></article><h2 id="MultiRegion"><a class="docs-heading-anchor" href="#MultiRegion">MultiRegion</a><a id="MultiRegion-1"></a><a class="docs-heading-anchor-permalink" href="#MultiRegion" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Oceananigans.MultiRegion.ConformalCubedSphereGrid"><a class="docstring-binding" href="#Oceananigans.MultiRegion.ConformalCubedSphereGrid"><code>Oceananigans.MultiRegion.ConformalCubedSphereGrid</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ConformalCubedSphereGrid(filepath::AbstractString, arch::AbstractArchitecture=CPU(), FT=Float64;
                         Nz,
                         z,
                         panel_halo = (4, 4, 4),
                         panel_topology = (FullyConnected, FullyConnected, Bounded),
                         radius = Oceananigans.defaults.planet_radius)</code></pre><p>Load a <code>ConformalCubedSphereGrid</code> from <code>filepath</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/MultiRegion/cubed_sphere_grid.jl#L367-L376">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.MultiRegion.ConformalCubedSphereGrid"><a class="docstring-binding" href="#Oceananigans.MultiRegion.ConformalCubedSphereGrid"><code>Oceananigans.MultiRegion.ConformalCubedSphereGrid</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ConformalCubedSphereGrid(arch=CPU(), FT=Float64;
                         panel_size,
                         z,
                         horizontal_direction_halo = 1,
                         z_halo = horizontal_direction_halo,
                         horizontal_topology = FullyConnected,
                         z_topology = Bounded,
                         radius = Oceananigans.defaults.planet_radius,
                         non_uniform_conformal_mapping = false,
                         spacing = GeometricSpacing(),
                         provided_conformal_mapping = nothing,
                         partition = CubedSpherePartition(; R = 1))</code></pre><p>Return a <code>ConformalCubedSphereGrid</code> that comprises of six <a href="#Oceananigans.OrthogonalSphericalShellGrids.ConformalCubedSpherePanelGrid"><code>ConformalCubedSpherePanelGrid</code></a>s; we refer to each of these grids as a &quot;panel&quot;. Each panel corresponds to a face of the cube.</p><p>The keyword arguments prescribe the properties of each of the panels. Only the topology in the vertical direction can be prescribed and that&#39;s done via the <code>z_topology</code> keyword argument (default: <code>Bounded</code>). Topologies in both horizontal directions for a <code>ConformalCubedSphereGrid</code> are <em>always</em> <a href="#Oceananigans.Grids.FullyConnected"><code>FullyConnected</code></a>.</p><p>Halo size in both horizontal dimensions <em>must</em> be equal; this is prescribed via the <code>horizontal_halo :: Integer</code> keyword argument. The number of halo points in the <span>$z$</span>-direction is prescribed by the <code>z_halo :: Integer</code> keyword argument.</p><p>The connectivity between the <code>ConformalCubedSphereGrid</code> panels is depicted below.</p><pre><code class="language-julia hljs">                          +==========+==========+
                          ∥    ↑     ∥    ↑     ∥
                          ∥    1W    ∥    1S    ∥
                          ∥←3N P5 6W→∥←5E P6 2S→∥
                          ∥    4N    ∥    4E    ∥
                          ∥    ↓     ∥    ↓     ∥
               +==========+==========+==========+
               ∥    ↑     ∥    ↑     ∥
               ∥    5W    ∥    5S    ∥
               ∥←1N P3 4W→∥←3E P4 6S→∥
               ∥    2N    ∥    2E    ∥
               ∥    ↓     ∥    ↓     ∥
    +==========+==========+==========+
    ∥    ↑     ∥    ↑     ∥
    ∥    3W    ∥    3S    ∥
    ∥←5N P1 2W→∥←1E P2 4S→∥
    ∥    6N    ∥    6E    ∥
    ∥    ↓     ∥    ↓     ∥
    +==========+==========+</code></pre><p>The North Pole of the sphere lies in the center of panel 3 (P3) and the South Pole in the center of panel 6 (P6).</p><p>The <code>partition</code> keyword argument prescribes the partitioning in regions within each panel; see <a href="#Oceananigans.MultiRegion.CubedSpherePartition-Tuple{}"><code>CubedSpherePartition</code></a>. For example, a <code>CubedSpherePartition(; R=2)</code> implies that each of the panels are partitioned into 2 regions in each dimension; this adds up, e.g., to 24 regions for the  whole sphere. In the depiction below, the intra-panel <code>x, y</code> indices are depicted in the center of each region and the overall region index is shown at the bottom right of each region.</p><pre><code class="language-julia hljs">                                                +==========+==========+==========+==========+
                                                ∥    ↑     |    ↑     ∥    ↑     |    ↑     ∥
                                                ∥          |          ∥          |          ∥
                                                ∥← (1, 2) →|← (2, 2) →∥← (1, 2) →|← (2, 2) →∥
                                                ∥          |          ∥          |          ∥
                                                ∥    ↓  19 |    ↓  20 ∥    ↓  23 |    ↓  24 ∥
                                                +-------- P 5 --------+-------- P 6 --------+
                                                ∥    ↑     |    ↑     ∥    ↑     |    ↑     ∥
                                                ∥          |          ∥          |          ∥
                                                ∥← (1, 1) →|← (2, 1) →∥← (1, 1) →|← (2, 1) →∥
                                                ∥          |          ∥          |          ∥
                                                ∥    ↓  17 |    ↓  18 ∥    ↓  21 |    ↓  22 ∥
                          +==========+==========+==========+==========+==========+==========+
                          ∥    ↑     |    ↑     ∥    ↑     |    ↑     ∥
                          ∥          |          ∥          |          ∥
                          ∥← (1, 2) →|← (2, 2) →∥← (1, 2) →|← (2, 2) →∥
                          ∥          |          ∥          |          ∥
                          ∥    ↓ 11  |    ↓  12 ∥    ↓  15 |    ↓  16 ∥
                          +-------- P 3 --------+-------- P 4 --------+
                          ∥    ↑     |    ↑     ∥    ↑     |    ↑     ∥
                          ∥          |          ∥          |          ∥
                          ∥← (1, 1) →|← (2, 1) →∥← (1, 1) →|← (2, 1) →∥
                          ∥          |          ∥          |          ∥
                          ∥    ↓  9  |    ↓  10 ∥    ↓  13 |    ↓  14 ∥
    +==========+==========+==========+==========+==========+==========+
    ∥    ↑     |    ↑     ∥    ↑     |    ↑     ∥
    ∥          |          ∥          |          ∥
    ∥← (1, 2) →|← (2, 2) →∥← (1, 2) →|← (2, 2) →∥
    ∥          |          ∥          |          ∥
    ∥    ↓   3 |    ↓   4 ∥    ↓   7 |    ↓   8 ∥
    +-------- P 1 --------+-------- P 2 --------+
    ∥    ↑     |    ↑     ∥    ↑     |    ↑     ∥
    ∥          |          ∥          |          ∥
    ∥← (1, 1) →|← (2, 1) →∥← (1, 1) →|← (2, 1) →∥
    ∥          |          ∥          |          ∥
    ∥    ↓   1 |    ↓   2 ∥    ↓   5 |    ↓   6 ∥
    +==========+==========+==========+==========+</code></pre><p>Below, we show in detail panels 1 and 2 and the connectivity of each panel.</p><pre><code class="language-julia hljs">+===============+==============+==============+===============+
∥       ↑       |      ↑       ∥      ↑       |      ↑        ∥
∥      11W      |      9W      ∥      9S      |     10S       ∥
∥←19N (2, 1) 4W→|←3E (2, 2) 7W→∥←4E (2, 1) 8W→|←7E (2, 2) 13S→∥
∥       1N      |      2N      ∥      5N      |      6N       ∥
∥       ↓     3 |      ↓     4 ∥      ↓     7 |      ↓      8 ∥
+------------- P 1 ------------+------------ P 2 -------------+
∥       ↑       |      ↑       ∥      ↑       |      ↑        ∥
∥       3S      |      4S      ∥      7S      |      8S       ∥
∥←20N (1, 1) 2W→|←1E (2, 1) 5W→∥←2E (1, 1) 6W→|←5E (2, 1) 14S→∥
∥      23N      |     24N      ∥     24N      |     22N       ∥
∥       ↓     1 |      ↓     2 ∥      ↓     5 |      ↓      6 ∥
+===============+==============+==============+===============+</code></pre><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; using Oceananigans.MultiRegion: ConformalCubedSphereGrid

julia&gt; grid = ConformalCubedSphereGrid(panel_size=(12, 12, 1), z=(-1, 0), radius=1)
ConformalCubedSphereGrid{Float64, FullyConnected, FullyConnected, Bounded} partitioned on CPU:
├── region_grids: 12×12×1 OrthogonalSphericalShellGrid{Float64, FullyConnected, FullyConnected, Bounded} on CPU with 3×3×3 halo
├── partition: CubedSpherePartition with (1 region in each panel)
└── connectivity: CubedSphereConnectivity</code></pre><p>The connectivities of the regions of our grid are stored in <code>grid.connectivity</code>. For example, to find out all connectivites on the South boundary of each region we call</p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans.MultiRegion: East, North, West, South

julia&gt; for region in 1:length(grid); println(grid.connectivity.connections[region].south); end
CubedSphereRegionalConnectivity
├── from: Oceananigans.BoundaryConditions.North side, region 6
├── to:   Oceananigans.BoundaryConditions.South side, region 1
└── no rotation
CubedSphereRegionalConnectivity
├── from: Oceananigans.BoundaryConditions.East side, region 6
├── to:   Oceananigans.BoundaryConditions.South side, region 2
└── counter-clockwise rotation ↺
CubedSphereRegionalConnectivity
├── from: Oceananigans.BoundaryConditions.North side, region 2
├── to:   Oceananigans.BoundaryConditions.South side, region 3
└── no rotation
CubedSphereRegionalConnectivity
├── from: Oceananigans.BoundaryConditions.East side, region 2
├── to:   Oceananigans.BoundaryConditions.South side, region 4
└── counter-clockwise rotation ↺
CubedSphereRegionalConnectivity
├── from: Oceananigans.BoundaryConditions.North side, region 4
├── to:   Oceananigans.BoundaryConditions.South side, region 5
└── no rotation
CubedSphereRegionalConnectivity
├── from: Oceananigans.BoundaryConditions.East side, region 4
├── to:   Oceananigans.BoundaryConditions.South side, region 6
└── counter-clockwise rotation ↺</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/MultiRegion/cubed_sphere_grid.jl#L24-L186">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.MultiRegion.CubedSpherePartition-Tuple{}"><a class="docstring-binding" href="#Oceananigans.MultiRegion.CubedSpherePartition-Tuple{}"><code>Oceananigans.MultiRegion.CubedSpherePartition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">CubedSpherePartition(; R = 1)</code></pre><p>Return a cubed sphere partition with <code>R</code> partitions in each horizontal dimension of each panel of the sphere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/MultiRegion/cubed_sphere_partitions.jl#L13-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.MultiRegion.MultiRegionGrid-Tuple{Any}"><a class="docstring-binding" href="#Oceananigans.MultiRegion.MultiRegionGrid-Tuple{Any}"><code>Oceananigans.MultiRegion.MultiRegionGrid</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MultiRegionGrid(global_grid; partition = XPartition(2))</code></pre><p>Split a <code>global_grid</code> into different regions.</p><p><strong>Positional Arguments</strong></p><ul><li><code>global_grid</code>: the grid to be divided into regions.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>partition</code>: the partitioning required. The implemented partitioning are <code>XPartition</code>              (division along the <span>$x$</span> direction) and <code>YPartition</code> (division along              the <span>$y$</span> direction).</li></ul><p><strong>Example</strong></p><pre><code class="language- hljs">julia&gt; using Oceananigans

julia&gt; using Oceananigans.MultiRegion: MultiRegionGrid, XPartition

julia&gt; grid = RectilinearGrid(size=(12, 12), extent=(1, 1), topology=(Bounded, Bounded, Flat));

julia&gt; multi_region_grid = MultiRegionGrid(grid, partition = XPartition(4))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/MultiRegion/multi_region_grid.jl#L66-L95">source</a></section></details></article><h2 id="Operators"><a class="docs-heading-anchor" href="#Operators">Operators</a><a id="Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Operators" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Oceananigans.Operators.divᶜᶜᶜ-NTuple{7, Any}"><a class="docstring-binding" href="#Oceananigans.Operators.divᶜᶜᶜ-NTuple{7, Any}"><code>Oceananigans.Operators.divᶜᶜᶜ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">divᶜᶜᶜ(i, j, k, grid, u, v, w)</code></pre><p>Calculate the divergence <span>$𝛁·𝐕$</span> of a vector field <span>$𝐕 = (u, v, w)$</span>,</p><pre><code class="language-julia hljs">1/V * [δxᶜᵃᵃ(Ax * u) + δxᵃᶜᵃ(Ay * v) + δzᵃᵃᶜ(Az * w)]</code></pre><p>which ends up at the cell centers <code>ccc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Operators/divergence_operators.jl#L5-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Operators.extrinsic_vector-Tuple{Any, Any, Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any}"><a class="docstring-binding" href="#Oceananigans.Operators.extrinsic_vector-Tuple{Any, Any, Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any}"><code>Oceananigans.Operators.extrinsic_vector</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">extrinsic_vector(i, j, k, grid::AbstractGrid, uᵢ, vᵢ, wᵢ)</code></pre><p>Convert the three-dimensional vector with components <code>uᵢ, vᵢ, wᵢ</code> defined on the <em>intrinsic</em> coordinate system of the grid, to the <em>extrinsic</em> coordinate system associated with the domain.</p><p><em>extrinsic</em> coordinate systems are:</p><ul><li>Cartesian coordinates for any grid that discretizes a cartesian domain (e.g. a <code>RectilinearGrid</code>)</li><li>Geographic coordinates for any grid that discretizes a spherical domain (e.g. an <code>AbstractCurvilinearGrid</code>)</li></ul><p>Therefore, for the <a href="#Oceananigans.Grids.RectilinearGrid"><code>RectilinearGrid</code></a> and the <a href="#Oceananigans.Grids.LatitudeLongitudeGrid"><code>LatitudeLongitudeGrid</code></a>, the <em>extrinsic</em> and the <em>intrinsic</em> coordinate systems are equivalent. However, for other grids (e.g., for the  <a href="@ref"><code>ConformalCubedSphereGrid</code></a>) that might not be the case.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Operators/vector_rotation_operators.jl#L26-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Operators.intrinsic_vector-Tuple{Any, Any, Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any}"><a class="docstring-binding" href="#Oceananigans.Operators.intrinsic_vector-Tuple{Any, Any, Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any}"><code>Oceananigans.Operators.intrinsic_vector</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">intrinsic_vector(i, j, k, grid::AbstractGrid, uₑ, vₑ, wₑ)</code></pre><p>Convert the three-dimensional vector with components <code>uₑ, vₑ, wₑ</code> defined in an <em>extrinsic</em> coordinate system associated with the domain, to the coordinate system <em>intrinsic</em> to the grid.</p><p><em>extrinsic</em> coordinate systems are:</p><ul><li>Cartesian coordinates for any grid that discretizes a cartesian domain (e.g. a <code>RectilinearGrid</code>)</li><li>Geographic coordinates for any grid that discretizes a spherical domain (e.g. an <code>AbstractCurvilinearGrid</code>)</li></ul><p>Therefore, for the <a href="#Oceananigans.Grids.RectilinearGrid"><code>RectilinearGrid</code></a> and the <a href="#Oceananigans.Grids.LatitudeLongitudeGrid"><code>LatitudeLongitudeGrid</code></a>, the <em>extrinsic</em> and the <em>intrinsic</em> coordinate system are equivalent. However, for other grids (e.g., for the  <a href="@ref"><code>ConformalCubedSphereGrid</code></a>) that might not be the case.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Operators/vector_rotation_operators.jl#L8-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Operators.ζ₃ᶠᶠᶜ-NTuple{6, Any}"><a class="docstring-binding" href="#Oceananigans.Operators.ζ₃ᶠᶠᶜ-NTuple{6, Any}"><code>Oceananigans.Operators.ζ₃ᶠᶠᶜ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ζ₃ᶠᶠᶜ(i, j, k, grid, u, v)</code></pre><p>The vertical vorticity associated with horizontal velocities <span>$u$</span> and <span>$v$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Operators/vorticity_operators.jl#L4-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Operators.∇²ᶜᶜᶜ-NTuple{5, Any}"><a class="docstring-binding" href="#Oceananigans.Operators.∇²ᶜᶜᶜ-NTuple{5, Any}"><code>Oceananigans.Operators.∇²ᶜᶜᶜ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">∇²ᶜᶜᶜ(i, j, k, grid, c)</code></pre><p>Calculate the Laplacian of <span>$c$</span> via</p><pre><code class="language-julia hljs">1/V * [δxᶜᵃᵃ(Ax * ∂xᶠᵃᵃ(c)) + δyᵃᶜᵃ(Ay * ∂yᵃᶠᵃ(c)) + δzᵃᵃᶜ(Az * ∂zᵃᵃᶠ(c))]</code></pre><p>which ends up at the location <code>ccc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Operators/laplacian_operators.jl#L25-L35">source</a></section></details></article><h2 id="Output-readers"><a class="docs-heading-anchor" href="#Output-readers">Output readers</a><a id="Output-readers-1"></a><a class="docs-heading-anchor-permalink" href="#Output-readers" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Oceananigans.OutputReaders.Clamp"><a class="docstring-binding" href="#Oceananigans.OutputReaders.Clamp"><code>Oceananigans.OutputReaders.Clamp</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Clamp()</code></pre><p>Specifies FieldTimeSeries Time extrapolation that returns data from the nearest value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/OutputReaders/field_time_series.jl#L101-L105">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.OutputReaders.Cyclical"><a class="docstring-binding" href="#Oceananigans.OutputReaders.Cyclical"><code>Oceananigans.OutputReaders.Cyclical</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Cyclical(period=nothing)</code></pre><p>Specifies cyclical FieldTimeSeries linear Time extrapolation. If <code>period</code> is not specified, it is inferred from the <code>fts::FieldTimeSeries</code> via</p><pre><code class="language-julia hljs">t = fts.times
Δt = t[end] - t[end-1]
period = t[end] - t[1] + Δt</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/OutputReaders/field_time_series.jl#L76-L87">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.OutputReaders.FieldDataset-Tuple{Any, Any}"><a class="docstring-binding" href="#Oceananigans.OutputReaders.FieldDataset-Tuple{Any, Any}"><code>Oceananigans.OutputReaders.FieldDataset</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">FieldDataset(times, fields;
             backend = OnDisk(),
             path = nothing,
             metadata = Dict(),
             reader_kw = NamedTuple())</code></pre><p>Returns a <code>FieldDataset</code> containing a new <code>FieldTimeSeries</code> for each field  in the <code>NamedTuple</code><code>fields</code> at <code>times</code>. Locations, indices and boundary  conditions are extracted from <code>fields</code>`</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>backend</code>: backend, <code>InMemory(indices=Colon())</code> or <code>OnDisk()</code></p></li><li><p><code>path</code>: path to data for <code>backend = OnDisk()</code></p></li><li><p><code>metadata</code>: <code>Dict</code> containing metadata entries</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/OutputReaders/field_dataset.jl#L167-L185">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.OutputReaders.FieldDataset-Tuple{Any}"><a class="docstring-binding" href="#Oceananigans.OutputReaders.FieldDataset-Tuple{Any}"><code>Oceananigans.OutputReaders.FieldDataset</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">FieldDataset(filepath;
             architecture=CPU(), grid=nothing, backend=InMemory(), metadata_paths=[&quot;metadata&quot;])</code></pre><p>Returns a <code>Dict</code> containing a <code>FieldTimeSeries</code> for each field in the JLD2 file located at <code>filepath</code>. Note that model output <strong>must</strong> have been saved with halos.</p><p><strong>Keyword arguments</strong></p><ul><li><code>backend</code>: Either <code>InMemory()</code> (default) or <code>OnDisk()</code>. The <code>InMemory</code> backend will</li></ul><p>load the data fully in memory as a 4D multi-dimensional array while the <code>OnDisk()</code> backend will lazily load field time snapshots when the <code>FieldTimeSeries</code> is indexed linearly.</p><ul><li><p><code>metadata_paths</code>: A list of JLD2 paths to look for metadata. By default it looks in <code>file[&quot;metadata&quot;]</code>.</p></li><li><p><code>grid</code>: May be specified to override the grid used in the JLD2 file.</p></li><li><p><code>reader_kw</code>: A named tuple or dictionary of keyword arguments to pass to the reader              (currently only JLD2) to be used when opening files.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/OutputReaders/field_dataset.jl#L12-L33">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.OutputReaders.FieldDataset-Union{Tuple{N}, Tuple{Any, Any, NTuple{N, Symbol}}} where N"><a class="docstring-binding" href="#Oceananigans.OutputReaders.FieldDataset-Union{Tuple{N}, Tuple{Any, Any, NTuple{N, Symbol}}} where N"><code>Oceananigans.OutputReaders.FieldDataset</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">FieldDataset(grid, times, fields;
             backend = OnDisk(),
             path = nothing,
             location = NamedTuple(),
             indices = NamedTuple(),
             boundary_conditions = NamedTuple(),
             metadata = Dict(),
             reader_kw = NamedTuple())</code></pre><p>Returns a <code>FieldDataset</code> containing a new <code>FieldTimeSeries</code> for each key in <code>fields</code> on <code>grid</code> at <code>times</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>backend</code>: backend, <code>InMemory(indices=Colon())</code> or <code>OnDisk()</code></p></li><li><p><code>path</code>: path to data for <code>backend = OnDisk()</code></p></li><li><p><code>location</code>: <code>NamedTuple</code> of location specifications, defaults to               (Center, Center, Center) for each field`</p></li><li><p><code>indices</code>: <code>NamedTuple</code> of spatial indices, defaults to (:, :, :) for each field</p></li><li><p><code>boundary_conditions</code>: <code>NamedTuple</code> of boundary conditions for each field</p></li><li><p><code>metadata</code>: <code>Dict</code> containing metadata entries</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/OutputReaders/field_dataset.jl#L88-L115">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.OutputReaders.FieldTimeSeries-Tuple{String, String}"><a class="docstring-binding" href="#Oceananigans.OutputReaders.FieldTimeSeries-Tuple{String, String}"><code>Oceananigans.OutputReaders.FieldTimeSeries</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">FieldTimeSeries(path, name;
                backend = InMemory(),
                architecture = nothing,
                grid = nothing,
                location = nothing,
                boundary_conditions = UnspecifiedBoundaryConditions(),
                time_indexing = Linear(),
                iterations = nothing,
                times = nothing,
                reader_kw = Dict{Symbol, Any}())</code></pre><p>Return a <code>FieldTimeSeries</code> containing a time-series of the field <code>name</code> load from JLD2 output located at <code>path</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>backend</code>: <code>InMemory()</code> to load data into a 4D array, <code>OnDisk()</code> to lazily load data from disk            when indexing into <code>FieldTimeSeries</code>.</p></li><li><p><code>grid</code>: A grid to associate with the data, in the case that the native grid was not serialized         properly.</p></li><li><p><code>iterations</code>: Iterations to load. Defaults to all iterations found in the file.</p></li><li><p><code>times</code>: Save times to load, as determined through an approximate floating point          comparison to recorded save times. Defaults to times associated with <code>iterations</code>.          Takes precedence over <code>iterations</code> if <code>times</code> is specified.</p></li><li><p><code>reader_kw</code>: A named tuple or dictionary of keyword arguments to pass to the reader              (currently only JLD2) to be used when opening files.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/OutputReaders/field_time_series.jl#L459-L491">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.OutputReaders.FieldTimeSeries-Union{Tuple{Oceananigans.Grids.AbstractGrid}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Oceananigans.Grids.AbstractGrid, Any}} where {LX, LY, LZ}"><a class="docstring-binding" href="#Oceananigans.OutputReaders.FieldTimeSeries-Union{Tuple{Oceananigans.Grids.AbstractGrid}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Oceananigans.Grids.AbstractGrid, Any}} where {LX, LY, LZ}"><code>Oceananigans.OutputReaders.FieldTimeSeries</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">FieldTimeSeries{LX, LY, LZ}(grid::AbstractGrid [, times=()]; kwargs...)</code></pre><p>Construct a <code>FieldTimeSeries</code> on <code>grid</code> and at <code>times</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>indices</code>: spatial indices</p></li><li><p><code>backend</code>: backend, <code>InMemory(indices=Colon())</code> or <code>OnDisk()</code></p></li><li><p><code>path</code>: path to data for <code>backend = OnDisk()</code></p></li><li><p><code>name</code>: name of field for <code>backend = OnDisk()</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/OutputReaders/field_time_series.jl#L428-L443">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.OutputReaders.InMemory-Tuple{Int64}"><a class="docstring-binding" href="#Oceananigans.OutputReaders.InMemory-Tuple{Int64}"><code>Oceananigans.OutputReaders.InMemory</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">InMemory(length=nothing)</code></pre><p>Return a <code>backend</code> for <code>FieldTimeSeries</code> that stores <code>size</code> fields in memory. The default <code>size = nothing</code> stores all fields in memory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/OutputReaders/field_time_series.jl#L42-L47">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.OutputReaders.Linear"><a class="docstring-binding" href="#Oceananigans.OutputReaders.Linear"><code>Oceananigans.OutputReaders.Linear</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Linear()</code></pre><p>Specifies FieldTimeSeries linear Time extrapolation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/OutputReaders/field_time_series.jl#L94-L98">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.OutputReaders.OnDisk"><a class="docstring-binding" href="#Oceananigans.OutputReaders.OnDisk"><code>Oceananigans.OutputReaders.OnDisk</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">OnDisk()</code></pre><p>Return a lazy <code>backend</code> for <code>FieldTimeSeries</code> that keeps data on disk, only loading it as requested by indexing into the <code>FieldTimeSeries</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/OutputReaders/field_time_series.jl#L63-L69">source</a></section></details></article><h2 id="Output-writers"><a class="docs-heading-anchor" href="#Output-writers">Output writers</a><a id="Output-writers-1"></a><a class="docs-heading-anchor-permalink" href="#Output-writers" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Oceananigans.OutputWriters.AveragedTimeInterval"><a class="docstring-binding" href="#Oceananigans.OutputWriters.AveragedTimeInterval"><code>Oceananigans.OutputWriters.AveragedTimeInterval</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">mutable struct AveragedTimeInterval &lt;: AbstractSchedule</code></pre><p>Container for parameters that configure and handle time-averaged output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/OutputWriters/windowed_time_average.jl#L10-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.OutputWriters.AveragedTimeInterval-Tuple{Any}"><a class="docstring-binding" href="#Oceananigans.OutputWriters.AveragedTimeInterval-Tuple{Any}"><code>Oceananigans.OutputWriters.AveragedTimeInterval</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">AveragedTimeInterval(interval; window=interval, stride=1)</code></pre><p>Returns a <code>schedule</code> that specifies periodic time-averaging of output. The time <code>window</code> specifies the extent of the time-average, which reoccurs every <code>interval</code>.</p><p><code>output</code> is computed and accumulated into the average every <code>stride</code> iterations during the averaging window. For example, <code>stride=1</code> computes output every iteration, whereas <code>stride=2</code> computes output every other iteration. Time-averages with longer <code>stride</code>s are faster to compute, but less accurate.</p><p>The time-average of <span>$a$</span> is a left Riemann sum corresponding to</p><p class="math-container">\[⟨a⟩ = T⁻¹ \int_{tᵢ-T}^{tᵢ} a \mathrm{d} t \, ,\]</p><p>where <span>$⟨a⟩$</span> is the time-average of <span>$a$</span>, <span>$T$</span> is the time-window for averaging, and the <span>$tᵢ$</span> are discrete times separated by the time <code>interval</code>. The <span>$tᵢ$</span> specify both the end of the averaging window and the time at which output is written.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Oceananigans.OutputWriters: AveragedTimeInterval
using Oceananigans.Units: days

schedule = AveragedTimeInterval(4days, window=2days)

# output
AveragedTimeInterval(window=2 days, stride=1, interval=4 days)</code></pre><p>An <code>AveragedTimeInterval</code> schedule directs an output writer to time-average its outputs before writing them to disk:</p><pre><code class="language- hljs">using Oceananigans
using Oceananigans.Units

model = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)))

simulation = Simulation(model, Δt=10minutes, stop_time=30days)

simulation.output_writers[:velocities] = JLD2Writer(model, model.velocities,
                                                    filename= &quot;averaged_velocity_data.jld2&quot;,
                                                    schedule = AveragedTimeInterval(4days, window=2days, stride=2))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/OutputWriters/windowed_time_average.jl#L24-L74">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.OutputWriters.Checkpointer-Tuple{Any}"><a class="docstring-binding" href="#Oceananigans.OutputWriters.Checkpointer-Tuple{Any}"><code>Oceananigans.OutputWriters.Checkpointer</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Checkpointer(model;
             schedule,
             dir = &quot;.&quot;,
             prefix = &quot;checkpoint&quot;,
             overwrite_existing = false,
             verbose = false,
             cleanup = false,
             properties = required_checkpoint_properties(model))</code></pre><p>Construct a <code>Checkpointer</code> that checkpoints the model to a JLD2 file on <code>schedule.</code> The <code>model.clock.iteration</code> is included in the filename to distinguish between multiple checkpoint files.</p><p>To restart or &quot;pickup&quot; a model from a checkpoint, specify <code>pickup = true</code> when calling <code>run!</code>, ensuring that the checkpoint file is in directory <code>dir</code>. See <a href="#Oceananigans.Simulations.run!-Tuple{Any}"><code>run!</code></a> for more details.</p><p>Note that extra model <code>properties</code> can be specified, but removing crucial properties such as <code>:timestepper</code> will render restoring from the checkpoint impossible.</p><p>The checkpointer attempts to serialize as much of the model to disk as possible, but functions or objects containing functions cannot be serialized at this time.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>schedule</code> (required): Schedule that determines when to checkpoint.</p></li><li><p><code>dir</code>: Directory to save output to. Default: <code>&quot;.&quot;</code> (current working directory).</p></li><li><p><code>prefix</code>: Descriptive filename prefixed to all output files. Default: <code>&quot;checkpoint&quot;</code>.</p></li><li><p><code>overwrite_existing</code>: Remove existing files if their filenames conflict. Default: <code>false</code>.</p></li><li><p><code>verbose</code>: Log what the output writer is doing with statistics on compute/write times            and file sizes. Default: <code>false</code>.</p></li><li><p><code>cleanup</code>: Previous checkpoint files are deleted once a new checkpoint file is written.            Default: <code>false</code>.</p></li><li><p><code>properties</code>: List of model properties to checkpoint. This list <em>must</em> contain               <code>:grid</code> and <code>:clock</code>, and if there is a timestepper then also               <code>:timestepper</code>. Default: calls <a href="@ref"><code>required_checkpoint_properties</code></a> on               <code>model</code> to get these properties.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/OutputWriters/checkpointer.jl#L21-L64">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.OutputWriters.FileSizeLimit-Tuple{Any}"><a class="docstring-binding" href="#Oceananigans.OutputWriters.FileSizeLimit-Tuple{Any}"><code>Oceananigans.OutputWriters.FileSizeLimit</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">FileSizeLimit(size_limit [, path=&quot;&quot;])</code></pre><p>Return a schedule that actuates when the file at <code>path</code> exceeds the <code>size_limit</code>.</p><p>The <code>path</code> is automatically added and updated when <code>FileSizeLimit</code> is used with an output writer, and should not be provided manually.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/OutputWriters/output_writer_utils.jl#L26-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.OutputWriters.JLD2Writer-Tuple{Any, Any}"><a class="docstring-binding" href="#Oceananigans.OutputWriters.JLD2Writer-Tuple{Any, Any}"><code>Oceananigans.OutputWriters.JLD2Writer</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">JLD2Writer(model, outputs; filename, schedule,
           dir = &quot;.&quot;,
           indices = (:, :, :),
           with_halos = true,
           array_type = Array{Float32},
           file_splitting = NoFileSplitting(),
           overwrite_existing = false,
           init = noinit,
           including = [:grid, :coriolis, :buoyancy, :closure],
           verbose = false,
           part = 1,
           jld2_kw = Dict{Symbol, Any}())</code></pre><p>Construct a <code>JLD2Writer</code> for an Oceananigans <code>model</code> that writes <code>label, output</code> pairs in <code>outputs</code> to a JLD2 file.</p><p>The argument <code>outputs</code> may be a <code>Dict</code> or <code>NamedTuple</code>. The keys of <code>outputs</code> are symbols or strings that &quot;name&quot; output data. The values of <code>outputs</code> are either <code>AbstractField</code>s, objects that are called with the signature <code>output(model)</code>, or <code>WindowedTimeAverage</code>s of <code>AbstractFields</code>s, functions, or callable objects.</p><p><strong>Keyword arguments</strong></p><p><strong>Filenaming</strong></p><ul><li><p><code>filename</code> (required): Descriptive filename. <code>&quot;.jld2&quot;</code> is appended to <code>filename</code> in the file path                        if <code>filename</code> does not end in <code>&quot;.jld2&quot;</code>.</p></li><li><p><code>dir</code>: Directory to save output to. Default: <code>&quot;.&quot;</code> (current working directory).</p></li></ul><p><strong>Output frequency and time-averaging</strong></p><ul><li><code>schedule</code> (required): <code>AbstractSchedule</code> that determines when output is saved.</li></ul><p><strong>Slicing and type conversion prior to output</strong></p><ul><li><p><code>indices</code>: Specifies the indices to write to disk with a <code>Tuple</code> of <code>Colon</code>, <code>UnitRange</code>,            or <code>Int</code> elements. Indices must be <code>Colon</code>, <code>Int</code>, or contiguous <code>UnitRange</code>.            Defaults to <code>(:, :, :)</code> or &quot;all indices&quot;. If <code>!with_halos</code>,            halo regions are removed from <code>indices</code>. For example, <code>indices = (:, :, 1)</code>            will save xy-slices of the bottom-most index.</p></li><li><p><code>with_halos</code> (Bool): Whether or not to slice off or keep halo regions from fields before writing output.                      Preserving halo region data can be useful for postprocessing. Default: true.</p></li><li><p><code>array_type</code>: The array type to which output arrays are converted to prior to saving.               Default: <code>Array{Float32}</code>.</p></li></ul><p><strong>File management</strong></p><ul><li><p><code>file_splitting</code>: Schedule for splitting the output file. The new files will be suffixed with                   <code>_part1</code>, <code>_part2</code>, etc. For example <code>file_splitting = FileSizeLimit(sz)</code> will                   split the output file when its size exceeds <code>sz</code>. Another example is                   <code>file_splitting = TimeInterval(30days)</code>, which will split files every 30 days of                   simulation time. The default incurs no splitting (<code>NoFileSplitting()</code>).</p></li><li><p><code>overwrite_existing</code>: Remove existing files if their filenames conflict.                       Default: <code>false</code>.</p></li></ul><p><strong>Output file metadata management</strong></p><ul><li><p><code>init</code>: A function of the form <code>init(file, model)</code> that runs when a JLD2 output file is initialized.         Default: <code>noinit(args...) = nothing</code>.</p></li><li><p><code>including</code>: List of model properties to save with every file.              Default depends of the type of model: <code>default_included_properties(model)</code></p></li></ul><p><strong>Miscellaneous keywords</strong></p><ul><li><p><code>verbose</code>: Log what the output writer is doing with statistics on compute/write times and file sizes.            Default: <code>false</code>.</p></li><li><p><code>part</code>: The starting part number used when file splitting.         Default: 1.</p></li><li><p><code>jld2_kw</code>: Dict of kwargs to be passed to <code>JLD2.jldopen</code> when data is written.</p></li></ul><p><strong>Example</strong></p><p>Output 3D fields of the model velocities <span>$u$</span>, <span>$v$</span>, and <span>$w$</span>:</p><pre><code class="language- hljs">using Oceananigans
using Oceananigans.Units

model = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)), tracers=:c)
simulation = Simulation(model, Δt=12, stop_time=1hour)

function init_save_some_metadata!(file, model)
    file[&quot;author&quot;] = &quot;Chim Riggles&quot;
    file[&quot;parameters/coriolis_parameter&quot;] = 1e-4
    file[&quot;parameters/density&quot;] = 1027
    return nothing
end

c_avg = Field(Average(model.tracers.c, dims=(1, 2)))

# Note that model.velocities is NamedTuple
simulation.output_writers[:velocities] = JLD2Writer(model, model.velocities,
                                                    filename = &quot;some_data.jld2&quot;,
                                                    schedule = TimeInterval(20minutes),
                                                    init = init_save_some_metadata!)</code></pre><p>and also output a both 5-minute-time-average and horizontal-average of the tracer <span>$c$</span> every 20 minutes of simulation time to a file called <code>some_averaged_data.jld2</code></p><pre><code class="language- hljs">simulation.output_writers[:avg_c] = JLD2Writer(model, (; c=c_avg),
                                               filename = &quot;some_averaged_data.jld2&quot;,
                                               schedule = AveragedTimeInterval(20minute, window=5minutes))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/OutputWriters/jld2_writer.jl#L26-L141">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.OutputWriters.WindowedTimeAverage"><a class="docstring-binding" href="#Oceananigans.OutputWriters.WindowedTimeAverage"><code>Oceananigans.OutputWriters.WindowedTimeAverage</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">WindowedTimeAverage(operand, model=nothing; schedule)</code></pre><p>Returns an object for computing running averages of <code>operand</code> over <code>schedule.window</code> and recurring on <code>schedule.interval</code>, where <code>schedule</code> is an <code>AveragedTimeInterval</code>. During the collection period, averages are computed every <code>schedule.stride</code> iteration.</p><p><code>operand</code> may be a <code>Oceananigans.Field</code> or a function that returns an array or scalar.</p><p>Calling <code>wta(model)</code> for <code>wta::WindowedTimeAverage</code> object returns <code>wta.result</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/OutputWriters/windowed_time_average.jl#L167-L177">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.OutputWriters.NetCDFWriter"><a class="docstring-binding" href="#Oceananigans.OutputWriters.NetCDFWriter"><code>Oceananigans.OutputWriters.NetCDFWriter</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NetCDFWriter(model, outputs;
             filename,
             schedule,
             grid = model.grid,
             dir = &quot;.&quot;,
             array_type = Array{Float32},
             indices = (:, :, :),
             global_attributes = Dict(),
             output_attributes = Dict(),
             dimensions = Dict(),
             with_halos = false,
             include_grid_metrics = true,
             overwrite_existing = nothing,
             verbose = false,
             deflatelevel = 0,
             part = 1,
             file_splitting = NoFileSplitting(),
             dimension_name_generator = trilocation_dim_name)</code></pre><p>Construct a <code>NetCDFWriter</code> that writes <code>(label, output)</code> pairs in <code>outputs</code> to a NetCDF file. The <code>outputs</code> can be a <code>Dict</code> or <code>NamedTuple</code> where each <code>label</code> is a string and each <code>output</code> is one of:</p><ul><li>A <code>Field</code> (e.g., <code>model.velocities.u</code>)</li><li>A <code>Reduction</code> (e.g., <code>Average(model.tracers.T, dims=(1, 2))</code>)</li><li><code>LagrangianParticles</code> for particle tracking data</li><li>A function <code>f(model)</code> that returns something to be written to disk</li></ul><p>If any of <code>outputs</code> are not <code>AbstractField</code>, <code>Reduction</code>, or <code>LagrangianParticles</code>, their spatial <code>dimensions</code> must be provided.</p><p><strong>Required arguments</strong></p><ul><li><p><code>model</code>: The Oceananigans model instance.</p></li><li><p><code>outputs</code>: A collection of outputs to write, specified as either:</p><ul><li>A <code>Dict</code> with string keys and Field/function values.</li><li>A <code>NamedTuple</code> of <code>Field</code>s or functions.</li></ul></li></ul><p><strong>Required keyword arguments</strong></p><ul><li><p><code>filename</code>: Descriptive filename. <code>&quot;.nc&quot;</code> is appended if not present.</p></li><li><p><code>schedule</code>: An <code>AbstractSchedule</code> that determines when output is saved. Options include:</p><ul><li><code>TimeInterval(dt)</code>: Save every <code>dt</code> seconds of simulation time.</li><li><code>IterationInterval(n)</code>: Save every <code>n</code> iterations.</li><li><code>AveragedTimeInterval(dt; window, stride)</code>: Time-average output over a window before saving.</li><li><code>WallTimeInterval(dt)</code>: Save every <code>dt</code> seconds of wall clock time.</li></ul></li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><p><code>grid</code>: The grid associated with <code>outputs</code>. Defaults to <code>model.grid</code>. To use <code>outputs</code> on a different         grid than <code>model.grid</code>, provide the proper <code>grid</code> here.</p></li><li><p><code>dir</code>: Directory to save output to. Default: <code>&quot;.&quot;</code>.</p></li><li><p><code>array_type</code>: Type to convert outputs to before saving. Default: <code>Array{Float32}</code>.</p></li><li><p><code>indices</code>: Tuple of indices of the output variables to include. Default is <code>(:, :, :)</code>, which            includes the full fields. This allows saving specific slices of the domain.</p></li><li><p><code>global_attributes</code>: <code>Dict</code> or <code>NamedTuple</code> of global attributes or metadata to save with every file.                      Default: <code>Dict()</code>. This is useful for saving information specific to the simulation.                      Some useful global attributes are included by default but will be overwritten if                      included in this <code>Dict</code>.</p></li><li><p><code>output_attributes</code>: <code>Dict</code> or <code>NamedTuple</code> of attributes to be saved with each field variable.                      Default: <code>Dict()</code>. Reasonable defaults including descriptive names and units are                      provided for velocities, buoyancy, temperature, and salinity. Attributes provided                      here will overwrite the defaults.</p></li><li><p><code>dimensions</code>: A <code>Dict</code> or <code>NamedTuple</code> of dimension tuples to apply to outputs (required for function               outputs that return custom data).</p></li><li><p><code>with_halos</code>: Boolean defining whether to include halos in the outputs. Default: <code>false</code>.               Note that to postprocess saved output (e.g., compute derivatives, etc.),               information about the boundary conditions is often crucial. In those cases,               you might need to set <code>with_halos = true</code>. Cannot be used with custom <code>indices</code>.</p></li><li><p><code>include_grid_metrics</code>: Include grid metrics such as grid spacings, areas, and volumes as                         additional variables. Default: <code>true</code>. Note that even with                         <code>include_grid_metrics = false</code>, core grid coordinates are still saved.</p></li><li><p><code>overwrite_existing</code>: If <code>false</code>, <code>NetCDFWriter</code> will append to existing files. If <code>true</code>,                       it will overwrite existing files or create new ones. Default: <code>true</code> if the                       file does not exist, <code>false</code> if it does.</p></li><li><p><code>verbose</code>: Log variable compute times, file write times, and file sizes. Default: <code>false</code>.</p></li><li><p><code>deflatelevel</code>: Determines the NetCDF compression level of data (integer 0-9; 0 (default) means no compression                 and 9 means maximum compression). See <a href="https://alexander-barth.github.io/NCDatasets.jl/stable/variables/#Creating-a-variable">NCDatasets.jl documentation</a>                 for more information.</p></li><li><p><code>part</code>: The starting part number used when file splitting. Default: <code>1</code>.</p></li><li><p><code>file_splitting</code>: Schedule for splitting the output file. The new files will be suffixed with                   <code>_part1</code>, <code>_part2</code>, etc. Options include:                   * <code>FileSizeLimit(sz)</code>: Split when file size exceeds <code>sz</code> (e.g., <code>200KiB</code>).                   * <code>TimeInterval(interval)</code>: Split every <code>interval</code> of simulation time.                   * <code>NoFileSplitting()</code> (default): Don&#39;t split files.</p></li><li><p><code>dimension_name_generator</code>: A function with signature <code>(var_name, grid, LX, LY, LZ, dim)</code> where <code>dim</code> is                             either <code>Val(:x)</code>, <code>Val(:y)</code>, or <code>Val(:z)</code> that returns a string corresponding                             to the name of the dimension <code>var_name</code> on <code>grid</code> with location <code>(LX, LY, LZ)</code>                             along <code>dim</code>. This advanced option can be used to rename dimensions and variables                             to satisfy certain naming conventions. Default: <code>trilocation_dim_name</code>.</p></li></ul><p><strong>Examples</strong></p><p>Saving the <span>$u$</span> velocity field and temperature fields, the full 3D fields and surface 2D slices to separate NetCDF files:</p><pre><code class="language- hljs">using Oceananigans

grid = RectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1))

model = NonhydrostaticModel(grid=grid, tracers=:c)

simulation = Simulation(model, Δt=12, stop_time=3600)

fields = Dict(&quot;u&quot; =&gt; model.velocities.u, &quot;c&quot; =&gt; model.tracers.c)

simulation.output_writers[:field_writer] =
    NetCDFWriter(model, fields, filename=&quot;fields.nc&quot;, schedule=TimeInterval(60))</code></pre><pre><code class="language- hljs">simulation.output_writers[:surface_slice_writer] =
    NetCDFWriter(model, fields, filename=&quot;surface_xy_slice.nc&quot;,
                 schedule=TimeInterval(60), indices=(:, :, grid.Nz))</code></pre><pre><code class="language- hljs">simulation.output_writers[:averaged_profile_writer] =
    NetCDFWriter(model, fields,
                 filename = &quot;averaged_z_profile.nc&quot;,
                 schedule = AveragedTimeInterval(60, window=20),
                 indices = (1, 1, :))</code></pre><p><code>NetCDFWriter</code> also accepts output functions that write scalars and arrays to disk, provided that their <code>dimensions</code> are provided:</p><pre><code class="language- hljs">using Oceananigans

Nx, Ny, Nz = 16, 16, 16

grid = RectilinearGrid(size=(Nx, Ny, Nz), extent=(1, 2, 3))

model = NonhydrostaticModel(; grid)

simulation = Simulation(model, Δt=1.25, stop_iteration=3)

f(model) = model.clock.time^2 # scalar output

zC = znodes(grid, Center())
g(model) = model.clock.time .* exp.(zC) # vector/profile output

xC, yF = xnodes(grid, Center()), ynodes(grid, Face())
XC = [xC[i] for i in 1:Nx, j in 1:Ny]
YF = [yF[j] for i in 1:Nx, j in 1:Ny]
h(model) = @. model.clock.time * sin(XC) * cos(YF) # xy slice output

outputs = Dict(&quot;scalar&quot; =&gt; f, &quot;profile&quot; =&gt; g, &quot;slice&quot; =&gt; h)

dims = Dict(&quot;scalar&quot; =&gt; (), &quot;profile&quot; =&gt; (&quot;zC&quot;,), &quot;slice&quot; =&gt; (&quot;xC&quot;, &quot;yC&quot;))

output_attributes = Dict(
    &quot;scalar&quot;  =&gt; Dict(&quot;long_name&quot; =&gt; &quot;Some scalar&quot;, &quot;units&quot; =&gt; &quot;bananas&quot;),
    &quot;profile&quot; =&gt; Dict(&quot;long_name&quot; =&gt; &quot;Some vertical profile&quot;, &quot;units&quot; =&gt; &quot;watermelons&quot;),
    &quot;slice&quot;   =&gt; Dict(&quot;long_name&quot; =&gt; &quot;Some slice&quot;, &quot;units&quot; =&gt; &quot;mushrooms&quot;))

global_attributes = Dict(&quot;location&quot; =&gt; &quot;Bay of Fundy&quot;, &quot;onions&quot; =&gt; 7)

simulation.output_writers[:things] =
    NetCDFWriter(model, outputs,
                 schedule=IterationInterval(1), filename=&quot;things.nc&quot;, dimensions=dims, verbose=true,
                 global_attributes=global_attributes, output_attributes=output_attributes)</code></pre><p><code>NetCDFWriter</code> can also be configured for <code>outputs</code> that are interpolated or regridded to a different grid than <code>model.grid</code>. To use this functionality, include the keyword argument <code>grid = output_grid</code>.</p><pre><code class="language- hljs">using Oceananigans
using Oceananigans.Fields: interpolate!

grid = RectilinearGrid(size=(1, 1, 8), extent=(1, 1, 1));
model = NonhydrostaticModel(; grid)

coarse_grid = RectilinearGrid(size=(grid.Nx, grid.Ny, grid.Nz÷2), extent=(grid.Lx, grid.Ly, grid.Lz))
coarse_u = Field{Face, Center, Center}(coarse_grid)

interpolate_u(model) = interpolate!(coarse_u, model.velocities.u)
outputs = (; u = interpolate_u)

output_writer = NetCDFWriter(model, outputs;
                             grid = coarse_grid,
                             filename = &quot;coarse_u.nc&quot;,
                             schedule = IterationInterval(1))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/ext/OceananigansNCDatasetsExt.jl#L914-L1123">source</a></section></details></article><h2 id="Simulations"><a class="docs-heading-anchor" href="#Simulations">Simulations</a><a id="Simulations-1"></a><a class="docs-heading-anchor-permalink" href="#Simulations" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Oceananigans.Simulations.Callback"><a class="docstring-binding" href="#Oceananigans.Simulations.Callback"><code>Oceananigans.Simulations.Callback</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Callback(func, schedule=IterationInterval(1);
         parameters=nothing, callsite=TimeStepCallsite())</code></pre><p>Return <code>Callback</code> that executes <code>func</code> on <code>schedule</code> at the <code>callsite</code> with optional <code>parameters</code>. By default, <code>schedule = IterationInterval(1)</code> and <code>callsite = TimeStepCallsite()</code>.</p><p>If <code>isnothing(parameters)</code>, <code>func(sim::Simulation)</code> is called. Otherwise, <code>func</code> is called via <code>func(sim::Simulation, parameters)</code>.</p><p>The <code>callsite</code> determines where <code>Callback</code> is executed. The possible values for <code>callsite</code> are:</p><ul><li><p><code>TimeStepCallsite()</code>: after a time-step.</p></li><li><p><code>TendencyCallsite()</code>: after tendencies are calculated, but before taking a time-step (useful for modifying tendency calculations).</p></li><li><p><code>UpdateStateCallsite()</code>: within <code>update_state!</code>, after auxiliary variables have been computed (for multi-stage time-steppers, <code>update_state!</code> may be called multiple times per time-step).</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Simulations/callback.jl#L46-L68">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Simulations.Simulation-Tuple{Any}"><a class="docstring-binding" href="#Oceananigans.Simulations.Simulation-Tuple{Any}"><code>Oceananigans.Simulations.Simulation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Simulation(model;
           Δt,
           verbose = true,
           stop_iteration = Inf,
           stop_time = Inf,
           wall_time_limit = Inf,
           minimum_relative_step = 0)</code></pre><p>Construct a <code>Simulation</code> for a <code>model</code> with time step <code>Δt</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>Δt</code>: Required keyword argument specifying the simulation time step. Can be a <code>Number</code>       for constant time steps or a <code>TimeStepWizard</code> for adaptive time-stepping.</p></li><li><p><code>stop_iteration</code>: Stop the simulation after this many iterations. Default: <code>Inf</code>.</p></li><li><p><code>stop_time</code>: Stop the simulation once this much model clock time has passed. Default: <code>Inf</code>.</p></li><li><p><code>wall_time_limit</code>: Stop the simulation if it&#39;s been running for longer than this many                    seconds of wall clock time. Default: <code>Inf</code>.</p></li><li><p><code>align_time_step</code>: When <code>true</code> it implies that the simulation will automatically adjust the                    time-step to meet a constraint imposed by various schedules like <code>ScheduledTimes</code>,                    <code>TimeInterval</code>, <code>AveragedTimeInterval</code>, as well as a <code>stop_time</code> criterion.                    If <code>false</code>, i.e., no time-step alignment, then the simulation might blithely step passed                    the specified time. Default: <code>true</code>.                    By <code>align_time_step = false</code> we ensure that the time-step does <em>not</em> change within                    <code>time_step!(simulation)</code></p></li><li><p><code>minimum_relative_step</code>: time steps smaller than <code>Δt * minimum_relative_step</code> will be skipped.                          This avoids extremely high values when writing the pressure to disk.                          Default value is 0. See github.com/CliMA/Oceananigans.jl/issues/3593 for details.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Simulations/simulation.jl#L35-L70">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Simulations.TimeStepWizard"><a class="docstring-binding" href="#Oceananigans.Simulations.TimeStepWizard"><code>Oceananigans.Simulations.TimeStepWizard</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TimeStepWizard([FT=Float64;]
               cfl = 0.2,
               diffusive_cfl = Inf,
               max_change = 1.1,
               min_change = 0.5,
               max_Δt = Inf,
               min_Δt = 0.0,
               cell_advection_timescale = cell_advection_timescale,
               cell_diffusion_timescale = infinite_diffusion_timescale)</code></pre><p>Callback function that adjusts the simulation time step to meet specified target values for advective and diffusive Courant-Friedrichs-Lewy (CFL) numbers (<code>cfl</code> and <code>diffusive_cfl</code>), subject to the limits</p><pre><code class="language-julia hljs">max(min_Δt, min_change * last_Δt) ≤ new_Δt ≤ min(max_Δt, max_change * last_Δt)</code></pre><p>where <code>new_Δt</code> is the new time step calculated by the <code>TimeStepWizard</code>.</p><p>For more information on the CFL number, see its [wikipedia entry] (https://en.wikipedia.org/wiki/Courant%E2%80%93Friedrichs%E2%80%93Lewy_condition).</p><p><strong>Example</strong></p><p>To use <code>TimeStepWizard</code>, insert it into a <a href="#Oceananigans.Simulations.Callback"><code>Callback</code></a> and then add the <code>Callback</code> to a <code>Simulation</code>:</p><pre><code class="language-julia hljs">julia&gt; simulation = Simulation(model, Δt=0.9, stop_iteration=100)

julia&gt; wizard = TimeStepWizard(cfl=0.2)

julia&gt; simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(4))</code></pre><p>Then when <code>run!(simulation)</code> is invoked, the time-step <code>simulation.Δt</code> will be updated every 4 iterations.</p><p>(Note that the name <code>:wizard</code> is unimportant.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Simulations/time_step_wizard.jl#L23-L64">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Simulations.add_callback!-Tuple{Any, Callback}"><a class="docstring-binding" href="#Oceananigans.Simulations.add_callback!-Tuple{Any, Callback}"><code>Oceananigans.Simulations.add_callback!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_callback!(simulation, callback::Callback; name = GenericName(), callback_kw...)
add_callback!(simulation, func, schedule=IterationInterval(1); name = GenericName(), callback_kw...)</code></pre><p>Add <code>Callback(func, schedule)</code> to <code>simulation.callbacks</code> under <code>name</code>. The default <code>GenericName()</code> generates a name of the form <code>:callbackN</code>, where <code>N</code> is big enough for the name to be unique.</p><p>If <code>name::Symbol</code> is supplied, it may be modified if <code>simulation.callbacks[name]</code> already exists.</p><p><code>callback_kw</code> are passed to the constructor for <a href="#Oceananigans.Simulations.Callback"><code>Callback</code></a>.</p><p>The <code>callback</code> (which contains a schedule) can also be supplied directly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Simulations/callback.jl#L111-L125">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Simulations.conjure_time_step_wizard!"><a class="docstring-binding" href="#Oceananigans.Simulations.conjure_time_step_wizard!"><code>Oceananigans.Simulations.conjure_time_step_wizard!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">conjure_time_step_wizard!(simulation, schedule=IterationInterval(5), wizard_kw...)</code></pre><p>Add a <code>TimeStepWizard</code> built with <code>wizard_kw</code> as a <code>Callback</code> to <code>simulation</code>, called on <code>schedule</code> which is <code>IterationInterval(5)</code> by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Simulations/time_step_wizard.jl#L119-L124">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Simulations.run!-Tuple{Any}"><a class="docstring-binding" href="#Oceananigans.Simulations.run!-Tuple{Any}"><code>Oceananigans.Simulations.run!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">run!(simulation; pickup=false)</code></pre><p>Run a <code>simulation</code> until one of <code>simulation.stop_criteria</code> evaluates <code>true</code>. The simulation will then stop.</p><p><strong>Picking simulations up from a checkpoint</strong></p><p>Simulations are &quot;picked up&quot; from a checkpoint if <code>pickup</code> is either <code>true</code>, a <code>String</code>, or an <code>Integer</code> greater than 0.</p><p>Picking up a simulation sets field and tendency data to the specified checkpoint, leaving all other model properties unchanged.</p><p>Possible values for <code>pickup</code> are:</p><ul><li><p><code>pickup=true</code> picks a simulation up from the latest checkpoint associated with the <code>Checkpointer</code> in <code>simulation.output_writers</code>.</p></li><li><p><code>pickup=iteration::Int</code> picks a simulation up from the checkpointed file associated  with <code>iteration</code> and the <code>Checkpointer</code> in <code>simulation.output_writers</code>.</p></li><li><p><code>pickup=filepath::String</code> picks a simulation up from checkpointer data in <code>filepath</code>.</p></li></ul><p>Note that <code>pickup=true</code> and <code>pickup=iteration</code> fails if <code>simulation.output_writers</code> contains more than one checkpointer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Simulations/run.jl#L65-L91">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Solvers.iteration-Tuple{Simulation}"><a class="docstring-binding" href="#Oceananigans.Solvers.iteration-Tuple{Simulation}"><code>Oceananigans.Solvers.iteration</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">iteration(sim::Simulation)</code></pre><p>Return the current simulation iteration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Simulations/simulation.jl#L171-L175">source</a></section></details></article><h2 id="Solvers"><a class="docs-heading-anchor" href="#Solvers">Solvers</a><a id="Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Solvers" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Oceananigans.Solvers.BatchedTridiagonalSolver"><a class="docstring-binding" href="#Oceananigans.Solvers.BatchedTridiagonalSolver"><code>Oceananigans.Solvers.BatchedTridiagonalSolver</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct BatchedTridiagonalSolver{A, B, C, T, G, P}</code></pre><p>A batched solver for large numbers of triadiagonal systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Solvers/batched_tridiagonal_solver.jl#L6-L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Solvers.BatchedTridiagonalSolver-Tuple{Any}"><a class="docstring-binding" href="#Oceananigans.Solvers.BatchedTridiagonalSolver-Tuple{Any}"><code>Oceananigans.Solvers.BatchedTridiagonalSolver</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">BatchedTridiagonalSolver(grid;
                         lower_diagonal,
                         diagonal,
                         upper_diagonal,
                         scratch = zeros(architecture(grid), eltype(grid), grid.Nx, grid.Ny, grid.Nz),
                         tridiagonal_direction = ZDirection()
                         parameters = nothing)</code></pre><p>Construct a solver for batched tridiagonal systems on <code>grid</code> of the form</p><pre><code class="language-julia hljs">                    bⁱʲ¹ ϕⁱʲ¹ + cⁱʲ¹ ϕⁱʲ²   = fⁱʲ¹,
    aⁱʲᵏ⁻¹ ϕⁱʲᵏ⁻¹ + bⁱʲᵏ ϕⁱʲᵏ + cⁱʲᵏ ϕⁱʲᵏ⁺¹ = fⁱʲᵏ,  k = 2, ..., N-1
    aⁱʲᴺ⁻¹ ϕⁱʲᴺ⁻¹ + bⁱʲᴺ ϕⁱʲᴺ               = fⁱʲᴺ,</code></pre><p>or in matrix form</p><pre><code class="language-julia hljs">    ⎡ bⁱʲ¹   cⁱʲ¹     0       ⋯         0   ⎤ ⎡ ϕⁱʲ¹ ⎤   ⎡ fⁱʲ¹ ⎤
    ⎢ aⁱʲ¹   bⁱʲ²   cⁱʲ²      0    ⋯    ⋮   ⎥ ⎢ ϕⁱʲ² ⎥   ⎢ fⁱʲ² ⎥
    ⎢  0      ⋱      ⋱       ⋱              ⎥ ⎢   .  ⎥   ⎢   .  ⎥
    ⎢  ⋮                                0   ⎥ ⎢ ϕⁱʲᵏ ⎥   ⎢ fⁱʲᵏ ⎥
    ⎢  ⋮           aⁱʲᴺ⁻²   bⁱʲᴺ⁻¹   cⁱʲᴺ⁻¹ ⎥ ⎢      ⎥   ⎢   .  ⎥
    ⎣  0      ⋯      0      aⁱʲᴺ⁻¹    bⁱʲᴺ  ⎦ ⎣ ϕⁱʲᴺ ⎦   ⎣ fⁱʲᴺ ⎦</code></pre><p>where <code>a</code> is the <code>lower_diagonal</code>, <code>b</code> is the <code>diagonal</code>, and <code>c</code> is the <code>upper_diagonal</code>.</p><p>Note the convention used here for indexing the upper and lower diagonals; this can be different from other implementations where, e.g., <code>aⁱʲ²</code> may appear at the second row, instead of <code>aⁱʲ¹</code> as above.</p><p><code>ϕ</code> is the solution and <code>f</code> is the right hand side source term passed to <code>solve!(ϕ, tridiagonal_solver, f)</code>.</p><p><code>a</code>, <code>b</code>, <code>c</code>, and <code>f</code> can be specified in three ways:</p><ol><li><p>A 1D array means, e.g., that <code>aⁱʲᵏ = a[k]</code>.</p></li><li><p>A 3D array means, e.g., that <code>aⁱʲᵏ = a[i, j, k]</code>.</p></li></ol><p>Other coefficient types can be implemented by extending <code>get_coefficient</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Solvers/batched_tridiagonal_solver.jl#L38-L78">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Solvers.ConjugateGradientSolver-Tuple{Any}"><a class="docstring-binding" href="#Oceananigans.Solvers.ConjugateGradientSolver-Tuple{Any}"><code>Oceananigans.Solvers.ConjugateGradientSolver</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ConjugateGradientSolver(linear_operation;
                        template_field,
                        maxiter = size(template_field.grid),
                        reltol = sqrt(eps(template_field.grid)),
                        abstol = 0,
                        preconditioner = nothing,
                        enforce_gauge_condition! = no_gauge_enforcement!)</code></pre><p>Return a <code>ConjugateGradientSolver</code> that solves the linear equation <span>$A x = b$</span> using a iterative conjugate gradient method with optional preconditioning.</p><p>The solver is used by calling</p><pre><code class="language-julia hljs">solve!(x, solver::PreconditionedConjugateGradientOperator, b, args...)</code></pre><p>for <code>solver</code>, right-hand side <code>b</code>, solution <code>x</code>, and optional arguments <code>args...</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>linear_operation</code>: Function with signature <code>linear_operation!(p, y, args...)</code> that calculates                     <code>A * y</code> and stores the result in <code>p</code> for a &quot;candidate solution&quot; <code>y</code>. <code>args...</code>                     are optional positional arguments passed from <code>solve!(x, solver, b, args...)</code>.</p></li><li><p><code>template_field</code>: Dummy field that is the same type and size as <code>x</code> and <code>b</code>, which                   is used to infer the <code>architecture</code>, <code>grid</code>, and to create work arrays                   that are used internally by the solver.</p></li><li><p><code>maxiter</code>: Maximum number of iterations the solver may perform before exiting.</p></li><li><p><code>reltol, abstol</code>: Relative and absolute tolerance for convergence of the algorithm.                   The iteration stops when <code>norm(A * x - b) &lt; tolerance</code>.</p></li><li><p><code>preconditioner</code>: Object for which <code>precondition!(z, preconditioner, r, args...)</code> computes <code>z = P * r</code>,                   where <code>r</code> is the residual. Typically <code>P</code> is approximately <code>A⁻¹</code>.</p></li><li><p><code>enforce_gauge_condition!</code>: Function with signature <code>enforce_gauge_condition!(x, r)</code> that                             enforces a gauge condition on the solution <code>x</code> and residual <code>r</code>.                             This is useful for problems where the solution is not unique, such as                             the Poisson equation with purely Neumann boundary conditions.                             The function is called at the end of each iteration of a conjugate                             gradient iteration to ensure that the solution remains consistent                             with the gauge condition.                             The default is <code>no_gauge_enforcement!</code>, which does not enforce a gauge condition.</p></li></ul><p>See <a href="#Oceananigans.Solvers.solve!"><code>solve!</code></a> for more information about the preconditioned conjugate-gradient algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Solvers/conjugate_gradient_solver.jl#L40-L89">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Solvers.FFTBasedPoissonSolver"><a class="docstring-binding" href="#Oceananigans.Solvers.FFTBasedPoissonSolver"><code>Oceananigans.Solvers.FFTBasedPoissonSolver</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FFTBasedPoissonSolver(grid, planner_flag=FFTW.PATIENT)</code></pre><p>Return an <code>FFTBasedPoissonSolver</code> that solves the &quot;generalized&quot; Poisson equation,</p><p class="math-container">\[(∇² + m) ϕ = b,\]</p><p>where <span>$m$</span> is a number, using a eigenfunction expansion of the discrete Poisson operator on a staggered grid and for periodic or Neumann boundary conditions.</p><p>In-place transforms are applied to <span>$b$</span>, which means <span>$b$</span> must have complex-valued elements (typically the same type as <code>solver.storage</code>).</p><p>See <a href="#Oceananigans.Solvers.solve!"><code>solve!</code></a> for more information about the FFT-based Poisson solver algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Solvers/fft_based_poisson_solver.jl#L35-L51">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Solvers.FourierTridiagonalPoissonSolver"><a class="docstring-binding" href="#Oceananigans.Solvers.FourierTridiagonalPoissonSolver"><code>Oceananigans.Solvers.FourierTridiagonalPoissonSolver</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FourierTridiagonalPoissonSolver(grid, planner_flag = FFTW.PATIENT; tridiagonal_formulation=nothing)</code></pre><p>Construct a <code>FourierTridiagonalPoissonSolver</code> on <code>grid</code> with <code>tridiagonal_formulation</code> either <code>XDirection()</code>, <code>YDirection()</code>, or <code>ZDirection()</code>. The <code>tridiagonal_formulation</code> can be used to tweak the tridiagonal matrices to solve variants on the Poisson equation, such as the screened Poisson equation,</p><p class="math-container">\[(∇² + m) ϕ = b\]</p><p>or the Poisson-like equation</p><p class="math-container">\[∂x² ϕ + ∂y² ϕ + ∂z (L ∂z ϕ) = b\]</p><p>or to implement boundary conditions other than the standard homogeneous Neumann boundary conditions.</p><p>The tridiagonal direction is determined by is <code>tridiagonal_direction(tridiagonal_formulation)</code>.</p><p>If <code>tridiagonal_formulation</code> is not specified, the tridiagonal direction is selected as the variably-spaced direction of the grid, or as the <code>ZDirection()</code> for grids with uniform spacing in all three directions.</p><p>The (possibly perturbed) Poisson equation is solved with an FFT-based eigenfunction expansion in the non-tridiagonal-directions augmented by a tridiagonal solve in the tridiagonal direction. The non-tridiagonal-directions must be uniformly spaced.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Solvers/fourier_tridiagonal_poisson_solver.jl#L61-L88">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Solvers.KrylovSolver-Tuple{Any}"><a class="docstring-binding" href="#Oceananigans.Solvers.KrylovSolver-Tuple{Any}"><code>Oceananigans.Solvers.KrylovSolver</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">KrylovSolver(linear_operator;
             template_field::AbstractField,
             maxiter::Int = prod(size(template_field)),
             maxtime::Real = Inf,
             reltol::Real = sqrt(eps(eltype(template_field.grid))),
             abstol::Real = zero(eltype(template_field.grid)),
             preconditioner = nothing,
             method::Symbol = :cg)</code></pre><p>Construct a Krylov subspace solver for implicit linear systems defined by <code>linear_operator</code>, using the structure of a reference field <code>template_field</code>.</p><p><strong>Arguments</strong></p><ul><li><code>linear_operator</code>: linear that defines the matrix-vector product <code>y = A * x</code>, where <code>x</code> has the same structure as <code>template_field</code>.</li><li><code>template_field::AbstractField</code>: A sample field used to infer the architecture, domain geometry, and data types. It is also used to allocate internal buffers and define the operator dimensions.</li><li><code>maxiter::Int</code>: Maximum number of Krylov iterations allowed.</li><li><code>maxtime::Real</code>: Maximum wall-clock time (in seconds) allowed for solving.</li><li><code>reltol::Real</code>: Relative tolerance on the residual norm for convergence.</li><li><code>abstol::Real</code>: Absolute tolerance on the residual norm for convergence.</li><li><code>preconditioner</code>: An optional preconditioner, passed as a callable or left as <code>nothing</code> for no preconditioning.</li><li><code>method::Symbol</code>: Krylov method to use, such as <code>:cg</code>, <code>:fom</code>, <code>:bicgstab</code>, <code>:gmres</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Solvers/krylov_solver.jl#L117-L140">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Solvers.solve!"><a class="docstring-binding" href="#Oceananigans.Solvers.solve!"><code>Oceananigans.Solvers.solve!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">solve!(ϕ, solver::FFTBasedPoissonSolver, b, m=0)</code></pre><p>Solve the &quot;generalized&quot; Poisson equation,</p><p class="math-container">\[(∇² + m) ϕ = b,\]</p><p>where <span>$m$</span> is a number, using a eigenfunction expansion of the discrete Poisson operator on a staggered grid and for periodic or Neumann boundary conditions.</p><p>In-place transforms are applied to <span>$b$</span>, which means <span>$b$</span> must have complex-valued elements (typically the same type as <code>solver.storage</code>).</p><div class="admonition is-info" id="Alternative-names-for-&#39;generalized&#39;-Poisson-equation-cfbef96ddc007b51"><header class="admonition-header">Alternative names for &#39;generalized&#39; Poisson equation<a class="admonition-anchor" href="#Alternative-names-for-&#39;generalized&#39;-Poisson-equation-cfbef96ddc007b51" title="Permalink"></a></header><div class="admonition-body"><p>Equation <span>$(∇² + m) ϕ = b$</span> is sometimes referred to as the &quot;screened Poisson&quot; equation when <span>$m &lt; 0$</span>, or the Helmholtz equation when <span>$m &gt; 0$</span>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Solvers/fft_based_poisson_solver.jl#L76-L94">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Solvers.solve!-Tuple{Any, Oceananigans.Solvers.BatchedTridiagonalSolver, Any, Vararg{Any}}"><a class="docstring-binding" href="#Oceananigans.Solvers.solve!-Tuple{Any, Oceananigans.Solvers.BatchedTridiagonalSolver, Any, Vararg{Any}}"><code>Oceananigans.Solvers.solve!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">solve!(ϕ, solver::BatchedTridiagonalSolver, rhs, args...)</code></pre><p>Solve the batched tridiagonal system of linear equations with right hand side <code>rhs</code> and lower diagonal, diagonal, and upper diagonal coefficients described by the <code>BatchedTridiagonalSolver</code> <code>solver</code>. <code>BatchedTridiagonalSolver</code> uses a modified TriDiagonal Matrix Algorithm (TDMA).</p><p>The result is stored in <code>ϕ</code> which must have size <code>(grid.Nx, grid.Ny, grid.Nz)</code>.</p><p>Implementation follows <a href="../../references/#Press1992">Press William <em>et al.</em> (1992)</a>; §2.4. Note that a slightly different notation from Press et al. is used for indexing the off-diagonal elements; see <a href="#Oceananigans.Solvers.BatchedTridiagonalSolver"><code>BatchedTridiagonalSolver</code></a>.</p><p><strong>Reference</strong></p><p>Press William, H., Teukolsky Saul, A., Vetterling William, T., &amp; Flannery Brian, P. (1992).     Numerical recipes: the art of scientific computing. Cambridge University Press</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Solvers/batched_tridiagonal_solver.jl#L91-L109">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Solvers.solve!-Tuple{Any, Oceananigans.Solvers.ConjugateGradientSolver, Any, Vararg{Any}}"><a class="docstring-binding" href="#Oceananigans.Solvers.solve!-Tuple{Any, Oceananigans.Solvers.ConjugateGradientSolver, Any, Vararg{Any}}"><code>Oceananigans.Solvers.solve!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">solve!(x, solver::ConjugateGradientSolver, b, args...)</code></pre><p>Solve <code>A * x = b</code> using an iterative conjugate-gradient method, where <code>A * x</code> is determined by <code>solver.linear_operation</code></p><p>See figure 2.5 in</p><blockquote><p>The Preconditioned Conjugate Gradient Method in &quot;Templates for the Solution of Linear Systems: Building Blocks for Iterative Methods&quot; Barrett et. al, 2nd Edition.</p></blockquote><p>Given:</p><ul><li>Linear Preconditioner operator <code>M!(solution, x, other_args...)</code> that computes <code>M * x = solution</code></li><li>A matrix operator <code>A</code> as a function <code>A()</code>;</li><li>A dot product function <code>norm()</code>;</li><li>A right-hand side <code>b</code>;</li><li>An initial guess <code>x</code>; and</li><li>Local vectors: <code>z</code>, <code>r</code>, <code>p</code>, <code>q</code></li></ul><p>This function executes the psuedocode algorithm</p><pre><code class="language-julia hljs">β  = 0
r = b - A(x)
iteration  = 0

Loop:
     if iteration &gt; maxiter
        break
     end

     ρ = r ⋅ z

     z = M(r)
     β = ρⁱ⁻¹ / ρ
     p = z + β * p
     q = A(p)

     α = ρ / (p ⋅ q)
     x = x + α * p
     r = r - α * q

     if |r| &lt; tolerance
        break
     end

     iteration += 1
     ρⁱ⁻¹ = ρ</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Solvers/conjugate_gradient_solver.jl#L127-L175">source</a></section></details></article><h2 id="Stokes-drift"><a class="docs-heading-anchor" href="#Stokes-drift">Stokes drift</a><a id="Stokes-drift-1"></a><a class="docs-heading-anchor-permalink" href="#Stokes-drift" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Oceananigans.StokesDrifts.StokesDrift-Tuple{}"><a class="docstring-binding" href="#Oceananigans.StokesDrifts.StokesDrift-Tuple{}"><code>Oceananigans.StokesDrifts.StokesDrift</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">StokesDrift(; ∂z_uˢ=zerofunction, ∂y_uˢ=zerofunction, ∂t_uˢ=zerofunction,
              ∂z_vˢ=zerofunction, ∂x_vˢ=zerofunction, ∂t_vˢ=zerofunction,
              ∂x_wˢ=zerofunction, ∂y_wˢ=zerofunction, ∂t_wˢ=zerofunction, parameters=nothing)</code></pre><p>Construct a set of functions of space and time for a Stokes drift velocity field corresponding to a surface gravity wave field with an envelope that (potentially) varies in the horizontal directions.</p><p>To resolve the evolution of the Lagrangian-mean momentum, we require all the components of the &quot;psuedovorticity&quot;,</p><p class="math-container">\[𝛁 × 𝐯ˢ = \hat{\boldsymbol{x}} (∂_y wˢ - ∂_z vˢ) + \hat{\boldsymbol{y}} (∂_z uˢ - ∂_x wˢ) + \hat{\boldsymbol{z}} (∂_x vˢ - ∂_y uˢ)\]</p><p>as well as the time-derivatives of <span>$uˢ$</span>, <span>$vˢ$</span>, and <span>$wˢ$</span>.</p><p>Note that each function (e.g., <code>∂z_uˢ</code>) is generally a function of depth, horizontal coordinates, and time.Thus, the correct function signature depends on the grid, since <code>Flat</code> horizontal directions are omitted.</p><p>For example, on a grid with <code>topology = (Periodic, Flat, Bounded)</code> (and <code>parameters=nothing</code>), then, e.g., <code>∂z_uˢ</code> is callable via <code>∂z_uˢ(x, z, t)</code>. When <code>!isnothing(parameters)</code>, then <code>∂z_uˢ</code> is callable via <code>∂z_uˢ(x, z, t, parameters)</code>. Similarly, on a grid with <code>topology = (Periodic, Periodic, Bounded)</code> and <code>parameters=nothing</code>, <code>∂z_uˢ</code> is called via <code>∂z_uˢ(x, y, z, t)</code>.</p><p><strong>Example</strong></p><p>A wavepacket moving with the group velocity in the <span>$x$</span>-direction. We write the Stokes drift as:</p><p class="math-container">\[uˢ(x, y, z, t) = A(x - cᵍ \, t, y) ûˢ(z)\]</p><p>with <span>$A(ξ, η) = \exp{[-(ξ^2 + η^2) / 2δ^2]}$</span>. We also assume <span>$vˢ = 0$</span>. If <span>$𝐯ˢ$</span> represents the solenoidal component of the Stokes drift, then in this system from incompressibility requirement we have that <span>$∂_z wˢ = - ∂_x uˢ = - (∂_ξ A) ûˢ$</span> and therefore, under the assumption that <span>$wˢ$</span> tends to zero at large depths, we get <span>$wˢ = - (∂_ξ A / 2k) ûˢ$</span>.</p><pre><code class="language-julia hljs">using Oceananigans
using Oceananigans.Units

g = 9.81 # gravitational acceleration

ϵ = 0.1
λ = 100meters  # horizontal wavelength
const k = 2π / λ  # horizontal wavenumber
c = sqrt(g / k)  # phase speed
const δ = 400kilometers  # wavepacket spread
const cᵍ = c / 2  # group speed
const Uˢ = ϵ^2 * c

@inline A(ξ, η) = exp(- (ξ^2 + η^2) / 2δ^2)

@inline ∂ξ_A(ξ, η) = - ξ / δ^2 * A(ξ, η)
@inline ∂η_A(ξ, η) = - η / δ^2 * A(ξ, η)
@inline ∂η_∂ξ_A(ξ, η) = η * ξ / δ^4 * A(ξ, η)
@inline ∂²ξ_A(ξ, η) = (ξ^2 / δ^2 - 1) * A(ξ, η) / δ^2

@inline ûˢ(z) = Uˢ * exp(2k * z)
@inline uˢ(x, y, z, t) = A(x - cᵍ * t, y) * ûˢ(z)

@inline ∂z_uˢ(x, y, z, t) = 2k * A(x - cᵍ * t, y) * ûˢ(z)
@inline ∂y_uˢ(x, y, z, t) = ∂η_A(x - cᵍ * t, y) * ûˢ(z)
@inline ∂t_uˢ(x, y, z, t) = - cᵍ * ∂ξ_A(x - cᵍ * t, y) * ûˢ(z)
@inline ∂x_wˢ(x, y, z, t) = - 1 / 2k * ∂²ξ_A(x - cᵍ * t, y) * ûˢ(z)
@inline ∂y_wˢ(x, y, z, t) = - 1 / 2k * ∂η_∂ξ_A(x - cᵍ * t, y) * ûˢ(z)
@inline ∂t_wˢ(x, y, z, t) = + cᵍ / 2k * ∂²ξ_A(x - cᵍ * t, y) * ûˢ(z)

stokes_drift = StokesDrift(; ∂z_uˢ, ∂t_uˢ, ∂y_uˢ, ∂t_wˢ, ∂x_wˢ, ∂y_wˢ)

# output

StokesDrift{Nothing}:
├── ∂x_vˢ: zerofunction
├── ∂x_wˢ: ∂x_wˢ
├── ∂y_uˢ: ∂y_uˢ
├── ∂y_wˢ: ∂y_wˢ
├── ∂z_uˢ: ∂z_uˢ
├── ∂z_vˢ: zerofunction
├── ∂t_uˢ: ∂t_uˢ
├── ∂t_vˢ: zerofunction
└── ∂t_wˢ: ∂t_wˢ</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/StokesDrifts.jl#L223-L313">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.StokesDrifts.UniformStokesDrift-Tuple{}"><a class="docstring-binding" href="#Oceananigans.StokesDrifts.UniformStokesDrift-Tuple{}"><code>Oceananigans.StokesDrifts.UniformStokesDrift</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">UniformStokesDrift(; ∂z_uˢ=zerofunction, ∂z_vˢ=zerofunction, ∂t_uˢ=zerofunction, ∂t_vˢ=zerofunction, parameters=nothing)</code></pre><p>Construct a set of functions for a Stokes drift velocity field corresponding to a horizontally-uniform surface gravity wave field, with optional <code>parameters</code>.</p><p>If <code>parameters=nothing</code>, then the functions <code>∂z_uˢ</code>, <code>∂z_vˢ</code>, <code>∂t_uˢ</code>, <code>∂t_vˢ</code> must be callable with signature <code>(z, t)</code>. If <code>!isnothing(parameters)</code>, then functions must be callable with the signature <code>(z, t, parameters)</code>.</p><p>To resolve the evolution of the Lagrangian-mean momentum, we require vertical-derivatives and time-derivatives of the horizontal components of the Stokes drift, <code>uˢ</code> and <code>vˢ</code>.</p><p><strong>Examples</strong></p><p>Exponentially decaying Stokes drift corresponding to a surface Stokes drift of <code>uˢ(z=0) = 0.005</code> and decay scale <code>h = 20</code>:</p><pre><code class="language-julia hljs">using Oceananigans

@inline uniform_stokes_shear(z, t) = 0.005 * exp(z / 20)

stokes_drift = UniformStokesDrift(∂z_uˢ=uniform_stokes_shear)

# output

UniformStokesDrift{Nothing}:
├── ∂z_uˢ: uniform_stokes_shear
├── ∂z_vˢ: zerofunction
├── ∂t_uˢ: zerofunction
└── ∂t_vˢ: zerofunction</code></pre><p>Exponentially-decaying Stokes drift corresponding to a surface Stokes drift of <code>uˢ = 0.005</code> and decay scale <code>h = 20</code>, using parameters:</p><pre><code class="language-julia hljs">using Oceananigans

@inline uniform_stokes_shear(z, t, p) = p.uˢ * exp(z / p.h)

stokes_drift_parameters = (uˢ = 0.005, h = 20)
stokes_drift = UniformStokesDrift(∂z_uˢ=uniform_stokes_shear, parameters=stokes_drift_parameters)

# output

UniformStokesDrift with parameters (uˢ=0.005, h=20):
├── ∂z_uˢ: uniform_stokes_shear
├── ∂z_vˢ: zerofunction
├── ∂t_uˢ: zerofunction
└── ∂t_vˢ: zerofunction</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/StokesDrifts.jl#L69-L123">source</a></section></details></article><h2 id="Time-steppers"><a class="docs-heading-anchor" href="#Time-steppers">Time steppers</a><a id="Time-steppers-1"></a><a class="docs-heading-anchor-permalink" href="#Time-steppers" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Oceananigans.TimeSteppers.Clock"><a class="docstring-binding" href="#Oceananigans.TimeSteppers.Clock"><code>Oceananigans.TimeSteppers.Clock</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">mutable struct Clock{TT, DT, IT, S}</code></pre><p>Keeps track of the current <code>time</code>, <code>last_Δt</code>, <code>iteration</code> number, and time-stepping <code>stage</code>. The <code>stage</code> is updated only for multi-stage time-stepping methods. The <code>time :: TT</code> is either a <code>Number</code> or a <code>DateTime</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/TimeSteppers/clock.jl#L9-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.TimeSteppers.Clock-Tuple{}"><a class="docstring-binding" href="#Oceananigans.TimeSteppers.Clock-Tuple{}"><code>Oceananigans.TimeSteppers.Clock</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Clock(; time, last_Δt=Inf, last_stage_Δt=Inf, iteration=0, stage=1)</code></pre><p>Return a <code>Clock</code> object. By default, <code>Clock</code> is initialized to the zeroth <code>iteration</code> and first time step <code>stage</code> with <code>last_Δt=last_stage_Δt=Inf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/TimeSteppers/clock.jl#L24-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper-Union{Tuple{IT}, Tuple{Any, Any}, Tuple{Any, Any, Any}} where IT"><a class="docstring-binding" href="#Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper-Union{Tuple{IT}, Tuple{Any, Any}, Tuple{Any, Any, Any}} where IT"><code>Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">QuasiAdamsBashforth2TimeStepper(grid, prognostic_fields, χ = 0.1;
                                implicit_solver = nothing,
                                Gⁿ = map(similar, prognostic_fields),
                                G⁻ = map(similar, prognostic_fields))</code></pre><p>Return a 2nd-order quasi Adams-Bashforth (AB2) time stepper (<code>QuasiAdamsBashforth2TimeStepper</code>) on <code>grid</code>, with <code>tracers</code>, and AB2 parameter <code>χ</code>. The tendency fields <code>Gⁿ</code> and <code>G⁻</code>, usually equal to the <code>prognostic_fields</code> that is passed as positional argument, can be specified via optional <code>kwargs</code>.</p><p>The 2nd-order quasi Adams-Bashforth timestepper steps forward the state <code>Uⁿ</code> by <code>Δt</code> via</p><pre><code class="language-julia hljs">Uⁿ⁺¹ = Uⁿ + Δt * [(3/2 + χ) * Gⁿ - (1/2 + χ) * Gⁿ⁻¹]</code></pre><p>where <code>Uⁿ</code> is the state at the <span>$n$</span>-th timestep, <code>Gⁿ</code> is the tendency at the <span>$n$</span>-th timestep, and <code>Gⁿ⁻¹</code> is the tendency at the previous timestep (<code>G⁻</code>).</p><div class="admonition is-info" id="First-timestep-718919516b95db85"><header class="admonition-header">First timestep<a class="admonition-anchor" href="#First-timestep-718919516b95db85" title="Permalink"></a></header><div class="admonition-body"><p>For the first timestep, since there are no saved tendencies from the previous timestep, the <code>QuasiAdamsBashforth2TimeStepper</code> performs an Euler timestep:</p><pre><code class="language-julia hljs">Uⁿ⁺¹ = Uⁿ + Δt * Gⁿ</code></pre></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/TimeSteppers/quasi_adams_bashforth_2.jl#L11-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.TimeSteppers.RungeKutta3TimeStepper"><a class="docstring-binding" href="#Oceananigans.TimeSteppers.RungeKutta3TimeStepper"><code>Oceananigans.TimeSteppers.RungeKutta3TimeStepper</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RungeKutta3TimeStepper{FT, TG} &lt;: AbstractTimeStepper</code></pre><p>Hold parameters and tendency fields for a low storage, third-order Runge-Kutta-Wray time-stepping scheme described by <a href="../../references/#LeMoin1991">Le and Moin (1991)</a>.</p><p><strong>References</strong></p><p>Le, H. and Moin, P. (1991). An improvement of fractional step methods for the incompressible     Navier–Stokes equations. Journal of Computational Physics, 92, 369–379.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/TimeSteppers/runge_kutta_3.jl#L5-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.TimeSteppers.RungeKutta3TimeStepper-Union{Tuple{TG}, Tuple{TI}, Tuple{Any, Any}} where {TI, TG}"><a class="docstring-binding" href="#Oceananigans.TimeSteppers.RungeKutta3TimeStepper-Union{Tuple{TG}, Tuple{TI}, Tuple{Any, Any}} where {TI, TG}"><code>Oceananigans.TimeSteppers.RungeKutta3TimeStepper</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">RungeKutta3TimeStepper(grid, prognostic_fields;
                       implicit_solver = nothing,
                       Gⁿ = map(similar, prognostic_fields),
                       G⁻ = map(similar, prognostic_fields))</code></pre><p>Return a 3rd-order Runge-Kutta timestepper (<code>RungeKutta3TimeStepper</code>) on <code>grid</code> and with <code>prognostic_fields</code>. The tendency fields <code>Gⁿ</code> and <code>G⁻</code>, typically equal to the <code>prognostic_fields</code> can be modified via the optional <code>kwargs</code>.</p><p>The scheme is described by <a href="../../references/#LeMoin1991">Le and Moin (1991)</a>. In a nutshell, the 3rd-order Runge-Kutta timestepper steps forward the state <code>Uⁿ</code> by <code>Δt</code> via 3 substeps. A pressure correction step is applied after at each substep.</p><p>The state <code>U</code> after each substep <code>m</code> is</p><pre><code class="language-julia hljs">Uᵐ⁺¹ = Uᵐ + Δt * (γᵐ * Gᵐ + ζᵐ * Gᵐ⁻¹)</code></pre><p>where <code>Uᵐ</code> is the state at the <span>$m$</span>-th substep, <code>Gᵐ</code> is the tendency at the <span>$m$</span>-th substep, <code>Gᵐ⁻¹</code> is the tendency at the previous substep, and constants <code>γ¹ = 8/15</code>, <code>γ² = 5/12</code>, <code>γ³ = 3/4</code>, <code>ζ¹ = 0</code>, <code>ζ² = -17/60</code>, and <code>ζ³ = -5/12</code>.</p><p>The state at the first substep is taken to be the one that corresponds to the <span>$n$</span>-th timestep, <code>U¹ = Uⁿ</code>, and the state after the third substep is then the state at the <code>Uⁿ⁺¹ = U⁴</code>.</p><p><strong>References</strong></p><p>Le, H. and Moin, P. (1991). An improvement of fractional step methods for the incompressible     Navier–Stokes equations. Journal of Computational Physics, 92, 369–379.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/TimeSteppers/runge_kutta_3.jl#L27-L60">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.TimeSteppers.SplitRungeKutta3TimeStepper"><a class="docstring-binding" href="#Oceananigans.TimeSteppers.SplitRungeKutta3TimeStepper"><code>Oceananigans.TimeSteppers.SplitRungeKutta3TimeStepper</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SplitRungeKutta3TimeStepper{FT, TG, PF, TI} &lt;: AbstractTimeStepper</code></pre><p>Hold parameters and tendency fields for a low storage, third-order Runge-Kutta-Wray time-stepping scheme described by <a href="../../references/#Lan2022">Lan et al. (2022)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/TimeSteppers/split_hydrostatic_runge_kutta_3.jl#L4-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.TimeSteppers.SplitRungeKutta3TimeStepper-Union{Tuple{PF}, Tuple{TG}, Tuple{TI}, Tuple{Any, Any, Vararg{Any}}} where {TI, TG, PF}"><a class="docstring-binding" href="#Oceananigans.TimeSteppers.SplitRungeKutta3TimeStepper-Union{Tuple{PF}, Tuple{TG}, Tuple{TI}, Tuple{Any, Any, Vararg{Any}}} where {TI, TG, PF}"><code>Oceananigans.TimeSteppers.SplitRungeKutta3TimeStepper</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SplitRungeKutta3TimeStepper(grid, prognostic_fields, args...;
                            implicit_solver::TI = nothing,
                            Gⁿ::TG = map(similar, prognostic_fields),
                            Ψ⁻::PF = map(similar, prognostic_fields),
                            kwargs...) where {TI, TG, PF}</code></pre><p>Return a 3rd-order <code>SplitRungeKutta3TimeStepper</code> on <code>grid</code> and with <code>tracers</code>. The tendency fields <code>Gⁿ</code> and <code>G⁻</code>, and the previous state <code>Ψ⁻</code> can be modified via optional <code>kwargs</code>.</p><p>The scheme is described by <a href="../../references/#knoth2014">Knoth and Wensch (2014)</a>. In a nutshell, the 3rd-order Runge-Kutta timestepper steps forward the state <code>Uⁿ</code> by <code>Δt</code> via 3 substeps. A barotropic velocity correction step is applied after at each substep.</p><p>The state <code>U</code> after each substep <code>m</code> is equivalent to an Euler step with a modified time step:</p><pre><code class="language-julia hljs">Δt̃   = Δt / βᵐ
Uᵐ⁺¹ = Uⁿ + Δt̃ * Gᵐ</code></pre><p>where <code>Uᵐ</code> is the state at the <span>$m$</span>-th substep, <code>Uⁿ</code> is the state at the <span>$n$</span>-th timestep, <code>Gᵐ</code> is the tendency at the <span>$m$</span>-th substep, and constants <code>β¹ = 3</code>, <code>β² = 2</code>, <code>β³ = 1</code>.</p><p>The state at the first substep is taken to be the one that corresponds to the <span>$n$</span>-th timestep, <code>U¹ = Uⁿ</code>, and the state after the third substep is then the state at the <code>Uⁿ⁺¹ = U³</code>.</p><p><strong>References</strong></p><p>Knoth, O., and Wensch, J. (2014). Generalized Split-Explicit Runge-Kutta methods for the     compressible Euler equations. Monthly Weather Review, 142, 2067-2081,     https://doi.org/10.1175/MWR-D-13-00068.1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/TimeSteppers/split_hydrostatic_runge_kutta_3.jl#L18-L52">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.TimeSteppers.time_step!-Tuple{Oceananigans.AbstractModel{&lt;:QuasiAdamsBashforth2TimeStepper}, Any}"><a class="docstring-binding" href="#Oceananigans.TimeSteppers.time_step!-Tuple{Oceananigans.AbstractModel{&lt;:QuasiAdamsBashforth2TimeStepper}, Any}"><code>Oceananigans.TimeSteppers.time_step!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">time_step!(model::AbstractModel{&lt;:QuasiAdamsBashforth2TimeStepper}, Δt; euler=false)</code></pre><p>Step forward <code>model</code> one time step <code>Δt</code> with a 2nd-order Adams-Bashforth method and pressure-correction substep. Setting <code>euler=true</code> will take a forward Euler time step. The tendencies are calculated by the <code>update_step!</code> at the end of the <code>time_step!</code> function.</p><p>The steps of the Quasi-Adams-Bashforth second-order (AB2) algorithm are:</p><ol><li>If this the first time step (<code>model.clock.iteration == 0</code>), then call <code>update_state!</code> and calculate the tendencies.</li><li>Advance tracers in time and compute predictor velocities (including implicit vertical diffusion).</li><li>Solve the elliptic equation for pressure (three dimensional for the non-hydrostatic model, two-dimensional for the hydrostatic model).</li><li>Correct the velocities based on the results of step 3.</li><li>Store the old tendencies.</li><li>Update the model state.</li><li>Compute tendencies for the next time step</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/TimeSteppers/quasi_adams_bashforth_2.jl#L57-L73">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.TimeSteppers.time_step!-Tuple{Oceananigans.AbstractModel{&lt;:RungeKutta3TimeStepper}, Any}"><a class="docstring-binding" href="#Oceananigans.TimeSteppers.time_step!-Tuple{Oceananigans.AbstractModel{&lt;:RungeKutta3TimeStepper}, Any}"><code>Oceananigans.TimeSteppers.time_step!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">time_step!(model::AbstractModel{&lt;:RungeKutta3TimeStepper}, Δt)</code></pre><p>Step forward <code>model</code> one time step <code>Δt</code> with a 3rd-order Runge-Kutta method. The 3rd-order Runge-Kutta method takes three intermediate substep stages to achieve a single timestep. A pressure correction step is applied at each intermediate stage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/TimeSteppers/runge_kutta_3.jl#L86-L93">source</a></section></details></article><h2 id="Turbulence-closures"><a class="docs-heading-anchor" href="#Turbulence-closures">Turbulence closures</a><a id="Turbulence-closures-1"></a><a class="docs-heading-anchor-permalink" href="#Turbulence-closures" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation"><a class="docstring-binding" href="#Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation"><code>Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AnisotropicMinimumDissipation{FT} &lt;: AbstractTurbulenceClosure</code></pre><p>Parameters for the &quot;anisotropic minimum dissipation&quot; turbulence closure for large eddy simulation proposed originally by <a href="../../references/#Rozema15">Rozema <em>et al.</em> (2015)</a> and <a href="../../references/#Abkar16">Abkar <em>et al.</em> (2016)</a>, then modified by <a href="../../references/#Verstappen18">Verstappen (2018)</a>, and finally described and validated for by <a href="../../references/#Vreugdenhil18">Vreugdenhil and Taylor (2018)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L5-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation-Union{Tuple{}, Tuple{TD}, Tuple{TD, Any}} where TD"><a class="docstring-binding" href="#Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation-Union{Tuple{}, Tuple{TD}, Tuple{TD, Any}} where TD"><code>Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">AnisotropicMinimumDissipation([time_discretization = ExplicitTimeDiscretization, FT = Float64;]
                              C = 1/3, Cν = nothing, Cκ = nothing, Cb = nothing)</code></pre><p>Return parameters of type <code>FT</code> for the <code>AnisotropicMinimumDissipation</code> turbulence closure.</p><p><strong>Arguments</strong></p><ul><li><p><code>time_discretization</code>: Either <code>ExplicitTimeDiscretization()</code> or <code>VerticallyImplicitTimeDiscretization()</code>,                        which integrates the terms involving only <span>$z$</span>-derivatives in the                        viscous and diffusive fluxes with an implicit time discretization.                        Default <code>ExplicitTimeDiscretization()</code>.</p></li><li><p><code>FT</code>: Float type; default <code>Float64</code>.</p></li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>C</code>: Poincaré constant for both eddy viscosity and eddy diffusivities. <code>C</code> is overridden      for eddy viscosity or eddy diffusivity if <code>Cν</code> or <code>Cκ</code> are set, respectively.</p></li><li><p><code>Cν</code>: Poincaré constant for momentum eddy viscosity.</p></li><li><p><code>Cκ</code>: Poincaré constant for tracer eddy diffusivities. If one number or function, the same       number or function is applied to all tracers. If a <code>NamedTuple</code>, it must possess       a field specifying the Poincaré constant for every tracer.</p></li><li><p><code>Cb</code>: Buoyancy modification multiplier (<code>Cb = nothing</code> turns it off, <code>Cb = 1</code> was used by       <a href="../../references/#Abkar16">Abkar et al. (2016)</a>). <em>Note</em>: that we <em>do not</em> subtract the       horizontally-average component before computing this buoyancy modification term.       This implementation differs from that by <a href="../../references/#Abkar16">Abkar et al. (2016)</a>&#39;s proposal       and the impact of this approximation has not been tested or validated.</p></li></ul><p>By default: <code>C = Cν = Cκ = 1/3</code>, and <code>Cb = nothing</code>, which turns off the buoyancy modification term. The default Poincaré constant is found by discretizing subgrid scale energy production, assuming a second-order advection scheme. <a href="../../references/#Verstappen14">Verstappen et al. (2014)</a> show that the Poincaré constant should be 4 times larger than for straightforward (spectral) discretisation, resulting in <code>C = 1/3</code> in our formulation. They also empirically demonstrated that this coefficient produces the correct discrete production-dissipation balance. Further demonstration of this can be found at <a href="https://github.com/CliMA/Oceananigans.jl/issues/4367">https://github.com/CliMA/Oceananigans.jl/issues/4367</a>.</p><p><code>C</code>, <code>Cν</code> and <code>Cκ</code> may be numbers, or functions of <code>x, y, z</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; pretty_diffusive_closure = AnisotropicMinimumDissipation(C=1/2)
AnisotropicMinimumDissipation{ExplicitTimeDiscretization} turbulence closure with:
           Poincaré constant for momentum eddy viscosity Cν: 0.5
    Poincaré constant for tracer(s) eddy diffusivit(ies) Cκ: 0.5
                        Buoyancy modification multiplier Cb: nothing</code></pre><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; const Δz = 0.5; # grid resolution at surface

julia&gt; surface_enhanced_tracer_C(x, y, z) = 1/12 * (1 + exp((z + Δz/2) / 8Δz));

julia&gt; fancy_closure = AnisotropicMinimumDissipation(Cκ=surface_enhanced_tracer_C)
AnisotropicMinimumDissipation{ExplicitTimeDiscretization} turbulence closure with:
           Poincaré constant for momentum eddy viscosity Cν: 0.3333333333333333
    Poincaré constant for tracer(s) eddy diffusivit(ies) Cκ: surface_enhanced_tracer_C
                        Buoyancy modification multiplier Cb: nothing</code></pre><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; tracer_specific_closure = AnisotropicMinimumDissipation(Cκ=(c₁=1/12, c₂=1/6))
AnisotropicMinimumDissipation{ExplicitTimeDiscretization} turbulence closure with:
           Poincaré constant for momentum eddy viscosity Cν: 0.3333333333333333
    Poincaré constant for tracer(s) eddy diffusivit(ies) Cκ: (c₁ = 0.08333333333333333, c₂ = 0.16666666666666666)
                        Buoyancy modification multiplier Cb: nothing</code></pre><p><strong>References</strong></p><p>Abkar, M., Bae, H. J., &amp; Moin, P. (2016). Minimum-dissipation scalar transport model for     large-eddy simulation of turbulent flows. Physical Review Fluids, 1(4), 041701.</p><p>Verstappen, R., Rozema, W., and Bae, J. H. (2014), &quot;Numerical scale separation in large-eddy     simulation&quot;, Center for Turbulence ResearchProceedings of the Summer Program 2014.</p><p>Vreugdenhil C., and Taylor J. (2018), &quot;Large-eddy simulations of stratified plane Couette     flow using the anisotropic minimum-dissipation model&quot;, Physics of Fluids 30, 085104.</p><p>Verstappen, R. (2018), &quot;How much eddy dissipation is needed to counterbalance the nonlinear     production of small, unresolved scales in a large-eddy simulation of turbulence?&quot;,     Computers &amp; Fluids 176, pp. 276-284.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L40-L137">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.TurbulenceClosures.ConvectiveAdjustmentVerticalDiffusivity"><a class="docstring-binding" href="#Oceananigans.TurbulenceClosures.ConvectiveAdjustmentVerticalDiffusivity"><code>Oceananigans.TurbulenceClosures.ConvectiveAdjustmentVerticalDiffusivity</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ConvectiveAdjustmentVerticalDiffusivity([time_discretization = VerticallyImplicitTimeDiscretization(), FT=Float64;]
                                        convective_κz = 0,
                                        convective_νz = 0,
                                        background_κz = 0,
                                        background_νz = 0)</code></pre><p>Return a convective adjustment vertical diffusivity closure that applies different values of diffusivity and/or viscosity depending whether the region is statically stable (positive or zero buoyancy gradient) or statically unstable (negative buoyancy gradient).</p><p><strong>Arguments</strong></p><ul><li><p><code>time_discretization</code>: Either <code>ExplicitTimeDiscretization()</code> or <code>VerticallyImplicitTimeDiscretization()</code>;                        default <code>VerticallyImplicitTimeDiscretization()</code>.</p></li><li><p><code>FT</code>: Float type; default <code>Float64</code>.</p></li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>convective_κz</code>: Vertical tracer diffusivity in regions with negative (unstable) buoyancy gradients. Either                  a single number, function, array, field, or tuple of diffusivities for each tracer.</p></li><li><p><code>background_κz</code>: Vertical tracer diffusivity in regions with zero or positive (stable) buoyancy gradients.</p></li><li><p><code>convective_νz</code>: Vertical viscosity in regions with negative (unstable) buoyancy gradients. Either                 a number, function, array, or field.</p></li><li><p><code>background_κz</code>: Vertical viscosity in regions with zero or positive (stable) buoyancy gradients.</p></li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; cavd = ConvectiveAdjustmentVerticalDiffusivity(convective_κz = 1)
ConvectiveAdjustmentVerticalDiffusivity{VerticallyImplicitTimeDiscretization}(background_κz=0.0 convective_κz=1 background_νz=0.0 convective_νz=0.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/TurbulenceClosures/turbulence_closure_implementations/convective_adjustment_vertical_diffusivity.jl#L21-L61">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization"><a class="docstring-binding" href="#Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization"><code>Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ExplicitTimeDiscretization &lt;: AbstractTimeDiscretization</code></pre><p>A fully-explicit time-discretization of a <code>TurbulenceClosure</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/TurbulenceClosures/implicit_explicit_time_discretization.jl#L3-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.TurbulenceClosures.HorizontalDivergenceScalarDiffusivity"><a class="docstring-binding" href="#Oceananigans.TurbulenceClosures.HorizontalDivergenceScalarDiffusivity"><code>Oceananigans.TurbulenceClosures.HorizontalDivergenceScalarDiffusivity</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">HorizontalDivergenceScalarDiffusivity([time_discretization=ExplicitTimeDiscretization(),
                                      FT::DataType=Float64;]
                                      kwargs...)</code></pre><p>Shorthand for a <code>ScalarDiffusivity</code> with <code>HorizontalDivergenceFormulation()</code>. See <a href="#Oceananigans.TurbulenceClosures.ScalarDiffusivity"><code>ScalarDiffusivity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L170-L176">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.TurbulenceClosures.HorizontalScalarDiffusivity"><a class="docstring-binding" href="#Oceananigans.TurbulenceClosures.HorizontalScalarDiffusivity"><code>Oceananigans.TurbulenceClosures.HorizontalScalarDiffusivity</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">HorizontalScalarDiffusivity([time_discretization=ExplicitTimeDiscretization(),
                            FT::DataType=Float64;]
                            kwargs...)</code></pre><p>Shorthand for a <code>ScalarDiffusivity</code> with <code>HorizontalFormulation()</code>. See <a href="#Oceananigans.TurbulenceClosures.ScalarDiffusivity"><code>ScalarDiffusivity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L159-L165">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.TurbulenceClosures.IsopycnalSkewSymmetricDiffusivity-Union{Tuple{}, Tuple{A}, Tuple{TD}, Tuple{TD, Any}} where {TD, A}"><a class="docstring-binding" href="#Oceananigans.TurbulenceClosures.IsopycnalSkewSymmetricDiffusivity-Union{Tuple{}, Tuple{A}, Tuple{TD}, Tuple{TD, Any}} where {TD, A}"><code>Oceananigans.TurbulenceClosures.IsopycnalSkewSymmetricDiffusivity</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">IsopycnalSkewSymmetricDiffusivity([time_disc=VerticallyImplicitTimeDiscretization(), FT=Float64;]
                                  κ_skew = 0,
                                  κ_symmetric = 0,
                                  skew_flux_formulation = DiffusiveFormulation(),
                                  isopycnal_tensor = SmallSlopeIsopycnalTensor(),
                                  slope_limiter = FluxTapering(1e-2))</code></pre><p>Return parameters for an isopycnal skew-symmetric tracer diffusivity with skew diffusivity <code>κ_skew</code> and symmetric diffusivity <code>κ_symmetric</code> that uses an <code>isopycnal_tensor</code> model for for calculating the isopycnal slopes, and (optionally) applying a <code>slope_limiter</code> to the calculated isopycnal slope values. The skew fluxes can be computed using either the <code>AdvectiveFormulation</code> or the <code>DiffusiveFormulation</code>.</p><p>Both <code>κ_skew</code> and <code>κ_symmetric</code> may be constants, arrays, fields, or functions of <code>(x, y, z, t)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/TurbulenceClosures/turbulence_closure_implementations/isopycnal_skew_symmetric_diffusivity.jl#L34-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.TurbulenceClosures.RiBasedVerticalDiffusivity"><a class="docstring-binding" href="#Oceananigans.TurbulenceClosures.RiBasedVerticalDiffusivity"><code>Oceananigans.TurbulenceClosures.RiBasedVerticalDiffusivity</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RiBasedVerticalDiffusivity([time_discretization = VerticallyImplicitTimeDiscretization(),
                           FT = Float64;]
                           Ri_dependent_tapering = HyperbolicTangentRiDependentTapering(),
                           horizontal_Ri_filter = nothing,
                           minimum_entrainment_buoyancy_gradient = 1e-10,
                           maximum_diffusivity = Inf,
                           maximum_viscosity = Inf,
                           ν₀  = 0.7,
                           κ₀  = 0.5,
                           κᶜᵃ = 1.7,
                           Cᵉⁿ = 0.1,
                           Cᵃᵛ = 0.6,
                           Ri₀ = 0.1,
                           Riᵟ = 0.4,
                           warning = true)</code></pre><p>Return a closure that estimates the vertical viscosity and diffusivity from &quot;convective adjustment&quot; coefficients <code>ν₀</code> and <code>κ₀</code> multiplied by a decreasing function of the Richardson number, <span>$Ri$</span>.</p><p><strong>Arguments</strong></p><ul><li><p><code>time_discretization</code>: Either <code>ExplicitTimeDiscretization()</code> or <code>VerticallyImplicitTimeDiscretization()</code>,                        which integrates the terms involving only <span>$z$</span>-derivatives in the                        viscous and diffusive fluxes with an implicit time discretization.                        Default <code>VerticallyImplicitTimeDiscretization()</code>.</p></li><li><p><code>FT</code>: Float type; default <code>Float64</code>.</p></li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>Ri_dependent_tapering</code>: The <span>$Ri$</span>-dependent tapering. Options are: <code>PiecewiseLinearRiDependentTapering()</code>, <code>HyperbolicTangentRiDependentTapering()</code> (default), and <code>ExponentialRiDependentTapering()</code>.</p></li><li><p><code>ν₀</code>: Non-convective viscosity (units of kinematic viscosity, typically m² s⁻¹).</p></li><li><p><code>κ₀</code>: Non-convective diffusivity for tracers (units of diffusivity, typically m² s⁻¹).</p></li><li><p><code>κᶜᵃ</code>: Convective adjustment diffusivity for tracers (units of diffusivity, typically m² s⁻¹).</p></li><li><p><code>Cᵉⁿ</code>: Entrainment coefficient for tracers (non-dimensional).        Set <code>Cᵉⁿ = 0</code> to turn off the penetrative entrainment diffusivity.</p></li><li><p><code>Cᵃᵛ</code>: Time-averaging coefficient for viscosity and diffusivity (non-dimensional).</p></li><li><p><code>Ri₀</code>: <span>$Ri$</span> threshold for decreasing viscosity and diffusivity (non-dimensional).</p></li><li><p><code>Riᵟ</code>: <span>$Ri$</span>-width over which viscosity and diffusivity decreases to 0 (non-dimensional).</p></li><li><p><code>minimum_entrainment_buoyancy_gradient</code>: Minimum buoyancy gradient for application of the entrainment                                          diffusvity. If the entrainment buoyancy gradient is less than the                                          minimum value, the entrainment diffusivity is 0. Units of                                          buoyancy gradient (typically s⁻²).</p></li><li><p><code>maximum_diffusivity</code>: A limiting maximum tracer diffusivity (units of diffusivity, typically m² s⁻¹).</p></li><li><p><code>maximum_viscosity</code>: A limiting maximum viscosity (units of kinematic viscosity, typically m² s⁻¹).</p></li><li><p><code>horizontal_Ri_filter</code>: Horizontal filter to apply to Ri, which can help alleviate noise for                         some simulations. The default is <code>nothing</code>, or no filtering. The other                         option is <code>horizontal_Ri_filter = FivePointHorizontalFilter()</code>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/TurbulenceClosures/turbulence_closure_implementations/ri_based_vertical_diffusivity.jl#L58-L124">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.TurbulenceClosures.ScalarBiharmonicDiffusivity"><a class="docstring-binding" href="#Oceananigans.TurbulenceClosures.ScalarBiharmonicDiffusivity"><code>Oceananigans.TurbulenceClosures.ScalarBiharmonicDiffusivity</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ScalarBiharmonicDiffusivity(formulation = ThreeDimensionalFormulation(), FT = Oceananigans.defaults.FloatType;
                            ν = 0,
                            κ = 0,
                            discrete_form = false,
                            loc = (nothing, nothing, nothing),
                            parameters = nothing)</code></pre><p>Return a scalar biharmonic diffusivity turbulence closure with viscosity coefficient <code>ν</code> and tracer diffusivities <code>κ</code> for each tracer field in <code>tracers</code>. If a single <code>κ</code> is provided, it is applied to all tracers. Otherwise <code>κ</code> must be a <code>NamedTuple</code> with values for every tracer individually.</p><p><strong>Arguments</strong></p><ul><li><p><code>formulation</code>:</p><ul><li><code>HorizontalFormulation()</code> for diffusivity applied in the horizontal direction(s)</li><li><code>VerticalFormulation()</code> for diffusivity applied in the vertical direction,</li><li><code>ThreeDimensionalFormulation()</code> (default) for diffusivity applied isotropically to all directions</li><li><code>HorizontalDivergenceFormulation()</code> for horizontal viscosity with &quot;divergence damping&quot; and no effect on tracers</li><li><code>HorizontalVectorInvariantFormulation()</code> for horizontally isotropic vector invariant diffusivity</li></ul></li><li><p><code>FT</code>: the float datatype (default: <code>Float64</code>)</p></li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>ν</code>: Viscosity. <code>Number</code>, <code>AbstractArray</code>, <code>Field</code>, or <code>Function</code>.</p></li><li><p><code>κ</code>: Diffusivity. <code>Number</code>, <code>AbstractArray</code>, <code>Field</code>, <code>Function</code>, or      <code>NamedTuple</code> of diffusivities with entries for each tracer.</p></li><li><p><code>discrete_form</code>: <code>Boolean</code>; default: <code>false</code>.</p></li><li><p><code>required_halo_size = 2</code>: the required halo size for the closure. This value should be an integer. change only if using a function for <code>ν</code> or <code>κ</code> that requires a halo size larger than 1 to compute.</p></li></ul><p>When prescribing the viscosities or diffusivities as functions, depending on the value of keyword argument <code>discrete_form</code>, the constructor expects:</p><ul><li><p><code>discrete_form = false</code> (default): functions of the grid&#39;s native coordinates and time, e.g., <code>(x, y, z, t)</code> for a <code>RectilinearGrid</code> or <code>(λ, φ, z, t)</code> for a <code>LatitudeLongitudeGrid</code>.</p></li><li><p><code>discrete_form = true</code>:</p><ul><li>with <code>loc = (nothing, nothing, nothing)</code> (default): functions of <code>(i, j, k, grid, ℓx, ℓy, ℓz)</code> with <code>ℓx</code>, <code>ℓy</code>, and <code>ℓz</code> either <code>Face()</code> or <code>Center()</code>.</li><li>with <code>loc = (ℓx, ℓy, ℓz)</code> with <code>ℓx</code>, <code>ℓy</code>, and <code>ℓz</code> either <code>Face()</code> or <code>Center()</code>: functions of <code>(i, j, k, grid)</code>.</li></ul></li><li><p><code>parameters</code>: <code>NamedTuple</code> with parameters used by the functions that compute viscosity and/or diffusivity; default: <code>nothing</code>.</p></li></ul><p>For examples see <a href="#Oceananigans.TurbulenceClosures.ScalarDiffusivity"><code>ScalarDiffusivity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/TurbulenceClosures/turbulence_closure_implementations/scalar_biharmonic_diffusivity.jl#L21-L76">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.TurbulenceClosures.ScalarBiharmonicDiffusivity"><a class="docstring-binding" href="#Oceananigans.TurbulenceClosures.ScalarBiharmonicDiffusivity"><code>Oceananigans.TurbulenceClosures.ScalarBiharmonicDiffusivity</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ScalarBiharmonicDiffusivity{F, N, V, K} &lt;: AbstractScalarBiharmonicDiffusivity{F}</code></pre><p>Holds viscosity and diffusivities for models with prescribed isotropic diffusivities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/TurbulenceClosures/turbulence_closure_implementations/scalar_biharmonic_diffusivity.jl#L3-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.TurbulenceClosures.ScalarDiffusivity"><a class="docstring-binding" href="#Oceananigans.TurbulenceClosures.ScalarDiffusivity"><code>Oceananigans.TurbulenceClosures.ScalarDiffusivity</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ScalarDiffusivity(time_discretization = ExplicitTimeDiscretization(),
                  formulation = ThreeDimensionalFormulation(), FT = Float64;
                  ν = 0,
                  κ = 0,
                  discrete_form = false,
                  loc = (nothing, nothing, nothing),
                  parameters = nothing)</code></pre><p>Return <code>ScalarDiffusivity</code> turbulence closure with viscosity <code>ν</code> and tracer diffusivities <code>κ</code> for each tracer field in <code>tracers</code>. If a single <code>κ</code> is provided, it is applied to all tracers. Otherwise <code>κ</code> must be a <code>NamedTuple</code> with values for every tracer individually.</p><p><strong>Arguments</strong></p><ul><li><p><code>time_discretization</code>: either <code>ExplicitTimeDiscretization()</code> (default) or <code>VerticallyImplicitTimeDiscretization()</code>.</p></li><li><p><code>formulation</code>:</p><ul><li><code>HorizontalFormulation()</code> for diffusivity applied in the horizontal direction(s)</li><li><code>VerticalFormulation()</code> for diffusivity applied in the vertical direction,</li><li><code>ThreeDimensionalFormulation()</code> (default) for diffusivity applied isotropically to all directions</li></ul></li><li><p><code>FT</code>: the float datatype (default: <code>Float64</code>)</p></li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>ν</code>: Viscosity. <code>Number</code>, <code>AbstractArray</code>, <code>Field</code>, or <code>Function</code>.</p></li><li><p><code>κ</code>: Diffusivity. <code>Number</code>, <code>AbstractArray</code>, <code>Field</code>, <code>Function</code>, or      <code>NamedTuple</code> of diffusivities with entries for each tracer.</p></li><li><p><code>discrete_form</code>: <code>Boolean</code>; default: <code>false</code>.</p></li></ul><p>When prescribing the viscosities or diffusivities as functions, depending on the value of keyword argument <code>discrete_form</code>, the constructor expects:</p><ul><li><p><code>discrete_form = false</code> (default): functions of the grid&#39;s native coordinates and time, e.g., <code>(x, y, z, t)</code> for a <code>RectilinearGrid</code> or <code>(λ, φ, z, t)</code> for a <code>LatitudeLongitudeGrid</code>.</p></li><li><p><code>discrete_form = true</code>:</p><ul><li>with <code>loc = (nothing, nothing, nothing)</code> and <code>parameters = nothing</code> (default): functions of <code>(i, j, k, grid, ℓx, ℓy, ℓz, clock, fields)</code> with <code>ℓx</code>, <code>ℓy</code>, and <code>ℓz</code> either <code>Face()</code> or <code>Center()</code>.</li><li>with <code>loc = (ℓx, ℓy, ℓz)</code> with <code>ℓx</code>, <code>ℓy</code>, and <code>ℓz</code> either <code>Face()</code> or <code>Center()</code> and <code>parameters = nothing</code>: functions of <code>(i, j, k, grid, clock, fields)</code>.</li><li>with <code>loc = (nothing, nothing, nothing)</code> and specified <code>parameters</code>: functions of <code>(i, j, k, grid, ℓx, ℓy, ℓz, clock, fields, parameters)</code>.</li><li>with <code>loc = (ℓx, ℓy, ℓz)</code> and specified <code>parameters</code>: functions of <code>(i, j, k, grid, clock, fields, parameters)</code>.</li></ul></li><li><p><code>required_halo_size = 1</code>: the required halo size for the closure. This value should be an integer. change only if using a function for <code>ν</code> or <code>κ</code> that requires a halo size larger than 1 to compute.</p></li><li><p><code>parameters</code>: <code>NamedTuple</code> with parameters used by the functions that compute viscosity and/or diffusivity; default: <code>nothing</code>.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; ScalarDiffusivity(ν=1000, κ=2000)
ScalarDiffusivity{ExplicitTimeDiscretization}(ν=1000.0, κ=2000.0)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; const depth_scale = 100;

julia&gt; @inline ν(x, y, z, t) = 1000 * exp(z / depth_scale)
ν (generic function with 1 method)

julia&gt; ScalarDiffusivity(ν=ν)
ScalarDiffusivity{ExplicitTimeDiscretization}(ν=ν (generic function with 1 method), κ=0.0)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans.Grids: znode

julia&gt; @inline function κ(i, j, k, grid, ℓx, ℓy, ℓz, clock, fields)
           z = znode(i, j, k, grid, ℓx, ℓy, ℓz)
           return 2000 * exp(z / depth_scale)
       end
κ (generic function with 1 method)

julia&gt; ScalarDiffusivity(κ=κ, discrete_form=true)
ScalarDiffusivity{ExplicitTimeDiscretization}(ν=0.0, κ=Oceananigans.TurbulenceClosures.DiscreteDiffusionFunction{Nothing, Nothing, Nothing, Nothing, typeof(κ)})</code></pre><pre><code class="language-julia-repl hljs">julia&gt; @inline function another_κ(i, j, k, grid, clock, fields, p)
           z = znode(i, j, k, grid, Center(), Center(), Face())
           return 2000 * exp(z / p.depth_scale)
       end
another_κ (generic function with 1 method)

julia&gt; ScalarDiffusivity(κ=another_κ, discrete_form=true, loc=(Center, Center, Face), parameters=(; depth_scale = 120.0))
ScalarDiffusivity{ExplicitTimeDiscretization}(ν=0.0, κ=Oceananigans.TurbulenceClosures.DiscreteDiffusionFunction{Center, Center, Face, @NamedTuple{depth_scale::Float64}, typeof(another_κ)})</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L9-L112">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.TurbulenceClosures.TwoDimensionalLeith"><a class="docstring-binding" href="#Oceananigans.TurbulenceClosures.TwoDimensionalLeith"><code>Oceananigans.TurbulenceClosures.TwoDimensionalLeith</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TwoDimensionalLeith(FT=Float64;
                    C=0.3, C_Redi=1, C_GM=1,
                    isopycnal_model=SmallSlopeIsopycnalTensor())</code></pre><p>Return a <code>TwoDimensionalLeith</code> type associated with the turbulence closure proposed by <a href="../../references/#leith1968diffusion">Leith (1968)</a> and <a href="../../references/#Fox-Kemper2008">Fox‐Kemper and Menemenlis (2008)</a> which has an eddy viscosity of the form</p><pre><code class="language-julia hljs">νₑ = (C * Δᶠ)³ * √(|∇ₕ ζ|² + |∇ₕ ∂w/∂z|²)</code></pre><p>and an eddy diffusivity of the form...</p><p>where <code>Δᶠ</code> is the filter width, <code>ζ = ∂v/∂x - ∂u/∂y</code> is the vertical vorticity, and <code>C</code> is a model constant.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>C</code>: Model constant</p></li><li><p><code>C_Redi</code>: Coefficient for down-gradient tracer diffusivity for each tracer.           Either a constant applied to every tracer, or a <code>NamedTuple</code> with fields           for each tracer individually.</p></li><li><p><code>C_GM</code>: Coefficient for down-gradient tracer diffusivity for each tracer.       Either a constant applied to every tracer, or a <code>NamedTuple</code> with fields       for each tracer individually.</p></li></ul><p><strong>References</strong></p><p>Leith, C. E. (1968). &quot;Diffusion Approximation for Two‐Dimensional Turbulence&quot;, The Physics of     Fluids 11, 671. doi: 10.1063/1.1691968</p><p>Fox‐Kemper, B., &amp; D. Menemenlis (2008). &quot;Can large eddy simulation techniques improve mesoscale rich     ocean models?&quot;, in Ocean Modeling in an Eddying Regime, Geophys. Monogr. Ser., 177, pp. 319–337.     doi: 10.1029/177GM19</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl#L20-L60">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.TurbulenceClosures.VerticalScalarDiffusivity"><a class="docstring-binding" href="#Oceananigans.TurbulenceClosures.VerticalScalarDiffusivity"><code>Oceananigans.TurbulenceClosures.VerticalScalarDiffusivity</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">VerticalScalarDiffusivity([time_discretization=ExplicitTimeDiscretization(),
                          FT::DataType=Float64;]
                          kwargs...)</code></pre><p>Shorthand for a <code>ScalarDiffusivity</code> with <code>VerticalFormulation()</code>. See <a href="#Oceananigans.TurbulenceClosures.ScalarDiffusivity"><code>ScalarDiffusivity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L148-L154">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.TurbulenceClosures.VerticallyImplicitTimeDiscretization"><a class="docstring-binding" href="#Oceananigans.TurbulenceClosures.VerticallyImplicitTimeDiscretization"><code>Oceananigans.TurbulenceClosures.VerticallyImplicitTimeDiscretization</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct VerticallyImplicitTimeDiscretization &lt;: AbstractTimeDiscretization</code></pre><p>A vertically-implicit time-discretization of a <code>TurbulenceClosure</code>.</p><p>This implies that a flux divergence such as <span>$𝛁 ⋅ 𝐪$</span> at the <span>$n$</span>-th timestep is time-discretized as</p><pre><code class="language-julia hljs">[∇ ⋅ q]ⁿ = [explicit_flux_divergence]ⁿ + [∂z (κ ∂z c)]ⁿ⁺¹</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/TurbulenceClosures/implicit_explicit_time_discretization.jl#L12-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.TurbulenceClosures.diffusivity"><a class="docstring-binding" href="#Oceananigans.TurbulenceClosures.diffusivity"><code>Oceananigans.TurbulenceClosures.diffusivity</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">diffusivity(closure, tracer_index, closure_fields)</code></pre><p>Returns the scalar diffusivity associated with <code>closure</code> and <code>tracer_index</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl#L59-L63">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.TurbulenceClosures.viscosity"><a class="docstring-binding" href="#Oceananigans.TurbulenceClosures.viscosity"><code>Oceananigans.TurbulenceClosures.viscosity</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">viscosity(closure, diffusivities)</code></pre><p>Returns the scalar viscosity associated with <code>closure</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl#L52-L56">source</a></section></details></article><h3 id="TKEBasedVerticalDiffusivities"><a class="docs-heading-anchor" href="#TKEBasedVerticalDiffusivities">TKEBasedVerticalDiffusivities</a><a id="TKEBasedVerticalDiffusivities-1"></a><a class="docs-heading-anchor-permalink" href="#TKEBasedVerticalDiffusivities" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="Oceananigans.TurbulenceClosures.TKEBasedVerticalDiffusivities.CATKEVerticalDiffusivity-Union{Tuple{}, Tuple{TD}, Tuple{TD, Any}} where TD"><a class="docstring-binding" href="#Oceananigans.TurbulenceClosures.TKEBasedVerticalDiffusivities.CATKEVerticalDiffusivity-Union{Tuple{}, Tuple{TD}, Tuple{TD, Any}} where TD"><code>Oceananigans.TurbulenceClosures.TKEBasedVerticalDiffusivities.CATKEVerticalDiffusivity</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">CATKEVerticalDiffusivity([time_discretization = VerticallyImplicitTimeDiscretization(),
                         FT = Float64;]
                         mixing_length = CATKEMixingLength(),
                         turbulent_kinetic_energy_equation = CATKEEquation(),
                         maximum_tracer_diffusivity = Inf,
                         maximum_tke_diffusivity = Inf,
                         maximum_viscosity = Inf,
                         minimum_tke = 1e-9,
                         minimum_convective_buoyancy_flux = 1e-11,
                         negative_tke_damping_time_scale = 1minute,
                         tke_time_step = nothing)</code></pre><p>Return the <code>CATKEVerticalDiffusivity</code> turbulence closure for vertical mixing by small-scale ocean turbulence based on the prognostic evolution of subgrid Turbulent Kinetic Energy (TKE).</p><div class="admonition is-info" id="CATKE-vertical-diffusivity-847f3485b623a07b"><header class="admonition-header">CATKE vertical diffusivity<a class="admonition-anchor" href="#CATKE-vertical-diffusivity-847f3485b623a07b" title="Permalink"></a></header><div class="admonition-body"><p><code>CATKEVerticalDiffusivity</code> is a new turbulence closure diffusivity. The default values for its free parameters are obtained from calibration against large eddy simulations. For more details please refer to <a href="../../references/#Wagner25catke">Wagner et al. (2025)</a>.</p><p>Use with caution and report any issues with the physics at <a href="https://github.com/CliMA/Oceananigans.jl/issues">https://github.com/CliMA/Oceananigans.jl/issues</a>.</p></div></div><p><strong>Arguments</strong></p><ul><li><p><code>time_discretization</code>: Either <code>ExplicitTimeDiscretization()</code> or <code>VerticallyImplicitTimeDiscretization()</code>;                        default <code>VerticallyImplicitTimeDiscretization()</code>.</p></li><li><p><code>FT</code>: Float type; default <code>Float64</code>.</p></li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>mixing_length</code>: The formulation for mixing length; default: <code>CATKEMixingLength()</code>.</p></li><li><p><code>turbulent_kinetic_energy_equation</code>: The TKE equation; default: <code>CATKEEquation()</code>.</p></li><li><p><code>maximum_tracer_diffusivity</code>: Maximum value for tracer diffusivity. CATKE-predicted tracer                               diffusivities that are larger than <code>maximum_tracer_diffusivity</code>                               are clipped. Default: <code>Inf</code>.</p></li><li><p><code>maximum_tke_diffusivity</code>: Maximum value for TKE diffusivity. CATKE-predicted diffusivities                            for TKE that are larger than <code>maximum_tke_diffusivity</code> are clipped.                            Default: <code>Inf</code>.</p></li><li><p><code>maximum_viscosity</code>: Maximum value for momentum diffusivity. CATKE-predicted momentum diffusivities                      that are larger than <code>maximum_viscosity</code> are clipped. Default: <code>Inf</code>.</p></li><li><p><code>minimum_tke</code>: Minimum value for the turbulent kinetic energy. Can be used to model the presence                &quot;background&quot; TKE levels due to, for example, mixing by breaking internal waves.                Default: 1e-9.</p></li><li><p><code>minimum_convective_buoyancy_flux</code> Minimum value for the convective buoyancy flux. Default: 1e-11.</p></li><li><p><code>negative_tke_damping_time_scale</code>: Damping time-scale for spurious negative values of TKE,                                    typically generated by oscillatory errors associated                                    with the TKE advection. Default: 1 minute.</p></li></ul><p><strong>References</strong></p><p>Wagner, G. L., Hillier, A., Constantinou, N. C., Silvestri, S., Souza, A., Burns, K., Hill,     C., Campin, J.-M., Marshall, J., and Ferrari, R. (2025). Formulation and calibration of CATKE,     a one-equation parameterization for microscale ocean mixing. J. Adv. Model. Earth Sy., 17, e2024MS004522.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl#L45-L111">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.TurbulenceClosures.TKEBasedVerticalDiffusivities.TKEDissipationVerticalDiffusivity-Union{Tuple{}, Tuple{TD}, Tuple{TD, Any}} where TD"><a class="docstring-binding" href="#Oceananigans.TurbulenceClosures.TKEBasedVerticalDiffusivities.TKEDissipationVerticalDiffusivity-Union{Tuple{}, Tuple{TD}, Tuple{TD, Any}} where TD"><code>Oceananigans.TurbulenceClosures.TKEBasedVerticalDiffusivities.TKEDissipationVerticalDiffusivity</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">TKEDissipationVerticalDiffusivity([time_discretization = VerticallyImplicitTimeDiscretization(),
                                  FT = Oceananigans.defaults.FloatType;]
                                  tke_dissipation_equations = TKEDissipationEquations(),
                                  stability_functions = VariableStabilityFunctions(),
                                  minimum_length_scale = StratifiedDisplacementScale(),
                                  maximum_tracer_diffusivity = Inf,
                                  maximum_tke_diffusivity = Inf,
                                  maximum_dissipation_diffusivity = Inf,
                                  maximum_viscosity = Inf,
                                  minimum_tke = 1e-6,
                                  minimum_stratification_number_safety_factor = 0.73,
                                  negative_tke_damping_time_scale = 1minute,
                                  tke_dissipation_time_step = nothing)</code></pre><p>Return the <code>TKEDissipationVerticalDiffusivity</code> turbulence closure for vertical mixing by microscale ocean turbulence based on the prognostic evolution of two variables: the turbulent kinetic energy (TKE), and the turbulent kinetic energy dissipation. Elsewhere this is referred to as &quot;k-ϵ&quot;. For more information about k-ϵ, see <a href="../../references/#burchard2001comparative">Burchard and Bolding (2001)</a>, <a href="../../references/#umlauf2003generic">Umlauf and Burchard (2003)</a>, and <a href="../../references/#umlauf2005second">Umlauf and Burchard (2005)</a>.</p><p><strong>Arguments</strong></p><ul><li><p><code>time_discretization</code>: Either <code>ExplicitTimeDiscretization()</code> or <code>VerticallyImplicitTimeDiscretization()</code>;                        default <code>VerticallyImplicitTimeDiscretization()</code>.</p></li><li><p><code>FT</code>: Float type; default <code>Float64</code>.</p></li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>maximum_diffusivity</code>: Maximum value for tracer, momentum, and TKE diffusivities.                        Used to clip the diffusivity when/if                        TKEDissipationVerticalDiffusivity predicts diffusivities                        that are too large.                        Default: <code>Inf</code>.</p></li><li><p><code>minimum_tke</code>: Minimum value for the turbulent kinetic energy.                Can be used to model the presence &quot;background&quot; TKE                levels due to, for example, mixing by breaking internal waves.                Default: 1e-9.</p></li><li><p><code>negative_tke_damping_time_scale</code>: Damping time-scale for spurious negative values of TKE,                                    typically generated by oscillatory errors associated                                    with TKE advection.                                    Default: 1 minute.</p></li></ul><p>Note that for numerical stability, it is recommended to either have a relative short <code>negative_turbulent_kinetic_energy_damping_time_scale</code> or a reasonable <code>minimum_turbulent_kinetic_energy</code>, or both.</p><p><strong>References</strong></p><p>Burchard, H., and Bolding, K. (2001). Comparative analysis of four second-moment turbulence closure     models for the oceanic mixed layer. Journal of Physical Oceanography, 31(8), 1943-1968.</p><p>Umlauf, L., and H. Burchard. (2003). A generic length-scale equation for geophysical turbulence models.     Journal of Marine Research 61, (2). https://elischolar.library.yale.edu/journal<em>of</em>marine_research/9</p><p>Umlauf, L., and Burchard, H. (2005). Second-order turbulence closure models for geophysical boundary layers.     A review of recent work. Continental Shelf Research, 25(7-8), 795-827.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/tke_dissipation_vertical_diffusivity.jl#L49-L116">source</a></section></details></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Oceananigans.Utils.AndSchedule-Tuple"><a class="docstring-binding" href="#Oceananigans.Utils.AndSchedule-Tuple"><code>Oceananigans.Utils.AndSchedule</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">AndSchedule(schedules...)</code></pre><p>Return a schedule that actuates when all <code>child_schedule</code>s actuate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Utils/schedules.jl#L288-L292">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Utils.ConsecutiveIterations"><a class="docstring-binding" href="#Oceananigans.Utils.ConsecutiveIterations"><code>Oceananigans.Utils.ConsecutiveIterations</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ConsecutiveIterations(parent_schedule)</code></pre><p>Return a <code>schedule::ConsecutiveIterations</code> that actuates both when <code>parent_schedule</code> actuates, and at iterations immediately following the actuation of <code>parent_schedule</code>. This can be used, for example, when one wants to use output to reproduce a first-order approximation of the time derivative of a quantity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Utils/schedules.jl#L255-L262">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Utils.IterationInterval-Tuple{Int64}"><a class="docstring-binding" href="#Oceananigans.Utils.IterationInterval-Tuple{Int64}"><code>Oceananigans.Utils.IterationInterval</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">IterationInterval(interval; offset=0)</code></pre><p>Return a callable <code>IterationInterval</code> that &quot;actuates&quot; (i.e., schedules output or callback execution) whenever the model iteration (modified by <code>offset</code>) is a multiple of <code>interval</code>.</p><p>For example,</p><ul><li><code>IterationInterval(100)</code> actuates at iterations <code>[100, 200, 300, ...]</code>.</li><li><code>IterationInterval(100, offset=-1)</code> actuates at iterations <code>[99, 199, 299, ...]</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Utils/schedules.jl#L107-L117">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Utils.KernelParameters-Tuple{AbstractUnitRange}"><a class="docstring-binding" href="#Oceananigans.Utils.KernelParameters-Tuple{AbstractUnitRange}"><code>Oceananigans.Utils.KernelParameters</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">KernelParameters(range1, [range2, range3])</code></pre><p>Return parameters for launching a kernel of up to three dimensions, where the indices spanned by the kernel in each dimension are given by (range1, range2, range3).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">kp = KernelParameters(1:4, 0:10)

# Launch a kernel with indices that range from i=1:4, j=0:10,
# where i, j are the first and second index, respectively.
launch!(arch, grid, kp, kernel!, kernel_args...)</code></pre><p>See the documentation for <a href="#Oceananigans.Utils.launch!-Tuple"><code>launch!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Utils/kernel_launching.jl#L52-L70">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Utils.KernelParameters-Tuple{Any, Any}"><a class="docstring-binding" href="#Oceananigans.Utils.KernelParameters-Tuple{Any, Any}"><code>Oceananigans.Utils.KernelParameters</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">KernelParameters(size, offsets)</code></pre><p>Return parameters for kernel launching and execution that define (i) a tuple that defines the <code>size</code> of the kernel being launched and (ii) a tuple of <code>offsets</code> that offset loop indices. For example, <code>offsets = (0, 0, 0)</code> with <code>size = (N, N, N)</code> means all indices loop from <code>1:N</code>. If <code>offsets = (1, 1, 1)</code>, then all indices loop from <code>2:N+1</code>. And so on.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">size = (8, 6, 4)
offsets = (0, 1, 2)
kp = KernelParameters(size, offsets)

# Launch a kernel with indices that range from i=1:8, j=2:7, k=3:6,
# where i, j, k are the first, second, and third index, respectively:

launch!(arch, grid, kp, kernel!, kernel_args...)</code></pre><p>See <a href="#Oceananigans.Utils.launch!-Tuple"><code>launch!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Utils/kernel_launching.jl#L22-L46">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Utils.OrSchedule-Tuple"><a class="docstring-binding" href="#Oceananigans.Utils.OrSchedule-Tuple"><code>Oceananigans.Utils.OrSchedule</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">OrSchedule(schedules...)</code></pre><p>Return a schedule that actuates when any of the <code>child_schedule</code>s actuates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Utils/schedules.jl#L304-L308">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Utils.SpecifiedTimes-Tuple"><a class="docstring-binding" href="#Oceananigans.Utils.SpecifiedTimes-Tuple"><code>Oceananigans.Utils.SpecifiedTimes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SpecifiedTimes(times)</code></pre><p>Return a <code>schedule::SpecifiedTimes</code> that &quot;actuates&quot; (i.e., schedules output or callback execution) whenever the model&#39;s clock equals the specified values in <code>times</code>. For example,</p><ul><li><code>SpecifiedTimes([1, 15.3])</code> actuates when <code>model.clock.time</code> is <code>1</code> and <code>15.3</code>.</li></ul><div class="admonition is-info" id="Sorting-specified-times-17b0e7943c42688e"><header class="admonition-header">Sorting specified times<a class="admonition-anchor" href="#Sorting-specified-times-17b0e7943c42688e" title="Permalink"></a></header><div class="admonition-body"><p>The specified <code>times</code> need not be ordered as the <code>SpecifiedTimes</code> constructor will check and order them in ascending order if needed.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Utils/schedules.jl#L170-L181">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Utils.TimeInterval-Tuple{Any}"><a class="docstring-binding" href="#Oceananigans.Utils.TimeInterval-Tuple{Any}"><code>Oceananigans.Utils.TimeInterval</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">TimeInterval(interval)</code></pre><p>Return a callable <code>TimeInterval</code> that schedules periodic output or diagnostic evaluation on a <code>interval</code> of simulation time, as kept by <code>model.clock</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Utils/schedules.jl#L38-L43">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Utils.WallTimeInterval-Tuple{Any}"><a class="docstring-binding" href="#Oceananigans.Utils.WallTimeInterval-Tuple{Any}"><code>Oceananigans.Utils.WallTimeInterval</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">WallTimeInterval(interval; start_time = time_ns() * 1e-9)</code></pre><p>Return a callable <code>WallTimeInterval</code> that schedules periodic output or diagnostic evaluation on a <code>interval</code> of &quot;wall time&quot; while a simulation runs, in units of seconds.</p><p>The &quot;wall time&quot; is the actual real world time in seconds, as kept by an actual or hypothetical clock hanging on your wall.</p><p>The keyword argument <code>start_time</code> can be used to specify a starting wall time other than the moment <code>WallTimeInterval</code> is constructed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Utils/schedules.jl#L132-L143">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Utils.configure_kernel-NTuple{4, Any}"><a class="docstring-binding" href="#Oceananigans.Utils.configure_kernel-NTuple{4, Any}"><code>Oceananigans.Utils.configure_kernel</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">configure_kernel(arch, grid, workspec, kernel!;
                 active_cells_map = nothing,
                 exclude_periphery = false;
                 reduced_dimensions = (),
                 location = nothing)</code></pre><p>Configure <code>kernel!</code> to launch over the <code>dims</code> of <code>grid</code> on the architecture <code>arch</code>.</p><p><strong>Arguments</strong></p><ul><li><code>arch</code>: The architecture on which the kernel will be launched.</li><li><code>grid</code>: The grid on which the kernel will be executed.</li><li><code>workspec</code>: The workspec that defines the work distribution.</li><li><code>kernel!</code>: The kernel function to be executed.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>reduced_dimensions</code>: A tuple specifying the dimensions to be reduced in the work distribution. Default is an empty tuple.</li><li><code>location</code>: The location of the kernel execution, needed for <code>include_right_boundaries</code>. Default is <code>nothing</code>.</li><li><code>active_cells_map</code>: A map indicating the active cells in the grid. If the map is not a nothing, the workspec will be disregarded and                     the kernel is configured as a linear kernel with a worksize equal to the length of the active cell map. Default is <code>nothing</code>.</li><li><code>exclude_periphery</code>: A boolean indicating whether to exclude the periphery, used only for interior kernels.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Utils/kernel_launching.jl#L233-L259">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Utils.launch!-Tuple"><a class="docstring-binding" href="#Oceananigans.Utils.launch!-Tuple"><code>Oceananigans.Utils.launch!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">launch!(arch, grid, workspec, kernel!, kernel_args...; kw...)</code></pre><p>Launches <code>kernel!</code> with arguments <code>kernel_args</code> over the <code>dims</code> of <code>grid</code> on the architecture <code>arch</code>. Kernels run on the default stream.</p><p>See <a href="#Oceananigans.Utils.configure_kernel-NTuple{4, Any}">configure_kernel</a> for more information and also a list of the keyword arguments <code>kw</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Utils/kernel_launching.jl#L326-L335">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Utils.newton_div-Union{Tuple{FT}, Tuple{Any, Any, FT}} where FT"><a class="docstring-binding" href="#Oceananigans.Utils.newton_div-Union{Tuple{FT}, Tuple{Any, Any, FT}} where FT"><code>Oceananigans.Utils.newton_div</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">newton_div(inv_FT, a, b::FT)</code></pre><p>Compute an approximation of <code>a / b</code> that uses <code>inv_FT</code> type to compute <code>1/b</code>, and then performs a single Newton iteration to add a few more bits of precision afterwards.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Utils/newton_div.jl#L1-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Utils.pretty_filesize"><a class="docstring-binding" href="#Oceananigans.Utils.pretty_filesize"><code>Oceananigans.Utils.pretty_filesize</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pretty_filesize(s, suffix=&quot;B&quot;)</code></pre><p>Convert a floating point value <code>s</code> representing a file size to a more human-friendly formatted string with one decimal places with a <code>suffix</code> defaulting to &quot;B&quot;. Depending on the value of <code>s</code> the string will be formatted to show <code>s</code> using an SI prefix from bytes, kiB (1024 bytes), MiB (1024² bytes), and so on up to YiB (1024⁸ bytes).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Utils/pretty_filesize.jl#L3-L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Utils.prettytime"><a class="docstring-binding" href="#Oceananigans.Utils.prettytime"><code>Oceananigans.Utils.prettytime</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">prettytime(t, longform=true)</code></pre><p>Convert a floating point value <code>t</code> representing an amount of time in SI units of seconds to a human-friendly string with three decimal places. Depending on the value of <code>t</code> the string will be formatted to show <code>t</code> in nanoseconds (ns), microseconds (μs), milliseconds (ms), seconds, minutes, hours, or days.</p><p>With <code>longform=false</code>, we use s, m, hrs, and d in place of seconds, minutes, and hours.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Utils/prettytime.jl#L8-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Utils.with_tracers-Tuple{Any, NamedTuple, Any}"><a class="docstring-binding" href="#Oceananigans.Utils.with_tracers-Tuple{Any, NamedTuple, Any}"><code>Oceananigans.Utils.with_tracers</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">with_tracers(tracer_names, initial_tuple, tracer_default)</code></pre><p>Create a tuple corresponding to the solution variables <code>u</code>, <code>v</code>, <code>w</code>, and <code>tracer_names</code>. <code>initial_tuple</code> is a <code>NamedTuple</code> that at least has fields <code>u</code>, <code>v</code>, and <code>w</code>, and may have some fields corresponding to the names in <code>tracer_names</code>. <code>tracer_default</code> is a function that produces a default tuple value for each tracer if not included in <code>initial_tuple</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Utils/with_tracers.jl#L1-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Utils.@apply_regionally-Tuple{Any}"><a class="docstring-binding" href="#Oceananigans.Utils.@apply_regionally-Tuple{Any}"><code>Oceananigans.Utils.@apply_regionally</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@apply_regionally expr</code></pre><p>Distributes locally the function calls in <code>expr</code>ession</p><p>When the function call in <code>expr</code> does not return anything, then <code>apply_regionally!</code> method is used. When the function in <code>expr</code> returns something, the <code>construct_regionally</code> method is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Utils/multi_region_transformation.jl#L128-L135">source</a></section></details></article><h2 id="Units"><a class="docs-heading-anchor" href="#Units">Units</a><a id="Units-1"></a><a class="docs-heading-anchor-permalink" href="#Units" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Oceananigans.Units.GiB"><a class="docstring-binding" href="#Oceananigans.Units.GiB"><code>Oceananigans.Units.GiB</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">GiB</code></pre><p>A <code>Float64</code> constant equal to 1024<code>MiB</code>. Useful for increasing the clarity of scripts, e.g. <code>max_filesize = 50GiB</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Units.jl#L109-L113">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Units.KiB"><a class="docstring-binding" href="#Oceananigans.Units.KiB"><code>Oceananigans.Units.KiB</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">KiB</code></pre><p>A <code>Float64</code> constant equal to 1024.0. Useful for increasing the clarity of scripts, e.g. <code>max_filesize = 250KiB</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Units.jl#L95-L99">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Units.MiB"><a class="docstring-binding" href="#Oceananigans.Units.MiB"><code>Oceananigans.Units.MiB</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">MiB</code></pre><p>A <code>Float64</code> constant equal to 1024<code>KiB</code>. Useful for increasing the clarity of scripts, e.g. <code>max_filesize = 100MiB</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Units.jl#L102-L106">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Units.TiB"><a class="docstring-binding" href="#Oceananigans.Units.TiB"><code>Oceananigans.Units.TiB</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">TiB</code></pre><p>A <code>Float64</code> constant equal to 1024<code>GiB</code>. Useful for increasing the clarity of scripts, e.g. <code>max_filesize = 2TiB</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Units.jl#L116-L120">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Units.day"><a class="docstring-binding" href="#Oceananigans.Units.day"><code>Oceananigans.Units.day</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">day</code></pre><p>A <code>Float64</code> constant equal to 24<code>hours</code>. Useful for increasing the clarity of scripts, e.g. <code>stop_time = 1day</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Units.jl#L53-L57">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Units.days"><a class="docstring-binding" href="#Oceananigans.Units.days"><code>Oceananigans.Units.days</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">days</code></pre><p>A <code>Float64</code> constant equal to 24<code>hours</code>. Useful for increasing the clarity of scripts, e.g. <code>stop_time = 7days</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Units.jl#L60-L64">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Units.hour"><a class="docstring-binding" href="#Oceananigans.Units.hour"><code>Oceananigans.Units.hour</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">hour</code></pre><p>A <code>Float64</code> constant equal to 60<code>minutes</code>. Useful for increasing the clarity of scripts, e.g. <code>Δt = 1hour</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Units.jl#L39-L43">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Units.hours"><a class="docstring-binding" href="#Oceananigans.Units.hours"><code>Oceananigans.Units.hours</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">hours</code></pre><p>A <code>Float64</code> constant equal to 60<code>minutes</code>. Useful for increasing the clarity of scripts, e.g. <code>Δt = 3hours</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Units.jl#L46-L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Units.kilometer"><a class="docstring-binding" href="#Oceananigans.Units.kilometer"><code>Oceananigans.Units.kilometer</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">kilometer</code></pre><p>A <code>Float64</code> constant equal to 1000<code>meters</code>. Useful for increasing the clarity of scripts, e.g. <code>Lx = 1kilometer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Units.jl#L81-L85">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Units.kilometers"><a class="docstring-binding" href="#Oceananigans.Units.kilometers"><code>Oceananigans.Units.kilometers</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">kilometers</code></pre><p>A <code>Float64</code> constant equal to 1000<code>meters</code>. Useful for increasing the clarity of scripts, e.g. <code>Lx = 5000kilometers</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Units.jl#L88-L92">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Units.meter"><a class="docstring-binding" href="#Oceananigans.Units.meter"><code>Oceananigans.Units.meter</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">meter</code></pre><p>A <code>Float64</code> constant equal to 1.0. Useful for increasing the clarity of scripts, e.g. <code>Lx = 1meter</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Units.jl#L67-L71">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Units.meters"><a class="docstring-binding" href="#Oceananigans.Units.meters"><code>Oceananigans.Units.meters</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">meters</code></pre><p>A <code>Float64</code> constant equal to 1.0. Useful for increasing the clarity of scripts, e.g. <code>Lx = 50meters</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Units.jl#L74-L78">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Units.minute"><a class="docstring-binding" href="#Oceananigans.Units.minute"><code>Oceananigans.Units.minute</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">minute</code></pre><p>A <code>Float64</code> constant equal to 60<code>seconds</code>. Useful for increasing the clarity of scripts, e.g. <code>Δt = 1minute</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Units.jl#L25-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Units.minutes"><a class="docstring-binding" href="#Oceananigans.Units.minutes"><code>Oceananigans.Units.minutes</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">minutes</code></pre><p>A <code>Float64</code> constant equal to 60<code>seconds</code>. Useful for increasing the clarity of scripts, e.g. <code>Δt = 15minutes</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Units.jl#L32-L36">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Units.second"><a class="docstring-binding" href="#Oceananigans.Units.second"><code>Oceananigans.Units.second</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">second</code></pre><p>A <code>Float64</code> constant equal to 1.0. Useful for increasing the clarity of scripts, e.g. <code>Δt = 1second</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Units.jl#L11-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Units.seconds"><a class="docstring-binding" href="#Oceananigans.Units.seconds"><code>Oceananigans.Units.seconds</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">seconds</code></pre><p>A <code>Float64</code> constant equal to 1.0. Useful for increasing the clarity of scripts, e.g. <code>Δt = 7seconds</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Units.jl#L18-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Oceananigans.Units.Time"><a class="docstring-binding" href="#Oceananigans.Units.Time"><code>Oceananigans.Units.Time</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Time(t)</code></pre><p>Return a time &quot;selector&quot; at the continuous time <code>t</code> for linearly interpolating <code>FieldTimeSeries</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Interpolate `field_time_series` to `t=0.1`, returning `interpolated::Field`
interpolated = field_time_series[Time(0.1)]

# Interpolate `field_time_series` at `i, j, k` and `t=0.1`
interpolated_ijk = field_time_series[i, j, k, Time(0.1)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/5d9670fc8dbea4733095e3877d72b645c9494d57/src/Units.jl#L123-L138">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../benchmarks/">« Performance benchmarks</a><a class="docs-footer-nextpage" href="../function_index/">Function index »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 24 December 2025 18:19">Wednesday 24 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

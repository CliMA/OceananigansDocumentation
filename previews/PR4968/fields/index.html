<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Fields · Oceananigans.jl</title><meta name="title" content="Fields · Oceananigans.jl"/><meta property="og:title" content="Fields · Oceananigans.jl"/><meta property="twitter:title" content="Fields · Oceananigans.jl"/><meta name="description" content="Documentation for Oceananigans.jl."/><meta property="og:description" content="Documentation for Oceananigans.jl."/><meta property="twitter:description" content="Documentation for Oceananigans.jl."/><meta property="og:url" content="https://clima.github.io/OceananigansDocumentation/stable/fields/"/><meta property="twitter:url" content="https://clima.github.io/OceananigansDocumentation/stable/fields/"/><link rel="canonical" href="https://clima.github.io/OceananigansDocumentation/stable/fields/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Oceananigans.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../quick_start/">Quick start</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../literated/one_dimensional_diffusion/">One-dimensional diffusion</a></li><li><a class="tocitem" href="../literated/two_dimensional_turbulence/">Two-dimensional turbulence</a></li><li><a class="tocitem" href="../literated/internal_wave/">Internal wave</a></li><li><a class="tocitem" href="../literated/internal_tide/">Internal tide by a seamount</a></li><li><a class="tocitem" href="../literated/convecting_plankton/">Convecting plankton</a></li><li><a class="tocitem" href="../literated/ocean_wind_mixing_and_convection/">Ocean wind mixing and convection</a></li><li><a class="tocitem" href="../literated/langmuir_turbulence/">Langmuir turbulence</a></li><li><a class="tocitem" href="../literated/baroclinic_adjustment/">Baroclinic adjustment</a></li><li><a class="tocitem" href="../literated/kelvin_helmholtz_instability/">Kelvin-Helmholtz instability</a></li><li><a class="tocitem" href="../literated/lock_exchange/">Lock exchange</a></li><li><a class="tocitem" href="../literated/shallow_water_Bickley_jet/">Shallow water Bickley jet</a></li><li><a class="tocitem" href="../literated/horizontal_convection/">Horizontal convection</a></li><li><a class="tocitem" href="../literated/tilted_bottom_boundary_layer/">Tilted bottom boundary layer</a></li></ul></li><li><a class="tocitem" href="../grids/">Grids</a></li><li class="is-active"><a class="tocitem" href>Fields</a><ul class="internal"><li><a class="tocitem" href="#Staggered-grids-and-field-locations"><span>Staggered grids and field locations</span></a></li><li><a class="tocitem" href="#Setting-Fields"><span>Setting <code>Field</code>s</span></a></li><li><a class="tocitem" href="#Halo-regions-and-boundary-conditions"><span>Halo regions and boundary conditions</span></a></li></ul></li><li><a class="tocitem" href="../operations/">Operations</a></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Models</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../models/models_overview/">Overview</a></li><li><a class="tocitem" href="../models/coriolis/">Coriolis forces</a></li><li><a class="tocitem" href="../models/buoyancy_and_equation_of_state/">Buoyancy and equations of state</a></li><li><a class="tocitem" href="../models/turbulence_closures/">Turbulence closures</a></li><li><a class="tocitem" href="../models/boundary_conditions/">Boundary conditions</a></li><li><a class="tocitem" href="../models/forcing_functions/">Forcings</a></li><li><a class="tocitem" href="../models/lagrangian_particles/">Lagrangian particles</a></li><li><a class="tocitem" href="../models/background_fields/">Background fields</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Simulations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../simulations/simulations_overview/">Overview</a></li><li><a class="tocitem" href="../simulations/schedules/">Schedules</a></li><li><a class="tocitem" href="../simulations/output_writers/">Output writers</a></li><li><a class="tocitem" href="../simulations/checkpointing/">Checkpointing</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Physics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../physics/coordinate_systems/">Coordinate systems</a></li><li><a class="tocitem" href="../physics/boussinesq/">Boussinesq approximation</a></li><li><input class="collapse-toggle" id="menuitem-9-3" type="checkbox"/><label class="tocitem" for="menuitem-9-3"><span class="docs-label"><code>NonhydrostaticModel</code></span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../physics/nonhydrostatic_model/">Nonhydrostatic model</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-4" type="checkbox"/><label class="tocitem" for="menuitem-9-4"><span class="docs-label"><code>HydrostaticFreeSurfaceModel</code></span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../physics/hydrostatic_free_surface_model/">Hydrostatic model with a free surface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-5" type="checkbox"/><label class="tocitem" for="menuitem-9-5"><span class="docs-label"><code>ShallowWaterModel</code></span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../physics/shallow_water_model/">Shallow water model</a></li></ul></li><li><a class="tocitem" href="../physics/boundary_conditions/">Boundary conditions</a></li><li><a class="tocitem" href="../physics/buoyancy_and_equations_of_state/">Buoyancy models and equations of state</a></li><li><a class="tocitem" href="../physics/coriolis_forces/">Coriolis forces</a></li><li><a class="tocitem" href="../physics/turbulence_closures/">Turbulence closures</a></li><li><a class="tocitem" href="../physics/surface_gravity_waves/">Surface gravity waves and the Craik-Leibovich approximation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Numerical implementation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../numerical_implementation/finite_volume/">Finite volume method</a></li><li><a class="tocitem" href="../numerical_implementation/spatial_operators/">Spatial operators</a></li><li><a class="tocitem" href="../numerical_implementation/generalized_vertical_coordinates/">Generalized vertical coordinates</a></li><li><a class="tocitem" href="../numerical_implementation/pressure_decomposition/">Pressure decomposition</a></li><li><a class="tocitem" href="../numerical_implementation/time_stepping/">Time stepping</a></li><li><a class="tocitem" href="../numerical_implementation/boundary_conditions/">Boundary conditions</a></li><li><a class="tocitem" href="../numerical_implementation/elliptic_solvers/">Elliptic solvers</a></li><li><a class="tocitem" href="../numerical_implementation/large_eddy_simulation/">Large eddy simulation</a></li></ul></li><li><a class="tocitem" href="../simulation_tips/">Simulation tips</a></li><li><a class="tocitem" href="../contributing/">Contributor&#39;s guide</a></li><li><a class="tocitem" href="../gallery/">Gallery</a></li><li><a class="tocitem" href="../references/">References</a></li><li><input class="collapse-toggle" id="menuitem-15" type="checkbox"/><label class="tocitem" for="menuitem-15"><span class="docs-label">Appendix</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../appendix/staggered_grid/">Staggered grid</a></li><li><a class="tocitem" href="../appendix/fractional_step/">Fractional step method</a></li><li><a class="tocitem" href="../appendix/convergence_tests/">Convergence tests</a></li><li><a class="tocitem" href="../appendix/benchmarks/">Performance benchmarks</a></li><li><a class="tocitem" href="../appendix/library/">Library</a></li><li><a class="tocitem" href="../appendix/function_index/">Function index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Fields</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Fields</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/CliMA/Oceananigans.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/CliMA/Oceananigans.jl/blob/main/docs/src/fields.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Fields-basics"><a class="docs-heading-anchor" href="#Fields-basics">Fields basics</a><a id="Fields-basics-1"></a><a class="docs-heading-anchor-permalink" href="#Fields-basics" title="Permalink"></a></h1><p><code>Field</code>s and its relatives are core Oceananigans data structures. <code>Field</code>s are arrays of <code>data</code> located on a <code>grid</code>, whose entries correspond to the average value of some quantity over some finite-sized volume. <code>Field</code>s also may contain <code>boundary_conditions</code>, may be computed from an <code>operand</code> or expression involving other fields, and may cover only a portion of the total <code>indices</code> spanned by the grid.</p><h2 id="Staggered-grids-and-field-locations"><a class="docs-heading-anchor" href="#Staggered-grids-and-field-locations">Staggered grids and field locations</a><a id="Staggered-grids-and-field-locations-1"></a><a class="docs-heading-anchor-permalink" href="#Staggered-grids-and-field-locations" title="Permalink"></a></h2><p>Oceananigans ocean-flavored fluids simulations rely fundamentally on &quot;staggered grid&quot; numerical methods.</p><p>Recall that <a href="../grids/#grids_tutorial">grids</a> represent a physical domain divided into finite volumes. For example, let&#39;s consider a horizontally-periodic, vertically-bounded grid of cells that divide up a cube with dimensions <span>$1 \times 1 \times 1$</span>:</p><pre><code class="language-julia hljs">using Oceananigans

grid = RectilinearGrid(topology = (Periodic, Periodic, Bounded),
                       size = (4, 5, 4),
                       halo = (1, 1, 1),
                       x = (0, 1),
                       y = (0, 1),
                       z = [0, 0.1, 0.3, 0.6, 1])

# output
4×5×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo
├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25
├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.2
└── Bounded  z ∈ [0.0, 1.0] variably spaced with min(Δz)=0.1, max(Δz)=0.4</code></pre><p>The cubic domain is divided into a &quot;primary mesh&quot; of <span>$4 \times 5 \times 4 = 80$</span> cells, which are evenly spaced in <span>$x, y$</span> but variably spaced in <span>$z$</span>. Now, in addition to the primary mesh, the grid defines also a set of &quot;staggered&quot; grids whose cells are shifted by half a cell width relative to the primary mesh. In other words, the staggered grid cells have a &quot;location&quot; in each direction – either <code>Center</code>, and therefore co-located with the primary mesh, or <code>Face</code> and located over the interfaces of the primary mesh. For example, the primary or <code>Center</code> cell spacings in <span>$z$</span> are</p><pre><code class="language-julia hljs">zspacings(grid, Center())[:, :, 1:4]

# output
4-element Vector{Float64}:
 0.1
 0.19999999999999998
 0.3
 0.4</code></pre><p>corresponding to cell interfaces located at <code>z = [0, 0.1, 0.3, 0.6, 1]</code>. But then for the grid which is staggered in <code>z</code> relative to the primary mesh,</p><pre><code class="language-julia hljs">zspacings(grid, Face())[:, :, 1:5]

# output
5-element Vector{Float64}:
 0.1
 0.15000000000000002
 0.24999999999999994
 0.3500000000000001
 0.3999999999999999</code></pre><p>The cells for the vertically staggered grid have different spacings than the primary mesh. That&#39;s because the <em>edges</em> of the vertically-staggered mesh coincide with the <em>nodes</em> (the cell centers) of the primary mesh. The nodes of the primary mesh are</p><pre><code class="language-julia hljs">znodes(grid, Center(), with_halos=true)

# output
6-element view(OffsetArray(::Vector{Float64}, 0:5), :) with eltype Float64 with indices 0:5:
 -0.05
  0.05
  0.2
  0.44999999999999996
  0.8
  1.2</code></pre><p>The center of the leftmost &quot;halo cell&quot; is <code>z = -0.05</code>, while the center of the first cell from the left is <code>z = 0.05</code>. This means that the width of the first cell on the vertically-staggered grid is <code>0.05 - (-0.05) = 0.1</code> – and so on. Finally, note that the nodes of the staggered mesh coincide with the cell interfaces of the primary mesh, so:</p><pre><code class="language-julia hljs">znodes(grid, Center())

# output
4-element view(::Vector{Float64}, 2:5) with eltype Float64:
 0.05
 0.2
 0.44999999999999996
 0.8</code></pre><p>In a three-dimensional domain, there are <span>$2³ = 8$</span> meshes – 1 primary mesh, and 7 meshes that are staggered to varying degrees from the primary mesh. This system of staggered grids is commonly used in fluid dynamics and was <a href="https://en.wikipedia.org/wiki/Arakawa_grids">invented specifically for simulations of the atmosphere and ocean</a>.</p><h3 id="Constructing-Fields-at-specified-locations"><a class="docs-heading-anchor" href="#Constructing-Fields-at-specified-locations">Constructing Fields at specified locations</a><a id="Constructing-Fields-at-specified-locations-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-Fields-at-specified-locations" title="Permalink"></a></h3><p>Every <code>Field</code> is associated with either the primary mesh or one of the staggered meshes by a three-dimensional &quot;location&quot; associated with each field. To build a fully-centered <code>Field</code>, for example, we write</p><pre><code class="language-julia hljs">c = Field{Center, Center, Center}(grid)

# output
4×5×4 Field{Center, Center, Center} on RectilinearGrid on CPU
├── grid: 4×5×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo
├── boundary conditions: FieldBoundaryConditions
│   └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: Nothing
└── data: 6×7×6 OffsetArray(::Array{Float64, 3}, 0:5, 0:6, 0:5) with eltype Float64 with indices 0:5×0:6×0:5
    └── max=0.0, min=0.0, mean=0.0</code></pre><p>Fully-centered fields also go by the alias <code>CenterField</code>,</p><pre><code class="language-julia hljs">c == CenterField(grid)

# output
true</code></pre><p>Many fluid dynamical variables are located at cell centers – for example, tracers like temperature and salinity. Another common type of <code>Field</code> we encounter have cells located over the <code>x</code>-interfaces of the primary grid,</p><pre><code class="language-julia hljs">u = Field{Face, Center, Center}(grid)

# output
4×5×4 Field{Face, Center, Center} on RectilinearGrid on CPU
├── grid: 4×5×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo
├── boundary conditions: FieldBoundaryConditions
│   └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: Nothing
└── data: 6×7×6 OffsetArray(::Array{Float64, 3}, 0:5, 0:6, 0:5) with eltype Float64 with indices 0:5×0:6×0:5
    └── max=0.0, min=0.0, mean=0.0</code></pre><p>which also goes by the alias <code>u = XFaceField(grid)</code>. The name <code>u</code> is suggestive: in the Arakawa type-C grid (&#39;C-grid&#39; for short) used by Oceananigans, the <code>x</code>-component of the velocity field is stored at <code>Face, Center, Center</code> location.</p><p>The centers of the <code>u</code> cells are shifted to the left relative to the <code>c</code> cells:</p><pre><code class="language-julia hljs">@show collect(xnodes(c))
@show collect(xnodes(u))
nothing

# output
collect(xnodes(c)) = [0.125, 0.375, 0.625, 0.875]
collect(xnodes(u)) = [0.0, 0.25, 0.5, 0.75]</code></pre><p>Notice that the first <code>u</code>-node is at <code>x=0</code>, the left end of the grid, but the last <code>u</code>-node is at <code>x=0.75</code>. Because the <code>x</code>-direction is <code>Periodic</code>, the <code>XFaceField</code> <code>u</code> has 4 cells in <code>x</code> – the cell just right of <code>x=0.75</code> is the same as the cell at <code>x=0</code>.</p><p>Because the vertical direction is <code>Bounded</code>, however, vertically-staggered fields have more vertical cells than <code>CenterField</code>s:</p><pre><code class="language-julia hljs">w = Field{Center, Center, Face}(grid)

@show collect(znodes(c))
@show collect(znodes(w))
nothing

# output
collect(znodes(c)) = [0.05, 0.2, 0.44999999999999996, 0.8]
collect(znodes(w)) = [0.0, 0.1, 0.3, 0.6, 1.0]</code></pre><p><code>Field</code>s at <code>Center, Center, Face</code> are also called <code>ZFaceField</code>, and the vertical velocity is a <code>ZFaceField</code> on the C-grid. Let&#39;s visualize the situation:</p><pre><code class="language-julia hljs">using CairoMakie

fig = Figure(size=(600, 180))
ax = Axis(fig[1, 1], xlabel=&quot;x&quot;)

# Visualize the domain
lines!(ax, [0, 1], [0, 0], color=:gray)

xc = xnodes(c)
xu = xnodes(u)

scatter!(ax, xc, 0 * xc, marker=:circle, markersize=10, label=&quot;Cell centers&quot;)
scatter!(ax, xu, 0 * xu, marker=:vline, markersize=20, label=&quot;Cell interfaces&quot;)

ylims!(ax, -1, 1)
xlims!(ax, -0.1, 1.1)
hideydecorations!(ax)
hidexdecorations!(ax, ticklabels=false, label=false)
hidespines!(ax)

Legend(fig[0, 1], ax, nbanks=2, framevisible=false)

current_figure()</code></pre><img src="55216348.png" alt="Example block output"/><h2 id="Setting-Fields"><a class="docs-heading-anchor" href="#Setting-Fields">Setting <code>Field</code>s</a><a id="Setting-Fields-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-Fields" title="Permalink"></a></h2><p><code>Field</code>s are full of 0&#39;s when they are created, which is not very exciting. The situation can be improved using <a href="@ref"><code>set!</code></a> to change the values of a field. For example,</p><pre><code class="language-julia hljs">set!(c, 42)

# output
4×5×4 Field{Center, Center, Center} on RectilinearGrid on CPU
├── grid: 4×5×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo
├── boundary conditions: FieldBoundaryConditions
│   └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: Nothing
└── data: 6×7×6 OffsetArray(::Array{Float64, 3}, 0:5, 0:6, 0:5) with eltype Float64 with indices 0:5×0:6×0:5
    └── max=42.0, min=42.0, mean=42.0</code></pre><p>Now <code>c</code> is filled with <code>42</code>s (for this simple case, we could also have used <code>c .= 42</code>). Let&#39;s confirm that:</p><pre><code class="language-julia hljs">c[1, 1, 1]

# output
42.0</code></pre><p>Looks good. And</p><pre><code class="language-julia hljs">c[1:4, 1:5, 1]

# output
4×5 Matrix{Float64}:
 42.0  42.0  42.0  42.0  42.0
 42.0  42.0  42.0  42.0  42.0
 42.0  42.0  42.0  42.0  42.0
 42.0  42.0  42.0  42.0  42.0</code></pre><p>Note that indexing into <code>c</code> is the same as indexing into <code>c.data</code>.</p><pre><code class="language-julia hljs">c[:, :, :] == c.data

# output
true</code></pre><p>We can also <code>set!</code> with arrays,</p><pre><code class="language-julia hljs">random_stuff = rand(size(c)...)
set!(c, random_stuff)

heatmap(view(c, :, :, 1))</code></pre><img src="63a5c28e.png" alt="Example block output"/><p>or even use functions to set,</p><pre><code class="language-julia hljs">fun_stuff(x, y, z) = 2x
set!(c, fun_stuff)

# output
4×5×4 Field{Center, Center, Center} on RectilinearGrid on CPU
├── grid: 4×5×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo
├── boundary conditions: FieldBoundaryConditions
│   └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: Nothing
└── data: 6×7×6 OffsetArray(::Array{Float64, 3}, 0:5, 0:6, 0:5) with eltype Float64 with indices 0:5×0:6×0:5
    └── max=1.75, min=0.25, mean=1.0</code></pre><p>and plot it</p><pre><code class="language-julia hljs">heatmap(view(c, :, :, 1))</code></pre><img src="27a74097.png" alt="Example block output"/><p>For <code>Field</code>s on three-dimensional grids, <code>set!</code> functions must have arguments <code>x, y, z</code> for <code>RectilinearGrid</code>, or <code>λ, φ, z</code> for <code>LatitudeLongitudeGrid</code> and <code>OrthogonalSphericalShellGrid</code>. But for <code>Field</code>s on one- and two-dimensional grids, only the arguments that correspond to the non-<code>Flat</code> directions must be included. For example, to <code>set!</code> on a one-dimensional grid we write</p><pre><code class="language-julia hljs"># Make a field on a one-dimensional grid
one_d_grid = RectilinearGrid(size=7, x=(0, 7), topology=(Periodic, Flat, Flat))
one_d_c = CenterField(one_d_grid)

# The one-dimensional grid varies only in `x`
still_pretty_fun(x) = 3x
set!(one_d_c, still_pretty_fun)

# output
7×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU
├── grid: 7×1×1 RectilinearGrid{Float64, Periodic, Flat, Flat} on CPU with 3×0×0 halo
├── boundary conditions: FieldBoundaryConditions
│   └── west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: Nothing
└── data: 13×1×1 OffsetArray(::Array{Float64, 3}, -2:10, 1:1, 1:1) with eltype Float64 with indices -2:10×1:1×1:1
    └── max=19.5, min=1.5, mean=10.5</code></pre><div class="admonition is-info" id="Note-7c5d0789defc3263"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-7c5d0789defc3263" title="Permalink"></a></header><div class="admonition-body"><p><code>Field</code> data is always stored in three-dimensional arrays –- even when they have <code>Nothing</code> locations, or on grids with <code>Flat</code> directions. As a result, <code>Field</code>s are indexed with three indices <code>i, j, k</code>, with <code>Flat</code> directions indexed with <code>1</code>.</p></div></div><h3 id="A-bit-more-about-setting-with-functions"><a class="docs-heading-anchor" href="#A-bit-more-about-setting-with-functions">A bit more about setting with functions</a><a id="A-bit-more-about-setting-with-functions-1"></a><a class="docs-heading-anchor-permalink" href="#A-bit-more-about-setting-with-functions" title="Permalink"></a></h3><p>Let&#39;s return to the three-dimensional <code>fun_stuff</code> case to investigate in more detail how <code>set!</code> works with functions. The <code>xnodes</code> of <code>c</code> – the coordinates of the center of <code>c</code>&#39;s finite volumes – are:</p><pre><code class="language-julia hljs">xc = xnodes(c)
@show collect(xc)
nothing # hide

# output
collect(xc) = [0.125, 0.375, 0.625, 0.875]</code></pre><p>To <code>set!</code> the values of <code>c</code> we evaluate <code>fun_stuff</code> at <code>c</code>&#39;s nodes, producing</p><pre><code class="language-julia hljs">c[1:4, 1, 1]

# output
4-element Vector{Float64}:
 0.25
 0.75
 1.25
 1.75</code></pre><div class="admonition is-info" id="Note-3f97c86185393f60"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-3f97c86185393f60" title="Permalink"></a></header><div class="admonition-body"><p>This function-setting method is a first-order method for computing the finite volume of <code>c</code> to <code>fun_stuff</code>. Higher-order algorithms could be implemented – have a crack if you&#39;re keen.</p></div></div><p>As a result <code>set!</code> can evaluate differently on <code>Field</code>s at different locations:</p><pre><code class="language-julia hljs">u = XFaceField(grid)
set!(u, fun_stuff)
u[1:4, 1, 1]

# output
4-element Vector{Float64}:
 0.0
 0.5
 1.0
 1.5</code></pre><h2 id="Halo-regions-and-boundary-conditions"><a class="docs-heading-anchor" href="#Halo-regions-and-boundary-conditions">Halo regions and boundary conditions</a><a id="Halo-regions-and-boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Halo-regions-and-boundary-conditions" title="Permalink"></a></h2><p>We built <code>grid</code> with <code>halo = (1, 1, 1)</code>, which means that the &quot;interior&quot; cells of the grid are surrounded by a &quot;halo region&quot; of cells that&#39;s one cell thick. The number of halo cells in each direction are stored in the properties <code>Hx, Hy, Hz</code>, so,</p><pre><code class="language-julia hljs">(grid.Hx, grid.Hy, grid.Hz)

# output
(1, 1, 1)</code></pre><p><code>set!</code> doesn&#39;t touch halo cells. Check out one of the two-dimensional slices of <code>c</code> showing both the interior and the halo regions:</p><pre><code class="language-julia hljs">c[:, :, 1]

# output
6×7 OffsetArray(::Matrix{Float64}, 0:5, 0:6) with eltype Float64 with indices 0:5×0:6:
 0.0  0.0   0.0   0.0   0.0   0.0   0.0
 0.0  0.25  0.25  0.25  0.25  0.25  0.0
 0.0  0.75  0.75  0.75  0.75  0.75  0.0
 0.0  1.25  1.25  1.25  1.25  1.25  0.0
 0.0  1.75  1.75  1.75  1.75  1.75  0.0
 0.0  0.0   0.0   0.0   0.0   0.0   0.0</code></pre><p>The interior region is populated, but the surrounding halo regions are all 0. To remedy this situation we need to <code>fill_halo_regions!</code>:</p><pre><code class="language-julia hljs">using Oceananigans.BoundaryConditions: fill_halo_regions!

fill_halo_regions!(c)

c[:, :, 1]

# output
6×7 OffsetArray(::Matrix{Float64}, 0:5, 0:6) with eltype Float64 with indices 0:5×0:6:
 1.75  1.75  1.75  1.75  1.75  1.75  1.75
 0.25  0.25  0.25  0.25  0.25  0.25  0.25
 0.75  0.75  0.75  0.75  0.75  0.75  0.75
 1.25  1.25  1.25  1.25  1.25  1.25  1.25
 1.75  1.75  1.75  1.75  1.75  1.75  1.75
 0.25  0.25  0.25  0.25  0.25  0.25  0.25</code></pre><p>The way the halo regions are filled depends on <code>c.boundary_conditions</code>:</p><pre><code class="language-julia hljs">c.boundary_conditions

# output
Oceananigans.FieldBoundaryConditions, with boundary conditions
├── west: PeriodicBoundaryCondition
├── east: PeriodicBoundaryCondition
├── south: PeriodicBoundaryCondition
├── north: PeriodicBoundaryCondition
├── bottom: FluxBoundaryCondition: Nothing
├── top: FluxBoundaryCondition: Nothing
└── immersed: Nothing</code></pre><p>Specifically for <code>c</code> above, <code>x</code> and <code>y</code> are <code>Periodic</code> while <code>z</code> has been assigned the default &quot;no-flux&quot; boundary conditions for a <code>Field</code> with <code>Center</code> location in a <code>Bounded</code> direction. For no-flux boundary conditions, the halo regions of <code>c</code> are filled so that derivatives evaluated on the boundary return 0. To view only the interior cells of <code>c</code> we use the function <code>interior</code>,</p><pre><code class="language-julia hljs">interior(c, :, :, 1)

# output
4×5 view(::Array{Float64, 3}, 2:5, 2:6, 2) with eltype Float64:
 0.25  0.25  0.25  0.25  0.25
 0.75  0.75  0.75  0.75  0.75
 1.25  1.25  1.25  1.25  1.25
 1.75  1.75  1.75  1.75  1.75</code></pre><p>Note that the indices of <code>c</code> (and the indices of <code>c.data</code>) are &quot;offset&quot; so that index <code>1</code> corresponds to the first interior cell. As a result,</p><pre><code class="language-julia hljs">c[1:4, 1:5, 1] == interior(c, :, :, 1)

# output
true</code></pre><p>and more generally</p><pre><code class="language-julia hljs">typeof(c.data)

# output
OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}</code></pre><p>Thus, for example, the <code>x</code>-indices of <code>c.data</code> vary from <code>1 - Hx</code> to <code>Nx + Hx</code> – in this case, from <code>0</code> to <code>5</code>. The underlying array can be accessed with <code>parent(c)</code>. But note that the &quot;parent&quot; array does not have offset indices, so</p><pre><code class="language-julia hljs">@show parent(c)[1:2, 2, 2]
@show c.data[1:2, 1, 1]
nothing

# output
(parent(c))[1:2, 2, 2] = [1.75, 0.25]
c.data[1:2, 1, 1] = [0.25, 0.75]</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../grids/">« Grids</a><a class="docs-footer-nextpage" href="../operations/">Operations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 26 December 2025 23:33">Friday 26 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

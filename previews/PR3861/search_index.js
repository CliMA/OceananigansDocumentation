var documenterSearchIndex = {"docs":
[{"location":"appendix/convergence_tests/#Convergence-Tests","page":"Convergence tests","title":"Convergence Tests","text":"","category":"section"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"Convergence tests are implemented in /validation/convergence_tests and range from zero-dimensional time-stepper tests to two-dimensional integration tests that involve non-trivial pressure fields, advection, and diffusion.","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"For all tests except point exponential decay, we use the L_1 norm,","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    L_1 equiv fracmathrmmean  phi_mathrmsim - phi_mathrmexact mathrmmean  phi_mathrmexact ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"and L_infty norm,","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    L_infty equiv fracmax  phi_mathrmsim - phi_mathrmexact max  phi_mathrmexact   ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"to compare simulated fields, phi_mathrmsim, with exact, analytically-derived solutions phi_mathrmexact. The field phi may be a tracer field or a velocity field.","category":"page"},{"location":"appendix/convergence_tests/#Point-Exponential-Decay","page":"Convergence tests","title":"Point Exponential Decay","text":"","category":"section"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"This test analyzes time-stepper convergence by simulating the zero-dimensional, or spatially-uniform equation","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    partial_t c = - c  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"with the initial condition c = 1, which has the analytical solution c = mathrme^-t.","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"We find the expected first-order convergence with decreasing time-step Delta t using our first-order accurate, \"modified second-order\" Adams-Bashforth time-stepping method:","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"(Image: Point exponential decay)","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"This result validates the correctness of the Oceananigans implementation of Adams-Bashforth time-stepping.","category":"page"},{"location":"appendix/convergence_tests/#One-dimensional-advection-and-diffusion-of-a-Gaussian","page":"Convergence tests","title":"One-dimensional advection and diffusion of a Gaussian","text":"","category":"section"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"This and the following tests focus on convergence with grid spacing, Delta x.","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"In one dimension with constant diffusivity kappa and in the presence of a constant velocity U, a Gaussian evolves according to","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    c = fracmathrme^- (x - U t)^2  4 kappa tsqrt4 pi kappa t  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"For this test we take the initial time as t=t_0. We simulate this problem with advection and diffusion, as well as with U=0 and thus diffusion only, as well as with kappa approx 0 and thus \"advection only\". The solutions are","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"(Image: Gaussian advection diffusion solutions)","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"which exhibit the expected second-order convergence with Delta x^2 propto 1  N_x^2:","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"(Image: Gaussian advection diffusion convergence)","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"These results validate the correctness of time-stepping, constant diffusivity operators, and advection operators.","category":"page"},{"location":"appendix/convergence_tests/#One-dimensional-advection-and-diffusion-of-a-cosine","page":"Convergence tests","title":"One-dimensional advection and diffusion of a cosine","text":"","category":"section"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"In one dimension with constant diffusivity kappa and in the presence of a constant velocity U, a cosine evolves according to","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    c = mathrme^-kappa t cos (x - U t)  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"The solutions are","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"(Image: Cosine advection diffusion solutions)","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"which exhibit the expected second-order convergence with Delta x^2 propto 1  N_x^2:","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"(Image: Cosine advection diffusion convergence)","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"These results validate the correctness of time-stepping, constant diffusivity operators, and advection operators.","category":"page"},{"location":"appendix/convergence_tests/#Two-dimensional-diffusion","page":"Convergence tests","title":"Two-dimensional diffusion","text":"","category":"section"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"With zero velocity field and constant diffusivity kappa, the tracer field","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    c(x y t=0) = cos(x) cos(y)  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"decays according to","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    c(x y t) = mathrme^-2 kappa t cos(x) cos(y)  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"with either periodic boundary conditions, or insulating boundary conditions in either x or y.","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"The expected convergence with Delta x^2 propto 1  N_x^2 is observed:","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"(Image: Two dimensional diffusion convergence)","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"This validates the correctness of multi-dimensional diffusion operators.","category":"page"},{"location":"appendix/convergence_tests/#Decaying,-advected-Taylor-Green-vortex","page":"Convergence tests","title":"Decaying, advected Taylor-Green vortex","text":"","category":"section"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"The velocity field","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"beginalign\n    u(x y t)  = U + mathrme^-t cos(x - U t) sin(y)   \n    v(x y t)  =   - mathrme^-t sin(x - U t) cos(y)  \nendalign","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"is a solution to the Navier-Stokes equations with viscosity nu = 1.","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"The expected convergence with spatial resolution is observed:","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"(Image: Decaying advected Taylor Green)","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"This validates the correctness of the advection and diffusion of a velocity field.","category":"page"},{"location":"appendix/convergence_tests/#Forced-two-dimensional-flows","page":"Convergence tests","title":"Forced two-dimensional flows","text":"","category":"section"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"We introduce two convergence tests associated with forced flows in domains that are  bounded in y, and periodic in x with no tracers.","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"Note: in this section, subscripts are used to denote derivatives to make reading  and typing equations easier.","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"In a two-dimensional flow in (x y), the velocity field (u v) can be expressed in terms of a streamfunction psi(x y t) such that","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    u equiv - psi_y   quad textand quad v equiv psi_x  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"where subscript denote derivatives such that psi_y equiv partial_y psi, for example. With an isotropic Laplacian viscosity nu = 1, the momentum and continuity equations are","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    beginalign\n    boldsymbolv_t + left ( boldsymbolv boldsymbolcdot boldsymbolnabla right ) boldsymbolv + boldsymbolnabla p  = nabla^2 boldsymbolv + boldsymbolF_v   \n    boldsymbolnabla boldsymbolcdot boldsymbolv  = 0  \n    endalign","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"while the equation for vorticity, omega = v_x - u_y = nabla^2 psi, is","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    omega_t + mathrmJ left ( psi omega right ) = nabla^2 omega + F_omega  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"Finally, taking the divergence of the momentum equation, we find a Poisson equation for pressure,","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    nabla^2 p = - u_x^2 - v_y^2 - 2 u_y v_x + partial_x F_v + partial_y F_v  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"To pose the problem, we first pick a streamfunction psi. This choice then yields the vorticity  forcing F_omega that satisfies the vorticity equation. We then determine F_u by solving  partial_y F_v = - F_omega, and pick F_v so that we can solve the Poisson equation  for pressure.","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"We restrict ourselves to a class of problems in which","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"psi(x y t) = - f(x t) g(y)   quad textwith quad f equiv cos x - xi(t)   quad\nxi(t) equiv 1 + sin(t^2)  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"Grinding through the algebra, this particular form implies that F_omega is given by","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    F_omega = -xi^prime f_x (g - g^primeprime) + f f_x (g g^primeprimeprime - g^prime g^primeprime) + f (g - 2 g^primeprime + g^primeprimeprimeprime)  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"where primes denote derivatives of functions of a single argument.  Setting partial_y F_v = F_omega, we find that if F_v satisfies","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    partial_y F_v = (g^prime)^2 + g g^primeprime  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"then the pressure Poisson equation becomes","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    nabla^2 p = cos 2 (x - xi) (g^prime)^2 - g g^primeprime + partial_x F_v  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"This completes the specification of the problem.","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"We set up the problem by imposing the time-dependent forcing functions F_u and F_v on u and v, initializing the flow at t=0, and integrating the problem forwards in time using Oceananigans. We find the expected convergence of the numerical solution to the analytical solution: the error between the numerical and analytical solutions decreases with 1N_x^2 sim Delta x^2, where N_x is the number of grid points and Delta x is the spatial resolution:","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"(Image: Forced free slip convergence)","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"The convergence tests are performed using both y and z as the bounded direction.","category":"page"},{"location":"appendix/convergence_tests/#Forced,-free-slip-flow","page":"Convergence tests","title":"Forced, free-slip flow","text":"","category":"section"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"A forced flow satisfying free-slip conditions at y = 0 and y = pi has the streamfunction","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    psi(x y t) = - cos x - xi(t) sin (y)  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"and thus g(y) = sin y. The velocity field (u v) is","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    u = cos (x - xi) cos y   quad textand quad v = sin (x - xi) sin y  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"which satisfies the boundary conditions u_y _y=0 = u_y _y=pi = 0 and v _y=0 = v _y=pi = 0. The vorticity forcing is","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    F_omega = - 2 xi^prime f_x sin y + 4 f sin y  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"which implies that","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    F_v = - 2 xi^prime f_x cos y + 4 f cos y  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"and F_v = tfrac12 sin 2 y.","category":"page"},{"location":"appendix/convergence_tests/#Forced,-fixed-slip-flow","page":"Convergence tests","title":"Forced, fixed-slip flow","text":"","category":"section"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"A forced flow satisfying \"fixed-slip\" boundary conditions at y=0 and y=1 has the streamfunction","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    psi(x y t) = - cos x - xi(t) (y^3 - y^2)  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"and thus g(y) = y^3 - y^2. The velocity field (u v) is","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    u = f (3y^2 - 2 y)   quad textand quad v = - f_x (y^3 - y^2)  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"which satisfies the boundary conditions","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    u _y=0 = 0   quad u _y=1 = f   quad textand quad v _y=0 = v _y=1 = 0  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"The vorticity forcing is","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    F_omega = - xi^prime f_x (y^3 - y^2 - 6y + 2) - f f_x (12 y^3 - 12 y^2 + 4 y) + f (y^3 - y^2 - 12 y + 4)  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"which implies that","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    F_v = xi^prime f_x (tfrac14 y^4 - tfrac13 y^3 - 3 y^2 + 2y)\n        + f f_x (3 y^4 - 4 y^3 + 2y^2 ) \n        - f (tfrac14 y^4 - tfrac13 y^3 - 6 y^2 + 4 y)  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"and","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"    F_v = 3 y^5 - 5 y^4 + 2y^3  ","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"We set up the problem in the same manner as the forced, free-slip problem above. Note that we  also must the no-slip boundary condition u _y=0 = 0 and the time-dependent fixed-slip  condition u _y=1 = f. As for the free-slip problem, we find that the error between the  numerical and analytical solutions decreases with 1  N_x^2 sim Delta x^2, where N_x is the number of grid points and Delta x is the spatial resolution:","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"(Image: Forced fixed slip convergence)","category":"page"},{"location":"appendix/convergence_tests/","page":"Convergence tests","title":"Convergence tests","text":"The convergence tests are performed using both y and z as the bounded direction.","category":"page"},{"location":"appendix/library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Documenting the public user interface.","category":"page"},{"location":"appendix/library/#Oceananigans.jl","page":"Library","title":"Oceananigans.jl","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.Oceananigans","page":"Library","title":"Oceananigans.Oceananigans","text":"Main module for Oceananigans.jl – a Julia software for fast, friendly, flexible, data-driven, ocean-flavored fluid dynamics on CPUs and GPUs.\n\n\n\n\n\n","category":"module"},{"location":"appendix/library/#Abstract-operations","page":"Library","title":"Abstract operations","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.AbstractOperations]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.AbstractOperations.volume","page":"Library","title":"Oceananigans.AbstractOperations.volume","text":"volume = VolumeMetric()\n\nInstance of VolumeMetric that generates BinaryOperations between AbstractFields and their cell volumes. Summing this BinaryOperation yields an integral of AbstractField over the domain.\n\nExample\n\njulia> using Oceananigans\n\njulia> using Oceananigans.AbstractOperations: volume\n\njulia> c = CenterField(RectilinearGrid(size=(2, 2, 2), extent=(1, 2, 3)));\n\njulia> c .= 1;\n\njulia> c_dV = c * volume\nBinaryOperation at (Center, Center, Center)\n├── grid: 2×2×2 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 2×2×2 halo\n└── tree:\n    * at (Center, Center, Center)\n    ├── 2×2×2 Field{Center, Center, Center} on RectilinearGrid on CPU\n    └── Vᶜᶜᶜ at (Center, Center, Center)\n\njulia> c_dV[1, 1, 1]\n0.75\n\njulia> sum(c_dV)\n6.0\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.AbstractOperations.Δz","page":"Library","title":"Oceananigans.AbstractOperations.Δz","text":"Δz = ZSpacingMetric()\n\nInstance of ZSpacingMetric that generates BinaryOperations between AbstractFields and the vertical grid spacing evaluated at the same location as the AbstractField. \n\nΔx and Δy play a similar role for horizontal grid spacings.\n\nExample\n\njulia> using Oceananigans\n\njulia> using Oceananigans.AbstractOperations: Δz\n\njulia> c = CenterField(RectilinearGrid(size=(1, 1, 1), extent=(1, 2, 3)));\n\njulia> c_dz = c * Δz # returns BinaryOperation between Field and GridMetricOperation\nBinaryOperation at (Center, Center, Center)\n├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo\n└── tree:\n    * at (Center, Center, Center)\n    ├── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU\n    └── Δzᶜᶜᶜ at (Center, Center, Center)\n\njulia> c .= 1;\n\njulia> c_dz[1, 1, 1]\n3.0\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.AbstractOperations.Average-Tuple{Oceananigans.Fields.AbstractField}","page":"Library","title":"Oceananigans.AbstractOperations.Average","text":"Average(field::AbstractField; dims=:, condition=nothing, mask=0)\n\nReturn Reduction representing a spatial average of field over dims.\n\nOver regularly-spaced dimensions this is equivalent to a numerical mean!.\n\nOver dimensions of variable spacing, field is multiplied by the appropriate grid length, area or volume, and divided by the total spatial extent of the interval.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.BinaryOperation-Union{Tuple{G}, Tuple{IB}, Tuple{IA}, Tuple{B}, Tuple{A}, Tuple{O}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{O, A, B, IA, IB, G}} where {LX, LY, LZ, O, A, B, IA, IB, G}","page":"Library","title":"Oceananigans.AbstractOperations.BinaryOperation","text":"BinaryOperation{LX, LY, LZ}(op, a, b, ▶a, ▶b, grid)\n\nReturn an abstract representation of the binary operation op(▶a(a), ▶b(b)) on grid, where ▶a and ▶b interpolate a and b to locations (LX, LY, LZ).\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.ConditionalOperation-Tuple{Oceananigans.Fields.AbstractField}","page":"Library","title":"Oceananigans.AbstractOperations.ConditionalOperation","text":"ConditionalOperation(operand::AbstractField;\n                     func = identity,\n                     condition = nothing,\n                     mask = 0)\n\nReturn an abstract representation of a masking procedure applied when condition is satisfied on a field described by func(operand).\n\nPositional arguments\n\noperand: The AbstractField to be masked (it must have a grid property!)\n\nKeyword arguments\n\nfunc: A unary transformation applied element-wise to the field operand at locations where         condition == true. Default is identity.\ncondition: either a function of (i, j, k, grid, operand) returning a Boolean,              or a 3-dimensional Boolean AbstractArray. At locations where condition == false,              operand will be masked by mask\nmask: the scalar mask\n\ncondition_operand is a convenience function used to construct a ConditionalOperation\n\ncondition_operand(func::Function, operand::AbstractField, condition, mask) = ConditionalOperation(operand; func, condition, mask)\n\nExample\n\njulia> using Oceananigans\n\njulia> using Oceananigans.Fields: condition_operand\n\njulia> c = CenterField(RectilinearGrid(size=(2, 1, 1), extent=(1, 1, 1)));\n\njulia> add_2(c) = c + 2\nadd_2 (generic function with 1 method)\n\njulia> f(i, j, k, grid, c) = i < 2; d = condition_operand(add_2, c, f, 10.0)\nConditionalOperation at (Center, Center, Center)\n├── operand: 2×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU\n├── grid: 2×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 2×1×1 halo\n├── func: add_2 (generic function with 1 method)\n├── condition: f (generic function with 1 method)\n└── mask: 10.0\n\njulia> d[1, 1, 1]\n2.0\n\njulia> d[2, 1, 1]\n10.0\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.CumulativeIntegral-Tuple{Oceananigans.Fields.AbstractField}","page":"Library","title":"Oceananigans.AbstractOperations.CumulativeIntegral","text":"CumulativeIntegral(field::AbstractField; dims, reverse=false, condition=nothing, mask=0)\n\nReturn an Accumulation representing the cumulative spatial integral of field over dims.\n\nExample\n\nCompute the cumulative integral of f(z) = z over z ∈ [0, 1].\n\njulia> using Oceananigans\n\njulia> grid = RectilinearGrid(size=8, z=(0, 1), topology=(Flat, Flat, Bounded));\n\njulia> c = CenterField(grid);\n\njulia> set!(c, z -> z)\n1×1×8 Field{Center, Center, Center} on RectilinearGrid on CPU\n├── grid: 1×1×8 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo\n├── boundary conditions: FieldBoundaryConditions\n│   └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux\n└── data: 1×1×14 OffsetArray(::Array{Float64, 3}, 1:1, 1:1, -2:11) with eltype Float64 with indices 1:1×1:1×-2:11\n    └── max=0.9375, min=0.0625, mean=0.5\n\njulia> C_op = CumulativeIntegral(c, dims=3)\nCumulativeIntegral of BinaryOperation at (Center, Center, Center) over dims 3\n└── operand: BinaryOperation at (Center, Center, Center)\n    └── grid: 1×1×8 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo\n\njulia> C = compute!(Field(C_op))\n1×1×8 Field{Center, Center, Center} on RectilinearGrid on CPU\n├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 1, 8)\n├── grid: 1×1×8 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo\n├── operand: CumulativeIntegral of BinaryOperation at (Center, Center, Center) over dims 3\n├── status: time=0.0\n└── data: 1×1×14 OffsetArray(::Array{Float64, 3}, 1:1, 1:1, -2:11) with eltype Float64 with indices 1:1×1:1×-2:11\n    └── max=0.5, min=0.0078125, mean=0.199219\n\njulia> C[1, 1, 8]\n0.5\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.Derivative-Union{Tuple{G}, Tuple{AD}, Tuple{IN}, Tuple{A}, Tuple{D}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{D, A, IN, AD, G}} where {LX, LY, LZ, D, A, IN, AD, G}","page":"Library","title":"Oceananigans.AbstractOperations.Derivative","text":"Derivative{LX, LY, LZ}(∂, arg, ▶, grid)\n\nReturn an abstract representation of the derivative ∂ on arg, and subsequent interpolation by ▶ on grid.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.Integral-Tuple{Oceananigans.Fields.AbstractField}","page":"Library","title":"Oceananigans.AbstractOperations.Integral","text":"Integral(field::AbstractField; dims=:, condition=nothing, mask=0)\n\nReturn a Reduction representing a spatial integral of field over dims.\n\nExample\n\nCompute the integral of f(x y z) = x y z over the domain (x y z)  0 1  0 1  0 1. The analytical answer is  x y z  dx  dy  dz = 18.\n\njulia> using Oceananigans\n\njulia> grid = RectilinearGrid(size=(8, 8, 8), x=(0, 1), y=(0, 1), z=(0, 1));\n\njulia> f = CenterField(grid);\n\njulia> set!(f, (x, y, z) -> x * y * z)\n8×8×8 Field{Center, Center, Center} on RectilinearGrid on CPU\n├── grid: 8×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo\n├── boundary conditions: FieldBoundaryConditions\n│   └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux\n└── data: 14×14×14 OffsetArray(::Array{Float64, 3}, -2:11, -2:11, -2:11) with eltype Float64 with indices -2:11×-2:11×-2:11\n    └── max=0.823975, min=0.000244141, mean=0.125\n\njulia> ∫f = Integral(f)\nIntegral of BinaryOperation at (Center, Center, Center) over dims (1, 2, 3)\n└── operand: BinaryOperation at (Center, Center, Center)\n    └── grid: 8×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo\n\njulia> ∫f = Field(Integral(f));\n\njulia> compute!(∫f);\n\njulia> ∫f[1, 1, 1]\n0.125\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.KernelFunctionOperation-Union{Tuple{G}, Tuple{K}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{K, G, Vararg{Any}}} where {LX, LY, LZ, K, G}","page":"Library","title":"Oceananigans.AbstractOperations.KernelFunctionOperation","text":"KernelFunctionOperation{LX, LY, LZ}(kernel_function, grid, arguments...)\n\nConstruct a KernelFunctionOperation at location (LX, LY, LZ) on grid with arguments.\n\nkernel_function is called with\n\nkernel_function(i, j, k, grid, arguments...)\n\nNote that compute!(kfo::KernelFunctionOperation) calls compute! on all kfo.arguments.\n\nExamples\n\nConstruct a KernelFunctionOperation that returns random numbers:\n\nusing Oceananigans\n\ngrid = RectilinearGrid(size=(1, 8, 8), extent=(1, 1, 1));\n\nrandom_kernel_function(i, j, k, grid) = rand(); # use CUDA.rand on the GPU\n\nkernel_op = KernelFunctionOperation{Center, Center, Center}(random_kernel_function, grid)\n\n# output\n\nKernelFunctionOperation at (Center, Center, Center)\n├── grid: 1×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×3×3 halo\n├── kernel_function: random_kernel_function (generic function with 1 method)\n└── arguments: ()\n\nConstruct a KernelFunctionOperation using the vertical vorticity operator used internally to compute vertical vorticity on all grids:\n\nusing Oceananigans.Operators: ζ₃ᶠᶠᶜ # called with signature ζ₃ᶠᶠᶜ(i, j, k, grid, u, v)\n\nmodel = HydrostaticFreeSurfaceModel(; grid);\n\nu, v, w = model.velocities;\n\nζ_op = KernelFunctionOperation{Face, Face, Center}(ζ₃ᶠᶠᶜ, grid, u, v)\n\n# output\n\nKernelFunctionOperation at (Face, Face, Center)\n├── grid: 1×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×3×3 halo\n├── kernel_function: ζ₃ᶠᶠᶜ (generic function with 1 method)\n└── arguments: (\"1×8×8 Field{Face, Center, Center} on RectilinearGrid on CPU\", \"1×8×8 Field{Center, Face, Center} on RectilinearGrid on CPU\")\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.UnaryOperation-Union{Tuple{G}, Tuple{IN}, Tuple{A}, Tuple{O}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{O, A, IN, G}} where {LX, LY, LZ, O, A, IN, G}","page":"Library","title":"Oceananigans.AbstractOperations.UnaryOperation","text":"UnaryOperation{LX, LY, LZ}(op, arg, ▶, grid)\n\nReturns an abstract UnaryOperation representing the action of op on arg, and subsequent interpolation by ▶ on grid.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.∂x-Tuple{Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}}","page":"Library","title":"Oceananigans.AbstractOperations.∂x","text":"Return the x-derivative function acting at (X, Y, Any).\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.∂x-Union{Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Tuple, Oceananigans.Fields.AbstractField{LX, LY, LZ}}} where {LX, LY, LZ}","page":"Library","title":"Oceananigans.AbstractOperations.∂x","text":"∂x(L::Tuple, arg::AbstractField)\n\nReturn an abstract representation of an x-derivative acting on field arg followed by interpolation to L, where L is a 3-tuple of Faces and Centers.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.∂x-Union{Tuple{Oceananigans.Fields.AbstractField{LX, LY, LZ}}, Tuple{LZ}, Tuple{LY}, Tuple{LX}} where {LX, LY, LZ}","page":"Library","title":"Oceananigans.AbstractOperations.∂x","text":"∂x(arg::AbstractField)\n\nReturn an abstract representation of a x-derivative acting on field arg.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.∂y-Tuple{Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}}","page":"Library","title":"Oceananigans.AbstractOperations.∂y","text":"Return the y-derivative function acting at (X, Y, Any).\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.∂y-Union{Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Tuple, Oceananigans.Fields.AbstractField{LX, LY, LZ}}} where {LX, LY, LZ}","page":"Library","title":"Oceananigans.AbstractOperations.∂y","text":"∂y(L::Tuple, arg::AbstractField)\n\nReturn an abstract representation of a y-derivative acting on field arg followed by interpolation to L, where L is a 3-tuple of Faces and Centers.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.∂y-Union{Tuple{Oceananigans.Fields.AbstractField{LX, LY, LZ}}, Tuple{LZ}, Tuple{LY}, Tuple{LX}} where {LX, LY, LZ}","page":"Library","title":"Oceananigans.AbstractOperations.∂y","text":"∂y(arg::AbstractField)\n\nReturn an abstract representation of a y-derivative acting on field arg.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.∂z-Tuple{Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}}","page":"Library","title":"Oceananigans.AbstractOperations.∂z","text":"Return the z-derivative function acting at (Any, Any, Z).\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.∂z-Union{Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Tuple, Oceananigans.Fields.AbstractField{LX, LY, LZ}}} where {LX, LY, LZ}","page":"Library","title":"Oceananigans.AbstractOperations.∂z","text":"∂z(L::Tuple, arg::AbstractField)\n\nReturn an abstract representation of a z-derivative acting on field arg followed by  interpolation to L, where L is a 3-tuple of Faces and Centers.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.∂z-Union{Tuple{Oceananigans.Fields.AbstractField{LX, LY, LZ}}, Tuple{LZ}, Tuple{LY}, Tuple{LX}} where {LX, LY, LZ}","page":"Library","title":"Oceananigans.AbstractOperations.∂z","text":"∂z(arg::AbstractField)\n\nReturn an abstract representation of a z-derivative acting on field arg.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.AbstractOperations.@at-Tuple{Any, Any}","page":"Library","title":"Oceananigans.AbstractOperations.@at","text":"@at location abstract_operation\n\nModify the abstract_operation so that it returns values at location, where location is a 3-tuple of Faces and Centers.\n\n\n\n\n\n","category":"macro"},{"location":"appendix/library/#Oceananigans.AbstractOperations.@binary-Tuple","page":"Library","title":"Oceananigans.AbstractOperations.@binary","text":"@binary op1 op2 op3...\n\nTurn each binary function in the list (op1, op2, op3...) into a binary operator on Oceananigans.Fields for use in AbstractOperations.\n\nNote: a binary function is a function with two arguments: for example, +(x, y) is a binary function.\n\nAlso note: a binary function in Base must be imported to be extended: use import Base: op; @binary op.\n\nExample\n\njulia> using Oceananigans, Oceananigans.AbstractOperations\n\njulia> using Oceananigans.AbstractOperations: BinaryOperation, AbstractGridMetric, choose_location\n\njulia> plus_or_times(x, y) = x < 0 ? x + y : x * y\nplus_or_times (generic function with 1 method)\n\njulia> @binary plus_or_times\nSet{Any} with 6 elements:\n  :+\n  :/\n  :^\n  :-\n  :*\n  :plus_or_times\n\njulia> c, d = (CenterField(RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))) for i = 1:2);\n\njulia> plus_or_times(c, d)\nBinaryOperation at (Center, Center, Center)\n├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo\n└── tree:\n    plus_or_times at (Center, Center, Center)\n    ├── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU\n    └── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU\n\n\n\n\n\n","category":"macro"},{"location":"appendix/library/#Oceananigans.AbstractOperations.@multiary-Tuple","page":"Library","title":"Oceananigans.AbstractOperations.@multiary","text":"@multiary op1 op2 op3...\n\nTurn each multiary operator in the list (op1, op2, op3...) into a multiary operator on Oceananigans.Fields for use in AbstractOperations.\n\nNote that a multiary operator:\n\nis a function with two or more arguments: for example, +(x, y, z) is a multiary function;\nmust be imported to be extended if part of Base: use import Base: op; @multiary op;\ncan only be called on Oceananigans.Fields if the \"location\" is noted explicitly; see example.\n\nExample\n\njulia> using Oceananigans, Oceananigans.AbstractOperations\n\njulia> harmonic_plus(a, b, c) = 1/3 * (1/a + 1/b + 1/c)\nharmonic_plus (generic function with 1 method)\n\njulia> c, d, e = Tuple(CenterField(RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))) for i = 1:3);\n\njulia> harmonic_plus(c, d, e) # before magic @multiary transformation\nBinaryOperation at (Center, Center, Center)\n├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo\n└── tree:\n    * at (Center, Center, Center)\n    ├── 0.3333333333333333\n    └── + at (Center, Center, Center)\n        ├── / at (Center, Center, Center)\n        │   ├── 1\n        │   └── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU\n        ├── / at (Center, Center, Center)\n        │   ├── 1\n        │   └── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU\n        └── / at (Center, Center, Center)\n            ├── 1\n            └── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU\n\njulia> @multiary harmonic_plus\nSet{Any} with 3 elements:\n  :+\n  :harmonic_plus\n  :*\n\njulia> harmonic_plus(c, d, e)\nMultiaryOperation at (Center, Center, Center)\n├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo\n└── tree:\n    harmonic_plus at (Center, Center, Center)\n    ├── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU\n    ├── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU\n    └── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU\n\n\n\n\n\n","category":"macro"},{"location":"appendix/library/#Oceananigans.AbstractOperations.@unary-Tuple","page":"Library","title":"Oceananigans.AbstractOperations.@unary","text":"@unary op1 op2 op3...\n\nTurn each unary function in the list (op1, op2, op3...) into a unary operator on Oceananigans.Fields for use in AbstractOperations.\n\nNote: a unary function is a function with one argument: for example, sin(x) is a unary function.\n\nAlso note: a unary function in Base must be imported to be extended: use import Base: op; @unary op.\n\nExample\n\njulia> using Oceananigans, Oceananigans.Grids, Oceananigans.AbstractOperations\n\njulia> square_it(x) = x^2\nsquare_it (generic function with 1 method)\n\njulia> @unary square_it\nSet{Any} with 10 elements:\n  :+\n  :sqrt\n  :square_it\n  :cos\n  :exp\n  :interpolate_identity\n  :-\n  :tanh\n  :sin\n  :abs\n\njulia> c = CenterField(RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)));\n\njulia> square_it(c)\nUnaryOperation at (Center, Center, Center)\n├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo\n└── tree:\n    square_it at (Center, Center, Center) via identity\n    └── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU\n\n\n\n\n\n","category":"macro"},{"location":"appendix/library/#Advection","page":"Library","title":"Advection","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Advection]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.Advection.Centered","page":"Library","title":"Oceananigans.Advection.Centered","text":"struct Centered{N, FT, XT, YT, ZT, CA} <: AbstractCenteredAdvectionScheme{N, FT}\n\nCentered reconstruction scheme.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Advection.FluxFormAdvection-Tuple{Any, Any, Any}","page":"Library","title":"Oceananigans.Advection.FluxFormAdvection","text":"function FluxFormAdvection(x, y, z)\n\nBuilds a FluxFormAdvection type with reconstructions schemes x, y, and z to be applied in the x, y, and z direction, respectively.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Advection.UpwindBiased","page":"Library","title":"Oceananigans.Advection.UpwindBiased","text":"struct UpwindBiasedFifthOrder <: AbstractUpwindBiasedAdvectionScheme{3}\n\nUpwind-biased fifth-order advection scheme.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Advection.VectorInvariant-Tuple{}","page":"Library","title":"Oceananigans.Advection.VectorInvariant","text":"VectorInvariant(; vorticity_scheme = EnstrophyConserving(),\n                  vorticity_stencil = VelocityStencil(),\n                  vertical_scheme = EnergyConserving(),\n                  kinetic_energy_gradient_scheme = vertical_scheme,\n                  divergence_scheme = vertical_scheme,\n                  upwinding = OnlySelfUpwinding(; cross_scheme = vertical_scheme),\n                  multi_dimensional_stencil = false)\n\nReturn a vector invariant momentum advection scheme.\n\nKeyword arguments\n\nvorticity_scheme: Scheme used for Center reconstruction of vorticity. Default: EnstrophyConserving(). Options:\nUpwindBiased()\nWENO()\nEnergyConserving()\nEnstrophyConserving()\nvorticity_stencil: Stencil used for smoothness indicators for WENO schemes. Default: VelocityStencil(). Options:\nVelocityStencil() (smoothness based on horizontal velocities)\nDefaultStencil() (smoothness based on variable being reconstructed)\nvertical_scheme: Scheme used for vertical advection of horizontal momentum. Default: EnergyConserving().\nkinetic_energy_gradient_scheme: Scheme used for kinetic energy gradient reconstruction. Default: vertical_scheme.\ndivergence_scheme: Scheme used for divergence flux. Only upwinding schemes are supported. Default: vorticity_scheme.\nupwinding: Treatment of upwinded reconstruction of divergence and kinetic energy gradient. Default: OnlySelfUpwinding(). Options:\nCrossAndSelfUpwinding()\nOnlySelfUpwinding()\nVelocityUpwinding()\nupwinding  \nmulti_dimensional_stencil : whether or not to use a horizontal two-dimensional stencil for the reconstruction                               of vorticity, divergence and kinetic energy gradient. Currently the \"tangential\"                               direction uses 5th-order centered WENO reconstruction.\n\nExamples\n\njulia> using Oceananigans\n\njulia> VectorInvariant()\nVector Invariant, Dimension-by-dimension reconstruction \n Vorticity flux scheme: \n └── EnstrophyConserving{Float64} \n Vertical advection / Divergence flux scheme: \n └── EnergyConserving{Float64}\n\n\njulia> using Oceananigans\n\njulia> VectorInvariant(vorticity_scheme = WENO(), vertical_scheme = WENO(order = 3))\nVector Invariant, Dimension-by-dimension reconstruction \n Vorticity flux scheme: \n ├── WENO reconstruction order 5 \n └── smoothness ζ: Oceananigans.Advection.VelocityStencil()\n Vertical advection / Divergence flux scheme: \n ├── WENO reconstruction order 3\n └── upwinding treatment: OnlySelfUpwinding \n KE gradient and Divergence flux cross terms reconstruction: \n └── Centered reconstruction order 2\n Smoothness measures: \n ├── smoothness δU: FunctionStencil f = divergence_smoothness\n ├── smoothness δV: FunctionStencil f = divergence_smoothness\n ├── smoothness δu²: FunctionStencil f = u_smoothness\n └── smoothness δv²: FunctionStencil f = v_smoothness      \n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Advection.WENO","page":"Library","title":"Oceananigans.Advection.WENO","text":"WENO([FT=Float64;] \n     order = 5,\n     grid = nothing, \n     bounds = nothing)\n\nConstruct a weighted essentially non-oscillatory advection scheme of order order.\n\nKeyword arguments\n\norder: The order of the WENO advection scheme. Default: 5\ngrid: (defaults to nothing)\n\nExamples\n\njulia> using Oceananigans\n\njulia> WENO()\nWENO reconstruction order 5\n Boundary scheme: \n    └── WENO reconstruction order 3\n Symmetric scheme: \n    └── Centered reconstruction order 4\n Directions:\n    ├── X regular \n    ├── Y regular \n    └── Z regular\n\njulia> using Oceananigans\n\njulia> Nx, Nz = 16, 10;\n\njulia> Lx, Lz = 1e4, 1e3;\n\njulia> chebychev_spaced_z_faces(k) = - Lz/2 - Lz/2 * cos(π * (k - 1) / Nz);\n\njulia> grid = RectilinearGrid(size = (Nx, Nz), halo = (4, 4), topology=(Periodic, Flat, Bounded),\n                              x = (0, Lx), z = chebychev_spaced_z_faces);\n\njulia> WENO(grid; order=7)\nWENO reconstruction order 7\n Boundary scheme: \n    └── WENO reconstruction order 5\n Symmetric scheme: \n    └── Centered reconstruction order 6\n Directions:\n    ├── X regular \n    ├── Y regular \n    └── Z stretched\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Advection.WENOVectorInvariant","page":"Library","title":"Oceananigans.Advection.WENOVectorInvariant","text":"WENOVectorInvariant(; upwinding = nothing,\n                      multi_dimensional_stencil = false,\n                      weno_kw...)\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.Advection.div_Uc-NTuple{7, Any}","page":"Library","title":"Oceananigans.Advection.div_Uc","text":"div_uc(i, j, k, grid, advection, U, c)\n\nCalculate the divergence of the flux of a tracer quantity c being advected by a velocity field, (𝐯 c),\n\n1/V * [δxᶜᵃᵃ(Ax * u * ℑxᶠᵃᵃ(c)) + δyᵃᶜᵃ(Ay * v * ℑyᵃᶠᵃ(c)) + δzᵃᵃᶜ(Az * w * ℑzᵃᵃᶠ(c))]\n\nwhich ends up at the location ccc.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Advection.div_𝐯u-NTuple{7, Any}","page":"Library","title":"Oceananigans.Advection.div_𝐯u","text":"div_𝐯u(i, j, k, grid, advection, U, u)\n\nCalculate the advection of momentum in the x-direction using the conservative form, (𝐯 u),\n\n1/Vᵘ * [δxᶠᵃᵃ(ℑxᶜᵃᵃ(Ax * u) * ℑxᶜᵃᵃ(u)) + δy_fca(ℑxᶠᵃᵃ(Ay * v) * ℑyᵃᶠᵃ(u)) + δz_fac(ℑxᶠᵃᵃ(Az * w) * ℑzᵃᵃᶠ(u))]\n\nwhich ends up at the location fcc.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Advection.div_𝐯v-NTuple{7, Any}","page":"Library","title":"Oceananigans.Advection.div_𝐯v","text":"div_𝐯v(i, j, k, grid, advection, U, v)\n\nCalculate the advection of momentum in the y-direction using the conservative form, (𝐯 v),\n\n1/Vʸ * [δx_cfa(ℑyᵃᶠᵃ(Ax * u) * ℑxᶠᵃᵃ(v)) + δyᵃᶠᵃ(ℑyᵃᶜᵃ(Ay * v) * ℑyᵃᶜᵃ(v)) + δz_afc(ℑxᶠᵃᵃ(Az * w) * ℑzᵃᵃᶠ(w))]\n\nwhich ends up at the location cfc.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Advection.div_𝐯w-NTuple{7, Any}","page":"Library","title":"Oceananigans.Advection.div_𝐯w","text":"div_𝐯w(i, j, k, grid, advection, U, w)\n\nCalculate the advection of momentum in the z-direction using the conservative form, (𝐯 w),\n\n1/Vʷ * [δx_caf(ℑzᵃᵃᶠ(Ax * u) * ℑxᶠᵃᵃ(w)) + δy_acf(ℑzᵃᵃᶠ(Ay * v) * ℑyᵃᶠᵃ(w)) + δzᵃᵃᶠ(ℑzᵃᵃᶜ(Az * w) * ℑzᵃᵃᶜ(w))]\n\nwhich ends up at the location ccf.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Architectures","page":"Library","title":"Architectures","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Architectures]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.Architectures.AbstractArchitecture","page":"Library","title":"Oceananigans.Architectures.AbstractArchitecture","text":"AbstractArchitecture\n\nAbstract supertype for architectures supported by Oceananigans.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Architectures.AbstractSerialArchitecture","page":"Library","title":"Oceananigans.Architectures.AbstractSerialArchitecture","text":"AbstractSerialArchitecture\n\nAbstract supertype for serial architectures supported by Oceananigans.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Architectures.CPU","page":"Library","title":"Oceananigans.Architectures.CPU","text":"CPU <: AbstractArchitecture\n\nRun Oceananigans on one CPU node. Uses multiple threads if the environment variable JULIA_NUM_THREADS is set.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Architectures.GPU","page":"Library","title":"Oceananigans.Architectures.GPU","text":"GPU <: AbstractArchitecture\n\nRun Oceananigans on a single NVIDIA CUDA GPU.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Boundary-conditions","page":"Library","title":"Boundary conditions","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.BoundaryConditions]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.BoundaryConditions.BoundaryCondition","page":"Library","title":"Oceananigans.BoundaryConditions.BoundaryCondition","text":"struct BoundaryCondition{C<:AbstractBoundaryConditionClassification, T}\n\nContainer for boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.BoundaryConditions.BoundaryCondition-Tuple{Oceananigans.BoundaryConditions.AbstractBoundaryConditionClassification, Function}","page":"Library","title":"Oceananigans.BoundaryConditions.BoundaryCondition","text":"BoundaryCondition(classification::AbstractBoundaryConditionClassification, condition::Function;\n                  parameters = nothing,\n                  discrete_form = false,\n                  field_dependencies=())\n\nConstruct a boundary condition of type classification with a function boundary condition.\n\nBy default, the function boudnary condition is assumed to have the 'continuous form' condition(ξ, η, t), where t is time and ξ and η vary along the boundary. In particular:\n\nOn x-boundaries, condition(y, z, t).\nOn y-boundaries, condition(x, z, t).\nOn z-boundaries, condition(x, y, t).\n\nIf parameters is not nothing, then function boundary conditions have the form func(ξ, η, t, parameters), where ξ and η are spatial coordinates varying along the boundary as explained above.\n\nIf discrete_form = true, the function condition is assumed to have the \"discrete form\",\n\ncondition(i, j, grid, clock, model_fields)\n\nwhere i, and j are indices that vary along the boundary. If discrete_form = true and parameters is not nothing, the function condition is called with\n\ncondition(i, j, grid, clock, model_fields, parameters)\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.BoundaryConditions.FieldBoundaryConditions","page":"Library","title":"Oceananigans.BoundaryConditions.FieldBoundaryConditions","text":"FieldBoundaryConditions(; kwargs...)\n\nReturn a template for boundary conditions on prognostic fields.\n\nKeyword arguments\n\nKeyword arguments specify boundary conditions on the 7 possible boundaries:\n\nwest: left end point in the x-direction where i = 1\neast: right end point in the x-direction where i = grid.Nx\nsouth: left end point in the y-direction where j = 1\nnorth: right end point in the y-direction where j = grid.Ny\nbottom: right end point in the z-direction where k = 1\ntop: right end point in the z-direction where k = grid.Nz\nimmersed: boundary between solid and fluid for immersed boundaries\n\nIf a boundary condition is unspecified, the default for prognostic fields and the topology in the boundary-normal direction is used:\n\nPeriodicBoundaryCondition for Periodic directions\nNoFluxBoundaryCondition for Bounded directions and Centered-located fields\nImpenetrableBoundaryCondition for Bounded directions and Face-located fields\nnothing for Flat directions and/or Nothing-located fields\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.BoundaryConditions.FieldBoundaryConditions-2","page":"Library","title":"Oceananigans.BoundaryConditions.FieldBoundaryConditions","text":"FieldBoundaryConditions(grid, location, indices=(:, :, :);\n                        west     = default_auxiliary_bc(topology(grid, 1)(), location[1]()),\n                        east     = default_auxiliary_bc(topology(grid, 1)(), location[1]()),\n                        south    = default_auxiliary_bc(topology(grid, 2)(), location[2]()),\n                        north    = default_auxiliary_bc(topology(grid, 2)(), location[2]()),\n                        bottom   = default_auxiliary_bc(topology(grid, 3)(), location[3]()),\n                        top      = default_auxiliary_bc(topology(grid, 3)(), location[3]()),\n                        immersed = NoFluxBoundaryCondition())\n\nReturn boundary conditions for auxiliary fields (fields whose values are derived from a model's prognostic fields) on grid and at location.\n\nKeyword arguments\n\nKeyword arguments specify boundary conditions on the 6 possible boundaries:\n\nwest, left end point in the x-direction where i = 1\neast, right end point in the x-direction where i = grid.Nx\nsouth, left end point in the y-direction where j = 1\nnorth, right end point in the y-direction where j = grid.Ny\nbottom, right end point in the z-direction where k = 1\ntop, right end point in the z-direction where k = grid.Nz\nimmersed: boundary between solid and fluid for immersed boundaries\n\nIf a boundary condition is unspecified, the default for auxiliary fields and the topology in the boundary-normal direction is used:\n\nPeriodicBoundaryCondition for Periodic directions\nGradientBoundaryCondition(0) for Bounded directions and Centered-located fields\nnothing for Bounded directions and Face-located fields\nnothing for Flat directions and/or Nothing-located fields\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.BoundaryConditions.Flux","page":"Library","title":"Oceananigans.BoundaryConditions.Flux","text":"struct Flux <: AbstractBoundaryConditionClassification\n\nA classification specifying a boundary condition on the flux of a field.\n\nThe sign convention is such that a positive flux represents the flux of a quantity in the positive direction. For example, a positive vertical flux implies a quantity is fluxed upwards, in the +z direction.\n\nDue to this convention, a positive flux applied to the top boundary specifies that a quantity is fluxed upwards across the top boundary and thus out of the domain. As a result, a positive flux applied to a top boundary leads to a reduction of that quantity in the interior of the domain; for example, a positive, upwards flux of heat at the top of the domain acts to cool the interior of the domain. Conversely, a positive flux applied to the bottom boundary leads to an increase of the quantity in the interior of the domain. The same logic holds for east, west, north, and south boundaries.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.BoundaryConditions.Gradient","page":"Library","title":"Oceananigans.BoundaryConditions.Gradient","text":"struct Gradient <: AbstractBoundaryConditionClassification\n\nA classification specifying a boundary condition on the derivative or gradient of a field. Also called a Neumann boundary condition.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.BoundaryConditions.Open","page":"Library","title":"Oceananigans.BoundaryConditions.Open","text":"struct Open <: AbstractBoundaryConditionClassification\n\nA classification that specifies the halo regions of a field directly.\n\nFor fields located at Faces, Open also specifies field value on the boundary.\n\nOpen boundary conditions are used to specify the component of a velocity field normal to a boundary and can also be used to describe nested or linked simulation domains.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.BoundaryConditions.Value","page":"Library","title":"Oceananigans.BoundaryConditions.Value","text":"struct Value <: AbstractBoundaryConditionClassification\n\nA classification specifying a boundary condition on the value of a field. Also called a Dirchlet boundary condition.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.BoundaryConditions.apply_x_bcs!-Tuple{Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any, Oceananigans.Architectures.AbstractArchitecture, Vararg{Any}}","page":"Library","title":"Oceananigans.BoundaryConditions.apply_x_bcs!","text":"Apply flux boundary conditions to a field c by adding the associated flux divergence to the source term Gc at the left and right.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.BoundaryConditions.apply_y_bcs!-Tuple{Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any, Oceananigans.Architectures.AbstractArchitecture, Vararg{Any}}","page":"Library","title":"Oceananigans.BoundaryConditions.apply_y_bcs!","text":"Apply flux boundary conditions to a field c by adding the associated flux divergence to the source term Gc at the left and right.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.BoundaryConditions.apply_z_bcs!-Tuple{Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any, Oceananigans.Architectures.AbstractArchitecture, Vararg{Any}}","page":"Library","title":"Oceananigans.BoundaryConditions.apply_z_bcs!","text":"Apply flux boundary conditions to a field c by adding the associated flux divergence to the source term Gc at the top and bottom.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.BoundaryConditions.fill_halo_regions!-Tuple{Union{Tuple{Vararg{OffsetArrays.OffsetArray, var\"#s328\"}} where var\"#s328\", OffsetArrays.OffsetArray}, Any, Any, Any, Any, Vararg{Any}}","page":"Library","title":"Oceananigans.BoundaryConditions.fill_halo_regions!","text":"Fill halo regions in x, y, and z for a given field's data.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Buoyancy-models","page":"Library","title":"Buoyancy models","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.BuoyancyModels]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.BuoyancyModels.Buoyancy-Tuple{}","page":"Library","title":"Oceananigans.BuoyancyModels.Buoyancy","text":"Buoyancy(; model, gravity_unit_vector=NegativeZDirection())\n\nConstruct a buoyancy given a buoyancy model. Optional keyword argument gravity_unit_vector can be used to specify the direction of gravity (default NegativeZDirection()). The buoyancy acceleration acts in the direction opposite to gravity.\n\nExample\n\nusing Oceananigans\n\ngrid = RectilinearGrid(size=(1, 8, 8), extent=(1, 1, 1))\n\nθ = 45 # degrees\ng̃ = (0, -sind(θ), -cosd(θ))\n\nbuoyancy = Buoyancy(model=BuoyancyTracer(), gravity_unit_vector=g̃)\n\nmodel = NonhydrostaticModel(; grid, buoyancy, tracers=:b)\n\n# output\n\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\n├── grid: 1×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×3×3 halo\n├── timestepper: RungeKutta3TimeStepper\n├── advection scheme: Centered reconstruction order 2\n├── tracers: b\n├── closure: Nothing\n├── buoyancy: BuoyancyTracer with ĝ = (0.0, -0.707107, -0.707107)\n└── coriolis: Nothing\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.BuoyancyModels.BuoyancyTracer","page":"Library","title":"Oceananigans.BuoyancyModels.BuoyancyTracer","text":"BuoyancyTracer <: AbstractBuoyancyModel{Nothing}\n\nType indicating that the tracer b represents buoyancy.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.BuoyancyModels.LinearEquationOfState","page":"Library","title":"Oceananigans.BuoyancyModels.LinearEquationOfState","text":"LinearEquationOfState([FT=Float64;] thermal_expansion=1.67e-4, haline_contraction=7.80e-4)\n\nReturn LinearEquationOfState for SeawaterBuoyancy with thermal_expansion coefficient and haline_contraction coefficient. The buoyancy perturbation b for LinearEquationOfState is\n\n    b = g (α T - β S)\n\nwhere g is gravitational acceleration, α is thermal_expansion, β is haline_contraction, T is temperature, and S is practical salinity units.\n\nDefault constants in units inverse Kelvin and practical salinity units for thermal_expansion and haline_contraction, respectively, are taken from Table 1.2 (page 33) of Vallis, \"Atmospheric and Oceanic Fluid Dynamics: Fundamentals and Large-Scale Circulation\" (2nd ed, 2017).\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.BuoyancyModels.LinearEquationOfState-2","page":"Library","title":"Oceananigans.BuoyancyModels.LinearEquationOfState","text":"LinearEquationOfState{FT} <: AbstractEquationOfState\n\nLinear equation of state for seawater.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.BuoyancyModels.SeawaterBuoyancy","page":"Library","title":"Oceananigans.BuoyancyModels.SeawaterBuoyancy","text":"SeawaterBuoyancy([FT = Float64;]\n                 gravitational_acceleration = g_Earth,\n                 equation_of_state = LinearEquationOfState(FT),\n                 constant_temperature = nothing,\n                 constant_salinity = nothing)\n\nReturn parameters for a temperature- and salt-stratified seawater buoyancy model with a gravitational_acceleration constant (typically called g), and an equation_of_state that related temperature and salinity (or conservative temperature and absolute salinity) to density anomalies and buoyancy.\n\nSetting constant_temperature to something that is not nothing indicates that buoyancy depends only on salinity. For a nonlinear equation of state, the value provided constant_temperature is used as the temperature of the system. Vice versa, setting constant_salinity indicates that buoyancy depends only on temperature.\n\nFor a linear equation of state, the values of constant_temperature or constant_salinity are irrelevant.\n\nExamples\n\nThe \"TEOS10\" equation of state, see https://www.teos-10.org\n\njulia> using SeawaterPolynomials.TEOS10: TEOS10EquationOfState\n\njulia> teos10 = TEOS10EquationOfState()\nBoussinesqEquationOfState{Float64}:\n    ├── seawater_polynomial: TEOS10SeawaterPolynomial{Float64}\n    └── reference_density: 1020.0\n\nBuoyancy that depends on both temperature and salinity\n\njulia> using Oceananigans\n\njulia> buoyancy = SeawaterBuoyancy(equation_of_state=teos10)\nSeawaterBuoyancy{Float64}:\n├── gravitational_acceleration: 9.80665\n└── equation_of_state: BoussinesqEquationOfState{Float64}\n\nBuoyancy that depends only on salinity with temperature held at 20 degrees Celsius\n\njulia> salinity_dependent_buoyancy = SeawaterBuoyancy(equation_of_state=teos10, constant_temperature=20) \nSeawaterBuoyancy{Float64}:\n├── gravitational_acceleration: 9.80665\n├── constant_temperature: 20\n└── equation_of_state: BoussinesqEquationOfState{Float64}\n\nBuoyancy that depends only on temperature with salinity held at 35 psu\n\njulia> temperature_dependent_buoyancy = SeawaterBuoyancy(equation_of_state=teos10, constant_salinity=35)\nSeawaterBuoyancy{Float64}:\n├── gravitational_acceleration: 9.80665\n├── constant_salinity: 35\n└── equation_of_state: BoussinesqEquationOfState{Float64}\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.BuoyancyModels.SeawaterBuoyancy-2","page":"Library","title":"Oceananigans.BuoyancyModels.SeawaterBuoyancy","text":"SeawaterBuoyancy{FT, EOS, T, S} <: AbstractBuoyancyModel{EOS}\n\nBuoyancyModels model for seawater. T and S are either nothing if both temperature and salinity are active, or of type FT if temperature or salinity are constant, respectively.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.BuoyancyModels.∂x_b-Tuple{Any, Any, Any, Any, SeawaterBuoyancy, Any}","page":"Library","title":"Oceananigans.BuoyancyModels.∂x_b","text":"∂x_b(i, j, k, grid, b::SeawaterBuoyancy, C)\n\nReturns the x-derivative of buoyancy for temperature and salt-stratified water,\n\n_x b = g ( α _x T - β _x S ) \n\nwhere g is gravitational acceleration, α is the thermal expansion coefficient, β is the haline contraction coefficient, T is conservative temperature, and S is absolute salinity.\n\nNote: In Oceananigans, model.tracers.T is conservative temperature and model.tracers.S is absolute salinity.\n\nNote that _x T (∂x_T), _x S (∂x_S), α, and β are all evaluated at cell interfaces in x and cell centers in y and z.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.BuoyancyModels.∂y_b-Tuple{Any, Any, Any, Any, SeawaterBuoyancy, Any}","page":"Library","title":"Oceananigans.BuoyancyModels.∂y_b","text":"∂y_b(i, j, k, grid, b::SeawaterBuoyancy, C)\n\nReturns the y-derivative of buoyancy for temperature and salt-stratified water,\n\n_y b = g ( α _y T - β _y S ) \n\nwhere g is gravitational acceleration, α is the thermal expansion coefficient, β is the haline contraction coefficient, T is conservative temperature, and S is absolute salinity.\n\nNote: In Oceananigans, model.tracers.T is conservative temperature and model.tracers.S is absolute salinity.\n\nNote that _y T (∂y_T), _y S (∂y_S), α, and β are all evaluated at cell interfaces in y and cell centers in x and z.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.BuoyancyModels.∂z_b-Tuple{Any, Any, Any, Any, SeawaterBuoyancy, Any}","page":"Library","title":"Oceananigans.BuoyancyModels.∂z_b","text":"∂z_b(i, j, k, grid, b::SeawaterBuoyancy, C)\n\nReturns the vertical derivative of buoyancy for temperature and salt-stratified water,\n\n_z b = N^2 = g ( α _z T - β _z S ) \n\nwhere g is gravitational acceleration, α is the thermal expansion coefficient, β is the haline contraction coefficient, T is conservative temperature, and S is absolute salinity.\n\nNote: In Oceananigans, model.tracers.T is conservative temperature and model.tracers.S is absolute salinity.\n\nNote that _z T (∂z_T), _z S (∂z_S), α, and β are all evaluated at cell interfaces in z and cell centers in x and y.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Coriolis","page":"Library","title":"Coriolis","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Coriolis]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.Coriolis.ActiveCellEnstrophyConserving","page":"Library","title":"Oceananigans.Coriolis.ActiveCellEnstrophyConserving","text":"struct ActiveCellEnstrophyConserving\n\nA parameter object for an enstrophy-conserving Coriolis scheme that excludes inactive (dry/land) edges (indices for which peripheral_node == true) from the velocity interpolation.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Coriolis.BetaPlane","page":"Library","title":"Oceananigans.Coriolis.BetaPlane","text":"BetaPlane([T=Float64;] f₀=nothing, β=nothing,\n                       rotation_rate=Ω_Earth, latitude=nothing, radius=R_Earth)\n\nReturn a β-plane Coriolis parameter, f = f₀ + β y. \n\nThe user may specify both f₀ and β, or the three parameters rotation_rate, latitude (in degrees), and radius that specify the rotation rate and radius of a planet, and the central latitude (where y = 0) at which the β-plane approximation is to be made.\n\nIf f₀ and β are not specified, they are calculated from rotation_rate, latitude, and radius according to the relations f₀ = 2 * rotation_rate * sind(latitude) and β = 2 * rotation_rate * cosd(latitude) / radius.\n\nBy default, the rotation_rate and planet radius are assumed to be Earth's.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Coriolis.BetaPlane-2","page":"Library","title":"Oceananigans.Coriolis.BetaPlane","text":"struct BetaPlane{T} <: AbstractRotation\n\nA parameter object for meridionally increasing Coriolis parameter (f = f₀ + β y) that accounts for the variation of the locally vertical component of the rotation vector with latitude.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Coriolis.ConstantCartesianCoriolis","page":"Library","title":"Oceananigans.Coriolis.ConstantCartesianCoriolis","text":"ConstantCartesianCoriolis([FT=Float64;] fx=nothing, fy=nothing, fz=nothing,\n                                        f=nothing, rotation_axis=ZDirection(), \n                                        rotation_rate=Ω_Earth, latitude=nothing)\n\nReturn a parameter object for a constant rotation decomposed into the x, y, and z directions. In oceanography the components x, y, z correspond to the directions east, north, and up. This constant rotation can be specified in three different ways:\n\nSpecifying all components fx, fy and fz directly.\nSpecifying the Coriolis parameter f and (optionally) a rotation_axis (which defaults to the z direction if not specified).\nSpecifying latitude (in degrees) and (optionally) a rotation_rate in radians per second (which defaults to Earth's rotation rate).\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Coriolis.ConstantCartesianCoriolis-2","page":"Library","title":"Oceananigans.Coriolis.ConstantCartesianCoriolis","text":"struct ConstantCartesianCoriolis{FT} <: AbstractRotation\n\nA Coriolis implementation that accounts for the locally vertical and possibly both local horizontal components of a constant rotation vector. This is a more general implementation of FPlane, which only accounts for the locally vertical component.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Coriolis.FPlane","page":"Library","title":"Oceananigans.Coriolis.FPlane","text":"FPlane([FT=Float64;] f=nothing, rotation_rate=Ω_Earth, latitude=nothing)\n\nReturn a parameter object for constant rotation at the angular frequency f/2, and therefore with background vorticity f, around a vertical axis. If f is not specified, it is calculated from rotation_rate and latitude (in degrees) according to the relation f = 2 * rotation_rate * sind(latitude).\n\nBy default, rotation_rate is assumed to be Earth's.\n\nAlso called FPlane, after the \"f-plane\" approximation for the local effect of a planet's rotation in a planar coordinate system tangent to the planet's surface.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Coriolis.FPlane-2","page":"Library","title":"Oceananigans.Coriolis.FPlane","text":"struct FPlane{FT} <: AbstractRotation\n\nA parameter object for constant rotation around a vertical axis.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Coriolis.HydrostaticSphericalCoriolis","page":"Library","title":"Oceananigans.Coriolis.HydrostaticSphericalCoriolis","text":"struct HydrostaticSphericalCoriolis{S, FT} <: AbstractRotation\n\nA parameter object for constant rotation around a vertical axis on the sphere.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Coriolis.HydrostaticSphericalCoriolis-Union{Tuple{}, Tuple{DataType}, Tuple{S}} where S","page":"Library","title":"Oceananigans.Coriolis.HydrostaticSphericalCoriolis","text":"HydrostaticSphericalCoriolis([FT=Float64;]\n                             rotation_rate = Ω_Earth,\n                             scheme = ActiveCellEnstrophyConserving())\n\nReturn a parameter object for Coriolis forces on a sphere rotating at rotation_rate.\n\nKeyword arguments\n\nrotation_rate: Sphere's rotation rate; default: Ω_Earth.\nscheme: Either EnergyConserving(), EnstrophyConserving(), or ActiveCellEnstrophyConserving() (default).\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Coriolis.NonTraditionalBetaPlane","page":"Library","title":"Oceananigans.Coriolis.NonTraditionalBetaPlane","text":"NonTraditionalBetaPlane(FT=Float64;\n                        fz=nothing, fy=nothing, β=nothing, γ=nothing,\n                        rotation_rate=Ω_Earth, latitude=nothing, radius=R_Earth)\n\nThe user may directly specify fz, fy, β, γ, and radius or the three parameters rotation_rate, latitude (in degrees), and radius that specify the rotation rate and radius of a planet, and the central latitude (where y = 0) at which the non-traditional β-plane approximation is to be made.\n\nIf fz, fy, β, and γ are not specified, they are calculated from rotation_rate,  latitude, and radius according to the relations fz = 2 * rotation_rate * sind(latitude), fy = 2 * rotation_rate * cosd(latitude), β = 2 * rotation_rate * cosd(latitude) / radius, and γ = - 4 * rotation_rate * sind(latitude) / radius.\n\nBy default, the rotation_rate and planet radius is assumed to be Earth's.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Coriolis.NonTraditionalBetaPlane-2","page":"Library","title":"Oceananigans.Coriolis.NonTraditionalBetaPlane","text":"struct NonTraditionalBetaPlane{FT} <: AbstractRotation\n\nA Coriolis implementation that accounts for the latitudinal variation of both the locally vertical and the locally horizontal components of the rotation vector. The \"traditional\" approximation in ocean models accounts for only the locally vertical component of the rotation vector (see BetaPlane).\n\nThis implementation is based off of section 5 of Dellar (2011) and it conserves energy, angular momentum, and potential vorticity.\n\nReferences\n\nDellar, P. (2011). Variations on a beta-plane: Derivation of non-traditional     beta-plane equations from Hamilton's principle on a sphere. Journal of     Fluid Mechanics, 674, 174-195. doi:10.1017/S0022112010006464\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Diagnostics","page":"Library","title":"Diagnostics","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Diagnostics]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.Diagnostics.CFL","page":"Library","title":"Oceananigans.Diagnostics.CFL","text":"struct CFL{D, S}\n\nAn object for computing the Courant-Freidrichs-Lewy (CFL) number.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Diagnostics.CFL-Tuple{Any}","page":"Library","title":"Oceananigans.Diagnostics.CFL","text":"CFL(Δt [, timescale = Oceananigans.Advection.cell_advection_timescale])\n\nReturn an object for computing the Courant-Freidrichs-Lewy (CFL) number associated with time step Δt or TimeStepWizard and timescale.\n\nSee also AdvectiveCFL and DiffusiveCFL.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Diagnostics.StateChecker-Tuple{Any}","page":"Library","title":"Oceananigans.Diagnostics.StateChecker","text":"StateChecker(; schedule, fields)\n\nReturns a StateChecker that logs field information (minimum, maximum, mean) for each field in a named tuple of fields when schedule actuates.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Diagnostics.AdvectiveCFL-Tuple{Any}","page":"Library","title":"Oceananigans.Diagnostics.AdvectiveCFL","text":"AdvectiveCFL(Δt)\n\nReturn an object for computing the Courant-Freidrichs-Lewy (CFL) number associated with time step Δt or TimeStepWizard and the time scale for advection across a cell. The advective CFL is, e.g., U Δt  Δx.\n\nExample\n\njulia> using Oceananigans\n\njulia> model = NonhydrostaticModel(grid = RectilinearGrid(size=(16, 16, 16), extent=(8, 8, 8)));\n\njulia> Δt = 1.0;\n\njulia> cfl = AdvectiveCFL(Δt);\n\njulia> model.velocities.u .= π;\n\njulia> cfl(model)\n6.283185307179586\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Diagnostics.DiffusiveCFL-Tuple{Any}","page":"Library","title":"Oceananigans.Diagnostics.DiffusiveCFL","text":"DiffusiveCFL(Δt)\n\nReturns an object for computing the diffusive Courant-Freidrichs-Lewy (CFL) number associated with time step Δt or TimeStepWizard and the time scale for diffusion across a cell associated with model.closure.  The diffusive CFL, e.g., for viscosity is ν Δt  Δx².\n\nThe maximum diffusive CFL number among viscosity and all tracer diffusivities is returned.\n\nExample\n\njulia> using Oceananigans\n\njulia> model = NonhydrostaticModel(grid = RectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1)),\n                                   closure = ScalarDiffusivity(; ν = 1e-2));\n\njulia> Δt = 0.1;\n\njulia> dcfl = DiffusiveCFL(Δt);\n\njulia> dcfl(model)\n0.256\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Distributed","page":"Library","title":"Distributed","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.DistributedComputations]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.DistributedComputations.Distributed","page":"Library","title":"Oceananigans.DistributedComputations.Distributed","text":"Distributed(child_architecture = CPU(); \n            partition = Partition(MPI.Comm_size(communicator)),\n            devices = nothing, \n            communicator = MPI.COMM_WORLD,\n            synchronized_communication = false)\n\nReturn a distributed architecture that uses MPI for communications.\n\nPositional arguments\n\nchild_architecture: Specifies whether the computation is performed on CPUs or GPUs.                        Default: CPU().\n\nKeyword arguments\n\npartition: A Partition specifying the total processors in the x, y, and z direction.              Note that support for distributed z direction is  limited; we strongly suggest              using partition with z = 1 kwarg.\ndevices: GPU device linked to local rank. The GPU will be assigned based on the             local node rank as such devices[node_rank]. Make sure to run --ntasks-per-node <= --gres=gpu.            If nothing, the devices will be assigned automatically based on the available resources.            This argument is irrelevant if child_architecture = CPU().\ncommunicator: the MPI communicator that orchestrates data transfer between nodes.                 Default: MPI.COMM_WORLD.\nsynchronized_communication: This keyword argument can be used to control downstream code behavior.                               If true, then downstream code may use this tag to toggle between an algorithm                               that permits communication between nodes \"asynchronously\" with other computations,                               and an alternative serial algorithm in which communication and computation are                               \"synchronous\" (that is, performed one after the other).                               Default: false, specifying the use of asynchronous algorithms where supported,                               which may result in faster time-to-solution.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.DistributedComputations.DistributedFFTBasedPoissonSolver","page":"Library","title":"Oceananigans.DistributedComputations.DistributedFFTBasedPoissonSolver","text":"DistributedFFTBasedPoissonSolver(global_grid, local_grid)\n\nReturn an FFT-based solver for the Poisson equation,\n\n²φ = b\n\nfor Distributed architectures.\n\nSupported configurations\n\nIn the following, Nx, Ny, and Nz are the number of grid points of the global grid,  in the x, y, and z directions, while Rx, Ry, and Rz are the number of ranks in the x, y, and z directions, respectively. Furthermore, 'pencil' decomposition refers to a domain  decomposed in two different directions (i.e., with Rx != 1 and Ry != 1), while 'slab' decomposition  refers to a domain decomposed only in one direction, (i.e., with either Rx == 1 or Ry == 1). Additionally, storage indicates the TransposableField used for storing intermediate results; see TransposableField.\n\nThree dimensional grids with pencil decompositions in (x y) such the:\n\nthe z direction is local, Ny ≥ Rx and Ny % Rx = 0, and Nz ≥ Ry and Nz % Ry = 0.\n\nTwo dimensional grids decomposed in x where Ny ≥ Rx and Ny % Rx = 0.\n\nwarning: Unsupported decompositions\nAny configuration decomposed in z direction is not supported. Furthermore, any (x y) decompositions other than the configurations mentioned above are also not supported.\n\nAlgorithm for pencil decompositions\n\nFor pencil decompositions (useful for three-dimensional problems), there are three forward transforms,  three backward transforms, and four transpositions that require MPI communication.  In the algorithm below, the first dimension is always the local dimension. In our implementation we require Nz ≥ Ry and Nx ≥ Ry with the additional constraint that Nz % Ry = 0 and Ny % Rx = 0.\n\nstorage.zfield, partitioned over (x y) is initialized with the rhs that is b.\nTransform along z.\n\n3  Transpose storage.zfield + communicate to storage.yfield partitioned into (Rx, Ry) processes in (x z).\n\nTransform along y.\nTranspose storage.yfield + communicate to storage.xfield partitioned into (Rx, Ry) processes in (y z).\nTransform in x.\n\nAt this point the three in-place forward transforms are complete, and we solve the Poisson equation by updating storage.xfield. Then the process is reversed to obtain storage.zfield in physical space partitioned over (x y).\n\nAlgorithm for stencil decompositions\n\nThe stecil decomposition algorithm works in the same manner as the pencil decompostion described above while skipping the transposes that are not required. For example if the domain is decomposed in x,  step 3 in the above algorithm is skipped (and the associated transposition step in the bakward transform)\n\nRestrictions\n\nPencil decomopositions:\nNy ≥ Rx and Ny % Rx = 0\nNz ≥ Ry and Nz % Ry = 0\nIf the z direction is Periodic, also the y and the x directions must be Periodic\nIf the y direction is Periodic, also the x direction must be Periodic\nStencil decomposition:\nsame as for pencil decompositions with Rx (or Ry) equal to one\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.DistributedComputations.Equal","page":"Library","title":"Oceananigans.DistributedComputations.Equal","text":"Equal()\n\nReturn a type that partitions a direction equally among remaining processes.\n\nEqual() can be used for only one direction. Other directions must either be unspecified, or specifically defined by Int, Fractional, or Sizes.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.DistributedComputations.Fractional-Tuple","page":"Library","title":"Oceananigans.DistributedComputations.Fractional","text":"Fractional(ϵ₁, ϵ₂, ..., ϵₙ)\n\nReturn a type that partitions a direction unequally. The total work is W = sum(ϵᵢ),  and each process is then allocated ϵᵢ / W of the domain.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.DistributedComputations.Partition-Tuple{Any}","page":"Library","title":"Oceananigans.DistributedComputations.Partition","text":"Partition(; x = 1, y = 1, z = 1)\n\nReturn Partition representing the division of a domain in the x (first), y (second) and z (third) dimension\n\nKeyword arguments:\n\nx: partitioning of the first dimension \ny: partitioning of the second dimension\nz: partitioning of the third dimension\n\nif supplied as positional arguments x will be the first argument,  y the second and z the third\n\nx, y and z can be:\n\nx::Int: allocate x processors to the first dimension\nEqual(): divide the domain in x equally among the remaining processes (not supported for multiple directions)\nFractional(ϵ₁, ϵ₂, ..., ϵₙ): divide the domain unequally among N processes. The total work is W = sum(ϵᵢ),                                 and each process is then allocated ϵᵢ / W of the domain.\nSizes(n₁, n₂, ..., nₙ): divide the domain unequally. The total work is W = sum(nᵢ),                            and each process is then allocated nᵢ.\n\nExamples:\n\njulia> using Oceananigans; using Oceananigans.DistributedComputations\n\njulia> Partition(1, 4)\nPartition across 4 = 1×4×1 ranks:\n└── y: 4\n\njulia> Partition(x = Fractional(1, 2, 3, 4))\nPartition across 4 = 4×1×1 ranks:\n└── x: Fractional(0.1, 0.2, 0.3, 0.4)\n\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.DistributedComputations.partition-Tuple{AbstractArray, Oceananigans.DistributedComputations.Distributed, Any}","page":"Library","title":"Oceananigans.DistributedComputations.partition","text":"partition(A, arch, local_size)\n\nPartition the globally-sized A into local arrays with local_size on architecture.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.DistributedComputations.partition-Tuple{Any, Field}","page":"Library","title":"Oceananigans.DistributedComputations.partition","text":"partition(A, b)\n\nPartition the globally-sized A into local arrays with the same size as b.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.DistributedComputations.reconstruct_global_grid-Tuple{RectilinearGrid{FT, TX, TY, TZ, FX, FY, FZ, VX, VY, VZ, <:Oceananigans.DistributedComputations.Distributed} where {FT, TX, TY, TZ, FX, FY, FZ, VX, VY, VZ}}","page":"Library","title":"Oceananigans.DistributedComputations.reconstruct_global_grid","text":"reconstruct_global_grid(grid::DistributedGrid)\n\nReturn the global grid on child_architecture(grid)\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Fields","page":"Library","title":"Fields","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Fields]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.Fields.AbstractField","page":"Library","title":"Oceananigans.Fields.AbstractField","text":"AbstractField{LX, LY, LZ, G, T, N}\n\nAbstract supertype for fields located at (LX, LY, LZ) and defined on a grid G with eltype T and N dimensions.\n\nNote: we need the parameter T to subtype AbstractArray.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Fields.Accumulation-Tuple{Any, Any}","page":"Library","title":"Oceananigans.Fields.Accumulation","text":"Accumulation(accumulate!, operand; dims)\n\nReturn a Accumulation of operand with accumulate!, where accumulate! can be called with\n\naccumulate!(field, operand; dims)\n\nto accumulate operand along dims and store in field.\n\nExample\n\nusing Oceananigans\n\nNx, Ny, Nz = 3, 3, 3\n\ngrid = RectilinearGrid(size=(Nx, Ny, Nz), x=(0, 1), y=(0, 1), z=(0, 1),\n                       topology=(Periodic, Periodic, Periodic))\n\nc = CenterField(grid)\n\nset!(c, (x, y, z) -> x + y + z)\n\ncumsum_c² = Field(Accumulation(cumsum!, c^2, dims=3))\n\ncompute!(cumsum_c²)\n\ncumsum_c²[1:Nx, 1:Ny, 1:Nz]\n\n# output\n3×3×3 Array{Float64, 3}:\n[:, :, 1] =\n 0.25      0.694444  1.36111\n 0.694444  1.36111   2.25\n 1.36111   2.25      3.36111\n\n[:, :, 2] =\n 0.944444  2.05556  3.61111\n 2.05556   3.61111  5.61111\n 3.61111   5.61111  8.05556\n\n[:, :, 3] =\n 2.30556   4.30556   6.97222\n 4.30556   6.97222  10.3056\n 6.97222  10.3056   14.3056\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.BackgroundField","page":"Library","title":"Oceananigans.Fields.BackgroundField","text":"BackgroundField{F, P}\n\nTemporary container for storing information about BackgroundFields.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Fields.BackgroundField-Tuple{Any}","page":"Library","title":"Oceananigans.Fields.BackgroundField","text":"BackgroundField(func; parameters=nothing)\n\nReturns a BackgroundField to be passed to NonhydrostaticModel for use as a background velocity or tracer field.\n\nIf parameters is not provided, func must be callable with the signature\n\nfunc(x, y, z, t)\n\nIf parameters is provided, func must be callable with the signature\n\nfunc(x, y, z, t, parameters)\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.Field-Union{Tuple{Oceananigans.Grids.AbstractGrid}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Oceananigans.Grids.AbstractGrid, DataType}} where {LX, LY, LZ}","page":"Library","title":"Oceananigans.Fields.Field","text":"Field{LX, LY, LZ}(grid::AbstractGrid,\n                  T::DataType=eltype(grid); kw...) where {LX, LY, LZ}\n\nConstruct a Field on grid with data type T at the location (LX, LY, LZ). Each of (LX, LY, LZ) is either Center or Face and determines the field's location in (x, y, z) respectively.\n\nKeyword arguments\n\ndata :: OffsetArray: An offset array with the fields data. If nothing is provided the field is filled with zeros.\nboundary_conditions: If nothing is provided, then field is created using the default boundary conditions via FieldBoundaryConditions.\nindices: Used to prescribe where a reduced field lives on. For example, at which k index does a two-dimensional x-y field lives on. Default: (:, :, :).\n\nExample\n\nA field at location (Face, Face, Center).\n\njulia> using Oceananigans\n\njulia> grid = RectilinearGrid(size=(2, 3, 4), extent=(1, 1, 1));\n\njulia> ω = Field{Face, Face, Center}(grid)\n2×3×4 Field{Face, Face, Center} on RectilinearGrid on CPU\n├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 2×3×3 halo\n├── boundary conditions: FieldBoundaryConditions\n│   └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux\n└── data: 6×9×10 OffsetArray(::Array{Float64, 3}, -1:4, -2:6, -2:7) with eltype Float64 with indices -1:4×-2:6×-2:7\n    └── max=0.0, min=0.0, mean=0.0\n\nNow, using indices we can create a two dimensional x-y field at location (Face, Face, Center) to compute, e.g., the vertical vorticity vx - uy at the fluid's surface z = 0, which for Center corresponds to k = Nz.\n\njulia> u = XFaceField(grid); v = YFaceField(grid);\n\njulia> ωₛ = Field(∂x(v) - ∂y(u), indices=(:, :, grid.Nz))\n2×3×1 Field{Face, Face, Center} on RectilinearGrid on CPU\n├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 2×3×3 halo\n├── boundary conditions: FieldBoundaryConditions\n│   └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux\n├── indices: (:, :, 4:4)\n├── operand: BinaryOperation at (Face, Face, Center)\n├── status: time=0.0\n└── data: 6×9×1 OffsetArray(::Array{Float64, 3}, -1:4, -2:6, 4:4) with eltype Float64 with indices -1:4×-2:6×4:4\n    └── max=0.0, min=0.0, mean=0.0\n\njulia> compute!(ωₛ)\n2×3×1 Field{Face, Face, Center} on RectilinearGrid on CPU\n├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 2×3×3 halo\n├── boundary conditions: FieldBoundaryConditions\n│   └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux\n├── indices: (:, :, 4:4)\n├── operand: BinaryOperation at (Face, Face, Center)\n├── status: time=0.0\n└── data: 6×9×1 OffsetArray(::Array{Float64, 3}, -1:4, -2:6, 4:4) with eltype Float64 with indices -1:4×-2:6×4:4\n    └── max=0.0, min=0.0, mean=0.0\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.Reduction-Tuple{Any, Any}","page":"Library","title":"Oceananigans.Fields.Reduction","text":"Reduction(reduce!, operand; dims)\n\nReturn a Reduction of operand with reduce!, where reduce! can be called with\n\nreduce!(field, operand)\n\nto reduce operand along dims and store in field.\n\nExample\n\nusing Oceananigans\n\nNx, Ny, Nz = 3, 3, 3\n\ngrid = RectilinearGrid(size=(Nx, Ny, Nz), x=(0, 1), y=(0, 1), z=(0, 1),\n                       topology=(Periodic, Periodic, Periodic))\n\nc = CenterField(grid)\n\nset!(c, (x, y, z) -> x + y + z)\n\nmax_c² = Field(Reduction(maximum!, c^2, dims=3))\n\ncompute!(max_c²)\n\nmax_c²[1:Nx, 1:Ny]\n\n# output\n3×3 Matrix{Float64}:\n 1.36111  2.25     3.36111\n 2.25     3.36111  4.69444\n 3.36111  4.69444  6.25\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.CenterField","page":"Library","title":"Oceananigans.Fields.CenterField","text":"CenterField(grid, T=eltype(grid); kw...)\n\nReturn a Field{Center, Center, Center} on grid. Additional keyword arguments are passed to the Field constructor.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.Fields.TendencyFields-Tuple{Any, Any}","page":"Library","title":"Oceananigans.Fields.TendencyFields","text":"TendencyFields(grid, tracer_names;\n               u = XFaceField(grid),\n               v = YFaceField(grid),\n               w = ZFaceField(grid),\n               kwargs...)\n\nReturn a NamedTuple with tendencies for all solution fields (velocity fields and tracer fields), initialized on grid. Optional kwargs can be specified to assign data arrays to each tendency field.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.TracerFields-Tuple{@NamedTuple{}, Any, Any}","page":"Library","title":"Oceananigans.Fields.TracerFields","text":"Shortcut constructor for empty tracer fields.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.TracerFields-Tuple{Any, Any, Any}","page":"Library","title":"Oceananigans.Fields.TracerFields","text":"TracerFields(tracer_names, grid, user_bcs)\n\nReturn a NamedTuple with tracer fields specified by tracer_names initialized as CenterFields on grid. Boundary conditions user_bcs may be specified via a named tuple of FieldBoundaryConditions.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.TracerFields-Tuple{Any, Any}","page":"Library","title":"Oceananigans.Fields.TracerFields","text":"TracerFields(tracer_names, grid; kwargs...)\n\nReturn a NamedTuple with tracer fields specified by tracer_names initialized as CenterFields on grid. Fields may be passed via optional keyword arguments kwargs for each field.\n\nThis function is used by OutputWriters.Checkpointer and TendencyFields. ```\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.TracerFields-Tuple{NamedTuple, Any, Any}","page":"Library","title":"Oceananigans.Fields.TracerFields","text":"TracerFields(proposed_tracers::NamedTuple, grid, bcs)\n\nReturn a NamedTuple of tracers, overwriting boundary conditions in proposed_tracers with corresponding fields in the NamedTuple bcs.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.VelocityFields","page":"Library","title":"Oceananigans.Fields.VelocityFields","text":"VelocityFields(grid, user_bcs = NamedTuple())\n\nReturn a NamedTuple with fields u, v, w initialized on grid. Boundary conditions bcs may be specified via a named tuple of FieldBoundaryConditions.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.Fields.VelocityFields-Tuple{NamedTuple{(:u, :v, :w)}, Any, Any}","page":"Library","title":"Oceananigans.Fields.VelocityFields","text":"VelocityFields(proposed_velocities::NamedTuple{(:u, :v, :w)}, grid, bcs)\n\nReturn a NamedTuple of velocity fields, overwriting boundary conditions in proposed_velocities with corresponding fields in the NamedTuple bcs.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.XFaceField","page":"Library","title":"Oceananigans.Fields.XFaceField","text":"XFaceField(grid, T=eltype(grid); kw...)\n\nReturn a Field{Face, Center, Center} on grid. Additional keyword arguments are passed to the Field constructor.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.Fields.YFaceField","page":"Library","title":"Oceananigans.Fields.YFaceField","text":"YFaceField(grid, T=eltype(grid); kw...)\n\nReturn a Field{Center, Face, Center} on grid. Additional keyword arguments are passed to the Field constructor.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.Fields.ZFaceField","page":"Library","title":"Oceananigans.Fields.ZFaceField","text":"ZFaceField(grid, T=eltype(grid); kw...)\n\nReturn a Field{Center, Center, Face} on grid. Additional keyword arguments are passed to the Field constructor.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.Fields.compute!","page":"Library","title":"Oceananigans.Fields.compute!","text":"compute!(field)\n\nComputes field.data from field.operand.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.Fields.field-Tuple{Any, AbstractArray, Any}","page":"Library","title":"Oceananigans.Fields.field","text":"field(loc, a, grid)\n\nBuild a field from array a at loc and on grid.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.interior-Tuple{Field}","page":"Library","title":"Oceananigans.Fields.interior","text":"interior(f::Field)\n\nReturn a view of f that excludes halo points.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.interpolate-NTuple{4, Any}","page":"Library","title":"Oceananigans.Fields.interpolate","text":"interpolate(at_node, from_field, from_loc, from_grid)\n\nInterpolate from_field, at_node, on from_grid and at from_location, where at_node is a tuple of coordinates and and from_loc = (ℓx, ℓy, ℓz).\n\nNote that this is a lower-level interpolate method defined for use in CPU/GPU kernels.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.interpolate-Tuple{Any, Any}","page":"Library","title":"Oceananigans.Fields.interpolate","text":"interpolate(to_node, from_field)\n\nInterpolate field to the physical point (x, y, z) using trilinear interpolation.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.regrid!-Tuple{Any, Any}","page":"Library","title":"Oceananigans.Fields.regrid!","text":"regrid!(a, b)\n\nRegrid field b onto the grid of field a. \n\nExample\n\nGenerate a tracer field on a vertically stretched grid and regrid it on a regular grid.\n\nusing Oceananigans\n\nNz, Lz = 2, 1.0\ntopology = (Flat, Flat, Bounded)\n\ninput_grid = RectilinearGrid(size=Nz, z = [0, Lz/3, Lz], topology=topology, halo=1)\ninput_field = CenterField(input_grid)\ninput_field[1, 1, 1:Nz] = [2, 3]\n\noutput_grid = RectilinearGrid(size=Nz, z=(0, Lz), topology=topology, halo=1)\noutput_field = CenterField(output_grid)\n\nregrid!(output_field, input_field)\n\noutput_field[1, 1, :]\n\n# output\n4-element OffsetArray(::Vector{Float64}, 0:3) with eltype Float64 with indices 0:3:\n 0.0\n 2.333333333333333\n 3.0\n 0.0\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.location-Tuple{Any}","page":"Library","title":"Oceananigans.location","text":"Returns the location (LX, LY, LZ) of an AbstractField{LX, LY, LZ}.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Fields.@compute-Tuple{Any}","page":"Library","title":"Oceananigans.Fields.@compute","text":"@compute(exprs...)\n\nCall compute! on fields after defining them.\n\n\n\n\n\n","category":"macro"},{"location":"appendix/library/#Forcings","page":"Library","title":"Forcings","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Forcings]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.Forcings.AdvectiveForcing-Tuple{}","page":"Library","title":"Oceananigans.Forcings.AdvectiveForcing","text":"AdvectiveForcing(u=ZeroField(), v=ZeroField(), w=ZeroField())\n\nBuild a forcing term representing advection by the velocity field u, v, w with an advection scheme.\n\nExample\n\nUsing a tracer field to model sinking particles\n\nusing Oceananigans\n\n# Physical parameters\ngravitational_acceleration          = 9.81     # m s⁻²\nocean_density                       = 1026     # kg m⁻³\nmean_particle_density               = 2000     # kg m⁻³\nmean_particle_radius                = 1e-3     # m\nocean_molecular_kinematic_viscosity = 1.05e-6  # m² s⁻¹\n\n# Terminal velocity of a sphere in viscous flow\nΔb = gravitational_acceleration * (mean_particle_density - ocean_density) / ocean_density\nν = ocean_molecular_kinematic_viscosity\nR = mean_particle_radius\n\nw_Stokes = - 2/9 * Δb / ν * R^2 # m s⁻¹\n\nsettling = AdvectiveForcing(w=w_Stokes)\n\n# output\nAdvectiveForcing:\n├── u: ZeroField{Int64}\n├── v: ZeroField{Int64}\n└── w: ConstantField(-1.97096)\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Forcings.ContinuousForcing","page":"Library","title":"Oceananigans.Forcings.ContinuousForcing","text":"ContinuousForcing{LX, LY, LZ, P, F, D, I, ℑ}\n\nA callable object that implements a \"continuous form\" forcing function on a field at the location LX, LY, LZ with optional parameters.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Forcings.ContinuousForcing-Tuple{Any}","page":"Library","title":"Oceananigans.Forcings.ContinuousForcing","text":"ContinuousForcing(func; parameters=nothing, field_dependencies=())\n\nConstruct a \"continuous form\" forcing with optional parameters and optional field_dependencies on other fields in a model.\n\nIf neither parameters nor field_dependencies are provided, then func must be callable with the signature\n\nfunc(X..., t)\n\nwhere, on a three-dimensional grid with no Flat directions, X = (x, y, z) is a 3-tuple containing the east-west, north-south, and vertical spatial coordinates, and t is time.\n\nDimensions with Flat topology are omitted from the coordinate tuple X. For example, on a grid with topology (Periodic, Periodic, Flat), and with no parameters or field_dependencies, then func must be callable\n\nfunc(x, y, t)\n\nwhere x and y are the east-west and north-south coordinates, respectively. For another example, on a grid with topology (Flat, Flat, Bounded) (e.g. a single column), and for a forcing with no parameters or field_dependencies, then func must be callable with\n\nfunc(z, t)\n\nwhere z is the vertical coordinate.\n\nIf field_dependencies are provided, the signature of func must include them. For example, if field_dependencies=(:u, :S) (and parameters are not provided), and on a three-dimensional grid with no Flat dimensions, then func must be callable with the signature\n\nfunc(x, y, z, t, u, S)\n\nwhere u is assumed to be the u-velocity component, and S is a tracer. Note that any field which does not have the name u, v, or w is assumed to be a tracer and must be present in model.tracers.\n\nIf parameters are provided, then the last argument to func must be parameters. For example, if func has no field_dependencies but does depend on parameters, then on a three-dimensional grid it must be callable with the signature\n\nfunc(x, y, z, t, parameters)\n\nWith field_dependencies=(:u, :v, :w, :c) and parameters and on a three-dimensional grid, then func must be callable with the signature\n\nfunc(x, y, z, t, u, v, w, c, parameters)\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Forcings.DiscreteForcing","page":"Library","title":"Oceananigans.Forcings.DiscreteForcing","text":"struct DiscreteForcing{P, F}\n\nWrapper for \"discrete form\" forcing functions with optional parameters.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Forcings.DiscreteForcing-Tuple{Any}","page":"Library","title":"Oceananigans.Forcings.DiscreteForcing","text":"DiscreteForcing(func; parameters=nothing)\n\nConstruct a \"discrete form\" forcing function with optional parameters. The forcing function is applied at grid point i, j, k.\n\nWhen parameters are not specified, func must be callable with the signature\n\nfunc(i, j, k, grid, clock, model_fields)\n\nwhere grid is model.grid, clock.time is the current simulation time and clock.iteration is the current model iteration, and model_fields is a NamedTuple with u, v, w and the fields in model.tracers.\n\nNote that the index end does not access the final physical grid point of a model field in any direction. The final grid point must be explicitly specified, as in model_fields.u[i, j, grid.Nz].\n\nWhen parameters is specified, func must be callable with the signature.\n\nfunc(i, j, k, grid, clock, model_fields, parameters)\n\nAbove, parameters is, in principle, arbitrary. Note, however, that GPU compilation can place constraints on typeof(parameters).\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Forcings.GaussianMask","page":"Library","title":"Oceananigans.Forcings.GaussianMask","text":"GaussianMask{D}(center, width)\n\nCallable object that returns a Gaussian masking function centered on center, with width, and varying along direction D, i.e.,\n\nexp(-(D - center)^2 / (2 * width^2))\n\nExample\n\nCreate a Gaussian mask centered on z=0 with width 1 meter.\n\njulia> mask = GaussianMask{:z}(center=0, width=1)\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Forcings.LinearTarget","page":"Library","title":"Oceananigans.Forcings.LinearTarget","text":"LinearTarget{D}(intercept, gradient)\n\nCallable object that returns a Linear target function with intercept and gradient, and varying along direction D, i.e.,\n\nintercept + D * gradient\n\nExample\n\nCreate a linear target function varying in z, equal to 0 at z=0 and with gradient 10⁻⁶:\n\njulia> target = LinearTarget{:z}(intercept=0, gradient=1e-6)\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Forcings.Relaxation","page":"Library","title":"Oceananigans.Forcings.Relaxation","text":"struct Relaxation{R, M, T}\n\nCallable object for restoring fields to a target at some rate and within a masked region in x, y, z.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Forcings.Relaxation-Tuple{}","page":"Library","title":"Oceananigans.Forcings.Relaxation","text":"Relaxation(; rate, mask=onefunction, target=zerofunction)\n\nReturns a Forcing that restores a field to target(X..., t) at the specified rate, in the region mask(X...).\n\nThe functions onefunction and zerofunction always return 1 and 0, respectively. Thus the default mask leaves the whole domain uncovered, and the default target is zero.\n\nExample\n\nRestore a field to zero on a timescale of \"3600\" (equal to one hour if the time units of the simulation are seconds).\n\nusing Oceananigans\n\ndamping = Relaxation(rate = 1/3600)\n\n# output\nRelaxation{Float64, typeof(Oceananigans.Forcings.onefunction), typeof(Oceananigans.Forcings.zerofunction)}\n├── rate: 0.0002777777777777778\n├── mask: 1\n└── target: 0\n\nRestore a field to a linear z-gradient within the bottom 1/4 of a domain on a timescale of \"60\" (equal to one minute if the time units of the simulation are seconds).\n\ndTdz = 0.001 # ⁰C m⁻¹, temperature gradient\n\nT₀ = 20 # ⁰C, surface temperature at z=0\n\nLz = 100 # m, depth of domain\n\nbottom_sponge_layer = Relaxation(; rate = 1/60,\n                                   target = LinearTarget{:z}(intercept=T₀, gradient=dTdz),\n                                   mask = GaussianMask{:z}(center=-Lz, width=Lz/4))\n\n# output\nRelaxation{Float64, GaussianMask{:z, Float64}, LinearTarget{:z, Float64}}\n├── rate: 0.016666666666666666\n├── mask: exp(-(z + 100.0)^2 / (2 * 25.0^2))\n└── target: 20.0 + 0.001 * z\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Forcings.Forcing-Tuple{AbstractArray}","page":"Library","title":"Oceananigans.Forcings.Forcing","text":"Forcing(array::AbstractArray)\n\nReturn a Forcing by array, which can be added to the tendency of a model field.\n\nForcing is computed by calling array[i, j, k], so array must be 3D with size(grid).\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Forcings.Forcing-Tuple{Any}","page":"Library","title":"Oceananigans.Forcings.Forcing","text":"Forcing(func; parameters=nothing, field_dependencies=(), discrete_form=false)\n\nReturn a Forcing function, which can be added to the tendency of a model field.\n\nIf discrete_form=false (the default), and neither parameters nor field_dependencies are provided, then func must be callable with the signature\n\nfunc(x, y, z, t)\n\nwhere x, y, z are the east-west, north-south, and vertical spatial coordinates, and t is time. Note that this form is also default in the constructor for NonhydrostaticModel, so that Forcing is not needed.\n\nIf discrete_form=false (the default), and field_dependencies are provided, the signature of func must include them. For example, if field_dependencies=(:u, :S) (and parameters are not provided), then func must be callable with the signature\n\nfunc(x, y, z, t, u, S)\n\nwhere u is assumed to be the u-velocity component, and S is a tracer. Note that any field which does not have the name u, v, or w is assumed to be a tracer and must be present in model.tracers.\n\nIf discrete_form=false (the default) and parameters are provided, then the last argument to func must be parameters. For example, if func has no field_dependencies but does depend on parameters, then it must be callable with the signature\n\nfunc(x, y, z, t, parameters)\n\nThe object parameters is arbitrary in principle, however GPU compilation can place constraints on typeof(parameters).\n\nWith field_dependencies=(:u, :v, :w, :c) and parameters, then func must be callable with the signature\n\nfunc(x, y, z, t, u, v, w, c, parameters)\n\nIf discrete_form=true then func must be callable with the \"discrete form\"\n\nfunc(i, j, k, grid, clock, model_fields)\n\nwhere i, j, k is the grid point at which the forcing is applied, grid is model.grid, clock.time is the current simulation time and clock.iteration is the current model iteration, and model_fields is a NamedTuple with u, v, w, the fields in model.tracers, and the fields in model.diffusivity_fields, each of which is an OffsetArrays (or NamedTuples of OffsetArrays depending on the turbulence closure) of field data.\n\nWhen discrete_form=true and parameters is specified, func must be callable with the signature\n\nfunc(i, j, k, grid, clock, model_fields, parameters)\n\nExamples\n\nusing Oceananigans\n\n# Parameterized forcing\nparameterized_func(x, y, z, t, p) = p.μ * exp(z / p.λ) * cos(p.ω * t)\n\nv_forcing = Forcing(parameterized_func, parameters = (μ=42, λ=0.1, ω=π))\n\n# output\nContinuousForcing{@NamedTuple{μ::Int64, λ::Float64, ω::Irrational{:π}}}\n├── func: parameterized_func (generic function with 1 method)\n├── parameters: (μ = 42, λ = 0.1, ω = π)\n└── field dependencies: ()\n\nNote that because forcing locations are regularized within the NonhydrostaticModel constructor:\n\ngrid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))\nmodel = NonhydrostaticModel(grid=grid, forcing=(v=v_forcing,))\n\nmodel.forcing.v\n\n# output\nContinuousForcing{@NamedTuple{μ::Int64, λ::Float64, ω::Irrational{:π}}} at (Center, Face, Center)\n├── func: parameterized_func (generic function with 1 method)\n├── parameters: (μ = 42, λ = 0.1, ω = π)\n└── field dependencies: ()\n\nAfter passing through the constructor for NonhydrostaticModel, the v-forcing location information is available and set to Center, Face, Center.\n\n# Field-dependent forcing\ngrowth_in_sunlight(x, y, z, t, P) = exp(z) * P\n\nplankton_forcing = Forcing(growth_in_sunlight, field_dependencies=:P)\n\n# output\nContinuousForcing{Nothing}\n├── func: growth_in_sunlight (generic function with 1 method)\n├── parameters: nothing\n└── field dependencies: (:P,)\n\n# Parameterized, field-dependent forcing\ntracer_relaxation(x, y, z, t, c, p) = p.μ * exp((z + p.H) / p.λ) * (p.dCdz * z - c) \n\nc_forcing = Forcing(tracer_relaxation,\n                    field_dependencies = :c,\n                            parameters = (μ=1/60, λ=10, H=1000, dCdz=1))\n\n# output\nContinuousForcing{@NamedTuple{μ::Float64, λ::Int64, H::Int64, dCdz::Int64}}\n├── func: tracer_relaxation (generic function with 1 method)\n├── parameters: (μ = 0.016666666666666666, λ = 10, H = 1000, dCdz = 1)\n└── field dependencies: (:c,)\n\n# Unparameterized discrete-form forcing function\nfiltered_relaxation(i, j, k, grid, clock, model_fields) =\n    @inbounds - (model_fields.c[i-1, j, k] + model_fields.c[i, j, k] + model_fields.c[i+1, j, k]) / 3\n\nfiltered_forcing = Forcing(filtered_relaxation, discrete_form=true)\n\n# output\nDiscreteForcing{Nothing}\n├── func: filtered_relaxation (generic function with 1 method)\n└── parameters: nothing\n\n# Discrete-form forcing function with parameters\nmasked_damping(i, j, k, grid, clock, model_fields, parameters) = \n    @inbounds - parameters.μ * exp(grid.zᵃᵃᶜ[k] / parameters.λ) * model_fields.u[i, j, k]\n\nmasked_damping_forcing = Forcing(masked_damping, parameters=(μ=42, λ=π), discrete_form=true)\n\n# output\nDiscreteForcing{@NamedTuple{μ::Int64, λ::Irrational{:π}}}\n├── func: masked_damping (generic function with 1 method)\n└── parameters: (μ = 42, λ = π)\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Forcings.Forcing-Tuple{Union{FieldTimeSeries{LX, LY, LZ, TI, K}, Oceananigans.OutputReaders.GPUAdaptedFieldTimeSeries{LX, LY, LZ, TI, K}} where {LX, LY, LZ, TI, K}}","page":"Library","title":"Oceananigans.Forcings.Forcing","text":"Forcing(array::FlavorOfFTS)\n\nReturn a Forcing by a FieldTimeSeries, which can be added to the tendency of a model field.\n\nForcing is computed by calling fts[i, j, k, Time(clock.time)], so the FieldTimeSeries must have the spatial dimensions of the grid.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Grids","page":"Library","title":"Grids","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Grids]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.Grids.AbstractCurvilinearGrid","page":"Library","title":"Oceananigans.Grids.AbstractCurvilinearGrid","text":"AbstractCurvilinearGrid{FT, TX, TY, TZ}\n\nAbstract supertype for curvilinear grids with elements of type FT and topology {TX, TY, TZ}.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.AbstractGrid","page":"Library","title":"Oceananigans.Grids.AbstractGrid","text":"AbstractGrid{FT, TX, TY, TZ}\n\nAbstract supertype for grids with elements of type FT and topology {TX, TY, TZ}.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.AbstractHorizontallyCurvilinearGrid","page":"Library","title":"Oceananigans.Grids.AbstractHorizontallyCurvilinearGrid","text":"AbstractHorizontallyCurvilinearGrid{FT, TX, TY, TZ}\n\nAbstract supertype for horizontally-curvilinear grids with elements of type FT and topology {TX, TY, TZ}.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.AbstractTopology","page":"Library","title":"Oceananigans.Grids.AbstractTopology","text":"AbstractTopology\n\nAbstract supertype for grid topologies.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.AbstractUnderlyingGrid","page":"Library","title":"Oceananigans.Grids.AbstractUnderlyingGrid","text":"AbstractUnderlyingGrid{FT, TX, TY, TZ}\n\nAbstract supertype for \"primary\" grids (as opposed to grids with immersed boundaries) with elements of type FT and topology {TX, TY, TZ}.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.Bounded","page":"Library","title":"Oceananigans.Grids.Bounded","text":"Bounded\n\nGrid topology for bounded dimensions, e.g., wall-bounded dimensions.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.Center","page":"Library","title":"Oceananigans.Grids.Center","text":"Center\n\nA type describing the location at the center of a grid cell.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.Face","page":"Library","title":"Oceananigans.Grids.Face","text":"Face\n\nA type describing the location at the face of a grid cell.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.Flat","page":"Library","title":"Oceananigans.Grids.Flat","text":"Flat\n\nGrid topology for flat dimensions, generally with one grid point, along which the solution is uniform and does not vary.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.FullyConnected","page":"Library","title":"Oceananigans.Grids.FullyConnected","text":"FullyConnected\n\nGrid topology for dimensions that are connected to other models or domains.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.LatitudeLongitudeGrid","page":"Library","title":"Oceananigans.Grids.LatitudeLongitudeGrid","text":"LatitudeLongitudeGrid([architecture = CPU(), FT = Float64];\n                      size,\n                      longitude,\n                      latitude,\n                      z = nothing,\n                      radius = R_Earth,\n                      topology = nothing,\n                      precompute_metrics = true,\n                      halo = nothing)\n\nCreates a LatitudeLongitudeGrid with coordinates (λ, φ, z) denoting longitude, latitude, and vertical coordinate respectively.\n\nPositional arguments\n\narchitecture: Specifies whether arrays of coordinates and spacings are stored                 on the CPU or GPU. Default: CPU().\nFT : Floating point data type. Default: Float64.\n\nKeyword arguments\n\nsize (required): A 3-tuple prescribing the number of grid points each direction.\nlongitude (required), latitude (required), z (default: nothing): Each is either a:\n2-tuple that specify the end points of the domain,\none-dimensional array specifying the cell interface locations, or\na single-argument function that takes an index and returns cell interface location.\nNote: the latitude and longitude coordinates extents are expected in degrees.\nradius: The radius of the sphere the grid lives on. By default is equal to the radius of Earth.\ntopology: Tuple of topologies (Flat, Bounded, Periodic) for each direction. The vertical             topology[3] must be Bounded, while the latitude-longitude topologies can be             Bounded, Periodic, or Flat. If no topology is provided then, by default, the             topology is (Periodic, Bounded, Bounded) if the latitudinal extent is 360 degrees             or (Bounded, Bounded, Bounded) otherwise.\nprecompute_metrics: Boolean specifying whether to precompute horizontal spacings and areas.                       Default: true. When false, horizontal spacings and areas are computed                       on-the-fly during a simulation.\nhalo: A 3-tuple of integers specifying the size of the halo region of cells surrounding         the physical interior. The default is 3 halo cells in every direction.\n\nExamples\n\nA default grid with Float64 type:\n\njulia> using Oceananigans\n\njulia> grid = LatitudeLongitudeGrid(size=(36, 34, 25),\n                                    longitude = (-180, 180),\n                                    latitude = (-85, 85),\n                                    z = (-1000, 0))\n36×34×25 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics\n├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=10.0\n├── latitude:  Bounded  φ ∈ [-85.0, 85.0]   regularly spaced with Δφ=5.0\n└── z:         Bounded  z ∈ [-1000.0, 0.0]  regularly spaced with Δz=40.0\n\nA bounded spherical sector with cell interfaces stretched hyperbolically near the top:\n\njulia> using Oceananigans\n\njulia> σ = 1.1; # stretching factor\n\njulia> Nz = 24; # vertical resolution\n\njulia> Lz = 1000; # depth (m)\n\njulia> hyperbolically_spaced_faces(k) = - Lz * (1 - tanh(σ * (k - 1) / Nz) / tanh(σ));\n\njulia> grid = LatitudeLongitudeGrid(size=(36, 34, Nz),\n                                    longitude = (-180, 180),\n                                    latitude = (-20, 20),\n                                    z = hyperbolically_spaced_faces,\n                                    topology = (Bounded, Bounded, Bounded))\n36×34×24 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics\n├── longitude: Bounded  λ ∈ [-180.0, 180.0] regularly spaced with Δλ=10.0\n├── latitude:  Bounded  φ ∈ [-20.0, 20.0]   regularly spaced with Δφ=1.17647\n└── z:         Bounded  z ∈ [-1000.0, -0.0] variably spaced with min(Δz)=21.3342, max(Δz)=57.2159\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.LeftConnected","page":"Library","title":"Oceananigans.Grids.LeftConnected","text":"LeftConnected\n\nGrid topology for dimensions that are connected to other models or domains only on the left (the other direction is bounded)\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.Periodic","page":"Library","title":"Oceananigans.Grids.Periodic","text":"Periodic\n\nGrid topology for periodic dimensions.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.RectilinearGrid","page":"Library","title":"Oceananigans.Grids.RectilinearGrid","text":"RectilinearGrid([architecture = CPU(), FT = Float64];\n                size,\n                x = nothing,\n                y = nothing,\n                z = nothing,\n                halo = nothing,\n                extent = nothing,\n                topology = (Periodic, Periodic, Bounded))\n\nCreate a RectilinearGrid with size = (Nx, Ny, Nz) grid points.\n\nPositional arguments\n\narchitecture: Specifies whether arrays of coordinates and spacings are stored                 on the CPU or GPU. Default: CPU().\nFT: Floating point data type. Default: Float64.\n\nKeyword arguments\n\nsize (required): A tuple prescribing the number of grid points in non-Flat directions.                    size is a 3-tuple for 3D models, a 2-tuple for 2D models, and either a                    scalar or 1-tuple for 1D models.\ntopology: A 3-tuple (TX, TY, TZ) specifying the topology of the domain.             TX, TY, and TZ specify whether the x-, y-, and z directions are             Periodic, Bounded, or Flat. The topology Flat indicates that a model does             not vary in those directions so that derivatives and interpolation are zero.             The default is topology = (Periodic, Periodic, Bounded).\nextent: A tuple prescribing the physical extent of the grid in non-Flat directions, e.g.,           (Lx, Ly, Lz). All directions are constructed with regular grid spacing and the domain           (in the case that no direction is Flat) is 0  x  L_x, 0  y  L_y, and           -L_z  z  0, which is most appropriate for oceanic applications in which z = 0           usually is the ocean's surface.\nx, y, and z: Each of x, y, z are either (i) 2-tuples that specify the end points of the domain                    in their respect directions (in which case scalar values may be used in Flat                    directions), or (ii) arrays or functions of the corresponding indices i, j, or k                    that specify the locations of cell faces in the x-, y-, or z-direction, respectively.                    For example, to prescribe the cell faces in z we need to provide a function that takes                    k as argument and returns the location of the faces for indices k = 1 through k = Nz + 1,                    where Nz is the size of the stretched z dimension.\n\nNote: Either extent, or all of x, y, and z must be specified.\n\nhalo: A tuple of integers that specifies the size of the halo region of cells surrounding         the physical interior for each non-Flat direction. The default is 3 halo cells in every direction.\n\nThe physical extent of the domain can be specified either via x, y, and z keyword arguments indicating the left and right endpoints of each dimensions, e.g., x = (-π, π) or via the extent argument, e.g., extent = (Lx, Ly, Lz), which specifies the extent of each dimension in which case 0  x  L_x, 0  y  L_y, and -L_z  z  0.\n\nA grid topology may be specified via a tuple assigning one of Periodic, Bounded, and, Flat to each dimension. By default, a horizontally periodic grid topology (Periodic, Periodic, Bounded) is assumed.\n\nConstants are stored using floating point values of type FT. By default this is Float64. Make sure to specify the desired FT if not using Float64.\n\nGrid properties\n\n(Nx, Ny, Nz) :: Int: Number of physical points in the (x y z)-direction.\n(Hx, Hy, Hz) :: Int: Number of halo points in the (x y z)-direction.\n(Lx, Ly, Lz) :: FT: Physical extent of the grid in the (x y z)-direction.\n(Δxᶜᵃᵃ, Δyᵃᶜᵃ, Δzᵃᵃᶜ): Spacings in the (x y z)-directions between the cell faces.                          These are the lengths in x, y, and z of Center cells and are                          defined at Center locations.\n(Δxᶠᵃᵃ, Δyᵃᶠᵃ, Δzᵃᵃᶠ): Spacings in the (x y z)-directions between the cell centers.                          These are the lengths in x, y, and z of Face cells and are                          defined at Face locations.\n(xᶜᵃᵃ, yᵃᶜᵃ, zᵃᵃᶜ): (x y z) coordinates of cell Centers.\n(xᶠᵃᵃ, yᵃᶠᵃ, zᵃᵃᶠ): (x y z) coordinates of cell Faces.\n\nExamples\n\nA grid with the default Float64 type:\n\njulia> using Oceananigans\n\njulia> grid = RectilinearGrid(size=(32, 32, 32), extent=(1, 2, 3))\n32×32×32 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo\n├── Periodic x ∈ [0.0, 1.0)  regularly spaced with Δx=0.03125\n├── Periodic y ∈ [0.0, 2.0)  regularly spaced with Δy=0.0625\n└── Bounded  z ∈ [-3.0, 0.0] regularly spaced with Δz=0.09375\n\nA grid with Float32 type:\n\njulia> using Oceananigans\n\njulia> grid = RectilinearGrid(Float32; size=(32, 32, 16), x=(0, 8), y=(-10, 10), z=(-π, π))\n32×32×16 RectilinearGrid{Float32, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo\n├── Periodic x ∈ [0.0, 8.0)          regularly spaced with Δx=0.25\n├── Periodic y ∈ [-10.0, 10.0)       regularly spaced with Δy=0.625\n└── Bounded  z ∈ [-3.14159, 3.14159] regularly spaced with Δz=0.392699\n\nA two-dimenisional, horizontally-periodic grid:\n\njulia> using Oceananigans\n\njulia> grid = RectilinearGrid(size=(32, 32), extent=(2π, 4π), topology=(Periodic, Periodic, Flat))\n32×32×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo\n├── Periodic x ∈ [3.60072e-17, 6.28319) regularly spaced with Δx=0.19635\n├── Periodic y ∈ [7.20145e-17, 12.5664) regularly spaced with Δy=0.392699\n└── Flat z\n\nA one-dimensional \"column\" grid:\n\njulia> using Oceananigans\n\njulia> grid = RectilinearGrid(size=256, z=(-128, 0), topology=(Flat, Flat, Bounded))\n1×1×256 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo\n├── Flat x\n├── Flat y\n└── Bounded  z ∈ [-128.0, 0.0] regularly spaced with Δz=0.5\n\nA horizontally-periodic regular grid with cell interfaces stretched hyperbolically near the top:\n\njulia> using Oceananigans\n\njulia> σ = 1.1; # stretching factor\n\njulia> Nz = 24; # vertical resolution\n\njulia> Lz = 32; # depth (m)\n\njulia> hyperbolically_spaced_faces(k) = - Lz * (1 - tanh(σ * (k - 1) / Nz) / tanh(σ));\n\njulia> grid = RectilinearGrid(size = (32, 32, Nz),\n                              x = (0, 64), y = (0, 64),\n                              z = hyperbolically_spaced_faces)\n32×32×24 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo\n├── Periodic x ∈ [0.0, 64.0)   regularly spaced with Δx=2.0\n├── Periodic y ∈ [0.0, 64.0)   regularly spaced with Δy=2.0\n└── Bounded  z ∈ [-32.0, -0.0] variably spaced with min(Δz)=0.682695, max(Δz)=1.83091\n\nA three-dimensional grid with regular spacing in x, cell interfaces at Chebyshev nodes in y, and cell interfaces hyperbolically stretched in z near the top:\n\njulia> using Oceananigans\n\njulia> Nx, Ny, Nz = 32, 30, 24;\n\njulia> Lx, Ly, Lz = 200, 100, 32; # (m)\n\njulia> chebychev_nodes(j) = - Ly/2 * cos(π * (j - 1) / Ny);\n\njulia> σ = 1.1; # stretching factor\n\njulia> hyperbolically_spaced_faces(k) = - Lz * (1 - tanh(σ * (k - 1) / Nz) / tanh(σ));\n\njulia> grid = RectilinearGrid(size = (Nx, Ny, Nz),\n                              topology = (Periodic, Bounded, Bounded),\n                              x = (0, Lx),\n                              y = chebychev_nodes,\n                              z = hyperbolically_spaced_faces)\n32×30×24 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3×3×3 halo\n├── Periodic x ∈ [0.0, 200.0)  regularly spaced with Δx=6.25\n├── Bounded  y ∈ [-50.0, 50.0] variably spaced with min(Δy)=0.273905, max(Δy)=5.22642\n└── Bounded  z ∈ [-32.0, -0.0] variably spaced with min(Δz)=0.682695, max(Δz)=1.83091\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Grids.RightConnected","page":"Library","title":"Oceananigans.Grids.RightConnected","text":"RightConnected\n\nGrid topology for dimensions that are connected to other models or domains only on the right (the other direction is bounded)\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Architectures.on_architecture-Tuple{Oceananigans.Architectures.AbstractSerialArchitecture, RectilinearGrid}","page":"Library","title":"Oceananigans.Architectures.on_architecture","text":"on_architecture(architecture, grid)\n\nReturn a new_grid that's identical to grid but on architecture.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.conformal_cubed_sphere_panel","page":"Library","title":"Oceananigans.Grids.conformal_cubed_sphere_panel","text":"conformal_cubed_sphere_panel(architecture::AbstractArchitecture = CPU(),\n                             FT::DataType = Float64;\n                             size,\n                             z,\n                             topology = (Bounded, Bounded, Bounded),\n                             ξ = (-1, 1),\n                             η = (-1, 1),\n                             radius = R_Earth,\n                             halo = (1, 1, 1),\n                             rotation = nothing)\n\nCreate a OrthogonalSphericalShellGrid that represents a section of a sphere after it has been  conformally mapped from the face of a cube. The cube's coordinates are ξ and η (which, by default, both take values in the range -1 1.\n\nThe mapping from the face of the cube to the sphere is done via the CubedSphere.jl package.\n\nPositional arguments\n\narchitecture: Specifies whether arrays of coordinates and spacings are stored                 on the CPU or GPU. Default: CPU().\nFT : Floating point data type. Default: Float64.\n\nKeyword arguments\n\nsize (required): A 3-tuple prescribing the number of grid points each direction.\nz (required): Either a\n2-tuple that specify the end points of the z-domain,\none-dimensional array specifying the cell interface locations, or\na single-argument function that takes an index and returns cell interface location.\nradius: The radius of the sphere the grid lives on. By default this is equal to the radius of Earth.\nhalo: A 3-tuple of integers specifying the size of the halo region of cells surrounding         the physical interior. The default is 1 halo cells in every direction.\nrotation :: Rotation: Rotation of the conformal cubed sphere panel about some axis that passes                         through the center of the sphere. If nothing is provided (default), then                         the panel includes the North Pole of the sphere in its center. For example,                         to construct a grid that includes tha South Pole we can pass either                         rotation = RotX(π) or rotation = RotY(π).\n\nExamples\n\nThe default conformal cubed sphere panel grid with Float64 type:\n\njulia> using Oceananigans, Oceananigans.Grids\n\njulia> grid = conformal_cubed_sphere_panel(size=(36, 34, 25), z=(-1000, 0))\n36×34×25 OrthogonalSphericalShellGrid{Float64, Bounded, Bounded, Bounded} on CPU with 1×1×1 halo and with precomputed metrics\n├── centered at: North Pole, (λ, φ) = (0.0, 90.0)\n├── longitude: Bounded  extent 90.0 degrees variably spaced with min(Δλ)=0.616164, max(Δλ)=2.58892\n├── latitude:  Bounded  extent 90.0 degrees variably spaced with min(Δφ)=0.664958, max(Δφ)=2.74119\n└── z:         Bounded  z ∈ [-1000.0, 0.0]  regularly spaced with Δz=40.0\n\nThe conformal cubed sphere panel that includes the South Pole with Float32 type:\n\njulia> using Oceananigans, Oceananigans.Grids, Rotations\n\njulia> grid = conformal_cubed_sphere_panel(Float32, size=(36, 34, 25), z=(-1000, 0), rotation=RotY(π))\n36×34×25 OrthogonalSphericalShellGrid{Float32, Bounded, Bounded, Bounded} on CPU with 1×1×1 halo and with precomputed metrics\n├── centered at: South Pole, (λ, φ) = (0.0, -90.0)\n├── longitude: Bounded  extent 90.0 degrees variably spaced with min(Δλ)=0.616167, max(Δλ)=2.58891\n├── latitude:  Bounded  extent 90.0 degrees variably spaced with min(Δφ)=0.664956, max(Δφ)=2.7412\n└── z:         Bounded  z ∈ [-1000.0, 0.0]  regularly spaced with Δz=40.0\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.Grids.halo_size-Tuple{Any}","page":"Library","title":"Oceananigans.Grids.halo_size","text":"halo_size(grid)\n\nReturn a 3-tuple with the number of halo cells on either side of the domain in (x, y, z).\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.minimum_xspacing-NTuple{4, Any}","page":"Library","title":"Oceananigans.Grids.minimum_xspacing","text":"minimum_xspacing(grid, ℓx, ℓy, ℓz)\nminimum_xspacing(grid) = minimum_xspacing(grid, Center(), Center(), Center())\n\nReturn the minimum spacing for grid in x direction at location ℓx, ℓy, ℓz.\n\nExamples\n\njulia> using Oceananigans\n\njulia> grid = RectilinearGrid(size=(2, 4, 8), extent=(1, 1, 1));\n\njulia> minimum_xspacing(grid, Center(), Center(), Center())\n0.5\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.minimum_yspacing-NTuple{4, Any}","page":"Library","title":"Oceananigans.Grids.minimum_yspacing","text":"minimum_yspacing(grid, ℓx, ℓy, ℓz)\nminimum_yspacing(grid) = minimum_yspacing(grid, Center(), Center(), Center())\n\nReturn the minimum spacing for grid in y direction at location ℓx, ℓy, ℓz.\n\nExamples\n\njulia> using Oceananigans\n\njulia> grid = RectilinearGrid(size=(2, 4, 8), extent=(1, 1, 1));\n\njulia> minimum_yspacing(grid, Center(), Center(), Center())\n0.25\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.minimum_zspacing-NTuple{4, Any}","page":"Library","title":"Oceananigans.Grids.minimum_zspacing","text":"minimum_zspacing(grid, ℓx, ℓy, ℓz)\nminimum_zspacing(grid) = minimum_zspacing(grid, Center(), Center(), Center())\n\nReturn the minimum spacing for grid in z direction at location ℓx, ℓy, ℓz.\n\nExamples\n\njulia> using Oceananigans\n\njulia> grid = RectilinearGrid(size=(2, 4, 8), extent=(1, 1, 1));\n\njulia> minimum_zspacing(grid, Center(), Center(), Center())\n0.125\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.new_data","page":"Library","title":"Oceananigans.Grids.new_data","text":"new_data(FT, arch, loc, topo, sz, halo_sz, indices)\n\nReturn an OffsetArray of zeros of float type FT on architecture, with indices corresponding to a field on a grid of size(grid) and located at loc.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.Grids.nodes-Tuple{Oceananigans.Grids.AbstractGrid, Any}","page":"Library","title":"Oceananigans.Grids.nodes","text":"nodes(grid, (ℓx, ℓy, ℓz); reshape=false, with_halos=false)\nnodes(grid, ℓx, ℓy, ℓz; reshape=false, with_halos=false)\n\nReturn a 3-tuple of views over the interior nodes of the grid's native coordinates at the locations in loc=(ℓx, ℓy, ℓz) in x, y, z.\n\nIf reshape=true, the views are reshaped to 3D arrays with non-singleton dimensions 1, 2, 3 for x, y, z, respectively. These reshaped arrays can then be used in broadcast operations with 3D fields or arrays.\n\nFor RectilinearGrids the native coordinates are x, y, z; for curvilinear grids, like LatitudeLongitudeGrid or OrthogonalSphericalShellGrid the native coordinates are λ, φ, z.\n\nSee xnodes, ynodes, znodes, λnodes, and φnodes.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.offset_data","page":"Library","title":"Oceananigans.Grids.offset_data","text":"offset_data(underlying_data, grid::AbstractGrid, loc, indices=default_indices(length(loc)))\n\nReturn an OffsetArray that maps to underlying_data in memory, with offset indices appropriate for the data of a field on a grid of size(grid) and located at loc.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.Grids.topology-Tuple{Any, Any}","page":"Library","title":"Oceananigans.Grids.topology","text":"topology(grid, dim)\n\nReturn the topology of the grid for the dim-th dimension.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.topology-Union{Tuple{Oceananigans.Grids.AbstractGrid{FT, TX, TY, TZ}}, Tuple{TZ}, Tuple{TY}, Tuple{TX}, Tuple{FT}} where {FT, TX, TY, TZ}","page":"Library","title":"Oceananigans.Grids.topology","text":"topology(grid)\n\nReturn a tuple with the topology of the grid for each dimension.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.total_size","page":"Library","title":"Oceananigans.Grids.total_size","text":"total_size(grid, loc)\n\nReturn the \"total\" size of a grid at loc. This is a 3-tuple of integers corresponding to the number of grid points along x, y, z.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.Grids.xnodes-NTuple{4, Any}","page":"Library","title":"Oceananigans.Grids.xnodes","text":"xnodes(grid, ℓx, ℓy, ℓz, with_halos=false)\n\nReturn the positions over the interior nodes on grid in the x-direction for the location ℓx, ℓy, ℓz. For Bounded directions, Face nodes include the boundary points.\n\nSee znodes for examples.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.xspacings-NTuple{4, Any}","page":"Library","title":"Oceananigans.Grids.xspacings","text":"xspacings(grid, ℓx, ℓy, ℓz; with_halos=true)\n\nReturn the spacings over the interior nodes on grid in the x-direction for the location ℓx, ℓy, ℓz. For Bounded directions, Face nodes include the boundary points.\n\njulia> using Oceananigans\n\njulia> grid = LatitudeLongitudeGrid(size=(8, 15, 10), longitude=(-20, 60), latitude=(-10, 50), z=(-100, 0));\n\njulia> xspacings(grid, Center(), Face(), Center())\n16-element view(OffsetArray(::Vector{Float64}, -2:18), 1:16) with eltype Float64:\n      1.0950562585518518e6\n      1.1058578920188267e6\n      1.1112718969963323e6\n      1.1112718969963323e6\n      1.1058578920188267e6\n      1.0950562585518518e6\n      1.0789196210678827e6\n      1.0575265956426917e6\n      1.0309814069457315e6\n 999413.38046802\n 962976.3124613502\n 921847.720658409\n 876227.979424229\n 826339.3435524226\n 772424.8654621692\n 714747.2110712599\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.ynodes-NTuple{4, Any}","page":"Library","title":"Oceananigans.Grids.ynodes","text":"ynodes(grid, ℓx, ℓy, ℓz, with_halos=false)\n\nReturn the positions over the interior nodes on grid in the y-direction for the location ℓx, ℓy, ℓz. For Bounded directions, Face nodes include the boundary points.\n\nSee znodes for examples.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.yspacings-NTuple{4, Any}","page":"Library","title":"Oceananigans.Grids.yspacings","text":"yspacings(grid, ℓx, ℓy, ℓz; with_halos=true)\n\nReturn the spacings over the interior nodes on grid in the y-direction for the location ℓx, ℓy, ℓz. For Bounded directions, Face nodes include the boundary points.\n\njulia> using Oceananigans\n\njulia> grid = LatitudeLongitudeGrid(size=(20, 15, 10), longitude=(0, 20), latitude=(-15, 15), z=(-100, 0));\n\njulia> yspacings(grid, Center(), Center(), Center())\n222389.85328911748\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.znodes-NTuple{4, Any}","page":"Library","title":"Oceananigans.Grids.znodes","text":"znodes(grid, ℓx, ℓy, ℓz; with_halos=false)\n\nReturn the positions over the interior nodes on grid in the z-direction for the location ℓx, ℓy, ℓz. For Bounded directions, Face nodes include the boundary points.\n\njulia> using Oceananigans\n\njulia> horz_periodic_grid = RectilinearGrid(size=(3, 3, 3), extent=(2π, 2π, 1), halo=(1, 1, 1),\n                                            topology=(Periodic, Periodic, Bounded));\n\njulia> zC = znodes(horz_periodic_grid, Center())\n3-element view(OffsetArray(::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, 0:4), 1:3) with eltype Float64:\n -0.8333333333333334\n -0.5\n -0.16666666666666666\n\njulia> zC = znodes(horz_periodic_grid, Center(), Center(), Center())\n3-element view(OffsetArray(::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, 0:4), 1:3) with eltype Float64:\n -0.8333333333333334\n -0.5\n -0.16666666666666666\n\njulia> zC = znodes(horz_periodic_grid, Center(), Center(), Center(), with_halos=true)\n-1.1666666666666667:0.3333333333333333:0.16666666666666666 with indices 0:4\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.zspacings-NTuple{4, Any}","page":"Library","title":"Oceananigans.Grids.zspacings","text":"zspacings(grid, ℓx, ℓy, ℓz; with_halos=true)\n\nReturn the spacings over the interior nodes on grid in the z-direction for the location ℓx, ℓy, ℓz. For Bounded directions, Face nodes include the boundary points.\n\njulia> using Oceananigans\n\njulia> grid = LatitudeLongitudeGrid(size=(20, 15, 10), longitude=(0, 20), latitude=(-15, 15), z=(-100, 0));\n\njulia> zspacings(grid, Center(), Center(), Center())\n10.0\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.λnodes-Tuple{Oceananigans.Grids.AbstractCurvilinearGrid, Any, Any, Any}","page":"Library","title":"Oceananigans.Grids.λnodes","text":"λnodes(grid::AbstractCurvilinearGrid, ℓx, ℓy, ℓz, with_halos=false)\n\nReturn the positions over the interior nodes on a curvilinear grid in the λ-direction for the location ℓλ, ℓφ, ℓz. For Bounded directions, Face nodes include the boundary points.\n\nSee znodes for examples.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Grids.φnodes-Tuple{Oceananigans.Grids.AbstractCurvilinearGrid, Any, Any, Any}","page":"Library","title":"Oceananigans.Grids.φnodes","text":"φnodes(grid::AbstractCurvilinearGrid, ℓx, ℓy, ℓz, with_halos=false)\n\nReturn the positions over the interior nodes on a curvilinear grid in the φ-direction for the location ℓλ, ℓφ, ℓz. For Bounded directions, Face nodes include the boundary points.\n\nSee znodes for examples.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Immersed-boundaries","page":"Library","title":"Immersed boundaries","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.ImmersedBoundaries]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.ImmersedBoundaries.GridFittedBottom-Tuple{Any}","page":"Library","title":"Oceananigans.ImmersedBoundaries.GridFittedBottom","text":"GridFittedBottom(bottom_height, [immersed_condition=CenterImmersedCondition()])\n\nReturn a bottom immersed boundary.\n\nKeyword Arguments\n\nbottom_height: an array or function that gives the height of the                  bottom in absolute z coordinates.\nimmersed_condition: Determine whether the part of the domain that is                        immersed are all the cell centers that lie below                       bottom_height (CenterImmersedCondition(); default)                       or all the cell faces that lie below bottom_height                       (InterfaceImmersedCondition()). The only purpose of                       immersed_condition to allow GridFittedBottom and                       PartialCellBottom to have the same behavior when the                       minimum fractional cell height for partial cells is set                       to 0.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.ImmersedBoundaries.GridFittedBoundary","page":"Library","title":"Oceananigans.ImmersedBoundaries.GridFittedBoundary","text":"GridFittedBoundary(mask)\n\nReturn a immersed boundary with a three-dimensional mask.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.ImmersedBoundaries.ImmersedBoundaryCondition-Tuple{}","page":"Library","title":"Oceananigans.ImmersedBoundaries.ImmersedBoundaryCondition","text":"ImmersedBoundaryCondition(; interfaces...)\n\nReturn an ImmersedBoundaryCondition with conditions on individual cell interfaces ∈ (west, east, south, north, bottom, top) between the fluid and the immersed boundary.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.ImmersedBoundaries.ImmersedBoundaryGrid-Tuple{Any, GridFittedBottom}","page":"Library","title":"Oceananigans.ImmersedBoundaries.ImmersedBoundaryGrid","text":"ImmersedBoundaryGrid(grid, ib::GridFittedBottom)\n\nReturn a grid with GridFittedBottom immersed boundary (ib).\n\nComputes ib.bottom_height and wraps it in a Field.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.ImmersedBoundaries.PartialCellBottom-Tuple{Any}","page":"Library","title":"Oceananigans.ImmersedBoundaries.PartialCellBottom","text":"PartialCellBottom(bottom_height; minimum_fractional_cell_height=0.2)\n\nReturn PartialCellBottom representing an immersed boundary with \"partial\" bottom cells. That is, the height of the bottommost cell in each column is reduced to fit the provided bottom_height, which may be a Field, Array, or function of (x, y).\n\nThe height of partial bottom cells is greater than\n\nminimum_fractional_cell_height * Δz,\n\nwhere Δz is the original height of the bottom cell underlying grid.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Logger","page":"Library","title":"Logger","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Logger]\nPrivate = false\nPages   = [\"Logger.jl\"]","category":"page"},{"location":"appendix/library/#Oceananigans.Logger.OceananigansLogger","page":"Library","title":"Oceananigans.Logger.OceananigansLogger","text":"OceananigansLogger(stream::IO=stdout, level=Logging.Info; show_info_source=false)\n\nBased on Logging.SimpleLogger, it tries to log all messages in the following format:\n\n[yyyy/mm/dd HH:MM:SS.sss] log_level message [-@-> source_file:line_number]\n\nwhere the source of the message between the square brackets is included only if show_info_source=true or if the message is not an info level message.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Models","page":"Library","title":"Models","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Models]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.Models.seawater_density-NTuple{5, Any}","page":"Library","title":"Oceananigans.Models.seawater_density","text":"Return a KernelFunctionOperation to compute the in-situ seawater_density.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Models.seawater_density-Tuple{Union{HydrostaticFreeSurfaceModel, NonhydrostaticModel}}","page":"Library","title":"Oceananigans.Models.seawater_density","text":"seawater_density(model; temperature, salinity, geopotential_height)\n\nReturn a KernelFunctionOperation that computes the in-situ density of seawater with (gridded) temperature, salinity, and at geopotential_height. To compute the in-situ density, the 55 term polynomial approximation to the equation of state from Roquet et al. (2015) is used. By default the seawater_density extracts the geopotential height from the model to compute the in-situ density. To compute a potential density at some user chosen reference geopotential height, set geopotential_height to a constant for the density computation,\n\ngeopotential_height = 0 # sea-surface height\nσ₀ = seawater_density(model; geopotential_height)\n\nNote: seawater_density must be passed a BoussinesqEquationOfState to compute the density. See the relevant documentation for how to set SeawaterBuoyancy using a BoussinesqEquationOfState.\n\nExample\n\nCompute a density Field using the KernelFunctionOperation returned from seawater_density\n\njulia> using Oceananigans, SeawaterPolynomials.TEOS10\n\njulia> using Oceananigans.Models: seawater_density\n\njulia> grid = RectilinearGrid(size=100, z=(-1000, 0), topology=(Flat, Flat, Bounded))\n1×1×100 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo\n├── Flat x\n├── Flat y\n└── Bounded  z ∈ [-1000.0, 0.0] regularly spaced with Δz=10.0\n\njulia> tracers = (:T, :S)\n(:T, :S)\n\njulia> eos = TEOS10EquationOfState()\nBoussinesqEquationOfState{Float64}:\n    ├── seawater_polynomial: TEOS10SeawaterPolynomial{Float64}\n    └── reference_density: 1020.0\n\njulia> buoyancy = SeawaterBuoyancy(equation_of_state=eos)\nSeawaterBuoyancy{Float64}:\n├── gravitational_acceleration: 9.80665\n└── equation_of_state: BoussinesqEquationOfState{Float64}\n\njulia> model = NonhydrostaticModel(; grid, buoyancy, tracers)\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\n├── grid: 1×1×100 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo\n├── timestepper: RungeKutta3TimeStepper\n├── advection scheme: Centered reconstruction order 2\n├── tracers: (T, S)\n├── closure: Nothing\n├── buoyancy: SeawaterBuoyancy with g=9.80665 and BoussinesqEquationOfState{Float64} with ĝ = NegativeZDirection()\n└── coriolis: Nothing\n\njulia> set!(model, S = 34.7, T = 0.5)\n\njulia> density_operation = seawater_density(model)\nKernelFunctionOperation at (Center, Center, Center)\n├── grid: 1×1×100 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo\n├── kernel_function: ρ (generic function with 3 methods)\n└── arguments: (\"BoussinesqEquationOfState{Float64}\", \"1×1×100 Field{Center, Center, Center} on RectilinearGrid on CPU\", \"1×1×100 Field{Center, Center, Center} on RectilinearGrid on CPU\", \"KernelFunctionOperation at (Center, Center, Center)\")\n\njulia> density_field = Field(density_operation)\n1×1×100 Field{Center, Center, Center} on RectilinearGrid on CPU\n├── grid: 1×1×100 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo\n├── boundary conditions: FieldBoundaryConditions\n│   └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux\n├── operand: KernelFunctionOperation at (Center, Center, Center)\n├── status: time=0.0\n└── data: 1×1×106 OffsetArray(::Array{Float64, 3}, 1:1, 1:1, -2:103) with eltype Float64 with indices 1:1×1:1×-2:103\n    └── max=0.0, min=0.0, mean=0.0\n\njulia> compute!(density_field)\n1×1×100 Field{Center, Center, Center} on RectilinearGrid on CPU\n├── grid: 1×1×100 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo\n├── boundary conditions: FieldBoundaryConditions\n│   └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux\n├── operand: KernelFunctionOperation at (Center, Center, Center)\n├── status: time=0.0\n└── data: 1×1×106 OffsetArray(::Array{Float64, 3}, 1:1, 1:1, -2:103) with eltype Float64 with indices 1:1×1:1×-2:103\n    └── max=1032.38, min=1027.73, mean=1030.06\n\nValues for temperature, salinity and geopotential_height can be passed to seawater_density to override the defaults that are obtained from the model.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Non-hydrostatic-models","page":"Library","title":"Non-hydrostatic models","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Models.NonhydrostaticModels]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.Models.NonhydrostaticModels.NonhydrostaticModel-Tuple{}","page":"Library","title":"Oceananigans.Models.NonhydrostaticModels.NonhydrostaticModel","text":"NonhydrostaticModel(;           grid,\n                                clock = Clock{eltype(grid)}(time = 0),\n                            advection = CenteredSecondOrder(),\n                             buoyancy = nothing,\n                             coriolis = nothing,\n                         stokes_drift = nothing,\n                  forcing::NamedTuple = NamedTuple(),\n                              closure = nothing,\n      boundary_conditions::NamedTuple = NamedTuple(),\n                              tracers = (),\n                          timestepper = :RungeKutta3,\n        background_fields::NamedTuple = NamedTuple(),\n        particles::ParticlesOrNothing = nothing,\nbiogeochemistry::AbstractBGCOrNothing = nothing,\n                           velocities = nothing,\n              nonhydrostatic_pressure = CenterField(grid),\n         hydrostatic_pressure_anomaly = DefaultHydrostaticPressureAnomaly(),\n                   diffusivity_fields = nothing,\n                      pressure_solver = nothing,\n                     auxiliary_fields = NamedTuple())\n\nConstruct a model for a non-hydrostatic, incompressible fluid on grid, using the Boussinesq approximation when buoyancy != nothing. By default, all Bounded directions are rigid and impenetrable.\n\nKeyword arguments\n\ngrid: (required) The resolution and discrete geometry on which the model is solved. The         architecture (CPU/GPU) that the model is solved on is inferred from the architecture         of the grid. Note that the grid needs to be regularly spaced in the horizontal         dimensions, x and y.\nadvection: The scheme that advects velocities and tracers. See Oceananigans.Advection.\nbuoyancy: The buoyancy model. See Oceananigans.BuoyancyModels.\ncoriolis: Parameters for the background rotation rate of the model.\nstokes_drift: Parameters for Stokes drift fields associated with surface waves. Default: nothing.\nforcing: NamedTuple of user-defined forcing functions that contribute to solution tendencies.\nclosure: The turbulence closure for model. See Oceananigans.TurbulenceClosures.\nboundary_conditions: NamedTuple containing field boundary conditions.\ntracers: A tuple of symbols defining the names of the modeled tracers, or a NamedTuple of            preallocated CenterFields.\ntimestepper: A symbol that specifies the time-stepping method. Either :QuasiAdamsBashforth2 or                :RungeKutta3 (default).\nbackground_fields: NamedTuple with background fields (e.g., background flow). Default: nothing.\nparticles: Lagrangian particles to be advected with the flow. Default: nothing.\nbiogeochemistry: Biogeochemical model for tracers.\nvelocities: The model velocities. Default: nothing.\nnonhydrostatic_pressure: The nonhydrostatic pressure field. Default: CenterField(grid).\nhydrostatic_pressure_anomaly: An optional field that stores the part of the nonhydrostatic pressure                                 in hydrostatic balance with the buoyancy field. If CenterField(grid) (default), the anomaly is precomputed by                                 vertically integrating the buoyancy field. In this case, the nonhydrostatic_pressure represents                                 only the part of pressure that deviates from the hydrostatic anomaly. If nothing, the anomaly                                 is not computed. \ndiffusivity_fields: Diffusivity fields. Default: nothing.\npressure_solver: Pressure solver to be used in the model. If nothing (default), the model constructor chooses the default based on the grid provide.\nauxiliary_fields: NamedTuple of auxiliary fields. Default: nothing         \n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Hydrostatic-free-surface-models","page":"Library","title":"Hydrostatic free-surface models","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Models.HydrostaticFreeSurfaceModels]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.Models.HydrostaticFreeSurfaceModels.ExplicitFreeSurface","page":"Library","title":"Oceananigans.Models.HydrostaticFreeSurfaceModels.ExplicitFreeSurface","text":"struct ExplicitFreeSurface{E, T}\n\nThe explicit free surface solver.\n\nη::Any: free surface elevation\ngravitational_acceleration::Any: gravitational accelerations\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Models.HydrostaticFreeSurfaceModels.HydrostaticFreeSurfaceModel-Tuple{}","page":"Library","title":"Oceananigans.Models.HydrostaticFreeSurfaceModels.HydrostaticFreeSurfaceModel","text":"HydrostaticFreeSurfaceModel(; grid,\n                            clock = Clock{eltype(grid)}(time = 0),\n               momentum_advection = VectorInvariant(),\n                 tracer_advection = CenteredSecondOrder(),\n                         buoyancy = SeawaterBuoyancy(eltype(grid)),\n                         coriolis = nothing,\n                     free_surface = default_free_surface(grid, gravitational_acceleration=g_Earth),\n              forcing::NamedTuple = NamedTuple(),\n                          closure = nothing,\n  boundary_conditions::NamedTuple = NamedTuple(),\n                          tracers = (:T, :S),\n    particles::ParticlesOrNothing = nothing,\n\nbiogeochemistry::AbstractBGCOrNothing = nothing,                            velocities = nothing,                              pressure = nothing,                    diffusivityfields = nothing,                      auxiliaryfields = NamedTuple(),     )\n\nConstruct a hydrostatic model with a free surface on grid.\n\nKeyword arguments\n\ngrid: (required) The resolution and discrete geometry on which model is solved. The         architecture (CPU/GPU) that the model is solved is inferred from the architecture         of the grid.\nmomentum_advection: The scheme that advects velocities. See Oceananigans.Advection.\ntracer_advection: The scheme that advects tracers. See Oceananigans.Advection.\nbuoyancy: The buoyancy model. See Oceananigans.BuoyancyModels.\ncoriolis: Parameters for the background rotation rate of the model.\nfree_surface: The free surface model. The default free-surface solver depends on the                 geometry of the grid. If the grid is a RectilinearGrid that is                 regularly spaced in the horizontal the default is an ImplicitFreeSurface                 solver with solver_method = :FFTBasedPoissonSolver. In all other cases,                 the default is a SplitExplicitFreeSurface.\ntracers: A tuple of symbols defining the names of the modeled tracers, or a NamedTuple of            preallocated CenterFields.\nforcing: NamedTuple of user-defined forcing functions that contribute to solution tendencies.\nclosure: The turbulence closure for model. See Oceananigans.TurbulenceClosures.\nboundary_conditions: NamedTuple containing field boundary conditions.\nparticles: Lagrangian particles to be advected with the flow. Default: nothing.\nbiogeochemistry: Biogeochemical model for tracers.\nvelocities: The model velocities. Default: nothing.\npressure: Hydrostatic pressure field. Default: nothing.\ndiffusivity_fields: Diffusivity fields. Default: nothing.\nauxiliary_fields: NamedTuple of auxiliary fields. Default: nothing.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Models.HydrostaticFreeSurfaceModels.ImplicitFreeSurface-Tuple{}","page":"Library","title":"Oceananigans.Models.HydrostaticFreeSurfaceModels.ImplicitFreeSurface","text":"ImplicitFreeSurface(; solver_method=:Default, gravitational_acceleration=g_Earth, solver_settings...)\n\nReturn an implicit free-surface solver. The implicit free-surface equation is\n\nleft  _h  (H _h) - frac1g Δt^2 right  η^n+1 = frac_h  𝐐_g Δt - fracη^ng Δt^2 \n\nwhere η^n is the free-surface elevation at the n-th time step, H is depth, g is the gravitational acceleration, Δt is the time step, _h is the horizontal gradient operator, and 𝐐_ is the barotropic volume flux associated with the predictor velocity field 𝐮_, i.e., \n\n𝐐_ = int_-H^0 𝐮_  𝖽 z \n\nwhere \n\n𝐮_ = 𝐮^n + int_t_n^t_n+1 𝐆ᵤ  𝖽t \n\nThis equation can be solved, in general, using the ConjugateGradientSolver but  other solvers can be invoked in special cases.\n\nIf H is constant, we divide through out to obtain\n\nleft ( ^2_h - frac1g H Δt^2 right ) η^n+1  = frac1g H Δt left ( _h  𝐐_ - fracη^nΔt right ) \n\nThus, for constant H and on grids with regular spacing in x and y directions, the free surface can be obtained using the FFTBasedPoissonSolver.\n\nsolver_method can be either of:\n\n:FastFourierTransform for FFTBasedPoissonSolver\n:HeptadiagonalIterativeSolver  for HeptadiagonalIterativeSolver\n:PreconditionedConjugateGradient for ConjugateGradientSolver\n\nBy default, if the grid has regular spacing in the horizontal directions then the :FastFourierTransform is chosen, otherwise the :HeptadiagonalIterativeSolver.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Models.HydrostaticFreeSurfaceModels.PrescribedVelocityFields-Tuple{}","page":"Library","title":"Oceananigans.Models.HydrostaticFreeSurfaceModels.PrescribedVelocityFields","text":"PrescribedVelocityFields(; u = ZeroField(),\n                           v = ZeroField(),\n                           w = ZeroField(),\n                           parameters = nothing)\n\nBuilds PrescribedVelocityFields with prescribed functions u, v, and w.\n\nIf isnothing(parameters), then u, v, w are called with the signature\n\nu(x, y, z, t) = # something interesting\n\nIf !isnothing(parameters), then u, v, w are called with the signature\n\nu(x, y, z, t, parameters) = # something parameterized and interesting\n\nIn the constructor for HydrostaticFreeSurfaceModel, the functions u, v, w are wrapped in FunctionField and associated with the model's grid and clock.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurface","page":"Library","title":"Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurface","text":"SplitExplicitFreeSurface(grid = nothing;\n                         gravitational_acceleration = g_Earth,\n                         substeps = nothing,\n                         cfl = nothing,\n                         fixed_Δt = nothing,\n                         averaging_kernel = averaging_shape_function,\n                         timestepper = ForwardBackwardScheme())\n\nReturn a SplitExplicitFreeSurface representing an explicit time discretization of a free surface dynamics with gravitational_acceleration.\n\nKeyword Arguments\n\ngravitational_acceleration: the gravitational acceleration (default: g_Earth)\nsubsteps: The number of substeps that divide the range (t, t + 2Δt), where Δt is the baroclinic             timestep. Note that some averaging functions do not require substepping until 2Δt.             The number of substeps is reduced automatically to the last index of averaging_kernel             for which averaging_kernel > 0.\ncfl: If set then the number of substeps are computed based on the advective timescale imposed from        the barotropic gravity-wave speed that corresponds to depth grid.Lz. If fixed_Δt is provided,        then the number of substeps adapts to maintain an exact cfl. If not, the effective cfl will        always be lower than the specified cfl provided that the baroclinic time step satisfies        Δt_baroclinic < fixed_Δt.\n\ninfo: Needed keyword arguments\nEither substeps or cfl need to be prescribed.When cfl is prescribed then grid is also required as a positional argument.\n\nfixed_Δt: The maximum baroclinic timestep allowed. If fixed_Δt is a nothing and a cfl is provided,             then the number of substeps will be computed on the fly from the baroclinic time step to             maintain a constant cfl.\naveraging_kernel: A function of τ used to average the barotropic transport U and the free surface                     η within the barotropic advancement. τ is the fractional substep going from 0 to 2                     with the baroclinic time step t + Δt located at τ = 1. The averaging_kernel                     function should be centered at τ = 1, that is,  (aₘ m  M) = 1, where the                     the summation occurs for m = 1  M_*. Here, m = 0 and m = M correspond                     to the two consecutive baroclinic timesteps between which the barotropic timestepping                     occurs and M_* corresponds to the last barotropic time step for which the                     averaging_kernel > 0. By default, the averaging kernel described by Shchepetkin and McWilliams (2005)                     is used.\ntimestepper: Time stepping scheme used for the barotropic advancement. Choose one of:\nForwardBackwardScheme() (default): η = f(U)   then U = f(η),\nAdamsBashforth3Scheme(): η = f(U, Uᵐ⁻¹, Uᵐ⁻²) then U = f(η, ηᵐ, ηᵐ⁻¹, ηᵐ⁻²).\n\nReferences\n\nShchepetkin, A. F., & McWilliams, J. C. (2005). The regional oceanic modeling system (ROMS): a split-explicit, free-surface, topography-following-coordinate oceanic model. Ocean Modelling, 9(4), 347-404.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurface-2","page":"Library","title":"Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurface","text":"struct SplitExplicitFreeSurface\n\nThe split-explicit free surface solver.\n\nη: The instantaneous free surface (ReducedField)\nstate: The entire state for the split-explicit solver (SplitExplicitState)\nauxiliary: Parameters for timestepping split-explicit solver (NamedTuple)\ngravitational_acceleration: Gravitational acceleration\nsettings: Settings for the split-explicit scheme\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Shallow-water-models","page":"Library","title":"Shallow-water models","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Models.ShallowWaterModels]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.Models.ShallowWaterModels.ShallowWaterModel-Tuple{}","page":"Library","title":"Oceananigans.Models.ShallowWaterModels.ShallowWaterModel","text":"ShallowWaterModel(; grid,\n                    gravitational_acceleration,\n                          clock = Clock{eltype(grid)}(time = 0),\n             momentum_advection = UpwindBiasedFifthOrder(),\n               tracer_advection = WENO(),\n                 mass_advection = WENO(),\n                       coriolis = nothing,\n            forcing::NamedTuple = NamedTuple(),\n                        closure = nothing,\n                     bathymetry = nothing,\n                        tracers = (),\n             diffusivity_fields = nothing,\nboundary_conditions::NamedTuple = NamedTuple(),\n            timestepper::Symbol = :RungeKutta3,\n                    formulation = ConservativeFormulation())\n\nConstruct a shallow water model on grid with gravitational_acceleration constant.\n\nKeyword arguments\n\ngrid: (required) The resolution and discrete geometry on which model is solved. The         architecture (CPU/GPU) that the model is solve is inferred from the architecture         of the grid.\ngravitational_acceleration: (required) The gravitational acceleration constant.\nclock: The clock for the model.\nmomentum_advection: The scheme that advects velocities. See Oceananigans.Advection. Default: UpwindBiasedFifthOrder().\ntracer_advection: The scheme that advects tracers. See Oceananigans.Advection. Default: WENO().\nmass_advection: The scheme that advects the mass equation. See Oceananigans.Advection. Default: WENO().\ncoriolis: Parameters for the background rotation rate of the model.\nforcing: NamedTuple of user-defined forcing functions that contribute to solution tendencies.\nclosure: The turbulence closure for model. See Oceananigans.TurbulenceClosures.\nbathymetry: The bottom bathymetry.\ntracers: A tuple of symbols defining the names of the modeled tracers, or a NamedTuple of            preallocated CenterFields.\ndiffusivity_fields: Stores diffusivity fields when the closures require a diffusivity to be                       calculated at each timestep.\nboundary_conditions: NamedTuple containing field boundary conditions.\ntimestepper: A symbol that specifies the time-stepping method. Either :QuasiAdamsBashforth2 or                :RungeKutta3 (default).\nformulation: Whether the dynamics are expressed in conservative form (ConservativeFormulation();                default) or in non-conservative form with a vector-invariant formulation for the                non-linear terms (VectorInvariantFormulation()).\n\nwarning: Formulation-grid compatibility requirements\nThe ConservativeFormulation() requires RectilinearGrid. Use VectorInvariantFormulation() with LatitudeLongitudeGrid.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Models.ShallowWaterModels.ShallowWaterScalarDiffusivity","page":"Library","title":"Oceananigans.Models.ShallowWaterModels.ShallowWaterScalarDiffusivity","text":"ShallowWaterScalarDiffusivity([FT::DataType=Float64;]\n                              ν=0, ξ=0, discrete_form=false)\n\nReturn a scalar diffusivity for the shallow water model.\n\nThe diffusivity for the shallow water model is calculated as h * ν so that we get a viscous term in the form h^-1   (h ν t), where t is the 2D stress tensor plus a trace, i.e., t = 𝐮 + (𝐮)^T - ξ I  (  𝐮).\n\nWith the VectorInvariantFormulation() (that evolves u and v) we compute h^-1 (ν h  t), while with the ConservativeFormulation() (that evolves u h and v h) we compute  (ν h  t).\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Lagrangian-particle-tracking","page":"Library","title":"Lagrangian particle tracking","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Models.LagrangianParticleTracking]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.Models.LagrangianParticleTracking.LagrangianParticles-Tuple{StructArrays.StructArray}","page":"Library","title":"Oceananigans.Models.LagrangianParticleTracking.LagrangianParticles","text":"LagrangianParticles(particles::StructArray; restitution=1.0, tracked_fields::NamedTuple=NamedTuple(), dynamics=no_dynamics)\n\nConstruct some LagrangianParticles that can be passed to a model. The particles should be a StructArray and can contain custom fields. The coefficient of restitution for particle-wall collisions is specified by restitution.\n\nA number of tracked_fields may be passed in as a NamedTuple of fields. Each particle will track the value of each field. Each tracked field must have a corresponding particle property. So if T is a tracked field, then T must also be a custom particle property.\n\ndynamics is a function of (lagrangian_particles, model, Δt) that is called prior to advecting particles. parameters can be accessed inside the dynamics function.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Models.LagrangianParticleTracking.LagrangianParticles-Tuple{}","page":"Library","title":"Oceananigans.Models.LagrangianParticleTracking.LagrangianParticles","text":"LagrangianParticles(; x, y, z, restitution=1.0, dynamics=no_dynamics, parameters=nothing)\n\nConstruct some LagrangianParticles that can be passed to a model. The particles will have initial locations x, y, and z. The coefficient of restitution for particle-wall collisions is specified by restitution.\n\ndynamics is a function of (lagrangian_particles, model, Δt) that is called prior to advecting particles. parameters can be accessed inside the dynamics function.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#MultiRegion","page":"Library","title":"MultiRegion","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.MultiRegion]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.MultiRegion.ConformalCubedSphereGrid","page":"Library","title":"Oceananigans.MultiRegion.ConformalCubedSphereGrid","text":"ConformalCubedSphereGrid(filepath::AbstractString, arch::AbstractArchitecture=CPU(), FT=Float64;\n                         Nz,\n                         z,\n                         panel_halo = (4, 4, 4),\n                         panel_topology = (FullyConnected, FullyConnected, Bounded),\n                         radius = R_Earth,\n                         devices = nothing)\n\nLoad a ConformalCubedSphereGrid from filepath.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.MultiRegion.ConformalCubedSphereGrid-2","page":"Library","title":"Oceananigans.MultiRegion.ConformalCubedSphereGrid","text":"ConformalCubedSphereGrid(arch=CPU(), FT=Float64;\n                         panel_size,\n                         z,\n                         horizontal_direction_halo = 1,\n                         z_halo = horizontal_direction_halo,\n                         horizontal_topology = FullyConnected,\n                         z_topology = Bounded,\n                         radius = R_Earth,\n                         partition = CubedSpherePartition(; R = 1),\n                         devices = nothing)\n\nReturn a ConformalCubedSphereGrid that comprises of six conformal_cubed_sphere_panel grids; we refer to each of these grids as a \"panel\". Each panel corresponds to a face of the cube.\n\nThe keyword arguments prescribe the properties of each of the panels. Only the topology in the vertical direction can be prescribed and that's done via the z_topology keyword argumet (default: Bounded). Topologies in both horizontal directions for a ConformalCubedSphereGrid are always FullyConnected.\n\nHalo size in both horizontal dimensions must be equal; this is prescribed via the horizontal_halo :: Integer keyword argument. The number of halo points in the z-direction is prescribed by the z_halo :: Integer keyword argument.\n\nThe connectivity between the ConformalCubedSphereGrid panels is depicted below.\n\n                          +==========+==========+\n                          ∥    ↑     ∥    ↑     ∥\n                          ∥    1W    ∥    1S    ∥\n                          ∥←3N P5 6W→∥←5E P6 2S→∥\n                          ∥    4N    ∥    4E    ∥\n                          ∥    ↓     ∥    ↓     ∥\n               +==========+==========+==========+\n               ∥    ↑     ∥    ↑     ∥\n               ∥    5W    ∥    5S    ∥\n               ∥←1N P3 4W→∥←3E P4 6S→∥\n               ∥    2N    ∥    2E    ∥\n               ∥    ↓     ∥    ↓     ∥\n    +==========+==========+==========+\n    ∥    ↑     ∥    ↑     ∥\n    ∥    3W    ∥    3S    ∥\n    ∥←5N P1 2W→∥←1E P2 4S→∥\n    ∥    6N    ∥    6E    ∥\n    ∥    ↓     ∥    ↓     ∥\n    +==========+==========+\n\nThe North Pole of the sphere lies in the center of panel 3 (P3) and the South Pole in the center of panel 6 (P6).\n\nThe partition keyword argument prescribes the partitioning in regions within each  panel; see CubedSpherePartition. For example, a CubedSpherePartition(; R=2) implies that each of the panels are partitioned into 2 regions in each dimension; this adds up, e.g., to 24 regions for the  whole sphere. In the depiction below, the intra-panel x, y indices are depicted in the center of each region and the overall region index is shown at the bottom right of each region.\n\n                                                +==========+==========+==========+==========+\n                                                ∥    ↑     |    ↑     ∥    ↑     |    ↑     ∥\n                                                ∥          |          ∥          |          ∥\n                                                ∥← (1, 2) →|← (2, 2) →∥← (1, 2) →|← (2, 2) →∥\n                                                ∥          |          ∥          |          ∥\n                                                ∥    ↓  19 |    ↓  20 ∥    ↓  23 |    ↓  24 ∥\n                                                +-------- P 5 --------+-------- P 6 --------+\n                                                ∥    ↑     |    ↑     ∥    ↑     |    ↑     ∥\n                                                ∥          |          ∥          |          ∥\n                                                ∥← (1, 1) →|← (2, 1) →∥← (1, 1) →|← (2, 1) →∥\n                                                ∥          |          ∥          |          ∥\n                                                ∥    ↓  17 |    ↓  18 ∥    ↓  21 |    ↓  22 ∥\n                          +==========+==========+==========+==========+==========+==========+\n                          ∥    ↑     |    ↑     ∥    ↑     |    ↑     ∥\n                          ∥          |          ∥          |          ∥\n                          ∥← (1, 2) →|← (2, 2) →∥← (1, 2) →|← (2, 2) →∥\n                          ∥          |          ∥          |          ∥\n                          ∥    ↓ 11  |    ↓  12 ∥    ↓  15 |    ↓  16 ∥\n                          +-------- P 3 --------+-------- P 4 --------+\n                          ∥    ↑     |    ↑     ∥    ↑     |    ↑     ∥\n                          ∥          |          ∥          |          ∥\n                          ∥← (1, 1) →|← (2, 1) →∥← (1, 1) →|← (2, 1) →∥\n                          ∥          |          ∥          |          ∥\n                          ∥    ↓  9  |    ↓  10 ∥    ↓  13 |    ↓  14 ∥\n    +==========+==========+==========+==========+==========+==========+\n    ∥    ↑     |    ↑     ∥    ↑     |    ↑     ∥\n    ∥          |          ∥          |          ∥\n    ∥← (1, 2) →|← (2, 2) →∥← (1, 2) →|← (2, 2) →∥\n    ∥          |          ∥          |          ∥\n    ∥    ↓   3 |    ↓   4 ∥    ↓   7 |    ↓   8 ∥\n    +-------- P 1 --------+-------- P 2 --------+\n    ∥    ↑     |    ↑     ∥    ↑     |    ↑     ∥\n    ∥          |          ∥          |          ∥\n    ∥← (1, 1) →|← (2, 1) →∥← (1, 1) →|← (2, 1) →∥\n    ∥          |          ∥          |          ∥\n    ∥    ↓   1 |    ↓   2 ∥    ↓   5 |    ↓   6 ∥\n    +==========+==========+==========+==========+\n\nBelow, we show in detail panels 1 and 2 and the connectivity of each panel.\n\n+===============+==============+==============+===============+\n∥       ↑       |      ↑       ∥      ↑       |      ↑        ∥\n∥      11W      |      9W      ∥      9S      |     10S       ∥\n∥←19N (2, 1) 4W→|←3E (2, 2) 7W→∥←4E (2, 1) 8W→|←7E (2, 2) 13S→∥\n∥       1N      |      2N      ∥      5N      |      6N       ∥\n∥       ↓     3 |      ↓     4 ∥      ↓     7 |      ↓      8 ∥\n+------------- P 1 ------------+------------ P 2 -------------+\n∥       ↑       |      ↑       ∥      ↑       |      ↑        ∥\n∥       3S      |      4S      ∥      7S      |      8S       ∥\n∥←20N (1, 1) 2W→|←1E (2, 1) 5W→∥←2E (1, 1) 6W→|←5E (2, 1) 14S→∥\n∥      23N      |     24N      ∥     24N      |     22N       ∥\n∥       ↓     1 |      ↓     2 ∥      ↓     5 |      ↓      6 ∥\n+===============+==============+==============+===============+\n\nExample\n\njulia> using Oceananigans\n\njulia> grid = ConformalCubedSphereGrid(panel_size=(12, 12, 1), z=(-1, 0), radius=1)\nConformalCubedSphereGrid{Float64, FullyConnected, FullyConnected, Bounded} partitioned on CPU(): \n├── grids: 12×12×1 OrthogonalSphericalShellGrid{Float64, FullyConnected, FullyConnected, Bounded} on CPU with 3×3×3 halo and with precomputed metrics \n├── partitioning: CubedSpherePartition with (1 region in each panel) \n├── connectivity: CubedSphereConnectivity \n└── devices: (CPU(), CPU(), CPU(), CPU(), CPU(), CPU())\n\nThe connectivities of the regions of our grid are stored in grid.connectivity. For example, to find out all connectivites on the South boundary of each region we call\n\njulia> using Oceananigans.MultiRegion: East, North, West, South\n\njulia> for region in 1:length(grid); println(grid.connectivity.connections[region].south); end\nCubedSphereRegionalConnectivity\n├── from: Oceananigans.MultiRegion.North side, region 6\n├── to:   Oceananigans.MultiRegion.South side, region 1\n└── no rotation\nCubedSphereRegionalConnectivity\n├── from: Oceananigans.MultiRegion.East side, region 6\n├── to:   Oceananigans.MultiRegion.South side, region 2\n└── counter-clockwise rotation ↺\nCubedSphereRegionalConnectivity\n├── from: Oceananigans.MultiRegion.North side, region 2\n├── to:   Oceananigans.MultiRegion.South side, region 3\n└── no rotation\nCubedSphereRegionalConnectivity\n├── from: Oceananigans.MultiRegion.East side, region 2\n├── to:   Oceananigans.MultiRegion.South side, region 4\n└── counter-clockwise rotation ↺\nCubedSphereRegionalConnectivity\n├── from: Oceananigans.MultiRegion.North side, region 4\n├── to:   Oceananigans.MultiRegion.South side, region 5\n└── no rotation\nCubedSphereRegionalConnectivity\n├── from: Oceananigans.MultiRegion.East side, region 4\n├── to:   Oceananigans.MultiRegion.South side, region 6\n└── counter-clockwise rotation ↺\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.MultiRegion.CubedSpherePartition-Tuple{}","page":"Library","title":"Oceananigans.MultiRegion.CubedSpherePartition","text":"CubedSpherePartition(; R = 1)\n\nReturn a cubed sphere partition with R partitions in each horizontal dimension of each panel of the sphere.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.MultiRegion.MultiRegionGrid-Tuple{Any}","page":"Library","title":"Oceananigans.MultiRegion.MultiRegionGrid","text":"MultiRegionGrid(global_grid; partition = XPartition(2),\n                             devices = nothing,\n                             validate = true)\n\nSplit a global_grid into different regions handled by devices.\n\nPositional Arguments\n\nglobal_grid: the grid to be divided into regions.\n\nKeyword Arguments\n\npartition: the partitioning required. The implemented partitioning are XPartition               (division along the x direction) and YPartition (division along              the y direction).\ndevices: the devices to allocate memory on. If nothing is provided (default) then memorey is            allocated on the the CPU. For GPU computation it is possible to specify the total            number of GPUs or the specific GPUs to allocate memory on. The number of devices does            not need to match the number of regions.\nvalidate :: Boolean: Whether to validate devices; defautl: true.\n\nExample\n\njulia> using Oceananigans\n\njulia> grid = RectilinearGrid(size=(12, 12), extent=(1, 1), topology=(Bounded, Bounded, Flat))\n12×12×1 RectilinearGrid{Float64, Bounded, Bounded, Flat} on CPU with 3×3×0 halo\n├── Bounded  x ∈ [0.0, 1.0] regularly spaced with Δx=0.0833333\n├── Bounded  y ∈ [0.0, 1.0] regularly spaced with Δy=0.0833333\n└── Flat z\n\njulia> multi_region_grid = MultiRegionGrid(grid, partition = XPartition(4))\n┌ Warning: MultiRegion functionalities are experimental: help the development by reporting bugs or non-implemented features!\n└ @ Oceananigans.MultiRegion ~/Research/OC11.jl/src/MultiRegion/multi_region_grid.jl:108\nMultiRegionGrid{Float64, Bounded, Bounded, Flat} partitioned on CPU():\n├── grids: 3×12×1 RectilinearGrid{Float64, RightConnected, Bounded, Flat} on CPU with 3×3×0 halo\n├── partitioning: Equal partitioning in X with (4 regions)\n├── connectivity: MultiRegionObject{Tuple{@NamedTuple{west::Nothing, east::Oceananigans.MultiRegion.RegionalConnectivity{Oceananigans.MultiRegion.East, Oceananigans.MultiRegion.West}, north::Nothing, south::Nothing}, @NamedTuple{west::Oceananigans.MultiRegion.RegionalConnectivity{Oceananigans.MultiRegion.West, Oceananigans.MultiRegion.East}, east::Oceananigans.MultiRegion.RegionalConnectivity{Oceananigans.MultiRegion.East, Oceananigans.MultiRegion.West}, north::Nothing, south::Nothing}, @NamedTuple{west::Oceananigans.MultiRegion.RegionalConnectivity{Oceananigans.MultiRegion.West, Oceananigans.MultiRegion.East}, east::Oceananigans.MultiRegion.RegionalConnectivity{Oceananigans.MultiRegion.East, Oceananigans.MultiRegion.West}, north::Nothing, south::Nothing}, @NamedTuple{west::Oceananigans.MultiRegion.RegionalConnectivity{Oceananigans.MultiRegion.West, Oceananigans.MultiRegion.East}, east::Nothing, north::Nothing, south::Nothing}}, NTuple{4, CPU}}\n└── devices: (CPU(), CPU(), CPU(), CPU())\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Operators","page":"Library","title":"Operators","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Operators]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.Operators.divᶜᶜᶜ-NTuple{7, Any}","page":"Library","title":"Oceananigans.Operators.divᶜᶜᶜ","text":"divᶜᶜᶜ(i, j, k, grid, u, v, w)\n\nCalculate the divergence 𝐕 of a vector field 𝐕 = (u v w),\n\n1/V * [δxᶜᵃᵃ(Ax * u) + δxᵃᶜᵃ(Ay * v) + δzᵃᵃᶜ(Az * w)]\n\nwhich ends up at the cell centers ccc.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Operators.extrinsic_vector-Tuple{Any, Any, Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any}","page":"Library","title":"Oceananigans.Operators.extrinsic_vector","text":"extrinsic_vector(i, j, k, grid::AbstractGrid, uᵢ, vᵢ, wᵢ)\n\nConvert the three-dimensional vector with components uᵢ, vᵢ, wᵢ defined on the intrinsic coordinate system of the grid, to the extrinsic coordinate system associated with the domain.\n\nextrinsic coordinate systems are:\n\nCartesian for any grid that discretizes a Cartesian domain (e.g. a RectilinearGrid)\nGeographic coordinates for any grid that discretizes a Spherical domain (e.g. an AbstractCurvilinearGrid)\n\nTherefore, for the RectilinearGrid and the LatitudeLongitudeGrid, the extrinsic and the  intrinsic coordinate systems are equivalent. However, for other grids (e.g., for the  ConformalCubedSphereGrid) that might not be the case.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Operators.intrinsic_vector-Tuple{Any, Any, Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any}","page":"Library","title":"Oceananigans.Operators.intrinsic_vector","text":"intrinsic_vector(i, j, k, grid::AbstractGrid, uₑ, vₑ, wₑ)\n\nConvert the three-dimensional vector with components uₑ, vₑ, wₑ defined in an extrinsic  coordinate system associated with the domain, to the coordinate system intrinsic to the grid.\n\nextrinsic coordinate systems are:\n\nCartesian for any grid that discretizes a Cartesian domain (e.g. a RectilinearGrid)\nGeographic coordinates for any grid that discretizes a Spherical domain (e.g. an AbstractCurvilinearGrid)\n\nTherefore, for the RectilinearGrid and the LatitudeLongitudeGrid, the extrinsic and the  intrinsic coordinate system are equivalent. However, for other grids (e.g., for the  ConformalCubedSphereGrid) that might not be the case.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Operators.ζ₃ᶠᶠᶜ-NTuple{6, Any}","page":"Library","title":"Oceananigans.Operators.ζ₃ᶠᶠᶜ","text":"ζ₃ᶠᶠᶜ(i, j, k, grid, u, v)\n\nThe vertical vorticity associated with horizontal velocities u and v.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Operators.∇²ᶜᶜᶜ-NTuple{5, Any}","page":"Library","title":"Oceananigans.Operators.∇²ᶜᶜᶜ","text":"∇²ᶜᶜᶜ(i, j, k, grid, c)\n\nCalculate the Laplacian of c via\n\n1/V * [δxᶜᵃᵃ(Ax * ∂xᶠᵃᵃ(c)) + δyᵃᶜᵃ(Ay * ∂yᵃᶠᵃ(c)) + δzᵃᵃᶜ(Az * ∂zᵃᵃᶠ(c))]\n\nwhich ends up at the location ccc.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Output-readers","page":"Library","title":"Output readers","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.OutputReaders]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.OutputReaders.Clamp","page":"Library","title":"Oceananigans.OutputReaders.Clamp","text":"Clamp()\n\nSpecifies FieldTimeSeries Time extrapolation that returns data from the nearest value.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.OutputReaders.Cyclical","page":"Library","title":"Oceananigans.OutputReaders.Cyclical","text":"Cyclical(period=nothing)\n\nSpecifies cyclical FieldTimeSeries linear Time extrapolation. If period is not specified, it is inferred from the fts::FieldTimeSeries via\n\nt = fts.times\nΔt = t[end] - t[end-1]\nperiod = t[end] - t[1] + Δt\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.OutputReaders.FieldDataset-Tuple{Any}","page":"Library","title":"Oceananigans.OutputReaders.FieldDataset","text":"FieldDataset(filepath;\n             architecture=CPU(), grid=nothing, backend=InMemory(), metadata_paths=[\"metadata\"])\n\nReturns a Dict containing a FieldTimeSeries for each field in the JLD2 file located at filepath. Note that model output must have been saved with halos.\n\nKeyword arguments\n\nbackend: Either InMemory() (default) or OnDisk(). The InMemory backend will\n\nload the data fully in memory as a 4D multi-dimensional array while the OnDisk() backend will lazily load field time snapshots when the FieldTimeSeries is indexed linearly.\n\nmetadata_paths: A list of JLD2 paths to look for metadata. By default it looks in file[\"metadata\"].\ngrid: May be specified to override the grid used in the JLD2 file.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.OutputReaders.FieldTimeSeries-Tuple{String, String}","page":"Library","title":"Oceananigans.OutputReaders.FieldTimeSeries","text":"FieldTimeSeries(path, name, backend = InMemory();\n                grid = nothing,\n                iterations = nothing,\n                times = nothing)\n\nReturn a FieldTimeSeries containing a time-series of the field name load from JLD2 output located at path.\n\nKeyword arguments\n\nbackend: InMemory() to load data into a 4D array, OnDisk() to lazily load data from disk            when indexing into FieldTimeSeries.\ngrid: A grid to associate with the data, in the case that the native grid was not serialized         properly.\niterations: Iterations to load. Defaults to all iterations found in the file.\ntimes: Save times to load, as determined through an approximate floating point          comparison to recorded save times. Defaults to times associated with iterations.          Takes precedence over iterations if times is specified.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.OutputReaders.FieldTimeSeries-Union{Tuple{Oceananigans.Grids.AbstractGrid}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Oceananigans.Grids.AbstractGrid, Any}} where {LX, LY, LZ}","page":"Library","title":"Oceananigans.OutputReaders.FieldTimeSeries","text":"FieldTimeSeries{LX, LY, LZ}(grid::AbstractGrid [, times=()]; kwargs...)\n\nConstruct a FieldTimeSeries on grid and at times.\n\nKeyword arguments\n\nindices: spatial indices\nbackend: backend, InMemory(indices=Colon()) or OnDisk()\npath: path to data for backend = OnDisk()\nname: name of field for backend = OnDisk()\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.OutputReaders.InMemory-Tuple{Int64}","page":"Library","title":"Oceananigans.OutputReaders.InMemory","text":"InMemory(length=nothing)\n\nReturn a backend for FieldTimeSeries that stores size fields in memory. The default size = nothing stores all fields in memory.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.OutputReaders.Linear","page":"Library","title":"Oceananigans.OutputReaders.Linear","text":"Linear()\n\nSpecifies FieldTimeSeries linear Time extrapolation.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.OutputReaders.OnDisk","page":"Library","title":"Oceananigans.OutputReaders.OnDisk","text":"OnDisk()\n\nReturn a lazy backend for FieldTimeSeries that keeps data on disk, only loading it as requested by indexing into the FieldTimeSeries.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Output-writers","page":"Library","title":"Output writers","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.OutputWriters]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.OutputWriters.AveragedTimeInterval","page":"Library","title":"Oceananigans.OutputWriters.AveragedTimeInterval","text":"mutable struct AveragedTimeInterval <: AbstractSchedule\n\nContainer for parameters that configure and handle time-averaged output.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.OutputWriters.AveragedTimeInterval-Tuple{Any}","page":"Library","title":"Oceananigans.OutputWriters.AveragedTimeInterval","text":"AveragedTimeInterval(interval; window=interval, stride=1)\n\nReturns a schedule that specifies periodic time-averaging of output. The time window specifies the extent of the time-average, which reoccurs every interval.\n\noutput is computed and accumulated into the average every stride iterations during the averaging window. For example, stride=1 computs output every iteration, whereas stride=2 computes output every other iteration. Time-averages with longer strides are faster to compute, but less accurate.\n\nThe time-average of a is a left Riemann sum corresponding to\n\na = T¹ int_tᵢ-T^tᵢ a mathrmd t  \n\nwhere a is the time-average of a, T is the time-window for averaging, and the tᵢ are discrete times separated by the time interval. The tᵢ specify both the end of the averaging window and the time at which output is written.\n\nExample\n\nusing Oceananigans.OutputWriters: AveragedTimeInterval\nusing Oceananigans.Utils: days\n\nschedule = AveragedTimeInterval(4days, window=2days)\n\n# output\nAveragedTimeInterval(window=2 days, stride=1, interval=4 days)\n\nAn AveragedTimeInterval schedule directs an output writer to time-average its outputs before writing them to disk:\n\nusing Oceananigans\nusing Oceananigans.Units\n\nmodel = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)))\n\nsimulation = Simulation(model, Δt=10minutes, stop_time=30days)\n\nsimulation.output_writers[:velocities] = JLD2OutputWriter(model, model.velocities,\n                                                          filename= \"averaged_velocity_data.jld2\",\n                                                          schedule = AveragedTimeInterval(4days, window=2days, stride=2))\n\n# output\nJLD2OutputWriter scheduled on TimeInterval(4 days):\n├── filepath: ./averaged_velocity_data.jld2\n├── 3 outputs: (u, v, w) averaged on AveragedTimeInterval(window=2 days, stride=2, interval=4 days)\n├── array type: Array{Float64}\n├── including: [:grid, :coriolis, :buoyancy, :closure]\n├── file_splitting: NoFileSplitting\n└── file size: 27.6 KiB\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.OutputWriters.Checkpointer-Tuple{Any}","page":"Library","title":"Oceananigans.OutputWriters.Checkpointer","text":"Checkpointer(model;\n             schedule,\n             dir = \".\",\n             prefix = \"checkpoint\",\n             overwrite_existing = false,\n             verbose = false,\n             cleanup = false,\n             properties = [:grid, :clock, :coriolis,\n                           :buoyancy, :closure, :timestepper, :particles])\n\nConstruct a Checkpointer that checkpoints the model to a JLD2 file on schedule. The model.clock.iteration is included in the filename to distinguish between multiple checkpoint files.\n\nTo restart or \"pickup\" a model from a checkpoint, specify pickup = true when calling run!, ensuring that the checkpoint file is in directory dir. See run! for more details.\n\nNote that extra model properties can be specified, but removing crucial properties such as :timestepper will render restoring from the checkpoint impossible.\n\nThe checkpointer attempts to serialize as much of the model to disk as possible, but functions or objects containing functions cannot be serialized at this time.\n\nKeyword arguments\n\nschedule (required): Schedule that determines when to checkpoint.\ndir: Directory to save output to. Default: \".\" (current working directory).\nprefix: Descriptive filename prefixed to all output files. Default: \"checkpoint\".\noverwrite_existing: Remove existing files if their filenames conflict. Default: false.\nverbose: Log what the output writer is doing with statistics on compute/write times            and file sizes. Default: false.\ncleanup: Previous checkpoint files will be deleted once a new checkpoint file is written.            Default: false.\nproperties: List of model properties to checkpoint. This list must contain               :grid, :timestepper, and :particles.               Default: [:grid, :timestepper, :particles, :clock, :coriolis, :buoyancy, :closure]\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.OutputWriters.FileSizeLimit-Tuple{Any}","page":"Library","title":"Oceananigans.OutputWriters.FileSizeLimit","text":"FileSizeLimit(size_limit [, path=\"\"])\n\nReturn a schedule that actuates when the file at path exceeds the size_limit.\n\nThe path is automatically added and updated when FileSizeLimit is used with an output writer, and should not be provided manually.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.OutputWriters.JLD2OutputWriter-Tuple{Any, Any}","page":"Library","title":"Oceananigans.OutputWriters.JLD2OutputWriter","text":"JLD2OutputWriter(model, outputs; filename, schedule,\n                          dir = \".\",\n                      indices = (:, :, :),\n                   with_halos = false,\n                   array_type = Array{Float64},\n               file_splitting = NoFileSplitting(),\n           overwrite_existing = false,\n                         init = noinit,\n                    including = [:grid, :coriolis, :buoyancy, :closure],\n                      verbose = false,\n                         part = 1,\n                      jld2_kw = Dict{Symbol, Any}())\n\nConstruct a JLD2OutputWriter for an Oceananigans model that writes label, output pairs in outputs to a JLD2 file.\n\nThe argument outputs may be a Dict or NamedTuple. The keys of outputs are symbols or strings that \"name\" output data. The values of outputs are either AbstractFields, objects that are called with the signature output(model), or WindowedTimeAverages of AbstractFieldss, functions, or callable objects.\n\nKeyword arguments\n\nFilenaming\n\nfilename (required): Descriptive filename. \".jld2\" is appended to filename in the file path                        if filename does not end in \".jld2\".\ndir: Directory to save output to. Default: \".\" (current working directory).\n\nOutput frequency and time-averaging\n\nschedule (required): AbstractSchedule that determines when output is saved.\n\nSlicing and type conversion prior to output\n\nindices: Specifies the indices to write to disk with a Tuple of Colon, UnitRange,            or Int elements. Indices must be Colon, Int, or contiguous UnitRange.            Defaults to (:, :, :) or \"all indices\". If !with_halos,            halo regions are removed from indices. For example, indices = (:, :, 1)            will save xy-slices of the bottom-most index.\nwith_halos (Bool): Whether or not to slice halo regions from fields before writing output.                      Note, that to postprocess saved output (e.g., compute derivatives, etc)                      information about the boundary conditions is often crucial. In that case                      you might need to set with_halos = true.\narray_type: The array type to which output arrays are converted to prior to saving.               Default: Array{Float64}.\n\nFile management\n\nfile_splitting: Schedule for splitting the output file. The new files will be suffixed with                   _part1, _part2, etc. For example file_splitting = FileSizeLimit(sz) will                   split the output file when its size exceeds sz. Another example is                    file_splitting = TimeInterval(30days), which will split files every 30 days of                   simulation time. The default incurs no splitting (NoFileSplitting()).\noverwrite_existing: Remove existing files if their filenames conflict.                       Default: false.\n\nOutput file metadata management\n\ninit: A function of the form init(file, model) that runs when a JLD2 output file is initialized.         Default: noinit(args...) = nothing.\nincluding: List of model properties to save with every file.              Default: [:grid, :coriolis, :buoyancy, :closure]\n\nMiscellaneous keywords\n\nverbose: Log what the output writer is doing with statistics on compute/write times and file sizes.            Default: false.\npart: The starting part number used when file splitting.         Default: 1.\njld2_kw: Dict of kwargs to be passed to jldopen when data is written.\n\nExample\n\nWrite out 3D fields for u, v, w, and a tracer c, along with a horizontal average:\n\nusing Oceananigans\nusing Oceananigans.Utils: hour, minute\n\nmodel = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)), tracers=:c)\nsimulation = Simulation(model, Δt=12, stop_time=1hour)\n\nfunction init_save_some_metadata!(file, model)\n    file[\"author\"] = \"Chim Riggles\"\n    file[\"parameters/coriolis_parameter\"] = 1e-4\n    file[\"parameters/density\"] = 1027\n    return nothing\nend\n\nc_avg =  Field(Average(model.tracers.c, dims=(1, 2)))\n\n# Note that model.velocities is NamedTuple\nsimulation.output_writers[:velocities] = JLD2OutputWriter(model, model.velocities,\n                                                          filename = \"some_data.jld2\",\n                                                          schedule = TimeInterval(20minute),\n                                                          init = init_save_some_metadata!)\n\n# output\nJLD2OutputWriter scheduled on TimeInterval(20 minutes):\n├── filepath: ./some_data.jld2\n├── 3 outputs: (u, v, w)\n├── array type: Array{Float64}\n├── including: [:grid, :coriolis, :buoyancy, :closure]\n├── file_splitting: NoFileSplitting\n└── file size: 28.0 KiB\n\nand a time- and horizontal-average of tracer c every 20 minutes of simulation time to a file called some_averaged_data.jld2\n\nsimulation.output_writers[:avg_c] = JLD2OutputWriter(model, (; c=c_avg),\n                                                     filename = \"some_averaged_data.jld2\",\n                                                     schedule = AveragedTimeInterval(20minute, window=5minute))\n\n# output\nJLD2OutputWriter scheduled on TimeInterval(20 minutes):\n├── filepath: ./some_averaged_data.jld2\n├── 1 outputs: c averaged on AveragedTimeInterval(window=5 minutes, stride=1, interval=20 minutes)\n├── array type: Array{Float64}\n├── including: [:grid, :coriolis, :buoyancy, :closure]\n├── file_splitting: NoFileSplitting\n└── file size: 17.8 KiB\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.OutputWriters.NetCDFOutputWriter-Tuple{Any, Any}","page":"Library","title":"Oceananigans.OutputWriters.NetCDFOutputWriter","text":"NetCDFOutputWriter(model, outputs; filename, schedule,\n                   grid = model.grid,\n                   dir = \".\",\n                   array_type = Array{Float64},\n                   indices = nothing,\n                   with_halos = false,\n                   global_attributes = Dict(),\n                   output_attributes = Dict(),\n                   dimensions = Dict(),\n                   overwrite_existing = false,\n                   deflatelevel = 0,\n                   part = 1,\n                   file_splitting = NoFileSplitting(),\n                   verbose = false)\n\nConstruct a NetCDFOutputWriter that writes (label, output) pairs in outputs (which should be a Dict) to a NetCDF file, where label is a string that labels the output and output is either a Field (e.g. model.velocities.u) or a function f(model) that returns something to be written to disk.\n\nIf any of outputs are not AbstractField, their spatial dimensions must be provided.\n\nTo use outputs on a grid not equal to model.grid, provide the keyword argument grid.\n\nKeyword arguments\n\ngrid: The grid associated with outputs. Defaults to model.grid.\n\nFilenaming\n\nfilename (required): Descriptive filename. \".nc\" is appended to filename if filename does                        not end in \".nc\".\ndir: Directory to save output to.\n\nOutput frequency and time-averaging\n\nschedule (required): AbstractSchedule that determines when output is saved.\n\nSlicing and type conversion prior to output\n\nindices: Tuple of indices of the output variables to include. Default is (:, :, :), which            includes the full fields.\nwith_halos: Boolean defining whether or not to include halos in the outputs. Default: false.               Note, that to postprocess saved output (e.g., compute derivatives, etc)               information about the boundary conditions is often crucial. In that case               you might need to set with_halos = true.\narray_type: The array type to which output arrays are converted to prior to saving.               Default: Array{Float64}.\ndimensions: A Dict of dimension tuples to apply to outputs (required for function outputs).\n\nFile management\n\noverwrite_existing: If false, NetCDFOutputWriter will be set to append to filepath. If true,                       NetCDFOutputWriter will overwrite filepath if it exists or create it if not.                       Default: false. See NCDatasets.jl documentation                       for more information about its mode option.\ndeflatelevel: Determines the NetCDF compression level of data (integer 0-9; 0 (default) means no compression                 and 9 means maximum compression). See NCDatasets.jl documentation                 for more information.\nfile_splitting: Schedule for splitting the output file. The new files will be suffixed with         _part1, _part2, etc. For example file_splitting = FileSizeLimit(sz) will         split the output file when its size exceeds sz. Another example is         file_splitting = TimeInterval(30days), which will split files every 30 days of         simulation time. The default incurs no splitting (NoFileSplitting()).\n\nMiscellaneous keywords\n\nverbose: Log what the output writer is doing with statistics on compute/write times and file sizes.            Default: false.\npart: The starting part number used when file splitting.\nglobal_attributes: Dict of model properties to save with every file. Default: Dict().\noutput_attributes: Dict of attributes to be saved with each field variable (reasonable                      defaults are provided for velocities, buoyancy, temperature, and salinity;                      otherwise output_attributes must be user-provided).\n\nExamples\n\nSaving the u velocity field and temperature fields, the full 3D fields and surface 2D slices to separate NetCDF files:\n\nusing Oceananigans\n\ngrid = RectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1))\n\nmodel = NonhydrostaticModel(grid=grid, tracers=:c)\n\nsimulation = Simulation(model, Δt=12, stop_time=3600)\n\nfields = Dict(\"u\" => model.velocities.u, \"c\" => model.tracers.c)\n\nsimulation.output_writers[:field_writer] =\n    NetCDFOutputWriter(model, fields, filename=\"fields.nc\", schedule=TimeInterval(60))\n\n# output\nNetCDFOutputWriter scheduled on TimeInterval(1 minute):\n├── filepath: ./fields.nc\n├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0)\n├── 2 outputs: (c, u)\n└── array type: Array{Float64}\n├── file_splitting: NoFileSplitting\n└── file size: 14.9 KiB\n\nsimulation.output_writers[:surface_slice_writer] =\n    NetCDFOutputWriter(model, fields, filename=\"surface_xy_slice.nc\",\n                       schedule=TimeInterval(60), indices=(:, :, grid.Nz))\n\n# output\nNetCDFOutputWriter scheduled on TimeInterval(1 minute):\n├── filepath: ./surface_xy_slice.nc\n├── dimensions: zC(1), zF(1), xC(16), yF(16), xF(16), yC(16), time(0)\n├── 2 outputs: (c, u)\n└── array type: Array{Float64}\n├── file_splitting: NoFileSplitting\n└── file size: 14.9 KiB\n\nsimulation.output_writers[:averaged_profile_writer] =\n    NetCDFOutputWriter(model, fields,\n                       filename = \"averaged_z_profile.nc\",\n                       schedule = AveragedTimeInterval(60, window=20),\n                       indices = (1, 1, :))\n\n# output\nNetCDFOutputWriter scheduled on TimeInterval(1 minute):\n├── filepath: ./averaged_z_profile.nc\n├── dimensions: zC(16), zF(17), xC(1), yF(1), xF(1), yC(1), time(0)\n├── 2 outputs: (c, u) averaged on AveragedTimeInterval(window=20 seconds, stride=1, interval=1 minute)\n└── array type: Array{Float64}\n├── file_splitting: NoFileSplitting\n└── file size: 17.6 KiB\n\nNetCDFOutputWriter also accepts output functions that write scalars and arrays to disk, provided that their dimensions are provided:\n\nusing Oceananigans\n\nNx, Ny, Nz = 16, 16, 16\n\ngrid = RectilinearGrid(size=(Nx, Ny, Nz), extent=(1, 2, 3))\n\nmodel = NonhydrostaticModel(; grid)\n\nsimulation = Simulation(model, Δt=1.25, stop_iteration=3)\n\nf(model) = model.clock.time^2 # scalar output\n\nzC = znodes(grid, Center())\ng(model) = model.clock.time .* exp.(zC) # vector/profile output\n\nxC, yF = xnodes(grid, Center()), ynodes(grid, Face())\nXC = [xC[i] for i in 1:Nx, j in 1:Ny]\nYF = [yF[j] for i in 1:Nx, j in 1:Ny]\nh(model) = @. model.clock.time * sin(XC) * cos(YF) # xy slice output\n\noutputs = Dict(\"scalar\" => f, \"profile\" => g, \"slice\" => h)\n\ndims = Dict(\"scalar\" => (), \"profile\" => (\"zC\",), \"slice\" => (\"xC\", \"yC\"))\n\noutput_attributes = Dict(\n    \"scalar\"  => Dict(\"long_name\" => \"Some scalar\", \"units\" => \"bananas\"),\n    \"profile\" => Dict(\"long_name\" => \"Some vertical profile\", \"units\" => \"watermelons\"),\n    \"slice\"   => Dict(\"long_name\" => \"Some slice\", \"units\" => \"mushrooms\")\n)\n\nglobal_attributes = Dict(\"location\" => \"Bay of Fundy\", \"onions\" => 7)\n\nsimulation.output_writers[:things] =\n    NetCDFOutputWriter(model, outputs,\n                       schedule=IterationInterval(1), filename=\"things.nc\", dimensions=dims, verbose=true,\n                       global_attributes=global_attributes, output_attributes=output_attributes)\n\n# output\nNetCDFOutputWriter scheduled on IterationInterval(1):\n├── filepath: ./things.nc\n├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0)\n├── 3 outputs: (profile, slice, scalar)\n└── array type: Array{Float64}\n├── file_splitting: NoFileSplitting\n└── file size: 17.8 KiB\n\nNetCDFOutputWriter can also be configured for outputs that are interpolated or regridded to a different grid than model.grid. To use this functionality, include the keyword argument grid = output_grid.\n\nusing Oceananigans\nusing Oceananigans.Fields: interpolate!\n\ngrid = RectilinearGrid(size=(1, 1, 8), extent=(1, 1, 1));\nmodel = NonhydrostaticModel(; grid)\n\ncoarse_grid = RectilinearGrid(size=(grid.Nx, grid.Ny, grid.Nz÷2), extent=(grid.Lx, grid.Ly, grid.Lz))\ncoarse_u = Field{Face, Center, Center}(coarse_grid)\n\ninterpolate_u(model) = interpolate!(coarse_u, model.velocities.u)\noutputs = (; u = interpolate_u)\n\noutput_writer = NetCDFOutputWriter(model, outputs;\n                                   grid = coarse_grid,\n                                   filename = \"coarse_u.nc\",\n                                   schedule = IterationInterval(1))\n\n# output\nNetCDFOutputWriter scheduled on IterationInterval(1):\n├── filepath: ./coarse_u.nc\n├── dimensions: zC(4), zF(5), xC(1), yF(1), xF(1), yC(1), time(0)\n├── 1 outputs: u\n└── array type: Array{Float64}\n├── file_splitting: NoFileSplitting\n└── file size: 14.6 KiB\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.OutputWriters.WindowedTimeAverage","page":"Library","title":"Oceananigans.OutputWriters.WindowedTimeAverage","text":"WindowedTimeAverage(operand, model=nothing; schedule)\n\nReturns an object for computing running averages of operand over schedule.window and recurring on schedule.interval, where schedule is an AveragedTimeInterval. During the collection period, averages are computed every schedule.stride iteration.\n\noperand may be a Oceananigans.Field or a function that returns an array or scalar.\n\nCalling wta(model) for wta::WindowedTimeAverage object returns wta.result.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Simulations","page":"Library","title":"Simulations","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Simulations]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.Simulations.Callback","page":"Library","title":"Oceananigans.Simulations.Callback","text":"Callback(func, schedule=IterationInterval(1);\n         parameters=nothing, callsite=TimeStepCallsite())\n\nReturn Callback that executes func on schedule at the callsite with optional parameters. By default, schedule = IterationInterval(1) and callsite = TimeStepCallsite().\n\nIf isnothing(parameters), func(sim::Simulation) is called. Otherwise, func is called via func(sim::Simulation, parameters).\n\nThe callsite determines where Callback is executed. The possible values for  callsite are\n\nTimeStepCallsite(): after a time-step.\nTendencyCallsite(): after tendencies are calculated, but before taking a time-step (useful for modifying tendency calculations).\nUpdateStateCallsite(): within update_state!, after auxiliary variables have been computed (for multi-stage time-steppers, update_state! may be called multiple times per time-step).\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Simulations.Simulation-Tuple{Any}","page":"Library","title":"Oceananigans.Simulations.Simulation","text":"Simulation(model; Δt,\n           verbose = true,\n           stop_iteration = Inf,\n           stop_time = Inf,\n           wall_time_limit = Inf)\n\nConstruct a Simulation for a model with time step Δt.\n\nKeyword arguments\n\nΔt: Required keyword argument specifying the simulation time step. Can be a Number       for constant time steps or a TimeStepWizard for adaptive time-stepping.\nstop_iteration: Stop the simulation after this many iterations.\nstop_time: Stop the simulation once this much model clock time has passed.\nwall_time_limit: Stop the simulation if it's been running for longer than this many                    seconds of wall clock time.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Simulations.TimeStepWizard","page":"Library","title":"Oceananigans.Simulations.TimeStepWizard","text":"TimeStepWizard([FT=Float64;]\n               cfl = 0.2,\n               diffusive_cfl = Inf,\n               max_change = 1.1,\n               min_change = 0.5,\n               max_Δt = Inf,\n               min_Δt = 0.0,\n               cell_advection_timescale = cell_advection_timescale,\n               cell_diffusion_timescale = infinite_diffusion_timescale)\n\nCallback function that adjusts the simulation time step to meet specified target values  for advective and diffusive Courant-Friedrichs-Lewy (CFL) numbers (cfl and diffusive_cfl),  subject to the limits\n\nmax(min_Δt, min_change * last_Δt) ≤ new_Δt ≤ min(max_Δt, max_change * last_Δt)\n\nwhere new_Δt is the new time step calculated by the TimeStepWizard.\n\nFor more information on the CFL number, see its wikipedia entry.\n\nExample\n\nTo use TimeStepWizard, insert it into a Callback and then add the Callback to a Simulation:\n\njulia> simulation = Simulation(model, Δt=0.9, stop_iteration=100)\n\njulia> wizard = TimeStepWizard(cfl=0.2)\n\njulia> simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(4))\n\nThen when run!(simulation) is invoked, the time-step simulation.Δt will be updated every 4 iterations.\n\n(Note that the name :wizard is unimportant.)\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Simulations.add_callback!-Tuple{Any, Callback}","page":"Library","title":"Oceananigans.Simulations.add_callback!","text":"add_callback!(simulation, callback::Callback; name = GenericName(), callback_kw...)\n\nadd_callback!(simulation, func, schedule=IterationInterval(1); name = GenericName(), callback_kw...)\n\nAdd Callback(func, schedule) to simulation.callbacks under name. The default GenericName() generates a name of the form :callbackN, where N is big enough for the name to be unique.\n\nIf name::Symbol is supplied, it may be modified if simulation.callbacks[name] already exists.\n\ncallback_kw are passed to the constructor for Callback.\n\nThe callback (which contains a schedule) can also be supplied directly.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Simulations.conjure_time_step_wizard!","page":"Library","title":"Oceananigans.Simulations.conjure_time_step_wizard!","text":"conjure_time_step_wizard!(simulation, schedule=IterationInterval(5), wizard_kw...)\n\nAdd a TimeStepWizard built with wizard_kw as a Callback to simulation, called on schedule which is IterationInterval(5) by default.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.Simulations.run!-Tuple{Any}","page":"Library","title":"Oceananigans.Simulations.run!","text":"run!(simulation; pickup=false)\n\nRun a simulation until one of simulation.stop_criteria evaluates true. The simulation will then stop.\n\nPicking simulations up from a checkpoint\n\nSimulations are \"picked up\" from a checkpoint if pickup is either true, a String, or an Integer greater than 0.\n\nPicking up a simulation sets field and tendency data to the specified checkpoint, leaving all other model properties unchanged.\n\nPossible values for pickup are:\n\npickup=true picks a simulation up from the latest checkpoint associated with the Checkpointer in simulation.output_writers.\npickup=iteration::Int picks a simulation up from the checkpointed file associated  with iteration and the Checkpointer in simulation.output_writers.\npickup=filepath::String picks a simulation up from checkpointer data in filepath.\n\nNote that pickup=true and pickup=iteration fails if simulation.output_writers contains more than one checkpointer.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Solvers.iteration-Tuple{Simulation}","page":"Library","title":"Oceananigans.Solvers.iteration","text":"iteration(sim::Simulation)\n\nReturn the current simulation iteration.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Solvers","page":"Library","title":"Solvers","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Solvers]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.Solvers.BatchedTridiagonalSolver","page":"Library","title":"Oceananigans.Solvers.BatchedTridiagonalSolver","text":"struct BatchedTridiagonalSolver{A, B, C, T, G, P}\n\nA batched solver for large numbers of triadiagonal systems.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Solvers.BatchedTridiagonalSolver-Tuple{Any}","page":"Library","title":"Oceananigans.Solvers.BatchedTridiagonalSolver","text":"BatchedTridiagonalSolver(grid;\n                         lower_diagonal,\n                         diagonal,\n                         upper_diagonal,\n                         scratch = on_architecture(architecture(grid), zeros(eltype(grid), size(grid)...)),\n                         tridiagonal_direction = ZDirection()\n                         parameters = nothing)\n\nConstruct a solver for batched tridiagonal systems on grid of the form\n\n                    bⁱʲ¹ ϕⁱʲ¹ + cⁱʲ¹ ϕⁱʲ²   = fⁱʲ¹,\n    aⁱʲᵏ⁻¹ ϕⁱʲᵏ⁻¹ + bⁱʲᵏ ϕⁱʲᵏ + cⁱʲᵏ ϕⁱʲᵏ⁺¹ = fⁱʲᵏ,  k = 2, ..., N-1\n    aⁱʲᴺ⁻¹ ϕⁱʲᴺ⁻¹ + bⁱʲᴺ ϕⁱʲᴺ               = fⁱʲᴺ,\n\nor in matrix form\n\n    ⎡ bⁱʲ¹   cⁱʲ¹     0       ⋯         0   ⎤ ⎡ ϕⁱʲ¹ ⎤   ⎡ fⁱʲ¹ ⎤\n    ⎢ aⁱʲ¹   bⁱʲ²   cⁱʲ²      0    ⋯    ⋮   ⎥ ⎢ ϕⁱʲ² ⎥   ⎢ fⁱʲ² ⎥\n    ⎢  0      ⋱      ⋱       ⋱              ⎥ ⎢   .  ⎥   ⎢   .  ⎥\n    ⎢  ⋮                                0   ⎥ ⎢ ϕⁱʲᵏ ⎥   ⎢ fⁱʲᵏ ⎥\n    ⎢  ⋮           aⁱʲᴺ⁻²   bⁱʲᴺ⁻¹   cⁱʲᴺ⁻¹ ⎥ ⎢      ⎥   ⎢   .  ⎥\n    ⎣  0      ⋯      0      aⁱʲᴺ⁻¹    bⁱʲᴺ  ⎦ ⎣ ϕⁱʲᴺ ⎦   ⎣ fⁱʲᴺ ⎦\n\nwhere a is the lower_diagonal, b is the diagonal, and c is the upper_diagonal.\n\nNote the convention used here for indexing the upper and lower diagonals; this can be different from  other implementations where, e.g., aⁱʲ² may appear at the second row, instead of aⁱʲ¹ as above.\n\nϕ is the solution and f is the right hand side source term passed to solve!(ϕ, tridiagonal_solver, f).\n\na, b, c, and f can be specified in three ways:\n\nA 1D array means, e.g., that aⁱʲᵏ = a[k].\nA 3D array means, e.g., that aⁱʲᵏ = a[i, j, k].\n\nOther coefficient types can be implemented by extending get_coefficient.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Solvers.ConjugateGradientSolver-Tuple{Any}","page":"Library","title":"Oceananigans.Solvers.ConjugateGradientSolver","text":"ConjugateGradientSolver(linear_operation;\n                                      template_field,\n                                      maxiter = size(template_field.grid),\n                                      reltol = sqrt(eps(template_field.grid)),\n                                      abstol = 0,\n                                      preconditioner = nothing)\n\nReturns a ConjugateGradientSolver that solves the linear equation A x = b using a iterative conjugate gradient method with optional preconditioning.\n\nThe solver is used by calling\n\nsolve!(x, solver::PreconditionedConjugateGradientOperator, b, args...)\n\nfor solver, right-hand side b, solution x, and optional arguments args....\n\nArguments\n\nlinear_operation: Function with signature linear_operation!(p, y, args...) that calculates                     A * y and stores the result in p for a \"candidate solution\" y. args...                     are optional positional arguments passed from solve!(x, solver, b, args...).\ntemplate_field: Dummy field that is the same type and size as x and b, which                   is used to infer the architecture, grid, and to create work arrays                   that are used internally by the solver.\nmaxiter: Maximum number of iterations the solver may perform before exiting.\nreltol, abstol: Relative and absolute tolerance for convergence of the algorithm.                   The iteration stops when norm(A * x - b) < tolerance.\npreconditioner: Object for which precondition!(z, preconditioner, r, args...) computes z = P * r,                   where r is the residual. Typically P is approximately A⁻¹.\n\nSee solve! for more information about the preconditioned conjugate-gradient algorithm.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Solvers.FFTBasedPoissonSolver","page":"Library","title":"Oceananigans.Solvers.FFTBasedPoissonSolver","text":"FFTBasedPoissonSolver(grid, planner_flag=FFTW.PATIENT)\n\nReturn an FFTBasedPoissonSolver that solves the \"generalized\" Poisson equation,\n\n(² + m) ϕ = b\n\nwhere m is a number, using a eigenfunction expansion of the discrete Poisson operator on a staggered grid and for periodic or Neumann boundary conditions.\n\nIn-place transforms are applied to b, which means b must have complex-valued elements (typically the same type as solver.storage).\n\nSee solve! for more information about the FFT-based Poisson solver algorithm.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Solvers.HeptadiagonalIterativeSolver-Tuple{Any}","page":"Library","title":"Oceananigans.Solvers.HeptadiagonalIterativeSolver","text":"HeptadiagonalIterativeSolver(coeffs;\n                             grid,\n                             iterative_solver = cg!,\n                             maximum_iterations = prod(size(grid)),\n                             tolerance = 1e-13,\n                             reduced_dim = (false, false, false), \n                             placeholder_timestep = -1.0, \n                             preconditioner_method = :Default, \n                             preconditioner_settings = nothing,\n                             template = on_architecture(architecture(grid), zeros(prod(size(grid)))),\n                             verbose = false)\n\nReturn a HeptadiagonalIterativeSolver to solve the problem A * x = b, provided that A is a symmetric matrix.\n\nThe solver relies on a sparse version of the matrix A that is stored in matrix_constructors.\n\nIn particular, given coefficients Ax, Ay, Az, C, D, the solved problem is\n\n    Axᵢ₊₁ ηᵢ₊₁ + Axᵢ ηᵢ₋₁ + Ayⱼ₊₁ ηⱼ₊₁ + Ayⱼ ηⱼ₋₁ + Azₖ₊₁ ηₖ₊₁ + Azₖ ηₖ₋₁ \n    - 2 ( Axᵢ₊₁ + Axᵢ + Ayⱼ₊₁ + Ayⱼ + Azₖ₊₁ + Azₖ ) ηᵢⱼₖ \n    +   ( Cᵢⱼₖ + Dᵢⱼₖ/Δt^2 ) ηᵢⱼₖ  = b\n\nTo have the equation solved at location {Center, Center, Center}, the coefficients must be specified at:\n\nAx -> {Face,   Center, Center}\nAy -> {Center, Face,   Center}\nAz -> {Center, Center, Face}\nC  -> {Center, Center, Center}\nD  -> {Center, Center, Center}\n\nsolver.matrix is precomputed with a placeholder timestep value of placeholder_timestep = -1.0.\n\nThe sparse matrix A can be constructed with:\n\nSparseMatrixCSC(constructors...) for CPU\nCuSparseMatrixCSC(constructors...) for GPU\n\nThe matrix constructors are calculated based on the pentadiagonal coeffients passed as an input to matrix_from_coefficients function.\n\nTo allow for variable time step, the diagonal term - Az / (g * Δt²) is only added later on and it is updated only when the previous time step changes (last_Δt != Δt).\n\nPreconditioning is done through the various methods implemented in Solvers/sparse_preconditioners.jl.\n\nThe iterative_solver used can is to be chosen from the IterativeSolvers.jl package.  The default solver is a Conjugate Gradient (cg):\n\nsolver = HeptadiagonalIterativeSolver((Ax, Ay, Az, C, D); grid)\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Solvers.solve!","page":"Library","title":"Oceananigans.Solvers.solve!","text":"solve!(ϕ, solver::FFTBasedPoissonSolver, b, m=0)\n\nSolve the \"generalized\" Poisson equation,\n\n(² + m) ϕ = b\n\nwhere m is a number, using a eigenfunction expansion of the discrete Poisson operator on a staggered grid and for periodic or Neumann boundary conditions.\n\nIn-place transforms are applied to b, which means b must have complex-valued elements (typically the same type as solver.storage).\n\ninfo: Alternative names for 'generalized' Poisson equation\nEquation (² + m) ϕ = b is sometimes referred to as the \"screened Poisson\" equation when m  0, or the Helmholtz equation when m  0.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.Solvers.solve!-Tuple{Any, Oceananigans.Solvers.BatchedTridiagonalSolver, Any, Vararg{Any}}","page":"Library","title":"Oceananigans.Solvers.solve!","text":"solve!(ϕ, solver::BatchedTridiagonalSolver, rhs, args...)\n\nSolve the batched tridiagonal system of linear equations with right hand side rhs and lower diagonal, diagonal, and upper diagonal coefficients described by the BatchedTridiagonalSolver solver. BatchedTridiagonalSolver uses a modified TriDiagonal Matrix Algorithm (TDMA).\n\nThe result is stored in ϕ which must have size (grid.Nx, grid.Ny, grid.Nz).\n\nImplementation follows Press William et al. (1992); §2.4. Note that a slightly different notation from Press et al. is used for indexing the off-diagonal elements; see BatchedTridiagonalSolver.\n\nReference\n\nPress William, H., Teukolsky Saul, A., Vetterling William, T., & Flannery Brian, P. (1992).     Numerical recipes: the art of scientific computing. Cambridge University Press\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Solvers.solve!-Tuple{Any, Oceananigans.Solvers.ConjugateGradientSolver, Any, Vararg{Any}}","page":"Library","title":"Oceananigans.Solvers.solve!","text":"solve!(x, solver::ConjugateGradientSolver, b, args...)\n\nSolve A * x = b using an iterative conjugate-gradient method, where A * x is determined by solver.linear_operation\n\nSee figure 2.5 in\n\nThe Preconditioned Conjugate Gradient Method in \"Templates for the Solution of Linear Systems: Building Blocks for Iterative Methods\" Barrett et. al, 2nd Edition.\n\nGiven:\n\nLinear Preconditioner operator M!(solution, x, other_args...) that computes M * x = solution\nA matrix operator A as a function A();\nA dot product function norm();\nA right-hand side b;\nAn initial guess x; and\nLocal vectors: z, r, p, q\n\nThis function executes the psuedocode algorithm\n\nβ  = 0\nr = b - A(x)\niteration  = 0\n\nLoop:\n     if iteration > maxiter\n        break\n     end\n\n     ρ = r ⋅ z\n\n     z = M(r)\n     β = ρⁱ⁻¹ / ρ\n     p = z + β * p\n     q = A(p)\n\n     α = ρ / (p ⋅ q)\n     x = x + α * p\n     r = r - α * q\n\n     if |r| < tolerance\n        break\n     end\n\n     iteration += 1\n     ρⁱ⁻¹ = ρ\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Stokes-drift","page":"Library","title":"Stokes drift","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.StokesDrifts]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.StokesDrifts.StokesDrift-Tuple{}","page":"Library","title":"Oceananigans.StokesDrifts.StokesDrift","text":"StokesDrift(; ∂z_uˢ=zerofunction, ∂y_uˢ=zerofunction, ∂t_uˢ=zerofunction, \n              ∂z_vˢ=zerofunction, ∂x_vˢ=zerofunction, ∂t_vˢ=zerofunction, \n              ∂x_wˢ=zerofunction, ∂y_wˢ=zerofunction, ∂t_wˢ=zerofunction, parameters=nothing)\n\nConstruct a set of functions of space and time for a Stokes drift velocity field corresponding to a surface gravity wave field with an envelope that (potentially) varies in the horizontal directions.\n\nTo resolve the evolution of the Lagrangian-mean momentum, we require all the components of the \"psuedovorticity\",\n\n  𝐯ˢ = hatboldsymbolx (_y wˢ - _z vˢ) + hatboldsymboly (_z uˢ - _x wˢ) + hatboldsymbolz (_x vˢ - _y uˢ)\n\nas well as the time-derivatives of uˢ, vˢ, and wˢ.\n\nNote that each function (e.g., ∂z_uˢ) is generally a function of depth, horizontal coordinates, and time.Thus, the correct function signature depends on the grid, since Flat horizontal directions are omitted.\n\nFor example, on a grid with topology = (Periodic, Flat, Bounded) (and parameters=nothing), then, e.g., ∂z_uˢ is callable via ∂z_uˢ(x, z, t). When !isnothing(parameters), then ∂z_uˢ is callable via ∂z_uˢ(x, z, t, parameters). Similarly, on a grid with topology = (Periodic, Periodic, Bounded) and parameters=nothing, ∂z_uˢ is called via ∂z_uˢ(x, y, z, t).\n\nExample\n\nA wavepacket moving with the group velocity in the x-direction. We write the Stokes drift as:\n\nuˢ(x y z t) = A(x - cᵍ  t y) uˢ(z)\n\nwith A(ξ η) = exp-(ξ^2 + η^2)  2δ^2. We also assume vˢ = 0. If 𝐯ˢ represents the solenoidal component of the Stokes drift, then in this system from incompressibility requirement we have that _z wˢ = - _x uˢ = - (_ξ A) uˢ and therefore, under the assumption that wˢ tends to zero at large depths, we get wˢ = - (_ξ A  2k) uˢ.\n\nusing Oceananigans\nusing Oceananigans.Units\n\ng = 9.81 # gravitational acceleration\n\nϵ = 0.1\nλ = 100meters  # horizontal wavelength\nconst k = 2π / λ  # horizontal wavenumber\nc = sqrt(g / k)  # phase speed\nconst δ = 400kilometers  # wavepacket spread\nconst cᵍ = c / 2  # group speed\nconst Uˢ = ϵ^2 * c\n\n@inline A(ξ, η) = exp(- (ξ^2 + η^2) / 2δ^2)\n\n@inline ∂ξ_A(ξ, η) = - ξ / δ^2 * A(ξ, η)\n@inline ∂η_A(ξ, η) = - η / δ^2 * A(ξ, η)\n@inline ∂η_∂ξ_A(ξ, η) = η * ξ / δ^4 * A(ξ, η)\n@inline ∂²ξ_A(ξ, η) = (ξ^2 / δ^2 - 1) * A(ξ, η) / δ^2\n\n@inline ûˢ(z) = Uˢ * exp(2k * z)\n@inline uˢ(x, y, z, t) = A(x - cᵍ * t, y) * ûˢ(z)\n\n@inline ∂z_uˢ(x, y, z, t) = 2k * A(x - cᵍ * t, y) * ûˢ(z)\n@inline ∂y_uˢ(x, y, z, t) = ∂η_A(x - cᵍ * t, y) * ûˢ(z)\n@inline ∂t_uˢ(x, y, z, t) = - cᵍ * ∂ξ_A(x - cᵍ * t, y) * ûˢ(z)\n@inline ∂x_wˢ(x, y, z, t) = - 1 / 2k * ∂²ξ_A(x - cᵍ * t, y) * ûˢ(z)\n@inline ∂y_wˢ(x, y, z, t) = - 1 / 2k * ∂η_∂ξ_A(x - cᵍ * t, y) * ûˢ(z)\n@inline ∂t_wˢ(x, y, z, t) = + cᵍ / 2k * ∂²ξ_A(x - cᵍ * t, y) * ûˢ(z)\n\nstokes_drift = StokesDrift(; ∂z_uˢ, ∂t_uˢ, ∂y_uˢ, ∂t_wˢ, ∂x_wˢ, ∂y_wˢ)\n\n# output\n\nStokesDrift{Nothing}:\n├── ∂x_vˢ: zerofunction\n├── ∂x_wˢ: ∂x_wˢ\n├── ∂y_uˢ: ∂y_uˢ\n├── ∂y_wˢ: ∂y_wˢ\n├── ∂z_uˢ: ∂z_uˢ\n├── ∂z_vˢ: zerofunction\n├── ∂t_uˢ: ∂t_uˢ\n├── ∂t_vˢ: zerofunction\n└── ∂t_wˢ: ∂t_wˢ\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.StokesDrifts.UniformStokesDrift-Tuple{}","page":"Library","title":"Oceananigans.StokesDrifts.UniformStokesDrift","text":"UniformStokesDrift(; ∂z_uˢ=zerofunction, ∂z_vˢ=zerofunction, ∂t_uˢ=zerofunction, ∂t_vˢ=zerofunction, parameters=nothing)\n\nConstruct a set of functions for a Stokes drift velocity field corresponding to a horizontally-uniform surface gravity wave field, with optional parameters.\n\nIf parameters=nothing, then the functions ∂z_uˢ, ∂z_vˢ, ∂t_uˢ, ∂t_vˢ must be callable with signature (z, t). If !isnothing(parameters), then functions must be callable with the signature (z, t, parameters).\n\nTo resolve the evolution of the Lagrangian-mean momentum, we require vertical-derivatives and time-derivatives of the horizontal components of the Stokes drift, uˢ and vˢ.\n\nExamples\n\nExponentially decaying Stokes drift corresponding to a surface Stokes drift of uˢ(z=0) = 0.005 and decay scale h = 20:\n\nusing Oceananigans\n\n@inline uniform_stokes_shear(z, t) = 0.005 * exp(z / 20)\n\nstokes_drift = UniformStokesDrift(∂z_uˢ=uniform_stokes_shear)\n\n# output\n\nUniformStokesDrift{Nothing}:\n├── ∂z_uˢ: uniform_stokes_shear\n├── ∂z_vˢ: zerofunction\n├── ∂t_uˢ: zerofunction\n└── ∂t_vˢ: zerofunction\n\nExponentially-decaying Stokes drift corresponding to a surface Stokes drift of uˢ = 0.005 and decay scale h = 20, using parameters:\n\nusing Oceananigans\n\n@inline uniform_stokes_shear(z, t, p) = p.uˢ * exp(z / p.h)\n\nstokes_drift_parameters = (uˢ = 0.005, h = 20)\nstokes_drift = UniformStokesDrift(∂z_uˢ=uniform_stokes_shear, parameters=stokes_drift_parameters)\n\n# output\n\nUniformStokesDrift with parameters (uˢ=0.005, h=20):\n├── ∂z_uˢ: uniform_stokes_shear\n├── ∂z_vˢ: zerofunction\n├── ∂t_uˢ: zerofunction\n└── ∂t_vˢ: zerofunction\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Time-steppers","page":"Library","title":"Time steppers","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.TimeSteppers]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.TimeSteppers.Clock","page":"Library","title":"Oceananigans.TimeSteppers.Clock","text":"mutable struct Clock{T, FT}\n\nKeeps track of the current time, last_Δt, iteration number, and time-stepping stage. The stage is updated only for multi-stage time-stepping methods. The time::T is either a number or a DateTime object.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TimeSteppers.Clock-Tuple{}","page":"Library","title":"Oceananigans.TimeSteppers.Clock","text":"Clock(; time, last_Δt=Inf, last_stage_Δt=Inf, iteration=0, stage=1)\n\nReturns a Clock object. By default, Clock is initialized to the zeroth iteration and first time step stage with last_Δt=last_stage_Δt=Inf.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper-Union{Tuple{IT}, Tuple{Any, Any}, Tuple{Any, Any, Any}} where IT","page":"Library","title":"Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper","text":"QuasiAdamsBashforth2TimeStepper(grid, tracers,\n                                χ = 0.1;\n                                implicit_solver = nothing,\n                                Gⁿ = TendencyFields(grid, tracers),\n                                G⁻ = TendencyFields(grid, tracers))\n\nReturn a 2nd-order quasi Adams-Bashforth (AB2) time stepper (QuasiAdamsBashforth2TimeStepper) on grid, with tracers, and AB2 parameter χ. The tendency fields Gⁿ and G⁻ can be specified via  optional kwargs.\n\nThe 2nd-order quasi Adams-Bashforth timestepper steps forward the state Uⁿ by Δt via\n\nUⁿ⁺¹ = Uⁿ + Δt * [(3/2 + χ) * Gⁿ - (1/2 + χ) * Gⁿ⁻¹]\n\nwhere Uⁿ is the state at the n-th timestep, Gⁿ is the tendency at the n-th timestep, and Gⁿ⁻¹ is the tendency at the previous timestep (G⁻).\n\nnote: First timestep\nFor the first timestep, since there are no saved tendencies from the previous timestep, the QuasiAdamsBashforth2TimeStepper performs an Euler timestep:Uⁿ⁺¹ = Uⁿ + Δt * Gⁿ\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.TimeSteppers.RungeKutta3TimeStepper","page":"Library","title":"Oceananigans.TimeSteppers.RungeKutta3TimeStepper","text":"RungeKutta3TimeStepper{FT, TG} <: AbstractTimeStepper\n\nHolds parameters and tendency fields for a low storage, third-order Runge-Kutta-Wray time-stepping scheme described by Le and Moin (1991).\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TimeSteppers.RungeKutta3TimeStepper-Union{Tuple{TG}, Tuple{TI}, Tuple{Any, Any}} where {TI, TG}","page":"Library","title":"Oceananigans.TimeSteppers.RungeKutta3TimeStepper","text":"RungeKutta3TimeStepper(grid, tracers;\n                       implicit_solver = nothing,\n                       Gⁿ = TendencyFields(grid, tracers),\n                       G⁻ = TendencyFields(grid, tracers))\n\nReturn a 3rd-order Runge0Kutta timestepper (RungeKutta3TimeStepper) on grid and with tracers. The tendency fields Gⁿ and G⁻ can be specified via  optional kwargs.\n\nThe scheme described by Le and Moin (1991). In a nutshel, the 3rd-order Runge Kutta timestepper steps forward the state Uⁿ by Δt via 3 substeps. A pressure correction step is applied after at each substep.\n\nThe state U after each substep m is\n\nUᵐ⁺¹ = Uᵐ + Δt * (γᵐ * Gᵐ + ζᵐ * Gᵐ⁻¹)\n\nwhere Uᵐ is the state at the m-th substep, Gᵐ is the tendency at the m-th substep, Gᵐ⁻¹ is the tendency at the previous substep, and constants γ¹ = 815, γ² = 512, γ³ = 34, ζ¹ = 0, ζ² = -1760, ζ³ = -512.\n\nThe state at the first substep is taken to be the one that corresponds to the n-th timestep, U¹ = Uⁿ, and the state after the third substep is then the state at the Uⁿ⁺¹ = U⁴.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.TimeSteppers.time_step!-Tuple{Oceananigans.AbstractModel{<:QuasiAdamsBashforth2TimeStepper}, Any}","page":"Library","title":"Oceananigans.TimeSteppers.time_step!","text":"time_step!(model::AbstractModel{<:QuasiAdamsBashforth2TimeStepper}, Δt; euler=false)\n\nStep forward model one time step Δt with a 2nd-order Adams-Bashforth method and pressure-correction substep. Setting euler=true will take a forward Euler time step. The tendencies are calculated by the update_step! at the end of the time_step! function.\n\nThe steps of the Quasi-Adams-Bashforth second-order (AB2) algorithm are:\n\nIf this the first time step (model.clock.iteration == 0), then call update_state! and calculate the tendencies.\nAdvance tracers in time and compute predictor velocities (including implicit vertical diffusion).\nSolve the elliptic equation for pressure (three dimensional for the non-hydrostatic model, two-dimensional for the hydrostatic model).\nCorrect the velocities based on the results of step 3.\nStore the old tendencies.\nUpdate the model state.\nCompute tendencies for the next time step\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.TimeSteppers.time_step!-Tuple{Oceananigans.AbstractModel{<:RungeKutta3TimeStepper}, Any}","page":"Library","title":"Oceananigans.TimeSteppers.time_step!","text":"time_step!(model::AbstractModel{<:RungeKutta3TimeStepper}, Δt)\n\nStep forward model one time step Δt with a 3rd-order Runge-Kutta method. The 3rd-order Runge-Kutta method takes three intermediate substep stages to achieve a single timestep. A pressure correction step is applied at each intermediate stage.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Turbulence-closures","page":"Library","title":"Turbulence closures","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.TurbulenceClosures]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation","page":"Library","title":"Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation","text":"AnisotropicMinimumDissipation{FT} <: AbstractTurbulenceClosure\n\nParameters for the \"anisotropic minimum dissipation\" turbulence closure for large eddy simulation proposed originally by Rozema et al. (2015) and Abkar et al. (2016), then modified by Verstappen (2018), and finally described and validated for by Vreugdenhil and Taylor (2018).\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation-Union{Tuple{}, Tuple{TD}, Tuple{TD, Any}} where TD","page":"Library","title":"Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation","text":"AnisotropicMinimumDissipation([time_discretization = ExplicitTimeDiscretization, FT = Float64;]\n                              C = 1/12, Cν = nothing, Cκ = nothing, Cb = nothing)\n\nReturn parameters of type FT for the AnisotropicMinimumDissipation turbulence closure.\n\nArguments\n\ntime_discretization: Either ExplicitTimeDiscretization() or VerticallyImplicitTimeDiscretization(),                         which integrates the terms involving only z-derivatives in the                        viscous and diffusive fluxes with an implicit time discretization.                        Default ExplicitTimeDiscretization().\nFT: Float type; default Float64.\n\nKeyword arguments\n\nC: Poincaré constant for both eddy viscosity and eddy diffusivities. C is overridden      for eddy viscosity or eddy diffusivity if Cν or Cκ are set, respecitvely.\nCν: Poincaré constant for momentum eddy viscosity.\nCκ: Poincaré constant for tracer eddy diffusivities. If one number or function, the same       number or function is applied to all tracers. If a NamedTuple, it must possess       a field specifying the Poncaré constant for every tracer.\nCb: Buoyancy modification multiplier (Cb = nothing turns it off, Cb = 1 was used by Abkar et al. (2016)).       Note: that we do not subtract the horizontally-average component before computing this       buoyancy modification term. This implementation differs from Abkar et al. (2016)'s proposal       and the impact of this approximation has not been tested or validated.\n\nBy default: C = Cν = Cκ = 1/12, which is appropriate for a finite-volume method employing a second-order advection scheme, and Cb = nothing, which turns off the buoyancy modification term.\n\nCν or Cκ may be numbers, or functions of x, y, z.\n\nExamples\n\njulia> using Oceananigans\n\njulia> pretty_diffusive_closure = AnisotropicMinimumDissipation(C=1/2)\nAnisotropicMinimumDissipation{ExplicitTimeDiscretization} turbulence closure with:\n           Poincaré constant for momentum eddy viscosity Cν: 0.5\n    Poincaré constant for tracer(s) eddy diffusivit(ies) Cκ: 0.5\n                        Buoyancy modification multiplier Cb: nothing\n\njulia> using Oceananigans\n\njulia> const Δz = 0.5; # grid resolution at surface\n\njulia> surface_enhanced_tracer_C(x, y, z) = 1/12 * (1 + exp((z + Δz/2) / 8Δz));\n\njulia> fancy_closure = AnisotropicMinimumDissipation(Cκ=surface_enhanced_tracer_C)\nAnisotropicMinimumDissipation{ExplicitTimeDiscretization} turbulence closure with:\n           Poincaré constant for momentum eddy viscosity Cν: 0.08333333333333333\n    Poincaré constant for tracer(s) eddy diffusivit(ies) Cκ: surface_enhanced_tracer_C\n                        Buoyancy modification multiplier Cb: nothing\n\njulia> using Oceananigans\n\njulia> tracer_specific_closure = AnisotropicMinimumDissipation(Cκ=(c₁=1/12, c₂=1/6))\nAnisotropicMinimumDissipation{ExplicitTimeDiscretization} turbulence closure with:\n           Poincaré constant for momentum eddy viscosity Cν: 0.08333333333333333\n    Poincaré constant for tracer(s) eddy diffusivit(ies) Cκ: (c₁ = 0.08333333333333333, c₂ = 0.16666666666666666)\n                        Buoyancy modification multiplier Cb: nothing\n\nReferences\n\nVreugdenhil C., and Taylor J. (2018), \"Large-eddy simulations of stratified plane Couette     flow using the anisotropic minimum-dissipation model\", Physics of Fluids 30, 085104.\n\nVerstappen, R. (2018), \"How much eddy dissipation is needed to counterbalance the nonlinear     production of small, unresolved scales in a large-eddy simulation of turbulence?\",     Computers & Fluids 176, pp. 276-284.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.ConvectiveAdjustmentVerticalDiffusivity","page":"Library","title":"Oceananigans.TurbulenceClosures.ConvectiveAdjustmentVerticalDiffusivity","text":"ConvectiveAdjustmentVerticalDiffusivity([time_discretization = VerticallyImplicitTimeDiscretization(), FT=Float64;]\n                                        convective_κz = 0,\n                                        convective_νz = 0,\n                                        background_κz = 0,\n                                        background_νz = 0)\n\nReturn a convective adjustment vertical diffusivity closure that applies different values of diffusivity and/or viscosity depending whether the region is statically stable (positive or zero buoyancy gradient) or statically unstable (negative buoyancy gradient).\n\nArguments\n\ntime_discretization: Either ExplicitTimeDiscretization() or VerticallyImplicitTimeDiscretization();                        default VerticallyImplicitTimeDiscretization().\nFT: Float type; default Float64.\n\nKeyword arguments\n\nconvective_κz: Vertical tracer diffusivity in regions with negative (unstable) buoyancy gradients. Either                  a single number, function, array, field, or tuple of diffusivities for each tracer.\nbackground_κz: Vertical tracer diffusivity in regions with zero or positive (stable) buoyancy gradients.\nconvective_νz: Vertical viscosity in regions with negative (unstable) buoyancy gradients. Either                 a number, function, array, or field.\nbackground_κz: Vertical viscosity in regions with zero or positive (stable) buoyancy gradients.\n\nExample\n\njulia> using Oceananigans\n\njulia> cavd = ConvectiveAdjustmentVerticalDiffusivity(convective_κz = 1)\nConvectiveAdjustmentVerticalDiffusivity{VerticallyImplicitTimeDiscretization}(background_κz=0.0 convective_κz=1 background_νz=0.0 convective_νz=0.0)\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization","page":"Library","title":"Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization","text":"struct ExplicitTimeDiscretization <: AbstractTimeDiscretization\n\nA fully-explicit time-discretization of a TurbulenceClosure.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.HorizontalDivergenceScalarDiffusivity","page":"Library","title":"Oceananigans.TurbulenceClosures.HorizontalDivergenceScalarDiffusivity","text":"HorizontalDivergenceScalarDiffusivity([time_discretization=ExplicitTimeDiscretization(),\n                                      FT::DataType=Float64;]\n                                      kwargs...)\n\nShorthand for a ScalarDiffusivity with HorizontalDivergenceFormulation(). See ScalarDiffusivity.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.HorizontalScalarDiffusivity","page":"Library","title":"Oceananigans.TurbulenceClosures.HorizontalScalarDiffusivity","text":"HorizontalScalarDiffusivity([time_discretization=ExplicitTimeDiscretization(),\n                            FT::DataType=Float64;]\n                            kwargs...)\n\nShorthand for a ScalarDiffusivity with HorizontalFormulation(). See ScalarDiffusivity.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.IsopycnalSkewSymmetricDiffusivity-Union{Tuple{}, Tuple{TD}, Tuple{TD, Any}} where TD","page":"Library","title":"Oceananigans.TurbulenceClosures.IsopycnalSkewSymmetricDiffusivity","text":"IsopycnalSkewSymmetricDiffusivity([time_disc=VerticallyImplicitTimeDiscretization(), FT=Float64;]\n                                  κ_skew = 0,\n                                  κ_symmetric = 0,\n                                  isopycnal_tensor = SmallSlopeIsopycnalTensor(),\n                                  slope_limiter = FluxTapering(1e-2))\n\nReturn parameters for an isopycnal skew-symmetric tracer diffusivity with skew diffusivity κ_skew and symmetric diffusivity κ_symmetric that uses an isopycnal_tensor model for for calculating the isopycnal slopes, and (optionally) applying a slope_limiter to the calculated isopycnal slope values.\n\nBoth κ_skew and κ_symmetric may be constants, arrays, fields, or functions of (x, y, z, t).\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.RiBasedVerticalDiffusivity","page":"Library","title":"Oceananigans.TurbulenceClosures.RiBasedVerticalDiffusivity","text":"RiBasedVerticalDiffusivity([time_discretization = VerticallyImplicitTimeDiscretization(),\n                           FT = Float64;]\n                           Ri_dependent_tapering = HyperbolicTangentRiDependentTapering(),\n                           horizontal_Ri_filter = nothing,\n                           minimum_entrainment_buoyancy_gradient = 1e-10,\n                           maximum_diffusivity = Inf,\n                           maximum_viscosity = Inf,\n                           ν₀  = 0.7,\n                           κ₀  = 0.5,\n                           κᶜᵃ = 1.7,\n                           Cᵉⁿ = 0.1,\n                           Cᵃᵛ = 0.6,\n                           Ri₀ = 0.1,\n                           Riᵟ = 0.4,\n                           warning = true)\n\nReturn a closure that estimates the vertical viscosity and diffusivity from \"convective adjustment\" coefficients ν₀ and κ₀ multiplied by a decreasing function of the Richardson number, Ri. \n\nArguments\n\ntime_discretization: Either ExplicitTimeDiscretization() or VerticallyImplicitTimeDiscretization(),                         which integrates the terms involving only z-derivatives in the                        viscous and diffusive fluxes with an implicit time discretization.                        Default VerticallyImplicitTimeDiscretization().\nFT: Float type; default Float64.\n\nKeyword arguments\n\nRi_dependent_tapering: The Ri-dependent tapering. Options are: PiecewiseLinearRiDependentTapering(), HyperbolicTangentRiDependentTapering() (default), and ExponentialRiDependentTapering().\nν₀: Non-convective viscosity (units of kinematic viscosity, typically m² s⁻¹).\nκ₀: Non-convective diffusivity for tracers (units of diffusivity, typically m² s⁻¹).\nκᶜᵃ: Convective adjustment diffusivity for tracers (units of diffusivity, typically m² s⁻¹).\nCᵉⁿ: Entrainment coefficient for tracers (non-dimensional).        Set Cᵉⁿ = 0 to turn off the penetrative entrainment diffusivity.\nCᵃᵛ: Time-averaging coefficient for viscosity and diffusivity (non-dimensional).\nRi₀: Ri threshold for decreasing viscosity and diffusivity (non-dimensional).\nRiᵟ: Ri-width over which viscosity and diffusivity decreases to 0 (non-dimensional).\nminimum_entrainment_buoyancy_gradient: Minimum buoyancy gradient for application of the entrainment                                          diffusvity. If the entrainment buoyancy gradient is less than the                                          minimum value, the entrainment diffusivity is 0. Units of                                           buoyancy gradient (typically s⁻²).\nmaximum_diffusivity: A limiting maximum tracer diffusivity (units of diffusivity, typically m² s⁻¹).\nmaximum_viscosity: A limiting maximum viscosity (units of kinematic viscosity, typically m² s⁻¹).\nhorizontal_Ri_filter: Horizontal filter to apply to Ri, which can help alleviate noise for                         some simulations. The default is nothing, or no filtering. The other                         option is horizontal_Ri_filter = FivePointHorizontalFilter().\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.ScalarBiharmonicDiffusivity","page":"Library","title":"Oceananigans.TurbulenceClosures.ScalarBiharmonicDiffusivity","text":"ScalarBiharmonicDiffusivity(formulation = ThreeDimensionalFormulation(), FT = Float64;\n                            ν = 0,\n                            κ = 0,\n                            discrete_form = false,\n                            loc = (nothing, nothing, nothing),\n                            parameters = nothing)\n\nReturn a scalar biharmonic diffusivity turbulence closure with viscosity coefficient ν and tracer diffusivities κ for each tracer field in tracers. If a single κ is provided, it is applied to all tracers. Otherwise κ must be a NamedTuple with values for every tracer individually.\n\nArguments\n\nformulation:\nHorizontalFormulation() for diffusivity applied in the horizontal direction(s)\nVerticalFormulation() for diffusivity applied in the vertical direction,\nThreeDimensionalFormulation() (default) for diffusivity applied isotropically to all directions\nFT: the float datatype (default: Float64)\n\nKeyword arguments\n\nν: Viscosity. Number, AbstractArray, Field, or Function.\nκ: Diffusivity. Number, AbstractArray, Field, Function, or      NamedTuple of diffusivities with entries for each tracer.\ndiscrete_form: Boolean; default: false.\nrequired_halo_size = 2: the required halo size for the closure. This value should be an integer. change only if using a function for ν or κ that requires a halo size larger than 1 to compute.\n\nWhen prescribing the viscosities or diffusivities as functions, depending on the value of keyword argument discrete_form, the constructor expects:\n\ndiscrete_form = false (default): functions of the grid's native coordinates and time, e.g., (x, y, z, t) for a RectilinearGrid or (λ, φ, z, t) for a LatitudeLongitudeGrid.\ndiscrete_form = true:\nwith loc = (nothing, nothing, nothing) (default): functions of (i, j, k, grid, ℓx, ℓy, ℓz) with ℓx, ℓy, and ℓz either Face() or Center().\nwith loc = (ℓx, ℓy, ℓz) with ℓx, ℓy, and ℓz either Face() or Center(): functions of (i, j, k, grid).\nparameters: NamedTuple with parameters used by the functions that compute viscosity and/or diffusivity; default: nothing.\n\nFor examples see ScalarDiffusivity.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.ScalarBiharmonicDiffusivity-2","page":"Library","title":"Oceananigans.TurbulenceClosures.ScalarBiharmonicDiffusivity","text":"struct ScalarBiharmonicDiffusivity{F, N, K} <: AbstractScalarBiharmonicDiffusivity{F}\n\nHolds viscosity and diffusivities for models with prescribed isotropic diffusivities.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.ScalarDiffusivity","page":"Library","title":"Oceananigans.TurbulenceClosures.ScalarDiffusivity","text":"ScalarDiffusivity(time_discretization = ExplicitTimeDiscretization(),\n                  formulation = ThreeDimensionalFormulation(), FT = Float64;\n                  ν = 0,\n                  κ = 0,\n                  discrete_form = false,\n                  loc = (nothing, nothing, nothing),\n                  parameters = nothing)\n\nReturn ScalarDiffusivity turbulence closure with viscosity ν and tracer diffusivities κ for each tracer field in tracers. If a single κ is provided, it is applied to all tracers. Otherwise κ must be a NamedTuple with values for every tracer individually.\n\nArguments\n\ntime_discretization: either ExplicitTimeDiscretization() (default) or VerticallyImplicitTimeDiscretization().\nformulation:\nHorizontalFormulation() for diffusivity applied in the horizontal direction(s)\nVerticalFormulation() for diffusivity applied in the vertical direction,\nThreeDimensionalFormulation() (default) for diffusivity applied isotropically to all directions\nFT: the float datatype (default: Float64)\n\nKeyword arguments\n\nν: Viscosity. Number, AbstractArray, Field, or Function.\nκ: Diffusivity. Number, AbstractArray, Field, Function, or      NamedTuple of diffusivities with entries for each tracer.\ndiscrete_form: Boolean; default: false.\n\nWhen prescribing the viscosities or diffusivities as functions, depending on the value of keyword argument discrete_form, the constructor expects:\n\ndiscrete_form = false (default): functions of the grid's native coordinates and time, e.g., (x, y, z, t) for a RectilinearGrid or (λ, φ, z, t) for a LatitudeLongitudeGrid.\ndiscrete_form = true:\nwith loc = (nothing, nothing, nothing) and parameters = nothing (default): functions of (i, j, k, grid, ℓx, ℓy, ℓz, clock, fields) with ℓx, ℓy, and ℓz either Face() or Center().\nwith loc = (ℓx, ℓy, ℓz) with ℓx, ℓy, and ℓz either Face() or Center() and parameters = nothing: functions of (i, j, k, grid, clock, fields).\nwith loc = (nothing, nothing, nothing) and specified parameters: functions of (i, j, k, grid, ℓx, ℓy, ℓz, clock, fields, parameters).\nwith loc = (ℓx, ℓy, ℓz) and specified parameters: functions of (i, j, k, grid, clock, fields, parameters).\nrequired_halo_size = 1: the required halo size for the closure. This value should be an integer. change only if using a function for ν or κ that requires a halo size larger than 1 to compute.\nparameters: NamedTuple with parameters used by the functions that compute viscosity and/or diffusivity; default: nothing.\n\nExamples\n\njulia> using Oceananigans\n\njulia> ScalarDiffusivity(ν=1000, κ=2000)\nScalarDiffusivity{ExplicitTimeDiscretization}(ν=1000.0, κ=2000.0)\n\njulia> const depth_scale = 100;\n\njulia> @inline ν(x, y, z) = 1000 * exp(z / depth_scale)\nν (generic function with 1 method)\n\njulia> ScalarDiffusivity(ν=ν)\nScalarDiffusivity{ExplicitTimeDiscretization}(ν=ν (generic function with 1 method), κ=0.0)\n\njulia> using Oceananigans.Grids: znode\n\njulia> @inline function κ(i, j, k, grid, ℓx, ℓy, ℓz, clock, fields)\n           z = znode(i, j, k, grid, ℓx, ℓy, ℓz)\n           return 2000 * exp(z / depth_scale)\n       end\nκ (generic function with 1 method)\n\njulia> ScalarDiffusivity(κ=κ, discrete_form=true)\nScalarDiffusivity{ExplicitTimeDiscretization}(ν=0.0, κ=Oceananigans.TurbulenceClosures.DiscreteDiffusionFunction{Nothing, Nothing, Nothing, Nothing, typeof(κ)})\n\njulia> @inline function another_κ(i, j, k, grid, clock, fields, p)\n           z = znode(i, j, k, grid, Center(), Center(), Face())\n           return 2000 * exp(z / p.depth_scale)\n       end\nanother_κ (generic function with 1 method)\n\njulia> ScalarDiffusivity(κ=another_κ, discrete_form=true, loc=(Center, Center, Face), parameters=(; depth_scale = 120.0))\nScalarDiffusivity{ExplicitTimeDiscretization}(ν=0.0, κ=Oceananigans.TurbulenceClosures.DiscreteDiffusionFunction{Center, Center, Face, @NamedTuple{depth_scale::Float64}, typeof(another_κ)})\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.SmagorinskyLilly-Union{Tuple{}, Tuple{TD}, Tuple{TD, Any}} where TD","page":"Library","title":"Oceananigans.TurbulenceClosures.SmagorinskyLilly","text":"SmagorinskyLilly([time_discretization::TD = ExplicitTimeDiscretization(), FT=Float64;] C=0.16, Cb=1.0, Pr=1.0)\n\nReturn a SmagorinskyLilly type associated with the turbulence closure proposed by Lilly (1962), Smagorinsky (1958), Smagorinsky (1963), and Lilly (1966), which has an eddy viscosity of the form\n\nνₑ = (C * Δᶠ)² * √(2Σ²) * √(1 - Cb * N² / Σ²)\n\nand an eddy diffusivity of the form\n\nκₑ = νₑ / Pr\n\nwhere Δᶠ is the filter width, Σ² = ΣᵢⱼΣᵢⱼ is the double dot product of the strain tensor Σᵢⱼ, Pr is the turbulent Prandtl number, N² is the total buoyancy gradient, and Cb is a constant the multiplies the Richardson number modification to the eddy viscosity.\n\nArguments\n\ntime_discretization: Either ExplicitTimeDiscretization() or VerticallyImplicitTimeDiscretization(),                         which integrates the terms involving only z-derivatives in the                        viscous and diffusive fluxes with an implicit time discretization.                        Default ExplicitTimeDiscretization().\nFT: Float type; default Float64.\n\nKeyword arguments\n\nC: Smagorinsky constant. Default value is 0.16 as obtained by Lilly (1966).\nCb: Buoyancy term multipler based on Lilly (1962) (Cb = 0 turns it off, Cb ≠ 0 turns it on.       Typically, and according to the original work by Lilly (1962), Cb = 1 / Pr.)\nPr: Turbulent Prandtl numbers for each tracer. Either a constant applied to every       tracer, or a NamedTuple with fields for each tracer individually.\n\nReferences\n\nSmagorinsky, J. \"On the numerical integration of the primitive equations of motion for     baroclinic flow in a closed region.\" Monthly Weather Review (1958)\n\nLilly, D. K. \"On the numerical simulation of buoyant convection.\" Tellus (1962)\n\nSmagorinsky, J. \"General circulation experiments with the primitive equations: I.     The basic experiment.\" Monthly Weather Review (1963)\n\nLilly, D. K. \"The representation of small-scale turbulence in numerical simulation experiments.\"      NCAR Manuscript No. 281, 0, (1966)\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.TwoDimensionalLeith","page":"Library","title":"Oceananigans.TurbulenceClosures.TwoDimensionalLeith","text":"TwoDimensionalLeith(FT=Float64;\n                    C=0.3, C_Redi=1, C_GM=1,\n                    isopycnal_model=SmallSlopeIsopycnalTensor())\n\nReturn a TwoDimensionalLeith type associated with the turbulence closure proposed by Leith (1968) and Fox-Kemper and Menemenlis (2008) which has an eddy viscosity of the form\n\nνₑ = (C * Δᶠ)³ * √(|∇ₕ ζ|² + |∇ₕ ∂w/∂z|²)\n\nand an eddy diffusivity of the form...\n\nwhere Δᶠ is the filter width, ζ = ∂v/∂x - ∂u/∂y is the vertical vorticity, and C is a model constant.\n\nKeyword arguments\n\nC: Model constant\nC_Redi: Coefficient for down-gradient tracer diffusivity for each tracer.           Either a constant applied to every tracer, or a NamedTuple with fields           for each tracer individually.\nC_GM: Coefficient for down-gradient tracer diffusivity for each tracer.         Either a constant applied to every tracer, or a NamedTuple with fields         for each tracer individually.\n\nReferences\n\nLeith, C. E. (1968). \"Diffusion Approximation for Two‐Dimensional Turbulence\", The Physics of     Fluids 11, 671. doi: 10.1063/1.1691968\n\nFox‐Kemper, B., & D. Menemenlis (2008), \"Can large eddy simulation techniques improve mesoscale rich     ocean models?\", in Ocean Modeling in an Eddying Regime, Geophys. Monogr. Ser., 177, pp. 319–337.     doi: 10.1029/177GM19\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.VerticalScalarDiffusivity","page":"Library","title":"Oceananigans.TurbulenceClosures.VerticalScalarDiffusivity","text":"VerticalScalarDiffusivity([time_discretization=ExplicitTimeDiscretization(),\n                          FT::DataType=Float64;]\n                          kwargs...)\n\nShorthand for a ScalarDiffusivity with VerticalFormulation(). See ScalarDiffusivity.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.VerticallyImplicitTimeDiscretization","page":"Library","title":"Oceananigans.TurbulenceClosures.VerticallyImplicitTimeDiscretization","text":"struct VerticallyImplicitTimeDiscretization <: AbstractTimeDiscretization\n\nA vertically-implicit time-discretization of a TurbulenceClosure.\n\nThis implies that a flux divergence such as   𝐪 at the n-th timestep is  time-discretized as\n\n[∇ ⋅ q]ⁿ = [explicit_flux_divergence]ⁿ + [∂z (κ ∂z c)]ⁿ⁺¹\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.diffusivity","page":"Library","title":"Oceananigans.TurbulenceClosures.diffusivity","text":"diffusivity(closure, tracer_index, diffusivity_fields)\n\nReturns the scalar diffusivity associated with closure and tracer_index.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.TurbulenceClosures.viscosity","page":"Library","title":"Oceananigans.TurbulenceClosures.viscosity","text":"viscosity(closure, diffusivities)\n\nReturns the scalar viscosity associated with closure.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Utilities","page":"Library","title":"Utilities","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Utils]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.Utils.AndSchedule-Tuple","page":"Library","title":"Oceananigans.Utils.AndSchedule","text":"AndSchedule(schedules...)\n\nReturn a schedule that actuates when all child_schedules actuate.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Utils.IterationInterval-Tuple{Any}","page":"Library","title":"Oceananigans.Utils.IterationInterval","text":"IterationInterval(interval; offset=0)\n\nReturn a callable IterationInterval that \"actuates\" (schedules output or callback execution) whenever the model iteration (modified by offset) is a multiple of interval.\n\nFor example, \n\nIterationInterval(100) actuates at iterations [100, 200, 300, ...].\nIterationInterval(100, offset=-1) actuates at iterations [99, 199, 299, ...].\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Utils.KernelParameters-Tuple{Any, Any}","page":"Library","title":"Oceananigans.Utils.KernelParameters","text":"KernelParameters(size, offsets)\n\nReturn parameters for kernel launching and execution that define (i) a tuple that defines the size of the kernel being launched and (ii) a tuple of offsets that offset loop indices. For example, offsets = (0, 0, 0) with size = (N, N, N) means all indices loop from 1:N. If offsets = (1, 1, 1), then all indices loop from  2:N+1. And so on.\n\nExample\n\nsize = (8, 6, 4)\noffsets = (0, 1, 2)\nkp = KernelParameters(size, offsets)\n\n# Launch a kernel with indices that range from i=1:8, j=2:7, k=3:6,\n# where i, j, k are the first, second, and third index, respectively:\n\nlaunch!(arch, grid, kp, kernel!, kernel_args...)\n\nSee launch!.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Utils.KernelParameters-Tuple{UnitRange}","page":"Library","title":"Oceananigans.Utils.KernelParameters","text":"KernelParameters(range1, [range2, range3])\n\nReturn parameters for launching a kernel of up to three dimensions, where the indices spanned by the kernel in each dimension are given by (range1, range2, range3).\n\nExample\n\nkp = KernelParameters(1:4, 0:10)\n\n# Launch a kernel with indices that range from i=1:4, j=0:10,\n# where i, j are the first and second index, respectively.\nlaunch!(arch, grid, kp, kernel!, kernel_args...)\n\nSee the documentation for launch!.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Utils.MultiRegionObject-Tuple{Tuple}","page":"Library","title":"Oceananigans.Utils.MultiRegionObject","text":"MultiRegionObject(regional_objects::Tuple; devices)\n\nReturn a MultiRegionObject\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Utils.OrSchedule-Tuple","page":"Library","title":"Oceananigans.Utils.OrSchedule","text":"OrSchedule(schedules...)\n\nReturn a schedule that actuates when any of the child_schedules actuates.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Utils.SpecifiedTimes-Union{Tuple{Vararg{T}}, Tuple{T}} where T<:Number","page":"Library","title":"Oceananigans.Utils.SpecifiedTimes","text":"SpecifiedTimes(times)\n\nReturn a callable TimeInterval that \"actuates\" (schedules output or callback execution) whenever the model's clock equals the specified values in times. For example, \n\nSpecifiedTimes([1, 15.3]) actuates when model.clock.time is 1 and 15.3.\n\ninfo: Sorting specified times\nThe specified times need not be ordered as the SpecifiedTimes constructor will check and order them in ascending order if needed.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Utils.TimeInterval","page":"Library","title":"Oceananigans.Utils.TimeInterval","text":"struct TimeInterval <: AbstractSchedule\n\nCallable TimeInterval schedule for periodic output or diagnostic evaluation according to model.clock.time.\n\n\n\n\n\n","category":"type"},{"location":"appendix/library/#Oceananigans.Utils.TimeInterval-Tuple{Any}","page":"Library","title":"Oceananigans.Utils.TimeInterval","text":"TimeInterval(interval)\n\nReturn a callable TimeInterval that schedules periodic output or diagnostic evaluation on a interval of simulation time, as kept by model.clock.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Utils.WallTimeInterval-Tuple{Any}","page":"Library","title":"Oceananigans.Utils.WallTimeInterval","text":"WallTimeInterval(interval; start_time = time_ns() * 1e-9)\n\nReturn a callable WallTimeInterval that schedules periodic output or diagnostic evaluation on a interval of \"wall time\" while a simulation runs, in units of seconds.\n\nThe \"wall time\" is the actual real world time in seconds, as kept by an actual or hypothetical clock hanging on your wall.\n\nThe keyword argument start_time can be used to specify a starting wall time other than the moment WallTimeInterval is constructed.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Utils.configure_kernel-NTuple{4, Any}","page":"Library","title":"Oceananigans.Utils.configure_kernel","text":"configure_kernel(arch, grid, workspec, kernel!;\n                 exclude_periphery = false,\n                 reduced_dimensions = (),\n                 location = nothing,\n                 active_cells_map = nothing,\n                 only_local_halos = false,\n                 async = false)\n\nConfigure kernel! to launch over the dims of grid on the architecture arch.\n\nArguments\n\n============\n\narch: The architecture on which the kernel will be launched.\ngrid: The grid on which the kernel will be executed.\nworkspec: The workspec that defines the work distribution.\nkernel!: The kernel function to be executed.\n\nKeyword Arguments\n\n====================\n\ninclude_right_boundaries: A boolean indicating whether to include right boundaries (N + 1). Default is false.\nreduced_dimensions: A tuple specifying the dimensions to be reduced in the work distribution. Default is an empty tuple.\nlocation: The location of the kernel execution, needed for include_right_boundaries. Default is nothing.\nactive_cells_map: A map indicating the active cells in the grid. If the map is not a nothing, the workspec will be disregarded and                      the kernel is configured as a linear kernel with a worksize equal to the length of the active cell map. Default is nothing.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Utils.launch!-Tuple","page":"Library","title":"Oceananigans.Utils.launch!","text":"launch!(arch, grid, workspec, kernel!, kernel_args...; kw...)\n\nLaunches kernel! with arguments kernel_args over the dims of grid on the architecture arch. Kernels run on the default stream.\n\nSee configure_kernel for more information and also a list of the keyword arguments kw.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Utils.pretty_filesize","page":"Library","title":"Oceananigans.Utils.pretty_filesize","text":"pretty_filesize(s, suffix=\"B\")\n\nConvert a floating point value s representing a file size to a more human-friendly formatted string with one decimal places with a suffix defaulting to \"B\". Depending on the value of s the string will be formatted to show s using an SI prefix from bytes, kiB (1024 bytes), MiB (1024² bytes), and so on up to YiB (1024⁸ bytes).\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.Utils.prettytime","page":"Library","title":"Oceananigans.Utils.prettytime","text":"prettytime(t, longform=true)\n\nConvert a floating point value t representing an amount of time in SI units of seconds to a human-friendly string with three decimal places. Depending on the value of t the string will be formatted to show t in nanoseconds (ns), microseconds (μs), milliseconds (ms), seconds, minutes, hours, or days.\n\nWith longform=false, we use s, m, hrs, and d in place of seconds, minutes, and hours.\n\n\n\n\n\n","category":"function"},{"location":"appendix/library/#Oceananigans.Utils.with_tracers-Tuple{Any, NamedTuple, Any}","page":"Library","title":"Oceananigans.Utils.with_tracers","text":"with_tracers(tracer_names, initial_tuple, tracer_default)\n\nCreate a tuple corresponding to the solution variables u, v, w, and tracer_names. initial_tuple is a NamedTuple that at least has fields u, v, and w, and may have some fields corresponding to the names in tracer_names. tracer_default is a function that produces a default tuple value for each tracer if not included in initial_tuple.\n\n\n\n\n\n","category":"method"},{"location":"appendix/library/#Oceananigans.Utils.@apply_regionally-Tuple{Any}","page":"Library","title":"Oceananigans.Utils.@apply_regionally","text":"@apply_regionally expr\n\nDistributes locally the function calls in expression\n\nIt calls apply_regionally! when the functions do not return anything.\n\nIn case the function in expr returns something, @apply_regionally calls construct_regionally.\n\n\n\n\n\n","category":"macro"},{"location":"appendix/library/#Units","page":"Library","title":"Units","text":"","category":"section"},{"location":"appendix/library/","page":"Library","title":"Library","text":"Modules = [Oceananigans.Units]\nPrivate = false","category":"page"},{"location":"appendix/library/#Oceananigans.Units.GiB","page":"Library","title":"Oceananigans.Units.GiB","text":"GiB\n\nA Float64 constant equal to 1024MiB. Useful for increasing the clarity of scripts, e.g. max_filesize = 50GiB.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.KiB","page":"Library","title":"Oceananigans.Units.KiB","text":"KiB\n\nA Float64 constant equal to 1024.0. Useful for increasing the clarity of scripts, e.g. max_filesize = 250KiB.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.MiB","page":"Library","title":"Oceananigans.Units.MiB","text":"MiB\n\nA Float64 constant equal to 1024KiB. Useful for increasing the clarity of scripts, e.g. max_filesize = 100MiB.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.TiB","page":"Library","title":"Oceananigans.Units.TiB","text":"TiB\n\nA Float64 constant equal to 1024GiB. Useful for increasing the clarity of scripts, e.g. max_filesize = 2TiB.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.day","page":"Library","title":"Oceananigans.Units.day","text":"day\n\nA Float64 constant equal to 24hours. Useful for increasing the clarity of scripts, e.g. stop_time = 1day.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.days","page":"Library","title":"Oceananigans.Units.days","text":"days\n\nA Float64 constant equal to 24hours. Useful for increasing the clarity of scripts, e.g. stop_time = 7days.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.hour","page":"Library","title":"Oceananigans.Units.hour","text":"hour\n\nA Float64 constant equal to 60minutes. Useful for increasing the clarity of scripts, e.g. Δt = 1hour.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.hours","page":"Library","title":"Oceananigans.Units.hours","text":"hours\n\nA Float64 constant equal to 60minutes. Useful for increasing the clarity of scripts, e.g. Δt = 3hours.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.kilometer","page":"Library","title":"Oceananigans.Units.kilometer","text":"kilometer\n\nA Float64 constant equal to 1000meters. Useful for increasing the clarity of scripts, e.g. Lx = 1kilometer.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.kilometers","page":"Library","title":"Oceananigans.Units.kilometers","text":"kilometers\n\nA Float64 constant equal to 1000meters. Useful for increasing the clarity of scripts, e.g. Lx = 5000kilometers.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.meter","page":"Library","title":"Oceananigans.Units.meter","text":"meter\n\nA Float64 constant equal to 1.0. Useful for increasing the clarity of scripts, e.g. Lx = 1meter.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.meters","page":"Library","title":"Oceananigans.Units.meters","text":"meters\n\nA Float64 constant equal to 1.0. Useful for increasing the clarity of scripts, e.g. Lx = 50meters.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.minute","page":"Library","title":"Oceananigans.Units.minute","text":"minute\n\nA Float64 constant equal to 60seconds. Useful for increasing the clarity of scripts, e.g. Δt = 1minute.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.minutes","page":"Library","title":"Oceananigans.Units.minutes","text":"minutes\n\nA Float64 constant equal to 60seconds. Useful for increasing the clarity of scripts, e.g. Δt = 15minutes.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.second","page":"Library","title":"Oceananigans.Units.second","text":"second\n\nA Float64 constant equal to 1.0. Useful for increasing the clarity of scripts, e.g. Δt = 1second.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.seconds","page":"Library","title":"Oceananigans.Units.seconds","text":"seconds\n\nA Float64 constant equal to 1.0. Useful for increasing the clarity of scripts, e.g. Δt = 7seconds.\n\n\n\n\n\n","category":"constant"},{"location":"appendix/library/#Oceananigans.Units.Time","page":"Library","title":"Oceananigans.Units.Time","text":"Time(t)\n\nReturn a time \"selector\" at the continuous time t for linearly interpolating FieldTimeSeries.\n\nExamples\n\n# Interpolate `field_time_series` to `t=0.1`, returning `interpolated::Field`\ninterpolated = field_time_series[Time(0.1)]\n\n# Interpolate `field_time_series` at `i, j, k` and `t=0.1`\ninterpolated_ijk = field_time_series[i, j, k, Time(0.1)]\n\n\n\n\n\n","category":"type"},{"location":"numerical_implementation/time_stepping/#time_stepping","page":"Time stepping","title":"Time-stepping and the fractional step method","text":"","category":"section"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"With the pressure decomposition as discussed, the momentum evolves via:","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"    beginequation\n    labeleqmomentum-time-derivative\n    partial_t boldsymbolv = boldsymbolG_boldsymbolv - boldsymbolnabla p_rmnon  \n    endequation","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"where, e.g., for the non-hydrostatic model (ignoring background velocities and surface-wave effects)","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"boldsymbolG_boldsymbolv equiv - boldsymbolnabla_h p_rmhyd \n                       - left ( boldsymbolv boldsymbolcdot boldsymbolnabla right ) boldsymbolv \n                       - boldsymbolf times boldsymbolv \n                       + boldsymbolnabla boldsymbolcdot boldsymboltau \n                       + boldsymbolF_boldsymbolv","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"collects all terms on the right side of the momentum equation \\eqref{eq:momentum-time-derivative}, except the  contribution of non-hydrostatic pressure boldsymbolnabla p_rmnon.","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"The time-integral of the momentum equation \\eqref{eq:momentum-time-derivative} from time step n at t = t_n to time step n+1 at t_n+1 is:","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"    beginequation\n    labeleqmomentum-time-integral\n    boldsymbolv^n+1 - boldsymbolv^n = \n        int_t_n^t_n+1 Big  - boldsymbolnabla p_rmnon + boldsymbolG_boldsymbolv Big   mathrmd t  \n    endequation","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"where the superscript n and n+1 imply evaluation at t_n and t_n+1, such that  boldsymbolv^n equiv boldsymbolv(t=t_n). The crux of the fractional step method is  to treat the pressure term boldsymbolnabla p_rmnon implicitly using the approximation","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"    beginalign\n    labeleqpnon_implicit\n    int_t_n^t_n+1 boldsymbolnabla p_rmnon  mathrmd t approx\n        Delta t boldsymbolnabla p_rmnon^n+1  \n    endalign","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"while treating the rest of the terms on the right hand side of \\eqref{eq:momentum-time-integral}  explicitly. The implicit treatment of pressure ensures that the velocity field obtained at  time step n+1 is divergence-free.","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"To effect such a fractional step method, we define an intermediate velocity field boldsymbolv^star such that","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"    beginequation\n    labeleqintermediate-velocity-field\n    boldsymbolv^star - boldsymbolv^n = int_t_n^t_n+1 boldsymbolG_boldsymbolv  mathrmd t  \n    endequation","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"The integral on the right of the equation for boldsymbolv^star may be approximated by a variety of explicit methods. For example, a forward Euler method approximates the integral via","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"    beginequation\n    int_t_n^t_n+1 G  mathrmd t approx Delta t G^n  \n    labeleqforward-euler\n    endequation","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"for any time-dependent function G(t), while a second-order Adams-Bashforth method uses the approximation","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"    beginequation\n    labeleqadams-bashforth\n    int_t_n^t_n+1 G  mathrmd t approx\n        Delta t left  left ( tfrac32 + chi right ) G^n \n        - left ( tfrac12 + chi right ) G^n-1 right   \n    endequation","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"where chi is a parameter. Ascher et al. (1995) claim that chi = tfrac18 is optimal;  chi = -tfrac12 yields the forward Euler scheme.","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"Combining the equation \\eqref{eq:intermediate-velocity-field} for boldsymbolv^star and the time integral of the non-hydrostatic pressure \\eqref{eq:pnon_implicit} yields","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"    beginequation\n    labeleqfractional-step\n    boldsymbolv^n+1 - boldsymbolv^star = - Delta t boldsymbolnabla p_rmnon^n+1  \n    endequation","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"Taking the divergence of fractional step equation \\eqref{eq:fractional-step} and requiring that  boldsymbolnabla boldsymbolcdot boldsymbolv^n+1 = 0 yields a Poisson equation  for the kinematic pressure p_rmnon at time-step n+1:","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"    beginequation\n    labeleqpressure-poisson\n    nabla^2 p_rmnon^n+1 = fracboldsymbolnabla boldsymbolcdot boldsymbolv^starDelta t  \n    endequation","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"With boldsymbolv^star in hand we can invert \\eqref{eq:pressure-poisson} to get p_rmnon^n+1 and then boldsymbolv^n+1 is computed via the fractional step equation \\eqref{eq:fractional-step}.","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"Tracers are stepped forward explicitly via","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"    beginequation\n    labeleqtracer-timestep\n    c^n+1 - c^n = int_t_n^t_n+1 G_c  mathrmd t  \n    endequation","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"where ","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"    beginequation\n    G_c equiv - boldsymbolnabla boldsymbolcdot left ( boldsymbolv c right ) - boldsymbolnabla boldsymbolcdot boldsymbolq_c + F_c  \n    endequation","category":"page"},{"location":"numerical_implementation/time_stepping/","page":"Time stepping","title":"Time stepping","text":"and the same forward Euler or Adams-Bashforth scheme as for the explicit evaluation of the time-integral of boldsymbolG_u is used to evaluate the integral of G_c.","category":"page"},{"location":"numerical_implementation/turbulence_closures/#numerical_closures","page":"Turbulence closures","title":"Turbulence closures","text":"","category":"section"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"To truly simulate and resolve turbulence at high Reynolds number (so basically all interesting flows) would require you resolve all motions down to the Kolmogorov (1941) length scale eta = (nu^3  varepsilon)^14 where nu is the kinematic viscosity and varepsilon the average rate of dissipation of turbulence kinetic energy per unit mass.","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"As pointed out way back by Corrsin (1961), to run a simulation on a horizontal domain about 10 times the size of an \"average eddy\" with 100 vertical levels and where the grid spacing is given by eta would require the computer to store on the order of 10^14 variables.[1] This is still impractical today, although may be within reach in less than a decade. He ends by suggesting the use of an analog rather digital computer–-a tank of water.","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"[1]: And even then, eta gives the maximum allowable grid spacing. There is significant flow structure smaller than eta.","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"To have any hope of simulating high Reynolds number flows we need some way of resolving the sub-grid scale motions.[2]","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"[2]: In reality there is no need to resolve all motions down to the Kolmogorov length scale to achieve acceptable accuracy. Perhaps good results can be achieved if 80\\% of the kinetic energy is resolved (§13) (Pope, 2000).","category":"page"},{"location":"numerical_implementation/turbulence_closures/#Reynolds-averaged-Navier–Stokes-equations","page":"Turbulence closures","title":"Reynolds-averaged Navier–Stokes equations","text":"","category":"section"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"Following Reynolds (1895), we can decompose flow variables such as velocity boldsymbolv into the mean component overlineboldsymbolv and the fluctuating component boldsymbolv^prime so that boldsymbolv = overlineboldsymbolv + boldsymbolv^prime [see §4 of Pope (2000) for a modern discussion].","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"Expressing the Navier-Stokes equations in tensor notation","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"beginalign\n    partial_i v_i = 0   \n    partial_t v_i + v_j partial_j v_i = f_i - alphapartial_i p + nu partial_j partial_j v_i  \nendalign","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"where alpha = rho^-1 is the specific volume and f_i represents external forces. We can plug in the Reynolds decomposition for boldsymbolv and after some manipulation arrive at the following form for the Reynolds-averaged Navier-Stokes equations","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"beginalign\n    partial_i overlineu_i = 0   \n    partial_t overlineu_i + overlineu_j partial_j overlineu_i = overlinef_i -\n    partial_j left(-alphaoverlinepdelta_ij + 2nu overlineS_ij - overlinev_i^prime v_j^primeright)  \nendalign","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"where","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"overlineS_ij = frac12 ( partial_j overlineu_i + partial_i overlineu_j )  ","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"is the mean rate of strain tensor.","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"Thanks to the non-linearity of the Navier-Stokes equations, even when averaged we are left with pesky fluctuation terms which form the components of the Reynolds stress tensor","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"tau_ij = rho overlinev_i^prime v_j^prime  ","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"Attempting to close the equations leads to the closure problem: the time evolution of the Reynolds stresses depends on  triple covariances overlinev_i^prime v_j^prime v_k^prime and covariances with pressure, which depend on quadruple covariances and so on (Chou, 1945).","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"This is kind of hopeless so we will have to find some way to model the Reynolds stresses.","category":"page"},{"location":"numerical_implementation/turbulence_closures/#Gradient-diffusion-hypothesis-and-eddy-viscosity-models","page":"Turbulence closures","title":"Gradient-diffusion hypothesis and eddy viscosity models","text":"","category":"section"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"The gradient-diffusion hypothesis, due to Boussinesq (1877), assumes that the transport of scalar fluxes such as overlineboldsymbolv^prime c^prime and overlinev_i^prime v_j^prime occurs down the mean scalar gradient boldsymbolnabla overlinec as if they are being diffused (§4.4) (Pope, 2000). This is in analogy with how momentum transfer by molecular motion in a gas can be described by a molecular viscosity.","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"Taking this assumption we can express the Reynolds stresses and turbulent tracer fluxes in terms of the mean variables and close the equations","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"overlineboldsymbolv^prime c^prime = -kappa_e boldsymbolnabla overlinec\nquad textand quad\noverlinev_i^prime v_j^prime = -2nu_e overlineS_ij  ","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"where nu_e = nu_e(boldsymbolx t) is the turbulent or eddy viscosity and kappa_e = kappa_e(boldsymbolx t) is the eddy diffusivity.","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"The effective diffusivity ends up being the sum of the molecular and eddy diffusivities. So just by using an elevated value for the viscosity and diffusivity, you are already using an eddy viscosity model.","category":"page"},{"location":"numerical_implementation/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"The eddy viscosity model is simple and for that reason is very popular. It can work well even with a constant eddy diffusivity. However, it does assume that the flux is aligned down gradient, which is not true even in simple turbulent flows as the physics of turbulence is quite different from that of colliding molecules leading to the viscous stress law (§4.4,10.1) (Pope, 2000). So we might want something a little bit more sophisticated.","category":"page"},{"location":"model_setup/output_writers/#Output-writers","page":"Output writers","title":"Output writers","text":"","category":"section"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"AbstractOutputWriters save data to disk. Oceananigans provides three ways to write output:","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"NetCDFOutputWriter for output of arrays and scalars that uses NCDatasets.jl\nJLD2OutputWriter for arbitrary julia data structures that uses JLD2.jl\nCheckpointer that automatically saves as much model data as possible, using JLD2.jl","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"The Checkpointer is discussed in detail on a separate section of the documentation.","category":"page"},{"location":"model_setup/output_writers/#Basic-usage","page":"Output writers","title":"Basic usage","text":"","category":"section"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"NetCDFOutputWriter and JLD2OutputWriter require four inputs:","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"The model from which output data is sourced (required to initialize the OutputWriter).\nA key-value pairing of output \"names\" and \"output\" objects. JLD2OutputWriter accepts NamedTuples and Dicts; NetCDFOutputWriter accepts Dicts with string-valued keys. Output objects are either AbstractFields or functions that return data when called via func(model).\nA schedule on which output is written. TimeInterval, IterationInterval, WallTimeInterval schedule periodic output according to the simulation time, simulation interval, or \"wall time\" (the physical time according to a clock on your wall). A fourth schedule called AveragedTimeInterval specifies periodic output that is time-averaged over a window prior to being written.\nThe filename and directory.","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"Other important keyword arguments are","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"indices for outputting subregions, two- and one-dimensional slices of fields. Specifies the indices to write to disk with a Tuple of Colon, UnitRange,or Int elements. For example, indices = (:, :, 1) implies outputing x-y-slices of the bottom-most index (k=1). Defaults to (:, :, :), i.e., \"all indices\".\nwith_halos :: Boolean: whether to output the halos (true) or only the interior points (false; default).\narray_type for specifying the type of the array that holds outputted field data. The default is Array{Float64}, or arrays of single-precision floating point numbers.","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"Once an OutputWriter is created, it can be used to write output by adding it the ordered dictionary simulation.output_writers. prior to calling run!(simulation).","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"More specific detail about the NetCDFOutputWriter and JLD2OutputWriter is given below.","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"tip: Time step alignment and output writing\nOceananigans simulations will shorten the time step as needed to align model output with each output writer's schedule.","category":"page"},{"location":"model_setup/output_writers/#NetCDF-output-writer","page":"Output writers","title":"NetCDF output writer","text":"","category":"section"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"Model data can be saved to NetCDF files along with associated metadata. The NetCDF output writer is generally used by passing it a dictionary of (label, field) pairs and any indices for slicing if you don't want to save the full 3D field.","category":"page"},{"location":"model_setup/output_writers/#Examples","page":"Output writers","title":"Examples","text":"","category":"section"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"Saving the u velocity field and temperature fields as full 3D fields, surface 2D slices, and 1D columns to separate NetCDF files:","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"using Oceananigans\n\ngrid = RectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1))\n\nmodel = NonhydrostaticModel(grid=grid, tracers=:c)\n\nsimulation = Simulation(model, Δt=12, stop_time=3600)\n\nfields = Dict(\"u\" => model.velocities.u, \"c\" => model.tracers.c)\n\nsimulation.output_writers[:field_writer] =\n    NetCDFOutputWriter(model, fields, filename=\"more_fields.nc\", schedule=TimeInterval(60))\n\n# output\nNetCDFOutputWriter scheduled on TimeInterval(1 minute):\n├── filepath: ./more_fields.nc\n├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0)\n├── 2 outputs: (c, u)\n└── array type: Array{Float64}\n├── file_splitting: NoFileSplitting\n└── file size: 14.9 KiB","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"simulation.output_writers[:surface_slice_writer] =\n    NetCDFOutputWriter(model, fields, filename=\"another_surface_xy_slice.nc\",\n                       schedule=TimeInterval(60), indices=(:, :, grid.Nz))\n\n# output\nNetCDFOutputWriter scheduled on TimeInterval(1 minute):\n├── filepath: ./another_surface_xy_slice.nc\n├── dimensions: zC(1), zF(1), xC(16), yF(16), xF(16), yC(16), time(0)\n├── 2 outputs: (c, u)\n└── array type: Array{Float64}\n├── file_splitting: NoFileSplitting\n└── file size: 14.9 KiB","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"simulation.output_writers[:averaged_profile_writer] =\n    NetCDFOutputWriter(model, fields,\n                       filename = \"another_averaged_z_profile.nc\",\n                       schedule = AveragedTimeInterval(60, window=20),\n                       indices = (1, 1, :))\n\n# output\nNetCDFOutputWriter scheduled on TimeInterval(1 minute):\n├── filepath: ./another_averaged_z_profile.nc\n├── dimensions: zC(16), zF(17), xC(1), yF(1), xF(1), yC(1), time(0)\n├── 2 outputs: (c, u) averaged on AveragedTimeInterval(window=20 seconds, stride=1, interval=1 minute)\n└── array type: Array{Float64}\n├── file_splitting: NoFileSplitting\n└── file size: 17.6 KiB","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"NetCDFOutputWriter also accepts output functions that write scalars and arrays to disk, provided that their dimensions are provided:","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"using Oceananigans\n\nNx, Ny, Nz = 16, 16, 16\n\ngrid = RectilinearGrid(size=(Nx, Ny, Nz), extent=(1, 2, 3))\n\nmodel = NonhydrostaticModel(grid=grid)\n\nsimulation = Simulation(model, Δt=1.25, stop_iteration=3)\n\nf(model) = model.clock.time^2; # scalar output\n\ng(model) = model.clock.time .* exp.(znodes(grid, Center())) # single-column profile output (vector)\n\nxC, yF = xnodes(grid, Center()), ynodes(grid, Face())\n\nXC = [xC[i] for i in 1:Nx, j in 1:Ny]\nYF = [yF[j] for i in 1:Nx, j in 1:Ny]\n\nh(model) = @. model.clock.time * sin(XC) * cos(YF) # x-y slice output (2D array)\n\noutputs = Dict(\"scalar\" => f, \"profile\" => g, \"slice\" => h)\n\ndims = Dict(\"scalar\" => (), \"profile\" => (\"zC\",), \"slice\" => (\"xC\", \"yC\"))\n\noutput_attributes = Dict(\n    \"scalar\"  => Dict(\"longname\" => \"Some scalar\", \"units\" => \"bananas\"),\n    \"profile\" => Dict(\"longname\" => \"Some vertical profile\", \"units\" => \"watermelons\"),\n    \"slice\"   => Dict(\"longname\" => \"Some slice\", \"units\" => \"mushrooms\")\n)\n\nglobal_attributes = Dict(\"location\" => \"Bay of Fundy\", \"onions\" => 7)\n\nsimulation.output_writers[:things] =\n    NetCDFOutputWriter(model, outputs,\n                       schedule=IterationInterval(1), filename=\"things.nc\", dimensions=dims, verbose=true,\n                       global_attributes=global_attributes, output_attributes=output_attributes)\n\n# output\nNetCDFOutputWriter scheduled on IterationInterval(1):\n├── filepath: ./things.nc\n├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0)\n├── 3 outputs: (profile, slice, scalar)\n└── array type: Array{Float64}\n├── file_splitting: NoFileSplitting\n└── file size: 17.8 KiB","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"NetCDFOutputWriter can also be configured for outputs that are interpolated or regridded to a different grid than model.grid. To use this functionality, include the keyword argument grid = output_grid.","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"using Oceananigans\nusing Oceananigans.Fields: interpolate!\n\ngrid = RectilinearGrid(size=(1, 1, 8), extent=(1, 1, 1));\nmodel = NonhydrostaticModel(; grid)\n\ncoarse_grid = RectilinearGrid(size=(grid.Nx, grid.Ny, grid.Nz÷2), extent=(grid.Lx, grid.Ly, grid.Lz))\ncoarse_u = Field{Face, Center, Center}(coarse_grid)\n\ninterpolate_u(model) = interpolate!(coarse_u, model.velocities.u)\noutputs = (; u = interpolate_u)\n\noutput_writer = NetCDFOutputWriter(model, outputs;\n                                   grid = coarse_grid,\n                                   filename = \"coarse_u.nc\",\n                                   schedule = IterationInterval(1))\n\n# output\nNetCDFOutputWriter scheduled on IterationInterval(1):\n├── filepath: ./coarse_u.nc\n├── dimensions: zC(4), zF(5), xC(1), yF(1), xF(1), yC(1), time(0)\n├── 1 outputs: u\n└── array type: Array{Float64}\n├── file_splitting: NoFileSplitting\n└── file size: 14.6 KiB","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"See NetCDFOutputWriter for more information.","category":"page"},{"location":"model_setup/output_writers/#JLD2-output-writer","page":"Output writers","title":"JLD2 output writer","text":"","category":"section"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"JLD2 is a fast HDF5 compatible file format written in pure Julia. JLD2 files can be opened in Julia with the JLD2.jl package and in Python with the h5py package.","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"The JLD2OutputWriter receives either a Dictionary or NamedTuple containing name, output pairs. The name can be a symbol or string. The output must either be an AbstractField or a function called with func(model) that returns arbitrary output. Whenever output needs to be written, the functions will be called and the output of the function will be saved to the JLD2 file.","category":"page"},{"location":"model_setup/output_writers/#Examples-2","page":"Output writers","title":"Examples","text":"","category":"section"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"Write out 3D fields for u, v, w, and a tracer c, along with a horizontal average:","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"using Oceananigans\nusing Oceananigans.Utils: hour, minute\n\nmodel = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)), tracers=(:c,))\nsimulation = Simulation(model, Δt=12, stop_time=1hour)\n\nfunction init_save_some_metadata!(file, model)\n    file[\"author\"] = \"Chim Riggles\"\n    file[\"parameters/coriolis_parameter\"] = 1e-4\n    file[\"parameters/density\"] = 1027\n    return nothing\nend\n\nc_avg = Field(Average(model.tracers.c, dims=(1, 2)))\n\n# Note that model.velocities is NamedTuple\nsimulation.output_writers[:velocities] = JLD2OutputWriter(model, model.velocities,\n                                                          filename = \"some_more_data.jld2\",\n                                                          schedule = TimeInterval(20minute),\n                                                          init = init_save_some_metadata!)\n\n# output\nJLD2OutputWriter scheduled on TimeInterval(20 minutes):\n├── filepath: ./some_more_data.jld2\n├── 3 outputs: (u, v, w)\n├── array type: Array{Float64}\n├── including: [:grid, :coriolis, :buoyancy, :closure]\n├── file_splitting: NoFileSplitting\n└── file size: 28.5 KiB","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"and a time- and horizontal-average of tracer c every 20 minutes of simulation time to a file called some_more_averaged_data.jld2","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"simulation.output_writers[:avg_c] = JLD2OutputWriter(model, (; c=c_avg),\n                                                     filename = \"some_more_averaged_data.jld2\",\n                                                     schedule = AveragedTimeInterval(20minute, window=5minute))\n\n# output\nJLD2OutputWriter scheduled on TimeInterval(20 minutes):\n├── filepath: ./some_more_averaged_data.jld2\n├── 1 outputs: c averaged on AveragedTimeInterval(window=5 minutes, stride=1, interval=20 minutes)\n├── array type: Array{Float64}\n├── including: [:grid, :coriolis, :buoyancy, :closure]\n├── file_splitting: NoFileSplitting\n└── file size: 18.3 KiB","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"See JLD2OutputWriter for more information.","category":"page"},{"location":"model_setup/output_writers/#Time-averaged-output","page":"Output writers","title":"Time-averaged output","text":"","category":"section"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"Time-averaged output is specified by setting the schedule keyword argument for either NetCDFOutputWriter or JLD2OutputWriter to AveragedTimeInterval.","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"With AveragedTimeInterval, the time-average of a is taken as a left Riemann sum corresponding to","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"langle a rangle = frac1T int_t_i-T^t_i a  mathrmd t  ","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"where langle a rangle is the time-average of a, T is the time-window for averaging specified by the window keyword argument to AveragedTimeInterval, and the t_i are discrete times separated by the time interval. The t_i specify both the end of the averaging window and the time at which output is written.","category":"page"},{"location":"model_setup/output_writers/#Example","page":"Output writers","title":"Example","text":"","category":"section"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"Building an AveragedTimeInterval that averages over a 1 day window, every 4 days,","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"using Oceananigans\nusing Oceananigans.Units\n\nschedule = AveragedTimeInterval(4days, window=1day)\n\n# output\nAveragedTimeInterval(window=1 day, stride=1, interval=4 days)","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"An AveragedTimeInterval schedule directs an output writer to time-average its outputs before writing them to disk:","category":"page"},{"location":"model_setup/output_writers/","page":"Output writers","title":"Output writers","text":"using Oceananigans\nusing Oceananigans.Units\n\nmodel = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)))\n\nsimulation = Simulation(model, Δt=10minutes, stop_time=30days)\n\nsimulation.output_writers[:velocities] = JLD2OutputWriter(model, model.velocities,\n                                                          filename = \"even_more_averaged_velocity_data.jld2\",\n                                                          schedule = AveragedTimeInterval(4days, window=1day, stride=2))\n\n# output\nJLD2OutputWriter scheduled on TimeInterval(4 days):\n├── filepath: ./even_more_averaged_velocity_data.jld2\n├── 3 outputs: (u, v, w) averaged on AveragedTimeInterval(window=1 day, stride=2, interval=4 days)\n├── array type: Array{Float64}\n├── including: [:grid, :coriolis, :buoyancy, :closure]\n├── file_splitting: NoFileSplitting\n└── file size: 27.6 KiB","category":"page"},{"location":"model_setup/clock/#Clock","page":"Clock","title":"Clock","text":"","category":"section"},{"location":"model_setup/clock/","page":"Clock","title":"Clock","text":"The clock holds the current simulation time, iteration number, and time step stage. The time step stage is relevant only for the multi-stage time-stepper RungeKutta3TimeStepper.","category":"page"},{"location":"model_setup/clock/","page":"Clock","title":"Clock","text":"By default, Clocks are initialized at iteration 0, and stage 1,","category":"page"},{"location":"model_setup/clock/","page":"Clock","title":"Clock","text":"DocTestSetup = quote\n    using Oceananigans\n    using TimesDates\nend","category":"page"},{"location":"model_setup/clock/","page":"Clock","title":"Clock","text":"julia> clock = Clock(time=0.0)\nClock{Float64, Float64}(time=0 seconds, iteration=0, last_Δt=Inf days)\n├── stage: 1\n└── last_stage_Δt: Inf days","category":"page"},{"location":"model_setup/clock/","page":"Clock","title":"Clock","text":"but can be modified to start the model clock at some other time. For example, passing","category":"page"},{"location":"model_setup/clock/","page":"Clock","title":"Clock","text":"julia> clock = Clock(time=3600.0)\nClock{Float64, Float64}(time=1 hour, iteration=0, last_Δt=Inf days)\n├── stage: 1\n└── last_stage_Δt: Inf days","category":"page"},{"location":"model_setup/clock/","page":"Clock","title":"Clock","text":"to the constructor for NonhydrostaticModel causes the simulation time to start at t = 3600 seconds.","category":"page"},{"location":"model_setup/clock/","page":"Clock","title":"Clock","text":"The type of the keyword argument time should be a float or date type. To use the date type TimeDate from the TimesDates.jl package, for example, pass","category":"page"},{"location":"model_setup/clock/","page":"Clock","title":"Clock","text":"julia> using TimesDates\n\njulia> clock = Clock(time=TimeDate(2020))\nClock{TimesDates.TimeDate, Float64}(time=2020-01-01T00:00:00, iteration=0, last_Δt=Inf days)\n├── stage: 1\n└── last_stage_Δt: Inf days","category":"page"},{"location":"model_setup/clock/","page":"Clock","title":"Clock","text":"to NonhydrostaticModel. TimesDates.TimeDate supports nanosecond resolution and is thus recommended over Base.Dates.DateTime, which is also supported but has only millisecond resolution.","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"EditURL = \"../../../examples/horizontal_convection.jl\"","category":"page"},{"location":"literated/horizontal_convection/#Horizontal-convection-example","page":"Horizontal convection","title":"Horizontal convection example","text":"","category":"section"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"In \"horizontal convection\", a non-uniform buoyancy is imposed on top of an initially resting fluid.","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"This example demonstrates:","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"How to use computed Fields for output.\nHow to post-process saved output using FieldTimeSeries.","category":"page"},{"location":"literated/horizontal_convection/#Install-dependencies","page":"Horizontal convection","title":"Install dependencies","text":"","category":"section"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"using Pkg\npkg\"add Oceananigans, CairoMakie\"","category":"page"},{"location":"literated/horizontal_convection/#Horizontal-convection","page":"Horizontal convection","title":"Horizontal convection","text":"","category":"section"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"We consider two-dimensional horizontal convection of an incompressible flow boldsymbolu = (u w) on the (x z)-plane (-L_x2 le x le L_x2 and -H le z le 0). The flow evolves under the effect of gravity. The only forcing on the fluid comes from a prescribed, non-uniform buoyancy at the top-surface of the domain.","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"We start by importing Oceananigans and Printf.","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"using Oceananigans\nusing Printf","category":"page"},{"location":"literated/horizontal_convection/#The-grid","page":"Horizontal convection","title":"The grid","text":"","category":"section"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"H = 1            # vertical domain extent\nLx = 2H          # horizontal domain extent\nNx, Nz = 128, 64 # horizontal, vertical resolution\n\ngrid = RectilinearGrid(size = (Nx, Nz),\n                       x = (-Lx/2, Lx/2),\n                       z = (-H, 0),\n                       topology = (Bounded, Flat, Bounded))","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"128×1×64 RectilinearGrid{Float64, Bounded, Flat, Bounded} on CPU with 3×0×3 halo\n├── Bounded  x ∈ [-1.0, 1.0] regularly spaced with Δx=0.015625\n├── Flat y                   \n└── Bounded  z ∈ [-1.0, 0.0] regularly spaced with Δz=0.015625","category":"page"},{"location":"literated/horizontal_convection/#Boundary-conditions","page":"Horizontal convection","title":"Boundary conditions","text":"","category":"section"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"At the surface, the imposed buoyancy is","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"b(x z = 0 t) = - b_* cos (2 pi x  L_x)  ","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"while zero-flux boundary conditions are imposed on all other boundaries. We use free-slip boundary conditions on u and w everywhere.","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"b★ = 1\n@inline bˢ(x, t, p) = - p.b★ * cos(2π * x / p.Lx)\n\nb_bcs = FieldBoundaryConditions(top = ValueBoundaryCondition(bˢ, parameters=(; b★, Lx)))","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"Oceananigans.FieldBoundaryConditions, with boundary conditions\n├── west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── bottom: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── top: ValueBoundaryCondition: ContinuousBoundaryFunction bˢ at (Nothing, Nothing, Nothing)\n└── immersed: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)","category":"page"},{"location":"literated/horizontal_convection/#Non-dimensional-control-parameters-and-Turbulence-closure","page":"Horizontal convection","title":"Non-dimensional control parameters and Turbulence closure","text":"","category":"section"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"The problem is characterized by three non-dimensional parameters. The first is the domain's aspect ratio, L_x  H and the other two are the Rayleigh (Ra) and Prandtl (Pr) numbers:","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"Ra = fracb_* L_x^3nu kappa   quad textand quad Pr = fracnukappa  ","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"The Prandtl number expresses the ratio of momentum over heat diffusion; the Rayleigh number is a measure of the relative importance of gravity over viscosity in the momentum equation.","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"For a domain with a given extent, the nondimensional values of Ra and Pr uniquely determine the viscosity and diffusivity, i.e.,","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"nu = sqrtfracPr b_* L_x^3Ra quad textand quad kappa = sqrtfracb_* L_x^3Pr Ra  ","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"We use isotropic viscosity and diffusivities, ν and κ whose values are obtain from the prescribed Ra and Pr numbers. Here, we use Pr = 1 and Ra = 10^8:","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"Pr = 1      # Prandtl number\nRa = 1e8    # Rayleigh number\n\nν = sqrt(Pr * b★ * Lx^3 / Ra)  # Laplacian viscosity\nκ = ν * Pr                     # Laplacian diffusivity","category":"page"},{"location":"literated/horizontal_convection/#Model-instantiation","page":"Horizontal convection","title":"Model instantiation","text":"","category":"section"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"We instantiate the model with the fifth-order WENO advection scheme, a 3rd order Runge-Kutta time-stepping scheme, and a BuoyancyTracer.","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"model = NonhydrostaticModel(; grid,\n                            advection = WENO(),\n                            timestepper = :RungeKutta3,\n                            tracers = :b,\n                            buoyancy = BuoyancyTracer(),\n                            closure = ScalarDiffusivity(; ν, κ),\n                            boundary_conditions = (; b=b_bcs))","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\n├── grid: 128×1×64 RectilinearGrid{Float64, Bounded, Flat, Bounded} on CPU with 3×0×3 halo\n├── timestepper: RungeKutta3TimeStepper\n├── advection scheme: FluxFormAdvection{3, Float64, WENO{3, Float64, Nothing, Nothing, Nothing, Nothing, WENO{2, Float64, Nothing, Nothing, Nothing, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{2, Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}}, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, WENO{3, Float64, Nothing, Nothing, Nothing, Nothing, WENO{2, Float64, Nothing, Nothing, Nothing, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{2, Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}}}\n├── tracers: b\n├── closure: ScalarDiffusivity{ExplicitTimeDiscretization}(ν=0.000282843, κ=(b=0.000282843,))\n├── buoyancy: BuoyancyTracer with ĝ = NegativeZDirection()\n└── coriolis: Nothing","category":"page"},{"location":"literated/horizontal_convection/#Simulation-set-up","page":"Horizontal convection","title":"Simulation set-up","text":"","category":"section"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"We set up a simulation that runs up to t = 40 with a JLD2OutputWriter that saves the flow speed, sqrtu^2 + w^2, the buoyancy, b, and the vorticity, partial_z u - partial_x w.","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"simulation = Simulation(model, Δt=1e-2, stop_time=40.0)","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"Simulation of NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\n├── Next time step: 10 ms\n├── Elapsed wall time: 0 seconds\n├── Wall time per iteration: NaN days\n├── Stop time: 40 seconds\n├── Stop iteration : Inf\n├── Wall time limit: Inf\n├── Callbacks: OrderedDict with 4 entries:\n│   ├── stop_time_exceeded => Callback of stop_time_exceeded on IterationInterval(1)\n│   ├── stop_iteration_exceeded => Callback of stop_iteration_exceeded on IterationInterval(1)\n│   ├── wall_time_limit_exceeded => Callback of wall_time_limit_exceeded on IterationInterval(1)\n│   └── nan_checker => Callback of NaNChecker for u on IterationInterval(100)\n├── Output writers: OrderedDict with no entries\n└── Diagnostics: OrderedDict with no entries","category":"page"},{"location":"literated/horizontal_convection/#The-TimeStepWizard","page":"Horizontal convection","title":"The TimeStepWizard","text":"","category":"section"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"The TimeStepWizard manages the time-step adaptively, keeping the Courant-Freidrichs-Lewy (CFL) number close to 0.7.","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"conjure_time_step_wizard!(simulation, IterationInterval(50), cfl=0.7, max_Δt=1e-1)","category":"page"},{"location":"literated/horizontal_convection/#A-progress-messenger","page":"Horizontal convection","title":"A progress messenger","text":"","category":"section"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"We write a function that prints out a helpful progress message while the simulation runs.","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"progress(sim) = @printf(\"Iter: % 6d, sim time: % 1.3f, wall time: % 10s, Δt: % 1.4f, advective CFL: %.2e, diffusive CFL: %.2e\\n\",\n                        iteration(sim), time(sim), prettytime(sim.run_wall_time),\n                        sim.Δt, AdvectiveCFL(sim.Δt)(sim.model), DiffusiveCFL(sim.Δt)(sim.model))\n\nsimulation.callbacks[:progress] = Callback(progress, IterationInterval(50))","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"Callback of progress on IterationInterval(50)","category":"page"},{"location":"literated/horizontal_convection/#Output","page":"Horizontal convection","title":"Output","text":"","category":"section"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"We use computed Fields to diagnose and output the total flow speed, the vorticity, zeta, and the buoyancy, b. Note that computed Fields take \"AbstractOperations\" on Fields as input:","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"u, v, w = model.velocities # unpack velocity `Field`s\nb = model.tracers.b        # unpack buoyancy `Field`\n\n# total flow speed\ns = @at (Center, Center, Center) sqrt(u^2 + w^2)\n\n# y-component of vorticity\nζ = ∂z(u) - ∂x(w)","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"We create a JLD2OutputWriter that saves the speed, and the vorticity. Because we want to post-process buoyancy and compute the buoyancy variance dissipation (which is proportional to boldsymbolnabla b^2) we use the with_halos = true. This way, the halos for the fields are saved and thus when we load them as fields they will come with the proper boundary conditions.","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"We then add the JLD2OutputWriter to the simulation.","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"saved_output_filename = \"horizontal_convection.jld2\"\n\nsimulation.output_writers[:fields] = JLD2OutputWriter(model, (; s, b, ζ),\n                                                      schedule = TimeInterval(0.5),\n                                                      filename = saved_output_filename,\n                                                      with_halos = true,\n                                                      overwrite_existing = true)","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"Ready to press the big red button:","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"run!(simulation)","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"[ Info: Initializing simulation...\nIter:      0, sim time:  0.000, wall time:  0 seconds, Δt:  0.0110, advective CFL: 0.00e+00, diffusive CFL: 1.27e-02\n[ Info:     ... simulation initialization complete (13.779 seconds)\n[ Info: Executing initial time step...\n[ Info:     ... initial time step complete (14.315 seconds).\nIter:     50, sim time:  0.544, wall time: 29.100 seconds, Δt:  0.0121, advective CFL: 4.38e-03, diffusive CFL: 1.40e-02\nIter:    100, sim time:  1.145, wall time: 30.235 seconds, Δt:  0.0133, advective CFL: 1.66e-02, diffusive CFL: 1.54e-02\nIter:    150, sim time:  1.806, wall time: 31.004 seconds, Δt:  0.0146, advective CFL: 3.74e-02, diffusive CFL: 1.70e-02\nIter:    200, sim time:  2.500, wall time: 31.794 seconds, Δt:  0.0161, advective CFL: 6.80e-02, diffusive CFL: 1.87e-02\nIter:    250, sim time:  3.290, wall time: 32.601 seconds, Δt:  0.0177, advective CFL: 1.16e-01, diffusive CFL: 2.05e-02\nIter:    300, sim time:  4.159, wall time: 33.337 seconds, Δt:  0.0195, advective CFL: 2.06e-01, diffusive CFL: 2.26e-02\nIter:    350, sim time:  5.117, wall time: 34.120 seconds, Δt:  0.0214, advective CFL: 5.91e-01, diffusive CFL: 2.48e-02\nIter:    400, sim time:  6.171, wall time: 34.891 seconds, Δt:  0.0164, advective CFL: 7.00e-01, diffusive CFL: 1.90e-02\nIter:    450, sim time:  6.976, wall time: 35.594 seconds, Δt:  0.0159, advective CFL: 7.00e-01, diffusive CFL: 1.84e-02\nIter:    500, sim time:  7.755, wall time: 36.275 seconds, Δt:  0.0155, advective CFL: 7.00e-01, diffusive CFL: 1.80e-02\nIter:    550, sim time:  8.516, wall time: 37.007 seconds, Δt:  0.0153, advective CFL: 7.00e-01, diffusive CFL: 1.77e-02\nIter:    600, sim time:  9.275, wall time: 37.733 seconds, Δt:  0.0165, advective CFL: 7.00e-01, diffusive CFL: 1.91e-02\nIter:    650, sim time:  10.082, wall time: 38.493 seconds, Δt:  0.0155, advective CFL: 7.00e-01, diffusive CFL: 1.80e-02\nIter:    700, sim time:  10.857, wall time: 39.201 seconds, Δt:  0.0159, advective CFL: 7.00e-01, diffusive CFL: 1.84e-02\nIter:    750, sim time:  11.595, wall time: 39.934 seconds, Δt:  0.0173, advective CFL: 7.00e-01, diffusive CFL: 2.01e-02\nIter:    800, sim time:  12.450, wall time: 40.690 seconds, Δt:  0.0179, advective CFL: 7.00e-01, diffusive CFL: 2.07e-02\nIter:    850, sim time:  13.322, wall time: 41.434 seconds, Δt:  0.0179, advective CFL: 7.00e-01, diffusive CFL: 2.08e-02\nIter:    900, sim time:  14.215, wall time: 42.199 seconds, Δt:  0.0183, advective CFL: 7.00e-01, diffusive CFL: 2.11e-02\nIter:    950, sim time:  15.110, wall time: 42.944 seconds, Δt:  0.0197, advective CFL: 7.00e-01, diffusive CFL: 2.28e-02\nIter:   1000, sim time:  16.079, wall time: 43.673 seconds, Δt:  0.0197, advective CFL: 7.00e-01, diffusive CFL: 2.28e-02\nIter:   1050, sim time:  17.039, wall time: 44.457 seconds, Δt:  0.0197, advective CFL: 7.00e-01, diffusive CFL: 2.28e-02\nIter:   1100, sim time:  17.992, wall time: 45.214 seconds, Δt:  0.0201, advective CFL: 7.00e-01, diffusive CFL: 2.32e-02\nIter:   1150, sim time:  18.981, wall time: 45.954 seconds, Δt:  0.0208, advective CFL: 7.00e-01, diffusive CFL: 2.41e-02\nIter:   1200, sim time:  20.021, wall time: 46.721 seconds, Δt:  0.0219, advective CFL: 7.00e-01, diffusive CFL: 2.53e-02\nIter:   1250, sim time:  21.109, wall time: 47.510 seconds, Δt:  0.0219, advective CFL: 7.00e-01, diffusive CFL: 2.54e-02\nIter:   1300, sim time:  22.197, wall time: 48.272 seconds, Δt:  0.0203, advective CFL: 7.00e-01, diffusive CFL: 2.35e-02\nIter:   1350, sim time:  23.203, wall time: 49.040 seconds, Δt:  0.0214, advective CFL: 7.00e-01, diffusive CFL: 2.48e-02\nIter:   1400, sim time:  24.257, wall time: 49.808 seconds, Δt:  0.0222, advective CFL: 7.00e-01, diffusive CFL: 2.57e-02\nIter:   1450, sim time:  25.355, wall time: 50.532 seconds, Δt:  0.0244, advective CFL: 6.79e-01, diffusive CFL: 2.83e-02\nIter:   1500, sim time:  26.549, wall time: 51.339 seconds, Δt:  0.0259, advective CFL: 7.00e-01, diffusive CFL: 3.00e-02\nIter:   1550, sim time:  27.810, wall time: 52.106 seconds, Δt:  0.0197, advective CFL: 7.00e-01, diffusive CFL: 2.28e-02\nIter:   1600, sim time:  28.775, wall time: 52.896 seconds, Δt:  0.0159, advective CFL: 7.00e-01, diffusive CFL: 1.84e-02\nIter:   1650, sim time:  29.548, wall time: 53.680 seconds, Δt:  0.0151, advective CFL: 7.00e-01, diffusive CFL: 1.75e-02\nIter:   1700, sim time:  30.302, wall time: 54.503 seconds, Δt:  0.0149, advective CFL: 7.00e-01, diffusive CFL: 1.72e-02\nIter:   1750, sim time:  31.030, wall time: 55.322 seconds, Δt:  0.0164, advective CFL: 6.28e-01, diffusive CFL: 1.89e-02\nIter:   1800, sim time:  31.843, wall time: 56.012 seconds, Δt:  0.0180, advective CFL: 6.29e-01, diffusive CFL: 2.08e-02\nIter:   1850, sim time:  32.734, wall time: 56.677 seconds, Δt:  0.0198, advective CFL: 6.69e-01, diffusive CFL: 2.29e-02\nIter:   1900, sim time:  33.698, wall time: 57.440 seconds, Δt:  0.0212, advective CFL: 7.00e-01, diffusive CFL: 2.46e-02\nIter:   1950, sim time:  34.733, wall time: 58.165 seconds, Δt:  0.0219, advective CFL: 7.00e-01, diffusive CFL: 2.53e-02\nIter:   2000, sim time:  35.806, wall time: 58.903 seconds, Δt:  0.0223, advective CFL: 7.00e-01, diffusive CFL: 2.59e-02\nIter:   2050, sim time:  36.902, wall time: 59.609 seconds, Δt:  0.0228, advective CFL: 7.00e-01, diffusive CFL: 2.64e-02\nIter:   2100, sim time:  38.000, wall time: 1.006 minutes, Δt:  0.0235, advective CFL: 7.00e-01, diffusive CFL: 2.73e-02\nIter:   2150, sim time:  39.118, wall time: 1.019 minutes, Δt:  0.0243, advective CFL: 7.00e-01, diffusive CFL: 2.81e-02\n[ Info: Simulation is stopping after running for 1.028 minutes.\n[ Info: Simulation time 40 seconds equals or exceeds stop time 40 seconds.\n","category":"page"},{"location":"literated/horizontal_convection/#Load-saved-output,-process,-visualize","page":"Horizontal convection","title":"Load saved output, process, visualize","text":"","category":"section"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"We animate the results by loading the saved output, extracting data for the iterations we ended up saving at, and ploting the saved fields. From the saved buoyancy field we compute the buoyancy dissipation, chi = kappa boldsymbolnabla b^2, and plot that also.","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"To start we load the saved fields are FieldTimeSeries and prepare for animating the flow by creating coordinate arrays that each field lives on.","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"using CairoMakie\nusing Oceananigans\nusing Oceananigans.Fields\nusing Oceananigans.AbstractOperations: volume\n\nsaved_output_filename = \"horizontal_convection.jld2\"\n\n# Open the file with our data\ns_timeseries = FieldTimeSeries(saved_output_filename, \"s\")\nb_timeseries = FieldTimeSeries(saved_output_filename, \"b\")\nζ_timeseries = FieldTimeSeries(saved_output_filename, \"ζ\")\n\ntimes = b_timeseries.times\n\n# Coordinate arrays\nxc, yc, zc = nodes(b_timeseries[1])\nxζ, yζ, zζ = nodes(ζ_timeseries[1])\n\nχ_timeseries = deepcopy(b_timeseries)\n\nfor n in 1:length(times)\n    bn = b_timeseries[n]\n    χ_timeseries[n] .= @at (Center, Center, Center) κ * (∂x(bn)^2 + ∂z(bn)^2)\nend","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"Now we're ready to animate using Makie.","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"@info \"Making an animation from saved data...\"\n\nn = Observable(1)\n\ntitle = @lift @sprintf(\"t=%1.2f\", times[$n])\n\nsn = @lift s_timeseries[$n]\nζn = @lift ζ_timeseries[$n]\nbn = @lift b_timeseries[$n]\nχn = @lift χ_timeseries[$n]\n\nslim = 0.6\nblim = 0.6\nζlim = 9\nχlim = 0.025\n\naxis_kwargs = (xlabel = L\"x / H\",\n               ylabel = L\"z / H\",\n               limits = ((-Lx/2, Lx/2), (-H, 0)),\n               aspect = Lx / H,\n               titlesize = 20)\n\nfig = Figure(size = (600, 1100))\n\nax_s = Axis(fig[2, 1]; title = L\"speed, $(u^2+w^2)^{1/2} / (L_x b_*)^{1/2}$\", axis_kwargs...)\nax_b = Axis(fig[3, 1]; title = L\"buoyancy, $b / b_*$\", axis_kwargs...)\nax_ζ = Axis(fig[4, 1]; axis_kwargs...,\n            title = L\"vorticity, $(∂u/∂z - ∂w/∂x) \\, (L_x / b_*)^{1/2}$\")\n\nax_χ = Axis(fig[5, 1]; axis_kwargs...,\n            title = L\"buoyancy dissipation, $κ |\\mathbf{\\nabla}b|^2 \\, (L_x / {b_*}^5)^{1/2}$\")\n\nfig[1, :] = Label(fig, title, fontsize=24, tellwidth=false)\n\nhm_s = heatmap!(ax_s, sn; colorrange=(0, slim), colormap=:speed)\nColorbar(fig[2, 2], hm_s)\n\nhm_b = heatmap!(ax_b, bn; colorrange=(-blim, blim), colormap=:thermal)\nColorbar(fig[3, 2], hm_b)\n\nhm_ζ = heatmap!(ax_ζ, ζn; colorrange=(-ζlim, ζlim), colormap=:balance)\nColorbar(fig[4, 2], hm_ζ)\n\nhm_χ = heatmap!(ax_χ, χn; colorrange=(0, χlim), colormap=:dense)\nColorbar(fig[5, 2], hm_χ)","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"Colorbar()","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"And, finally, we record a movie.","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"frames = 1:length(times)\n\nrecord(fig, \"horizontal_convection.mp4\", frames, framerate=8) do i\n    msg = string(\"Plotting frame \", i, \" of \", frames[end])\n    print(msg * \" \\r\")\n    n[] = i\nend","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"Plotting frame 1 of 81 Plotting frame 2 of 81 Plotting frame 3 of 81 Plotting frame 4 of 81 Plotting frame 5 of 81 Plotting frame 6 of 81 Plotting frame 7 of 81 Plotting frame 8 of 81 Plotting frame 9 of 81 Plotting frame 10 of 81 Plotting frame 11 of 81 Plotting frame 12 of 81 Plotting frame 13 of 81 Plotting frame 14 of 81 Plotting frame 15 of 81 Plotting frame 16 of 81 Plotting frame 17 of 81 Plotting frame 18 of 81 Plotting frame 19 of 81 Plotting frame 20 of 81 Plotting frame 21 of 81 Plotting frame 22 of 81 Plotting frame 23 of 81 Plotting frame 24 of 81 Plotting frame 25 of 81 Plotting frame 26 of 81 Plotting frame 27 of 81 Plotting frame 28 of 81 Plotting frame 29 of 81 Plotting frame 30 of 81 Plotting frame 31 of 81 Plotting frame 32 of 81 Plotting frame 33 of 81 Plotting frame 34 of 81 Plotting frame 35 of 81 Plotting frame 36 of 81 Plotting frame 37 of 81 Plotting frame 38 of 81 Plotting frame 39 of 81 Plotting frame 40 of 81 Plotting frame 41 of 81 Plotting frame 42 of 81 Plotting frame 43 of 81 Plotting frame 44 of 81 Plotting frame 45 of 81 Plotting frame 46 of 81 Plotting frame 47 of 81 Plotting frame 48 of 81 Plotting frame 49 of 81 Plotting frame 50 of 81 Plotting frame 51 of 81 Plotting frame 52 of 81 Plotting frame 53 of 81 Plotting frame 54 of 81 Plotting frame 55 of 81 Plotting frame 56 of 81 Plotting frame 57 of 81 Plotting frame 58 of 81 Plotting frame 59 of 81 Plotting frame 60 of 81 Plotting frame 61 of 81 Plotting frame 62 of 81 Plotting frame 63 of 81 Plotting frame 64 of 81 Plotting frame 65 of 81 Plotting frame 66 of 81 Plotting frame 67 of 81 Plotting frame 68 of 81 Plotting frame 69 of 81 Plotting frame 70 of 81 Plotting frame 71 of 81 Plotting frame 72 of 81 Plotting frame 73 of 81 Plotting frame 74 of 81 Plotting frame 75 of 81 Plotting frame 76 of 81 Plotting frame 77 of 81 Plotting frame 78 of 81 Plotting frame 79 of 81 Plotting frame 80 of 81 Plotting frame 81 of 81 ","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"(Image: )","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"At higher Rayleigh numbers the flow becomes much more vigorous. See, for example, an animation of the voricity of the fluid at Ra = 10^12 on vimeo.","category":"page"},{"location":"literated/horizontal_convection/#The-Nusselt-number","page":"Horizontal convection","title":"The Nusselt number","text":"","category":"section"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"Often we are interested on how much the flow enhances mixing. This is quantified by the Nusselt number, which measures how much the flow enhances mixing compared if only diffusion was in operation. The Nusselt number is given by","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"Nu = fraclangle chi ranglelangle chi_rm diff rangle  ","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"where angle brackets above denote both a volume and time average and chi_rm diff is the buoyancy dissipation that we get without any flow, i.e., the buoyancy dissipation associated with the buoyancy distribution that satisfies","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"kappa nabla^2 b_rm diff = 0  ","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"with the same boundary conditions same as our setup. In this case, we can readily find that","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"b_rm diff(x z) = b_s(x) fraccosh left 2 pi (H + z)  L_x right cosh(2 pi H  L_x)  ","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"where b_s(x) is the surface boundary condition. The diffusive solution implies","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"langle chi_rm diff rangle = frackappa b_*^2 piL_x H tanh(2 pi Η  L_x) ","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"We use the loaded FieldTimeSeries to compute the Nusselt number from buoyancy and the volume average kinetic energy of the fluid.","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"First we compute the diffusive buoyancy dissipation, chi_rm diff (which is just a scalar):","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"χ_diff = κ * b★^2 * π * tanh(2π * H / Lx) / (Lx * H)","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"We recover the time from the saved FieldTimeSeries and construct two empty arrays to store the volume-averaged kinetic energy and the instantaneous Nusselt number,","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"t = b_timeseries.times\n\nkinetic_energy, Nu = zeros(length(t)), zeros(length(t))","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"Now we can loop over the fields in the FieldTimeSeries, compute kinetic energy and Nu, and plot. We make use of Integral to compute the volume integral of fields over our domain.","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"for n = 1:length(t)\n    ke = Field(Integral(1/2 * s_timeseries[n]^2 / (Lx * H)))\n    compute!(ke)\n    kinetic_energy[n] = ke[1, 1, 1]\n\n    χ = Field(Integral(χ_timeseries[n] / (Lx * H)))\n    compute!(χ)\n\n    Nu[n] = χ[1, 1, 1] / χ_diff\nend\n\nfig = Figure(size = (850, 450))\n\nax_KE = Axis(fig[1, 1], xlabel = L\"t \\, (b_* / L_x)^{1/2}\", ylabel = L\"KE $ / (L_x b_*)$\")\nlines!(ax_KE, t, kinetic_energy; linewidth = 3)\n\nax_Nu = Axis(fig[2, 1], xlabel = L\"t \\, (b_* / L_x)^{1/2}\", ylabel = L\"Nu\")\nlines!(ax_Nu, t, Nu; linewidth = 3)\n\nfig","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"(Image: )","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"","category":"page"},{"location":"literated/horizontal_convection/","page":"Horizontal convection","title":"Horizontal convection","text":"This page was generated using Literate.jl.","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#Turbulent-diffusivity-closures-and-large-eddy-simulation-models","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and large eddy simulation models","text":"","category":"section"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"A turbulent diffusivity closure representing the effects of viscous dissipation and diffusion can be passed via the closure keyword.","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"See turbulence closures and large eddy simulation for more details on turbulent diffusivity closures.","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#Constant-isotropic-diffusivity","page":"Turbulent diffusivity closures and LES models","title":"Constant isotropic diffusivity","text":"","category":"section"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"To use constant isotropic values for the viscosity nu and diffusivity kappa you can use ScalarDiffusivity:","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"julia> using Oceananigans.TurbulenceClosures\n\njulia> closure = ScalarDiffusivity(ν=1e-2, κ=1e-2)\nScalarDiffusivity{ExplicitTimeDiscretization}(ν=0.01, κ=0.01)","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#Constant-anisotropic-diffusivity","page":"Turbulent diffusivity closures and LES models","title":"Constant anisotropic diffusivity","text":"","category":"section"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"To specify constant values for the horizontal and vertical viscosities, nu_h and nu_z, and horizontal and vertical diffusivities, kappa_h and kappa_z, you can use HorizontalScalarDiffusivity() and VerticalScalarDiffusivity(), e.g.,","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"julia> using Oceananigans.TurbulenceClosures\n\njulia> horizontal_closure = HorizontalScalarDiffusivity(ν=1e-3, κ=2e-3)\nHorizontalScalarDiffusivity{ExplicitTimeDiscretization}(ν=0.001, κ=0.002)\n\njulia> vertical_closure = VerticalScalarDiffusivity(ν=1e-3, κ=2e-3)\nVerticalScalarDiffusivity{ExplicitTimeDiscretization}(ν=0.001, κ=0.002)","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"After that you can set, e.g., closure = (horizontal_closure, vertical_closure) when constructing the model so that all components will be taken into account when calculating the diffusivity term. Note that VerticalScalarDiffusivity and HorizontalScalarDiffusivity are implemented using different schemes with different conservation properties.","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#Tracer-specific-diffusivities","page":"Turbulent diffusivity closures and LES models","title":"Tracer-specific diffusivities","text":"","category":"section"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"You can also set different diffusivities for each tracer in your simulation by passing a NamedTuple as the argument kappa:","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"julia> using Oceananigans.TurbulenceClosures\n\njulia> ScalarDiffusivity(ν=1e-6, κ=(S=1e-7, T=1e-10))\nScalarDiffusivity{ExplicitTimeDiscretization}(ν=1.0e-6, κ=(S=1.0e-7, T=1.0e-10))","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"The example above sets a viscosity of 1e-6, a diffusivity for a tracer called T of 1e-7, and a diffusivity for a tracer called S of 1e-10. Specifying diffusivities this way is also valid for HorizontalScalarDiffusivity and VerticalScalarDiffusivity. If this method is used, diffusivities for all tracers need to be specified.","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#Smagorinsky-Lilly","page":"Turbulent diffusivity closures and LES models","title":"Smagorinsky-Lilly","text":"","category":"section"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"To use the default Smagorinsky-Lilly LES closure, we write","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"julia> using Oceananigans.TurbulenceClosures\n\njulia> closure = SmagorinskyLilly()\nSmagorinskyLilly: C=0.16, Cb=1.0, Pr=1.0","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"The parameters C, Cb, and Pr may alternatively be specified explicitly. For more details see SmagorinskyLilly.","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#Anisotropic-minimum-dissipation","page":"Turbulent diffusivity closures and LES models","title":"Anisotropic minimum dissipation","text":"","category":"section"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"To use the constant anisotropic minimum dissipation (AMD) LES closure,","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"julia> using Oceananigans.TurbulenceClosures\n\njulia> closure = AnisotropicMinimumDissipation()\nAnisotropicMinimumDissipation{ExplicitTimeDiscretization} turbulence closure with:\n           Poincaré constant for momentum eddy viscosity Cν: 0.08333333333333333\n    Poincaré constant for tracer(s) eddy diffusivit(ies) Cκ: 0.08333333333333333\n                        Buoyancy modification multiplier Cb: nothing","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"no parameters are required although they may be specified. By default, the background viscosity and diffusivity are assumed to be the molecular values for seawater. For more details see AnisotropicMinimumDissipation.","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#Convective-Adjustment-Vertical-Diffusivity–Viscosity","page":"Turbulent diffusivity closures and LES models","title":"Convective Adjustment Vertical Diffusivity–Viscosity","text":"","category":"section"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"To use the a convective adjustment scheme that applies enhanced values for vertical diffusivity kappa_z and/or viscosity nu_z, anytime and anywhere the background stratification becomes unstable.","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"julia> using Oceananigans\n\njulia> closure = ConvectiveAdjustmentVerticalDiffusivity(convective_κz = 1.0, background_κz = 1e-3)\nConvectiveAdjustmentVerticalDiffusivity{VerticallyImplicitTimeDiscretization}(background_κz=0.001 convective_κz=1.0 background_νz=0.0 convective_νz=0.0)","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"EditURL = \"../../../examples/one_dimensional_diffusion.jl\"","category":"page"},{"location":"literated/one_dimensional_diffusion/#one_dimensional_diffusion_example","page":"One-dimensional diffusion","title":"Simple diffusion example","text":"","category":"section"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"This is Oceananigans.jl's simplest example: the diffusion of a one-dimensional Gaussian. This example demonstrates","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"How to load Oceananigans.jl.\nHow to instantiate an Oceananigans.jl model.\nHow to create simple Oceananigans.jl output.\nHow to set an initial condition with a function.\nHow to time-step a model forward.\nHow to look at results.","category":"page"},{"location":"literated/one_dimensional_diffusion/#Install-dependencies","page":"One-dimensional diffusion","title":"Install dependencies","text":"","category":"section"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"using Pkg\npkg\"add Oceananigans, CairoMakie\"","category":"page"},{"location":"literated/one_dimensional_diffusion/#Using-Oceananigans.jl","page":"One-dimensional diffusion","title":"Using Oceananigans.jl","text":"","category":"section"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Write","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"using Oceananigans","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"to load Oceananigans functions and objects into our script.","category":"page"},{"location":"literated/one_dimensional_diffusion/#Instantiating-and-configuring-a-model","page":"One-dimensional diffusion","title":"Instantiating and configuring a model","text":"","category":"section"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"A core Oceananigans type is NonhydrostaticModel. We build a NonhydrostaticModel by passing it a grid, plus information about the equations we would like to solve.","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Below, we build a rectilinear grid with 128 regularly-spaced grid points in the z-direction, where z spans from z = -0.5 to z = 0.5,","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"grid = RectilinearGrid(size=128, z=(-0.5, 0.5), topology=(Flat, Flat, Bounded))","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"1×1×128 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo\n├── Flat x                   \n├── Flat y                   \n└── Bounded  z ∈ [-0.5, 0.5] regularly spaced with Δz=0.0078125","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"The default topology is (Periodic, Periodic, Bounded). In this example, we're trying to solve a one-dimensional problem, so we assign Flat to the x and y topologies. We excise halos and avoid interpolation or differencing in Flat directions, saving computation and memory.","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"We next specify a model with an ScalarDiffusivity, which models either molecular or turbulent diffusion,","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"closure = ScalarDiffusivity(κ=1)","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"ScalarDiffusivity{ExplicitTimeDiscretization}(ν=0.0, κ=1.0)","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"We finally pass these two ingredients to NonhydrostaticModel,","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"model = NonhydrostaticModel(; grid, closure, tracers=:T)","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\n├── grid: 1×1×128 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo\n├── timestepper: RungeKutta3TimeStepper\n├── advection scheme: Centered reconstruction order 2\n├── tracers: T\n├── closure: ScalarDiffusivity{ExplicitTimeDiscretization}(ν=0.0, κ=(T=1.0,))\n├── buoyancy: Nothing\n└── coriolis: Nothing","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"By default, NonhydrostaticModel has no-flux (insulating and stress-free) boundary conditions on all fields.","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Next, we set! an initial condition on the temperature field, model.tracers.T. Our objective is to observe the diffusion of a Gaussian.","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"width = 0.1\ninitial_temperature(z) = exp(-z^2 / (2width^2))\nset!(model, T=initial_temperature)","category":"page"},{"location":"literated/one_dimensional_diffusion/#Visualizing-model-data","page":"One-dimensional diffusion","title":"Visualizing model data","text":"","category":"section"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Calling set! above changes the data contained in model.tracers.T, which was initialized as 0's when the model was created. To see the new data in model.tracers.T, we plot it:","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"using CairoMakie\nset_theme!(Theme(fontsize = 24, linewidth=3))\n\nfig = Figure()\naxis = (xlabel = \"Temperature (ᵒC)\", ylabel = \"z\")\nlabel = \"t = 0\"\nlines(model.tracers.T; label, axis)","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"(Image: )","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"The function interior above extracts a view of model.tracers.T over the physical points (excluding halos) at (1, 1, :).","category":"page"},{"location":"literated/one_dimensional_diffusion/#Running-a-Simulation","page":"One-dimensional diffusion","title":"Running a Simulation","text":"","category":"section"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Next we set-up a Simulation that time-steps the model forward and manages output.","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"# Time-scale for diffusion across a grid cell\nmin_Δz = minimum_zspacing(model.grid)\ndiffusion_time_scale = min_Δz^2 / model.closure.κ.T\n\nsimulation = Simulation(model, Δt = 0.1 * diffusion_time_scale, stop_iteration = 1000)","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Simulation of NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\n├── Next time step: 6.104 μs\n├── Elapsed wall time: 0 seconds\n├── Wall time per iteration: NaN days\n├── Stop time: Inf days\n├── Stop iteration : 1000.0\n├── Wall time limit: Inf\n├── Callbacks: OrderedDict with 4 entries:\n│   ├── stop_time_exceeded => Callback of stop_time_exceeded on IterationInterval(1)\n│   ├── stop_iteration_exceeded => Callback of stop_iteration_exceeded on IterationInterval(1)\n│   ├── wall_time_limit_exceeded => Callback of wall_time_limit_exceeded on IterationInterval(1)\n│   └── nan_checker => Callback of NaNChecker for u on IterationInterval(100)\n├── Output writers: OrderedDict with no entries\n└── Diagnostics: OrderedDict with no entries","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"simulation will run for 1000 iterations with a time-step that resolves the time-scale at which our temperature field diffuses. All that's left is to","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"run!(simulation)","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"[ Info: Initializing simulation...\n[ Info:     ... simulation initialization complete (2.475 seconds)\n[ Info: Executing initial time step...\n[ Info:     ... initial time step complete (4.266 seconds).\n[ Info: Simulation is stopping after running for 12.530 seconds.\n[ Info: Model iteration 1000 equals or exceeds stop iteration 1000.\n","category":"page"},{"location":"literated/one_dimensional_diffusion/#Visualizing-the-results","page":"One-dimensional diffusion","title":"Visualizing the results","text":"","category":"section"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Let's look at how model.tracers.T changed during the simulation.","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"using Printf\n\nlabel = @sprintf(\"t = %.3f\", model.clock.time)\nlines!(model.tracers.T; label)\naxislegend()","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"(Image: )","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Very interesting! Next, we run the simulation a bit longer and make an animation. For this, we use the JLD2OutputWriter to write data to disk as the simulation progresses.","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"simulation.output_writers[:temperature] =\n    JLD2OutputWriter(model, model.tracers,\n                     filename = \"one_dimensional_diffusion.jld2\",\n                     schedule=IterationInterval(100),\n                     overwrite_existing = true)","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"JLD2OutputWriter scheduled on IterationInterval(100):\n├── filepath: ./one_dimensional_diffusion.jld2\n├── 1 outputs: T\n├── array type: Array{Float64}\n├── including: [:grid, :coriolis, :buoyancy, :closure]\n├── file_splitting: NoFileSplitting\n└── file size: 20.9 KiB","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"We run the simulation for 10,000 more iterations,","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"simulation.stop_iteration += 10000\nrun!(simulation)","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"[ Info: Initializing simulation...\n[ Info:     ... simulation initialization complete (40.225 ms)\n[ Info: Executing initial time step...\n[ Info:     ... initial time step complete (5.294 ms).\n[ Info: Simulation is stopping after running for 54.772 seconds.\n[ Info: Model iteration 11000 equals or exceeds stop iteration 11000.\n","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Finally, we animate the results by opening the JLD2 file, extract the iterations we ended up saving at, and plot the evolution of the temperature profile in a loop over the iterations.","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"T_timeseries = FieldTimeSeries(\"one_dimensional_diffusion.jld2\", \"T\")\ntimes = T_timeseries.times\n\nfig = Figure()\nax = Axis(fig[2, 1]; xlabel = \"Temperature (ᵒC)\", ylabel = \"z\")\nxlims!(ax, 0, 1)\n\nn = Observable(1)\n\nT = @lift T_timeseries[$n]\nlines!(T)\n\nlabel = @lift \"t = \" * string(round(times[$n], digits=3))\nLabel(fig[1, 1], label, tellwidth=false)\n\nfig","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"(Image: )","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Finally, we record a movie.","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"frames = 1:length(times)\n\n@info \"Making an animation...\"\n\nrecord(fig, \"one_dimensional_diffusion.mp4\", frames, framerate=24) do i\n    n[] = i\nend","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"[ Info: Making an animation...\n","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"(Image: )","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"","category":"page"},{"location":"literated/one_dimensional_diffusion/","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"This page was generated using Literate.jl.","category":"page"},{"location":"physics/notation/#Coordinate-system-and-notation","page":"Coordinate system and notation","title":"Coordinate system and notation","text":"","category":"section"},{"location":"physics/notation/","page":"Coordinate system and notation","title":"Coordinate system and notation","text":"Oceananigans.jl is formulated in a Cartesian coordinate system boldsymbolx = (x y z)  with unit vectors boldsymbolhat x, boldsymbolhat y, and boldsymbolhat z,  where boldsymbolhat x points east, boldsymbolhat y points north, and boldsymbolhat z  points 'upward', opposite the direction of gravitational acceleration.","category":"page"},{"location":"physics/notation/","page":"Coordinate system and notation","title":"Coordinate system and notation","text":"We denote time with t, partial derivatives with respect to time t or a coordinate x  with partial_t or partial_x, and denote the gradient operator boldsymbolnabla equiv  partial_x boldsymbolhat x + partial_y boldsymbolhat y + partial_z boldsymbolhat z.  Horizontal gradients are denoted with boldsymbolnabla_h equiv partial_x boldsymbolhat x + partial_y boldsymbolhat y.","category":"page"},{"location":"physics/notation/","page":"Coordinate system and notation","title":"Coordinate system and notation","text":"We use u, v, and w to denote the east, north, and vertical velocity components, such that boldsymbolv = u boldsymbolhat x + v boldsymbolhat y + w boldsymbolhat z. We reserve boldsymbolv for the three-dimensional velocity field and use boldsymbolu to denote the horizontal components of flow, i.e., boldsymbolu = u boldsymbolhat x +  v boldsymbolhat y.","category":"page"},{"location":"simulations/#Simulations","page":"Simulations","title":"Simulations","text":"","category":"section"},{"location":"simulations/","page":"Simulations","title":"Simulations","text":"Simulations are basically a utility for managing a time-stepping loop, including scheduling important activities such as:","category":"page"},{"location":"simulations/","page":"Simulations","title":"Simulations","text":"Logging the progress of a simulation,\nComputing and writing diagnostics or other output to disk,\nStopping a simulation when its time has come.","category":"page"},{"location":"simulations/","page":"Simulations","title":"Simulations","text":"The most important line in any script is run!(simulation).","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"EditURL = \"../../../examples/kelvin_helmholtz_instability.jl\"","category":"page"},{"location":"literated/kelvin_helmholtz_instability/#Stratified-Kelvin-Helmholtz-instability","page":"Kelvin-Helmholtz instability","title":"Stratified Kelvin-Helmholtz instability","text":"","category":"section"},{"location":"literated/kelvin_helmholtz_instability/#Install-dependencies","page":"Kelvin-Helmholtz instability","title":"Install dependencies","text":"","category":"section"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"using Pkg\npkg\"add Oceananigans, CairoMakie\"","category":"page"},{"location":"literated/kelvin_helmholtz_instability/#The-physical-domain","page":"Kelvin-Helmholtz instability","title":"The physical domain","text":"","category":"section"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"We simulate a Kelvin-Helmholtz instability in two-dimensions in x z and therefore assign Flat to the y direction,","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"using Oceananigans\n\ngrid = RectilinearGrid(size=(64, 64), x=(-5, 5), z=(-5, 5),\n                       topology=(Periodic, Flat, Bounded))","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"64×1×64 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo\n├── Periodic x ∈ [-5.0, 5.0) regularly spaced with Δx=0.15625\n├── Flat y                   \n└── Bounded  z ∈ [-5.0, 5.0] regularly spaced with Δz=0.15625","category":"page"},{"location":"literated/kelvin_helmholtz_instability/#The-basic-state","page":"Kelvin-Helmholtz instability","title":"The basic state","text":"","category":"section"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"We're simulating the instability of a sheared and stably-stratified basic state U(z) and B(z). Two parameters define our basic state: the Richardson number,","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Ri = frac_z B(_z U)^2 ","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"and the width of the stratification layer, h.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"shear_flow(x, z, t) = tanh(z)\n\nstratification(x, z, t, p) = p.h * p.Ri * tanh(z / p.h)\n\nU = BackgroundField(shear_flow)\n\nB = BackgroundField(stratification, parameters=(Ri=0.1, h=1/4))","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"BackgroundField{typeof(Main.var\"##230\".stratification), @NamedTuple{Ri::Float64, h::Float64}}\n├── func: stratification (generic function with 1 method)\n└── parameters: (Ri = 0.1, h = 0.25)","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Our basic state thus has a thin layer of stratification in the center of the channel, embedded within a thicker shear layer surrounded by unstratified fluid.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"using CairoMakie\n\nzF = znodes(grid, Face())\nzC = znodes(grid, Center())\n\nRi, h = B.parameters\n\nfig = Figure(size = (850, 450))\n\nax = Axis(fig[1, 1], xlabel = \"U(z)\", ylabel = \"z\")\nlines!(ax, shear_flow.(0, zC, 0), zC; linewidth = 3)\n\nax = Axis(fig[1, 2], xlabel = \"B(z)\")\nlines!(ax, [stratification(0, z, 0, (Ri=Ri, h=h)) for z in zC], zC; linewidth = 3, color = :red)\n\nax = Axis(fig[1, 3], xlabel = \"Ri(z)\")\nlines!(ax, [Ri * sech(z / h)^2 / sech(z)^2 for z in zF], zF; linewidth = 3, color = :black) # Ri(z)= ∂_z B / (∂_z U)²; derivatives computed by hand\n\nfig","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"(Image: )","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"In unstable flows it is often useful to determine the dominant spatial structure of the instability and the growth rate at which the instability grows. If the simulation idealizes a physical flow, this can be used to make predictions as to what should develop and how quickly. Since these instabilities are often attributed to a linear instability, we can determine information about the structure and the growth rate of the instability by analyzing the linear operator that governs small perturbations about a base state, or by solving for the linear dynamics.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Here, we discuss first briefly linear instabilities and how one can obtain growth rates and structures of most unstable modes via eigenanalysis. Then we present an alternative method for approximating the eigenanalysis results when one does not have access to the linear dynamics or the linear operator about the base state.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/#Linear-Instabilities","page":"Kelvin-Helmholtz instability","title":"Linear Instabilities","text":"","category":"section"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"The base state U(z), B(z) is a solution of the inviscid equations of motion. Whether the base state is stable or not is determined by whether small perturbations about this base state grow or decay. To formalize this, we study the linearized dynamics satisfied by perturbations about the base state:","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"partial_t Phi = L Phi  ","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"where Phi = (u v w b) is a vector of the perturbation velocities u v w and perturbation buoyancy b and L a linear operator that depends on the base state, L = L(U(z) B(z)) (the background_fields). Eigenanalysis of the linear operator L determines the stability of the base state, such as the Kelvin-Helmholtz instability. That is, by using the ansantz","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Phi(x y z t) = phi(x y z)  exp(lambda t)  ","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"then lambda and phi are respectively eigenvalues and eigenmodes of L, i.e., they obey","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"L  phi_j = lambda_j  phi_j quad j=12dots  ","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"From hereafter we'll use the convention that the eigenvalues are ordered according to their real part, mathrmRe(lambda_1) ge mathrmRe(lambda_2) ge dotsb.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Remarks:","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"As we touched upon briefly above, Oceananigans.jl, does not include the linearized version of the equations. Furthermore, Oceananigans.jl does not give us access to the linear operator L so that we can perform eigenanalysis. Below we discuss an alternative way of approximating the eigenanalysis results. The method boils down to solving the nonlinear equations while continually renormalize the magnitude of the perturbations to ensure that nonlinear terms (terms that are quadratic or higher in perturbations) remain negligibly small, i.e.,much smaller than the background flow.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/#The-power-method-algorithm","page":"Kelvin-Helmholtz instability","title":"The power method algorithm","text":"","category":"section"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Successive application of L to a random initial state will eventually render it parallel with eigenmode phi_1:","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"lim_n to infty L^n Phi propto phi_1  ","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Of course, if phi_1 is an unstable mode (i.e., sigma_1 = mathrmRe(lambda_1)  0), then successive application of L will lead to exponential amplification. (Similarly, if sigma_1  0, successive application of L will lead to exponential decay of Phi down to machine precision.) Therefore, after each application of the linear operator L, we rescale the output L Phi back to a pre-selected amplitude.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"So, we initialize a simulation with random initial conditions with amplitude much less than those of the base state (which are O(1)). Instead of \"applying\" L on our initial state, we evolve the (approximately) linear dynamics for interval Delta tau. We measure how much the energy has grown during that interval, rescale the perturbations back to original energy amplitude and repeat. After some iterations the state will converge to the most unstable eigenmode.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"In summary, each iteration of the power method includes:","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"compute the perturbation energy, E_0,\nevolve the system for a time-interval Delta tau,\ncompute the perturbation energy, E_1,\ndetermine the exponential growth of the most unstable mode during the interval Delta tau as  log(E_1  E_0)  (2 Delta tau),\nrepeat the above until growth rate converges.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"By fiddling a bit with Delta t we can get convergence after only a few iterations.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Let's apply all these to our example.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/#The-model","page":"Kelvin-Helmholtz instability","title":"The model","text":"","category":"section"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"model = NonhydrostaticModel(timestepper = :RungeKutta3,\n                              advection = UpwindBiasedFifthOrder(),\n                                   grid = grid,\n                               coriolis = nothing,\n                      background_fields = (u=U, b=B),\n                                closure = ScalarDiffusivity(ν=2e-4, κ=2e-4),\n                               buoyancy = BuoyancyTracer(),\n                                tracers = :b)","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\n├── grid: 64×1×64 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo\n├── timestepper: RungeKutta3TimeStepper\n├── advection scheme: FluxFormAdvection{3, Float64, UpwindBiased{3, Float64, Nothing, Nothing, Nothing, UpwindBiased{2, Float64, Nothing, Nothing, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{2, Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}}, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, UpwindBiased{3, Float64, Nothing, Nothing, Nothing, UpwindBiased{2, Float64, Nothing, Nothing, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{2, Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}}}\n├── tracers: b\n├── closure: ScalarDiffusivity{ExplicitTimeDiscretization}(ν=0.0002, κ=(b=0.0002,))\n├── buoyancy: BuoyancyTracer with ĝ = NegativeZDirection()\n└── coriolis: Nothing","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"We have included a \"pinch\" of viscosity and diffusivity in anticipation of what will follow furtherdown: viscosity and diffusivity will ensure numerical stability when we evolve the unstable mode to the point it becomes nonlinear.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Here, we take Delta tau = 15. We also set verbose=false so that run!(simulation) is a little quieter.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"simulation = Simulation(model, Δt=0.1, stop_iteration=150, verbose=false)","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Simulation of NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\n├── Next time step: 100 ms\n├── Elapsed wall time: 0 seconds\n├── Wall time per iteration: NaN days\n├── Stop time: Inf days\n├── Stop iteration : 150.0\n├── Wall time limit: Inf\n├── Callbacks: OrderedDict with 4 entries:\n│   ├── stop_time_exceeded => Callback of stop_time_exceeded on IterationInterval(1)\n│   ├── stop_iteration_exceeded => Callback of stop_iteration_exceeded on IterationInterval(1)\n│   ├── wall_time_limit_exceeded => Callback of wall_time_limit_exceeded on IterationInterval(1)\n│   └── nan_checker => Callback of NaNChecker for u on IterationInterval(100)\n├── Output writers: OrderedDict with no entries\n└── Diagnostics: OrderedDict with no entries","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Now some helper functions that will be used during for the power method algorithm.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"First a function that evolves the state for Delta tau and measure the energy growth over that period.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"\"\"\"\n    grow_instability!(simulation, energy)\n\nGrow an instability by running `simulation`.\n\nEstimates the growth rate ``σ`` of the instability\nusing the fractional change in volume-mean kinetic energy,\nover the course of the `simulation`\n\n``\nenergy(t₀ + Δτ) / energy(t₀) ≈ exp(2 σ Δτ)\n``\n\nwhere ``t₀`` is the starting time of the simulation and ``t₀ + Δτ``\nthe ending time of the simulation. We thus find that the growth rate\nis measured by\n\n``\nσ = log(energy(t₀ + Δτ) / energy(t₀)) / (2 Δτ) .\n``\n\"\"\"\nfunction grow_instability!(simulation, energy)\n    # Initialize\n    simulation.model.clock.iteration = 0\n    t₀ = simulation.model.clock.time = 0\n    compute!(energy)\n    energy₀ = energy[1, 1, 1]\n\n    # Grow\n    run!(simulation)\n\n    # Analyze\n    compute!(energy)\n    energy₁ = energy[1, 1, 1]\n    Δτ = simulation.model.clock.time - t₀\n\n    # ½(u² + v²) ~ exp(2 σ Δτ)\n    σ = growth_rate = log(energy₁ / energy₀) / 2Δτ\n\n    return growth_rate\nend","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Finally, we write a function that rescales the state. The rescaling is done via computing the kinetic energy and then rescaling all flow fields so that the kinetic energy assumes a targetted value.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"(Measuring the perturbation growth via the kinetic energy works fine unless an unstable mode only has buoyancy structure. In that case, the total perturbation energy is more adequate.)","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"\"\"\"\n    rescale!(model, energy; target_kinetic_energy = 1e-3)\n\nRescales all model fields so that `energy = target_kinetic_energy`.\n\"\"\"\nfunction rescale!(model, energy; target_kinetic_energy = 1e-6)\n    compute!(energy)\n    rescale_factor = √(target_kinetic_energy / energy[1, 1, 1])\n\n    for f in merge(model.velocities, model.tracers)\n        f .*= rescale_factor\n    end\n\n    return nothing\nend\n\nusing Printf","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Another helper function for the power method,","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"\"\"\"\n    convergence(σ)\n\nCheck if the growth rate has converged. If the array `σ` has at least 2 elements then returns the\nrelative difference between ``σ[end]`` and ``σ[end-1]``.\n\"\"\"\nconvergence(σ) = length(σ) > 1 ? abs((σ[end] - σ[end-1]) / σ[end]) : 9.1e18 # pretty big (not Inf tho)","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"and the main function that performs the power method iteration.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"\"\"\"\n    estimate_growth_rate(simulation, energy, ω; convergence_criterion=1e-3)\n\nEstimates the growth rate iteratively until the relative change\nin the estimated growth rate ``σ`` falls below `convergence_criterion`.\n\nReturns ``σ``.\n\"\"\"\nfunction estimate_growth_rate(simulation, energy, ω, b; convergence_criterion=1e-3)\n    σ = []\n    power_method_data = []\n    compute!(ω)\n    push!(power_method_data, (ω=collect(interior(ω, :, 1, :)), b=collect(interior(b, :, 1, :)), σ=deepcopy(σ)))\n\n    while convergence(σ) > convergence_criterion\n        compute!(energy)\n\n        @info @sprintf(\"About to start power method iteration %d; kinetic energy: %.2e\", length(σ)+1, energy[1, 1, 1])\n        push!(σ, grow_instability!(simulation, energy))\n        compute!(energy)\n\n        @info @sprintf(\"Power method iteration %d, kinetic energy: %.2e, σⁿ: %.2e, relative Δσ: %.2e\",\n                       length(σ), energy[1, 1, 1], σ[end], convergence(σ))\n\n        compute!(ω)\n        rescale!(simulation.model, energy)\n        push!(power_method_data, (ω=collect(interior(ω, :, 1, :)), b=collect(interior(b, :, 1, :)), σ=deepcopy(σ)))\n    end\n\n    return σ, power_method_data\nend","category":"page"},{"location":"literated/kelvin_helmholtz_instability/#Eigenplotting","page":"Kelvin-Helmholtz instability","title":"Eigenplotting","text":"","category":"section"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"A good algorithm wouldn't be complete without a good visualization,","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"u, v, w = model.velocities\nb = model.tracers.b\n\nperturbation_vorticity = Field(∂z(u) - ∂x(w))\n\nxω, yω, zω = nodes(perturbation_vorticity)\nxb, yb, zb = nodes(b)","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"([-4.921875, -4.765625, -4.609375, -4.453125, -4.296875, -4.140625, -3.984375, -3.828125, -3.671875, -3.515625, -3.359375, -3.203125, -3.046875, -2.890625, -2.734375, -2.578125, -2.421875, -2.265625, -2.109375, -1.953125, -1.796875, -1.640625, -1.484375, -1.328125, -1.171875, -1.015625, -0.859375, -0.703125, -0.546875, -0.390625, -0.234375, -0.078125, 0.078125, 0.234375, 0.390625, 0.546875, 0.703125, 0.859375, 1.015625, 1.171875, 1.328125, 1.484375, 1.640625, 1.796875, 1.953125, 2.109375, 2.265625, 2.421875, 2.578125, 2.734375, 2.890625, 3.046875, 3.203125, 3.359375, 3.515625, 3.671875, 3.828125, 3.984375, 4.140625, 4.296875, 4.453125, 4.609375, 4.765625, 4.921875], nothing, [-4.921875, -4.765625, -4.609375, -4.453125, -4.296875, -4.140625, -3.984375, -3.828125, -3.671875, -3.515625, -3.359375, -3.203125, -3.046875, -2.890625, -2.734375, -2.578125, -2.421875, -2.265625, -2.109375, -1.953125, -1.796875, -1.640625, -1.484375, -1.328125, -1.171875, -1.015625, -0.859375, -0.703125, -0.546875, -0.390625, -0.234375, -0.078125, 0.078125, 0.234375, 0.390625, 0.546875, 0.703125, 0.859375, 1.015625, 1.171875, 1.328125, 1.484375, 1.640625, 1.796875, 1.953125, 2.109375, 2.265625, 2.421875, 2.578125, 2.734375, 2.890625, 3.046875, 3.203125, 3.359375, 3.515625, 3.671875, 3.828125, 3.984375, 4.140625, 4.296875, 4.453125, 4.609375, 4.765625, 4.921875])","category":"page"},{"location":"literated/kelvin_helmholtz_instability/#Rev-your-engines...","page":"Kelvin-Helmholtz instability","title":"Rev your engines...","text":"","category":"section"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"We initialize the power iteration with random noise and rescale to have a target_kinetic_energy","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"using Random, Statistics\n\nmean_perturbation_kinetic_energy = Field(Average(1/2 * (u^2 + w^2)))\nnoise(x, z) = randn()\nset!(model, u=noise, w=noise, b=noise)\nrescale!(simulation.model, mean_perturbation_kinetic_energy, target_kinetic_energy=1e-6)\ngrowth_rates, power_method_data = estimate_growth_rate(simulation, mean_perturbation_kinetic_energy, perturbation_vorticity, b)\n\n@info \"Power iterations converged! Estimated growth rate: $(growth_rates[end])\"","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"[ Info: About to start power method iteration 1; kinetic energy: 1.94e-03\n[ Info: Power method iteration 1, kinetic energy: 5.81e-06, σⁿ: -1.94e-01, relative Δσ: 9.10e+18\n[ Info: About to start power method iteration 2; kinetic energy: 1.02e-06\n[ Info: Power method iteration 2, kinetic energy: 9.79e-06, σⁿ: 7.55e-02, relative Δσ: 3.56e+00\n[ Info: About to start power method iteration 3; kinetic energy: 1.06e-06\n[ Info: Power method iteration 3, kinetic energy: 1.40e-05, σⁿ: 8.60e-02, relative Δσ: 1.22e-01\n[ Info: About to start power method iteration 4; kinetic energy: 1.08e-06\n[ Info: Power method iteration 4, kinetic energy: 1.65e-05, σⁿ: 9.10e-02, relative Δσ: 5.50e-02\n[ Info: About to start power method iteration 5; kinetic energy: 1.10e-06\n[ Info: Power method iteration 5, kinetic energy: 1.71e-05, σⁿ: 9.16e-02, relative Δσ: 6.45e-03\n[ Info: About to start power method iteration 6; kinetic energy: 1.10e-06\n[ Info: Power method iteration 6, kinetic energy: 1.72e-05, σⁿ: 9.16e-02, relative Δσ: 5.52e-04\n[ Info: Power iterations converged! Estimated growth rate: 0.09161450122577916\n","category":"page"},{"location":"literated/kelvin_helmholtz_instability/#Powerful-convergence","page":"Kelvin-Helmholtz instability","title":"Powerful convergence","text":"","category":"section"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"We animate the power method steps. A scatter plot illustrates how the growth rate converges as the power method iterates.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"n = Observable(1)\n\nfig = Figure(size=(800, 600))\n\nkwargs = (xlabel=\"x\", ylabel=\"z\", limits = ((xω[1], xω[end]), (zω[1], zω[end])), aspect=1,)\n\nω_title(t) = t === nothing ? @sprintf(\"vorticity\") : @sprintf(\"vorticity at t = %.2f\", t)\nb_title(t) = t === nothing ? @sprintf(\"buoyancy\")  : @sprintf(\"buoyancy at t = %.2f\", t)\n\nax_ω = Axis(fig[2, 1]; title = ω_title(nothing), kwargs...)\n\nax_b = Axis(fig[2, 3]; title = b_title(nothing), kwargs...)\n\nωₙ = @lift power_method_data[$n].ω\nbₙ = @lift power_method_data[$n].b\n\nσₙ = @lift [(i-1, i==1 ? NaN : growth_rates[i-1]) for i in 1:$n]\n\nω_lims = @lift (-maximum(abs, power_method_data[$n].ω) - 1e-16, maximum(abs, power_method_data[$n].ω) + 1e-16)\nb_lims = @lift (-maximum(abs, power_method_data[$n].b) - 1e-16, maximum(abs, power_method_data[$n].b) + 1e-16)\n\nhm_ω = heatmap!(ax_ω, xω, zω, ωₙ; colorrange = ω_lims, colormap = :balance)\nColorbar(fig[2, 2], hm_ω)\n\nhm_b = heatmap!(ax_b, xb, zb, bₙ; colorrange = b_lims, colormap = :balance)\nColorbar(fig[2, 4], hm_b)\n\neigentitle(σ, t) = length(σ) > 0 ? @sprintf(\"Iteration #%i; growth rate %.2e\", length(σ), σ[end]) : @sprintf(\"Initial perturbation fields\")\nσ_title = @lift eigentitle(power_method_data[$n].σ, nothing)\n\nax_σ = Axis(fig[1, :];\n            xlabel = \"Power iteration\",\n            ylabel = \"Growth rate\",\n            title = σ_title,\n            xticks = 1:length(power_method_data)-1,\n            limits = ((0.5, length(power_method_data)-0.5), (-0.25, 0.25)))\n\nscatter!(ax_σ, σₙ; color = :blue)\n\nframes = 1:length(power_method_data)\n\nrecord(fig, \"powermethod.mp4\", frames, framerate=1) do i\n       n[] = i\nend\n","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"(Image: )","category":"page"},{"location":"literated/kelvin_helmholtz_instability/#Now-for-the-fun-part","page":"Kelvin-Helmholtz instability","title":"Now for the fun part","text":"","category":"section"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Now we simulate the nonlinear evolution of the eigenmode we've isolated for a few e-folding times 1sigma,","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"# Reset the clock\nmodel.clock.iteration = 0\nmodel.clock.time = 0\n\nestimated_growth_rate = growth_rates[end]\n\nsimulation.stop_time = 5 / estimated_growth_rate\nsimulation.stop_iteration = 9.1e18 # pretty big (not Inf tho)\n\n# Rescale the eigenmode\ninitial_eigenmode_energy = 5e-5\nrescale!(simulation.model, mean_perturbation_kinetic_energy, target_kinetic_energy=initial_eigenmode_energy)","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Let's save and plot the perturbation vorticity and buoyancy and also the total vorticity and buoyancy (perturbation + basic state). It'll be also neat to plot the kinetic energy time-series and confirm it grows with the estimated growth rate.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"total_vorticity = Field(∂z(u) + ∂z(model.background_fields.velocities.u) - ∂x(w))\n\ntotal_b = Field(b + model.background_fields.tracers.b)\n\nsimulation.output_writers[:vorticity] =\n    JLD2OutputWriter(model, (ω=perturbation_vorticity, Ω=total_vorticity, b=b, B=total_b, KE=mean_perturbation_kinetic_energy),\n                     schedule = TimeInterval(0.10 / estimated_growth_rate),\n                     filename = \"kelvin_helmholtz_instability.jld2\",\n                     overwrite_existing = true)","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"JLD2OutputWriter scheduled on TimeInterval(1.092 seconds):\n├── filepath: ./kelvin_helmholtz_instability.jld2\n├── 5 outputs: (ω, Ω, b, B, KE)\n├── array type: Array{Float64}\n├── including: [:grid, :coriolis, :buoyancy, :closure]\n├── file_splitting: NoFileSplitting\n└── file size: 41.0 KiB","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"And now we...","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"@info \"*** Running a simulation of Kelvin-Helmholtz instability...\"\nrun!(simulation)","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"[ Info: *** Running a simulation of Kelvin-Helmholtz instability...\n","category":"page"},{"location":"literated/kelvin_helmholtz_instability/#Pretty-things","page":"Kelvin-Helmholtz instability","title":"Pretty things","text":"","category":"section"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"First we plot the nonlinear equilibration of the perturbation fields together with the evolution of the kinetic energy,","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"@info \"Making a neat movie of stratified shear flow...\"\n\nfilepath = simulation.output_writers[:vorticity].filepath\n\nω_timeseries = FieldTimeSeries(filepath, \"ω\")\nb_timeseries = FieldTimeSeries(filepath, \"b\")\nΩ_timeseries = FieldTimeSeries(filepath, \"Ω\")\nB_timeseries = FieldTimeSeries(filepath, \"B\")\nKE_timeseries = FieldTimeSeries(filepath, \"KE\")\n\ntimes = ω_timeseries.times\n\nt_final = times[end]\n\nn = Observable(1)\n\nωₙ = @lift interior(ω_timeseries, :, 1, :, $n)\nbₙ = @lift interior(b_timeseries, :, 1, :, $n)\n\nfig = Figure(size=(800, 600))\n\nkwargs = (xlabel=\"x\", ylabel=\"z\", limits = ((xω[1], xω[end]), (zω[1], zω[end])), aspect=1,)\n\ntitle = @lift @sprintf(\"t = %.2f\", times[$n])\n\nax_ω = Axis(fig[2, 1]; title = \"perturbation vorticity\", kwargs...)\n\nax_b = Axis(fig[2, 3]; title = \"perturbation buoyancy\", kwargs...)\n\nax_KE = Axis(fig[3, :];\n             yscale = log10,\n             limits = ((0, t_final), (initial_eigenmode_energy, 1e-1)),\n             xlabel = \"time\")\n\nfig[1, :] = Label(fig, title, fontsize=24, tellwidth=false)\n\nω_lims = @lift (-maximum(abs, interior(ω_timeseries, :, 1, :, $n)) - 1e-16, maximum(abs, interior(ω_timeseries, :, 1, :, $n)) + 1e-16)\nb_lims = @lift (-maximum(abs, interior(b_timeseries, :, 1, :, $n)) - 1e-16, maximum(abs, interior(b_timeseries, :, 1, :, $n)) + 1e-16)\n\nhm_ω = heatmap!(ax_ω, xω, zω, ωₙ; colorrange = ω_lims, colormap = :balance)\nColorbar(fig[2, 2], hm_ω)\n\nhm_b = heatmap!(ax_b, xb, zb, bₙ; colorrange = b_lims, colormap = :balance)\nColorbar(fig[2, 4], hm_b)\n\ntₙ = @lift times[1:$n]\nKEₙ = @lift KE_timeseries[1:$n]\n\nlines!(ax_KE, [0, t_final], @. initial_eigenmode_energy * exp(2 * estimated_growth_rate * [0, t_final]);\n       label = \"~ exp(2 σ t)\",\n       linewidth = 2,\n       color = :black)\n\nlines!(ax_KE, times, KE_timeseries[:];\n       label = \"perturbation kinetic energy\",\n       linewidth = 4, color = :blue, alpha = 0.4)\n\nKE_point = @lift Point2f[(times[$n], KE_timeseries[$n][1, 1, 1])]\n\nscatter!(ax_KE, KE_point;\n         marker = :circle, markersize = 16, color = :blue)\n\nframes = 1:length(times)\n\nrecord(fig, \"kelvin_helmholtz_instability_perturbations.mp4\", frames, framerate=8) do i\n    @info \"Plotting frame $i of $(frames[end])...\"\n    n[] = i\nend","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"[ Info: Making a neat movie of stratified shear flow...\n[ Info: Plotting frame 1 of 51...\n[ Info: Plotting frame 2 of 51...\n[ Info: Plotting frame 3 of 51...\n[ Info: Plotting frame 4 of 51...\n[ Info: Plotting frame 5 of 51...\n[ Info: Plotting frame 6 of 51...\n[ Info: Plotting frame 7 of 51...\n[ Info: Plotting frame 8 of 51...\n[ Info: Plotting frame 9 of 51...\n[ Info: Plotting frame 10 of 51...\n[ Info: Plotting frame 11 of 51...\n[ Info: Plotting frame 12 of 51...\n[ Info: Plotting frame 13 of 51...\n[ Info: Plotting frame 14 of 51...\n[ Info: Plotting frame 15 of 51...\n[ Info: Plotting frame 16 of 51...\n[ Info: Plotting frame 17 of 51...\n[ Info: Plotting frame 18 of 51...\n[ Info: Plotting frame 19 of 51...\n[ Info: Plotting frame 20 of 51...\n[ Info: Plotting frame 21 of 51...\n[ Info: Plotting frame 22 of 51...\n[ Info: Plotting frame 23 of 51...\n[ Info: Plotting frame 24 of 51...\n[ Info: Plotting frame 25 of 51...\n[ Info: Plotting frame 26 of 51...\n[ Info: Plotting frame 27 of 51...\n[ Info: Plotting frame 28 of 51...\n[ Info: Plotting frame 29 of 51...\n[ Info: Plotting frame 30 of 51...\n[ Info: Plotting frame 31 of 51...\n[ Info: Plotting frame 32 of 51...\n[ Info: Plotting frame 33 of 51...\n[ Info: Plotting frame 34 of 51...\n[ Info: Plotting frame 35 of 51...\n[ Info: Plotting frame 36 of 51...\n[ Info: Plotting frame 37 of 51...\n[ Info: Plotting frame 38 of 51...\n[ Info: Plotting frame 39 of 51...\n[ Info: Plotting frame 40 of 51...\n[ Info: Plotting frame 41 of 51...\n[ Info: Plotting frame 42 of 51...\n[ Info: Plotting frame 43 of 51...\n[ Info: Plotting frame 44 of 51...\n[ Info: Plotting frame 45 of 51...\n[ Info: Plotting frame 46 of 51...\n[ Info: Plotting frame 47 of 51...\n[ Info: Plotting frame 48 of 51...\n[ Info: Plotting frame 49 of 51...\n[ Info: Plotting frame 50 of 51...\n[ Info: Plotting frame 51 of 51...\n","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"(Image: )","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"And then the same for total vorticity & buoyancy of the fluid.","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"n = Observable(1)\n\nΩₙ = @lift interior(Ω_timeseries, :, 1, :, $n)\nBₙ = @lift interior(B_timeseries, :, 1, :, $n)\n\nfig = Figure(size=(800, 600))\n\nkwargs = (xlabel=\"x\", ylabel=\"z\", limits = ((xω[1], xω[end]), (zω[1], zω[end])), aspect=1,)\n\ntitle = @lift @sprintf(\"t = %.2f\", times[$n])\n\nax_Ω = Axis(fig[2, 1]; title = \"total vorticity\", kwargs...)\n\nax_B = Axis(fig[2, 3]; title = \"total buoyancy\", kwargs...)\n\nax_KE = Axis(fig[3, :];\n             yscale = log10,\n             limits = ((0, t_final), (initial_eigenmode_energy, 1e-1)),\n             xlabel = \"time\")\n\nfig[1, :] = Label(fig, title, fontsize=24, tellwidth=false)\n\nhm_Ω = heatmap!(ax_Ω, xω, zω, Ωₙ; colorrange = (-1, 1), colormap = :balance)\nColorbar(fig[2, 2], hm_Ω)\n\nhm_B = heatmap!(ax_B, xb, zb, Bₙ; colorrange = (-0.05, 0.05), colormap = :balance)\nColorbar(fig[2, 4], hm_B)\n\ntₙ = @lift times[1:$n]\nKEₙ = @lift KE_timeseries[1, 1, 1, 1:$n]\n\nlines!(ax_KE, [0, t_final], @. initial_eigenmode_energy * exp(2 * estimated_growth_rate * [0, t_final]);\n       label = \"~ exp(2 σ t)\",\n       linewidth = 2,\n       color = :black)\n\nlines!(ax_KE, times, KE_timeseries[:];\n       label = \"perturbation kinetic energy\",\n       linewidth = 4, color = :blue, alpha = 0.4)\n\nKE_point = @lift Point2f[(times[$n], KE_timeseries[$n][1, 1, 1])]\n\nscatter!(ax_KE, KE_point;\n         marker = :circle, markersize = 16, color = :blue)\n\naxislegend(ax_KE; position = :rb)\n\nrecord(fig, \"kelvin_helmholtz_instability_total.mp4\", frames, framerate=8) do i\n    n[] = i\nend","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"(Image: )","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"","category":"page"},{"location":"literated/kelvin_helmholtz_instability/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"This page was generated using Literate.jl.","category":"page"},{"location":"model_setup/checkpointing/#checkpointing","page":"Checkpointing","title":"Checkpointing","text":"","category":"section"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"A Checkpointer can be used to serialize the entire model state to a file from which the model can be restored at any time. This is useful if you'd like to periodically checkpoint when running long simulations in case of crashes or hitting cluster time limits, but also if you'd like to restore from a checkpoint and try out multiple scenarios.","category":"page"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"For example, to periodically checkpoint the model state to disk every 1,000,000 seconds of simulation time to files of the form model_checkpoint_iteration12500.jld2 where 12500 is the iteration number (automatically filled in).","category":"page"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"Here's an example where we checkpoint every 5 iterations. This is far more often than appropriate for typical applications: we only do it here for illustration purposes.","category":"page"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"using Oceananigans\n\nmodel = NonhydrostaticModel(grid=RectilinearGrid(size=(8, 8, 8), extent=(1, 1, 1)))\n\nsimulation = Simulation(model, Δt=1, stop_iteration=8)\n\nsimulation.output_writers[:checkpointer] = Checkpointer(model, schedule=IterationInterval(5), prefix=\"model_checkpoint\")","category":"page"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"Again, for illustration purposes of this example, we also add another callback so we can see the iteration of the simulation","category":"page"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"show_iteration(sim) = @info \"iteration: $(iteration(sim)); time: $(prettytime(sim.model.clock.time))\"\nadd_callback!(simulation, show_iteration, name=:info, IterationInterval(1))","category":"page"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"Now let's run","category":"page"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"run!(simulation)","category":"page"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"The default options should provide checkpoint files that are easy to restore from (in most cases). For more advanced options and features, see Checkpointer.","category":"page"},{"location":"model_setup/checkpointing/#Picking-up-a-simulation-from-a-checkpoint-file","page":"Checkpointing","title":"Picking up a simulation from a checkpoint file","text":"","category":"section"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"Picking up a simulation from a checkpoint requires the original script that was used to generate the checkpoint data. Change the first instance of run! in the script to take pickup=true.","category":"page"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"When pickup=true is provided to run! then it finds the latest checkpoint file in the current working directory, loads prognostic fields and their tendencies from file, resets the model clock and iteration, to the clock time and iteration that the checkpoint corresponds to, and updates the model auxiliary state. After that, the time-stepping loop. In this simple example, although the simulation run up to iteration 8, the latest checkpoint is associated with iteration 5.","category":"page"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"simulation.stop_iteration = 12\n\nrun!(simulation, pickup=true)","category":"page"},{"location":"model_setup/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"Use pickup=iteration, where iteration is an Integer, to pick up from a specific iteration. Or, use pickup=filepath, where filepath is a string, to pickup from a specific file located at filepath.","category":"page"},{"location":"model_setup/forcing_functions/#Forcing-functions","page":"Forcing functions","title":"Forcing functions","text":"","category":"section"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"\"Forcings\" are user-defined terms appended to right-hand side of the momentum or tracer evolution equations. In Oceananigans, momentum and tracer forcings are defined via julia functions. Oceananigans includes an interface for implementing forcing functions that depend on spatial coordinates, time, model velocity and tracer fields, and external parameters.","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"DocTestSetup = quote\n    using Oceananigans\nend","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"Forcings are added to models by passing a NamedTuple of functions or forcing objects to the forcing keyword argument in NonhydrostaticModel's constructor. By default, momentum and tracer forcing functions are assumed to be functions of x, y, z, t. A basic example is","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"u_forcing(x, y, z, t) = exp(z) * cos(x) * sin(t)\n\ngrid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))\nmodel = NonhydrostaticModel(grid=grid, forcing=(u=u_forcing,))\n\nmodel.forcing.u\n\n# output\nContinuousForcing{Nothing} at (Face, Center, Center)\n├── func: u_forcing (generic function with 1 method)\n├── parameters: nothing\n└── field dependencies: ()","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"More general forcing functions are built via the Forcing constructor described below. Oceananigans also provides two convenience types:","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"Relaxation for damping terms that restore a field to a target distribution outside of a masked region of space. Relaxation can be used to implement sponge layers near the boundaries of a domain.\nAdvectiveForcing for advecting individual quantities by a separate or \"slip\" velocity relative to both the prognostic model velocity field and any BackgroundField velocity field.","category":"page"},{"location":"model_setup/forcing_functions/#The-Forcing-constructor","page":"Forcing functions","title":"The Forcing constructor","text":"","category":"section"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"The Forcing constructor provides an interface for specifying forcing functions that","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"Depend on external parameters; and\nDepend on model fields at the x, y, z location that forcing is applied; and/or\nRequire access to discrete model data.","category":"page"},{"location":"model_setup/forcing_functions/#Forcing-functions-with-external-parameters","page":"Forcing functions","title":"Forcing functions with external parameters","text":"","category":"section"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"Most forcings involve external, changeable parameters. Here are two examples of forcing_functions that depend on  (i) a single scalar parameter s, and (ii) a NamedTuple of parameters, p:","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"# Forcing that depends on a scalar parameter `s`\nu_forcing_func(x, y, z, t, s) = s * z\n\nu_forcing = Forcing(u_forcing_func, parameters=0.1)\n\n# Forcing that depends on a `NamedTuple` of parameters `p`\nT_forcing_func(x, y, z, t, p) = - p.μ * exp(z / p.λ) * cos(p.k * x) * sin(p.ω * t)\n\nT_forcing = Forcing(T_forcing_func, parameters=(μ=1, λ=0.5, k=2π, ω=4π))\n\ngrid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))\nmodel = NonhydrostaticModel(grid=grid, forcing=(u=u_forcing, T=T_forcing), buoyancy=SeawaterBuoyancy(), tracers=(:T, :S))\n\nmodel.forcing.T\n\n# output\nContinuousForcing{@NamedTuple{μ::Int64, λ::Float64, k::Float64, ω::Float64}} at (Center, Center, Center)\n├── func: T_forcing_func (generic function with 1 method)\n├── parameters: (μ = 1, λ = 0.5, k = 6.283185307179586, ω = 12.566370614359172)\n└── field dependencies: ()","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"model.forcing.u\n\n# output\nContinuousForcing{Float64} at (Face, Center, Center)\n├── func: u_forcing_func (generic function with 1 method)\n├── parameters: 0.1\n└── field dependencies: ()","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"In this example, the objects passed to the parameters keyword in the construction of u_forcing and T_forcing – a floating point number for u_forcing, and a NamedTuple of parameters for T_forcing – are passed on to u_forcing_func and T_forcing_func when they are called during time-stepping. The object passed to parameters is in principle arbitrary. However, if using the GPU, then typeof(parameters) may be restricted by the requirements of GPU-compiliability.","category":"page"},{"location":"model_setup/forcing_functions/#Forcing-functions-that-depend-on-model-fields","page":"Forcing functions","title":"Forcing functions that depend on model fields","text":"","category":"section"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"Forcing functions may depend on model fields (velocity, tracers or auxiliary fields) evaluated at the x, y, z where forcing is applied. Here's a somewhat non-sensical example:","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"# Forcing that depends on the velocity fields `u`, `v`, and `w`\nw_forcing_func(x, y, z, t, u, v, w) = - (u^2 + v^2 + w^2) / 2\n\nw_forcing = Forcing(w_forcing_func, field_dependencies=(:u, :v, :w))\n\n# Forcing that depends on salinity `S` and a scalar parameter\nS_forcing_func(x, y, z, t, S, μ) = - μ * S\n\nS_forcing = Forcing(S_forcing_func, parameters=0.01, field_dependencies=:S)\n\ngrid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))\nmodel = NonhydrostaticModel(grid=grid, forcing=(w=w_forcing, S=S_forcing), buoyancy=SeawaterBuoyancy(), tracers=(:T, :S))\n\nmodel.forcing.w\n\n# output\nContinuousForcing{Nothing} at (Center, Center, Face)\n├── func: w_forcing_func (generic function with 1 method)\n├── parameters: nothing\n└── field dependencies: (:u, :v, :w)","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"model.forcing.S\n\n# output\nContinuousForcing{Float64} at (Center, Center, Center)\n├── func: S_forcing_func (generic function with 1 method)\n├── parameters: 0.01\n└── field dependencies: (:S,)","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"The field_dependencies arguments follow x, y, z, t in the forcing function in the order they are specified in Forcing. If both field_dependencies and parameters are specified, then the field_dependencies arguments follow x, y, z, t, and parameters follow field_dependencies.","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"Model fields that arise in the arguments of continuous Forcing functions are automatically interpolated to the staggered grid location at which the forcing is applied.","category":"page"},{"location":"model_setup/forcing_functions/#\"Discrete-form\"-forcing-functions","page":"Forcing functions","title":"\"Discrete form\" forcing functions","text":"","category":"section"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"\"Discrete form\" forcing functions are either called with the signature","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"func(i, j, k, grid, clock, model_fields)","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"or the parameterized form","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"func(i, j, k, grid, clock, model_fields, parameters)","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"Discrete form forcing functions can access the entirety of model field data through the argument model_fields. The object model_fields is a NamedTuple whose properties include the velocity fields model_fields.u, model_fields.v, model_fields.w and all fields in model.tracers.","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"Using discrete forcing functions may require understanding the staggered arrangement of velocity fields and tracers in Oceananigans. Here's a slightly non-sensical example in which the vertical derivative of a buoyancy tracer is used as a time-scale for damping the u-velocity field:","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"# A damping term that depends on a \"local average\":\nlocal_average(i, j, k, grid, c) = @inbounds (c[i, j, k] + c[i-1, j, k] + c[i+1, j, k] +\n                                                          c[i, j-1, k] + c[i, j+1, k] +\n                                                          c[i, j, k-1] + c[i, j, k+1]) / 7\n\nb_forcing_func(i, j, k, grid, clock, model_fields) = - local_average(i, j, k, grid, model_fields.b)\n\nb_forcing = Forcing(b_forcing_func, discrete_form=true)\n\n# A term that damps the local velocity field in the presence of stratification\nusing Oceananigans.Operators: ∂zᶠᶜᶠ, ℑxzᶠᵃᶜ\n\nfunction u_forcing_func(i, j, k, grid, clock, model_fields, ε)\n    # The vertical derivative of buoyancy, interpolated to the u-velocity location:\n    N² = ℑxzᶠᵃᶜ(i, j, k, grid, ∂zᶠᶜᶠ, model_fields.b)\n\n    # Set to zero in unstable stratification where N² < 0:\n    N² = max(N², zero(typeof(N²)))\n\n    return @inbounds - ε * sqrt(N²) * model_fields.u[i, j, k]\nend\n\nu_forcing = Forcing(u_forcing_func, discrete_form=true, parameters=1e-3)\n\ngrid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))\nmodel = NonhydrostaticModel(grid=grid, tracers=:b, buoyancy=BuoyancyTracer(), forcing=(u=u_forcing, b=b_forcing))\n\nmodel.forcing.b\n\n# output\nDiscreteForcing{Nothing}\n├── func: b_forcing_func (generic function with 1 method)\n└── parameters: nothing","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"model.forcing.u\n\n# output\nDiscreteForcing{Float64}\n├── func: u_forcing_func (generic function with 1 method)\n└── parameters: 0.001","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"The annotation @inbounds is crucial for performance when accessing array indices of the fields in model_fields.","category":"page"},{"location":"model_setup/forcing_functions/#Relaxation","page":"Forcing functions","title":"Relaxation","text":"","category":"section"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"Relaxation defines a special forcing function that restores a field at a specified rate to a target distribution, within a region uncovered by a masking function. Relaxation is useful for implementing sponge layers, as shown in the second example.","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"The following code constructs a model in which all components of the velocity field are damped to zero everywhere on a time-scale of 1000 seconds, or ~17 minutes:","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"damping = Relaxation(rate = 1/1000)\n\ngrid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)) \nmodel = NonhydrostaticModel(grid=grid, forcing=(u=damping, v=damping, w=damping))\n\nmodel.forcing.w\n\n# output\nContinuousForcing{Nothing} at (Center, Center, Face)\n├── func: Relaxation(rate=0.001, mask=1, target=0)\n├── parameters: nothing\n└── field dependencies: (:w,)","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"The constructor for Relaxation accepts the keyword arguments mask, and target, which specify a mask(x, y, z) function that multiplies the forcing, and a target(x, y, z) distribution for the quantity in question. By default, mask uncovered the whole domain and target restores the field in question to 0","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"We illustrate usage of mask and target by implementing a sponge layer that relaxes velocity fields to zero and restores temperature to a linear gradient in the bottom 1/10th of the domain:","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"grid = RectilinearGrid(size=(1, 1, 1), x=(0, 1), y=(0, 1), z=(-1, 0))\n\n        damping_rate = 1/100 # relax fields on a 100 second time-scale\ntemperature_gradient = 0.001 # ⁰C m⁻¹\n surface_temperature = 20    # ⁰C (at z=0)\n\ntarget_temperature = LinearTarget{:z}(intercept=surface_temperature, gradient=temperature_gradient)\n       bottom_mask = GaussianMask{:z}(center=-grid.Lz, width=grid.Lz/10)\n\nuvw_sponge = Relaxation(rate=damping_rate, mask=bottom_mask)\n  T_sponge = Relaxation(rate=damping_rate, mask=bottom_mask, target=target_temperature)\n\nmodel = NonhydrostaticModel(grid=grid, forcing=(u=uvw_sponge, v=uvw_sponge, w=uvw_sponge, T=T_sponge), buoyancy=SeawaterBuoyancy(), tracers=(:T, :S))\n\nmodel.forcing.u\n\n# output\nContinuousForcing{Nothing} at (Face, Center, Center)\n├── func: Relaxation(rate=0.01, mask=exp(-(z + 1.0)^2 / (2 * 0.1^2)), target=0)\n├── parameters: nothing\n└── field dependencies: (:u,)","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"model.forcing.T\n\n# output\nContinuousForcing{Nothing} at (Center, Center, Center)\n├── func: Relaxation(rate=0.01, mask=exp(-(z + 1.0)^2 / (2 * 0.1^2)), target=20.0 + 0.001 * z)\n├── parameters: nothing\n└── field dependencies: (:T,)","category":"page"},{"location":"model_setup/forcing_functions/#AdvectiveForcing","page":"Forcing functions","title":"AdvectiveForcing","text":"","category":"section"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"AdvectiveForcing defines a forcing function that represents advection by a separate or \"slip\" velocity relative to the prognostic model velocity field. AdvectiveForcing is implemented with native Oceananigans advection operators, which means that tracers advected by the \"flux form\" advection term 𝐮_rm slip c. Caution is advised when 𝐮_rm slip is not divergence free.","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"As an example, consider a model for sediment settling at a constant rate:","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"using Oceananigans\n\nr_sediment = 1e-4 # [m] \"Fine sand\"\nρ_sediment = 1200 # kg m⁻³\nρ_ocean = 1026 # kg m⁻³\nΔb = 9.81 * (ρ_ocean - ρ_sediment) / ρ_ocean # m s⁻²\nν_molecular = 1.05e-6 # m² s⁻¹\nw_sediment = 2/9 * Δb / ν_molecular * r_sediment^2 # m s⁻¹\n\nsinking = AdvectiveForcing(w=w_sediment)\n\n# output\nAdvectiveForcing:\n├── u: ZeroField{Int64}\n├── v: ZeroField{Int64}\n└── w: ConstantField(-0.00352102)","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"The three keyword arguments specify the u, v, and w components of the separate slip velocity field. The default for each u, v, w is ZeroField.","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"Next we consider a dynamically-evolving slip velocity. For this we use ZFaceField with appropriate boundary conditions as our slip velocity:","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"using Oceananigans\nusing Oceananigans.BoundaryConditions: ImpenetrableBoundaryCondition\n\ngrid = RectilinearGrid(size=(32, 32, 32), x=(-10, 10), y=(-10, 10), z=(-4, 4),\n                       topology=(Periodic, Periodic, Bounded))\n\nno_penetration = ImpenetrableBoundaryCondition()\nslip_bcs = FieldBoundaryConditions(grid, (Center, Center, Face),\n                                   top=no_penetration, bottom=no_penetration)\n\nw_slip = ZFaceField(grid, boundary_conditions=slip_bcs)\nsinking = AdvectiveForcing(w=w_slip)\n\n# output\nAdvectiveForcing:\n├── u: ZeroField{Int64}\n├── v: ZeroField{Int64}\n└── w: 32×32×33 Field{Center, Center, Face} on RectilinearGrid on CPU","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"To compute the slip velocity, we must add a Callbackto simulations.callback that computes w_slip ever iteration:","category":"page"},{"location":"model_setup/forcing_functions/","page":"Forcing functions","title":"Forcing functions","text":"using Oceananigans.BoundaryConditions: fill_halo_regions!\n\nmodel = NonhydrostaticModel(; grid, tracers=(:b, :P), forcing=(; P=sinking))\nsimulation = Simulation(model; Δt=1, stop_iteration=100)\n\n# Build abstract operation for slip velocity\nb_particle = - 1e-4 # relative buoyancy depends on reference density and initial buoyancy condition\nb = model.tracers.b\nR = 1e-3 # [m] mean particle radius\nν = 1.05e-6 # [m² s⁻¹] molecular kinematic viscosity of water\nw_slip_op = 2/9 * (b - b_particle) / ν * R^2 # Stokes terminal velocity\n\nfunction compute_slip_velocity!(sim)\n    w_slip .= w_slip_op\n    fill_halo_regions!(w_slip)\n    return nothing\nend\n\nsimulation.callbacks[:slip] = Callback(compute_slip_velocity!)\n\n# output\nCallback of compute_slip_velocity! on IterationInterval(1)","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"EditURL = \"../../../examples/internal_wave.jl\"","category":"page"},{"location":"literated/internal_wave/#Internal-wave-example","page":"Internal wave","title":"Internal wave example","text":"","category":"section"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"In this example, we initialize an internal wave packet in two-dimensions and watch it propagate. This example illustrates how to set up a two-dimensional model, set initial conditions, and how to use BackgroundFields.","category":"page"},{"location":"literated/internal_wave/#Install-dependencies","page":"Internal wave","title":"Install dependencies","text":"","category":"section"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"using Pkg\npkg\"add Oceananigans, CairoMakie\"","category":"page"},{"location":"literated/internal_wave/#The-physical-domain","page":"Internal wave","title":"The physical domain","text":"","category":"section"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"First, we pick a resolution and domain size. We use a two-dimensional domain that's periodic in (x z) and is Flat in y:","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"using Oceananigans\n\ngrid = RectilinearGrid(size=(128, 128), x=(-π, π), z=(-π, π), topology=(Periodic, Flat, Periodic))","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"128×1×128 RectilinearGrid{Float64, Periodic, Flat, Periodic} on CPU with 3×0×3 halo\n├── Periodic x ∈ [-3.14159, 3.14159) regularly spaced with Δx=0.0490874\n├── Flat y                           \n└── Periodic z ∈ [-3.14159, 3.14159) regularly spaced with Δz=0.0490874","category":"page"},{"location":"literated/internal_wave/#Internal-wave-parameters","page":"Internal wave","title":"Internal wave parameters","text":"","category":"section"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"Inertia-gravity waves propagate in fluids that are both (i) rotating, and (ii) density-stratified. We use Oceananigans' Coriolis abstraction to implement a background rotation rate:","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"coriolis = FPlane(f=0.2)","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"FPlane{Float64}(f=0.2)","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"On an FPlane, the domain is idealized as rotating at a constant rate with rotation period 2π/f. coriolis is passed to NonhydrostaticModel below. Our units are arbitrary.","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"We use Oceananigans' background_fields abstraction to define a background buoyancy field B(z) = N^2 * z, where z is the vertical coordinate and N is the \"buoyancy frequency\". This means that the modeled buoyancy field perturbs the basic state B(z).","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"# Background fields are functions of `x, y, z, t`, and optional parameters.\n# Here we have one parameter, the buoyancy frequency\n\nN = 1       # buoyancy frequency [s⁻¹]\nB_func(x, z, t, N) = N^2 * z\nB = BackgroundField(B_func, parameters=N)","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"BackgroundField{typeof(Main.var\"##288\".B_func), Int64}\n├── func: B_func (generic function with 1 method)\n└── parameters: 1","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"We are now ready to instantiate our model. We pass grid, coriolis, and B to the NonhydrostaticModel constructor. We add a small amount of IsotropicDiffusivity to keep the model stable during time-stepping, and specify that we're using a single tracer called b that we identify as buoyancy by setting buoyancy=BuoyancyTracer().","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"model = NonhydrostaticModel(; grid, coriolis,\n                            advection = CenteredFourthOrder(),\n                            timestepper = :RungeKutta3,\n                            closure = ScalarDiffusivity(ν=1e-6, κ=1e-6),\n                            tracers = :b,\n                            buoyancy = BuoyancyTracer(),\n                            background_fields = (; b=B)) # `background_fields` is a `NamedTuple`","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\n├── grid: 128×1×128 RectilinearGrid{Float64, Periodic, Flat, Periodic} on CPU with 3×0×3 halo\n├── timestepper: RungeKutta3TimeStepper\n├── advection scheme: FluxFormAdvection{2, Float64, Centered{2, Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}, Centered{2, Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}}\n├── tracers: b\n├── closure: ScalarDiffusivity{ExplicitTimeDiscretization}(ν=1.0e-6, κ=(b=1.0e-6,))\n├── buoyancy: BuoyancyTracer with ĝ = NegativeZDirection()\n└── coriolis: FPlane{Float64}(f=0.2)","category":"page"},{"location":"literated/internal_wave/#A-Gaussian-wavepacket","page":"Internal wave","title":"A Gaussian wavepacket","text":"","category":"section"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"Next, we set up an initial condition that excites an internal wave that propates through our rotating, stratified fluid. This internal wave has the pressure field","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"p(x z t) = a(x z)  cos(k x + m z - ω t)  ","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"where m is the vertical wavenumber, k is the horizontal wavenumber, ω is the wave frequncy, and a(x z) is a Gaussian envelope. The internal wave dispersion relation links the wave numbers k and m, the Coriolis parameter f, and the buoyancy frequency N:","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"Non-dimensional internal wave parameters","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"m = 16      # vertical wavenumber\nk = 8       # horizontal wavenumber\nf = coriolis.f\n\n# Dispersion relation for inertia-gravity waves\nω² = (N^2 * k^2 + f^2 * m^2) / (k^2 + m^2)\n\nω = sqrt(ω²)","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"We define a Gaussian envelope for the wave packet so that we can observe wave propagation.","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"# Some Gaussian parameters\ngaussian_amplitude = 1e-9\ngaussian_width = grid.Lx / 15\n\n# A Gaussian envelope centered at `(x, z) = (0, 0)`\na(x, z) = gaussian_amplitude * exp( -( x^2 + z^2 ) / 2gaussian_width^2 )","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"An inertia-gravity wave is a linear solution to the Boussinesq equations. In order that our initial condition excites an inertia-gravity wave, we initialize the velocity and buoyancy perturbation fields to be consistent with the pressure field p = a  cos(kx + mx - ωt) at t=0. These relations are sometimes called the \"polarization relations\". At t=0, the polarization relations yield","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"u₀(x, z) = a(x, z) * k * ω   / (ω^2 - f^2) * cos(k * x + m * z)\nv₀(x, z) = a(x, z) * k * f   / (ω^2 - f^2) * sin(k * x + m * z)\nw₀(x, z) = a(x, z) * m * ω   / (ω^2 - N^2) * cos(k * x + m * z)\nb₀(x, z) = a(x, z) * m * N^2 / (ω^2 - N^2) * sin(k * x + m * z)\n\nset!(model, u=u₀, v=v₀, w=w₀, b=b₀)","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"Recall that the buoyancy b is a perturbation, so that the total buoyancy field is N^2 z + b.","category":"page"},{"location":"literated/internal_wave/#A-wave-packet-on-the-loose","page":"Internal wave","title":"A wave packet on the loose","text":"","category":"section"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"We're ready to release the packet. We build a simulation with a constant time-step,","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"simulation = Simulation(model, Δt = 0.1 * 2π/ω, stop_iteration = 20)","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"Simulation of NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\n├── Next time step: 1.304 seconds\n├── Elapsed wall time: 0 seconds\n├── Wall time per iteration: NaN days\n├── Stop time: Inf days\n├── Stop iteration : 20.0\n├── Wall time limit: Inf\n├── Callbacks: OrderedDict with 4 entries:\n│   ├── stop_time_exceeded => Callback of stop_time_exceeded on IterationInterval(1)\n│   ├── stop_iteration_exceeded => Callback of stop_iteration_exceeded on IterationInterval(1)\n│   ├── wall_time_limit_exceeded => Callback of wall_time_limit_exceeded on IterationInterval(1)\n│   └── nan_checker => Callback of NaNChecker for u on IterationInterval(100)\n├── Output writers: OrderedDict with no entries\n└── Diagnostics: OrderedDict with no entries","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"and add an output writer that saves the vertical velocity field every two iterations:","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"filename = \"internal_wave.jld2\"\nsimulation.output_writers[:velocities] = JLD2OutputWriter(model, model.velocities; filename,\n                                                          schedule = IterationInterval(1),\n                                                          overwrite_existing = true)","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"JLD2OutputWriter scheduled on IterationInterval(1):\n├── filepath: ./internal_wave.jld2\n├── 3 outputs: (u, v, w)\n├── array type: Array{Float64}\n├── including: [:grid, :coriolis, :buoyancy, :closure]\n├── file_splitting: NoFileSplitting\n└── file size: 33.9 KiB","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"With initial conditions set and an output writer at the ready, we run the simulation","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"run!(simulation)","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"[ Info: Initializing simulation...\n[ Info:     ... simulation initialization complete (4.494 seconds)\n[ Info: Executing initial time step...\n[ Info:     ... initial time step complete (6.025 seconds).\n[ Info: Simulation is stopping after running for 10.838 seconds.\n[ Info: Model iteration 20 equals or exceeds stop iteration 20.\n","category":"page"},{"location":"literated/internal_wave/#Animating-a-propagating-packet","page":"Internal wave","title":"Animating a propagating packet","text":"","category":"section"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"To animate a the propagating wavepacket we just simulated, we load CairoMakie and make a Figure and an Axis for the animation,","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"using CairoMakie\nset_theme!(Theme(fontsize = 24))\n\nfig = Figure(size = (600, 600))\n\nax = Axis(fig[2, 1]; xlabel = \"x\", ylabel = \"z\",\n          limits = ((-π, π), (-π, π)), aspect = AxisAspect(1))\n","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"Next, we load w data with FieldTimeSeries of w and make contour plots of vertical velocity. We use Makie's Observable to animate the data. To dive into how Observables work, refer to Makie.jl's Documentation.","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"n = Observable(1)\n\nw_timeseries = FieldTimeSeries(filename, \"w\")\nw = @lift w_timeseries[$n]\nw_lim = 1e-8\n\ncontourf!(ax, w;\n          levels = range(-w_lim, stop=w_lim, length=10),\n          colormap = :balance,\n          extendlow = :auto,\n          extendhigh = :auto)\n\ntitle = @lift \"ωt = \" * string(round(w_timeseries.times[$n] * ω, digits=2))\nfig[1, 1] = Label(fig, title, fontsize=24, tellwidth=false)","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"Label()","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"And, finally, we record a movie.","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"using Printf\n\nframes = 1:length(w_timeseries.times)\n\n@info \"Animating a propagating internal wave...\"\n\nrecord(fig, \"internal_wave.mp4\", frames, framerate=8) do i\n    n[] = i\nend","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"[ Info: Animating a propagating internal wave...\n","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"(Image: )","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"","category":"page"},{"location":"literated/internal_wave/","page":"Internal wave","title":"Internal wave","text":"This page was generated using Literate.jl.","category":"page"},{"location":"field_time_series/#FieldTimeSeries","page":"FieldTimeSeries","title":"FieldTimeSeries","text":"","category":"section"},{"location":"appendix/function_index/#Index","page":"Function index","title":"Index","text":"","category":"section"},{"location":"appendix/function_index/","page":"Function index","title":"Function index","text":"","category":"page"},{"location":"physics/boussinesq/#boussinesq_approximation","page":"Boussinesq approximation","title":"The Boussinesq approximation","text":"","category":"section"},{"location":"physics/boussinesq/","page":"Boussinesq approximation","title":"Boussinesq approximation","text":"Oceananigans.jl often employs the Boussinesq approximation[1]. In the Boussinesq approximation the fluid density rho is, in general, decomposed into three components:","category":"page"},{"location":"physics/boussinesq/","page":"Boussinesq approximation","title":"Boussinesq approximation","text":"    rho(boldsymbolx t) = rho_0 + rho_*(z) + rho(boldsymbolx t)  ","category":"page"},{"location":"physics/boussinesq/","page":"Boussinesq approximation","title":"Boussinesq approximation","text":"where rho_0 is a constant 'reference' density, rho_*(z) is a background density profile which, when non-zero, is typically associated with the hydrostatic compression of seawater in the deep ocean, and rho(boldsymbolx t) is the dynamic component of density corresponding to inhomogeneous distributions of a buoyant tracer such as temperature or salinity.","category":"page"},{"location":"physics/boussinesq/","page":"Boussinesq approximation","title":"Boussinesq approximation","text":"The fluid buoyancy, associated with the buoyant acceleration of fluid, is defined in terms of rho as","category":"page"},{"location":"physics/boussinesq/","page":"Boussinesq approximation","title":"Boussinesq approximation","text":"    b = - fracg rhorho_0  ","category":"page"},{"location":"physics/boussinesq/","page":"Boussinesq approximation","title":"Boussinesq approximation","text":"where g is gravitational acceleration.","category":"page"},{"location":"physics/boussinesq/","page":"Boussinesq approximation","title":"Boussinesq approximation","text":"The Boussinesq approximation is valid when rho_* + rho ll rho_0, which implies the fluid is approximately incompressible, and thus does not support acoustic waves. In this case,  the mass conservation equation reduces to the continuity equation","category":"page"},{"location":"physics/boussinesq/","page":"Boussinesq approximation","title":"Boussinesq approximation","text":"    beginequation\n    boldsymbolnabla boldsymbolcdot boldsymbolv = partial_x u + partial_y v + partial_z w = 0  \n    labeleqcontinuity\n    endequation","category":"page"},{"location":"physics/boussinesq/","page":"Boussinesq approximation","title":"Boussinesq approximation","text":"Similarly, in the the momentum equations we can divide through with rho_0 and use that rho_* + rho ll rho_0 to get:","category":"page"},{"location":"physics/boussinesq/","page":"Boussinesq approximation","title":"Boussinesq approximation","text":"    beginequation\n    partial_t boldsymbolv + boldsymbolv boldsymbolcdot boldsymbolnabla boldsymbolv + dotsb = - frac1rho_0 boldsymbolnabla p - g fracrhorho_0 hatboldsymbolz + dotsb  \n    labeleqmomentum\n    endequation","category":"page"},{"location":"physics/boussinesq/","page":"Boussinesq approximation","title":"Boussinesq approximation","text":"We refer to p  rho_0 as the \"kinematic pressure\" with dimensions of velocity squared. Hereafter, we abuse notation a bit and denote the kinematic pressure simply as p.","category":"page"},{"location":"physics/boussinesq/","page":"Boussinesq approximation","title":"Boussinesq approximation","text":"info: Convention on dynamic versus kinematic pressure\nIn Oceananigans, the pressure p refers to \"kinematic pressure\" (with dimensions velocity squared), i.e., the dynamic pressure scaled with the reference fluid density rho_0.","category":"page"},{"location":"physics/boussinesq/","page":"Boussinesq approximation","title":"Boussinesq approximation","text":"[1]: Named after Boussinesq (1903) although used earlier by Oberbeck (1879), the Boussinesq   approximation neglects density differences in the momentum equation except when associated   with the gravitational term. It is an accurate approximation for many flows, and especially   so for oceanic flows where density differences are very small. See Vallis (2017, section 2.4)   for an oceanographic introduction to the Boussinesq equations and Vallis (2017, Section 2.A)   for an asymptotic derivation. See Kundu (2015, Section 4.9) for an engineering   introduction.","category":"page"},{"location":"numerical_implementation/finite_volume/#finite_volume","page":"Finite volume method","title":"Finite volume method on a staggered grid","text":"","category":"section"},{"location":"numerical_implementation/finite_volume/","page":"Finite volume method","title":"Finite volume method","text":"The Oceananigans.jl staggered grid is defined by a rectilinear array of cuboids of horizontal dimensions  Delta x_i j k Delta y_i j k and vertical dimension  Delta z_i j k, where (i j k) index the location of each cell in the staggered grid. Note that the indices (i j k) increase with increasing coordinate (x y z).","category":"page"},{"location":"numerical_implementation/finite_volume/","page":"Finite volume method","title":"Finite volume method","text":"(Image: Schematic of staggered grid) A schematic of Oceananigans.jl finite volumes for a two-dimensional staggered grid in (x z). Tracers c and pressure p are defined at the center of the control volume. The u control volumes are  centered on the left and right edges of the pressure control volume while the w control volumes are centered  on the top and bottom edges of the pressure control volumes. The indexing convention places the i^rmth  u-node on cell x-faces to the left of the i tracer point at cell centers.","category":"page"},{"location":"numerical_implementation/finite_volume/","page":"Finite volume method","title":"Finite volume method","text":"Dropping explicit indexing, the areas of cell faces are given by","category":"page"},{"location":"numerical_implementation/finite_volume/","page":"Finite volume method","title":"Finite volume method","text":"    A_x = Delta y Delta z quad A_y = Delta x Delta z quad A_z = Delta x Delta y  ","category":"page"},{"location":"numerical_implementation/finite_volume/","page":"Finite volume method","title":"Finite volume method","text":"so that each cell encloses a volume V = Delta x Delta y Delta z.","category":"page"},{"location":"numerical_implementation/finite_volume/","page":"Finite volume method","title":"Finite volume method","text":"A finite volume method discretizes a continuous quantity c by considering its average over a finite volume:","category":"page"},{"location":"numerical_implementation/finite_volume/","page":"Finite volume method","title":"Finite volume method","text":"    c_i j k equiv frac1V_i j k int c(boldsymbolx)  mathrmd V_i j k  ","category":"page"},{"location":"numerical_implementation/finite_volume/","page":"Finite volume method","title":"Finite volume method","text":"The finite volumes that discretize each of u, v, and w are located on a grid which is \"staggered\"  with respect to the grid that defines tracer finite volumes.  The nodes, or central points of the velocity finite volumes are co-located with the faces of the tracer  finite volume. In particular, the u-nodes are located in the center of the \"x-face\" (east of the tracer point),  v-nodes are located on y-faces south of the tracer point, and w-nodes are located on  z-faces downwards from the tracer point.","category":"page"},{"location":"grids/#grids_tutorial","page":"Grids","title":"Grids","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"DocTestSetup = quote\n    using Oceananigans\n    using CairoMakie\n    CairoMakie.activate!(type = \"svg\")\n    set_theme!(Theme(fontsize=24))\nend","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"Oceananigans simulates the dynamics of ocean-flavored fluids by solving equations that conserve momentum, mass, and energy on a grid of finite volumes or \"cells\". The first decision we make when setting up a simulation is: on what grid are we going to run our simulation? The \"grid\" captures the","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"The geometry of the physical domain;\nThe way that domain is divided into a mesh of finite volumes;\nThe machine architecture (CPU, GPU, lots of CPUs or lots of GPUs); and\nThe precision of floating point numbers (double precision or single precision).","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"We start by making a simple grid that divides a three-dimensional rectangular domain – \"a box\" – into evenly-spaced cells,","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"using Oceananigans\n\ngrid = RectilinearGrid(topology = (Periodic, Periodic, Bounded),\n                       size = (16, 8, 4),\n                       x = (0, 64),\n                       y = (0, 32),\n                       z = (0, 8))\n\n# output\n16×8×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo\n├── Periodic x ∈ [0.0, 64.0) regularly spaced with Δx=4.0\n├── Periodic y ∈ [0.0, 32.0) regularly spaced with Δy=4.0\n└── Bounded  z ∈ [0.0, 8.0]  regularly spaced with Δz=2.0","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"This simple grid","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"Has a domain that's \"periodic\" in x y, but bounded in z.\nHas 16 cells in x, 8 cells in y, and 4 cells in z. That means there are 16 times 8 times 4 = 512 cells in all.\nHas an x dimension that spans from x=0, to x=64. And y spans y=0 to y=32, and z spans z=0 to z=8.\nHas cells that are all the same size, dividing the box in 512 that each has dimension 4 times 4 times 2. Note that length units are whatever is used to construct the grid, so it's up to the user to make sure that all inputs use consistent units.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"In building our first grid, we did not specify whether it should be constructed on the CPUor [GPU](@ref). As a result, the grid was constructed by default on the CPU. Next we build a grid on the _GPU_ that's two-dimensional inx, zand has variably-spaced cell interfaces in thez`-direction,","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"architecture = GPU()\nz_faces = [0, 1, 3, 6, 10]\n\ngrid = RectilinearGrid(architecture,\n                       topology = (Periodic, Flat, Bounded),\n                       size = (10, 4),\n                       x = (0, 20),\n                       z = z_faces)\n\n# output\n10×1×4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on GPU with 3×0×3 halo\n├── Periodic x ∈ [0.0, 20.0) regularly spaced with Δx=2.0\n├── Flat y\n└── Bounded  z ∈ [0.0, 10.0] variably spaced with min(Δz)=1.0, max(Δz)=4.0","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"note: GPU architecture requires a CUDA-enabled device\nTo run the above example and create a grid on the GPU, an Nvidia GPU has to be available and CUDA.jl must be working). For more information see the CUDA.jl documentation.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"The y-dimension is \"missing\" because it's marked Flat in topology = (Periodic, Flat, Bounded). So nothing varies in y: y-derivatives are 0. Also, the keyword argument (or \"kwarg\" for short) that specifies the y-domains may be omitted, and size has only two elements rather than 3 as in the first example. In the stretched cell interfaces specified by z_interfaces, the number of vertical cell interfaces is Nz + 1 = length(z_interfaces) = 5, where Nz = 4 is the number of cells in the vertical.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"A bit later in this tutorial, we'll give examples that illustrate how to build a grid thats Distributed across multiple CPUs and GPUs.","category":"page"},{"location":"grids/#Grid-types:-squares,-shells,-and-mountains","page":"Grids","title":"Grid types: squares, shells, and mountains","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"The shape of the physical domain determines what grid type should be used:","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"RectilinearGrid can be fashioned into lines, rectangles and boxes.\nLatitudeLongitudeGrid represents sectors of thin spherical shells, with cells bounded by lines of constant latitude and longitude.\nOrthogonalSphericalShellGrid represents sectors of thin spherical shells divided with mesh lines that intersect at right angles (thus, orthogonal) but are otherwise arbitrary.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"note: OrthogonalSphericalShellGrids.jl\nSee the auxiliary package OrthogonalSphericalShellGrids.jl for recipes that implement some useful OrthogonalSphericalShellGrid, including the \"tripolar\" grid.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"For example, to make a LatitudeLongitudeGrid that wraps around the sphere, extends for 60 degrees latitude on either side of the equator, and also has 5 vertical levels down to 1000 meters, we write","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"architecture = CPU()\n\ngrid = LatitudeLongitudeGrid(architecture,\n                             size = (180, 10, 5),\n                             longitude = (-180, 180),\n                             latitude = (-60, 60),\n                             z = (-1000, 0))\n\n# output\n180×10×5 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics\n├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=2.0\n├── latitude:  Bounded  φ ∈ [-60.0, 60.0]   regularly spaced with Δφ=12.0\n└── z:         Bounded  z ∈ [-1000.0, 0.0]  regularly spaced with Δz=200.0","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"The main difference between the syntax for LatitudeLongitudeGrid versus that for the RectilinearGrid are the names of the horizontal coordinates: LatitudeLongitudeGrid has longitude and latitude where RectilinearGrid has x and y.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"note: Extrinsic and intrinsic coordinate systems\nEvery grid is associated with an \"extrinsic\" coordinate system: RectilinearGrid uses a Cartesian coordinate system, while LatitudeLongitudeGrid and OrthogonalSphericalShellGrid use the geographic coordinates (λ, φ, z), where λ is longitude, φ is latitude, and z is height. Additionally, OrthogonalSphericalShellGrid has an \"intrinsic\" coordinate system associated with the orientation of its finite volumes (which, in general, are not aligned with geographic coordinates). To type λ or φ at the REPL, write either \\lambda (for λ) or \\varphi (for φ) and then press <TAB>.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"If topology is not provided for LatitudeLongitudeGrid, then we try to infer it: if the longitude spans 360 degrees, the default x-topology is Periodic; if longitude spans less than 360 degrees x-topology is Bounded. For example,","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"grid = LatitudeLongitudeGrid(size = (60, 10, 5),\n                             longitude = (0, 60),\n                             latitude = (-60, 60),\n                             z = (-1000, 0))\n\n# output\n60×10×5 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics\n├── longitude: Bounded  λ ∈ [0.0, 60.0]    regularly spaced with Δλ=1.0\n├── latitude:  Bounded  φ ∈ [-60.0, 60.0]  regularly spaced with Δφ=12.0\n└── z:         Bounded  z ∈ [-1000.0, 0.0] regularly spaced with Δz=200.0","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"is Bounded by default, because longitude = (0, 60).","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"note: LatitudeLongitudeGrid topologies\nIt's still possible to use topology = (Periodic, Bounded, Bounded) if longitude doesn't have 360 degrees. But neither latitude nor z may be Periodic with LatitudeLongitudeGrid.","category":"page"},{"location":"grids/#Bathymetry,-topography,-and-other-irregularities","page":"Grids","title":"Bathymetry, topography, and other irregularities","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"Irregular or \"complex\" domains are represented with ImmersedBoundaryGrid, which combines one of the above underlying grids with a type of immersed boundary. The immersed boundaries we support currently are","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"GridFittedBottom, which fits a one- or two-dimensional bottom height to the underlying grid, so the active part of the domain is above the bottom height.\nPartialCellBottom, which is similar to GridFittedBottom, except that the height of the bottommost cell is changed to conform to bottom height, limited to prevent the bottom cells from becoming too thin.\nGridFittedBoundary, which fits a three-dimensional mask to the grid.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"To build an ImmersedBoundaryGrid, we start by building one of the three underlying grids, and then embedding a boundary into that underlying grid.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"using Oceananigans.Units\n\ngrid = RectilinearGrid(topology = (Bounded, Bounded, Bounded),\n                       size = (20, 20, 20),\n                       x = (-5kilometers, 5kilometers),\n                       y = (-5kilometers, 5kilometers),\n                       z = (0, 1kilometer))\n\n# Height and width\nH = 100meters\nW = 1kilometer\n\nmountain(x, y) = H * exp(-(x^2 + y^2) / 2W^2)\nmountain_grid = ImmersedBoundaryGrid(grid, GridFittedBottom(mountain))\n\n# output\n20×20×20 ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3×3×3 halo:\n├── immersed_boundary: GridFittedBottom(mean(z)=6.28318, min(z)=1.58939e-8, max(z)=93.9413)\n├── underlying_grid: 20×20×20 RectilinearGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3×3×3 halo\n├── Bounded  x ∈ [-5000.0, 5000.0] regularly spaced with Δx=500.0\n├── Bounded  y ∈ [-5000.0, 5000.0] regularly spaced with Δy=500.0\n└── Bounded  z ∈ [0.0, 1000.0]     regularly spaced with Δz=50.0","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"Yep, that's a Gaussian mountain:","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"using Oceananigans\nusing Oceananigans.Units\n\nusing CairoMakie\nCairoMakie.activate!(type = \"svg\")\nset_theme!(Theme(fontsize=24))\n\ngrid = RectilinearGrid(topology = (Bounded, Bounded, Bounded),\n                       size = (20, 20, 20),\n                       x = (-5kilometers, 5kilometers),\n                       y = (-5kilometers, 5kilometers),\n                       z = (0, 1kilometer))\n\nH = 100meters\nW = 1kilometer\n\nmountain(x, y) = H * exp(-(x^2 + y^2) / 2W^2)\nmountain_grid = ImmersedBoundaryGrid(grid, GridFittedBottom(mountain))","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"using CairoMakie\n\nh = mountain_grid.immersed_boundary.bottom_height\n\nfig = Figure(size=(600, 600))\nax = Axis(fig[2, 1], xlabel=\"x (m)\", ylabel=\"y (m)\", aspect=1)\nhm = heatmap!(ax, h)\nColorbar(fig[1, 1], hm, vertical=false, label=\"Bottom height (m)\")\n\ncurrent_figure()","category":"page"},{"location":"grids/#Once-more-with-feeling","page":"Grids","title":"Once more with feeling","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"In summary, making a grid requires ","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"The machine architecture, or whether data is stored on the CPU, GPU, or distributed across multiple devices or nodes.\nInformation about the domain geometry. Domains can take a variety of shapes, including\nlines (one-dimensional),\nrectangles (two-dimensional),\nboxes (three-dimensional),\nsectors of a thin spherical shells (two- or three-dimensional).\nIrregular domains – such as domains that include bathymetry or topography – are represented by using a masking technique to \"immerse\" an irregular boundary within an \"underlying\" regular grid. Part of specifying the shape of the domain also requires specifying the nature of each dimension, which may be\nPeriodic, which means that the dimension circles back onto itself: information leaving the left side of the domain re-enters on the right.\nBounded, which means that the two sides of the dimension are either impenetrable (solid walls), or \"open\", representing a specified external state.\nFlat, which means nothing can vary in that dimension, reducing the overall dimensionality of the grid.\nDefining the number of cells that divide each dimension. The number of cells, with or without explicit specification of the cell interfaces, determines the spatial resolution of the grid.\nThe representation of floating point numbers, which can be single-precision (Float32) or double precision (Float64).","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"Let's dive into each of these options in more detail.","category":"page"},{"location":"grids/#Specifying-the-machine-architecture","page":"Grids","title":"Specifying the machine architecture","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"The positional argument CPU() or GPU(), specifies the \"architecture\" of the simulation. By using architecture = GPU(), any fields constructed on grid store their data on an Nvidia GPU, if one is available. By default, the grid will be constructed on the CPU if this argument is omitted. So, for example,","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"grid     = RectilinearGrid(size=3, z=(0, 1), topology=(Flat, Flat, Bounded))\ncpu_grid = RectilinearGrid(CPU(), size=3, z=(0, 1), topology=(Flat, Flat, Bounded))\n\ngrid == cpu_grid\n\n# output\ntrue","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"To use more than one CPU, we use the Distributed architecture,","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"child_architecture = CPU()\narchitecture = Distributed(child_architecture)\n\n# output\n[ Info: MPI has not been initialized, so we are calling MPI.Init().\nDistributed{CPU} across 1 rank:\n├── local_rank: 0 of 0-0\n└── local_index: [1, 1, 1]","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"which allows us to distributed computations across either CPUs or GPUs. In this case, we didn't launch julia on multiple nodes using MPI, so we're only \"distributed\" across 1 node. <!– For more, see Distributed grids. –> More details on Distributed grids in a separate section.","category":"page"},{"location":"grids/#Specifying-the-topology-for-each-dimension","page":"Grids","title":"Specifying the topology for each dimension","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"The keyword argument topology determines if the grid is one-, two-, or three-dimensional (the current case), and additionally specifies the nature of each dimension. topology is always a Tuple with three elements (a 3-Tuple). For RectilinearGrid, the three elements correspond to (x y z) and indicate whether the respective direction is Periodic, Bounded, or Flat. A few more examples are,","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"topology = (Periodic, Periodic, Periodic) # triply periodic\ntopology = (Periodic, Periodic, Bounded)  # periodic in x, y, bounded in z\ntopology = (Periodic, Bounded, Bounded)   # periodic in x, but bounded in y, z (a \"channel\")\ntopology = (Bounded, Bounded, Bounded)    # bounded in x, y, z (a closed box)\ntopology = (Periodic, Periodic, Flat)     # two-dimensional, doubly-periodic in x, y (a torus)\ntopology = (Periodic, Flat, Flat)         # one-dimensional, periodic in x (a line)\ntopology = (Flat, Flat, Bounded)          # one-dimensional and bounded in z (a single column)","category":"page"},{"location":"grids/#Specifying-the-size-of-the-grid","page":"Grids","title":"Specifying the size of the grid","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"The size is a Tuple that specifes the number of grid points in each direction. The number of tuple elements corresponds to the number of dimensions that are not Flat.","category":"page"},{"location":"grids/#The-halo-size","page":"Grids","title":"The halo size","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"An additional keyword argument halo allows us to set the number of \"halo cells\" that surround the core \"interior\" grid. The default is 3 for each non-flat coordinate. But we can change the halo size, for example,","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"big_halo_grid = RectilinearGrid(topology = (Periodic, Periodic, Flat),\n                                size = (32, 16),\n                                halo = (7, 7),\n                                x = (0, 2π),\n                                y = (0, π))\n\n# output\n32×16×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 7×7×0 halo\n├── Periodic x ∈ [-6.90805e-17, 6.28319) regularly spaced with Δx=0.19635\n├── Periodic y ∈ [-1.07194e-16, 3.14159) regularly spaced with Δy=0.19635\n└── Flat z","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"The halo size has to be set for certain advection schemes that require more halo points than the default 3 in every direction. Note that both size and halo are 2-Tuples, rather than the 3-Tuple that would be required for a three-dimensional grid, or the single number that would be used for a one-dimensional grid.","category":"page"},{"location":"grids/#The-dimensions:-x,-y,-z-for-RectilinearGrid,-or-latitude,-longitude,-z-for-LatitudeLongitudeGrid","page":"Grids","title":"The dimensions: x, y, z for RectilinearGrid, or latitude, longitude, z for LatitudeLongitudeGrid","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"These keyword arguments specify the extent and location of the finite volume cells that divide up the three dimensions of the grid. For RectilinearGrid, the dimensions are called x, y, and z, whereas for LatitudeLongitudeGrid the dimensions are called latitude, longitude, and z. The type of each keyword argument determines how the dimension is divided up:","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"Tuples that specify only the end points indicate that the dimension should be divided into equally-spaced cells. For example, x = (0, 64) with size = (16, 8, 4) means that the x-dimension is divided into 16 cells, where the first or leftmost cell interface is located at x = 0 and the last or rightmost cell interface is located at x = 64. The width of each cell is Δx=4.0.\nVectors and functions alternatively give the location of each cell interface, and thereby may be used to build grids that are divided into cells of varying width.","category":"page"},{"location":"grids/#A-complicated-example:-three-dimensional-RectilinearGrid-with-variable-spacing-via-functions","page":"Grids","title":"A complicated example: three-dimensional RectilinearGrid with variable spacing via functions","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"Next we build a grid that is both Bounded and stretched in both the y and z directions. The purpose of the stretching is to increase grid resolution near the boundaries. We'll do this by using functions to specify the keyword arguments y and z.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"Nx = Ny = 64\nNz = 32\n\nLx = Ly = 1e4\nLz = 1e3\n\n# Note that j varies from 1 to Ny\nchebychev_spaced_y_faces(j) = Ly * (1 - cos(π * (j - 1) / Ny)) / 2\n\n# Note that k varies from 1 to Nz\nchebychev_spaced_z_faces(k) = - Lz * (1 + cos(π * (k - 1) / Nz)) / 2\n\ngrid = RectilinearGrid(size = (Nx, Ny, Nz),\n                       topology = (Periodic, Bounded, Bounded),\n                       x = (0, Lx),\n                       y = chebychev_spaced_y_faces,\n                       z = chebychev_spaced_z_faces)\n\n# output\n64×64×32 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3×3×3 halo\n├── Periodic x ∈ [0.0, 10000.0)  regularly spaced with Δx=156.25\n├── Bounded  y ∈ [0.0, 10000.0]  variably spaced with min(Δy)=6.02272, max(Δy)=245.338\n└── Bounded  z ∈ [-1000.0, -0.0] variably spaced with min(Δz)=2.40764, max(Δz)=49.0086","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"using Oceananigans\nusing CairoMakie\nCairoMakie.activate!(type = \"svg\")\nset_theme!(Theme(fontsize=24))\n\nNx, Ny, Nz = 64, 64, 32\nLx, Ly, Lz = 1e4, 1e4, 1e3\n\nchebychev_spaced_y_faces(j) = Ly * (1 - cos(π * (j - 1) / Ny)) / 2\nchebychev_spaced_z_faces(k) = - Lz * (1 + cos(π * (k - 1) / Nz)) / 2\n\ngrid = RectilinearGrid(size = (Nx, Ny, Nz),\n                       topology = (Periodic, Bounded, Bounded),\n                       x = (0, Lx),\n                       y = chebychev_spaced_y_faces,\n                       z = chebychev_spaced_z_faces)","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"We can easily visualize the spacings of y and z directions. We can use, e.g., ynodes and yspacings to extract the positions and spacings of the nodes from the grid.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"yc = ynodes(grid, Center())\nzc = znodes(grid, Center())\n\nyf = ynodes(grid, Face())\nzf = znodes(grid, Face())\n\nΔy = yspacings(grid, Center())\nΔz = zspacings(grid, Center())\n\nusing CairoMakie\n\nfig = Figure(size=(1200, 1200))\n\naxy = Axis(fig[1, 1], title=\"y-grid\")\nlines!(axy, [0, Ly], [0, 0], color=:gray)\nscatter!(axy, yf, 0 * yf, marker=:vline, color=:gray, markersize=20)\nscatter!(axy, yc, 0 * yc)\nhidedecorations!(axy)\nhidespines!(axy)\n\naxΔy = Axis(fig[2, 1]; xlabel = \"y (m)\", ylabel = \"y-spacing (m)\")\nscatter!(axΔy, yc, Δy)\nhidespines!(axΔy, :t, :r) \n\naxz = Axis(fig[3, 1], title=\"z-grid\")\nlines!(axz, [-Lz, 0], [0, 0], color=:gray)\nscatter!(axz, zf, 0 * zf, marker=:vline, color=:gray, markersize=20)\nscatter!(axz, zc, 0 * zc)\nhidedecorations!(axz)\nhidespines!(axz)\n\naxΔz = Axis(fig[4, 1]; xlabel = \"z (m)\", ylabel = \"z-spacing (m)\")\nscatter!(axΔz, zc, Δz)\nhidespines!(axΔz, :t, :r)\n\nrowsize!(fig.layout, 1, Relative(0.1))\nrowsize!(fig.layout, 3, Relative(0.1))\n\ncurrent_figure()","category":"page"},{"location":"grids/#Inspecting-LatitudeLongitudeGrid-cell-spacings","page":"Grids","title":"Inspecting LatitudeLongitudeGrid cell spacings","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"using Oceananigans","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"grid = LatitudeLongitudeGrid(size = (1, 44),\n                             longitude = (0, 1),   \n                             latitude = (0, 88),\n                             topology = (Bounded, Bounded, Flat))\n\nφ = φnodes(grid, Center())\nΔx = xspacings(grid, Center(), Center())\n\nusing CairoMakie\n\nfig = Figure(size=(600, 400))\nax = Axis(fig[1, 1], xlabel=\"Zonal spacing on 2 degree grid (km)\", ylabel=\"Latitude (degrees)\")\nscatter!(ax, Δx ./ 1e3, φ)\n\ncurrent_figure()","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"(Image: )","category":"page"},{"location":"grids/#LatitudeLongitudeGrid-with-variable-spacing","page":"Grids","title":"LatitudeLongitudeGrid with variable spacing","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"The syntax for building a grid with variably-spaced cells is the same as for RectilinearGrid. In our next example, we use a function to build a Mercator grid with a spacing of 2 degrees at the equator,","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"# Mercator scale factor\nscale_factor(φ) = 1 / cosd(φ)\n\n# Compute cell interfaces with Mercator spacing\nm = 2 # spacing at the equator in degrees\nfunction latitude_faces(j)\n    if j == 1 # equator\n        return 0\n    else # crudely estimate the location of the jth face \n        φ₋ = latitude_faces(j-1)\n        φ′ = φ₋ + m * scale_factor(φ₋) / 2\n        return φ₋ + m * scale_factor(φ′)\n    end\nend\n\nLx = 360\nNx = Int(Lx / m)\nNy = findfirst(latitude_faces.(1:Nx) .> 90) - 2\n\ngrid = LatitudeLongitudeGrid(size = (Nx, Ny),\n                             longitude = (0, Lx),\n                             latitude = latitude_faces,\n                             topology = (Bounded, Bounded, Flat))\n\n# output\n180×28×1 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Flat} on CPU with 3×3×0 halo and with precomputed metrics\n├── longitude: Bounded  λ ∈ [0.0, 360.0]   regularly spaced with Δλ=2.0\n├── latitude:  Bounded  φ ∈ [0.0, 77.2679] variably spaced with min(Δφ)=2.0003, max(Δφ)=6.95319\n└── z:         Flat z                      ","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"We've also illustrated the construction of a grid that is Flat in the vertical direction. Now let's plot the metrics for this grid,","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"# Mercator scale factor\nscale_factor(φ) = 1 / cosd(φ)\n\n# Compute cell interfaces with Mercator spacing\nm = 2 # spacing at the equator in degrees\nfunction latitude_faces(j)\n    if j == 1 # equator\n        return 0\n    else # crudely estimate the location of the jth face \n        φ₋ = latitude_faces(j-1)\n        φ′ = φ₋ + m * scale_factor(φ₋) / 2\n        return φ₋ + m * scale_factor(φ′)\n    end\nend\n\nLx = 360\nNx = Int(Lx / m)\n\n# Deduce number of cells south of 90ᵒN\nλf = latitude_faces.(1:Nx)\nNy = findfirst(λf .> 90) - 2\n\ngrid = LatitudeLongitudeGrid(size = (Nx, Ny),\n                             longitude = (0, Lx),\n                             latitude = latitude_faces,\n                             topology = (Bounded, Bounded, Flat))","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"φ = φnodes(grid, Center())\nΔx = xspacings(grid, Center(), Center(), with_halos=true)[1:Ny]\nΔy = yspacings(grid, Center())[1:Ny]\n\nusing CairoMakie\n\nfig = Figure(size=(800, 400), title=\"Spacings on a Mercator grid\")\naxx = Axis(fig[1, 1], xlabel=\"Zonal spacing (km)\", ylabel=\"Latitude (degrees)\")\nscatter!(axx, Δx ./ 1e3, φ)\n\naxy = Axis(fig[1, 2], xlabel=\"Meridional spacing (km)\")\nscatter!(axy, Δy ./ 1e3, φ)\n\nhidespines!(axx, :t, :r)\nhidespines!(axy, :t, :l, :r)\nhideydecorations!(axy, grid=false)\n\ncurrent_figure()","category":"page"},{"location":"grids/#Single-precision-RectilinearGrid","page":"Grids","title":"Single-precision RectilinearGrid","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"To build a grid whose fields are represented with single-precision floating point values, we specify the float_type argument along with the (optional) architecture argument,","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"architecture = CPU()\nfloat_type = Float32\n\ngrid = RectilinearGrid(architecture, float_type,\n                       topology = (Periodic, Periodic, Bounded),\n                       size = (16, 8, 4),\n                       x = (0, 64),\n                       y = (0, 32),\n                       z = (0, 8))\n\n# output\n16×8×4 RectilinearGrid{Float32, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo\n├── Periodic x ∈ [0.0, 64.0) regularly spaced with Δx=4.0\n├── Periodic y ∈ [0.0, 32.0) regularly spaced with Δy=4.0\n└── Bounded  z ∈ [0.0, 8.0]  regularly spaced with Δz=2.0","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"warn: Using single precision\nSingle precision should be used with care. Users interested in performing single-precision simulations should get in touch via Discussions, and should subject their work to extensive testing and validation.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"For more examples see RectilinearGrid and LatitudeLongitudeGrid.","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"EditURL = \"../../../examples/langmuir_turbulence.jl\"","category":"page"},{"location":"literated/langmuir_turbulence/#Langmuir-turbulence-example","page":"Langmuir turbulence","title":"Langmuir turbulence example","text":"","category":"section"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"This example implements a Langmuir turbulence simulation reported in section 4 of","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"Wagner et al., \"Near-inertial waves and turbulence driven by the growth of swell\", Journal of Physical Oceanography (2021)","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"This example demonstrates","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"How to run large eddy simulations with surface wave effects via the Craik-Leibovich approximation.\nHow to specify time- and horizontally-averaged output.","category":"page"},{"location":"literated/langmuir_turbulence/#Install-dependencies","page":"Langmuir turbulence","title":"Install dependencies","text":"","category":"section"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"using Pkg\npkg\"add Oceananigans, CairoMakie\"","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"using Oceananigans\nusing Oceananigans.Units: minute, minutes, hours","category":"page"},{"location":"literated/langmuir_turbulence/#Model-set-up","page":"Langmuir turbulence","title":"Model set-up","text":"","category":"section"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"To build the model, we specify the grid, Stokes drift, boundary conditions, and Coriolis parameter.","category":"page"},{"location":"literated/langmuir_turbulence/#Domain-and-numerical-grid-specification","page":"Langmuir turbulence","title":"Domain and numerical grid specification","text":"","category":"section"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"We use a modest resolution and the same total extent as Wagner et al. (2021),","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"grid = RectilinearGrid(size=(32, 32, 32), extent=(128, 128, 64))","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"32×32×32 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo\n├── Periodic x ∈ [0.0, 128.0) regularly spaced with Δx=4.0\n├── Periodic y ∈ [0.0, 128.0) regularly spaced with Δy=4.0\n└── Bounded  z ∈ [-64.0, 0.0] regularly spaced with Δz=2.0","category":"page"},{"location":"literated/langmuir_turbulence/#The-Stokes-Drift-profile","page":"Langmuir turbulence","title":"The Stokes Drift profile","text":"","category":"section"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"The surface wave Stokes drift profile prescribed in Wagner et al. (2021), corresponds to a 'monochromatic' (that is, single-frequency) wave field.","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"A monochromatic wave field is characterized by its wavelength and amplitude (half the distance from wave crest to wave trough), which determine the wave frequency and the vertical scale of the Stokes drift profile.","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"using Oceananigans.BuoyancyModels: g_Earth\n\n amplitude = 0.8 # m\nwavelength = 60  # m\nwavenumber = 2π / wavelength # m⁻¹\n frequency = sqrt(g_Earth * wavenumber) # s⁻¹\n\n# The vertical scale over which the Stokes drift of a monochromatic surface wave\n# decays away from the surface is `1/2wavenumber`, or\nconst vertical_scale = wavelength / 4π\n\n# Stokes drift velocity at the surface\nconst Uˢ = amplitude^2 * wavenumber * frequency # m s⁻¹","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"0.06791774197745354","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"The const declarations ensure that Stokes drift functions compile on the GPU. To run this example on the GPU, include GPU() in the RectilinearGrid constructor above.","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"The Stokes drift profile is","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"uˢ(z) = Uˢ * exp(z / vertical_scale)","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"uˢ (generic function with 1 method)","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"and its z-derivative is","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"∂z_uˢ(z, t) = 1 / vertical_scale * Uˢ * exp(z / vertical_scale)","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"∂z_uˢ (generic function with 1 method)","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"info: The Craik-Leibovich equations in Oceananigans\nOceananigans implements the Craik-Leibovich approximation for surface wave effects using the Lagrangian-mean velocity field as its prognostic momentum variable. In other words, model.velocities.u is the Lagrangian-mean x-velocity beneath surface waves. This differs from models that use the Eulerian-mean velocity field as a prognostic variable, but has the advantage that u accounts for the total advection of tracers and momentum, and that u = v = w = 0 is a steady solution even when Coriolis forces are present. See the physics documentation for more information.","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"Finally, we note that the time-derivative of the Stokes drift must be provided if the Stokes drift and surface wave field undergoes forced changes in time. In this example, the Stokes drift is constant and thus the time-derivative of the Stokes drift is 0.","category":"page"},{"location":"literated/langmuir_turbulence/#Boundary-conditions","page":"Langmuir turbulence","title":"Boundary conditions","text":"","category":"section"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"At the surface z = 0, Wagner et al. (2021) impose","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"Qᵘ = -3.72e-5 # m² s⁻², surface kinematic momentum flux\n\nu_boundary_conditions = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵘ))","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"Oceananigans.FieldBoundaryConditions, with boundary conditions\n├── west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── bottom: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── top: FluxBoundaryCondition: -3.72e-5\n└── immersed: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"Wagner et al. (2021) impose a linear buoyancy gradient N² at the bottom along with a weak, destabilizing flux of buoyancy at the surface to faciliate spin-up from rest.","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"Qᵇ = 2.307e-8 # m² s⁻³, surface buoyancy flux\nN² = 1.936e-5 # s⁻², initial and bottom buoyancy gradient\n\nb_boundary_conditions = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵇ),\n                                                bottom = GradientBoundaryCondition(N²))","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"Oceananigans.FieldBoundaryConditions, with boundary conditions\n├── west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── bottom: GradientBoundaryCondition: 1.936e-5\n├── top: FluxBoundaryCondition: 2.307e-8\n└── immersed: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"info: The flux convention in Oceananigans\nNote that Oceananigans uses \"positive upward\" conventions for all fluxes. In consequence, a negative flux at the surface drives positive velocities, and a positive flux of buoyancy drives cooling.","category":"page"},{"location":"literated/langmuir_turbulence/#Coriolis-parameter","page":"Langmuir turbulence","title":"Coriolis parameter","text":"","category":"section"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"Wagner et al. (2021) use","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"coriolis = FPlane(f=1e-4) # s⁻¹","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"FPlane{Float64}(f=0.0001)","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"which is typical for mid-latitudes on Earth.","category":"page"},{"location":"literated/langmuir_turbulence/#Model-instantiation","page":"Langmuir turbulence","title":"Model instantiation","text":"","category":"section"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"We are ready to build the model. We use a fifth-order Weighted Essentially Non-Oscillatory (WENO) advection scheme and the AnisotropicMinimumDissipation model for large eddy simulation. Because our Stokes drift does not vary in x y, we use UniformStokesDrift, which expects Stokes drift functions of z t only.","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"model = NonhydrostaticModel(; grid, coriolis,\n                            advection = WENO(),\n                            timestepper = :RungeKutta3,\n                            tracers = :b,\n                            buoyancy = BuoyancyTracer(),\n                            closure = AnisotropicMinimumDissipation(),\n                            stokes_drift = UniformStokesDrift(∂z_uˢ=∂z_uˢ),\n                            boundary_conditions = (u=u_boundary_conditions, b=b_boundary_conditions))","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\n├── grid: 32×32×32 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo\n├── timestepper: RungeKutta3TimeStepper\n├── advection scheme: WENO reconstruction order 5\n├── tracers: b\n├── closure: AnisotropicMinimumDissipation{ExplicitTimeDiscretization, @NamedTuple{b::Float64}, Float64, Nothing}\n├── buoyancy: BuoyancyTracer with ĝ = NegativeZDirection()\n└── coriolis: FPlane{Float64}(f=0.0001)","category":"page"},{"location":"literated/langmuir_turbulence/#Initial-conditions","page":"Langmuir turbulence","title":"Initial conditions","text":"","category":"section"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"We make use of random noise concentrated in the upper 4 meters for buoyancy and velocity initial conditions,","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"Ξ(z) = randn() * exp(z / 4)","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"Our initial condition for buoyancy consists of a surface mixed layer 33 m deep, a deep linear stratification, plus noise,","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"initial_mixed_layer_depth = 33 # m\nstratification(z) = z < - initial_mixed_layer_depth ? N² * z : N² * (-initial_mixed_layer_depth)\n\nbᵢ(x, y, z) = stratification(z) + 1e-1 * Ξ(z) * N² * model.grid.Lz","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"bᵢ (generic function with 1 method)","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"The simulation we reproduce from Wagner et al. (2021) is zero Lagrangian-mean velocity. This initial condition is consistent with a wavy, quiescent ocean suddenly impacted by winds. To this quiescent state we add noise scaled by the friction velocity to u and w.","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"u★ = sqrt(abs(Qᵘ))\nuᵢ(x, y, z) = u★ * 1e-1 * Ξ(z)\nwᵢ(x, y, z) = u★ * 1e-1 * Ξ(z)\n\nset!(model, u=uᵢ, w=wᵢ, b=bᵢ)","category":"page"},{"location":"literated/langmuir_turbulence/#Setting-up-the-simulation","page":"Langmuir turbulence","title":"Setting up the simulation","text":"","category":"section"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"simulation = Simulation(model, Δt=45.0, stop_time=4hours)","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"Simulation of NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\n├── Next time step: 45 seconds\n├── Elapsed wall time: 0 seconds\n├── Wall time per iteration: NaN days\n├── Stop time: 4 hours\n├── Stop iteration : Inf\n├── Wall time limit: Inf\n├── Callbacks: OrderedDict with 4 entries:\n│   ├── stop_time_exceeded => Callback of stop_time_exceeded on IterationInterval(1)\n│   ├── stop_iteration_exceeded => Callback of stop_iteration_exceeded on IterationInterval(1)\n│   ├── wall_time_limit_exceeded => Callback of wall_time_limit_exceeded on IterationInterval(1)\n│   └── nan_checker => Callback of NaNChecker for u on IterationInterval(100)\n├── Output writers: OrderedDict with no entries\n└── Diagnostics: OrderedDict with no entries","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"We use the TimeStepWizard for adaptive time-stepping with a Courant-Freidrichs-Lewy (CFL) number of 1.0,","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"conjure_time_step_wizard!(simulation, cfl=1.0, max_Δt=1minute)","category":"page"},{"location":"literated/langmuir_turbulence/#Nice-progress-messaging","page":"Langmuir turbulence","title":"Nice progress messaging","text":"","category":"section"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"We define a function that prints a helpful message with maximum absolute value of u v w and the current wall clock time.","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"using Printf\n\nfunction progress(simulation)\n    u, v, w = simulation.model.velocities\n\n    # Print a progress message\n    msg = @sprintf(\"i: %04d, t: %s, Δt: %s, umax = (%.1e, %.1e, %.1e) ms⁻¹, wall time: %s\\n\",\n                   iteration(simulation),\n                   prettytime(time(simulation)),\n                   prettytime(simulation.Δt),\n                   maximum(abs, u), maximum(abs, v), maximum(abs, w),\n                   prettytime(simulation.run_wall_time))\n\n    @info msg\n\n    return nothing\nend\n\nsimulation.callbacks[:progress] = Callback(progress, IterationInterval(20))","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"Callback of progress on IterationInterval(20)","category":"page"},{"location":"literated/langmuir_turbulence/#Output","page":"Langmuir turbulence","title":"Output","text":"","category":"section"},{"location":"literated/langmuir_turbulence/#A-field-writer","page":"Langmuir turbulence","title":"A field writer","text":"","category":"section"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"We set up an output writer for the simulation that saves all velocity fields, tracer fields, and the subgrid turbulent diffusivity.","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"output_interval = 5minutes\n\nfields_to_output = merge(model.velocities, model.tracers, (; νₑ=model.diffusivity_fields.νₑ))\n\nsimulation.output_writers[:fields] =\n    JLD2OutputWriter(model, fields_to_output,\n                     schedule = TimeInterval(output_interval),\n                     filename = \"langmuir_turbulence_fields.jld2\",\n                     overwrite_existing = true)","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"JLD2OutputWriter scheduled on TimeInterval(5 minutes):\n├── filepath: ./langmuir_turbulence_fields.jld2\n├── 5 outputs: (u, v, w, b, νₑ)\n├── array type: Array{Float64}\n├── including: [:grid, :coriolis, :buoyancy, :closure]\n├── file_splitting: NoFileSplitting\n└── file size: 41.5 KiB","category":"page"},{"location":"literated/langmuir_turbulence/#An-\"averages\"-writer","page":"Langmuir turbulence","title":"An \"averages\" writer","text":"","category":"section"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"We also set up output of time- and horizontally-averaged velocity field and momentum fluxes.","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"u, v, w = model.velocities\nb = model.tracers.b\n\n U = Average(u, dims=(1, 2))\n V = Average(v, dims=(1, 2))\n B = Average(b, dims=(1, 2))\nwu = Average(w * u, dims=(1, 2))\nwv = Average(w * v, dims=(1, 2))\n\nsimulation.output_writers[:averages] =\n    JLD2OutputWriter(model, (; U, V, B, wu, wv),\n                     schedule = AveragedTimeInterval(output_interval, window=2minutes),\n                     filename = \"langmuir_turbulence_averages.jld2\",\n                     overwrite_existing = true)","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"JLD2OutputWriter scheduled on TimeInterval(5 minutes):\n├── filepath: ./langmuir_turbulence_averages.jld2\n├── 5 outputs: (U, V, B, wu, wv) averaged on AveragedTimeInterval(window=2 minutes, stride=1, interval=5 minutes)\n├── array type: Array{Float64}\n├── including: [:grid, :coriolis, :buoyancy, :closure]\n├── file_splitting: NoFileSplitting\n└── file size: 41.1 KiB","category":"page"},{"location":"literated/langmuir_turbulence/#Running-the-simulation","page":"Langmuir turbulence","title":"Running the simulation","text":"","category":"section"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"This part is easy,","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"run!(simulation)","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"[ Info: Initializing simulation...\n[ Info: i: 0000, t: 0 seconds, Δt: 49.500 seconds, umax = (1.4e-03, 6.1e-04, 6.7e-04) ms⁻¹, wall time: 0 seconds\n[ Info:     ... simulation initialization complete (17.373 seconds)\n[ Info: Executing initial time step...\n[ Info:     ... initial time step complete (7.098 seconds).\n[ Info: i: 0020, t: 15.907 minutes, Δt: 59.895 seconds, umax = (2.3e-02, 9.8e-03, 2.3e-02) ms⁻¹, wall time: 27.704 seconds\n[ Info: i: 0040, t: 33 minutes, Δt: 1 minute, umax = (3.4e-02, 8.3e-03, 2.1e-02) ms⁻¹, wall time: 28.922 seconds\n[ Info: i: 0060, t: 53 minutes, Δt: 1 minute, umax = (4.6e-02, 1.2e-02, 1.5e-02) ms⁻¹, wall time: 30.144 seconds\n[ Info: i: 0080, t: 1.183 hours, Δt: 56.639 seconds, umax = (5.4e-02, 1.8e-02, 1.5e-02) ms⁻¹, wall time: 31.297 seconds\n[ Info: i: 0100, t: 1.461 hours, Δt: 51.107 seconds, umax = (5.9e-02, 2.4e-02, 2.2e-02) ms⁻¹, wall time: 32.426 seconds\n[ Info: i: 0120, t: 1.705 hours, Δt: 48.606 seconds, umax = (6.2e-02, 3.0e-02, 2.8e-02) ms⁻¹, wall time: 33.526 seconds\n[ Info: i: 0140, t: 1.944 hours, Δt: 47.425 seconds, umax = (6.6e-02, 3.3e-02, 2.7e-02) ms⁻¹, wall time: 34.692 seconds\n[ Info: i: 0160, t: 2.179 hours, Δt: 43.283 seconds, umax = (6.5e-02, 3.6e-02, 2.7e-02) ms⁻¹, wall time: 35.855 seconds\n[ Info: i: 0180, t: 2.402 hours, Δt: 41.093 seconds, umax = (6.6e-02, 3.7e-02, 3.3e-02) ms⁻¹, wall time: 36.805 seconds\n[ Info: i: 0200, t: 2.605 hours, Δt: 40.132 seconds, umax = (6.9e-02, 4.0e-02, 3.3e-02) ms⁻¹, wall time: 38.021 seconds\n[ Info: i: 0220, t: 2.820 hours, Δt: 40.159 seconds, umax = (7.4e-02, 4.2e-02, 2.8e-02) ms⁻¹, wall time: 39.136 seconds\n[ Info: i: 0240, t: 3.021 hours, Δt: 35.839 seconds, umax = (7.5e-02, 4.6e-02, 3.1e-02) ms⁻¹, wall time: 40.399 seconds\n[ Info: i: 0260, t: 3.205 hours, Δt: 37.700 seconds, umax = (7.1e-02, 5.0e-02, 3.8e-02) ms⁻¹, wall time: 41.647 seconds\n[ Info: i: 0280, t: 3.411 hours, Δt: 40.312 seconds, umax = (6.8e-02, 4.3e-02, 3.6e-02) ms⁻¹, wall time: 42.735 seconds\n[ Info: i: 0300, t: 3.616 hours, Δt: 38.837 seconds, umax = (6.4e-02, 4.9e-02, 3.2e-02) ms⁻¹, wall time: 43.776 seconds\n[ Info: i: 0320, t: 3.826 hours, Δt: 39.707 seconds, umax = (6.5e-02, 4.7e-02, 3.0e-02) ms⁻¹, wall time: 44.705 seconds\n[ Info: Simulation is stopping after running for 45.616 seconds.\n[ Info: Simulation time 4 hours equals or exceeds stop time 4 hours.\n","category":"page"},{"location":"literated/langmuir_turbulence/#Making-a-neat-movie","page":"Langmuir turbulence","title":"Making a neat movie","text":"","category":"section"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"We look at the results by loading data from file with FieldTimeSeries, and plotting vertical slices of u and w, and a horizontal slice of w to look for Langmuir cells.","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"using CairoMakie\n\ntime_series = (;\n     w = FieldTimeSeries(\"langmuir_turbulence_fields.jld2\", \"w\"),\n     u = FieldTimeSeries(\"langmuir_turbulence_fields.jld2\", \"u\"),\n     B = FieldTimeSeries(\"langmuir_turbulence_averages.jld2\", \"B\"),\n     U = FieldTimeSeries(\"langmuir_turbulence_averages.jld2\", \"U\"),\n     V = FieldTimeSeries(\"langmuir_turbulence_averages.jld2\", \"V\"),\n    wu = FieldTimeSeries(\"langmuir_turbulence_averages.jld2\", \"wu\"),\n    wv = FieldTimeSeries(\"langmuir_turbulence_averages.jld2\", \"wv\"))\n\ntimes = time_series.w.times\nxw, yw, zw = nodes(time_series.w)\nxu, yu, zu = nodes(time_series.u)","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"We are now ready to animate using Makie. We use Makie's Observable to animate the data. To dive into how Observables work we refer to Makie.jl's Documentation.","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"n = Observable(1)\n\nwxy_title = @lift string(\"w(x, y, t) at z=-8 m and t = \", prettytime(times[$n]))\nwxz_title = @lift string(\"w(x, z, t) at y=0 m and t = \", prettytime(times[$n]))\nuxz_title = @lift string(\"u(x, z, t) at y=0 m and t = \", prettytime(times[$n]))\n\nfig = Figure(size = (850, 850))\n\nax_B = Axis(fig[1, 4];\n            xlabel = \"Buoyancy (m s⁻²)\",\n            ylabel = \"z (m)\")\n\nax_U = Axis(fig[2, 4];\n            xlabel = \"Velocities (m s⁻¹)\",\n            ylabel = \"z (m)\",\n            limits = ((-0.07, 0.07), nothing))\n\nax_fluxes = Axis(fig[3, 4];\n                 xlabel = \"Momentum fluxes (m² s⁻²)\",\n                 ylabel = \"z (m)\",\n                 limits = ((-3.5e-5, 3.5e-5), nothing))\n\nax_wxy = Axis(fig[1, 1:2];\n              xlabel = \"x (m)\",\n              ylabel = \"y (m)\",\n              aspect = DataAspect(),\n              limits = ((0, grid.Lx), (0, grid.Ly)),\n              title = wxy_title)\n\nax_wxz = Axis(fig[2, 1:2];\n              xlabel = \"x (m)\",\n              ylabel = \"z (m)\",\n              aspect = AxisAspect(2),\n              limits = ((0, grid.Lx), (-grid.Lz, 0)),\n              title = wxz_title)\n\nax_uxz = Axis(fig[3, 1:2];\n              xlabel = \"x (m)\",\n              ylabel = \"z (m)\",\n              aspect = AxisAspect(2),\n              limits = ((0, grid.Lx), (-grid.Lz, 0)),\n              title = uxz_title)\n\n\nwₙ = @lift time_series.w[$n]\nuₙ = @lift time_series.u[$n]\nBₙ = @lift time_series.B[$n][1, 1, :]\nUₙ = @lift time_series.U[$n][1, 1, :]\nVₙ = @lift time_series.V[$n][1, 1, :]\nwuₙ = @lift time_series.wu[$n][1, 1, :]\nwvₙ = @lift time_series.wv[$n][1, 1, :]\n\nk = searchsortedfirst(grid.zᵃᵃᶠ[:], -8)\nwxyₙ = @lift interior(time_series.w[$n], :, :, k)\nwxzₙ = @lift interior(time_series.w[$n], :, 1, :)\nuxzₙ = @lift interior(time_series.u[$n], :, 1, :)\n\nwlims = (-0.03, 0.03)\nulims = (-0.05, 0.05)\n\nlines!(ax_B, Bₙ, zu)\n\nlines!(ax_U, Uₙ, zu; label = L\"\\bar{u}\")\nlines!(ax_U, Vₙ, zu; label = L\"\\bar{v}\")\naxislegend(ax_U; position = :rb)\n\nlines!(ax_fluxes, wuₙ, zw; label = L\"mean $wu$\")\nlines!(ax_fluxes, wvₙ, zw; label = L\"mean $wv$\")\naxislegend(ax_fluxes; position = :rb)\n\nhm_wxy = heatmap!(ax_wxy, xw, yw, wxyₙ;\n                  colorrange = wlims,\n                  colormap = :balance)\n\nColorbar(fig[1, 3], hm_wxy; label = \"m s⁻¹\")\n\nhm_wxz = heatmap!(ax_wxz, xw, zw, wxzₙ;\n                  colorrange = wlims,\n                  colormap = :balance)\n\nColorbar(fig[2, 3], hm_wxz; label = \"m s⁻¹\")\n\nax_uxz = heatmap!(ax_uxz, xu, zu, uxzₙ;\n                  colorrange = ulims,\n                  colormap = :balance)\n\nColorbar(fig[3, 3], ax_uxz; label = \"m s⁻¹\")\n\nfig","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"(Image: )","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"And, finally, we record a movie.","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"frames = 1:length(times)\n\nrecord(fig, \"langmuir_turbulence.mp4\", frames, framerate=8) do i\n    n[] = i\nend","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"(Image: )","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"","category":"page"},{"location":"literated/langmuir_turbulence/","page":"Langmuir turbulence","title":"Langmuir turbulence","text":"This page was generated using Literate.jl.","category":"page"},{"location":"physics/hydrostatic_free_surface_model/#hydrostatic_free_surface_model","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"","category":"section"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"The HydrostaticFreeSurfaceModel solves the incompressible Navier-Stokes equations under the Boussinesq and hydrostatic approximations and with an arbitrary number of tracer conservation  equations. Physics associated with individual terms in the momentum and tracer conservation equations – the background rotation rate of the equation's reference frame, gravitational effects associated with buoyant tracers under the Boussinesq approximation, generalized stresses and tracer fluxes associated with viscous and diffusive physics, and arbitrary \"forcing functions\" – are determined by the whims of the user.","category":"page"},{"location":"physics/hydrostatic_free_surface_model/#Mass-conservation-and-free-surface-evolution-equation","page":"Hydrostatic model with a free surface","title":"Mass conservation and free surface evolution equation","text":"","category":"section"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"The mass conservation equation is","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"    0 = boldsymbolnabla_h boldsymbolcdot boldsymbolu + partial_z w    ","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"Given the horizontal flow boldsymbolu we use the above to diagnose the vertical velocity w. We integrate the mass conservation equation from the bottom of the fluid (where w = 0) up to depth z and recover w(x y z t).","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"The free surface displacement eta(x y t) satisfies the linearized kinematic boundary  condition at the surface","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"    partial_t eta = w(x y z=0 t)  ","category":"page"},{"location":"physics/hydrostatic_free_surface_model/#The-momentum-conservation-equation","page":"Hydrostatic model with a free surface","title":"The momentum conservation equation","text":"","category":"section"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"The equations governing the conservation of momentum in a rotating fluid, including buoyancy via the Boussinesq approximation are","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"    beginalign\n    partial_t boldsymbolu  = - left ( boldsymbolv boldsymbolcdot boldsymbolnabla right ) boldsymbolu\n                        - boldsymbolf times boldsymbolu \n                        - boldsymbolnabla_h (p + g eta)\n                        - boldsymbolnabla boldsymbolcdot boldsymboltau\n                        + boldsymbolF_u   labeleqmomentum\n    0  = b - partial_z p   labeleqhydrostatic\n    endalign","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"where b the is buoyancy, boldsymboltau is the hydrostatic kinematic stress tensor,  boldsymbolF_u denotes an internal forcing of the horizontal flow boldsymbolu, boldsymbolv = boldsymbolu + w hatboldsymbolz is the three-dimensional flow, p is kinematic pressure, eta is the free-surface displacement, and boldsymbolf  is the Coriolis parameter, or the background vorticity associated with the specified rate of  rotation of the frame of reference.","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"Equation \\eqref{eq:hydrostatic} above is the hydrostatic approximation and comes about as the  dominant balance of terms in the Navier-Stokes vertical momentum equation under the Boussinesq  approximation.","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"The terms that appear on the right-hand side of the momentum conservation equation are (in order):","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"momentum advection: left ( boldsymbolv boldsymbolcdot boldsymbolnabla right )  boldsymbolu,\nCoriolis: boldsymbolf times boldsymbolu,\nbaroclinic kinematic pressure gradient: boldsymbolnabla p,\nbarotropic kinematic pressure gradient: boldsymbolnabla (g eta),\nmolecular or turbulence viscous stress: boldsymbolnabla boldsymbolcdot boldsymboltau, and\nan arbitrary internal source of momentum: boldsymbolF_u.","category":"page"},{"location":"physics/hydrostatic_free_surface_model/#The-tracer-conservation-equation","page":"Hydrostatic model with a free surface","title":"The tracer conservation equation","text":"","category":"section"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"The conservation law for tracers is","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"    beginalign\n    partial_t c = - boldsymbolv boldsymbolcdot boldsymbolnabla c\n                   - boldsymbolnabla boldsymbolcdot boldsymbolq_c\n                   + F_c  \n    labeleqtracer\n    endalign","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"where boldsymbolq_c is the diffusive flux of c and F_c is an arbitrary source term. An arbitrary tracers are permitted and thus an arbitrary number of tracer equations can be solved simultaneously alongside with the momentum equations.","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"From left to right, the terms that appear on the right-hand side of the tracer conservation  equation are","category":"page"},{"location":"physics/hydrostatic_free_surface_model/","page":"Hydrostatic model with a free surface","title":"Hydrostatic model with a free surface","text":"tracer advection: boldsymbolv boldsymbolcdot boldsymbolnabla c,\nmolecular or turbulent diffusion: boldsymbolnabla boldsymbolcdot boldsymbolq_c, and\nan arbitrary internal source of tracer: F_c.","category":"page"},{"location":"fields/#Fields-basics","page":"Fields","title":"Fields basics","text":"","category":"section"},{"location":"fields/","page":"Fields","title":"Fields","text":"Fields and its relatives are core Oceananigans data structures. Fields are more or less arrays of data located on a grid, whose entries correspond to the average value of some quantity over some finite-sized volume. Fields also may contain boundary_conditions, may be computed from an operand  or expression involving other fields, and may cover only a portion of the total indices spanned by the grid.","category":"page"},{"location":"fields/#Staggered-grids-and-field-locations","page":"Fields","title":"Staggered grids and field locations","text":"","category":"section"},{"location":"fields/","page":"Fields","title":"Fields","text":"Oceananigans ocean-flavored fluids simulations rely fundamentally on \"staggered grid\" numerical methods.","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"Recall that grids represent a physical domain divided into finite volumes. For example, let's consider a horizontally-periodic, vertically-bounded grid of cells that divide up a cube with dimensions 1 times 1 times 1:","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"using Oceananigans\n\ngrid = RectilinearGrid(topology = (Periodic, Periodic, Bounded),\n                       size = (4, 5, 4),\n                       halo = (1, 1, 1),\n                       x = (0, 1),\n                       y = (0, 1),\n                       z = [0, 0.1, 0.3, 0.6, 1])\n\n# output\n4×5×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo\n├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25\n├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.2\n└── Bounded  z ∈ [0.0, 1.0] variably spaced with min(Δz)=0.1, max(Δz)=0.4","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"The cubic domain is divided into a \"primary mesh\" of 4 times 5 times 4 = 80 cells, which are evenly spaced in x y but variably spaced in z. Now, in addition to the primary mesh, the grid defines also a set of \"staggered\" grids whose cells are shifted by half a cell width relative to the primary mesh. In other words, the staggered grid cells have a \"location\" in each direction – either Center, and therefore co-located with the primary mesh, or Face and located over the interfaces of the primary mesh. For example, the primary or Center cell spacings in z are","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"zspacings(grid, Center())\n\n# output\n4-element view(OffsetArray(::Vector{Float64}, 0:5), 1:4) with eltype Float64:\n 0.1\n 0.19999999999999998\n 0.3\n 0.4","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"corresponding to cell interfaces located at z = [0, 0.1, 0.3, 0.6, 1]. But then for the grid which is staggered in z relative to the primary mesh,","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"zspacings(grid, Face())\n\n# output\n5-element view(OffsetArray(::Vector{Float64}, -1:5), 1:5) with eltype Float64:\n 0.1\n 0.15000000000000002\n 0.24999999999999994\n 0.3500000000000001\n 0.3999999999999999","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"The cells for the vertically staggered grid have different spacings than the primary mesh. That's because the edges of the vertically-staggered mesh coincide with the nodes (the cell centers) of the primary mesh. The nodes of the primary mesh are","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"znodes(grid, Center(), with_halos=true)\n\n# output\n6-element OffsetArray(::Vector{Float64}, 0:5) with eltype Float64 with indices 0:5:\n -0.05\n  0.05\n  0.2\n  0.44999999999999996\n  0.8\n  1.2","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"The center of the leftmost \"halo cell\" is z = -0.05, while the center of the first cell from the left is z = 0.05. This means that the width of the first cell on the vertically-staggered grid is 0.05 - (-0.05) = 0.1 – and so on. Finally, note that the nodes of the staggered mesh coincide with the cell interfaces of the primary mesh, so:","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"znodes(grid, Center())\n\n# output\n4-element view(OffsetArray(::Vector{Float64}, 0:5), 1:4) with eltype Float64:\n 0.05\n 0.2\n 0.44999999999999996\n 0.8","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"In a three-dimensional domain, there are 2³ = 8 meshes – 1 primary mesh, and 7 meshes that are staggered to varying degrees from the primary mesh. This system of staggered grids is commonly used in fluid dynamics and was invented specifically for simulations of the atmosphere and ocean.","category":"page"},{"location":"fields/#Constructing-Fields-at-specified-locations","page":"Fields","title":"Constructing Fields at specified locations","text":"","category":"section"},{"location":"fields/","page":"Fields","title":"Fields","text":"Every Field is associated with either the primary mesh or one of the staggered meshes by a three-dimensional \"location\" associated with each field. To build a fully-centered Field, for example, we write","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"c = Field{Center, Center, Center}(grid)\n\n# output\n4×5×4 Field{Center, Center, Center} on RectilinearGrid on CPU\n├── grid: 4×5×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo\n├── boundary conditions: FieldBoundaryConditions\n│   └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux\n└── data: 6×7×6 OffsetArray(::Array{Float64, 3}, 0:5, 0:6, 0:5) with eltype Float64 with indices 0:5×0:6×0:5\n    └── max=0.0, min=0.0, mean=0.0","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"Fully-centered fields also go by the alias CenterField,","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"c == CenterField(grid)\n\n# output\ntrue","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"Many fluid dynamical variables are located at cell centers – for example, tracers like temperature and salinity. Another common type of Field we encounter have cells located over the x-interfaces of the primary grid,","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"u = Field{Face, Center, Center}(grid)\n\n# output\n4×5×4 Field{Face, Center, Center} on RectilinearGrid on CPU\n├── grid: 4×5×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo\n├── boundary conditions: FieldBoundaryConditions\n│   └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux\n└── data: 6×7×6 OffsetArray(::Array{Float64, 3}, 0:5, 0:6, 0:5) with eltype Float64 with indices 0:5×0:6×0:5\n    └── max=0.0, min=0.0, mean=0.0","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"which also goes by the alias u = XFaceField(grid). The name u is suggestive: in the Arakawa type-C grid ('C-grid' for short) used by Oceananigans, the x-component of the velocity field is stored at Face, Center, Center location.","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"The centers of the u cells are shifted to the left relative to the c cells:","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"@show xnodes(c)\n@show xnodes(u)\nnothing\n\n# output\nxnodes(c) = [0.125, 0.375, 0.625, 0.875]\nxnodes(u) = [0.0, 0.25, 0.5, 0.75]","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"Notice that the first u-node is at x=0, the left end of the grid, but the last u-node is at x=0.75. Because the x-direction is Periodic, the XFaceField u has 4 cells in x – the cell just right of x=0.75 is the same as the cell at x=0.","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"Because the vertical direction is Bounded, however, vertically-staggered fields have more vertical cells than CenterFields:","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"w = Field{Center, Center, Face}(grid)\n\n@show znodes(c)\n@show znodes(w)\nnothing\n\n# output\nznodes(c) = [0.05, 0.2, 0.44999999999999996, 0.8]\nznodes(w) = [0.0, 0.1, 0.3, 0.6, 1.0]","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"Fields at Center, Center, Face are also called ZFaceField, and the vertical velocity is a ZFaceField on the C-grid. Let's visualize the situation:","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"using Oceananigans\nusing CairoMakie\nset_theme!(Theme(fontsize=24))\nCairoMakie.activate!(type=\"svg\")\n\ngrid = RectilinearGrid(topology = (Periodic, Periodic, Bounded),\n                       size = (4, 4, 4),\n                       halo = (1, 1, 1),\n                       x = (0, 1),\n                       y = (0, 1),\n                       z = [0, 0.1, 0.3, 0.6, 1])\n\nc = CenterField(grid)\n\nu = XFaceField(grid)","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"using CairoMakie\n\nfig = Figure(size=(600, 180))\nax = Axis(fig[1, 1], xlabel=\"x\")\n\n# Visualize the domain\nlines!(ax, [0, 1], [0, 0], color=:gray)\n\nxc = xnodes(c)\nxu = xnodes(u)\n\nscatter!(ax, xc, 0 * xc, marker=:circle, markersize=10, label=\"Cell centers\")\nscatter!(ax, xu, 0 * xu, marker=:vline, markersize=20, label=\"Cell interfaces\")\n\nylims!(ax, -1, 1)\nxlims!(ax, -0.1, 1.1)\nhideydecorations!(ax)\nhidexdecorations!(ax, ticklabels=false, label=false)\nhidespines!(ax)\n\nLegend(fig[0, 1], ax, nbanks=2, framevisible=false)\n\ncurrent_figure()","category":"page"},{"location":"fields/#Setting-Fields","page":"Fields","title":"Setting Fields","text":"","category":"section"},{"location":"fields/","page":"Fields","title":"Fields","text":"Fields are full of 0's when they are created, which is not very exciting. The situation can be improved using set! to change the values of a field. For example,","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"set!(c, 42)\n\n# output\n4×5×4 Field{Center, Center, Center} on RectilinearGrid on CPU\n├── grid: 4×5×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo\n├── boundary conditions: FieldBoundaryConditions\n│   └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux\n└── data: 6×7×6 OffsetArray(::Array{Float64, 3}, 0:5, 0:6, 0:5) with eltype Float64 with indices 0:5×0:6×0:5\n    └── max=42.0, min=42.0, mean=42.0","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"Now c is filled with 42s (for this simple case, we could also have used c .= 42). Let's confirm that:","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"c[1, 1, 1]\n\n# output\n42.0","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"Looks good. And","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"c[1:4, 1:5, 1]\n\n# output\n4×5 Matrix{Float64}:\n 42.0  42.0  42.0  42.0  42.0\n 42.0  42.0  42.0  42.0  42.0\n 42.0  42.0  42.0  42.0  42.0\n 42.0  42.0  42.0  42.0  42.0","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"Note that indexing into c is the same as indexing into c.data.","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"c[:, :, :] == c.data\n \n# output\ntrue","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"We can also set! with arrays,","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"using Random\nRandom.seed!(123)","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"random_stuff = rand(size(c)...)\nset!(c, random_stuff)\n\nheatmap(view(c, :, :, 1))","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"or even use functions to set,","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"fun_stuff(x, y, z) = 2x\nset!(c, fun_stuff)\n\n# output\n\n4×5×4 Field{Center, Center, Center} on RectilinearGrid on CPU\n├── grid: 4×5×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo\n├── boundary conditions: FieldBoundaryConditions\n│   └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux\n└── data: 6×7×6 OffsetArray(::Array{Float64, 3}, 0:5, 0:6, 0:5) with eltype Float64 with indices 0:5×0:6×0:5\n    └── max=1.75, min=0.25, mean=1.0","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"fun_stuff(x, y, z) = 2x\nset!(c, fun_stuff)","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"and plot it","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"heatmap(view(c, :, :, 1))","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"For Fields on three-dimensional grids, set! functions must have arguments x, y, z for RectilinearGrid, or λ, φ, z for LatitudeLongitudeGrid and OrthogonalSphericalShellGrid. But for Fields on one- and two-dimensional grids, only the arguments that correspond to the non-Flat directions must be included. For example, to set! on a one-dimensional grid we write","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"# Make a field on a one-dimensional grid\none_d_grid = RectilinearGrid(size=7, x=(0, 7), topology=(Periodic, Flat, Flat))\none_d_c = CenterField(one_d_grid)\n\n# The one-dimensional grid varies only in `x` \nstill_pretty_fun(x) = 3x\nset!(one_d_c, still_pretty_fun)\n\n# output\n7×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU\n├── grid: 7×1×1 RectilinearGrid{Float64, Periodic, Flat, Flat} on CPU with 3×0×0 halo\n├── boundary conditions: FieldBoundaryConditions\n│   └── west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux\n└── data: 13×1×1 OffsetArray(::Array{Float64, 3}, -2:10, 1:1, 1:1) with eltype Float64 with indices -2:10×1:1×1:1\n    └── max=19.5, min=1.5, mean=10.5","category":"page"},{"location":"fields/#A-bit-more-about-setting-with-functions","page":"Fields","title":"A bit more about setting with functions","text":"","category":"section"},{"location":"fields/","page":"Fields","title":"Fields","text":"Let's return to the three-dimensional fun_stuff case to investigate in more detail how set! works with functions. The xnodes of c – the coordinates of the center of c's finite volumes – are:","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"xc = xnodes(c)\n@show xc\nnothing # hide\n\n# output\nxc = [0.125, 0.375, 0.625, 0.875]","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"To set! the values of c we evaluate fun_stuff at c's nodes, producing","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"c[1:4, 1, 1]\n\n# output\n4-element Vector{Float64}:\n 0.25\n 0.75\n 1.25\n 1.75","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"note: Note\nThis function-setting method is a first-order method for computing the finite volume of c to fun_stuff. Higher-order algorithms could be implemented – have a crack if you're keen.","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"As a result set! can evaluate differently on Fields at different locations:","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"u = XFaceField(grid)\nset!(u, fun_stuff)\nu[1:4, 1, 1]\n\n# output\n4-element Vector{Float64}:\n 0.0\n 0.5\n 1.0\n 1.5","category":"page"},{"location":"fields/#Halo-regions-and-boundary-conditions","page":"Fields","title":"Halo regions and boundary conditions","text":"","category":"section"},{"location":"fields/","page":"Fields","title":"Fields","text":"We built grid with halo = (1, 1, 1), which means that the \"interior\" cells of the grid are surrounded by a \"halo region\" of cells that's one cell thick. The number of halo cells in each direction are stored in the properties Hx, Hy, Hz, so,","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"(grid.Hx, grid.Hy, grid.Hz)\n\n# output\n(1, 1, 1)","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"set! doesn't touch halo cells. Check out one of the two-dimensional slices of c showing both the interior and the halo regions:","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"c[:, :, 1]\n\n# output\n6×7 OffsetArray(::Matrix{Float64}, 0:5, 0:6) with eltype Float64 with indices 0:5×0:6:\n 0.0  0.0   0.0   0.0   0.0   0.0   0.0\n 0.0  0.25  0.25  0.25  0.25  0.25  0.0\n 0.0  0.75  0.75  0.75  0.75  0.75  0.0\n 0.0  1.25  1.25  1.25  1.25  1.25  0.0\n 0.0  1.75  1.75  1.75  1.75  1.75  0.0\n 0.0  0.0   0.0   0.0   0.0   0.0   0.0","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"The interior region is populated, but the surrounding halo regions are all 0. To remedy this situation we need to fill_halo_regions!:","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"using Oceananigans.BoundaryConditions: fill_halo_regions!\n\nfill_halo_regions!(c)\n\nc[:, :, 1]\n\n# output\n6×7 OffsetArray(::Matrix{Float64}, 0:5, 0:6) with eltype Float64 with indices 0:5×0:6:\n 1.75  1.75  1.75  1.75  1.75  1.75  1.75\n 0.25  0.25  0.25  0.25  0.25  0.25  0.25\n 0.75  0.75  0.75  0.75  0.75  0.75  0.75\n 1.25  1.25  1.25  1.25  1.25  1.25  1.25\n 1.75  1.75  1.75  1.75  1.75  1.75  1.75\n 0.25  0.25  0.25  0.25  0.25  0.25  0.25","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"The way the halo regions are filled depends on c.boundary_conditions:","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"c.boundary_conditions\n\n# output\nOceananigans.FieldBoundaryConditions, with boundary conditions\n├── west: PeriodicBoundaryCondition\n├── east: PeriodicBoundaryCondition\n├── south: PeriodicBoundaryCondition\n├── north: PeriodicBoundaryCondition\n├── bottom: FluxBoundaryCondition: Nothing\n├── top: FluxBoundaryCondition: Nothing\n└── immersed: FluxBoundaryCondition: Nothing","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"Specifically for c above, x and y are Periodic while z has been assigned the default \"no-flux\" boundary conditions for a Field with Center location in a Bounded direction. For no-flux boundary conditions, the halo regions of c are filled so that derivatives evaluated on the boundary return 0. To view only the interior cells of c we use the function interior,","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"interior(c, :, :, 1)\n\n# output\n4×5 view(::Array{Float64, 3}, 2:5, 2:6, 2) with eltype Float64:\n 0.25  0.25  0.25  0.25  0.25\n 0.75  0.75  0.75  0.75  0.75\n 1.25  1.25  1.25  1.25  1.25\n 1.75  1.75  1.75  1.75  1.75","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"Note that the indices of c (and the indices of c.data) are \"offset\" so that index 1 corresponds to the first interior cell. As a result,","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"c[1:4, 1:5, 1] == interior(c, :, :, 1)\n\n# output\ntrue","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"and more generally","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"typeof(c.data)\n\n# output\nOffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"Thus, for example, the x-indices of c.data vary from 1 - Hx to Nx + Hx – in this case, from 0 to 5. The underlying array can be accessed with parent(c). But note that the \"parent\" array does not have offset indices, so","category":"page"},{"location":"fields/","page":"Fields","title":"Fields","text":"@show parent(c)[1:2, 2, 2]\n@show c.data[1:2, 1, 1]\nnothing\n\n# output\n(parent(c))[1:2, 2, 2] = [1.75, 0.25]\nc.data[1:2, 1, 1] = [0.25, 0.75]","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"EditURL = \"../../../examples/ocean_wind_mixing_and_convection.jl\"","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/#gpu_example","page":"Ocean wind mixing and convection","title":"Wind- and convection-driven mixing in an ocean surface boundary layer","text":"","category":"section"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"This example simulates mixing by three-dimensional turbulence in an ocean surface boundary layer driven by atmospheric winds and convection. It demonstrates:","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"How to set-up a grid with varying spacing in the vertical direction\nHow to use the SeawaterBuoyancy model for buoyancy with a linear equation of state.\nHow to use a turbulence closure for large eddy simulation.\nHow to use a function to impose a boundary condition.","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/#Install-dependencies","page":"Ocean wind mixing and convection","title":"Install dependencies","text":"","category":"section"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"using Pkg\npkg\"add Oceananigans, CairoMakie\"","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We start by importing all of the packages and functions that we'll need for this example.","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"using Random\nusing Printf\nusing CairoMakie\n\nusing Oceananigans\nusing Oceananigans.Units: minute, minutes, hour","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/#The-grid","page":"Ocean wind mixing and convection","title":"The grid","text":"","category":"section"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We use 32²×24 grid points with 2 m grid spacing in the horizontal and varying spacing in the vertical, with higher resolution closer to the surface. Here we use a stretching function for the vertical nodes that maintains relatively constant vertical spacing in the mixed layer, which is desirable from a numerical standpoint:","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Nx = Ny = 32     # number of points in each of horizontal directions\nNz = 24          # number of points in the vertical direction\n\nLx = Ly = 64     # (m) domain horizontal extents\nLz = 32          # (m) domain depth\n\nrefinement = 1.2 # controls spacing near surface (higher means finer spaced)\nstretching = 12  # controls rate of stretching at bottom\n\n# Normalized height ranging from 0 to 1\nh(k) = (k - 1) / Nz\n\n# Linear near-surface generator\nζ₀(k) = 1 + (h(k) - 1) / refinement\n\n# Bottom-intensified stretching function\nΣ(k) = (1 - exp(-stretching * h(k))) / (1 - exp(-stretching))\n\n# Generating function\nz_faces(k) = Lz * (ζ₀(k) * Σ(k) - 1)\n\ngrid = RectilinearGrid(size = (Nx, Nx, Nz),\n                          x = (0, Lx),\n                          y = (0, Ly),\n                          z = z_faces)","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"32×32×24 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo\n├── Periodic x ∈ [0.0, 64.0)  regularly spaced with Δx=2.0\n├── Periodic y ∈ [0.0, 64.0)  regularly spaced with Δy=2.0\n└── Bounded  z ∈ [-32.0, 0.0] variably spaced with min(Δz)=1.11123, max(Δz)=2.53571","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We plot vertical spacing versus depth to inspect the prescribed grid stretching:","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"fig = Figure(size=(1200, 800))\nax = Axis(fig[1, 1], ylabel = \"Depth (m)\", xlabel = \"Vertical spacing (m)\")\n\nlines!(ax, zspacings(grid, Center()), znodes(grid, Center()))\nscatter!(ax, zspacings(grid, Center()), znodes(grid, Center()))\n\nfig","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"(Image: )","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/#Buoyancy-that-depends-on-temperature-and-salinity","page":"Ocean wind mixing and convection","title":"Buoyancy that depends on temperature and salinity","text":"","category":"section"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We use the SeawaterBuoyancy model with a linear equation of state,","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"buoyancy = SeawaterBuoyancy(equation_of_state=LinearEquationOfState(thermal_expansion = 2e-4,\n                                                                    haline_contraction = 8e-4))","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"SeawaterBuoyancy{Float64}:\n├── gravitational_acceleration: 9.80665\n└── equation_of_state: LinearEquationOfState(thermal_expansion=0.0002, haline_contraction=0.0008)","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/#Boundary-conditions","page":"Ocean wind mixing and convection","title":"Boundary conditions","text":"","category":"section"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We calculate the surface temperature flux associated with surface cooling of 200 W m⁻², reference density ρₒ, and heat capacity cᴾ,","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Qʰ = 200.0  # W m⁻², surface _heat_ flux\nρₒ = 1026.0 # kg m⁻³, average density at the surface of the world ocean\ncᴾ = 3991.0 # J K⁻¹ kg⁻¹, typical heat capacity for seawater\n\nQᵀ = Qʰ / (ρₒ * cᴾ) # K m s⁻¹, surface _temperature_ flux","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"4.884283985946938e-5","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Finally, we impose a temperature gradient dTdz both initially and at the bottom of the domain, culminating in the boundary conditions on temperature,","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"dTdz = 0.01 # K m⁻¹\n\nT_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵀ),\n                                bottom = GradientBoundaryCondition(dTdz))","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Oceananigans.FieldBoundaryConditions, with boundary conditions\n├── west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── bottom: GradientBoundaryCondition: 0.01\n├── top: FluxBoundaryCondition: 4.88428e-5\n└── immersed: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Note that a positive temperature flux at the surface of the ocean implies cooling. This is because a positive temperature flux implies that temperature is fluxed upwards, out of the ocean.","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"For the velocity field, we imagine a wind blowing over the ocean surface with an average velocity at 10 meters u₁₀, and use a drag coefficient cᴰ to estimate the kinematic stress (that is, stress divided by density) exerted by the wind on the ocean:","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"u₁₀ = 10    # m s⁻¹, average wind velocity 10 meters above the ocean\ncᴰ = 2.5e-3 # dimensionless drag coefficient\nρₐ = 1.225  # kg m⁻³, average density of air at sea-level\n\nQᵘ = - ρₐ / ρₒ * cᴰ * u₁₀ * abs(u₁₀) # m² s⁻²","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"-0.0002984892787524367","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"The boundary conditions on u are thus","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"u_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵘ))","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Oceananigans.FieldBoundaryConditions, with boundary conditions\n├── west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── bottom: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── top: FluxBoundaryCondition: -0.000298489\n└── immersed: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"For salinity, S, we impose an evaporative flux of the form","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"@inline Qˢ(x, y, t, S, evaporation_rate) = - evaporation_rate * S # [salinity unit] m s⁻¹","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"where S is salinity. We use an evporation rate of 1 millimeter per hour,","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"evaporation_rate = 1e-3 / hour # m s⁻¹","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"2.7777777777777776e-7","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We build the Flux evaporation BoundaryCondition with the function Qˢ, indicating that Qˢ depends on salinity S and passing the parameter evaporation_rate,","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"evaporation_bc = FluxBoundaryCondition(Qˢ, field_dependencies=:S, parameters=evaporation_rate)","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"FluxBoundaryCondition: ContinuousBoundaryFunction Qˢ at (Nothing, Nothing, Nothing)","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"The full salinity boundary conditions are","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"S_bcs = FieldBoundaryConditions(top=evaporation_bc)","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Oceananigans.FieldBoundaryConditions, with boundary conditions\n├── west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── bottom: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── top: FluxBoundaryCondition: ContinuousBoundaryFunction Qˢ at (Nothing, Nothing, Nothing)\n└── immersed: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/#Model-instantiation","page":"Ocean wind mixing and convection","title":"Model instantiation","text":"","category":"section"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We fill in the final details of the model here: upwind-biased 5th-order advection for momentum and tracers, 3rd-order Runge-Kutta time-stepping, Coriolis forces, and the AnisotropicMinimumDissipation closure for large eddy simulation to model the effect of turbulent motions at scales smaller than the grid scale that we cannot explicitly resolve.","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"model = NonhydrostaticModel(; grid, buoyancy,\n                            advection = UpwindBiasedFifthOrder(),\n                            timestepper = :RungeKutta3,\n                            tracers = (:T, :S),\n                            coriolis = FPlane(f=1e-4),\n                            closure = AnisotropicMinimumDissipation(),\n                            boundary_conditions = (u=u_bcs, T=T_bcs, S=S_bcs))","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\n├── grid: 32×32×24 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo\n├── timestepper: RungeKutta3TimeStepper\n├── advection scheme: Upwind Biased reconstruction order 5\n├── tracers: (T, S)\n├── closure: AnisotropicMinimumDissipation{ExplicitTimeDiscretization, @NamedTuple{T::Float64, S::Float64}, Float64, Nothing}\n├── buoyancy: SeawaterBuoyancy with g=9.80665 and LinearEquationOfState(thermal_expansion=0.0002, haline_contraction=0.0008) with ĝ = NegativeZDirection()\n└── coriolis: FPlane{Float64}(f=0.0001)","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Notes:","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"To use the Smagorinsky-Lilly turbulence closure (with a constant model coefficient) rather than AnisotropicMinimumDissipation, use closure = SmagorinskyLilly() in the model constructor.\nTo change the architecture to GPU, replace CPU() with GPU() inside the grid constructor.","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/#Initial-conditions","page":"Ocean wind mixing and convection","title":"Initial conditions","text":"","category":"section"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Our initial condition for temperature consists of a linear stratification superposed with random noise damped at the walls, while our initial condition for velocity consists only of random noise.","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"# Random noise damped at top and bottom\nΞ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz) # noise\n\n# Temperature initial condition: a stable density gradient with random noise superposed.\nTᵢ(x, y, z) = 20 + dTdz * z + dTdz * model.grid.Lz * 1e-6 * Ξ(z)\n\n# Velocity initial condition: random noise scaled by the friction velocity.\nuᵢ(x, y, z) = sqrt(abs(Qᵘ)) * 1e-3 * Ξ(z)\n\n# `set!` the `model` fields using functions or constants:\nset!(model, u=uᵢ, w=uᵢ, T=Tᵢ, S=35)","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/#Setting-up-a-simulation","page":"Ocean wind mixing and convection","title":"Setting up a simulation","text":"","category":"section"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We set-up a simulation with an initial time-step of 10 seconds that stops at 40 minutes, with adaptive time-stepping and progress printing.","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"simulation = Simulation(model, Δt=10.0, stop_time=40minutes)","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Simulation of NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\n├── Next time step: 10 seconds\n├── Elapsed wall time: 0 seconds\n├── Wall time per iteration: NaN days\n├── Stop time: 40 minutes\n├── Stop iteration : Inf\n├── Wall time limit: Inf\n├── Callbacks: OrderedDict with 4 entries:\n│   ├── stop_time_exceeded => Callback of stop_time_exceeded on IterationInterval(1)\n│   ├── stop_iteration_exceeded => Callback of stop_iteration_exceeded on IterationInterval(1)\n│   ├── wall_time_limit_exceeded => Callback of wall_time_limit_exceeded on IterationInterval(1)\n│   └── nan_checker => Callback of NaNChecker for u on IterationInterval(100)\n├── Output writers: OrderedDict with no entries\n└── Diagnostics: OrderedDict with no entries","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"The TimeStepWizard helps ensure stable time-stepping with a Courant-Freidrichs-Lewy (CFL) number of 1.0.","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"wizard = TimeStepWizard(cfl=1.0, max_change=1.1, max_Δt=1minute)\nsimulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10))","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Callback of TimeStepWizard(cfl=1.0, max_Δt=60.0, min_Δt=0.0) on IterationInterval(10)","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Nice progress messaging is helpful:","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"# Print a progress message\nprogress_message(sim) = @printf(\"Iteration: %04d, time: %s, Δt: %s, max(|w|) = %.1e ms⁻¹, wall time: %s\\n\",\n                                iteration(sim), prettytime(sim), prettytime(sim.Δt),\n                                maximum(abs, sim.model.velocities.w), prettytime(sim.run_wall_time))\n\nadd_callback!(simulation, progress_message, IterationInterval(20))","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We then set up the simulation:","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/#Output","page":"Ocean wind mixing and convection","title":"Output","text":"","category":"section"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We use the JLD2OutputWriter to save x z slices of the velocity fields, tracer fields, and eddy diffusivities. The prefix keyword argument to JLD2OutputWriter indicates that output will be saved in ocean_wind_mixing_and_convection.jld2.","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"# Create a NamedTuple with eddy viscosity\neddy_viscosity = (; νₑ = model.diffusivity_fields.νₑ)\n\nfilename = \"ocean_wind_mixing_and_convection\"\n\nsimulation.output_writers[:slices] =\n    JLD2OutputWriter(model, merge(model.velocities, model.tracers, eddy_viscosity),\n                     filename = filename * \".jld2\",\n                     indices = (:, grid.Ny/2, :),\n                     schedule = TimeInterval(1minute),\n                     overwrite_existing = true)","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"JLD2OutputWriter scheduled on TimeInterval(1 minute):\n├── filepath: ./ocean_wind_mixing_and_convection.jld2\n├── 6 outputs: (u, v, w, T, S, νₑ)\n├── array type: Array{Float64}\n├── including: [:grid, :coriolis, :buoyancy, :closure]\n├── file_splitting: NoFileSplitting\n└── file size: 50.3 KiB","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We're ready:","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"run!(simulation)","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"[ Info: Initializing simulation...\nIteration: 0000, time: 0 seconds, Δt: 11 seconds, max(|w|) = 1.1e-05 ms⁻¹, wall time: 0 seconds\n[ Info:     ... simulation initialization complete (18.367 seconds)\n[ Info: Executing initial time step...\n[ Info:     ... initial time step complete (9.508 seconds).\nIteration: 0020, time: 3.403 minutes, Δt: 13.310 seconds, max(|w|) = 8.9e-06 ms⁻¹, wall time: 28.476 seconds\nIteration: 0040, time: 7.488 minutes, Δt: 16.105 seconds, max(|w|) = 5.9e-06 ms⁻¹, wall time: 29.210 seconds\nIteration: 0060, time: 12 minutes, Δt: 9.990 seconds, max(|w|) = 1.1e-05 ms⁻¹, wall time: 29.988 seconds\nIteration: 0080, time: 14.884 minutes, Δt: 7.989 seconds, max(|w|) = 4.8e-05 ms⁻¹, wall time: 31.081 seconds\nIteration: 0100, time: 17.245 minutes, Δt: 6.846 seconds, max(|w|) = 2.0e-04 ms⁻¹, wall time: 31.734 seconds\nIteration: 0120, time: 19.321 minutes, Δt: 6.035 seconds, max(|w|) = 1.1e-03 ms⁻¹, wall time: 32.317 seconds\nIteration: 0140, time: 21.191 minutes, Δt: 5.408 seconds, max(|w|) = 4.8e-03 ms⁻¹, wall time: 32.959 seconds\nIteration: 0160, time: 22.919 minutes, Δt: 4.816 seconds, max(|w|) = 1.7e-02 ms⁻¹, wall time: 33.471 seconds\nIteration: 0180, time: 24.390 minutes, Δt: 4.754 seconds, max(|w|) = 3.4e-02 ms⁻¹, wall time: 34.013 seconds\nIteration: 0200, time: 25.993 minutes, Δt: 5.095 seconds, max(|w|) = 4.1e-02 ms⁻¹, wall time: 34.635 seconds\nIteration: 0220, time: 27.634 minutes, Δt: 5.836 seconds, max(|w|) = 5.9e-02 ms⁻¹, wall time: 35.170 seconds\nIteration: 0240, time: 29.496 minutes, Δt: 5.613 seconds, max(|w|) = 7.0e-02 ms⁻¹, wall time: 35.750 seconds\nIteration: 0260, time: 31.185 minutes, Δt: 6.085 seconds, max(|w|) = 7.3e-02 ms⁻¹, wall time: 36.494 seconds\nIteration: 0280, time: 33.106 minutes, Δt: 6.014 seconds, max(|w|) = 6.2e-02 ms⁻¹, wall time: 37.119 seconds\nIteration: 0300, time: 35.104 minutes, Δt: 6.349 seconds, max(|w|) = 5.7e-02 ms⁻¹, wall time: 37.766 seconds\nIteration: 0320, time: 37.108 minutes, Δt: 6.610 seconds, max(|w|) = 6.1e-02 ms⁻¹, wall time: 38.550 seconds\nIteration: 0340, time: 39.229 minutes, Δt: 6.482 seconds, max(|w|) = 5.5e-02 ms⁻¹, wall time: 39.130 seconds\n[ Info: Simulation is stopping after running for 39.350 seconds.\n[ Info: Simulation time 40 minutes equals or exceeds stop time 40 minutes.\n","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/#Turbulence-visualization","page":"Ocean wind mixing and convection","title":"Turbulence visualization","text":"","category":"section"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We animate the data saved in ocean_wind_mixing_and_convection.jld2. We prepare for animating the flow by loading the data into FieldTimeSeries and defining functions for computing colorbar limits.","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"filepath = filename * \".jld2\"\n\ntime_series = (w = FieldTimeSeries(filepath, \"w\"),\n               T = FieldTimeSeries(filepath, \"T\"),\n               S = FieldTimeSeries(filepath, \"S\"),\n               νₑ = FieldTimeSeries(filepath, \"νₑ\"))\n\n# Coordinate arrays\nxw, yw, zw = nodes(time_series.w)\nxT, yT, zT = nodes(time_series.T)","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"([1.0, 3.0, 5.0, 7.0, 9.0, 11.0, 13.0, 15.0, 17.0, 19.0, 21.0, 23.0, 25.0, 27.0, 29.0, 31.0, 33.0, 35.0, 37.0, 39.0, 41.0, 43.0, 45.0, 47.0, 49.0, 51.0, 53.0, 55.0, 57.0, 59.0, 61.0, 63.0], [1.0, 3.0, 5.0, 7.0, 9.0, 11.0, 13.0, 15.0, 17.0, 19.0, 21.0, 23.0, 25.0, 27.0, 29.0, 31.0, 33.0, 35.0, 37.0, 39.0, 41.0, 43.0, 45.0, 47.0, 49.0, 51.0, 53.0, 55.0, 57.0, 59.0, 61.0, 63.0], [-30.73214655800215, -28.344120885446316, -26.245517670529452, -24.406267643406927, -22.77515636448867, -21.301119444298777, -19.9410533865803, -18.66145654635607, -17.43754626408272, -16.251584220508228, -15.09116977761991, -13.947785764082138, -12.815662268579008, -11.690933327108011, -10.57103192002591, -9.45426630377412, -8.339528643431164, -7.226097424980429, -6.1135049573687645, -5.001449332843377, -3.889736372710594, -2.7782415919634484, -1.666885417004453, -0.5556171156552487])","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We start the animation at t = 10 minutes since things are pretty boring till then:","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"times = time_series.w.times\nintro = searchsortedfirst(times, 10minutes)","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"11","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We are now ready to animate using Makie. We use Makie's Observable to animate the data. To dive into how Observables work we refer to Makie.jl's Documentation.","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"n = Observable(intro)\n\n wₙ = @lift interior(time_series.w[$n],  :, 1, :)\n Tₙ = @lift interior(time_series.T[$n],  :, 1, :)\n Sₙ = @lift interior(time_series.S[$n],  :, 1, :)\nνₑₙ = @lift interior(time_series.νₑ[$n], :, 1, :)\n\nfig = Figure(size = (1000, 500))\n\naxis_kwargs = (xlabel=\"x (m)\",\n               ylabel=\"z (m)\",\n               aspect = AxisAspect(grid.Lx/grid.Lz),\n               limits = ((0, grid.Lx), (-grid.Lz, 0)))\n\nax_w  = Axis(fig[2, 1]; title = \"Vertical velocity\", axis_kwargs...)\nax_T  = Axis(fig[2, 3]; title = \"Temperature\", axis_kwargs...)\nax_S  = Axis(fig[3, 1]; title = \"Salinity\", axis_kwargs...)\nax_νₑ = Axis(fig[3, 3]; title = \"Eddy viscocity\", axis_kwargs...)\n\ntitle = @lift @sprintf(\"t = %s\", prettytime(times[$n]))\n\nwlims = (-0.05, 0.05)\nTlims = (19.7, 19.99)\nSlims = (35, 35.005)\nνₑlims = (1e-6, 5e-3)\n\nhm_w = heatmap!(ax_w, xw, zw, wₙ; colormap = :balance, colorrange = wlims)\nColorbar(fig[2, 2], hm_w; label = \"m s⁻¹\")\n\nhm_T = heatmap!(ax_T, xT, zT, Tₙ; colormap = :thermal, colorrange = Tlims)\nColorbar(fig[2, 4], hm_T; label = \"ᵒC\")\n\nhm_S = heatmap!(ax_S, xT, zT, Sₙ; colormap = :haline, colorrange = Slims)\nColorbar(fig[3, 2], hm_S; label = \"g / kg\")\n\nhm_νₑ = heatmap!(ax_νₑ, xT, zT, νₑₙ; colormap = :thermal, colorrange = νₑlims)\nColorbar(fig[3, 4], hm_νₑ; label = \"m s⁻²\")\n\nfig[1, 1:4] = Label(fig, title, fontsize=24, tellwidth=false)\n\nfig","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"(Image: )","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"And now record a movie.","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"frames = intro:length(times)\n\n@info \"Making a motion picture of ocean wind mixing and convection...\"\n\nrecord(fig, filename * \".mp4\", frames, framerate=8) do i\n    n[] = i\nend","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"[ Info: Making a motion picture of ocean wind mixing and convection...\n","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"(Image: )","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"","category":"page"},{"location":"literated/ocean_wind_mixing_and_convection/","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"This page was generated using Literate.jl.","category":"page"},{"location":"simulation_tips/#simulation_tips","page":"Simulation tips","title":"Simulation tips","text":"","category":"section"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Oceananigans attempts to optimize computations as much as possible \"behind the scenes\". Yet Oceananigans' flexibility places some responsibility on users to ensure high performance simulations, especially for complex setups with user-defined forcing functions, boundary condition functions, and diagnostics. Furthermore, in case of more complex GPU runs, some details could sometimes prevent your simulation from running altogether. While Julia knowledge is obviously desirable here, a user that is unfamiliar with Julia can get away with efficient simulations by learning a few rules of thumb. It is nonetheless recommended that users go through Julia's performance tips, which contains more in-depth explanations of some of the aspects discussed here.","category":"page"},{"location":"simulation_tips/#General-(CPU/GPU)-simulation-tips","page":"Simulation tips","title":"General (CPU/GPU) simulation tips","text":"","category":"section"},{"location":"simulation_tips/#Avoid-global-variables-whenever-possible","page":"Simulation tips","title":"Avoid global variables whenever possible","text":"","category":"section"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"In general using a global variable (which can be loosely defined as a variable defined in the main script) inside functions slows down the code. One way to circumvent this is to always use local variables or pass them as arguments to functions. This helps the compiler optimize the code.","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Another way around this is to define global variables as constants whenever possible. One thing to keep in mind when doing this is that when a const is defined, its value can't be changed until you restart the Julia session. So this latter approach is good for production-ready code, but may be undesirable in the early stages of development while you still have to change the parameters of the simulation for exploration.","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"It is especially important to avoid global variables in functions that are meant to be executed in GPU kernels (such as functions defining boundary conditions and forcings). Otherwise the Julia GPU compiler can fail with obscure errors. This is explained in more detail in the GPU simulation tips section below.","category":"page"},{"location":"simulation_tips/#Consider-inlining-small-functions","page":"Simulation tips","title":"Consider inlining small functions","text":"","category":"section"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Inlining is when the compiler replaces a function call with the body of the function that is being called before compiling. The advantage of inlining (which in julia can be done with the @inline macro) is that gets rid of the time spent calling the function. The Julia compiler automatically makes some calls as to what functions it should or shouldn't inline, but you can force a function to be inlined by including the macro @inline before its definition. This is more suited for small functions that are called often. Here's an example of an implementation of the Heaviside function that forces it to be inlined:","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"@inline heaviside(x) = ifelse(x < 0, zero(x), one(x))","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"In practice it's hard to say whether inlining a function will bring runtime benefits with certainty, since Julia and KernelAbstractions.jl (needed for GPU runs) already inline some functions automatically. However, it is generally a good idea to at least investigate this aspect in your code as the benefits can potentially be significant.","category":"page"},{"location":"simulation_tips/#GPU-simulation-tips","page":"Simulation tips","title":"GPU simulation tips","text":"","category":"section"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Running on GPUs can be very different from running on CPUs. Oceananigans makes most of the necessary changes in the background, so that for very simple simulations changing between CPUs and GPUs is just a matter of changing the architecture argument in the model from CPU() to GPU(). However, for more complex simulations some care needs to be taken on the part of the user. While knowledge of GPU computing (and Julia) is again desirable, an inexperienced user can also achieve high efficiency in GPU simulations by following a few simple principles.","category":"page"},{"location":"simulation_tips/#Global-variables-that-need-to-be-used-in-GPU-computations-need-to-be-defined-as-constants-or-passed-as-parameters","page":"Simulation tips","title":"Global variables that need to be used in GPU computations need to be defined as constants or passed as parameters","text":"","category":"section"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Any global variable that needs to be accessed by the GPU needs to be a constant or the simulation will crash. This includes any variables that are referenced as global variables in functions used for forcing of boundary conditions. For example,","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"T₀ = 20 # ᵒC\nsurface_temperature(x, y, t) = T₀ * sin(2π / 86400 * t)\nT_bcs = FieldBoundaryConditions(bottom = GradientBoundaryCondition(surface_temperature))","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"will throw an error if run on the GPU (and will run more slowly than it should on the CPU). Replacing the first line above with","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"const T₀ = 20 # ᵒC","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"fixes the issue by indicating to the compiler that T₀ will not change.","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Note that the literal 2π / 86400 is not an issue – it's only the variable T₀ that must be declared const.","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Alternatively, we can pass the variable as a parameter to GradientBoundaryCondition. To do that we need to pass a named tuple as parameter keyword argument:","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"T₀ = 20 # ᵒC\nsurface_temperature(x, y, t, p) = p.T₀ * sin(2π / 86400 * t)\nT_bcs = FieldBoundaryConditions(bottom = GradientBoundaryCondition(surface_temperature, parameters=(; T₀)))","category":"page"},{"location":"simulation_tips/#Complex-diagnostics-using-computed-Fields-may-not-work-on-GPUs","page":"Simulation tips","title":"Complex diagnostics using computed Fields may not work on GPUs","text":"","category":"section"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Fields are the most convenient way to calculate diagnostics for your simulation. They will always work on CPUs, but when their complexity is high (in terms of number of abstract operations) the compiler can't translate them into GPU code and they fail for GPU runs. (This limitation is summarized  in this Github issue and contributions are welcome.) For example, in the example below, calculating u² works in both CPUs and GPUs, but calculating  ε will not compile on GPUs when we call the command compute!:","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"using Oceananigans\ngrid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1))\nmodel = NonhydrostaticModel(grid=grid, closure=ScalarDiffusivity(ν=1e-6))\nu, v, w = model.velocities\nν = model.closure.ν\nu² = Field(u^2)\nε = Field(ν*(∂x(u)^2 + ∂x(v)^2 + ∂x(w)^2 + ∂y(u)^2 + ∂y(v)^2 + ∂y(w)^2 + ∂z(u)^2 + ∂z(v)^2 + ∂z(w)^2))\ncompute!(u²)\ncompute!(ε)","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"There are a few ways to work around this issue. One is to compute ε in steps by nesting computed Fields,","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"ddx² = Field(∂x(u)^2 + ∂x(v)^2 + ∂x(w)^2)\nddy² = Field(∂y(u)^2 + ∂y(v)^2 + ∂y(w)^2)\nddz² = Field(∂z(u)^2 + ∂z(v)^2 + ∂z(w)^2)\nε = Field(ν * (ddx² + ddy² + ddz²))\ncompute!(ε)","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"This method increases the computational cost since it requires computing and storing 3 intermediate terms. ε may also be calculated via KernelFunctionOperationss, which requires explicitly building a \"kernel function\" from low-level Oceananigans operators.","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"using Oceananigans.Operators\nusing Oceananigans.AbstractOperations: KernelFunctionOperation\n\n@inline fψ_plus_gφ²(i, j, k, grid, f, ψ, g, φ) = (f(i, j, k, grid, ψ) + g(i, j, k, grid, φ))^2\n\nfunction isotropic_viscous_dissipation_rate_ccc(i, j, k, grid, u, v, w, ν)\n    Σˣˣ² = ∂xᶜᶜᶜ(i, j, k, grid, u)^2\n    Σʸʸ² = ∂yᶜᶜᶜ(i, j, k, grid, v)^2\n    Σᶻᶻ² = ∂zᶜᶜᶜ(i, j, k, grid, w)^2\n\n    Σˣʸ² = ℑxyᶜᶜᵃ(i, j, k, grid, fψ_plus_gφ², ∂yᶠᶠᶜ, u, ∂xᶠᶠᶜ, v) / 4\n    Σˣᶻ² = ℑxzᶜᵃᶜ(i, j, k, grid, fψ_plus_gφ², ∂zᶠᶜᶠ, u, ∂xᶠᶜᶠ, w) / 4\n    Σʸᶻ² = ℑyzᵃᶜᶜ(i, j, k, grid, fψ_plus_gφ², ∂zᶜᶠᶠ, v, ∂yᶜᶠᶠ, w) / 4\n\n    return 2ν * (Σˣˣ² + Σʸʸ² + Σᶻᶻ² + 2 * (Σˣʸ² + Σˣᶻ² + Σʸᶻ²))\nend\n\nε_op = KernelFunctionOperation{Center, Center, Center}(isotropic_viscous_dissipation_rate_ccc,\n                                                       grid, u, v, w, ν)\n\nε = Field(ε_op)\n\ncompute!(ε)","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Writing kernel functions like isotropic_viscous_dissipation_rate_ccc requires understanding the C-grid, but incurs only one iteration over the domain.","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"KernelFunctionOperations for some diagnostics common to large eddy simulation are defined in Oceanostics.jl,","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"using Oceanostics: IsotropicPseudoViscousDissipationRate\nε = IsotropicViscousDissipationRate(model, u, v, w, ν)\ncompute!(ε)","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Start an issue on Github if more help is needed.","category":"page"},{"location":"simulation_tips/#Try-to-decrease-the-memory-use-of-your-runs","page":"Simulation tips","title":"Try to decrease the memory-use of your runs","text":"","category":"section"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"GPU runs are sometimes memory-limited. A state-of-the-art Tesla V100 GPU has 32GB of memory – enough memory for simulations with about 100 million points, or grids a bit smaller than 512 × 512 × 512. (The maximum grid size depends on some user-specified factors, like the number of passive tracers or computed diagnostics.) For large simulations on the GPU, careful management of memory allocation may be required:","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Use the nvidia-smi command line utility to monitor the memory usage of the GPU. It should tell you how much memory there is on your GPU and how much of it you're using and you can run it from Julia via\njulia> ;\nshell> run(`nvidia-smi`)\nTry to use higher-order advection schemes. In general when you use a higher-order scheme you need fewer grid points to achieve the same accuracy that you would with a lower-order one. Refer to the documentation for available advection schemes.\nManually define scratch space to be reused in diagnostics. By default, every time a user-defined diagnostic is calculated the compiler reserves a new chunk of memory for that calculation, usually called scratch space. In general, the more diagnostics, the more scratch space needed and the bigger the memory requirements. However, if you explicitly create a scratch space and pass that same scratch space for as many diagnostics as you can, you minimize the memory requirements of your calculations by reusing the same chunk of memory. Have a look at an example for how to create scratch space and how it can be used in calculations.","category":"page"},{"location":"simulation_tips/#Arrays-in-GPUs-are-usually-different-from-arrays-in-CPUs","page":"Simulation tips","title":"Arrays in GPUs are usually different from arrays in CPUs","text":"","category":"section"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Oceananigans.jl uses CUDA.CuArray to store  data for GPU computations. One limitation of CuArrays compared to the Arrays used for  CPU computations is that CuArray elements in general cannot be accessed outside kernels launched through CUDA.jl or KernelAbstractions.jl. (You can learn more about GPU kernels  here and  here.) Doing so requires individual elements to be copied from or to the GPU for processing, which is very slow and can result in huge slowdowns. To avoid such unintentional slowdowns, Oceananigans.jl disables CUDA scalar indexing by default. See the scalar indexing section of the CUDA.jl documentation for more information on scalar indexing.","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"For example, if can be difficult to just view a CuArray since Julia needs to access  its elements to do that. Consider the example below:","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"julia> using Oceananigans, Adapt\n\njulia> grid = RectilinearGrid(GPU(); size=(1, 1, 1), extent=(1, 1, 1), halo=(1, 1, 1))\n1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 1×1×1 halo\n├── Periodic x ∈ [0.0, 1.0)  regularly spaced with Δx=1.0\n├── Periodic y ∈ [0.0, 1.0)  regularly spaced with Δy=1.0\n└── Bounded  z ∈ [-1.0, 0.0] regularly spaced with Δz=1.0\n\njulia> model = NonhydrostaticModel(; grid)\nNonhydrostaticModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\n├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 1×1×1 halo\n├── timestepper: RungeKutta3TimeStepper\n├── tracers: ()\n├── closure: Nothing\n├── buoyancy: Nothing\n└── coriolis: Nothing\n\njulia> typeof(model.velocities.u.data)\nOffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}\n\njulia> adapt(Array, model.velocities.u.data)\n3×3×3 OffsetArray(::Array{Float64, 3}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2×0:2×0:2:\n[:, :, 0] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n[:, :, 1] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n[:, :, 2] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Notice that to view the CuArray that stores values for u we first need to transform it into a regular Array using Adapt.adapt. If we naively try to view the CuArray without that step we get an error:","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"julia> model.velocities.u.data\n3×3×3 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2×0:2×0:2:\n[:, :, 0] =\nError showing value of type OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}:\nERROR: Scalar indexing is disallowed.","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"Here CUDA.jl throws an error because scalar getindex is not allowed. There are ways to overcome this limitation and allow scalar indexing (more about that  in the CUDA.jl documentation), but this option can be very slow on GPUs, so it is advised to only use this last method when using the REPL or  prototyping – never in production-ready scripts.","category":"page"},{"location":"simulation_tips/","page":"Simulation tips","title":"Simulation tips","text":"You might also need to keep these differences in mind when using arrays to define initial conditions, boundary conditions or forcing functions on a GPU. To learn more about working with CuArrays, see the array programming section of the CUDA.jl documentation.","category":"page"},{"location":"physics/surface_gravity_waves/#Surface-gravity-waves-and-the-Craik-Leibovich-approximation","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"","category":"section"},{"location":"physics/surface_gravity_waves/","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"Users can model the effects of surface waves by specifying spatial and temporal gradients of the Stokes drift velocity field. At the moment, only uniform unidirectional Stokes drift fields are supported, in which case","category":"page"},{"location":"physics/surface_gravity_waves/","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"    boldsymbolu^S = u^S(z t) hatboldsymbolx + v^S(z t) hatboldsymboly  ","category":"page"},{"location":"physics/surface_gravity_waves/","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"Surface waves are modeled in the NonhydrostaticModel by the Craik-Leibovich approximation, which governs interior motions under a surface gravity wave field that have been time- or phase-averaged over the rapid oscillations of the surface waves. The oscillatory vertical and horizontal motions associated with surface waves themselves, therefore, are not present in the resolved velocity field boldsymbolv, and only the  steady, averaged effect of surface waves that manifests over several or more wave oscillations  are modeled.","category":"page"},{"location":"physics/surface_gravity_waves/","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"When surface waves are included, the resolved velocity field boldsymbolv is the  Lagrangian-mean velocity field. The Lagrangian-mean velocity field at a particular location  (x y z) is average velocity of a fluid particle whose average position is (x y z)  at time t. The average position of a fluid particle boldsymbolxi(t) = (xi eta zeta)  is thus governed by","category":"page"},{"location":"physics/surface_gravity_waves/","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"    partial_t boldsymbolxi + boldsymbolv(boldsymbolxi t) boldsymbolcdot boldsymbolnabla boldsymbolxi = boldsymbolv(boldsymbolxi t)  ","category":"page"},{"location":"physics/surface_gravity_waves/","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"which is the same relationship that holds when surface waves are not present and boldsymbolv  ceases to be an averaged velocity field. The simplicity of the governing equations for Lagrangian-mean  momentum is the main reason we use a Lagrangian-mean formulation in Oceananigans.jl, rather  than an Eulerian-mean formulation: for example, the tracer conservation equation is unchanged  by the inclusion of surface wave effects. Moreover, because the effect of surface waves manifests  either as a bulk forcing of Lagrangian-mean momentum or as a modification to the effective background  rotation rate of the interior fluid similar to any bulk forcing or Coriolis force, we do not  explicitly include the effects of surface waves in turbulence closures that model the effects  of subgrid turbulence. More specifically, the effect of steady surface waves does not effect  the conservation of Lagrangian-mean turbulent kinetic energy.","category":"page"},{"location":"physics/surface_gravity_waves/","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"The Lagrangian-mean velocity field boldsymbolv contrasts with the Eulerian-mean velocity  field boldsymbolv^E, which is the fluid velocity averaged at the fixed Eulerian position  (x y z). The surface wave Stokes drift field supplied by the user is, in fact, defined by the difference between the Eulerian- and Lagrangian-mean velocity:","category":"page"},{"location":"physics/surface_gravity_waves/","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"    boldsymbolu^S equiv boldsymbolv - boldsymbolv^E  ","category":"page"},{"location":"physics/surface_gravity_waves/","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"The Stokes drift velocity field is typically prescribed for idealized scenarios, or determined from a wave model for the evolution of surface waves under time-dependent atmospheric winds in more realistic cases.","category":"page"},{"location":"#Oceananigans.jl","page":"Home","title":"Oceananigans.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"🌊 Fast and friendly fluid dynamics on CPUs and GPUs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Oceananigans is a fast, friendly, flexible software package for finite volume simulations of the nonhydrostatic and hydrostatic Boussinesq equations on CPUs and GPUs. It runs on GPUs (wow, fast!), though we believe Oceananigans makes the biggest waves with its ultra-flexible user interface that makes simple simulations easy, and complex, creative simulations possible.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Oceananigans is written in Julia by the Climate Modeling Alliance and heroic external collaborators.","category":"page"},{"location":"#Quick-install","page":"Home","title":"Quick install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Oceananigans is a registered Julia package. So to install it,","category":"page"},{"location":"","page":"Home","title":"Home","text":"Download Julia.\nLaunch Julia and type","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\n\njulia> Pkg.add(\"Oceananigans\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"compat: Julia 1.9 is required\nOceananigans requires Julia 1.9 or later.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you're new to Julia and its wonderful Pkg manager, the Oceananigans wiki provides more detailed installation instructions.","category":"page"},{"location":"#The-Oceananigans-\"knowledge-base\"","page":"Home","title":"The Oceananigans \"knowledge base\"","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"It's deep and includes:","category":"page"},{"location":"","page":"Home","title":"Home","text":"This documentation, which provides\nexample Oceananigans scripts,\ntutorials that describe key Oceananigans objects and functions,\nexplanations of Oceananigans finite-volume-based numerical methods,\ndetails of the dynamical equations solved by Oceananigans models, and\na library documenting all user-facing Oceananigans objects and functions.\nDiscussions on the Oceananigans github, covering topics like\n\"Computational science\", or how to science and set up numerical simulations in Oceananigans, and\n\"Experimental features\", which covers new and sparsely-documented features for those who like to live dangerously.\nIf you've got a question or something to talk about, don't hesitate to start a new discussion!\nThe Oceananigans wiki, which contains practical tips for getting started with Julia, accessing and using GPUs, and productive workflows when using Oceananigans.\nIssues and pull requests also contain lots of information about problems we've found, solutions we're trying to implement, and dreams we're dreaming to make tomorrow better 🌈.","category":"page"},{"location":"#Getting-in-touch","page":"Home","title":"Getting in touch","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Whether you need help getting started with Oceananigans, found a bug, want Oceananigans to be more awesome, or just want to chat about computational oceanography, you've got a few options for getting in touch:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Start a discussion. This is great for general questions about numerics, science, experimental or under-documented features, and for getting help setting up a neat new numerical experiment.\nOpen an issue. Issues are best if you think the Oceananigans source code needs attention: a bug, a sign error (😱), an important missing feature, or a typo in this documentation 👀.\nSign up for the Julia Slack and join the #oceananigans channel because we love to chat.","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use Oceananigans as part of your research, teaching, or other activities, we would be grateful if you could cite our work and mention Oceananigans by name.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{OceananigansJOSS,\n  doi = {10.21105/joss.02018},\n  url = {https://doi.org/10.21105/joss.02018},\n  year = {2020},\n  publisher = {The Open Journal},\n  volume = {5},\n  number = {53},\n  pages = {2018},\n  author = {Ali Ramadhan and Gregory LeClaire Wagner and Chris Hill and Jean-Michel Campin and Valentin Churavy and Tim Besard and Andre Souza and Alan Edelman and Raffaele Ferrari and John Marshall},\n  title = {Oceananigans.jl: Fast and friendly geophysical fluid dynamics on GPUs},\n  journal = {Journal of Open Source Software}\n}","category":"page"},{"location":"#Papers-and-preprints-using-Oceananigans","page":"Home","title":"Papers and preprints using Oceananigans","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you have work using Oceananigans that you would like to have listed here, please open a pull request to add it or let us know!","category":"page"},{"location":"","page":"Home","title":"Home","text":"Bisits, J. I., Zika, J. D., and Evans, D. G. (2024) Does cabbeling shape the thermohaline structure of high-latitude oceans? Journal of Physical Oceanography, in press. DOI: 10.1175/JPO-D-24-0061.1\nStrong-Wright J. and Taylor, J. R. (2024) A model of tidal flow and tracer release in a giant kelp forest, Flow, 4, E21. DOI: 10.1017/flo.2024.13\nChor, T. and Wenegrat, J. (2024). The turbulent dynamics of anticyclonic submesoscale headland wakes, Earth arXiv, DOI: 10.31223/X5570C\nWagner, G. L., Hillier, A., Constantinou, N. C., Silvestri, S., Souza, A., Burns, K., Hill, C., Campin, J.-M., Marshall, J., and Ferrari, R. (2024). Formulation and calibration of CATKE, a one-equation parameterization for microscale ocean mixing, arXiv, arXiv:2306.13204. DOI: 10.48550/arXiv.2306.13204\nAllred, T., Li, X., Wiersdorf, A., Greenman, B., and Gopalakrishnan, G. (2024). FlowFPX: Nimble tools for debugging floating-point exceptions, arXiv, arXiv:2403.15632. DOI: 10.48550/arXiv.2403.15632\nSilvestri, S., Wagner, G. L., Constantinou, N. C., Hill, C., Campin, J.-M., Souza, A., Bishnu, S., Churavy, V., Marshall, J., and Ferrari, R. (2024) A GPU-based ocean dynamical core for routine mesoscale-resolving climate simulations, ESS Open Archive. DOI: 10.22541/essoar.171708158.82342448/v1\nSilvestri, S., Wagner, G. L., Campin, J.-M., Constantinou, N. C., Hill, C., Souza, A., and Ferrari, R. (2024). A new WENO-based momentum advection scheme for simulations of ocean mesoscale turbulence, ESS Open Archive. DOI: 10.22541/essoar.170110657.76489860/v2\nWhitley V. and Wenegrat, J. O. (2024) Breaking internal waves on sloping topography: connecting parcel displacements to overturn size, interior-boundary exchanges, and mixing, Earth Arxiv. DOI: 10.31223/X5PM5Q\nChen S., Strong-Wright J., and Taylor, J. R. (2024) Modeling carbon dioxide removal via sinking of particulate organic carbon from macroalgae cultivation, Frontiers in Marine Science, 11, 1359614. DOI: 10.3389/fmars.2024.1359614\nGupta, M., Gürcan, E., and Thompson, A. F. (2024). Eddy-induced dispersion of sea ice floes at the marginal ice zone, Geophysical Research Letters, 51, e2023GL105656. DOI: 10.1029/2023GL105656\nWagner, G. L., Pizzo, N. E., Lenain, L., and Veron, F. (2023) Transition to turbulence in wind-drift layers, Journal of Fluid Mechanics, 976, A8. DOI: 10.1017/jfm.2023.920\nJiménez-Urias, M. A. and Haine T. W. N. (2023) On the non-self-adjoint and multiscale character of passive scalar mixing under laminar advection, Journal of Fluid Mechanics, 973, A44. DOI: 10.1017/jfm.2023.748\nStrong-Wright, J, Chen, S., Constantinou, N. C., Silvestri, S., Wagner, G. L., and Taylor, J. R. (2023). OceanBioME.jl: A flexible environment for modelling the coupled interactions between ocean biogeochemistry and physics, Journal of Open Source Software, 90(8), 5669. DOI: 10.21105/joss.05669\nRamadhan, A., Marshall, J. C., Souza, A. N., Lee, X. K., Piterbarg, U., Hillier, A., Wagner, G. L., Rackauckas, C., Hill, C., Campin, J.-M., and Ferrari, R. (2022). Capturing missing physics in climate model parameterizations using neural differential equations, ESS Open Archive. DOI: 10.1002/essoar.10512533.1\nGupta, M. and Thompson, A. F. (2022). Regimes of sea-ice floe melt: Ice-ocean coupling at the submesoscales, Journal of Geophysical Research: Oceans, 127, e2022JC018894. DOI: 10.1029/2022JC018894\nSimoes-Sousa, I. T., Tandon, A., Pereira, F., Lazaneo, C. Z., and Mahadevan, A. (2022). Mixed layer eddies supply nutrients to enhance the spring phytoplankton bloom, Frontiers in Marine Sciences, 9, 825027. DOI: 10.3389/fmars.2022.825027\nChor, T., Wenegrat, J. O., and Taylor, J. (2022). Insights into the mixing efficiency of submesoscale Centrifugal-Symmetric instabilities., Journal of Physical Oceanography, 52(10), 2273-2287. DOI: 10.1175/JPO-D-21-0259.1\nBire, S., Kang, W., Ramadhan, A., Campin, J.-M., and Marshall, J. (2022). Exploring ocean circulation on icy moons heated from below., Journal of Geophysical Research: Planets, 127, e2021JE007025. DOI: 10.1029/2021JE007025\nRackauckas, C., Ma, Y., Martensen, J., Warner, C., Zubov, K., Supekar, R., Skinner, D., Ramadhan, A., and Edelman, A. (2021) Universal differential equations for scientific machine learning, arXiv, arXiv.2001.04385. DOI: 10.48550/arXiv.2001.04385\nCoakley, S., Miles, T. N., Glenn, S., and Lim, H. S. (2021). Observation-Large eddy simulation comparison of ocean mixing under Typhoon Soulik (2018), OCEANS 2021: San Diego – Porto, 2021, pp. 1-7. DOI: 10.23919/OCEANS44145.2021.9705670\nArnscheidt, C. W., Marshall, J., Dutrieux, P., Rye, C. D., and Ramadhan, A. (2021). On the settling depth of meltwater escaping from beneath Antarctic ice shelves, Journal of Physical Oceanography, 51(7), 2257–2270. DOI: 10.1175/JPO-D-20-0178.1\nWagner, G. L., Chini, G. P., Ramadhan, A., Gallet, B., and Ferrari, R. (2021). Near-inertial waves and turbulence driven by the growth of swell, Journal of Physical Oceanography, 51(5), 1337-1351. DOI: 10.1175/JPO-D-20-0178.1\nBuffett, B. A. (2021). Conditions for turbulent Ekman layers in precessionally driven flow, Geophysical Journal International, 226(1), 56–65. DOI: 10.1093/gji/ggab088\nBhamidipati, N., Souza, A.N., and Flierl, G.R. (2020). Turbulent mixing of a passive scalar in the ocean mixed layer, Ocean Modelling, 149, 101615. DOI: 10.1016/j.ocemod.2020.101615\nSouza, A. N., Wagner, G. L., Ramadhan, A., Allen, B., Churavy, V., Schloss, J., Campin, J. M., Hill, C., Edelman, A., Marshall, J., Flierl, G., and Ferrari, R. (2020). Uncertainty quantification of ocean parameterizations: Application to the K‐Profile‐Parameterization for penetrative convection, Journal of Advances in Modeling Earth Systems, 12, e2020MS002108. DOI: 10.1029/2020MS002108","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Abkar, M.; Bae, H. J. and Moin, P. (2016). Minimum-dissipation scalar transport model for large-eddy simulation of turbulent flows. Physical Review Fluids 1.\n\n\n\nAbkar, M. and Moin, P. (2017). Large-eddy simulation of thermally stratified atmospheric boundary-layer flow using a minimum dissipation model. Boundary-Layer Meteorology 165, 405–419.\n\n\n\nArakawa, A. and Lamb, V. R. (1977). Computational design of the basic dynamical processes of the UCLA General Circulation Model. In: Methods in Computational Physics: Advances in Research and Applications, Vol. 17 (Elsevier); pp. 173–265.\n\n\n\nAscher, U.; Ruuth, S. and Wetton, B. (1995). Implicit-explicit methods for time-dependent partial differential equations. SIAM Journal on Numerical Analysis 32, 797–823.\n\n\n\nBoussinesq, J. (1877). Essai sur la théorie des eaux courantes. Mémoires présentés par divers savants à l'Académie des sciences de l'Institut national de France (Impr. Nationale).\n\n\n\nBrown, D. L.; Cortez, R. and Minion, M. L. (2001). Accurate projection methods for the incompressible Navier–Stokes equations. Journal of Computational Physics 168, 464–499.\n\n\n\nBuzbee, B.; Golub, G. and Nielson, C. (1970). On direct methods for solving Poisson’s equations. SIAM Journal on Numerical Analysis 7, 627–656.\n\n\n\nChou, P. Y. (1945). On velocity correlations and the solutions of the equations of turbulent fluctuation. Quarterly of Applied Mathematics 3, 38–54.\n\n\n\nCorrsin, S. (1961). Turbulent flow. American Scientist 49, 300–325.\n\n\n\nDeardorff, J. W. (1970). A numerical study of three-dimensional turbulent channel flow at large Reynolds numbers. Journal of Fluid Mechanics 41, 453–480.\n\n\n\nDeardorff, J. W. (1974). Three-dimensional numerical study of the height and mean structure of a heated planetary boundary layer. Boundary-Layer Meteorology 7, 81–106.\n\n\n\nDellar, P. J. (2011). Variations on a beta-plane: derivation of non-traditional beta-plane equations from Hamilton's principle on a sphere. Journal of Fluid Mechanics 674, 174.\n\n\n\nFox-Kemper, B. and Menemenlis, D. (2008). Can large eddy simulation techniques improve mesoscale rich ocean models? In: Ocean Modeling in an Eddying Regime (American Geophysical Union (AGU)); pp. 319–337.\n\n\n\nFrigo, M. and Johnson, S. (1998). FFTW: an adaptive software architecture for the FFT. In: Proceedings of the 1998 IEEE International Conference on Acoustics, Speech and Signal Processing, ICASSP '98 (Cat. No.98CH36181), Vol. 3 (IEEE, Seattle, WA, USA); pp. 1381–1384.\n\n\n\nFrigo, M. and Johnson, S. (2005). The design and implementation of FFTW3. Proceedings of the IEEE 93, 216–231.\n\n\n\nHarlow, F. H. and Welch, J. E. (1965). Numerical calculation of time-dependent viscous incompressible flow of fluid with free surface. Physics of Fluids 8, 2182–89.\n\n\n\nHockney, R. W. (1965). A fast direct solution of Poisson's equation using Fourier analysis. Journal of the ACM 12, 95–113.\n\n\n\nHockney, R. W. (1969). The potential calculation and some applications. In: Methods of Computational Physics, Vol. 9, edited by Adler, B.; Fernback, S. and Rotenberg, M. (Academic Press, New York and London); pp. 136–211.\n\n\n\nKolmogorov, A. (1941). The local structure of turbulence in incompressible viscous fluid for very large Reynolds' numbers. C. R. Akademiia U.R.S.S. (Doklady) 30, 301–305.\n\n\n\nKundu, P. K.; Cohen, I. M. and Dowling, D. R. (2015). Fluid mechanics. 6 Edition (Academic Press).\n\n\n\nLe, H. and Moin, P. (1991). An improvement of fractional step methods for the incompressible Navier–Stokes equations. Journal of Computational Physics 92, 369–379.\n\n\n\nLeith, C. E. (1968). Diffusion approximation for two-dimensional turbulence. Physics of Fluids 11, 671–672.\n\n\n\nLeonard, A. (1975). Energy cascade in large-eddy simulations of turbulent fluid flows. In: Advances in Geophysics, Vol. 18 (Elsevier); pp. 237–248.\n\n\n\nLilly, D. K. (1962). On the numerical simulation of buoyant convection. Tellus 14, 148–172.\n\n\n\nLilly, D. K. (1966). The representation of small-scale turbulence in numerical simulation experiments. NCAR Manuscript No. 281 0.\n\n\n\nMakhoul, J. (1980). A fast cosine transform in one and two dimensions. IEEE Transactions on Acoustics, Speech, and Signal Processing 28, 27–34.\n\n\n\nMarshall, J.; Adcroft, A.; Hill, C.; Perelman, L. and Heisey, C. (1997). A finite-volume, incompressible Navier–Stokes model for studies of the ocean on parallel computers. Journal of Geophysical Research: Oceans 102, 5753–5766.\n\n\n\nOrszag, S. A.; Israeli, M. and Deville, M. O. (1986). Boundary conditions for incompressible flows. Journal of Scientific Computing 1, 75–111.\n\n\n\nPatankar, S. (1980). Numerical heat transfer and fluid flow (CRC Press).\n\n\n\nPope, S. B. (2000). Turbulent flows (Cambridge University Press).\n\n\n\nPress William, H.; Teukolsky Saul, A.; Vetterling William, T. and Flannery Brian, P. (1992). Numerical recipes: the art of scientific computing (Cambridge University Press, Cambridge, UK).\n\n\n\nReynolds, O. (1895). On the dynamical theory of incompressible viscous fluids and the determination of the criterion. Philosophical Transactions of the Royal Society of London A 186, 123–164.\n\n\n\nRoquet, F.; Madec, G.; McDougall, T. J. and Barker, P. M. (2015). Accurate polynomial expressions for the density and specific volume of seawater using the TEOS-10 standard. Ocean Modeling 90, 29–43.\n\n\n\nRoquet, F.; Madec, G.; Brodeau, L. and Nycander, J. (2015). Defining a simplified yet “realistic” equation of state for seawater. Journal of Physical Oceanography 45, 2564–2579.\n\n\n\nRozema, W.; Bae, H. J.; Moin, P. and Verstappen, R. (2015). Minimum-dissipation models for large-eddy simulation. Physics of Fluids 27, 085107.\n\n\n\nSagaut, P. and Meneveau, C. (2006). Large eddy simulation for incompressible flows: An introduction. Scientific Computation (Springer).\n\n\n\nSani, R. L.; Gresho, P. M.; Lee, R. L. and Griffiths, D. F. (1981). The cause and cure (?) of the spurious pressures generated by certain FEM solutions of the incompressible Navier–Stokes equations: Part 1. International Journal for Numerical Methods in Fluids 1, 17–43.\n\n\n\nSchumann, U. and Sweet, R. A. (1988). Fast Fourier transforms for direct solution of Poisson's equation with staggered boundary conditions. Journal of Computational Physics 75, 123–137.\n\n\n\nShchepetkin, A. F. and McWilliams, J. C. (2005). The regional oceanic modeling system (ROMS): a split-explicit, free-surface, topography-following-coordinate oceanic model. Ocean modelling 9, 347–404.\n\n\n\nSmagorinsky, J. (1963). General circulation experiments with the primitive equations I. The basic experiment. Monthly Weather Review 91, 99–164.\n\n\n\nSmagorinsky, J. (1958). On the numerical integration of the primitive equations of motion for baroclinic flow in a closed region. Monthly Weather Review 86, 457–466.\n\n\n\nSmagorinsky, J. (1963). General circulation experiments with the primitive equations: I. The basic experiment. Monthly weather review 91, 99–164.\n\n\n\nSwarztrauber, P. N. (1977). The methods of cyclic reduction, Fourier analysis and the FACR algorithm for the discrete solution of Poisson’s equation on a rectangle. SIAM Review 19, 490–501.\n\n\n\nTemperton, C. (1979). Direct methods for the solution of the discrete Poisson equation: Some comparisons. Journal of Computational Physics 31, 1–20.\n\n\n\nTemperton, C. (1980). On the FACR(ell) algorithm for the discrete Poisson equation. Journal of Computational Physics 34, 314–329.\n\n\n\nVerstappen, R. (2018). How much eddy dissipation is needed to counterbalance the nonlinear production of small, unresolved scales in a large-eddy simulation of turbulence? Computers & Fluids 176, 276–284.\n\n\n\nVreugdenhil, C. A. and Taylor, J. R. (2018). Large-eddy simulations of stratified plane Couette flow using the anisotropic minimum-dissipation model. Physics of Fluids 30, 085104.\n\n\n\n","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"EditURL = \"../../../examples/internal_tide.jl\"","category":"page"},{"location":"literated/internal_tide/#Internal-tide-by-a-seamount","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"","category":"section"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"In this example, we show how internal tide is generated from a barotropic tidal flow sloshing back and forth over a sea mount.","category":"page"},{"location":"literated/internal_tide/#Install-dependencies","page":"Internal tide by a seamount","title":"Install dependencies","text":"","category":"section"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"using Pkg\npkg\"add Oceananigans, CairoMakie\"","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"using Oceananigans\nusing Oceananigans.Units\nusing Oceananigans.ImmersedBoundaries: PartialCellBottom","category":"page"},{"location":"literated/internal_tide/#Grid","page":"Internal tide by a seamount","title":"Grid","text":"","category":"section"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"We create an ImmersedBoundaryGrid wrapped around an underlying two-dimensional RectilinearGrid that is periodic in x and bounded in z.","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"Nx, Nz = 250, 125\n\nH = 2kilometers\n\nunderlying_grid = RectilinearGrid(size = (Nx, Nz),\n                                  x = (-1000kilometers, 1000kilometers),\n                                  z = (-H, 0),\n                                  halo = (4, 4),\n                                  topology = (Periodic, Flat, Bounded))","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"250×1×125 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 4×0×4 halo\n├── Periodic x ∈ [-1.0e6, 1.0e6) regularly spaced with Δx=8000.0\n├── Flat y                       \n└── Bounded  z ∈ [-2000.0, 0.0]  regularly spaced with Δz=16.0","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"Now we can create the non-trivial bathymetry. We use GridFittedBottom that gets as input either (i) a two-dimensional function whose arguments are the grid's native horizontal coordinates and it returns the z of the bottom, or (ii) a two-dimensional array with the values of z at the bottom cell centers.","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"In this example we'd like to have a Gaussian hill at the center of the domain.","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"h(x) = -H + h_0 exp(-x^2  2σ^2)","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"h₀ = 250meters\nwidth = 20kilometers\nhill(x) = h₀ * exp(-x^2 / 2width^2)\nbottom(x) = - H + hill(x)\n\ngrid = ImmersedBoundaryGrid(underlying_grid, PartialCellBottom(bottom))","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"250×1×125 ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded} on CPU with 4×0×4 halo:\n├── immersed_boundary: PartialCellBottom(mean(zb)=-1993.93, min(zb)=-2000.0, max(zb)=-1754.95, ϵ=0.2)\n├── underlying_grid: 250×1×125 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 4×0×4 halo\n├── Periodic x ∈ [-1.0e6, 1.0e6) regularly spaced with Δx=8000.0\n├── Flat y                       \n└── Bounded  z ∈ [-2000.0, 0.0]  regularly spaced with Δz=16.0","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"Let's see how the domain with the bathymetry is.","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"x = xnodes(grid, Center())\nbottom_boundary = interior(grid.immersed_boundary.bottom_height, :, 1, 1)\ntop_boundary = 0 * x\n\nusing CairoMakie\n\nfig = Figure(size = (700, 200))\nax = Axis(fig[1, 1],\n          xlabel=\"x [km]\",\n          ylabel=\"z [m]\",\n          limits=((-grid.Lx/2e3, grid.Lx/2e3), (-grid.Lz, 0)))\n\nband!(ax, x/1e3, bottom_boundary, top_boundary, color = :mediumblue)\n\nfig","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"(Image: )","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"Now we want to add a barotropic tide forcing. For example, to add the lunar semi-diurnal M_2 tide we need to add forcing in the u-momentum equation of the form:","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"F_0 sin(omega_2 t)","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"where omega_2 = 2π  T_2, with T_2 = 12421 mathrmhours the period of the M_2 tide.","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"The excursion parameter is a nondimensional number that expresses the ratio of the flow movement due to the tide compared to the size of the width of the hill.","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"epsilon = fracU_mathrmtidal  omega_2sigma","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"We prescribe the excursion parameter which, in turn, implies a tidal velocity U_mathrmtidal which then allows us to determing the tidal forcing amplitude F_0. For the last step, we use Fourier decomposition on the inviscid, linearized momentum equations to determine the flow response for a given tidal forcing. Doing so we get that for the sinusoidal forcing above, the tidal velocity and tidal forcing amplitudes are related via:","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"U_mathrmtidal = fracomega_2omega_2^2 - f^2 F_0","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"Now we have the way to find the value of the tidal forcing amplitude that would correspond to a given excursion parameter. The Coriolis frequency is needed, so we start by constructing a Coriolis on an f-plane at the mid-latitudes.","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"coriolis = FPlane(latitude = -45)","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"FPlane{Float64}(f=-0.000103126)","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"Now we have everything we require to construct the tidal forcing given a value of the excursion parameter.","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"T₂ = 12.421hours\nω₂ = 2π / T₂ # radians/sec\n\nϵ = 0.1 # excursion parameter\n\nU_tidal = ϵ * ω₂ * width\n\ntidal_forcing_amplitude = U_tidal * (ω₂^2 - coriolis.f^2) / ω₂\n\n@inline tidal_forcing(x, z, t, p) = p.tidal_forcing_amplitude * sin(p.ω₂ * t)\n\nu_forcing = Forcing(tidal_forcing, parameters=(; tidal_forcing_amplitude, ω₂))","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"ContinuousForcing{@NamedTuple{tidal_forcing_amplitude::Float64, ω₂::Float64}}\n├── func: tidal_forcing (generic function with 1 method)\n├── parameters: (tidal_forcing_amplitude = 1.8218611749508242e-5, ω₂ = 0.00014051439111137024)\n└── field dependencies: ()","category":"page"},{"location":"literated/internal_tide/#Model","page":"Internal tide by a seamount","title":"Model","text":"","category":"section"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"We built a HydrostaticFreeSurfaceModel:","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"model = HydrostaticFreeSurfaceModel(; grid, coriolis,\n                                      buoyancy = BuoyancyTracer(),\n                                      tracers = :b,\n                                      momentum_advection = WENO(),\n                                      tracer_advection = WENO(),\n                                      forcing = (; u = u_forcing))","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"HydrostaticFreeSurfaceModel{CPU, ImmersedBoundaryGrid}(time = 0 seconds, iteration = 0)\n├── grid: 250×1×125 ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded} on CPU with 4×0×4 halo\n├── timestepper: QuasiAdamsBashforth2TimeStepper\n├── tracers: b\n├── closure: Nothing\n├── buoyancy: BuoyancyTracer with ĝ = NegativeZDirection()\n├── free surface: SplitExplicitFreeSurface with gravitational acceleration 9.80665 m s⁻²\n│   └── substepping: Barotropic time step equal to 39.986 seconds\n├── advection scheme: \n│   ├── momentum: FluxFormAdvection{3, Float64, WENO{3, Float64, Nothing, Nothing, Nothing, Nothing, WENO{2, Float64, Nothing, Nothing, Nothing, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{2, Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}}, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, WENO{3, Float64, Nothing, Nothing, Nothing, Nothing, WENO{2, Float64, Nothing, Nothing, Nothing, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{2, Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}}}\n│   └── b: FluxFormAdvection{3, Float64, WENO{3, Float64, Nothing, Nothing, Nothing, Nothing, WENO{2, Float64, Nothing, Nothing, Nothing, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{2, Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}}, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, WENO{3, Float64, Nothing, Nothing, Nothing, Nothing, WENO{2, Float64, Nothing, Nothing, Nothing, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{2, Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}}}\n└── coriolis: FPlane{Float64}","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"We initialize the model with the tidal flow and a linear stratification.","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"uᵢ(x, z) = U_tidal\n\nNᵢ² = 1e-4  # [s⁻²] initial buoyancy frequency / stratification\nbᵢ(x, z) = Nᵢ² * z\n\nset!(model, u=uᵢ, b=bᵢ)","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"Now let's build a Simulation.","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"Δt = 5minutes\nstop_time = 4days\n\nsimulation = Simulation(model; Δt, stop_time)","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"Simulation of HydrostaticFreeSurfaceModel{CPU, ImmersedBoundaryGrid}(time = 0 seconds, iteration = 0)\n├── Next time step: 5 minutes\n├── Elapsed wall time: 0 seconds\n├── Wall time per iteration: NaN days\n├── Stop time: 4 days\n├── Stop iteration : Inf\n├── Wall time limit: Inf\n├── Callbacks: OrderedDict with 4 entries:\n│   ├── stop_time_exceeded => Callback of stop_time_exceeded on IterationInterval(1)\n│   ├── stop_iteration_exceeded => Callback of stop_iteration_exceeded on IterationInterval(1)\n│   ├── wall_time_limit_exceeded => Callback of wall_time_limit_exceeded on IterationInterval(1)\n│   └── nan_checker => Callback of NaNChecker for u on IterationInterval(100)\n├── Output writers: OrderedDict with no entries\n└── Diagnostics: OrderedDict with no entries","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"We add a callback to print a message about how the simulation is going,","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"using Printf\n\nwall_clock = Ref(time_ns())\n\nfunction progress(sim)\n    elapsed = 1e-9 * (time_ns() - wall_clock[])\n\n    msg = @sprintf(\"iteration: %d, time: %s, wall time: %s, max|w|: %6.3e, m s⁻¹\\n\",\n                   iteration(sim), prettytime(sim), prettytime(elapsed),\n                   maximum(abs, sim.model.velocities.w))\n\n    wall_clock[] = time_ns()\n\n    @info msg\n\n    return nothing\nend\n\nadd_callback!(simulation, progress, name=:progress, IterationInterval(200))","category":"page"},{"location":"literated/internal_tide/#Diagnostics/Output","page":"Internal tide by a seamount","title":"Diagnostics/Output","text":"","category":"section"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"Add some diagnostics. Instead of u we save the deviation of u from its instantaneous domain average, u = u - (L_x H)^-1 int u  mathrmdx mathrmdz. We also save the stratification N^2 = partial_z b.","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"b = model.tracers.b\nu, v, w = model.velocities\n\nU = Field(Average(u))\n\nu′ = u - U\n\nN² = ∂z(b)\n\nfilename = \"internal_tide\"\nsave_fields_interval = 30minutes\n\nsimulation.output_writers[:fields] = JLD2OutputWriter(model, (; u, u′, w, b, N²);\n                                                      filename,\n                                                      schedule = TimeInterval(save_fields_interval),\n                                                      overwrite_existing = true)","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"JLD2OutputWriter scheduled on TimeInterval(30 minutes):\n├── filepath: ./internal_tide.jld2\n├── 5 outputs: (u, u′, w, b, N²)\n├── array type: Array{Float64}\n├── including: [:grid, :coriolis, :buoyancy, :closure]\n├── file_splitting: NoFileSplitting\n└── file size: 58.2 KiB","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"We are ready – let's run!","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"run!(simulation)","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"[ Info: Initializing simulation...\n[ Info: iteration: 0, time: 0 seconds, wall time: 3.238 minutes, max|w|: 1.980e-03, m s⁻¹\n[ Info:     ... simulation initialization complete (32.075 seconds)\n[ Info: Executing initial time step...\n[ Info:     ... initial time step complete (28.478 seconds).\n[ Info: iteration: 200, time: 16.667 hours, wall time: 46.862 seconds, max|w|: 4.720e-03, m s⁻¹\n[ Info: iteration: 400, time: 1.389 days, wall time: 8.135 seconds, max|w|: 4.180e-03, m s⁻¹\n[ Info: iteration: 600, time: 2.083 days, wall time: 8.424 seconds, max|w|: 1.783e-03, m s⁻¹\n[ Info: iteration: 800, time: 2.778 days, wall time: 8.593 seconds, max|w|: 3.876e-03, m s⁻¹\n[ Info: iteration: 1000, time: 3.472 days, wall time: 8.195 seconds, max|w|: 2.969e-03, m s⁻¹\n[ Info: Simulation is stopping after running for 1.806 minutes.\n[ Info: Simulation time 4 days equals or exceeds stop time 4 days.\n","category":"page"},{"location":"literated/internal_tide/#Load-output","page":"Internal tide by a seamount","title":"Load output","text":"","category":"section"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"First, we load the saved velocities and stratification output as FieldTimeSerieses.","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"saved_output_filename = filename * \".jld2\"\n\nu′_t = FieldTimeSeries(saved_output_filename, \"u′\")\n w_t = FieldTimeSeries(saved_output_filename, \"w\")\nN²_t = FieldTimeSeries(saved_output_filename, \"N²\")\n\numax = maximum(abs, u′_t[end])\nwmax = maximum(abs, w_t[end])\n\ntimes = u′_t.times","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"We retrieve each field's coordinates and convert from meters to kilometers.","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"xu,  _, zu  = nodes(u′_t[1])\nxw,  _, zw  = nodes(w_t[1])\nxN², _, zN² = nodes(N²_t[1])\n\nxu  = xu  ./ 1e3\nxw  = xw  ./ 1e3\nxN² = xN² ./ 1e3\nzu  = zu  ./ 1e3\nzw  = zw  ./ 1e3\nzN² = zN² ./ 1e3","category":"page"},{"location":"literated/internal_tide/#Visualize","page":"Internal tide by a seamount","title":"Visualize","text":"","category":"section"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"Now we can visualize our resutls! We use CairoMakie here. On a system with OpenGL using GLMakie is more convenient as figures will be displayed on the screen.","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"We use Makie's Observable to animate the data. To dive into how Observables work we refer to Makie.jl's Documentation.","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"using CairoMakie\n\nn = Observable(1)\n\ntitle = @lift @sprintf(\"t = %1.2f days = %1.2f T₂\",\n                       round(times[$n] / day, digits=2) , round(times[$n] / T₂, digits=2))\n\nu′n = @lift u′_t[$n]\n wn = @lift  w_t[$n]\nN²n = @lift N²_t[$n]\n\naxis_kwargs = (xlabel = \"x [km]\",\n               ylabel = \"z [km]\",\n               limits = ((-grid.Lx/2e3, grid.Lx/2e3), (-grid.Lz/1e3, 0)), # note conversion to kilometers\n               titlesize = 20)\n\nfig = Figure(size = (700, 900))\n\nfig[1, :] = Label(fig, title, fontsize=24, tellwidth=false)\n\nax_u = Axis(fig[2, 1]; title = \"u'-velocity\", axis_kwargs...)\nhm_u = heatmap!(ax_u, xu, zu, u′n; nan_color=:gray, colorrange=(-umax, umax), colormap=:balance)\nColorbar(fig[2, 2], hm_u, label = \"m s⁻¹\")\n\nax_w = Axis(fig[3, 1]; title = \"w-velocity\", axis_kwargs...)\nhm_w = heatmap!(ax_w, xw, zw, wn; nan_color=:gray, colorrange=(-wmax, wmax), colormap=:balance)\nColorbar(fig[3, 2], hm_w, label = \"m s⁻¹\")\n\nax_N² = Axis(fig[4, 1]; title = \"stratification N²\", axis_kwargs...)\nhm_N² = heatmap!(ax_N², xN², zN², N²n; nan_color=:gray, colorrange=(0.9Nᵢ², 1.1Nᵢ²), colormap=:magma)\nColorbar(fig[4, 2], hm_N², label = \"s⁻²\")\n\nfig","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"(Image: )","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"Finally, we can record a movie.","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"@info \"Making an animation from saved data...\"\n\nframes = 1:length(times)\n\nrecord(fig, filename * \".mp4\", frames, framerate=16) do i\n    @info string(\"Plotting frame \", i, \" of \", frames[end])\n    n[] = i\nend","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"[ Info: Making an animation from saved data...\n[ Info: Plotting frame 1 of 193\n[ Info: Plotting frame 2 of 193\n[ Info: Plotting frame 3 of 193\n[ Info: Plotting frame 4 of 193\n[ Info: Plotting frame 5 of 193\n[ Info: Plotting frame 6 of 193\n[ Info: Plotting frame 7 of 193\n[ Info: Plotting frame 8 of 193\n[ Info: Plotting frame 9 of 193\n[ Info: Plotting frame 10 of 193\n[ Info: Plotting frame 11 of 193\n[ Info: Plotting frame 12 of 193\n[ Info: Plotting frame 13 of 193\n[ Info: Plotting frame 14 of 193\n[ Info: Plotting frame 15 of 193\n[ Info: Plotting frame 16 of 193\n[ Info: Plotting frame 17 of 193\n[ Info: Plotting frame 18 of 193\n[ Info: Plotting frame 19 of 193\n[ Info: Plotting frame 20 of 193\n[ Info: Plotting frame 21 of 193\n[ Info: Plotting frame 22 of 193\n[ Info: Plotting frame 23 of 193\n[ Info: Plotting frame 24 of 193\n[ Info: Plotting frame 25 of 193\n[ Info: Plotting frame 26 of 193\n[ Info: Plotting frame 27 of 193\n[ Info: Plotting frame 28 of 193\n[ Info: Plotting frame 29 of 193\n[ Info: Plotting frame 30 of 193\n[ Info: Plotting frame 31 of 193\n[ Info: Plotting frame 32 of 193\n[ Info: Plotting frame 33 of 193\n[ Info: Plotting frame 34 of 193\n[ Info: Plotting frame 35 of 193\n[ Info: Plotting frame 36 of 193\n[ Info: Plotting frame 37 of 193\n[ Info: Plotting frame 38 of 193\n[ Info: Plotting frame 39 of 193\n[ Info: Plotting frame 40 of 193\n[ Info: Plotting frame 41 of 193\n[ Info: Plotting frame 42 of 193\n[ Info: Plotting frame 43 of 193\n[ Info: Plotting frame 44 of 193\n[ Info: Plotting frame 45 of 193\n[ Info: Plotting frame 46 of 193\n[ Info: Plotting frame 47 of 193\n[ Info: Plotting frame 48 of 193\n[ Info: Plotting frame 49 of 193\n[ Info: Plotting frame 50 of 193\n[ Info: Plotting frame 51 of 193\n[ Info: Plotting frame 52 of 193\n[ Info: Plotting frame 53 of 193\n[ Info: Plotting frame 54 of 193\n[ Info: Plotting frame 55 of 193\n[ Info: Plotting frame 56 of 193\n[ Info: Plotting frame 57 of 193\n[ Info: Plotting frame 58 of 193\n[ Info: Plotting frame 59 of 193\n[ Info: Plotting frame 60 of 193\n[ Info: Plotting frame 61 of 193\n[ Info: Plotting frame 62 of 193\n[ Info: Plotting frame 63 of 193\n[ Info: Plotting frame 64 of 193\n[ Info: Plotting frame 65 of 193\n[ Info: Plotting frame 66 of 193\n[ Info: Plotting frame 67 of 193\n[ Info: Plotting frame 68 of 193\n[ Info: Plotting frame 69 of 193\n[ Info: Plotting frame 70 of 193\n[ Info: Plotting frame 71 of 193\n[ Info: Plotting frame 72 of 193\n[ Info: Plotting frame 73 of 193\n[ Info: Plotting frame 74 of 193\n[ Info: Plotting frame 75 of 193\n[ Info: Plotting frame 76 of 193\n[ Info: Plotting frame 77 of 193\n[ Info: Plotting frame 78 of 193\n[ Info: Plotting frame 79 of 193\n[ Info: Plotting frame 80 of 193\n[ Info: Plotting frame 81 of 193\n[ Info: Plotting frame 82 of 193\n[ Info: Plotting frame 83 of 193\n[ Info: Plotting frame 84 of 193\n[ Info: Plotting frame 85 of 193\n[ Info: Plotting frame 86 of 193\n[ Info: Plotting frame 87 of 193\n[ Info: Plotting frame 88 of 193\n[ Info: Plotting frame 89 of 193\n[ Info: Plotting frame 90 of 193\n[ Info: Plotting frame 91 of 193\n[ Info: Plotting frame 92 of 193\n[ Info: Plotting frame 93 of 193\n[ Info: Plotting frame 94 of 193\n[ Info: Plotting frame 95 of 193\n[ Info: Plotting frame 96 of 193\n[ Info: Plotting frame 97 of 193\n[ Info: Plotting frame 98 of 193\n[ Info: Plotting frame 99 of 193\n[ Info: Plotting frame 100 of 193\n[ Info: Plotting frame 101 of 193\n[ Info: Plotting frame 102 of 193\n[ Info: Plotting frame 103 of 193\n[ Info: Plotting frame 104 of 193\n[ Info: Plotting frame 105 of 193\n[ Info: Plotting frame 106 of 193\n[ Info: Plotting frame 107 of 193\n[ Info: Plotting frame 108 of 193\n[ Info: Plotting frame 109 of 193\n[ Info: Plotting frame 110 of 193\n[ Info: Plotting frame 111 of 193\n[ Info: Plotting frame 112 of 193\n[ Info: Plotting frame 113 of 193\n[ Info: Plotting frame 114 of 193\n[ Info: Plotting frame 115 of 193\n[ Info: Plotting frame 116 of 193\n[ Info: Plotting frame 117 of 193\n[ Info: Plotting frame 118 of 193\n[ Info: Plotting frame 119 of 193\n[ Info: Plotting frame 120 of 193\n[ Info: Plotting frame 121 of 193\n[ Info: Plotting frame 122 of 193\n[ Info: Plotting frame 123 of 193\n[ Info: Plotting frame 124 of 193\n[ Info: Plotting frame 125 of 193\n[ Info: Plotting frame 126 of 193\n[ Info: Plotting frame 127 of 193\n[ Info: Plotting frame 128 of 193\n[ Info: Plotting frame 129 of 193\n[ Info: Plotting frame 130 of 193\n[ Info: Plotting frame 131 of 193\n[ Info: Plotting frame 132 of 193\n[ Info: Plotting frame 133 of 193\n[ Info: Plotting frame 134 of 193\n[ Info: Plotting frame 135 of 193\n[ Info: Plotting frame 136 of 193\n[ Info: Plotting frame 137 of 193\n[ Info: Plotting frame 138 of 193\n[ Info: Plotting frame 139 of 193\n[ Info: Plotting frame 140 of 193\n[ Info: Plotting frame 141 of 193\n[ Info: Plotting frame 142 of 193\n[ Info: Plotting frame 143 of 193\n[ Info: Plotting frame 144 of 193\n[ Info: Plotting frame 145 of 193\n[ Info: Plotting frame 146 of 193\n[ Info: Plotting frame 147 of 193\n[ Info: Plotting frame 148 of 193\n[ Info: Plotting frame 149 of 193\n[ Info: Plotting frame 150 of 193\n[ Info: Plotting frame 151 of 193\n[ Info: Plotting frame 152 of 193\n[ Info: Plotting frame 153 of 193\n[ Info: Plotting frame 154 of 193\n[ Info: Plotting frame 155 of 193\n[ Info: Plotting frame 156 of 193\n[ Info: Plotting frame 157 of 193\n[ Info: Plotting frame 158 of 193\n[ Info: Plotting frame 159 of 193\n[ Info: Plotting frame 160 of 193\n[ Info: Plotting frame 161 of 193\n[ Info: Plotting frame 162 of 193\n[ Info: Plotting frame 163 of 193\n[ Info: Plotting frame 164 of 193\n[ Info: Plotting frame 165 of 193\n[ Info: Plotting frame 166 of 193\n[ Info: Plotting frame 167 of 193\n[ Info: Plotting frame 168 of 193\n[ Info: Plotting frame 169 of 193\n[ Info: Plotting frame 170 of 193\n[ Info: Plotting frame 171 of 193\n[ Info: Plotting frame 172 of 193\n[ Info: Plotting frame 173 of 193\n[ Info: Plotting frame 174 of 193\n[ Info: Plotting frame 175 of 193\n[ Info: Plotting frame 176 of 193\n[ Info: Plotting frame 177 of 193\n[ Info: Plotting frame 178 of 193\n[ Info: Plotting frame 179 of 193\n[ Info: Plotting frame 180 of 193\n[ Info: Plotting frame 181 of 193\n[ Info: Plotting frame 182 of 193\n[ Info: Plotting frame 183 of 193\n[ Info: Plotting frame 184 of 193\n[ Info: Plotting frame 185 of 193\n[ Info: Plotting frame 186 of 193\n[ Info: Plotting frame 187 of 193\n[ Info: Plotting frame 188 of 193\n[ Info: Plotting frame 189 of 193\n[ Info: Plotting frame 190 of 193\n[ Info: Plotting frame 191 of 193\n[ Info: Plotting frame 192 of 193\n[ Info: Plotting frame 193 of 193\n","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"(Image: )","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"","category":"page"},{"location":"literated/internal_tide/","page":"Internal tide by a seamount","title":"Internal tide by a seamount","text":"This page was generated using Literate.jl.","category":"page"},{"location":"numerical_implementation/spatial_operators/#Spatial-operators","page":"Spatial operators","title":"Spatial operators","text":"","category":"section"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"To calculate the various terms and perform the time-stepping, discrete difference and interpolation  operators must be designed from which all the terms, such as momentum advection and Laplacian  diffusion, may be constructed. Much of the material in this section is derived from Marshall et al. (1997).","category":"page"},{"location":"numerical_implementation/spatial_operators/#Differences","page":"Spatial operators","title":"Differences","text":"","category":"section"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"Difference operators act as the discrete form of the derivative operator. Care must be taken  when calculating differences on a staggered grid. For example, the the difference of a cell-centered  variable such as temperature T lies on the faces  in the direction of the difference, and  vice versa. In principle, there are three difference operators, one for each  direction","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"  delta_x f = f_E - f_W  quad\n  delta_y f = f_N - f_S  quad\n  delta_z f = f_T - f_B ","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"where the E and W subscripts indicate that the value is evaluated the eastern or western  wall of the cell, N and S indicate the northern and southern walls, and T and B  indicate the top and bottom walls.","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"Additionally, two delta operators must be defined for each direction to account for the  staggered nature of the grid. One for taking the difference of a cell-centered variable and  projecting it onto the cell faces","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"beginalign\n    delta_x^faa f_i j k = f_i j k - f_i-1 j k   \n    delta_y^afa f_i j k = f_i j k - f_i j-1 k   \n    delta_z^aaf f_i j k = f_i j k - f_i j k-1   \nendalign","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"and another for taking the difference of a face-centered variable and projecting it onto the cell centers","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"beginalign\n    delta_x^caa f_i j k = f_i+1 j k - f_i j k   \n    delta_y^aca f_i j k = f_i j+1 k - f_i j k   \n    delta_z^aac f_i j k = f_i j k+1 - f_i j k  \nendalign","category":"page"},{"location":"numerical_implementation/spatial_operators/#Interpolation","page":"Spatial operators","title":"Interpolation","text":"","category":"section"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"In order to add or multiply variables that are defined at different points they are interpolated.  In our case, linear interpolation or averaging is employed. Once again, there are two averaging  operators, one for each direction,","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"beginequation\n  overlinef^x = fracf_E + f_W2   quad\n  overlinef^y = fracf_N + f_S2   quad\n  overlinef^z = fracf_T + f_B2  \nendequation","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"Additionally, three averaging operators must be defined for each direction. One for taking the  average of a cell-centered  variable and projecting it onto the cell faces","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"beginalign\n    overlinef_i j k^faa = fracf_i j k + f_i-1 j k2   \n    overlinef_i j k^afa = fracf_i j k + f_i j-1 k2   \n    overlinef_i j k^aaf = fracf_i j k + f_i j k-12  \nendalign","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"and another for taking the average of a face-centered variable and projecting it onto the cell centers","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"beginalign\n    overlinef_i j k^caa = fracf_i+1 j k + f_i j k2   \n    overlinef_i j k^aca = fracf_i j+1 k + f_i j k2   \n    overlinef_i j k^aac = fracf_i j k+1 + f_i j k2  \nendalign","category":"page"},{"location":"numerical_implementation/spatial_operators/#Divergence-and-flux-divergence","page":"Spatial operators","title":"Divergence and flux divergence","text":"","category":"section"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"The divergence of the flux of a cell-centered quantity over the cell can be calculated as","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"boldsymbolnabla boldsymbolcdot boldsymbolf\n= frac1V left delta_x^faa (A_x f_x)\n                   + delta_y^afa (A_y f_y)\n                   + delta_z^aaf (A_z f_z) right  ","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"where boldsymbolf = (f_x f_y f_z) is the flux with components defined normal to the  faces, and V is the volume of the cell. The presence of a solid boundary is indicated by  setting the appropriate flux normal to the boundary to zero.","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"A similar divergence operator can be defined for a face-centered quantity. The divergence of, e.g., the flux of T over a cell, boldsymbolnabla boldsymbolcdot (boldsymbolv T),  is then","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"renewcommanddiv1 boldsymbolnabla boldsymbolcdot left ( 1 right )\ndivboldsymbolv T\n= frac1V left delta_x^caa (A_x u overlineT^faa)\n                   + delta_y^aca (A_y v overlineT^afa)\n                   + delta_z^aac (A_z w overlineT^aaf) right  ","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"where T is interpolated onto the cell faces where it can be multiplied by the velocities,  which are then differenced and projected onto the cell centers where they added together.","category":"page"},{"location":"numerical_implementation/spatial_operators/#Momentum-advection","page":"Spatial operators","title":"Momentum advection","text":"","category":"section"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"The advection terms that appear in model equations can be rewritten using the incompressibility  (boldsymbolnabla boldsymbolcdot boldsymbolv = 0) as, e.g,","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"renewcommanddiv1 boldsymbolnabla boldsymbolcdot left ( 1 right )\nbeginalign\nboldsymbolv boldsymbolcdot boldsymbolnabla u  = divu boldsymbolv - u ( boldsymbolnabla boldsymbolcdot boldsymbolv ) nonumber \n     = divu boldsymbolv  \nendalign","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"which can then be discretized similarly to the flux divergence operator, however, they must  be discretized differently for each direction.","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"For example, the x-momentum advection operator is discretized as","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"boldsymbolv boldsymbolcdot boldsymbolnabla u\n= frac1overlineV^x left\n    delta_x^faa left( overlineA_x u^caa overlineu^caa right)\n  + delta_y^afa left( overlineA_y v^aca overlineu^aca right)\n  + delta_z^aaf left( overlineA_z w^aac overlineu^aac right)\nright  ","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"where overlineV^x is the average of the volumes of the cells on either side of the face  in question. Calculating partial_x (uu) can be performed by interpolating A_x u and  u onto the cell centers then multiplying them and differencing them back onto the faces.  However, in the case of the the two other terms, partial_y (vu) and partial_z (wu),  the two variables must be interpolated onto the cell edges to be multiplied then differenced  back onto the cell faces.","category":"page"},{"location":"numerical_implementation/spatial_operators/#Discretization-of-isotropic-diffusion-operators","page":"Spatial operators","title":"Discretization of isotropic diffusion operators","text":"","category":"section"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"An isotropic viscosity operator acting on vertical momentum is discretized via","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"    boldsymbolnabla boldsymbolcdot left ( nu boldsymbolnabla w right )\n    = frac1V left\n          delta_x^faa ( nu overlineA_x^caa partial_x^caa w )\n        + delta_y^afa ( nu overlineA_y^aca partial_y^aca w )\n        + delta_z^aaf ( nu overlineA_z^aac partial_z^aac w )\n    right   ","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"where nu is the kinematic viscosity.","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"An isotropic diffusion operator acting on a tracer c, on the other hand, is discretized via","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"   boldsymbolnabla boldsymbolcdot left ( kappa boldsymbolnabla c right )\n    = frac1V left vphantomoverlineA_x^caa\n        delta_x^caa ( kappa A_x partial_x^faa c )\n      + delta_y^aca ( kappa A_y partial_y^afa c )\n      + delta_z^aac ( kappa A_z partial_z^aaf c )\n    right  ","category":"page"},{"location":"numerical_implementation/spatial_operators/#Vertical-integrals","page":"Spatial operators","title":"Vertical integrals","text":"","category":"section"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"Vertical integrals are converted into sums along each column. For example, the hydrostatic pressure  anomaly is","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"    p_HY^prime = int_-L_z^0 b^prime  mathrmd z  ","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"where b^prime is the buoyancy perturbation. Converting it into a sum that we compute from  the top downwards we get","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"    beginequation\n    p_HY^prime(k) =\n        begincases\n            - overlineb_N_z^prime^aaf Delta z^F_N_z                quad k = N_z   \n            p_HY^prime(k+1) - overlineb_k+1^prime^aaf Delta z^F_k  quad 1 le k le N_z - 1  \n        endcases\n    endequation","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"where we converted the sum into a recursive definition for p_HY^prime(k) in terms of  p_HY^prime(k+1) so that the integral may be computed with mathcalO(N_z) operations  by a single thread.","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"The vertical velocity w may be computed from u and v via the continuity equation","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"    w = - int_-L_z^0 (partial_x u + partial_y v)  mathrmd z  ","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"to satisfy the incompressibility condition boldsymbolnabla boldsymbolcdot boldsymbolv = 0 to numerical precision. This also involves computing a vertical integral, in this case evaluated from the bottom up","category":"page"},{"location":"numerical_implementation/spatial_operators/","page":"Spatial operators","title":"Spatial operators","text":"    beginequation\n    w_k =\n        begincases\n            0  quad k = 1   \n            w_k-1 - left( partial_x^caa u + partial_y^aca v right) Delta z^C_k  quad 2 le k le N_z  \n        endcases\n    endequation","category":"page"},{"location":"contributing/#Contributors-Guide","page":"Contributor's guide","title":"Contributors Guide","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Thank you for considering contributions to Oceananigans! We hope this guide helps you make a contribution.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Feel free to ask us questions and chat with us at any time about any topic at all by:","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Opening a GitHub issue\nCreating a GitHub discussion\nSending a message to the #oceananigans channel on Julia Slack.","category":"page"},{"location":"contributing/#Creating-issues","page":"Contributor's guide","title":"Creating issues","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"The simplest way to contribute to Oceananigans is to create or comment on issues and discussions.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"The most useful bug reports:","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Provide an explicit code snippet – not just a link – that reproduces the bug in the latest tagged version of Oceananigans. This is sometimes called the \"minimal working example\". Reducing bug-producing code to a minimal example can dramatically decrease the time it takes to resolve an issue.\nPaste the entire error received when running the code snippet, even if it's unbelievably long.\nUse triple backticks (e.g., ```some_code; and_some_more_code;```) to enclose code snippets, and other markdown formatting syntax to make your issue easy and quick to read.\nReport the Oceananigans version, Julia version, machine (especially if using a GPU) and any other possibly useful details of the computational environment in which the bug was created.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Discussions are recommended for asking questions about (for example) the user interface, implementation details, science, and life in general.","category":"page"},{"location":"contributing/#But-I-want-to-*code*!","page":"Contributor's guide","title":"But I want to code!","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"New users help write Oceananigans code and documentation by forking the Oceananigans repository, using git to edit code and docs, and then creating a pull request. Pull requests are reviewed by Oceananigans collaborators.\nA pull request can be merged once it is reviewed and approved by collaborators. If the pull request author has write access, they have the responsibility of merging their pull request. Otherwise, Oceananigans.jl collaborators will execute the merge with permission from the pull request author.\nNote: for small or minor changes (such as fixing a typo in documentation), the GitHub editor is super useful for forking and opening a pull request with a single click.\nWrite your code with love and care. In particular, conform to existing Oceananigans style and formatting conventions. For example, we love verbose and explicit variable names, use TitleCase for types, snake_case for objects, and always,put,spaces.after.commas,or.periods. For formatting decisions we loosely follow the YASGuide. It's worth few extra minutes of our time to leave future generations with well-written, readable code.","category":"page"},{"location":"contributing/#What-is-a-\"collaborator\"-and-how-can-I-become-one?","page":"Contributor's guide","title":"What is a \"collaborator\" and how can I become one?","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Collaborators have permissions to review pull requests and status allows a contributor to review pull requests in addition to opening them. Collaborators can also create branches in the main Oceananigans repository.\nWe ask that new contributors try their hand at forking Oceananigans, and opening and merging a pull request before requesting collaborator status.","category":"page"},{"location":"contributing/#What's-a-good-way-to-start-developing-Oceananigans?","page":"Contributor's guide","title":"What's a good way to start developing Oceananigans?","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Tackle an existing issue. We keep a list of good first issues that are self-contained and suitable for a newcomer to try and work on.\nTry to run Oceananigans and play around with it to simulate your favorite fluids and ocean physics. If you run into any problems or find it difficult to use or understand, please open an issue!\nWrite up an example or tutorial on how to do something useful with Oceananigans, like how to set up a new physical configuration.\nImprove documentation or comments if you found something hard to use.\nImplement a new feature if you need it to use Oceananigans.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"If you're interested in working on something, let us know by commenting on existing issues or  by opening a new issue. This is to make sure no one else is working on the same issue and so  we can help and guide you in case there is anything you need to know beforehand.","category":"page"},{"location":"contributing/#Ground-Rules","page":"Contributor's guide","title":"Ground Rules","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Each pull request should consist of a logical collection of changes. You can include multiple bug fixes in a single pull request, but they should be related. For unrelated changes, please submit multiple pull requests.\nDo not commit changes to files that are irrelevant to your feature or bugfix (eg: .gitignore).\nBe willing to accept criticism and work on improving your code; we don't want to break other users' code, so care must be taken not to introduce bugs. We discuss pull requests and keep working on them until we believe we've done a good job.\nBe aware that the pull request review process is not immediate, and is generally proportional to the size of the pull request.","category":"page"},{"location":"contributing/#Reporting-a-bug","page":"Contributor's guide","title":"Reporting a bug","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"The easiest way to get involved is to report issues you encounter when using Oceananigans or by requesting something you think is missing.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Head over to the issues page.\nSearch to see if your issue already exists or has even been solved previously.\nIf you indeed have a new issue or request, click the \"New Issue\" button.\nPlease be as specific as possible. Include the version of the code you were using, as well as what operating system you are running. The output of Julia's versioninfo() and ] status is helpful to include. Try your best to include a complete, \"minimal working example\" that reproduces the issue.","category":"page"},{"location":"contributing/#Setting-up-your-development-environment","page":"Contributor's guide","title":"Setting up your development environment","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Install Julia on your system.\nInstall git on your system if it is not already there (install XCode command line tools on a Mac or git bash on Windows).\nLogin to your GitHub account and make a fork of the Oceananigans repository by clicking the \"Fork\" button.\nClone your fork of the Oceananigans repository (in terminal on Mac/Linux or git shell/ GUI on Windows) in the location you'd like to keep it.\ngit clone https://github.com/your-user-name/Oceananigans.jl.git\nNavigate to that folder in the terminal or in Anaconda Prompt if you're on Windows.\nConnect your repository to the upstream (main project).\ngit remote add oceananigans https://github.com/CLiMA/Oceananigans.jl.git\nCreate the development environment by opening Julia via julia --project then typing in ] instantiate. This will install all the dependencies in the Project.toml file. Your development environment is now ready!\nYou can test to make sure Oceananigans works by typing in ] test. (This is equivalent to using Pkg; Pkg.test().) Doing so will run all the tests (and this can take a while). Alternatively, you can run only one test script file by providing its name as an environment variable. For example, to run the tests only from the test_coriolis.jl file we call:\n$ TEST_FILE=test_coriolis.jl julia --project -e\"using Pkg; Pkg.test()\"","category":"page"},{"location":"contributing/#Pull-Requests","page":"Contributor's guide","title":"Pull Requests","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"We follow the ColPrac guide for collaborative practices. We ask that new contributors read that guide before submitting a pull request.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Changes and contributions should be made via GitHub pull requests against the main branch.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"When you're done making changes, commit the changes you made. Chris Beams has written a  guide on how to write good commit messages.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"When you think your changes are ready to be merged into the main repository, push to your fork and submit a pull request.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Working on your first Pull Request? You can learn how from this free video series How to Contribute to an Open Source Project on GitHub, Aaron Meurer's tutorial on the git workflow, or the guide “How to Contribute to Open Source\".","category":"page"},{"location":"contributing/#Documentation","page":"Contributor's guide","title":"Documentation","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Now that you've made your awesome contribution, it's time to tell the world how to use it. Writing documentation strings is really important to make sure others use your functionality properly. Didn't write new functions? That's fine, but be sure that the documentation for the code you touched is still in great shape. It is not uncommon to find some strange wording or clarification that you can take care of while you are here.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"You can preview how the Documentation will look like after merging by building the documentation  locally. From the main directory of your local repository call","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"julia --project=docs/ -e 'using Pkg; Pkg.develop(PackageSpec(path=pwd())); Pkg.instantiate()'","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"to instantiate the documentation environment and then","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"JULIA_DEBUG=Documenter julia --project=docs/ docs/make.jl","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"If the documentation built is successful, you can open docs/build/index.html in your favorite browser.Providing the environment variable  JULIA_DEBUG=Documenter will provide with more information in the documentation build process and thus help figuring out a potential bug.","category":"page"},{"location":"contributing/#Credits","page":"Contributor's guide","title":"Credits","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"This contributor's guide is heavily based on the excellent MetPy contributor's guide.","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"EditURL = \"../../../examples/shallow_water_Bickley_jet.jl\"","category":"page"},{"location":"literated/shallow_water_Bickley_jet/#An-unstable-Bickley-jet-in-Shallow-Water-model","page":"Shallow water Bickley jet","title":"An unstable Bickley jet in Shallow Water model","text":"","category":"section"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"This example uses Oceananigans.jl's ShallowWaterModel to simulate the evolution of an unstable, geostrophically balanced, Bickley jet The example is periodic in x with flat bathymetry and uses the conservative formulation of the shallow water equations. The initial conditions superpose the Bickley jet with small-amplitude perturbations. See \"The nonlinear evolution of barotropically unstable jets,\" J. Phys. Oceanogr. (2003) for more details on this problem.","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"The mass transport (uh vh) is the prognostic momentum variable in the conservative formulation of the shallow water equations, where (u v) are the horizontal velocity components and h is the layer height.","category":"page"},{"location":"literated/shallow_water_Bickley_jet/#Install-dependencies","page":"Shallow water Bickley jet","title":"Install dependencies","text":"","category":"section"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"First we make sure that we have all of the packages that are required to run the simulation.","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"using Pkg\npkg\"add Oceananigans, NCDatasets, Polynomials, CairoMakie\"","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"using Oceananigans\nusing Oceananigans.Models: ShallowWaterModel","category":"page"},{"location":"literated/shallow_water_Bickley_jet/#Two-dimensional-domain","page":"Shallow water Bickley jet","title":"Two-dimensional domain","text":"","category":"section"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"The shallow water model is two-dimensional and uses grids that are Flat in the vertical direction. We use length scales non-dimensionalized by the width of the Bickley jet.","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"grid = RectilinearGrid(size = (48, 128),\n                       x = (0, 2π),\n                       y = (-10, 10),\n                       topology = (Periodic, Bounded, Flat))","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"48×128×1 RectilinearGrid{Float64, Periodic, Bounded, Flat} on CPU with 3×3×0 halo\n├── Periodic x ∈ [-1.67581e-17, 6.28319) regularly spaced with Δx=0.1309\n├── Bounded  y ∈ [-10.0, 10.0]           regularly spaced with Δy=0.15625\n└── Flat z                               ","category":"page"},{"location":"literated/shallow_water_Bickley_jet/#Building-a-ShallowWaterModel","page":"Shallow water Bickley jet","title":"Building a ShallowWaterModel","text":"","category":"section"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"We build a ShallowWaterModel with the WENO advection scheme, 3rd-order Runge-Kutta time-stepping, non-dimensional Coriolis, and gravitational acceleration","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"gravitational_acceleration = 1\ncoriolis = FPlane(f=1)\n\nmodel = ShallowWaterModel(; grid, coriolis, gravitational_acceleration,\n                          timestepper = :RungeKutta3,\n                          momentum_advection = WENO())","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"ShallowWaterModel{typename(CPU), Float64}(time = 0 seconds, iteration = 0) \n├── grid: 48×128×1 RectilinearGrid{Float64, Periodic, Bounded, Flat} on CPU with 3×3×0 halo\n├── timestepper: RungeKutta3TimeStepper\n├── advection scheme: \n│   ├── momentum: WENO reconstruction order 5\n│   └── mass: WENO reconstruction order 5\n├── tracers: ()\n└── coriolis: FPlane{Float64}","category":"page"},{"location":"literated/shallow_water_Bickley_jet/#Background-state-and-perturbation","page":"Shallow water Bickley jet","title":"Background state and perturbation","text":"","category":"section"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"The background velocity u and free-surface η correspond to a geostrophically balanced Bickely jet with maximum speed of U and maximum free-surface deformation of Δη,","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"U = 1  # Maximum jet velocity\nH = 10 # Reference depth\nf = coriolis.f\ng = gravitational_acceleration\nΔη = f * U / g  # Maximum free-surface deformation as dictated by geostrophy\n\nh̄(x, y) = H - Δη * tanh(y)\nū(x, y) = U * sech(y)^2","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"ū (generic function with 1 method)","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"The total height of the fluid is h = L_z + eta. Linear stability theory predicts that for the parameters we consider here, the growth rate for the most unstable mode that fits our domain is approximately 0139.","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"The vorticity of the background state is","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"ω̄(x, y) = 2 * U * sech(y)^2 * tanh(y)","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"ω̄ (generic function with 1 method)","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"The initial conditions include a small-amplitude perturbation that decays away from the center of the jet.","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"small_amplitude = 1e-4\n\n uⁱ(x, y) = ū(x, y) + small_amplitude * exp(-y^2) * randn()\nuhⁱ(x, y) = uⁱ(x, y) * h̄(x, y)","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"uhⁱ (generic function with 1 method)","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"We first set a \"clean\" initial condition without noise for the purpose of discretely calculating the initial 'mean' vorticity,","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"ū̄h(x, y) = ū(x, y) * h̄(x, y)\n\nset!(model, uh = ū̄h, h = h̄)","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"We next compute the initial vorticity and perturbation vorticity,","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"uh, vh, h = model.solution\n\n# Build velocities\nu = uh / h\nv = vh / h\n\n# Build and compute mean vorticity discretely\nω = Field(∂x(v) - ∂y(u))\ncompute!(ω)\n\n# Copy mean vorticity to a new field\nωⁱ = Field((Face, Face, Nothing), model.grid)\nωⁱ .= ω\n\n# Use this new field to compute the perturbation vorticity\nω′ = Field(ω - ωⁱ)","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"48×129×1 Field{Face, Face, Center} on RectilinearGrid on CPU\n├── grid: 48×128×1 RectilinearGrid{Float64, Periodic, Bounded, Flat} on CPU with 3×3×0 halo\n├── boundary conditions: FieldBoundaryConditions\n│   └── west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux\n├── operand: BinaryOperation at (Face, Face, Center)\n├── status: time=0.0\n└── data: 54×135×1 OffsetArray(::Array{Float64, 3}, -2:51, -2:132, 1:1) with eltype Float64 with indices -2:51×-2:132×1:1\n    └── max=0.0, min=0.0, mean=0.0","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"and finally set the \"true\" initial condition with noise,","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"set!(model, uh = uhⁱ)","category":"page"},{"location":"literated/shallow_water_Bickley_jet/#Running-a-Simulation","page":"Shallow water Bickley jet","title":"Running a Simulation","text":"","category":"section"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"We pick the time-step so that we make sure we resolve the surface gravity waves, which propagate with speed of the order sqrtg H. That is, with Δt = 1e-2 we ensure that sqrtg H Δt  Δx  sqrtg H Δt  Δy  07.","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"simulation = Simulation(model, Δt = 1e-2, stop_time = 100)","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Simulation of ShallowWaterModel{RectilinearGrid{Float64, Periodic, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, CPU}, CPU, Float64, Float64, @NamedTuple{momentum::WENO{3, Float64, Nothing, Nothing, Nothing, Nothing, WENO{2, Float64, Nothing, Nothing, Nothing, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{2, Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}}, mass::WENO{3, Float64, Nothing, Nothing, Nothing, Nothing, WENO{2, Float64, Nothing, Nothing, Nothing, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{2, Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}}}, @NamedTuple{u::Field{Face, Center, Center, BinaryOperation{Face, Center, Center, typeof(/), Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, Nothing, Nothing, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, Nothing, Nothing, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, typeof(Oceananigans.Operators.identity4), typeof(ℑxᶠᵃᵃ), RectilinearGrid{Float64, Periodic, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, CPU}, Float64}, RectilinearGrid{Float64, Periodic, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, Nothing, Nothing, BoundaryCondition{Flux, Nothing}}, Oceananigans.Fields.FieldStatus{Float64}, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, v::Field{Center, Face, Center, BinaryOperation{Center, Face, Center, typeof(/), Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Open{Nothing}, Nothing}, BoundaryCondition{Open{Nothing}, Nothing}, Nothing, Nothing, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, Nothing, Nothing, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, typeof(Oceananigans.Operators.identity5), typeof(ℑyᵃᶠᵃ), RectilinearGrid{Float64, Periodic, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, CPU}, Float64}, RectilinearGrid{Float64, Periodic, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Flux, Nothing}}, Oceananigans.Fields.FieldStatus{Float64}, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, w::Nothing}, FPlane{Float64}, @NamedTuple{uh::typeof(Oceananigans.Forcings.zeroforcing), vh::typeof(Oceananigans.Forcings.zeroforcing), h::typeof(Oceananigans.Forcings.zeroforcing)}, Nothing, Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, Nothing, Nothing, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, @NamedTuple{uh::Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, Nothing, Nothing, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, vh::Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Open{Nothing}, Nothing}, BoundaryCondition{Open{Nothing}, Nothing}, Nothing, Nothing, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, h::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, Nothing, Nothing, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}}, @NamedTuple{}, Nothing, RungeKutta3TimeStepper{Float64, @NamedTuple{uh::Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, Nothing, Nothing, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, vh::Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, h::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, Nothing, Nothing, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}}, Nothing}, ConservativeFormulation}\n├── Next time step: 10 ms\n├── Elapsed wall time: 0 seconds\n├── Wall time per iteration: NaN days\n├── Stop time: 1.667 minutes\n├── Stop iteration : Inf\n├── Wall time limit: Inf\n├── Callbacks: OrderedDict with 4 entries:\n│   ├── stop_time_exceeded => Callback of stop_time_exceeded on IterationInterval(1)\n│   ├── stop_iteration_exceeded => Callback of stop_iteration_exceeded on IterationInterval(1)\n│   ├── wall_time_limit_exceeded => Callback of wall_time_limit_exceeded on IterationInterval(1)\n│   └── nan_checker => Callback of NaNChecker for uh on IterationInterval(100)\n├── Output writers: OrderedDict with no entries\n└── Diagnostics: OrderedDict with no entries","category":"page"},{"location":"literated/shallow_water_Bickley_jet/#Prepare-output-files","page":"Shallow water Bickley jet","title":"Prepare output files","text":"","category":"section"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Define a function to compute the norm of the perturbation on the cross channel velocity. We obtain the norm function from LinearAlgebra.","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"using LinearAlgebra: norm\n\nperturbation_norm(args...) = norm(v)","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"perturbation_norm (generic function with 1 method)","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Build the output_writer for the two-dimensional fields to be output. Output every t = 1.0.","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"fields_filename = joinpath(@__DIR__, \"shallow_water_Bickley_jet_fields.nc\")\nsimulation.output_writers[:fields] = NetCDFOutputWriter(model, (; ω, ω′),\n                                                        filename = fields_filename,\n                                                        schedule = TimeInterval(2),\n                                                        overwrite_existing = true)","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"NetCDFOutputWriter scheduled on TimeInterval(2 seconds):\n├── filepath: /var/lib/buildkite-agent/builds/tartarus-15/clima/oceananigans/docs/src/literated/shallow_water_Bickley_jet_fields.nc\n├── dimensions: zC(1), zF(1), xC(48), yF(129), xF(48), yC(128), time(0)\n├── 2 outputs: (ω, ω′)\n└── array type: Array{Float64}\n├── file_splitting: NoFileSplitting\n└── file size: 16.8 KiB","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Build the output_writer for the growth rate, which is a scalar field. Output every time step.","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"growth_filename = joinpath(@__DIR__, \"shallow_water_Bickley_jet_perturbation_norm.nc\")\nsimulation.output_writers[:growth] = NetCDFOutputWriter(model, (; perturbation_norm),\n                                                        filename = growth_filename,\n                                                        schedule = IterationInterval(1),\n                                                        dimensions = (; perturbation_norm = ()),\n                                                        overwrite_existing = true)","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"NetCDFOutputWriter scheduled on IterationInterval(1):\n├── filepath: /var/lib/buildkite-agent/builds/tartarus-15/clima/oceananigans/docs/src/literated/shallow_water_Bickley_jet_perturbation_norm.nc\n├── dimensions: zC(1), zF(1), xC(48), yF(129), xF(48), yC(128), time(0)\n├── 1 outputs: perturbation_norm\n└── array type: Array{Float64}\n├── file_splitting: NoFileSplitting\n└── file size: 14.7 KiB","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"And finally run the simulation.","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"run!(simulation)","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"[ Info: Initializing simulation...\n[ Info:     ... simulation initialization complete (8.865 seconds)\n[ Info: Executing initial time step...\n[ Info:     ... initial time step complete (4.999 seconds).\n[ Info: Simulation is stopping after running for 1.608 minutes.\n[ Info: Simulation time 1.667 minutes equals or exceeds stop time 1.667 minutes.\n","category":"page"},{"location":"literated/shallow_water_Bickley_jet/#Visualize-the-results","page":"Shallow water Bickley jet","title":"Visualize the results","text":"","category":"section"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Load required packages to read output and plot.","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"using NCDatasets, Printf, CairoMakie","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Define the coordinates for plotting.","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"x, y = xnodes(ω), ynodes(ω)","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Read in the output_writer for the two-dimensional fields and then create an animation showing both the total and perturbation vorticities.","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"fig = Figure(size = (1200, 660))\n\naxis_kwargs = (xlabel = \"x\", ylabel = \"y\")\nax_ω  = Axis(fig[2, 1]; title = \"Total vorticity, ω\", axis_kwargs...)\nax_ω′ = Axis(fig[2, 3]; title = \"Perturbation vorticity, ω - ω̄\", axis_kwargs...)\n\nn = Observable(1)\n\nds = NCDataset(simulation.output_writers[:fields].filepath, \"r\")\n\ntimes = ds[\"time\"][:]\n\nω = @lift ds[\"ω\"][:, :, 1, $n]\nhm_ω = heatmap!(ax_ω, x, y, ω, colorrange = (-1, 1), colormap = :balance)\nColorbar(fig[2, 2], hm_ω)\n\nω′ = @lift ds[\"ω′\"][:, :, 1, $n]\nhm_ω′ = heatmap!(ax_ω′, x, y, ω′, colormap = :balance)\nColorbar(fig[2, 4], hm_ω′)\n\ntitle = @lift @sprintf(\"t = %.1f\", times[$n])\nfig[1, 1:4] = Label(fig, title, fontsize=24, tellwidth=false)\n\nfig","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"(Image: )","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Finally, we record a movie.","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"frames = 1:length(times)\n\nrecord(fig, \"shallow_water_Bickley_jet.mp4\", frames, framerate=12) do i\n    n[] = i\nend","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"(Image: )","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"It's always good practice to close the NetCDF files when we are done.","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"close(ds)","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"closed Dataset","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Read in the output_writer for the scalar field (the norm of v-velocity).","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"ds2 = NCDataset(simulation.output_writers[:growth].filepath, \"r\")\n\n     t = ds2[\"time\"][:]\nnorm_v = ds2[\"perturbation_norm\"][:]\n\nclose(ds2)","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"We import the fit function from Polynomials.jl to compute the best-fit slope of the perturbation norm on a logarithmic plot. This slope corresponds to the growth rate.","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"using Polynomials: fit\n\nI = 5000:6000\n\ndegree = 1\nlinear_fit_polynomial = fit(t[I], log.(norm_v[I]), degree, var = :t)","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"&#45;9.928716278867707 &#43; 0.13695608888334984&#8729;t","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"We can get the coefficient of the n-th power from the fitted polynomial by using n as an index, e.g.,","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"constant, slope = linear_fit_polynomial[0], linear_fit_polynomial[1]","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"(-9.928716278867707, 0.13695608888334984)","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"We then use the computed linear fit coefficients to construct the best fit and plot it together with the time-series for the perturbation norm for comparison.","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"best_fit = @. exp(constant + slope * t)\n\nlines(t, norm_v;\n      linewidth = 4,\n      label = \"norm(v)\",\n      axis = (yscale = log10,\n              limits = (nothing, (1e-3, 30)),\n              xlabel = \"time\",\n              ylabel = \"norm(v)\",\n               title = \"growth of perturbation norm\"))\n\nlines!(t[I], 2 * best_fit[I]; # factor 2 offsets fit from curve for better visualization\n       linewidth = 4,\n       label = \"best fit\")\n\naxislegend(position = :rb)\n","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"(Image: )","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"The slope of the best-fit curve on a logarithmic scale approximates the rate at which instability grows in the simulation. Let's see how this compares with the theoretical growth rate.","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"println(\"Numerical growth rate is approximated to be \", round(slope, digits=3), \",\\n\",\n        \"which is very close to the theoretical value of 0.139.\")","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"Numerical growth rate is approximated to be 0.137,\nwhich is very close to the theoretical value of 0.139.\n","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"","category":"page"},{"location":"literated/shallow_water_Bickley_jet/","page":"Shallow water Bickley jet","title":"Shallow water Bickley jet","text":"This page was generated using Literate.jl.","category":"page"},{"location":"physics/turbulence_closures/#Turbulence-closures","page":"Turbulence closures","title":"Turbulence closures","text":"","category":"section"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"The turbulence closure selected by the user determines the form of stress divergence boldsymbolnabla boldsymbolcdot boldsymboltau and diffusive flux divergence boldsymbolnabla boldsymbolcdot boldsymbolq_c in the momentum and tracer conservation equations.","category":"page"},{"location":"physics/turbulence_closures/#Constant-isotropic-diffusivity","page":"Turbulence closures","title":"Constant isotropic diffusivity","text":"","category":"section"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"In a constant isotropic diffusivity model, the kinematic stress tensor is defined","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"tau_ij = - nu Sigma_ij  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"where nu is a constant viscosity and Sigma_ij equiv tfrac12 left ( v_i j + v_j i right ) is the strain-rate tensor. The divergence of boldsymboltau is then","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"boldsymbolnabla boldsymbolcdot boldsymboltau = -nu nabla^2 boldsymbolv  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"Similarly, the diffusive tracer flux is boldsymbolq_c = - kappa boldsymbolnabla c for tracer diffusivity kappa, and the diffusive tracer flux divergence is","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"boldsymbolnabla boldsymbolcdot boldsymbolq_c = - kappa nabla^2 c  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"Each tracer may have a unique diffusivity kappa.","category":"page"},{"location":"physics/turbulence_closures/#Constant-anisotropic-diffusivity","page":"Turbulence closures","title":"Constant anisotropic diffusivity","text":"","category":"section"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"A constant anisotropic diffusivity implies a constant tensor diffusivity nu_j k and stress boldsymboltau_ij = nu_j k u_i k with non-zero components nu_11 = nu_22 = nu_h and nu_33 = nu_z. With this form the kinematic stress divergence becomes","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"boldsymbolnabla boldsymbolcdot boldsymboltau = - left  nu_h left ( partial_x^2 + partial_y^2 right )\n                                    + nu_v partial_z^2 right  boldsymbolv  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"and diffusive flux divergence","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"boldsymbolnabla boldsymbolcdot boldsymbolq_c = - left  kappa_h left ( partial_x^2 + partial_y^2 right )\n                                    + kappa_v partial_z^2 right  c  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"in terms of the horizontal viscosities and diffusivities, nu_h and kappa_h, and the vertical viscosity and diffusivities, nu_z and kappa_z. Each tracer may have a unique diffusivity components kappa_h and kappa_v.","category":"page"},{"location":"physics/turbulence_closures/#Scalar-biharmonic-diffusivity","page":"Turbulence closures","title":"Scalar biharmonic diffusivity","text":"","category":"section"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"A constant biharmonic diffusivity implies a constant tensor diffusivity nu_j k and stressboldsymboltau_ij = nu_j k partial_k^3 u_i with non-zero components nu_11 = nu_22 = nu_h and nu_33 = nu_z.","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"With this form the kinematic stress divergence becomes","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"boldsymbolnabla boldsymbolcdot boldsymboltau = - left  nu_h left ( partial_x^2 + partial_y^2 right )^2\n                                    + nu_v partial_z^4 right  boldsymbolv  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"and diffusive flux divergence","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"boldsymbolnabla boldsymbolcdot boldsymbolq_c = - left  kappa_h left ( partial_x^2 + partial_y^2 right )^2\n                                    + kappa_v partial_z^4 right  c  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"in terms of the horizontal biharmonic viscosities and diffusivities, nu_h and kappa_h, and the vertical biharmonic viscosity and diffusivities, nu_z and kappa_z. Each tracer may have a unique diffusivity components kappa_h and kappa_z.","category":"page"},{"location":"physics/turbulence_closures/#Smagorinsky-Lilly-turbulence-closure","page":"Turbulence closures","title":"Smagorinsky-Lilly turbulence closure","text":"","category":"section"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"In the turbulence closure proposed by Lilly (1962) and Smagorinsky (1963), the subgrid stress associated with unresolved turbulent motions is modeled diffusively via","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"tau_ij = - 2 nu_e Sigma_ij  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"where Sigma_ij = tfrac12 left ( v_i j + v_j i right ) is the resolved strain rate. The eddy viscosity is given by","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"    beginalign\n    nu_e = left ( C Delta_f right )^2 sqrt Sigma^2   varsigma(N^2  Sigma^2)  \n    labeleqsmagorinsky-viscosity\n    endalign","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"where Delta_f is the \"filter width\" associated with the finite volume grid spacing and C is a user-specified model constant, Sigma^2 equiv Sigma_ij Sigma_ij. The factor varsigma(N^2  Sigma^2) reduces nu_e in regions of strong stratification via","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"    varsigma(N^2  Sigma^2) = sqrt1 - min left ( 1 C_b N^2  Sigma^2 right )  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"where N^2 = max left (0 partial_z b right ) is the squared buoyancy frequency for stable stratification with partial_z b  0 and C_b is a user-specified constant.  Lilly (1962) proposed C_b = 1Pr, where Pr is a turbulent Prandtl number. The filter width for the Smagorinsky-Lilly closure is","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"Delta_f(boldsymbolx) = left ( Delta x Delta y Delta z right)^13  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"where Delta x, Delta y, and Delta z are the grid spacing in the boldsymbolhat x, boldsymbolhat y, and boldsymbolhat z directions at location boldsymbolx = (x y z).","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"The effect of subgrid turbulence on tracer mixing is also modeled diffusively via","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"boldsymbolq_c = - kappa_e boldsymbolnabla c  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"where the eddy diffusivity kappa_e is","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"kappa_e = fracnu_ePr + kappa  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"Both Pr and kappa may be set independently for each tracer.","category":"page"},{"location":"physics/turbulence_closures/#Anisotropic-minimum-dissipation-(AMD)-turbulence-closure","page":"Turbulence closures","title":"Anisotropic minimum dissipation (AMD) turbulence closure","text":"","category":"section"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"The anisotropic minimum dissipation (AMD) model proposed by Verstappen (2018) and was described and tested by Vreugdenhil and Taylor (2018). The AMD model uses an eddy diffusivity hypothesis similar the Smagorinsky-Lilly model. In the AMD model, the eddy viscosity and diffusivity for each tracer are defined in terms of eddy viscosity and diffusivity predictors nu_e^dagger and kappa_e^dagger, such that","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"    nu_e = max left ( 0 nu_e^dagger right ) + nu\n    quad textand quad\n    kappa_e = max left ( 0 kappa_e^dagger right ) + kappa  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"to ensure that nu_e ge 0 and kappa_e ge 0, where nu and kappa are the constant isotropic background viscosity and diffusivities for each tracer. The eddy viscosity  predictor is","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"    beginequation\n    nu_e^dagger = C Delta_f^2\n    frac\n        (hatpartial_k hatv_i) (hatpartial_k hatv_j) hatSigma_ij\n        + C_b hatdelta_i3 (hatpartial_k hatv_i) (hatpartial_k b)\n        (hatpartial_l hatv_m) (hatpartial_l hatv_m)  \n    labeleqnu-dagger\n    endequation","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"while the eddy diffusivity predictor for tracer c is","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"    beginequation\n    labeleqkappa-dagger\n    kappa_e^dagger = C Delta_f^2\n    frac\n        (hatpartial_k hatv_i) (hatpartial_k c) (hatpartial_i c)\n        (hatpartial_l c) (hatpartial_l c)  \n    endequation","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"In the definitions of the eddy viscosity and eddy diffusivity predictor, C and C_b are user-specified model constants, Delta_f is a \"filter width\" associated with the finite volume grid spacing, and the hat decorators on partial derivatives, velocities, and the Kronecker delta hat delta_i3 are defined such that","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"    hat partial_i equiv Delta_i partial_i qquad\n    hatv_i(x t) equiv fracv_i(x t)Delta_i quad textand quad\n    hatdelta_i3 equiv fracdelta_i3Delta_3  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"A velocity gradient, for example, is therefore hatpartial_i hatv_j(x t) = fracDelta_iDelta_j partial_i v_j(x t), while the normalized strain tensor is","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"    hatSigma_ij =\n        frac12 left hatpartial_i hatv_j(x t) + hatpartial_j hatv_i(x t) right  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"The filter width Delta_f in that appears in the viscosity and diffusivity predictors is taken as the square root of the harmonic mean of the squares of the filter widths in each direction:","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"    frac1Delta_f^2 = frac13 left(   frac1Delta x^2\n                                              + frac1Delta y^2\n                                              + frac1Delta z^2 right)  ","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"The constant C_b permits the \"buoyancy modification\" term it multiplies to be omitted from a calculation. By default we use the model constants C = 112 and C_b = 0.","category":"page"},{"location":"physics/turbulence_closures/#Convective-adjustment-vertical-diffusivity","page":"Turbulence closures","title":"Convective adjustment vertical diffusivity","text":"","category":"section"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"This closure aims to model the enhanced mixing that occurs due to convection. At every point and for every time instance, the closure diagnoses the gravitational stability of the fluid and applies the vertical diffusivities (i) background_νz to u, v and background_κz to all tracers if the fluid is gravitationally neutral or stable with bz  0, or (ii) convective_νz and convective_κz if bz  0.","category":"page"},{"location":"physics/turbulence_closures/","page":"Turbulence closures","title":"Turbulence closures","text":"This closure is a plausible model for convection if convective_κz gg background_κz and convective_νz gg background_νz.","category":"page"},{"location":"model_setup/architecture/#Architecture","page":"Architecture","title":"Architecture","text":"","category":"section"},{"location":"model_setup/architecture/","page":"Architecture","title":"Architecture","text":"Passing CPU() or GPU() to the grid constructor determines whether the grid lives on a CPU or GPU.","category":"page"},{"location":"model_setup/architecture/","page":"Architecture","title":"Architecture","text":"Ideally a set up or simulation script does not need to be modified to run on a GPU but still we are smoothing out rough edges. Generally the CPU wants Array objects while the GPU wants CuArray objects.","category":"page"},{"location":"model_setup/architecture/","page":"Architecture","title":"Architecture","text":"tip: Running on GPUs\nThe section on simulation tips includes information that can come handy when running on GPUs.We would very welcome any suggestions you may have to improve the API and make transitions from CPU to GPU even smoother. Please  open an issue with any such suggestions.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#numerical_les","page":"Large eddy simulation","title":"Large eddy simulation","text":"","category":"section"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"The idea behind large eddy simulation (LES) is to resolve the \"large eddies\" while modeling the effect of unresolved sub-grid scale motions. This is done usually be assuming eddy viscosity and eddy diffusivity models and providing an estimate for the eddy viscosity nu_e and diffusivity kappa_e.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"Much of the early work on LES was motivated by the study of atmospheric boundary layer turbulence, being developed by Smagorinsky (1963) and Lilly (1966), then first implemented by Deardorff (1970) and Deardorff (1974).","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"In the LES framework, the Navier-Stokes equations are averaged in the same way as Reynolds (1895) except that the mean field overlineboldsymbolv is obtained via convolution with a filter convolution kernel G","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"overlineboldsymbolv(boldsymbolx t) = G star boldsymbolv =\n  int_-infty^infty int_-infty^infty\n  boldsymbolv(boldsymbolx^prime t) G(boldsymbolx - boldsymbolx^prime t - tau)  mathrmdboldsymbolx^prime  mathrmd tau  ","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"as described by Leonard (1975) who introduced the general filtering formalism.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"The overlinev_i^prime v_j^prime terms are now components of what is called the sub-grid scale (SGS) stress tensor tau^textSGS_ij, which looks the same as the Reynolds stress tensor so we will drop the SGS superscript.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"It is probably important to note that the large eddy simulation filtering operation does not satisfy the properties of a Reynolds operator (§2.1) (Sagaut and Meneveau, 2006) and that in general, the filtered residual is not zero: overlineboldsymbolv^prime(boldsymbolx t) ne 0.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"§13.2 of Pope (2000) lists a number of popular choices for the filter function G. For practical reasons we simply employ the box kernel","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"  beginequation\n  labeleqbox-kernel\n  G_Delta = G(boldsymbolx t) = frac1Delta H left( frac12Delta - boldsymbolx right) delta(t - t_n)  \n  endequation","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"where H is the Heaviside function, Delta is the grid spacing, and t_n is the current time step. With \\eqref{eq:box-kernel} we get back the averaging operator originally used by Deardorff (1970)","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"overlineboldsymbolv(x y z t) =\n  frac1Delta x Delta y Delta z\n  int_x - frac12Delta x^x + frac12Delta x\n  int_y - frac12Delta y^y + frac12Delta y\n  int_z - frac12Delta z^z + frac12Delta z\n  boldsymbolv(xi eta zeta t)  mathrmd xi  mathrmd eta  mathrmd zeta  ","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"which if evaluated at the cell centers just returns the cell averages we already compute in the finite volume method.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#Smagorinsky-Lilly-model","page":"Large eddy simulation","title":"Smagorinsky-Lilly model","text":"","category":"section"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"Smagorinsky (1963) estimated the eddy viscosity nu_e via a characteristic length scale Delta times a velocity scale given by Delta overlineS where overlineS = sqrt2overlineS_ijoverlineS_ij. Thus the SGS stress tensor is given by","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"tau_ij = -2 nu_e overlineS_ij = -2 (C_s Delta)^2 overlineS overlineS_ij  ","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"where C_s is a dimensionless constant. The grid spacing is usually used for the characteristic length scale Delta. The eddy diffusivities are calculated via kappa_e = nu_e  textPr_t where the turbulent Prandtl number textPr_t is usually chosen to be mathcalO(1) from experimental observations.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"Assuming that the SGS energy cascade is equal to the overall dissipation rate varepsilon from the Kolmogorov (1941) theory, Lilly (1966) was able to derive a value of","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"C_s = left( frac32C_Kpi^frac43 right)^-frac34 approx 016  ","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"using an empirical value of C_K approx 16 for the Kolmogorov constant. This seems reasonable for isotropic turbulence if the grid spacing Delta falls in the inertial range. In practice, C_s is a tunable parameter.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"Due to the presence of the constant C_s, the model is sometimes referred to as the constant Smagorinsky model in contrast to dynamic Smagorinsky models that dynamically compute C_s to account for effects such as buoyant convection.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#Anisotropic-minimum-dissipation-models","page":"Large eddy simulation","title":"Anisotropic minimum dissipation models","text":"","category":"section"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"Minimum-dissipation eddy-viscosity models are a class of LES closures that use the minimum eddy dissipation required to dissipate the energy of sub-grid scale motion. Rozema et al. (2015) proposed the first minimum-dissipation model appropriate for use on anisotropic grids, termed the anisotropic minimum dissipation (AMD) model.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"It has a number of desirable properties over Smagorinsky-type closures: it is more cost-effective than dynamic Smagorinsky, it appropriately switches off in laminar and transitional flows, and it is consistent with the exact SGS stress tensor on both isotropic and anisotropic grids. Abkar et al. (2016) extended the AMD model to model SGS scalar fluxes for tracer transport. Abkar and Moin (2017) further extended the model to include a buoyancy term that accounts for the contribution of buoyant forces to the production and suppression of turbulence.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"Vreugdenhil and Taylor (2018) derive a modified AMD model by following the requirement suggested by Verstappen (2018), which entail normalising the displacement, the velocity, and the velocity gradient by the filter width to ensure that the resulting eddy dissipation properly counteracts the spurious kinetic energy transferred by convective nonlinearity, to derive a modified AMD model.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"The eddy viscosity and diffusivity are defined in terms of eddy viscosity and diffusivity predictors nu_e^dagger and kappa_e^dagger, such that","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"nu_e = max lbrace 0 nu_e^dagger rbrace\nquad textand quad\nkappa_e = max lbrace 0 kappa_e^dagger rbrace  ","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"to ensure that nu_e ge 0 and kappa_e ge 0. Leaving out the overlines and understanding that all variables represent the resolved/filtered variables, the eddy viscosity predictor is given by","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"    beginequation\n    labeleqnu-dagger\n    nu_e^dagger = -(CDelta)^2\n      frac\n        left( hatpartial_k hatv_i right) left( hatpartial_k hatv_j right) hatS_ij\n        + C_bhatdelta_i3 alpha g left( hatpartial_k hatv_i right) hatpartial_k theta\n        left( hatpartial_l hatv_m right) left( hatpartial_l hatv_m right)  \n    endequation","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"and the eddy diffusivity predictor by","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"    beginequation\n    kappa_e^dagger = -(CDelta)^2\n    frac\n        left( hatpartial_k hatv_i right) left( hatpartial_k hattheta right) hatpartial_i theta\n        left( hatpartial_l hattheta right) left( hatpartial_l hattheta right)  \n    endequation","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"where","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"  beginequation\n  hatx_i = fracx_iDelta_i quad\n  hatv_i(hatx t) = fracv_i(x t)Delta_i quad\n  hatpartial_i hatv_j(hatx t) = fracDelta_iDelta_j partial_i v_j(x t) quad\n  hatdelta_i3 = fracdelta_i3Delta_3  \n  endequation","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"so that the normalized rate of strain tensor is","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"    beginequation\n    labeleqS-hat\n    hatS_ij =\n      frac12 left hatpartial_i hatv_j(hatx t) + hatpartial_j hatv_i(hatx t) right  \n    endequation","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"In equations \\eqref{eq:nu-dagger}–\\eqref{eq:S-hat}, C is a modified Poincaré \"constant\" that is independent from the filter width Delta but does depend on the accuracy of the discretization method used. Abkar et al. (2016) cite C^2 = frac112 for a spectral method and C^2 = frac13 for a second-order accurate scheme. Delta_i is the filter width in the x_i-direction, and Delta is given by the square root of the harmonic mean of the squares of the filter widths in each direction","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"    frac1Delta^2 = frac13 left( frac1Delta x^2 + frac1Delta y^2 + frac1Delta z^2 right)  ","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/","page":"Large eddy simulation","title":"Large eddy simulation","text":"The term multiplying C_b is the buoyancy modification introduced by Abkar and Moin (2017) and is small for weakly stratified flows. We have introduced the C_b constant so that the buoyancy modification term may be turned on and off.","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"EditURL = \"../../../examples/two_dimensional_turbulence.jl\"","category":"page"},{"location":"literated/two_dimensional_turbulence/#Two-dimensional-turbulence-example","page":"Two-dimensional turbulence","title":"Two dimensional turbulence example","text":"","category":"section"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"In this example, we initialize a random velocity field and observe its turbulent decay in a two-dimensional domain. This example demonstrates:","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"How to run a model with no tracers and no buoyancy model.\nHow to use computed Fields to generate output.","category":"page"},{"location":"literated/two_dimensional_turbulence/#Install-dependencies","page":"Two-dimensional turbulence","title":"Install dependencies","text":"","category":"section"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"using Pkg\npkg\"add Oceananigans, CairoMakie\"","category":"page"},{"location":"literated/two_dimensional_turbulence/#Model-setup","page":"Two-dimensional turbulence","title":"Model setup","text":"","category":"section"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"We instantiate the model with an isotropic diffusivity. We use a grid with 128² points, a fifth-order advection scheme, third-order Runge-Kutta time-stepping, and a small isotropic viscosity.  Note that we assign Flat to the z direction.","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"using Oceananigans\n\ngrid = RectilinearGrid(size=(128, 128), extent=(2π, 2π), topology=(Periodic, Periodic, Flat))\n\nmodel = NonhydrostaticModel(; grid,\n                            timestepper = :RungeKutta3,\n                            advection = UpwindBiasedFifthOrder(),\n                            closure = ScalarDiffusivity(ν=1e-5))","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\n├── grid: 128×128×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo\n├── timestepper: RungeKutta3TimeStepper\n├── advection scheme: FluxFormAdvection{3, Float64, UpwindBiased{3, Float64, Nothing, Nothing, Nothing, UpwindBiased{2, Float64, Nothing, Nothing, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{2, Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}}, UpwindBiased{3, Float64, Nothing, Nothing, Nothing, UpwindBiased{2, Float64, Nothing, Nothing, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{2, Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}}, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}}\n├── tracers: ()\n├── closure: ScalarDiffusivity{ExplicitTimeDiscretization}(ν=1.0e-5)\n├── buoyancy: Nothing\n└── coriolis: Nothing","category":"page"},{"location":"literated/two_dimensional_turbulence/#Random-initial-conditions","page":"Two-dimensional turbulence","title":"Random initial conditions","text":"","category":"section"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Our initial condition randomizes model.velocities.u and model.velocities.v. We ensure that both have zero mean for aesthetic reasons.","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"using Statistics\n\nu, v, w = model.velocities\n\nuᵢ = rand(size(u)...)\nvᵢ = rand(size(v)...)\n\nuᵢ .-= mean(uᵢ)\nvᵢ .-= mean(vᵢ)\n\nset!(model, u=uᵢ, v=vᵢ)","category":"page"},{"location":"literated/two_dimensional_turbulence/#Setting-up-a-simulation","page":"Two-dimensional turbulence","title":"Setting up a simulation","text":"","category":"section"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"We set-up a simulation that stops at 50 time units, with an initial time-step of 0.1, and with adaptive time-stepping and progress printing.","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"simulation = Simulation(model, Δt=0.2, stop_time=50)","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Simulation of NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\n├── Next time step: 200 ms\n├── Elapsed wall time: 0 seconds\n├── Wall time per iteration: NaN days\n├── Stop time: 50 seconds\n├── Stop iteration : Inf\n├── Wall time limit: Inf\n├── Callbacks: OrderedDict with 4 entries:\n│   ├── stop_time_exceeded => Callback of stop_time_exceeded on IterationInterval(1)\n│   ├── stop_iteration_exceeded => Callback of stop_iteration_exceeded on IterationInterval(1)\n│   ├── wall_time_limit_exceeded => Callback of wall_time_limit_exceeded on IterationInterval(1)\n│   └── nan_checker => Callback of NaNChecker for u on IterationInterval(100)\n├── Output writers: OrderedDict with no entries\n└── Diagnostics: OrderedDict with no entries","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"The TimeStepWizard helps ensure stable time-stepping with a Courant-Freidrichs-Lewy (CFL) number of 0.7.","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"wizard = TimeStepWizard(cfl=0.7, max_change=1.1, max_Δt=0.5)\nsimulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10))","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Callback of TimeStepWizard(cfl=0.7, max_Δt=0.5, min_Δt=0.0) on IterationInterval(10)","category":"page"},{"location":"literated/two_dimensional_turbulence/#Logging-simulation-progress","page":"Two-dimensional turbulence","title":"Logging simulation progress","text":"","category":"section"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"We set up a callback that logs the simulation iteration and time every 100 iterations.","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"using Printf\n\nfunction progress_message(sim)\n    max_abs_u = maximum(abs, sim.model.velocities.u)\n    walltime = prettytime(sim.run_wall_time)\n\n    return @info @sprintf(\"Iteration: %04d, time: %1.3f, Δt: %.2e, max(|u|) = %.1e, wall time: %s\\n\",\n                          iteration(sim), time(sim), sim.Δt, max_abs_u, walltime)\nend\n\nadd_callback!(simulation, progress_message, IterationInterval(100))","category":"page"},{"location":"literated/two_dimensional_turbulence/#Output","page":"Two-dimensional turbulence","title":"Output","text":"","category":"section"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"We set up an output writer for the simulation that saves vorticity and speed every 20 iterations.","category":"page"},{"location":"literated/two_dimensional_turbulence/#Computing-vorticity-and-speed","page":"Two-dimensional turbulence","title":"Computing vorticity and speed","text":"","category":"section"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"To make our equations prettier, we unpack u, v, and w from the NamedTuple model.velocities:","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"u, v, w = model.velocities","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"NamedTuple with 3 Fields on 128×128×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo:\n├── u: 128×128×1 Field{Face, Center, Center} on RectilinearGrid on CPU\n├── v: 128×128×1 Field{Center, Face, Center} on RectilinearGrid on CPU\n└── w: 128×128×1 Field{Center, Center, Face} on RectilinearGrid on CPU","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Next we create two Fields that calculate (i) vorticity that measures the rate at which the fluid rotates and is defined as","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"ω = _x v - _y u  ","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"ω = ∂x(v) - ∂y(u)","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"BinaryOperation at (Face, Face, Center)\n├── grid: 128×128×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo\n└── tree: \n    - at (Face, Face, Center)\n    ├── ∂xᶠᶠᶜ at (Face, Face, Center) via identity\n    │   └── 128×128×1 Field{Center, Face, Center} on RectilinearGrid on CPU\n    └── ∂yᶠᶠᶜ at (Face, Face, Center) via identity\n        └── 128×128×1 Field{Face, Center, Center} on RectilinearGrid on CPU","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"We also calculate (ii) the speed of the flow,","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"s = sqrtu^2 + v^2  ","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"s = sqrt(u^2 + v^2)","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"UnaryOperation at (Face, Center, Center)\n├── grid: 128×128×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo\n└── tree: \n    sqrt at (Face, Center, Center) via identity\n    └── + at (Face, Center, Center)\n        ├── ^ at (Face, Center, Center)\n        │   ├── 128×128×1 Field{Face, Center, Center} on RectilinearGrid on CPU\n        │   └── 2\n        └── ^ at (Center, Face, Center)\n            ├── 128×128×1 Field{Center, Face, Center} on RectilinearGrid on CPU\n            └── 2","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"We pass these operations to an output writer below to calculate and output them during the simulation.","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"filename = \"two_dimensional_turbulence\"\n\nsimulation.output_writers[:fields] = JLD2OutputWriter(model, (; ω, s),\n                                                      schedule = TimeInterval(0.6),\n                                                      filename = filename * \".jld2\",\n                                                      overwrite_existing = true)","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"JLD2OutputWriter scheduled on TimeInterval(600 ms):\n├── filepath: ./two_dimensional_turbulence.jld2\n├── 2 outputs: (ω, s)\n├── array type: Array{Float64}\n├── including: [:grid, :coriolis, :buoyancy, :closure]\n├── file_splitting: NoFileSplitting\n└── file size: 27.8 KiB","category":"page"},{"location":"literated/two_dimensional_turbulence/#Running-the-simulation","page":"Two-dimensional turbulence","title":"Running the simulation","text":"","category":"section"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Pretty much just","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"run!(simulation)","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"[ Info: Initializing simulation...\n[ Info: Iteration: 0000, time: 0.000, Δt: 1.00e-01, max(|u|) = 7.2e-01, wall time: 0 seconds\n[ Info:     ... simulation initialization complete (9.173 seconds)\n[ Info: Executing initial time step...\n[ Info:     ... initial time step complete (4.263 seconds).\n[ Info: Iteration: 0100, time: 6.557, Δt: 7.35e-02, max(|u|) = 2.8e-01, wall time: 14.606 seconds\n[ Info: Iteration: 0200, time: 13.800, Δt: 8.26e-02, max(|u|) = 3.1e-01, wall time: 15.838 seconds\n[ Info: Iteration: 0300, time: 21.160, Δt: 8.50e-02, max(|u|) = 3.0e-01, wall time: 16.826 seconds\n[ Info: Iteration: 0400, time: 28.800, Δt: 9.86e-02, max(|u|) = 2.7e-01, wall time: 17.702 seconds\n[ Info: Iteration: 0500, time: 36.905, Δt: 7.84e-02, max(|u|) = 2.9e-01, wall time: 18.596 seconds\n[ Info: Iteration: 0600, time: 44.852, Δt: 9.09e-02, max(|u|) = 2.7e-01, wall time: 19.542 seconds\n[ Info: Simulation is stopping after running for 20.186 seconds.\n[ Info: Simulation time 50 seconds equals or exceeds stop time 50 seconds.\n","category":"page"},{"location":"literated/two_dimensional_turbulence/#Visualizing-the-results","page":"Two-dimensional turbulence","title":"Visualizing the results","text":"","category":"section"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"We load the output.","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"ω_timeseries = FieldTimeSeries(filename * \".jld2\", \"ω\")\ns_timeseries = FieldTimeSeries(filename * \".jld2\", \"s\")\n\ntimes = ω_timeseries.times","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"0.0:0.6:49.8","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Construct the x y z grid for plotting purposes,","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"xω, yω, zω = nodes(ω_timeseries)\nxs, ys, zs = nodes(s_timeseries)","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"and animate the vorticity and fluid speed.","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"using CairoMakie\nset_theme!(Theme(fontsize = 24))\n\nfig = Figure(size = (800, 500))\n\naxis_kwargs = (xlabel = \"x\",\n               ylabel = \"y\",\n               limits = ((0, 2π), (0, 2π)),\n               aspect = AxisAspect(1))\n\nax_ω = Axis(fig[2, 1]; title = \"Vorticity\", axis_kwargs...)\nax_s = Axis(fig[2, 2]; title = \"Speed\", axis_kwargs...)","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"We use Makie's Observable to animate the data. To dive into how Observables work we refer to Makie.jl's Documentation.","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"n = Observable(1)","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Observable(1)\n","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Now let's plot the vorticity and speed.","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"ω = @lift ω_timeseries[$n]\ns = @lift s_timeseries[$n]\n\nheatmap!(ax_ω, ω; colormap = :balance, colorrange = (-2, 2))\nheatmap!(ax_s, s; colormap = :speed, colorrange = (0, 0.2))\n\ntitle = @lift \"t = \" * string(round(times[$n], digits=2))\nLabel(fig[1, 1:2], title, fontsize=24, tellwidth=false)\n\nfig","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"(Image: )","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Finally, we record a movie.","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"frames = 1:length(times)\n\n@info \"Making a neat animation of vorticity and speed...\"\n\nrecord(fig, filename * \".mp4\", frames, framerate=24) do i\n    n[] = i\nend","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"[ Info: Making a neat animation of vorticity and speed...\n","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"(Image: )","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"","category":"page"},{"location":"literated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"This page was generated using Literate.jl.","category":"page"},{"location":"physics/boundary_conditions/#Boundary-conditions","page":"Boundary conditions","title":"Boundary conditions","text":"","category":"section"},{"location":"physics/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Users may impose no-penetration, flux, gradient (Neumann), and value (Dirichlet) boundary conditions in bounded, non-periodic directions. Note that the only boundary condition available for a velocity field normal to the bounded direction is no-penetration.","category":"page"},{"location":"physics/boundary_conditions/#Flux-boundary-conditions","page":"Boundary conditions","title":"Flux boundary conditions","text":"","category":"section"},{"location":"physics/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"A flux boundary condition prescribes flux of a quantity normal to the boundary.   For a tracer c this corresponds to prescribing","category":"page"},{"location":"physics/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"q_c  _b equiv boldsymbolq_c boldsymbolcdot hatboldsymboln  _partial Omega_b  ","category":"page"},{"location":"physics/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"where partial Omega_b is an external boundary.","category":"page"},{"location":"physics/boundary_conditions/#Gradient-(Neumann)-boundary-condition","page":"Boundary conditions","title":"Gradient (Neumann) boundary condition","text":"","category":"section"},{"location":"physics/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"A gradient boundary condition prescribes the gradient of a field normal to the boundary. For a tracer c this prescribes","category":"page"},{"location":"physics/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"gamma equiv boldsymbolnabla c boldsymbolcdot hatboldsymboln  _partial Omega_b  ","category":"page"},{"location":"physics/boundary_conditions/#Value-(Dirichlet)-boundary-condition","page":"Boundary conditions","title":"Value (Dirichlet) boundary condition","text":"","category":"section"},{"location":"physics/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"A value boundary condition prescribes the value of a field on a boundary; for a tracer this prescribes","category":"page"},{"location":"physics/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"c_b equiv c  _partial Omega_b  ","category":"page"},{"location":"physics/boundary_conditions/#No-penetration-boundary-condition","page":"Boundary conditions","title":"No penetration boundary condition","text":"","category":"section"},{"location":"physics/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"A no penetration boundary condition prescribes the velocity component normal to a boundary to be 0, so that","category":"page"},{"location":"physics/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"boldsymbolhatn boldsymbolcdot boldsymbolv  _partial Omega_b = 0  ","category":"page"},{"location":"appendix/fractional_step/#fractional_step_method","page":"Fractional step method","title":"Fractional step method","text":"","category":"section"},{"location":"appendix/fractional_step/","page":"Fractional step method","title":"Fractional step method","text":"In some models (e.g., NonhydrostaticModel or HydrostaticFreeSurfaceModel) solving the momentum  coupled with the continuity equation can be cumbersome so instead we employ a fractional step  method. To approximate the solution of the coupled system we first solve an approximation to  the discretized momentum equation for an intermediate velocity field boldsymbolv^star  without worrying about satisfying the incompressibility constraint. We then project boldsymbolv^star  onto the space of divergence-free velocity fields to obtain a value for boldsymbolv^n+1  that satisfies continuity.","category":"page"},{"location":"appendix/fractional_step/","page":"Fractional step method","title":"Fractional step method","text":"For example, for the NonhydrostaticModel, if we ignore the background velocity fields and the surface waves, we thus discretize the momentum equation as","category":"page"},{"location":"appendix/fractional_step/","page":"Fractional step method","title":"Fractional step method","text":"  fracboldsymbolv^star - boldsymbolv^nDelta t\n    = - left boldsymbolv boldsymbolcdot boldsymbolnabla boldsymbolv right^n+frac12\n      - boldsymbolf times boldsymbolv^n+frac12\n      + boldsymbolnabla boldsymbolcdot left ( nu boldsymbolnabla boldsymbolv^n+frac12 right )\n      + boldsymbolF_boldsymbolv^n+frac12  ","category":"page"},{"location":"appendix/fractional_step/","page":"Fractional step method","title":"Fractional step method","text":"where the superscript n + frac12 indicates that these terms are evaluated at time step  n + frac12, which we compute explicitly (see Time-stepping section).","category":"page"},{"location":"appendix/fractional_step/","page":"Fractional step method","title":"Fractional step method","text":"The projection is then performed","category":"page"},{"location":"appendix/fractional_step/","page":"Fractional step method","title":"Fractional step method","text":"   boldsymbolv^n+1 = boldsymbolv^star - Delta t  boldsymbolnabla p^n+1  ","category":"page"},{"location":"appendix/fractional_step/","page":"Fractional step method","title":"Fractional step method","text":"to obtain a divergence-free velocity field boldsymbolv^n+1. Here the projection is performed by solving an elliptic problem for the pressure p^n+1 with the boundary condition","category":"page"},{"location":"appendix/fractional_step/","page":"Fractional step method","title":"Fractional step method","text":"  boldsymbolhatn boldsymbolcdot boldsymbolnabla p^n+1 _partialOmega = 0  ","category":"page"},{"location":"appendix/fractional_step/","page":"Fractional step method","title":"Fractional step method","text":"Orszag et al. (1986) and Brown et al. (2001) raise an important issue regarding these fractional step  methods, which is that \"while the velocity can be reliably computed to second-order accuracy  in time and space, the pressure is typically only first-order accurate in the L_infty-norm.\"  The numerical boundary conditions must be carefully accounted for to ensure the second-order  accuracy promised by the fractional step methods.","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"EditURL = \"../../../examples/baroclinic_adjustment.jl\"","category":"page"},{"location":"literated/baroclinic_adjustment/#Baroclinic-adjustment","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"","category":"section"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"In this example, we simulate the evolution and equilibration of a baroclinically unstable front.","category":"page"},{"location":"literated/baroclinic_adjustment/#Install-dependencies","page":"Baroclinic adjustment","title":"Install dependencies","text":"","category":"section"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"using Pkg\npkg\"add Oceananigans, CairoMakie\"","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"using Oceananigans\nusing Oceananigans.Units","category":"page"},{"location":"literated/baroclinic_adjustment/#Grid","page":"Baroclinic adjustment","title":"Grid","text":"","category":"section"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"We use a three-dimensional channel that is periodic in the x direction:","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"Lx = 1000kilometers # east-west extent [m]\nLy = 1000kilometers # north-south extent [m]\nLz = 1kilometers    # depth [m]\n\ngrid = RectilinearGrid(size = (48, 48, 8),\n                       x = (0, Lx),\n                       y = (-Ly/2, Ly/2),\n                       z = (-Lz, 0),\n                       topology = (Periodic, Bounded, Bounded))","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"48×48×8 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3×3×3 halo\n├── Periodic x ∈ [0.0, 1.0e6)          regularly spaced with Δx=20833.3\n├── Bounded  y ∈ [-500000.0, 500000.0] regularly spaced with Δy=20833.3\n└── Bounded  z ∈ [-1000.0, 0.0]        regularly spaced with Δz=125.0","category":"page"},{"location":"literated/baroclinic_adjustment/#Model","page":"Baroclinic adjustment","title":"Model","text":"","category":"section"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"We built a HydrostaticFreeSurfaceModel with an ImplicitFreeSurface solver. Regarding Coriolis, we use a beta-plane centered at 45° South.","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"model = HydrostaticFreeSurfaceModel(; grid,\n                                    coriolis = BetaPlane(latitude = -45),\n                                    buoyancy = BuoyancyTracer(),\n                                    tracers = :b,\n                                    momentum_advection = WENO(),\n                                    tracer_advection = WENO())","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"HydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\n├── grid: 48×48×8 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3×3×3 halo\n├── timestepper: QuasiAdamsBashforth2TimeStepper\n├── tracers: b\n├── closure: Nothing\n├── buoyancy: BuoyancyTracer with ĝ = NegativeZDirection()\n├── free surface: ImplicitFreeSurface with gravitational acceleration 9.80665 m s⁻²\n│   └── solver: FFTImplicitFreeSurfaceSolver\n├── advection scheme: \n│   ├── momentum: WENO reconstruction order 5\n│   └── b: WENO reconstruction order 5\n└── coriolis: BetaPlane{Float64}","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"We start our simulation from rest with a baroclinically unstable buoyancy distribution. We use ramp(y, Δy), defined below, to specify a front with width Δy and horizontal buoyancy gradient M². We impose the front on top of a vertical buoyancy gradient N² and a bit of noise.","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"\"\"\"\n    ramp(y, Δy)\n\nLinear ramp from 0 to 1 between -Δy/2 and +Δy/2.\n\nFor example:\n```\n            y < -Δy/2 => ramp = 0\n    -Δy/2 < y < -Δy/2 => ramp = y / Δy\n            y >  Δy/2 => ramp = 1\n```\n\"\"\"\nramp(y, Δy) = min(max(0, y/Δy + 1/2), 1)\n\nN² = 1e-5 # [s⁻²] buoyancy frequency / stratification\nM² = 1e-7 # [s⁻²] horizontal buoyancy gradient\n\nΔy = 100kilometers # width of the region of the front\nΔb = Δy * M²       # buoyancy jump associated with the front\nϵb = 1e-2 * Δb     # noise amplitude\n\nbᵢ(x, y, z) = N² * z + Δb * ramp(y, Δy) + ϵb * randn()\n\nset!(model, b=bᵢ)","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"Let's visualize the initial buoyancy distribution.","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"using CairoMakie\n\n# Build coordinates with units of kilometers\nx, y, z = 1e-3 .* nodes(grid, (Center(), Center(), Center()))\n\nb = model.tracers.b\n\nfig, ax, hm = heatmap(view(b, 1, :, :),\n                      colormap = :deep,\n                      axis = (xlabel = \"y [km]\",\n                              ylabel = \"z [km]\",\n                              title = \"b(x=0, y, z, t=0)\",\n                              titlesize = 24))\n\nColorbar(fig[1, 2], hm, label = \"[m s⁻²]\")\n\nfig","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"(Image: )","category":"page"},{"location":"literated/baroclinic_adjustment/#Simulation","page":"Baroclinic adjustment","title":"Simulation","text":"","category":"section"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"Now let's build a Simulation.","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"simulation = Simulation(model, Δt=20minutes, stop_time=20days)","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"Simulation of HydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\n├── Next time step: 20 minutes\n├── Elapsed wall time: 0 seconds\n├── Wall time per iteration: NaN days\n├── Stop time: 20 days\n├── Stop iteration : Inf\n├── Wall time limit: Inf\n├── Callbacks: OrderedDict with 4 entries:\n│   ├── stop_time_exceeded => Callback of stop_time_exceeded on IterationInterval(1)\n│   ├── stop_iteration_exceeded => Callback of stop_iteration_exceeded on IterationInterval(1)\n│   ├── wall_time_limit_exceeded => Callback of wall_time_limit_exceeded on IterationInterval(1)\n│   └── nan_checker => Callback of NaNChecker for u on IterationInterval(100)\n├── Output writers: OrderedDict with no entries\n└── Diagnostics: OrderedDict with no entries","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"We add a TimeStepWizard callback to adapt the simulation's time-step,","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"conjure_time_step_wizard!(simulation, IterationInterval(20), cfl=0.2, max_Δt=20minutes)","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"Also, we add a callback to print a message about how the simulation is going,","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"using Printf\n\nwall_clock = Ref(time_ns())\n\nfunction print_progress(sim)\n    u, v, w = model.velocities\n    progress = 100 * (time(sim) / sim.stop_time)\n    elapsed = (time_ns() - wall_clock[]) / 1e9\n\n    @printf(\"[%05.2f%%] i: %d, t: %s, wall time: %s, max(u): (%6.3e, %6.3e, %6.3e) m/s, next Δt: %s\\n\",\n            progress, iteration(sim), prettytime(sim), prettytime(elapsed),\n            maximum(abs, u), maximum(abs, v), maximum(abs, w), prettytime(sim.Δt))\n\n    wall_clock[] = time_ns()\n\n    return nothing\nend\n\nadd_callback!(simulation, print_progress, IterationInterval(100))","category":"page"},{"location":"literated/baroclinic_adjustment/#Diagnostics/Output","page":"Baroclinic adjustment","title":"Diagnostics/Output","text":"","category":"section"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"Here, we save the buoyancy, b, at the edges of our domain as well as the zonal (x) average of buoyancy.","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"u, v, w = model.velocities\nζ = ∂x(v) - ∂y(u)\nB = Average(b, dims=1)\nU = Average(u, dims=1)\nV = Average(v, dims=1)\n\nfilename = \"baroclinic_adjustment\"\nsave_fields_interval = 0.5day\n\nslicers = (east = (grid.Nx, :, :),\n           north = (:, grid.Ny, :),\n           bottom = (:, :, 1),\n           top = (:, :, grid.Nz))\n\nfor side in keys(slicers)\n    indices = slicers[side]\n\n    simulation.output_writers[side] = JLD2OutputWriter(model, (; b, ζ);\n                                                       filename = filename * \"_$(side)_slice\",\n                                                       schedule = TimeInterval(save_fields_interval),\n                                                       overwrite_existing = true,\n                                                       indices)\nend\n\nsimulation.output_writers[:zonal] = JLD2OutputWriter(model, (; b=B, u=U, v=V);\n                                                     filename = filename * \"_zonal_average\",\n                                                     schedule = TimeInterval(save_fields_interval),\n                                                     overwrite_existing = true)","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"JLD2OutputWriter scheduled on TimeInterval(12 hours):\n├── filepath: ./baroclinic_adjustment_zonal_average.jld2\n├── 3 outputs: (b, u, v)\n├── array type: Array{Float64}\n├── including: [:grid, :coriolis, :buoyancy, :closure]\n├── file_splitting: NoFileSplitting\n└── file size: 30.7 KiB","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"Now we're ready to run.","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"@info \"Running the simulation...\"\n\nrun!(simulation)\n\n@info \"Simulation completed in \" * prettytime(simulation.run_wall_time)","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"[ Info: Running the simulation...\n[ Info: Initializing simulation...\n[00.00%] i: 0, t: 0 seconds, wall time: 22.077 seconds, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 20 minutes\n[ Info:     ... simulation initialization complete (23.642 seconds)\n[ Info: Executing initial time step...\n[ Info:     ... initial time step complete (18.396 seconds).\n[06.94%] i: 100, t: 1.389 days, wall time: 33.967 seconds, max(u): (1.280e-01, 1.136e-01, 1.657e-03) m/s, next Δt: 20 minutes\n[13.89%] i: 200, t: 2.778 days, wall time: 1.026 seconds, max(u): (2.171e-01, 1.754e-01, 1.674e-03) m/s, next Δt: 20 minutes\n[20.83%] i: 300, t: 4.167 days, wall time: 1.056 seconds, max(u): (2.984e-01, 2.673e-01, 1.726e-03) m/s, next Δt: 20 minutes\n[27.78%] i: 400, t: 5.556 days, wall time: 1.061 seconds, max(u): (3.945e-01, 4.110e-01, 2.081e-03) m/s, next Δt: 20 minutes\n[34.72%] i: 500, t: 6.944 days, wall time: 984.872 ms, max(u): (4.916e-01, 5.529e-01, 2.481e-03) m/s, next Δt: 20 minutes\n[41.67%] i: 600, t: 8.333 days, wall time: 988.984 ms, max(u): (6.150e-01, 7.730e-01, 2.712e-03) m/s, next Δt: 20 minutes\n[48.61%] i: 700, t: 9.722 days, wall time: 1.096 seconds, max(u): (9.211e-01, 1.046e+00, 3.847e-03) m/s, next Δt: 20 minutes\n[55.56%] i: 800, t: 11.111 days, wall time: 1.009 seconds, max(u): (1.313e+00, 1.186e+00, 4.501e-03) m/s, next Δt: 20 minutes\n[62.50%] i: 900, t: 12.500 days, wall time: 890.399 ms, max(u): (1.351e+00, 1.085e+00, 4.132e-03) m/s, next Δt: 20 minutes\n[69.44%] i: 1000, t: 13.889 days, wall time: 1.038 seconds, max(u): (1.299e+00, 9.991e-01, 4.373e-03) m/s, next Δt: 20 minutes\n[76.39%] i: 1100, t: 15.278 days, wall time: 981.375 ms, max(u): (1.538e+00, 9.450e-01, 3.371e-03) m/s, next Δt: 20 minutes\n[83.33%] i: 1200, t: 16.667 days, wall time: 988.196 ms, max(u): (1.354e+00, 1.047e+00, 3.751e-03) m/s, next Δt: 20 minutes\n[90.28%] i: 1300, t: 18.056 days, wall time: 882.888 ms, max(u): (1.381e+00, 9.728e-01, 2.937e-03) m/s, next Δt: 20 minutes\n[97.22%] i: 1400, t: 19.444 days, wall time: 998.971 ms, max(u): (1.377e+00, 1.192e+00, 2.616e-03) m/s, next Δt: 20 minutes\n[ Info: Simulation is stopping after running for 1.002 minutes.\n[ Info: Simulation time 20 days equals or exceeds stop time 20 days.\n[ Info: Simulation completed in 1.003 minutes\n","category":"page"},{"location":"literated/baroclinic_adjustment/#Visualization","page":"Baroclinic adjustment","title":"Visualization","text":"","category":"section"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"All that's left is to make a pretty movie. Actually, we make two visualizations here. First, we illustrate how to make a 3D visualization with Makie's Axis3 and Makie.surface. Then we make a movie in 2D. We use CairoMakie in this example, but note that using GLMakie is more convenient on a system with OpenGL, as figures will be displayed on the screen.","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"using CairoMakie","category":"page"},{"location":"literated/baroclinic_adjustment/#Three-dimensional-visualization","page":"Baroclinic adjustment","title":"Three-dimensional visualization","text":"","category":"section"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"We load the saved buoyancy output on the top, north, and east surface as FieldTimeSerieses.","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"filename = \"baroclinic_adjustment\"\n\nsides = keys(slicers)\n\nslice_filenames = NamedTuple(side => filename * \"_$(side)_slice.jld2\" for side in sides)\n\nb_timeserieses = (east   = FieldTimeSeries(slice_filenames.east, \"b\"),\n                  north  = FieldTimeSeries(slice_filenames.north, \"b\"),\n                  top    = FieldTimeSeries(slice_filenames.top, \"b\"))\n\nB_timeseries = FieldTimeSeries(filename * \"_zonal_average.jld2\", \"b\")\n\ntimes = B_timeseries.times\ngrid = B_timeseries.grid","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"48×48×8 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3×3×3 halo\n├── Periodic x ∈ [0.0, 1.0e6)          regularly spaced with Δx=20833.3\n├── Bounded  y ∈ [-500000.0, 500000.0] regularly spaced with Δy=20833.3\n└── Bounded  z ∈ [-1000.0, 0.0]        regularly spaced with Δz=125.0","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"We build the coordinates. We rescale horizontal coordinates to kilometers.","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"xb, yb, zb = nodes(b_timeserieses.east)\n\nxb = xb ./ 1e3 # convert m -> km\nyb = yb ./ 1e3 # convert m -> km\n\nNx, Ny, Nz = size(grid)\n\nx_xz = repeat(x, 1, Nz)\ny_xz_north = y[end] * ones(Nx, Nz)\nz_xz = repeat(reshape(z, 1, Nz), Nx, 1)\n\nx_yz_east = x[end] * ones(Ny, Nz)\ny_yz = repeat(y, 1, Nz)\nz_yz = repeat(reshape(z, 1, Nz), grid.Ny, 1)\n\nx_xy = x\ny_xy = y\nz_xy_top = z[end] * ones(grid.Nx, grid.Ny)","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"Then we create a 3D axis. We use zonal_slice_displacement to control where the plot of the instantaneous zonal average flow is located.","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"fig = Figure(size = (1600, 800))\n\nzonal_slice_displacement = 1.2\n\nax = Axis3(fig[2, 1],\n           aspect=(1, 1, 1/5),\n           xlabel = \"x (km)\",\n           ylabel = \"y (km)\",\n           zlabel = \"z (m)\",\n           xlabeloffset = 100,\n           ylabeloffset = 100,\n           zlabeloffset = 100,\n           limits = ((x[1], zonal_slice_displacement * x[end]), (y[1], y[end]), (z[1], z[end])),\n           elevation = 0.45,\n           azimuth = 6.8,\n           xspinesvisible = false,\n           zgridvisible = false,\n           protrusions = 40,\n           perspectiveness = 0.7)","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"Axis3()","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"We use data from the final savepoint for the 3D plot. Note that this plot can easily be animated by using Makie's Observable. To dive into Observables, check out Makie.jl's Documentation.","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"n = length(times)","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"41","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"Now let's make a 3D plot of the buoyancy and in front of it we'll use the zonally-averaged output to plot the instantaneous zonal-average of the buoyancy.","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"b_slices = (east   = interior(b_timeserieses.east[n], 1, :, :),\n            north  = interior(b_timeserieses.north[n], :, 1, :),\n            top    = interior(b_timeserieses.top[n], :, :, 1))\n\n# Zonally-averaged buoyancy\nB = interior(B_timeseries[n], 1, :, :)\n\nclims = 1.1 .* extrema(b_timeserieses.top[n][:])\n\nkwargs = (colorrange=clims, colormap=:deep, shading=NoShading)\n\nsurface!(ax, x_yz_east, y_yz, z_yz;  color = b_slices.east, kwargs...)\nsurface!(ax, x_xz, y_xz_north, z_xz; color = b_slices.north, kwargs...)\nsurface!(ax, x_xy, y_xy, z_xy_top;   color = b_slices.top, kwargs...)\n\nsf = surface!(ax, zonal_slice_displacement .* x_yz_east, y_yz, z_yz; color = B, kwargs...)\n\ncontour!(ax, y, z, B; transformation = (:yz, zonal_slice_displacement * x[end]),\n         levels = 15, linewidth = 2, color = :black)\n\nColorbar(fig[2, 2], sf, label = \"m s⁻²\", height = Relative(0.4), tellheight=false)\n\ntitle = \"Buoyancy at t = \" * string(round(times[n] / day, digits=1)) * \" days\"\nfig[1, 1:2] = Label(fig, title; fontsize = 24, tellwidth = false, padding = (0, 0, -120, 0))\n\nrowgap!(fig.layout, 1, Relative(-0.2))\ncolgap!(fig.layout, 1, Relative(-0.1))\n\nsave(\"baroclinic_adjustment_3d.png\", fig)","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"(Image: )","category":"page"},{"location":"literated/baroclinic_adjustment/#Two-dimensional-movie","page":"Baroclinic adjustment","title":"Two-dimensional movie","text":"","category":"section"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"We make a 2D movie that shows buoyancy b and vertical vorticity ζ at the surface, as well as the zonally-averaged zonal and meridional velocities U and V in the (y z) plane. First we load the FieldTimeSeries and extract the additional coordinates we'll need for plotting","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"ζ_timeseries = FieldTimeSeries(slice_filenames.top, \"ζ\")\nU_timeseries = FieldTimeSeries(filename * \"_zonal_average.jld2\", \"u\")\nB_timeseries = FieldTimeSeries(filename * \"_zonal_average.jld2\", \"b\")\nV_timeseries = FieldTimeSeries(filename * \"_zonal_average.jld2\", \"v\")\n\nxζ, yζ, zζ = nodes(ζ_timeseries)\nyv = ynodes(V_timeseries)\n\nxζ = xζ ./ 1e3 # convert m -> km\nyζ = yζ ./ 1e3 # convert m -> km\nyv = yv ./ 1e3 # convert m -> km","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"49-element Vector{Float64}:\n -500.0\n -479.1666666666667\n -458.3333333333333\n -437.5\n -416.6666666666667\n -395.8333333333333\n -375.0\n -354.1666666666667\n -333.3333333333333\n -312.5\n -291.6666666666667\n -270.8333333333333\n -250.0\n -229.16666666666666\n -208.33333333333334\n -187.5\n -166.66666666666666\n -145.83333333333334\n -125.0\n -104.16666666666667\n  -83.33333333333333\n  -62.5\n  -41.666666666666664\n  -20.833333333333332\n    0.0\n   20.833333333333332\n   41.666666666666664\n   62.5\n   83.33333333333333\n  104.16666666666667\n  125.0\n  145.83333333333334\n  166.66666666666666\n  187.5\n  208.33333333333334\n  229.16666666666666\n  250.0\n  270.8333333333333\n  291.6666666666667\n  312.5\n  333.3333333333333\n  354.1666666666667\n  375.0\n  395.8333333333333\n  416.6666666666667\n  437.5\n  458.3333333333333\n  479.1666666666667\n  500.0","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"Next, we set up a plot with 4 panels. The top panels are large and square, while the bottom panels get a reduced aspect ratio through rowsize!.","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"set_theme!(Theme(fontsize=24))\n\nfig = Figure(size=(1800, 1000))\n\naxb = Axis(fig[1, 2], xlabel=\"x (km)\", ylabel=\"y (km)\", aspect=1)\naxζ = Axis(fig[1, 3], xlabel=\"x (km)\", ylabel=\"y (km)\", aspect=1, yaxisposition=:right)\n\naxu = Axis(fig[2, 2], xlabel=\"y (km)\", ylabel=\"z (m)\")\naxv = Axis(fig[2, 3], xlabel=\"y (km)\", ylabel=\"z (m)\", yaxisposition=:right)\n\nrowsize!(fig.layout, 2, Relative(0.3))","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"To prepare a plot for animation, we index the timeseries with an Observable,","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"n = Observable(1)\n\nb_top = @lift interior(b_timeserieses.top[$n], :, :, 1)\nζ_top = @lift interior(ζ_timeseries[$n], :, :, 1)\nU = @lift interior(U_timeseries[$n], 1, :, :)\nV = @lift interior(V_timeseries[$n], 1, :, :)\nB = @lift interior(B_timeseries[$n], 1, :, :)","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"Observable([-0.009375745815438158 -0.008110486560734714 -0.006845445851007245 -0.00560989774611479 -0.004410962191820233 -0.003132546265302069 -0.0018767858151831635 -0.0006083072196331408; -0.009359871654194794 -0.008125048453760244 -0.006850075254976443 -0.00562121552228241 -0.00436689614991329 -0.0031452345032862146 -0.0018846723485935728 -0.0006232382713378319; -0.00936532432107848 -0.008100672727044895 -0.00686243874276531 -0.0056295829791514485 -0.004383225509308261 -0.0031194858537667487 -0.0018863111228592556 -0.0006054562278148614; -0.009375260848678069 -0.008123498897139644 -0.006895939018947077 -0.00558490517866998 -0.004369359449900168 -0.00312113609311932 -0.001868720387329567 -0.0006388848250287207; -0.009393316405862108 -0.008120451707531975 -0.006860282836922985 -0.0056269709968609985 -0.00436466901647833 -0.0031171573647172045 -0.0018791417095764065 -0.0006455429556166975; -0.009366554833854056 -0.00813891979506512 -0.006871317951225648 -0.0055973117415044115 -0.004382222133761785 -0.0031127911724267263 -0.0018625511591681663 -0.0006036336795420949; -0.009390220873853836 -0.00812607837846545 -0.006860433241376036 -0.00566006633752289 -0.004385556848062567 -0.0031048874826156894 -0.00185897067625734 -0.0006442898805187887; -0.009387900187016027 -0.008133107299198463 -0.006883311859200501 -0.005637474124243778 -0.004390886257976904 -0.003133620423123981 -0.0019154416194635156 -0.000613893368327405; -0.009376322352776335 -0.00814280680890894 -0.006854285718656469 -0.005618666500569487 -0.004372345498078622 -0.003104133659223718 -0.001873593692636493 -0.0006157300938435269; -0.00935852846825302 -0.008168529623123899 -0.006872680113442449 -0.005624639899327989 -0.004369544608534975 -0.003108748006382571 -0.001890302597012137 -0.000630373523538932; -0.009365058824539188 -0.008121346971957573 -0.00687246821445209 -0.005609517199468568 -0.0043636592491659585 -0.0031323247121971087 -0.001875318111298839 -0.0006296362622120675; -0.009362673552677987 -0.008140353859245287 -0.006864027427592435 -0.0056296447300420984 -0.004358614620989847 -0.003123684918193237 -0.0018778650429297622 -0.0006226654412235946; -0.009367173105050646 -0.008159151218571322 -0.0069020867723195755 -0.005637928217141922 -0.004345157702390767 -0.003123768958191022 -0.0018632067562196254 -0.0006510235870483116; -0.009364743054632358 -0.008131095103135066 -0.006869519705957619 -0.00564831171468629 -0.004381273176422837 -0.0031352537900093905 -0.001880380370558679 -0.0006266431521084576; -0.009364158254053017 -0.008134771445735406 -0.006879356316501144 -0.005634371118263791 -0.004368857736317114 -0.003139006923989741 -0.0018732374879732294 -0.000621620532894376; -0.009364483042269918 -0.008139536137702111 -0.00688306097099783 -0.005626942654587643 -0.004384324318538657 -0.00308899694583793 -0.0018964308363897953 -0.0006313905002864165; -0.009384792530385126 -0.008125235100559477 -0.006886526121369513 -0.005624674706819602 -0.004378422303486636 -0.0031663794975801355 -0.001857756539946581 -0.000626297759500547; -0.009384635661844323 -0.008143212406178926 -0.006885479396155476 -0.005624456319293862 -0.004327439116694219 -0.0031568361885686395 -0.0018623254933492668 -0.0006149940881728331; -0.009387569778085436 -0.008132887869802374 -0.006858929940406727 -0.0056555449849575124 -0.004372185199894162 -0.0031277394037456563 -0.0018876161573612774 -0.0006238365356934786; -0.009364485859489171 -0.008097912772217502 -0.006870395906679813 -0.005629197694839387 -0.004349661229334422 -0.00311987979267539 -0.0018900422238316335 -0.000623150515360981; -0.009367703909600435 -0.008160834543118424 -0.006883208055994887 -0.0056344818391748765 -0.004388976269260395 -0.003109932896106783 -0.0018904206989471385 -0.0006149766549031352; -0.009354038598828374 -0.00813687127725716 -0.00688174506812118 -0.005634801572834765 -0.00439767681921471 -0.0031185436010942326 -0.001882332573391855 -0.0006165576382823706; -0.007500220184397422 -0.00625256401084016 -0.004998803098954661 -0.003746901040177215 -0.0024744775668372057 -0.0012295518654582788 -5.78334700866714e-6 0.0012277840766442593; -0.005414062214526692 -0.004187804848750353 -0.002929172347898031 -0.0016804106753660634 -0.0004215452393054868 0.0008347638786392143 0.0020863729482395142 0.003337252996079844; -0.0033454053327159443 -0.0020958035983693678 -0.00084311456713269 0.00041210911856422633 0.0016561994132033636 0.002923057491683756 0.004172945823198816 0.005401282350000256; -0.0012485907111592478 -2.2818828286904014e-5 0.0012200900563916698 0.0024605386652325144 0.0037441724915635573 0.005014752461326151 0.006233233076793303 0.007522253625498007; 0.0006235602070499439 0.001872798537831855 0.003117208858651903 0.00437838066629703 0.005634022905016395 0.006844204082161763 0.008124929656260238 0.009355186511348389; 0.0006146720564517719 0.001868654860664119 0.0031326106277873252 0.0043776192881010015 0.005629107929052531 0.006882478388954565 0.008163976276552035 0.009381233819628342; 0.0006243921514366909 0.0018799337367011112 0.0031284412817577396 0.0043734110437152725 0.005613028350625419 0.006881712942467211 0.00814158166368797 0.009348354467068885; 0.0006188913389557675 0.0018857708495039185 0.003102331226372259 0.004379636759166458 0.005638026488978545 0.006875026206063916 0.008122610546883383 0.009368283593191036; 0.0006235866689465324 0.0018888327837193787 0.0031176402919384292 0.004401794328302835 0.005654373382644298 0.006858552909529569 0.008133619098386302 0.009369519504332931; 0.0006046629225759673 0.0018607816022560442 0.003130824737315323 0.004367000973646088 0.005617276938728944 0.006859491436655471 0.008123865541359304 0.0093724177003291; 0.0006358069707892536 0.0018852710745065452 0.0031207438016164473 0.004362229985755234 0.005618528532762178 0.006888076485708769 0.008132659683145528 0.009403004388368661; 0.0006418895849783833 0.001868595172102942 0.0031104866659571588 0.0043707825575151965 0.005636398639406887 0.006871572527067473 0.008119854666645734 0.009378838325611085; 0.000608905954691789 0.0018914904393547627 0.0031424366141812447 0.004350317821129356 0.005649108134262883 0.006874508686461958 0.008122244748893845 0.009368477037017514; 0.0006175399862168376 0.0018800028291802284 0.0031381054575252026 0.004389412362569334 0.005647986222172409 0.006889922926559144 0.008107569681557038 0.009353466243996245; 0.0006256401677608555 0.0018774916628892622 0.0030950829774655663 0.004358238223589297 0.005623280464637711 0.006859181842111335 0.00810727013165812 0.00940548813354671; 0.0006364049371862405 0.001869256436146497 0.003141286595332374 0.004398250470172555 0.005628279693366835 0.006861540665524184 0.008121721843466823 0.009369392459436805; 0.0006350309108886822 0.0018367642527267007 0.0031007026867615113 0.004332448749027486 0.0056422034305784125 0.006864557209798553 0.008150066303071427 0.009382298819106382; 0.0006539949146287797 0.0018573177168026006 0.0031633414053676575 0.004390357775789246 0.005619358110052714 0.006889716403189666 0.008109658193003454 0.009385600028223693; 0.0006099445945508403 0.001871986423431964 0.003120303497644125 0.004374588177453027 0.00562825283387982 0.006872618826137648 0.008112443853444328 0.00937065449349796; 0.0006265045983450063 0.0018675741206028624 0.0031220092398390243 0.004365955965877793 0.005618761271375487 0.006910714460768091 0.008143414484605706 0.00937749142132487; 0.000634261242736018 0.0018876514446321366 0.0031279757160750632 0.004374955238385325 0.005619864920970601 0.006877217730869699 0.00812191988445726 0.00938656021179173; 0.0006265475917805408 0.001872801317617757 0.0031426489661315546 0.004347714761423958 0.005592564788209131 0.006889785056728512 0.00812638424110245 0.009355331495590475; 0.0006483038292281706 0.0018588816804510518 0.0031445028328437063 0.00437269914075085 0.005615411973811889 0.006861413375187389 0.008131037218321683 0.009419367237839375; 0.0006151847567894695 0.0018711686317392096 0.0031137386696287843 0.00436706601390052 0.005605459795326934 0.006885365512789127 0.008125340434749535 0.00937704782450194; 0.0005941102243190278 0.0018724244469391195 0.003142064710938235 0.004389082547296163 0.005620694198667201 0.0068723711568145955 0.008119100659313998 0.009366543844072097; 0.0006053165753543525 0.0018955726400570402 0.003086933339505211 0.004360562591727884 0.005643732432242495 0.0068530991610138035 0.008123407734180957 0.009343153017449826])\n","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"and then build our plot:","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"hm = heatmap!(axb, xb, yb, b_top, colorrange=(0, Δb), colormap=:thermal)\nColorbar(fig[1, 1], hm, flipaxis=false, label=\"Surface b(x, y) (m s⁻²)\")\n\nhm = heatmap!(axζ, xζ, yζ, ζ_top, colorrange=(-5e-5, 5e-5), colormap=:balance)\nColorbar(fig[1, 4], hm, label=\"Surface ζ(x, y) (s⁻¹)\")\n\nhm = heatmap!(axu, yb, zb, U; colorrange=(-5e-1, 5e-1), colormap=:balance)\nColorbar(fig[2, 1], hm, flipaxis=false, label=\"Zonally-averaged U(y, z) (m s⁻¹)\")\ncontour!(axu, yb, zb, B; levels=15, color=:black)\n\nhm = heatmap!(axv, yv, zb, V; colorrange=(-1e-1, 1e-1), colormap=:balance)\nColorbar(fig[2, 4], hm, label=\"Zonally-averaged V(y, z) (m s⁻¹)\")\ncontour!(axv, yb, zb, B; levels=15, color=:black)","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"Finally, we're ready to record the movie.","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"frames = 1:length(times)\n\nrecord(fig, filename * \".mp4\", frames, framerate=8) do i\n    n[] = i\nend","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"(Image: )","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"","category":"page"},{"location":"literated/baroclinic_adjustment/","page":"Baroclinic adjustment","title":"Baroclinic adjustment","text":"This page was generated using Literate.jl.","category":"page"},{"location":"operations/#Operations-and-averaging","page":"Operations","title":"Operations and averaging","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"Fields are more than mere vessels for data. They come equipped with a powerful infrastructure for assembling expression trees that represent arithmetic and discrete calculus operations. We also supply a system for computing reductions (averages, integrals, and cumulative integrals) of Fields. This infrastructure can be used to construct initial conditions, set up diagnostic calculations that are performed and saved to disk while a simulation runs, and also for post-processing.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"We start by constructing a CenterField on a simple grid,","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"using Oceananigans\n\ngrid = RectilinearGrid(topology = (Periodic, Flat, Bounded),\n                       size = (4, 4),\n                       x = (0, 2π),\n                       z = (-4, 0))\n\nc = CenterField(grid)\n\nperiodic_but_decaying(x, z) = sin(x) * exp(z)\nset!(c, periodic_but_decaying)\n\n# output\n4×1×4 Field{Center, Center, Center} on RectilinearGrid on CPU\n├── grid: 4×1×4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo\n├── boundary conditions: FieldBoundaryConditions\n│   └── west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux\n└── data: 10×1×10 OffsetArray(::Array{Float64, 3}, -2:7, 1:1, -2:7) with eltype Float64 with indices -2:7×1:1×-2:7\n    └── max=0.428882, min=-0.428882, mean=1.04083e-17","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"An AbstractOperation (or operation for short) differs from a Field in that only represents a computation. Unlike Fields, AbstractOperations do not have any data, and are associated only with minimal memory allocation. AbstractOperations are generated by inflicting Fields with ordinary arithmetic expressions,","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"two_c = 2 * c\n\n# output\nBinaryOperation at (Center, Center, Center)\n├── grid: 4×1×4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo\n└── tree:\n    * at (Center, Center, Center)\n    ├── 2\n    └── 4×1×4 Field{Center, Center, Center} on RectilinearGrid on CPU","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"and even by chaining expressions together, which may themselves include AbstractOperations,","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"quadratic = c^2 + two_c + 1\n\n# output\nBinaryOperation at (Center, Center, Center)\n├── grid: 4×1×4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo\n└── tree:\n    + at (Center, Center, Center)\n    ├── + at (Center, Center, Center)\n    │   ├── ^ at (Center, Center, Center)\n    │   │   ├── 4×1×4 Field{Center, Center, Center} on RectilinearGrid on CPU\n    │   │   └── 2\n    │   └── * at (Center, Center, Center)\n        │   ├── 2\n        │   └── 4×1×4 Field{Center, Center, Center} on RectilinearGrid on CPU\n    └── 1","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Like Fields, AbstractOperations have a location and a grid.  In addition to BinaryOperations like the kind above, UnaryOperations and MultiaryOperations are also supported,","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"cos_c = cos(c)\n\n# output\nUnaryOperation at (Center, Center, Center)\n├── grid: 4×1×4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo\n└── tree:\n    cos at (Center, Center, Center) via identity\n    └── 4×1×4 Field{Center, Center, Center} on RectilinearGrid on CPU","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"four_c = c + c + c + c\n\n# output\nMultiaryOperation at (Center, Center, Center)\n├── grid: 4×1×4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo\n└── tree:\n    + at (Center, Center, Center)\n    ├── 4×1×4 Field{Center, Center, Center} on RectilinearGrid on CPU\n    ├── 4×1×4 Field{Center, Center, Center} on RectilinearGrid on CPU\n    ├── 4×1×4 Field{Center, Center, Center} on RectilinearGrid on CPU\n    └── 4×1×4 Field{Center, Center, Center} on RectilinearGrid on CPU","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"UnaryOperation, BinaryOperation and MultiaryOperation all have both an \"operator\", and between 1 and many. Last, and definitely not least, the fourth flavor of AbstractOperation represents a derivative,","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"dx_c = ∂x(c)\n\n# output\nDerivative at (Face, Center, Center)\n├── grid: 4×1×4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo\n└── tree:\n    ∂xᶠᶜᶜ at (Face, Center, Center) via identity\n    └── 4×1×4 Field{Center, Center, Center} on RectilinearGrid on CPU","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"note: Note\nThe x-derivative of c is computed by invoking the function ∂xᶠᶜᶜ, where the superscript ᶠᶜᶜ indicates that the result of this function is located at (Face, Center, Center). This convention is used throughout Oceananigans source code. A third superscripted letter ᵃ stands for \"any\" location and applies to operators that are location-agnostic in the given direction.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Like Fields, AbstractOperations are evaluated by indexing,","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"@show c[1, 1, 1]\n@show quadratic[1, 1, 1]\nnothing\n\n# output\nc[1, 1, 1] = 0.02135277459201165\nquadratic[1, 1, 1] = 1.0431614901668005","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Also like Fields, AbstractOperations have a location. For example,","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"@show location(c)\n@show location(dx_c)\nnothing\n\n# output\nlocation(c) = (Center, Center, Center)\nlocation(dx_c) = (Face, Center, Center)","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Notice that the location of dx_c is shifted in x relative to c. Likewise, y-derivatives are shifted in y and z-derivatives are shifted in z.","category":"page"},{"location":"operations/#Locations-and-interpolation","page":"Operations","title":"Locations and interpolation","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"Reconstruction of Fields from one location to another is intrinsic to arithmetic on the staggered grid. Consider the magnitude of the gradient of c:","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"∇c² = ∂x(c)^2 + ∂z(c)^2\n\n# output\nBinaryOperation at (Face, Center, Center)\n├── grid: 4×1×4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo\n└── tree:\n    + at (Face, Center, Center)\n    ├── ^ at (Face, Center, Center)\n    │   ├── ∂xᶠᶜᶜ at (Face, Center, Center) via identity\n    │   │   └── 4×1×4 Field{Center, Center, Center} on RectilinearGrid on CPU\n    │   └── 2\n    └── ^ at (Center, Center, Face)\n        ├── ∂zᶜᶜᶠ at (Center, Center, Face) via identity\n        │   └── 4×1×4 Field{Center, Center, Center} on RectilinearGrid on CPU\n        └── 2","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Because ∂x(c)^2 is located at (Face, Center, Center) and ∂z(c)^2 is located at (Center, Center, Face), a decision has to be made to compute ∇c². By default, AbstractOperations are reconstructed at the location of the first object in the expression. So","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"∇c²_ccf = ∂z(c)^2 + ∂x(c)^2\n\n# output\nBinaryOperation at (Center, Center, Face)\n├── grid: 4×1×4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo\n└── tree:\n    + at (Center, Center, Face)\n    ├── ^ at (Center, Center, Face)\n    │   ├── ∂zᶜᶜᶠ at (Center, Center, Face) via identity\n    │   │   └── 4×1×4 Field{Center, Center, Center} on RectilinearGrid on CPU\n    │   └── 2\n    └── ^ at (Face, Center, Center)\n        ├── ∂xᶠᶜᶜ at (Face, Center, Center) via identity\n        │   └── 4×1×4 Field{Center, Center, Center} on RectilinearGrid on CPU\n        └── 2","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"ends up at (Center, Center, Face). To control the location of an operation we use the macro @at,","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"∇c²_ccc = @at (Center, Center, Center) ∂x(c)^2 + ∂z(c)^2\n\n# output\nBinaryOperation at (Center, Center, Center)\n├── grid: 4×1×4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo\n└── tree:\n    + at (Center, Center, Center)\n    ├── ^ at (Center, Center, Center)\n    │   ├── ∂xᶠᶜᶜ at (Center, Center, Center) via ℑxᶜᵃᵃ\n    │   │   └── 4×1×4 Field{Center, Center, Center} on RectilinearGrid on CPU\n    │   └── 2\n    └── ^ at (Center, Center, Center)\n        ├── ∂zᶜᶜᶠ at (Center, Center, Center) via ℑzᵃᵃᶜ\n        │   └── 4×1×4 Field{Center, Center, Center} on RectilinearGrid on CPU\n        └── 2","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#Buoyancy-models-and-equations-of-state","page":"Buoyancy models and equation of state","title":"Buoyancy models and equations of state","text":"","category":"section"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"The buoyancy option selects how buoyancy is treated in NonhydrostaticModels and HydrostaticFreeSurfaceModels (ShallowWaterModels do not have that option given the physics of the model). There are currently three alternatives:","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"No buoyancy (and no gravity).\nEvolve buoyancy as a tracer.\nSeawater buoyancy: evolve temperature T and salinity S as tracers with a value for the gravitational acceleration g and an equation of state of your choosing.","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#No-buoyancy","page":"Buoyancy models and equation of state","title":"No buoyancy","text":"","category":"section"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"To turn off buoyancy (and gravity) you can simply pass buoyancy = nothing to the model constructor. For example to create a NonhydrostaticModel:","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"DocTestSetup = quote\n    using Oceananigans\nend","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> grid = RectilinearGrid(size=(8, 8, 8), extent=(1, 1, 1));\n\njulia> model = NonhydrostaticModel(; grid, buoyancy=nothing)\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\n├── grid: 8×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo\n├── timestepper: RungeKutta3TimeStepper\n├── advection scheme: Centered reconstruction order 2\n├── tracers: ()\n├── closure: Nothing\n├── buoyancy: Nothing\n└── coriolis: Nothing","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"The option buoyancy = nothing is the default for NonhydrostaticModel, so omitting the buoyancy keyword argument from the NonhydrostaticModel constructor yields the same:","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> model = NonhydrostaticModel(; grid)\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\n├── grid: 8×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo\n├── timestepper: RungeKutta3TimeStepper\n├── advection scheme: Centered reconstruction order 2\n├── tracers: ()\n├── closure: Nothing\n├── buoyancy: Nothing\n└── coriolis: Nothing","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"The same is true for HydrostaticFreeSurfaceModel,","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> model = HydrostaticFreeSurfaceModel(; grid)\nHydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\n├── grid: 8×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo\n├── timestepper: QuasiAdamsBashforth2TimeStepper\n├── tracers: ()\n├── closure: Nothing\n├── buoyancy: Nothing\n├── free surface: ImplicitFreeSurface with gravitational acceleration 9.80665 m s⁻²\n│   └── solver: FFTImplicitFreeSurfaceSolver\n├── advection scheme: \n│   └── momentum: Vector Invariant, Dimension-by-dimension reconstruction\n└── coriolis: Nothing","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#Buoyancy-as-a-tracer","page":"Buoyancy models and equation of state","title":"Buoyancy as a tracer","text":"","category":"section"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"Both NonhydrostaticModel and HydrostaticFreeSurfaceModel support evolving a buoyancy tracer by including :b in tracers and specifying  buoyancy = BuoyancyTracer():","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> model = NonhydrostaticModel(; grid, buoyancy=BuoyancyTracer(), tracers=:b)\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\n├── grid: 8×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo\n├── timestepper: RungeKutta3TimeStepper\n├── advection scheme: Centered reconstruction order 2\n├── tracers: b\n├── closure: Nothing\n├── buoyancy: BuoyancyTracer with ĝ = NegativeZDirection()\n└── coriolis: Nothing","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"Similarly for a HydrostaticFreeSurfaceModel with buoyancy as a tracer:","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> model = HydrostaticFreeSurfaceModel(; grid, buoyancy=BuoyancyTracer(), tracers=:b)\nHydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\n├── grid: 8×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo\n├── timestepper: QuasiAdamsBashforth2TimeStepper\n├── tracers: b\n├── closure: Nothing\n├── buoyancy: BuoyancyTracer with ĝ = NegativeZDirection()\n├── free surface: ImplicitFreeSurface with gravitational acceleration 9.80665 m s⁻²\n│   └── solver: FFTImplicitFreeSurfaceSolver\n├── advection scheme:\n│   ├── momentum: Vector Invariant, Dimension-by-dimension reconstruction\n│   └── b: Centered reconstruction order 2\n└── coriolis: Nothing","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#Seawater-buoyancy","page":"Buoyancy models and equation of state","title":"Seawater buoyancy","text":"","category":"section"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"NonhydrostaticModel and HydrostaticFreeSurfaceModel support modeling the buoyancy of seawater as a function of the gravitational acceleration, the conservative temperature T, and the absolute salinity S. The relationship between T, S, the geopotential height, and the density perturbation from a reference value is called the equation_of_state.","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"Specifying buoyancy = SeawaterBuoyancy() returns a buoyancy model with a linear equation of state, Earth standard gravitational_acceleration = 9.80665 (in  S.I. units textmtexts^-2) and requires to add :T and :S as tracers:","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> model = NonhydrostaticModel(; grid, buoyancy=SeawaterBuoyancy(), tracers=(:T, :S))\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\n├── grid: 8×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo\n├── timestepper: RungeKutta3TimeStepper\n├── advection scheme: Centered reconstruction order 2\n├── tracers: (T, S)\n├── closure: Nothing\n├── buoyancy: SeawaterBuoyancy with g=9.80665 and LinearEquationOfState(thermal_expansion=0.000167, haline_contraction=0.00078) with ĝ = NegativeZDirection()\n└── coriolis: Nothing","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"and the same is true for HydrostaticFreeSurfaceModel,","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> model = HydrostaticFreeSurfaceModel(; grid, buoyancy=SeawaterBuoyancy(), tracers=(:T, :S))\nHydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\n├── grid: 8×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo\n├── timestepper: QuasiAdamsBashforth2TimeStepper\n├── tracers: (T, S)\n├── closure: Nothing\n├── buoyancy: SeawaterBuoyancy with g=9.80665 and LinearEquationOfState(thermal_expansion=0.000167, haline_contraction=0.00078) with ĝ = NegativeZDirection()\n├── free surface: ImplicitFreeSurface with gravitational acceleration 9.80665 m s⁻²\n│   └── solver: FFTImplicitFreeSurfaceSolver\n├── advection scheme:\n│   ├── momentum: Vector Invariant, Dimension-by-dimension reconstruction\n│   ├── T: Centered reconstruction order 2\n│   └── S: Centered reconstruction order 2\n└── coriolis: Nothing","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"To model flows near the surface of Europa where gravitational_acceleration = 1.3 textmtexts^-2, we might alternatively specify","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> buoyancy = SeawaterBuoyancy(gravitational_acceleration=1.3)\nSeawaterBuoyancy{Float64}:\n├── gravitational_acceleration: 1.3\n└── equation_of_state: LinearEquationOfState(thermal_expansion=0.000167, haline_contraction=0.00078)\n\njulia> model = NonhydrostaticModel(; grid, buoyancy, tracers=(:T, :S))\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\n├── grid: 8×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo\n├── timestepper: RungeKutta3TimeStepper\n├── advection scheme: Centered reconstruction order 2\n├── tracers: (T, S)\n├── closure: Nothing\n├── buoyancy: SeawaterBuoyancy with g=1.3 and LinearEquationOfState(thermal_expansion=0.000167, haline_contraction=0.00078) with ĝ = NegativeZDirection()\n└── coriolis: Nothing","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"for example.","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#Linear-equation-of-state","page":"Buoyancy models and equation of state","title":"Linear equation of state","text":"","category":"section"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"To specify the thermal expansion and haline contraction coefficients alpha = 2 times 10^-3  textK^-1 and beta = 5 times 10^-4 textpsu^-1,","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> buoyancy = SeawaterBuoyancy(equation_of_state=LinearEquationOfState(thermal_expansion=2e-3, haline_contraction=5e-4))\nSeawaterBuoyancy{Float64}:\n├── gravitational_acceleration: 9.80665\n└── equation_of_state: LinearEquationOfState(thermal_expansion=0.002, haline_contraction=0.0005)","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#Idealized-nonlinear-equations-of-state","page":"Buoyancy models and equation of state","title":"Idealized nonlinear equations of state","text":"","category":"section"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"Instead of a linear equation of state, six idealized (second-order) nonlinear equations of state as described by Roquet et al. (2015) may be used. These equations of state are provided via the SeawaterPolynomials.jl package.","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> using SeawaterPolynomials.SecondOrderSeawaterPolynomials\n\njulia> eos = RoquetEquationOfState(:Freezing)\nBoussinesqEquationOfState{Float64}:\n    ├── seawater_polynomial: SecondOrderSeawaterPolynomial{Float64}\n    └── reference_density: 1024.6\n    \njulia> eos.seawater_polynomial # the density anomaly\nρ' = 0.7718 Sᴬ - 0.0491 Θ - 0.005027 Θ² - 2.5681e-5 Θ Z + 0.0 Sᴬ² + 0.0 Sᴬ Z + 0.0 Sᴬ Θ\n\njulia> buoyancy = SeawaterBuoyancy(equation_of_state=eos)\nSeawaterBuoyancy{Float64}:\n├── gravitational_acceleration: 9.80665\n└── equation_of_state: BoussinesqEquationOfState{Float64}","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#TEOS-10-equation-of-state","page":"Buoyancy models and equation of state","title":"TEOS-10 equation of state","text":"","category":"section"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"A high-accuracy 55-term polynomial approximation to the TEOS-10 equation of state suitable for use in Boussinesq models as described by Roquet et al. (2015) is implemented in the SeawaterPolynomials.jl package and may be used.","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> using SeawaterPolynomials.TEOS10\n\njulia> eos = TEOS10EquationOfState()\nBoussinesqEquationOfState{Float64}:\n    ├── seawater_polynomial: TEOS10SeawaterPolynomial{Float64}\n    └── reference_density: 1020.0","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#The-direction-of-gravitational-acceleration","page":"Buoyancy models and equation of state","title":"The direction of gravitational acceleration","text":"","category":"section"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"To simulate gravitational accelerations that don't align with the vertical (z) coordinate, we wrap the buoyancy model in Buoyancy() function call, which takes the keyword arguments model and gravity_unit_vector,","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/","page":"Buoyancy models and equation of state","title":"Buoyancy models and equation of state","text":"julia> grid = RectilinearGrid(size=(8, 8, 8), extent=(1, 1, 1));\n\njulia> θ = 45; # degrees\n\njulia> g̃ = (0, sind(θ), cosd(θ));\n\njulia> buoyancy = Buoyancy(model=BuoyancyTracer(), gravity_unit_vector=g̃)\nBuoyancy:\n├── model: BuoyancyTracer\n└── gravity_unit_vector: (0.0, 0.707107, 0.707107)\n\njulia> model = NonhydrostaticModel(; grid, buoyancy, tracers=:b)\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\n├── grid: 8×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo\n├── timestepper: RungeKutta3TimeStepper\n├── advection scheme: Centered reconstruction order 2\n├── tracers: b\n├── closure: Nothing\n├── buoyancy: BuoyancyTracer with ĝ = (0.0, 0.707107, 0.707107)\n└── coriolis: Nothing","category":"page"},{"location":"appendix/staggered_grid/#Staggered-grid","page":"Staggered grid","title":"Staggered grid","text":"","category":"section"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"Velocities u, v, and w are defined on the faces of the cells, which are coincident with three orthogonal coordinate axes (the Cartesian axes in the case of Oceananigans). Pressure p and tracers c are stored at the cell  centers as cell averages. See schematic below of the different control volumes. Other quantities may be defined at other locations. For example, vorticity boldsymbolomega = boldsymbolnabla times boldsymbolv is defined at the cell edges.[1]","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"[1]: In 2D it would more correct to say the cell corners. In 3D, variables like vorticity lie at the same vertical levels as the cell-centered variables and so they really lie at the cell edges.","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"(Image: Schematic of control volumes) A schematic of Oceananigans.jl finite volumes for a two-dimensional staggered grid in (x z). Tracers c and pressure p are defined at the center of the control volume. The u control volumes are  centered on the left and right edges of the pressure control volume while the w control volumes are centered  on the top and bottom edges of the pressure control volumes. The indexing convention places the i^rmth  u-node on cell x-faces to the left of the i tracer point at cell centers.","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"This staggered arrangement of variables is more complicated than the collocated grid arrangement but is greatly beneficial as it avoids the odd-even decoupling between the pressure and velocity if they are stored at the same positions. §6.1 of Patankar (1980) discusses this problem in the presence of a zigzag pressure field: on a 1D collocated grid the velocity at the point i is influenced by the pressure at points i-1 and i+1, and a zigzag pressure field will be felt as a uniform pressure, which is obviously wrong and would reduce the accuracy of the solution. The pressure is effectively taken from a coarser grid than what is actually used. The basic problem is that the momentum equations will use the pressure difference between two alternate points when it should be using two adjacent points.","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"From the viewpoint of linear algebra, these spurious pressure modes correspond to solutions in the null space of the pressure projection operator with eigenvalue zero and are thus indistinguishable from a uniform pressure field (Sani et al., 1981).","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"The staggered grid was first introduced by Harlow and Welch (1965) with their marker and cell method. In meteorology and oceanography, this particular staggered grid configuration is referred to as the Arakawa C-grid after Arakawa and Lamb (1977), who investigated four different staggered grids and the unstaggered A-grid for use in an atmospheric model.","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"Arakawa and Lamb (1977) investigated the dispersion relation of inertia-gravity waves[2] traveling in the x-direction","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"  omega^2 = f^2 + gHk^2  ","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"in the linearized rotating shallow-water equations for five grids. Here omega is the angular frequency, H is the height of the fluid and k is the wavenumber in the x-direction. Looking at the effect of spatial discretization error on the frequency of these waves they find that the B and C-grids reproduce the dispersion relation most closely out of the five Arakawa and Lamb (1977) (Figure 5). In particular, the dispersion relation for the C-grid is given by","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"  omega^2 = f^2 left cos^2 left( frackDelta2 right)\n             + 4 left( fraclambdaDelta right)^2 sin^2 left( frackDelta2 right) right  ","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"where lambda is the wavelength and Delta is the grid spacing. Paraphrasing p. 184 of Arakawa and Lamb (1977): The wavelength of the shortest resolvable wave is 2Delta with corresponding wavenumber k = piDelta so it is sufficient to evaluate the dispersion relation over the range 0  k Delta  pi. The frequency is monotonically increasing for lambda  Delta  frac12 and monotonically decreasing for lambda  Delta  frac12. For the fourth smallest wave lambda  Delta = frac12 we get omega^2 = f^2 which matches the k = 0 wave. Furthermore, the group velocity is zero for all k. On the other grids, waves with k Delta = pi can behave like pure inertial oscillations or stationary waves, which is bad.","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"The B and C-grids are less oscillatory than the others and quite faithfully simulate geostrophic adjustment. However, the C-grid is the only one that faithfully reproduces the two-dimensional dispersion relation omega^2(k ell), all the other grids have false maxima, and so Arakawa and Lamb (1977) conclude that the C-grid is best for simulating geostrophic adjustment except for abnormal situations in which lambda  Delta is less than or close to 1. This seems to have held true for most atmospheric and oceanographic simulations as the C-grid is popular and widely used.","category":"page"},{"location":"appendix/staggered_grid/","page":"Staggered grid","title":"Staggered grid","text":"[2]: Apparently also called Poincaré waves, Sverdrup waves, and rotational gravity waves §13.9 of Kundu et al. (2015).","category":"page"},{"location":"numerical_implementation/elliptic_solvers/#Elliptic-solvers","page":"Elliptic solvers","title":"Elliptic solvers","text":"","category":"section"},{"location":"numerical_implementation/elliptic_solvers/#The-elliptic-problem-for-the-pressure","page":"Elliptic solvers","title":"The elliptic problem for the pressure","text":"","category":"section"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"The 3D non-hydrostatic pressure field is obtained by taking the divergence of the horizontal  component of the momentum equations and invoking the vertical component to yield an elliptic  Poisson equation for the non-hydrostatic kinematic pressure","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"   beginequation\n   labeleqpoisson-pressure\n   nabla^2 p_NH = fracboldsymbolnabla boldsymbolcdot boldsymbolv^nDelta t + boldsymbolnabla boldsymbolcdot boldsymbolG_boldsymbolv equiv mathscrF  \n   endequation","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"along with homogenous Neumann boundary conditions boldsymbolv cdot boldsymbolhatn = 0  (Neumann on p for wall-bounded directions and periodic otherwise) and where mathscrF  denotes the source term for the Poisson equation.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"note: Hydrostatic approximation\nFor problems in which the hydrostatic approximation is invoked, the Poisson equation for pressure above only needs to be solved for the vertically integrated flow and the pressure field is a two dimensional term p_S(x y t).","category":"page"},{"location":"numerical_implementation/elliptic_solvers/#Direct-method","page":"Elliptic solvers","title":"Direct method","text":"","category":"section"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"Discretizing elliptic problems that can be solved via a classical separation-of-variables approach, such as Poisson's equation, results in a linear system of equations M boldsymbolx = boldsymboly where M is a real symmetric matrix of block tridiagonal form. This allows for the matrix to be decomposed and solved efficiently, provided that the eigenvalues and eigenvectors of the blocks are known (§2) (Buzbee et al., 1970). In the case of Poisson's equation on a rectangle, Hockney (1965) has taken advantage of the fact that the fast Fourier transform can be used to perform the matrix multiplication steps resulting in an even more efficient method. Schumann and Sweet (1988) describe the implementation of such an algorithm for Poisson's equation on a staggered grid with Dirichlet, Neumann, and periodic boundary conditions.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"The method can be explained easily by taking the Fourier transform of both sides of \\eqref{eq:poisson-pressure} to yield","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"    beginequation\n    labeleqpoisson-spectral\n    -(k_x^2 + k_y^2 + k_z^2) widehatp_NH = widehatmathscrF\n    quad implies quad\n    widehatp_NH = - fracwidehatmathscrFk_x^2 + k_y^2 + k_z^2  \n    endequation","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"where widehatcdot denotes the Fourier component. Here k_x, k_y, and k_z are the wavenumbers. However, when solving the equation on a staggered grid we require a solution for p_NH that is second-order accurate such that when when its Laplacian is computed, nabla^2 p_NH matches mathscrF to machine precision. This is crucial to ensure that the projection step in the fractional time-step works (see Time-stepping section and Fractional step method appendix). To do this, the wavenumbers are replaced by eigenvalues lambda^x, lambda^y, and lambda^z satisfying the discrete form of Poisson's equation with appropriate boundary conditions. Thus, Poisson's equation is diagonalized in Fourier space and the Fourier coefficients of the solution are easily solved for","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"widehatp_NH(i j k) = - fracwidehatmathscrF(i j k)lambda^x_i + lambda^y_j + lambda^z_k  ","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"The eigenvalues are given by Schumann and Sweet (1988) and can also be tediously derived by plugging in the definition of the discrete Fourier transform into \\eqref{eq:poisson-spectral}:","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"beginalign\n    lambda^x_i = 4fracN_x^2L_x^2 sin^2 left  frac(i-1) piN_x  right  quad i=0 1 dots N_x-1   \n    lambda^y_j = 4fracN_y^2L_y^2 sin^2 left  frac(j-1) piN_y  right  quad j=0 1 dots N_y-1   \n    lambda^z_k = 4fracN_z^2L_z^2 sin^2 left  frac(k-1) pi2N_z right  quad k=0 1 dots N_z-1  \nendalign","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"where lambda^x and lambda^y correspond to periodic boundary conditions in the horizontal and lambda^z to Neumann boundary conditions in the vertical.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"There is also an ambiguity in the solution to Poisson's equation as it's only defined up to a constant. To resolve this ambiguity we choose the solution with zero mean by setting the zeroth Fourier coefficient p_000 (corresponding to k_x = k_y = k_z = 0) to zero. This also has the added benefit of discarding the zero eigenvalue so we don't divide by it.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"The Fast Fourier transforms are computed using FFTW.jl [(Frigo and Johnson, 1998) and (Frigo and Johnson, 2005)] on the CPU and using the cuFFT library on the GPU. Along wall-bounded dimensions, the cosine transform is used. In particular, as the transforms are performed on a staggered grid, DCT-II (REDFT10) is used to perform the forward cosine transform and DCT-III (REDFT01) is used to perform the inverse cosine transform.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/#Direct-method-with-a-vertically-stretched-grid","page":"Elliptic solvers","title":"Direct method with a vertically stretched grid","text":"","category":"section"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"Using Fourier transforms for all three dimensions results in a method requiring mathcalO(N log_2 N) operations where N is the total number of grid points. This algorithm can be made even more efficient by solving a tridiagonal system along one of the dimensions and utilizing cyclic reduction. This results in the Fourier analysis cyclic reduction or textFACR(ell) algorithm (with ell cyclic reduction steps) which requires only mathcalO(N log_2log_2 N) operations provided the optimal number of cyclic reduction steps is taken, which is ell = log_2 log_2 n where n is the number of grid points in the cyclic reduction dimension. The FACR algorithm was first developed by Hockney (1969) and is well reviewed by Swarztrauber (1977) then further benchmarked and extended by Temperton (1979) and Temperton (1980).","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"Furthermore, the FACR algorithm removes the restriction that the grid is uniform in one of the dimensions so it can be utilized to implement a fast Poisson solver for vertically stretched grids if the cyclic reduction is applied in the along the vertical dimension.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"Expanding p_NH and mathscrF into Fourier modes along the x and y directions","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"p_ijk = sum_m=1^N_x sum_n=1^N_y tildep_mnk  e^-mathrmi 2pi i m  N_x   e^-mathrmi 2pi j n  N_y  ","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"and recalling that Fourier transforms do partial_x rightarrow mathrmi k_x and partial_y rightarrow mathrmi k_y we can write \\eqref{eq:poisson-pressure} as","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"sum_m=1^N_x sum_n=1^N_y\nleftlbrace\n    partial_z^2 tildep_mnk - (k_x^2 + k_y^2) tildep_mnk - tildemathscrF_mnk\nrightrbrace e^-mathrmi 2 pi i m  N_x  e^-mathrmi 2 pi j n  N_y = 0  ","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"Discretizing the partial_z^2 derivative and equating the term inside the brackets to zero we arrive at N_xtimes N_y symmetric tridiagonal systems of N_z linear equations for the Fourier modes:","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"fractildep_mn k-1Delta z^C_k\n- leftlbrace frac1Delta z^C_k + frac1Delta z^C_k+1 + Delta z^F_k (k_x^2 + k_y^2) rightrbrace\n  tildep_mnk\n+ fractildep_mn k+1Delta z^C_k+1\n= Delta z^F_k tildemathscrF_mnk  ","category":"page"},{"location":"numerical_implementation/elliptic_solvers/#Cosine-transforms-on-the-GPU","page":"Elliptic solvers","title":"Cosine transforms on the GPU","text":"","category":"section"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"Unfortunately cuFFT does not provide cosine transforms and so we must write our own fast cosine  transforms for the GPU. We implemented the fast 1D and 2D cosine transforms described by Makhoul (1980)  which compute it by applying the regular Fourier transform to a permuted version of the array.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"In this section we will be using the DCT-II as the definition of the forward cosine transform  for a real signal of length N","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"    beginequation\n    labeleqFCT\n    textDCT(X) quad Y_k = 2 sum_j=0^N-1 cos left fracpi(j + frac12)kN right X_j  \n    endequation","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"and the DCT-III as the definition of the inverse cosine transform","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"    beginequation\n    labeleqIFCT\n    textIDCT(X) quad Y_k = X_0 + 2 sum_j=1^N-1 cos left fracpi j (k + frac12)N right X_j  \n    endequation  ","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"and will use omega_M = e^-2 pi mathrmi  M to denote the M^textth root of unity, sometimes called the twiddle factors in the context of FFT algorithms.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/#1D-fast-cosine-transform","page":"Elliptic solvers","title":"1D fast cosine transform","text":"","category":"section"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"To calculate \\eqref{eq:FCT} using the fast Fourier transform, we first permute the input signal along the appropriate dimension by ordering the odd elements first followed by the even elements to produce a permuted signal","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"    X^prime_n =\n    begincases\n        displaystyle X_2N quad 0 le n le left fracN-12 right   \n        displaystyle X_2N - 2n - 1 quad left fracN+12 right le n le N-1  \n    endcases","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"where a indicates the integer part of a. This should produce, for example,","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"    beginequation\n    labeleqpermutation\n    (a b c d e f g h) quad rightarrow quad (a c e g h f d b)  \n    endequation","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"after which \\eqref{eq:FCT} is computed using","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"  Y = textDCT(X) = 2 textRe leftlbrace omega_4N^k textFFT lbrace X^prime rbrace rightrbrace  ","category":"page"},{"location":"numerical_implementation/elliptic_solvers/#1D-fast-inverse-cosine-transform","page":"Elliptic solvers","title":"1D fast inverse cosine transform","text":"","category":"section"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"The inverse \\eqref{eq:IFCT} can be computed using","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"  Y = textIDCT(X) = textRe leftlbrace omega_4N^-k textIFFT lbrace X rbrace rightrbrace  ","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"after which the inverse permutation of \\eqref{eq:permutation} must be applied.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/#2D-fast-cosine-transform","page":"Elliptic solvers","title":"2D fast cosine transform","text":"","category":"section"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"Unfortunately, the 1D algorithm cannot be applied dimension-wise so the 2D algorithm is more  complicated. Thankfully, the permutation \\eqref{eq:permutation} can be applied dimension-wise.  The forward cosine transform for a real signal of length N_1 times N_2 is then given by","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"Y_k_1 k_2 = textDCT(X_n_1 n_2) =\n2 textRe leftlbrace\n    omega_4N_1^k left( omega_4N_2^k tildeX + omega_4N_2^-k tildeX^- right)\nrightrbrace  ","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"where tildeX = textFFT(X^prime) and tildeX^- indicates that tildeX is indexed in reverse.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/#2D-fast-inverse-cosine-transform","page":"Elliptic solvers","title":"2D fast inverse cosine transform","text":"","category":"section"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"The inverse can be computed using","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"Y_k_1 k_2 = textIDCT(X_n_1 n_2) =\nfrac14 textRe leftlbrace\n    omega_4N_1^-k omega_4N_2^-k\n    left( tildeX - M_1 M_2 tildeX^-- right)\n    - mathrmi left( M_1 tildeX^-+ + M_2 tildeX^+- right)\nrightrbrace  ","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"where tildeX = textIFFT(X) here, tildeX^-+ is indexed in reverse along the first dimension, tildeX^-+ along the second dimension, and tildeX^-- along both. M_1 and M_2 are masks of lengths N_1 and N_2 respectively, both containing ones except at the first element where M_0 = 0. Afterwards, the inverse permutation of \\eqref{eq:permutation} must be applied.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"Due to the extra steps involved in calculating the cosine transform in 2D, running with two  wall-bounded dimensions typically slows the model down by a factor of 2. Switching to the FACR  algorithm may help here as a 2D cosine transform won't be necessary anymore.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/#Iterative-Solvers","page":"Elliptic solvers","title":"Iterative Solvers","text":"","category":"section"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"For problems with irregular grids the eigenvectors of the discrete Poisson operator are no longer simple Fourier series sines and cosines. This means discrete Fast Fourier Transforms can't be used to generate the projection  of the equation right hand side onto eigenvectors. So an eigenvector based approach to solving the Poisson equation is not computationally efficient.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"For problems with grids that are non uniform in multiple directions, we use instead a pre-conditioned conjugate gradient iterative solver. Such cases include curvilinear grids on the sphere and also telescoping cartesian grids that stretch along more than one dimension. There are two forms of the pressure operator in this approach. One is rigid lid form and one is an implicit free-surface form.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/#Rigid-lid-pressure-operator","page":"Elliptic solvers","title":"Rigid lid pressure operator","text":"","category":"section"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"The rigid lid operator is based on the same continuous form as is used in the Direct Method solver.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/#Implicit-free-surface-pressure-operator","page":"Elliptic solvers","title":"Implicit free surface pressure operator","text":"","category":"section"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"The implicit free surface solver solves for the free-surface, eta(x y t), in the vertically integrated continuity equation:","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"    beginequation\n    labeleqvertically-integrated-continuity\n    partial_t eta + partial_x left ( int_-H^0 u  mathrmdz right ) + partial_y left ( int_-H^0 v  mathrmdz right ) = M  \n    endequation","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"where H(x y) is the depth of the water column (to first order with respect to the free surface elevation) and M is some surface volume flux (e.g., terms such as precipitation, evaporation and runoff); currently Oceananigans.jl assumes M = 0. Note that in deriving \\eqref{eq:vertically-integrated-continuity}, we used the bottom boundary condition w_rm bottom = boldsymbolu_rm bottom boldsymbolcdot boldsymbolnabla_h H.","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"To form a linear system that can be solved implicitly we recast the vertically-integrated continuity equation \\eqref{eq:vertically-integrated-continuity} into a discrete integral form. The best way to do so is by starting from the discrete version of the continuity equation (in this case without any surface volume flux, M = 0)","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"    beginalign\n    labeleqcontinuity-discrete\n    delta_x (A_x u) + delta_y (A_y v) + delta_z (A_z w) = 0  \n    endalign","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"and summing it vertically to get:","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"    beginalign\n    labeleqvertically-integrated-continuity-discrete\n    delta_x sum_k (A_x u) + delta_y sum_k (A_y v) + A_z underbracew(k = N_z + 1)_w_rm top = 0  \n    endalign","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"In equations \\eqref{eq:continuity-discrete} and \\eqref{eq:vertically-integrated-continuity-discrete} and here after, we have abused notation and used, e.g., u and v to denote the volume averages over grid cells of the quantities u and v respectively. Using w_rm top = partial_t eta and being a bit more explicit on the locations the difference operators act on, \\eqref{eq:vertically-integrated-continuity-discrete} becomes:","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"    beginequation\n    labeleqsemi-discrete-integral-continuity\n    A_z partial_t eta + delta_x^caa sum_k (A_x u) + delta_y^aca sum_k (A_y v) = 0  \n    endequation","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"We can now apply the velocity fractional step equation (discussed in the Time-stepping section) for the hydrostatic model:","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"    beginequation\n    labeleqhydrostatic-fractional-step\n    boldsymbolu^n+1 = boldsymbolu^star - g Delta t  boldsymbolnabla eta^n+1  \n    endequation","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"We impose that the n+1-th time step velocity is consistent with \\eqref{eq:semi-discrete-integral-continuity}","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"    beginequation\n    A_z fraceta^n+1 - eta^nDelta t = - delta_x^caa sum_k (A_x u^n+1) - delta_y^aca sum_k (A_y v^n+1)  \n    endequation","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"Substituting u^n+1 and v^n+1 from the discrete form of the right-hand-side of \\eqref{eq:hydrostatic-fractional-step} then gives us an implicit equation for eta^n+1:","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"beginalign\n    delta_x^caasum_k A_x partial_x^faa eta^n+1  + delta_y^aca sum_k A_y partial_y^afa eta^n+1 - frac1g  Delta t^2 A_z eta^n+1 = nonumber \n     = frac1g  Delta t left( delta_x^caa sum_k A_x u^star + delta_y^aca sum_k A_y v^star right ) - frac1g  Delta t^2 A_z eta^n   labeleqimplicit-free-surface\nendalign","category":"page"},{"location":"numerical_implementation/elliptic_solvers/","page":"Elliptic solvers","title":"Elliptic solvers","text":"The left-hand-side of \\eqref{eq:implicit-free-surface} is nothing else than a linear operator acting on eta^n+1. Formulated in this way, the linear operator is symmetric and therefore \\eqref{eq:implicit-free-surface} can be solved using a preconditioned conjugate gradient algorithm.","category":"page"},{"location":"appendix/benchmarks/#performance_benchmarks","page":"Performance benchmarks","title":"Performance benchmarks","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"The performance benchmarking scripts in the benchmarks directory of the git repository can be run to benchmark Oceananigans.jl on your machine. They use BenchmarkTools.jl to collect data and PrettyTables.jl  to nicely format the benchmark results.","category":"page"},{"location":"appendix/benchmarks/#Shallow-Water-Model","page":"Performance benchmarks","title":"Shallow Water Model","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"This benchmark tests the performance of the shallow water model run in a doubly periodic domain (topology = (Periodic, Periodic, Flat)) on a CPU versus a GPU.  We find that with the WENO advection scheme we get a maximum speedup of more than 400 times on a 16384^2 grid.","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Oceananigans v0.58.1\nJulia Version 1.6.0\nCommit f9720dc2eb (2021-03-24 12:55 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake)\nEnvironment:\n  EBVERSIONJULIA = 1.6.0\n  JULIA_DEPOT_PATH = :\n  EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0\n  EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel\n  JULIA_LOAD_PATH = :\n  GPU: Tesla V100-SXM2-32GB\n\n                                              Shallow water model benchmarks\n┌───────────────┬─────────────┬───────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┬─────────┐\n│ Architectures │ Float_types │    Ns │        min │     median │       mean │        max │    memory │ allocs │ samples │\n├───────────────┼─────────────┼───────┼────────────┼────────────┼────────────┼────────────┼───────────┼────────┼─────────┤\n│           CPU │     Float64 │    32 │   2.677 ms │   2.876 ms │   3.047 ms │   4.806 ms │  1.36 MiB │   2253 │      10 │\n│           CPU │     Float64 │    64 │   5.795 ms │   5.890 ms │   6.073 ms │   7.770 ms │  1.36 MiB │   2255 │      10 │\n│           CPU │     Float64 │   128 │  16.979 ms │  17.350 ms │  17.578 ms │  19.993 ms │  1.36 MiB │   2255 │      10 │\n│           CPU │     Float64 │   256 │  62.543 ms │  63.222 ms │  63.544 ms │  67.347 ms │  1.36 MiB │   2255 │      10 │\n│           CPU │     Float64 │   512 │ 250.149 ms │ 251.023 ms │ 251.092 ms │ 252.389 ms │  1.36 MiB │   2315 │      10 │\n│           CPU │     Float64 │  1024 │ 990.901 ms │ 993.115 ms │ 993.360 ms │ 996.091 ms │  1.36 MiB │   2315 │       6 │\n│           CPU │     Float64 │  2048 │    4.002 s │    4.004 s │    4.004 s │    4.007 s │  1.36 MiB │   2315 │       2 │\n│           CPU │     Float64 │  4096 │   16.371 s │   16.371 s │   16.371 s │   16.371 s │  1.36 MiB │   2315 │       1 │\n│           CPU │     Float64 │  8192 │   64.657 s │   64.657 s │   64.657 s │   64.657 s │  1.36 MiB │   2315 │       1 │\n│           CPU │     Float64 │ 16384 │  290.423 s │  290.423 s │  290.423 s │  290.423 s │  1.36 MiB │   2315 │       1 │\n│           GPU │     Float64 │    32 │   3.468 ms │   3.656 ms │   3.745 ms │   4.695 ms │  1.82 MiB │   5687 │      10 │\n│           GPU │     Float64 │    64 │   3.722 ms │   3.903 ms │   4.050 ms │   5.671 ms │  1.82 MiB │   5687 │      10 │\n│           GPU │     Float64 │   128 │   3.519 ms │   3.808 ms │   4.042 ms │   6.372 ms │  1.82 MiB │   5687 │      10 │\n│           GPU │     Float64 │   256 │   3.822 ms │   4.153 ms │   4.288 ms │   5.810 ms │  1.82 MiB │   5687 │      10 │\n│           GPU │     Float64 │   512 │   4.637 ms │   4.932 ms │   4.961 ms │   5.728 ms │  1.82 MiB │   5765 │      10 │\n│           GPU │     Float64 │  1024 │   3.240 ms │   3.424 ms │   3.527 ms │   4.553 ms │  1.82 MiB │   5799 │      10 │\n│           GPU │     Float64 │  2048 │  10.783 ms │  10.800 ms │  11.498 ms │  17.824 ms │  1.98 MiB │  16305 │      10 │\n│           GPU │     Float64 │  4096 │  41.880 ms │  41.911 ms │  42.485 ms │  47.627 ms │  2.67 MiB │  61033 │      10 │\n│           GPU │     Float64 │  8192 │ 166.751 ms │ 166.800 ms │ 166.847 ms │ 167.129 ms │  5.21 MiB │ 227593 │      10 │\n│           GPU │     Float64 │ 16384 │ 681.129 ms │ 681.249 ms │ 681.301 ms │ 681.583 ms │ 16.59 MiB │ 973627 │       8 │\n└───────────────┴─────────────┴───────┴────────────┴────────────┴────────────┴────────────┴───────────┴────────┴─────────┘\n\n        Shallow water model CPU to GPU speedup\n┌─────────────┬───────┬──────────┬─────────┬─────────┐\n│ Float_types │    Ns │  speedup │  memory │  allocs │\n├─────────────┼───────┼──────────┼─────────┼─────────┤\n│     Float64 │    32 │ 0.786715 │ 1.33777 │ 2.52419 │\n│     Float64 │    64 │  1.50931 │ 1.33774 │ 2.52195 │\n│     Float64 │   128 │  4.55587 │ 1.33774 │ 2.52195 │\n│     Float64 │   256 │  15.2238 │ 1.33774 │ 2.52195 │\n│     Float64 │   512 │  50.8995 │ 1.33771 │ 2.49028 │\n│     Float64 │  1024 │  290.085 │ 1.33809 │ 2.50497 │\n│     Float64 │  2048 │  370.777 │ 1.45575 │  7.0432 │\n│     Float64 │  4096 │  390.617 │ 1.95667 │ 26.3641 │\n│     Float64 │  8192 │  387.632 │ 3.82201 │ 98.3123 │\n│     Float64 │ 16384 │   426.31 │  12.177 │ 420.573 │\n└─────────────┴───────┴──────────┴─────────┴─────────┘","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"As shown in the graph below, speedups increase sharply starting at grid size 512^2 and then plateau off at around 400 times at grid size 4096^2 and beyond.","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"(Image: shallow_water_speedup)","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"The time graph below shows that execution times on GPU are negligibly small up until grid size 1024^2 where it starts to scale similarly to times on CPU.","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"(Image: shallow_water_times)","category":"page"},{"location":"appendix/benchmarks/#Nonhydrostatic-Model","page":"Performance benchmarks","title":"Nonhydrostatic Model","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Similar to to shallow water model, the nonhydrostatic model benchmark tests for its performance on both a CPU and a GPU. It was also benchmarked with the WENO advection scheme. The nonhydrostatic model is 3-dimensional unlike the 2-dimensional shallow water model. Total number of grid points is Ns cubed.","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Oceananigans v0.58.8\nJulia Version 1.6.1\nCommit 6aaedecc44 (2021-04-23 05:59 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake)\nEnvironment:\n  EBVERSIONJULIA = 1.6.1\n  JULIA_DEPOT_PATH = :\n  EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1\n  EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1/easybuild/avx2-Core-julia-1.6.1-easybuild-devel\n  JULIA_LOAD_PATH = :\n  GPU: Tesla V100-SXM2-32GB\n\n                                            Nonhydrostatic model benchmarks\n┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬────────────┬──────────┬────────┬─────────┐\n│ Architectures │ Float_types │  Ns │        min │     median │       mean │        max │   memory │ allocs │ samples │\n├───────────────┼─────────────┼─────┼────────────┼────────────┼────────────┼────────────┼──────────┼────────┼─────────┤\n│           CPU │     Float32 │  32 │  34.822 ms │  34.872 ms │  35.278 ms │  38.143 ms │ 1.38 MiB │   2302 │      10 │\n│           CPU │     Float32 │  64 │ 265.408 ms │ 265.571 ms │ 265.768 ms │ 267.765 ms │ 1.38 MiB │   2302 │      10 │\n│           CPU │     Float32 │ 128 │    2.135 s │    2.135 s │    2.136 s │    2.138 s │ 1.38 MiB │   2302 │       3 │\n│           CPU │     Float32 │ 256 │   17.405 s │   17.405 s │   17.405 s │   17.405 s │ 1.38 MiB │   2302 │       1 │\n│           CPU │     Float64 │  32 │  37.022 ms │  37.179 ms │  37.335 ms │  39.017 ms │ 1.77 MiB │   2302 │      10 │\n│           CPU │     Float64 │  64 │ 287.944 ms │ 288.154 ms │ 288.469 ms │ 290.838 ms │ 1.77 MiB │   2302 │      10 │\n│           CPU │     Float64 │ 128 │    2.326 s │    2.326 s │    2.326 s │    2.327 s │ 1.77 MiB │   2302 │       3 │\n│           CPU │     Float64 │ 256 │   19.561 s │   19.561 s │   19.561 s │   19.561 s │ 1.77 MiB │   2302 │       1 │\n│           GPU │     Float32 │  32 │   4.154 ms │   4.250 ms │   4.361 ms │   5.557 ms │ 2.13 MiB │   6033 │      10 │\n│           GPU │     Float32 │  64 │   3.383 ms │   3.425 ms │   3.889 ms │   8.028 ms │ 2.13 MiB │   6077 │      10 │\n│           GPU │     Float32 │ 128 │   5.564 ms │   5.580 ms │   6.095 ms │  10.725 ms │ 2.15 MiB │   7477 │      10 │\n│           GPU │     Float32 │ 256 │  38.685 ms │  38.797 ms │  39.548 ms │  46.442 ms │ 2.46 MiB │  27721 │      10 │\n│           GPU │     Float64 │  32 │   3.309 ms │   3.634 ms │   3.802 ms │   5.844 ms │ 2.68 MiB │   6033 │      10 │\n│           GPU │     Float64 │  64 │   3.330 ms │   3.648 ms │   4.008 ms │   7.808 ms │ 2.68 MiB │   6071 │      10 │\n│           GPU │     Float64 │ 128 │   7.209 ms │   7.323 ms │   8.313 ms │  17.259 ms │ 2.71 MiB │   8515 │      10 │\n│           GPU │     Float64 │ 256 │  46.614 ms │  56.444 ms │  55.461 ms │  56.563 ms │ 3.17 MiB │  38253 │      10 │\n└───────────────┴─────────────┴─────┴────────────┴────────────┴────────────┴────────────┴──────────┴────────┴─────────┘\n\n      Nonhydrostatic model CPU to GPU speedup\n┌─────────────┬─────┬─────────┬─────────┬─────────┐\n│ Float_types │  Ns │ speedup │  memory │  allocs │\n├─────────────┼─────┼─────────┼─────────┼─────────┤\n│     Float32 │  32 │ 8.20434 │ 1.53786 │ 2.62076 │\n│     Float32 │  64 │ 77.5308 │ 1.53835 │ 2.63988 │\n│     Float32 │ 128 │ 382.591 │ 1.55378 │ 3.24805 │\n│     Float32 │ 256 │ 448.619 │ 1.77688 │ 12.0421 │\n│     Float64 │  32 │ 10.2308 │ 1.51613 │ 2.62076 │\n│     Float64 │  64 │ 78.9952 │ 1.51646 │ 2.63727 │\n│     Float64 │ 128 │ 317.663 │ 1.53759 │ 3.69896 │\n│     Float64 │ 256 │ 346.554 │ 1.79466 │ 16.6173 │\n└─────────────┴─────┴─────────┴─────────┴─────────┘","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Like the shallow water model, it can be seen at grid size 64^3 that the GPU is beginning to be saturated as speedups rapidly increase. At grid sizes 128^3 and 256^3 we see the speedup stabilize to around 400 times.","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"(Image: incompressible_speedup)","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"For both float types, the benchmarked GPU times of the nonhydrostatic model starts to scale like its CPU times when grid size reaches 128^3.","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"(Image: incompressible_times)","category":"page"},{"location":"appendix/benchmarks/#Distributed-Shallow-Water-Model","page":"Performance benchmarks","title":"Distributed Shallow Water Model","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"By using MPI.jl the shallow water model can be run on multiple CPUs and multiple GPUs. For the benchmark results shown below, each rank is run on one CPU core and each uses a distinct GPU if applicable. ","category":"page"},{"location":"appendix/benchmarks/#Weak-Scaling-Shallow-Water-Model","page":"Performance benchmarks","title":"Weak Scaling Shallow Water Model","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Oceananigans v0.58.2\nJulia Version 1.6.0\nCommit f9720dc2eb (2021-03-24 12:55 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, broadwell)\nEnvironment:\n  EBVERSIONJULIA = 1.6.0\n  JULIA_DEPOT_PATH = :\n  EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0\n  EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel\n  JULIA_LOAD_PATH = :\n\n                                  Shallow water model weak scaling benchmark\n┌───────────────┬──────────┬────────────┬────────────┬────────────┬────────────┬──────────┬────────┬─────────┐\n│          size │    ranks │        min │     median │       mean │        max │   memory │ allocs │ samples │\n├───────────────┼──────────┼────────────┼────────────┼────────────┼────────────┼──────────┼────────┼─────────┤\n│   (4096, 256) │   (1, 1) │ 363.885 ms │ 364.185 ms │ 364.911 ms │ 370.414 ms │ 1.60 MiB │   2774 │      10 │\n│   (4096, 512) │   (1, 2) │ 370.782 ms │ 375.032 ms │ 375.801 ms │ 394.781 ms │ 1.49 MiB │   3116 │      20 │\n│  (4096, 1024) │   (1, 4) │ 369.648 ms │ 369.973 ms │ 371.613 ms │ 399.526 ms │ 1.49 MiB │   3116 │      40 │\n│  (4096, 2048) │   (1, 8) │ 377.386 ms │ 379.982 ms │ 382.732 ms │ 432.787 ms │ 1.49 MiB │   3116 │      80 │\n│  (4096, 4096) │  (1, 16) │ 388.336 ms │ 395.473 ms │ 400.079 ms │ 496.598 ms │ 1.49 MiB │   3116 │     160 │\n│  (4096, 8192) │  (1, 32) │ 403.565 ms │ 447.136 ms │ 449.138 ms │ 545.945 ms │ 1.49 MiB │   3116 │     320 │\n│ (4096, 16384) │  (1, 64) │ 397.965 ms │ 441.627 ms │ 453.465 ms │ 619.493 ms │ 1.49 MiB │   3125 │     640 │\n│ (4096, 32768) │ (1, 128) │ 400.481 ms │ 447.789 ms │ 448.692 ms │ 590.028 ms │ 1.49 MiB │   3125 │    1280 │\n└───────────────┴──────────┴────────────┴────────────┴────────────┴────────────┴──────────┴────────┴─────────┘\n\n                Shallow water model weak scaling speedup\n┌───────────────┬──────────┬──────────┬────────────┬──────────┬─────────┐\n│          size │    ranks │ slowdown │ efficiency │   memory │  allocs │\n├───────────────┼──────────┼──────────┼────────────┼──────────┼─────────┤\n│   (4096, 256) │   (1, 1) │      1.0 │        1.0 │      1.0 │     1.0 │\n│   (4096, 512) │   (1, 2) │  1.02978 │   0.971077 │ 0.930602 │ 1.12329 │\n│  (4096, 1024) │   (1, 4) │  1.01589 │   0.984355 │ 0.930602 │ 1.12329 │\n│  (4096, 2048) │   (1, 8) │  1.04338 │   0.958427 │ 0.930602 │ 1.12329 │\n│  (4096, 4096) │  (1, 16) │  1.08591 │   0.920886 │ 0.930602 │ 1.12329 │\n│  (4096, 8192) │  (1, 32) │  1.22777 │   0.814484 │ 0.930602 │ 1.12329 │\n│ (4096, 16384) │  (1, 64) │  1.21264 │   0.824644 │ 0.930687 │ 1.12653 │\n│ (4096, 32768) │ (1, 128) │  1.22957 │   0.813296 │ 0.930687 │ 1.12653 │\n└───────────────┴──────────┴──────────┴────────────┴──────────┴─────────┘","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"As seen in the tables above and in the graph below, efficiency drops off to around 80% and remains as such from 16 to 128 ranks. GPUs are not used in this or the next benchmark setup. ","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"(Image: ws_shallow_water_efficiency)","category":"page"},{"location":"appendix/benchmarks/#Strong-Scaling-Shallow-Water-Model","page":"Performance benchmarks","title":"Strong Scaling Shallow Water Model","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Oceananigans v0.58.2\nJulia Version 1.6.0\nCommit f9720dc2eb (2021-03-24 12:55 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, broadwell)\nEnvironment:\n  EBVERSIONJULIA = 1.6.0\n  JULIA_DEPOT_PATH = :\n  EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0\n  EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel\n  JULIA_LOAD_PATH = :\n\n                                Shallow water model strong scaling benchmark\n┌──────────────┬──────────┬────────────┬────────────┬────────────┬────────────┬──────────┬────────┬─────────┐\n│         size │    ranks │        min │     median │       mean │        max │   memory │ allocs │ samples │\n├──────────────┼──────────┼────────────┼────────────┼────────────┼────────────┼──────────┼────────┼─────────┤\n│ (4096, 4096) │   (1, 1) │    5.694 s │    5.694 s │    5.694 s │    5.694 s │ 1.60 MiB │   2804 │       1 │\n│ (4096, 4096) │   (1, 2) │    2.865 s │    2.865 s │    2.866 s │    2.869 s │ 1.49 MiB │   3146 │       4 │\n│ (4096, 4096) │   (1, 4) │    1.435 s │    1.437 s │    1.441 s │    1.475 s │ 1.49 MiB │   3146 │      16 │\n│ (4096, 4096) │   (1, 8) │ 732.711 ms │ 736.394 ms │ 738.930 ms │ 776.773 ms │ 1.49 MiB │   3146 │      56 │\n│ (4096, 4096) │  (1, 16) │ 389.211 ms │ 395.749 ms │ 396.813 ms │ 433.332 ms │ 1.49 MiB │   3116 │     160 │\n│ (4096, 4096) │  (1, 32) │ 197.894 ms │ 219.211 ms │ 236.780 ms │ 367.188 ms │ 1.49 MiB │   3116 │     320 │\n│ (4096, 4096) │  (1, 64) │ 101.520 ms │ 112.606 ms │ 116.809 ms │ 221.497 ms │ 1.49 MiB │   3125 │     640 │\n│ (4096, 4096) │ (1, 128) │  51.452 ms │  60.256 ms │  70.959 ms │ 232.309 ms │ 1.49 MiB │   3125 │    1280 │\n└──────────────┴──────────┴────────────┴────────────┴────────────┴────────────┴──────────┴────────┴─────────┘\n\n              Shallow water model strong scaling speedup\n┌──────────────┬──────────┬─────────┬────────────┬──────────┬─────────┐\n│         size │    ranks │ speedup │ efficiency │   memory │  allocs │\n├──────────────┼──────────┼─────────┼────────────┼──────────┼─────────┤\n│ (4096, 4096) │   (1, 1) │     1.0 │        1.0 │      1.0 │     1.0 │\n│ (4096, 4096) │   (1, 2) │ 1.98728 │   0.993641 │ 0.930621 │ 1.12197 │\n│ (4096, 4096) │   (1, 4) │ 3.96338 │   0.990845 │ 0.930621 │ 1.12197 │\n│ (4096, 4096) │   (1, 8) │ 7.73237 │   0.966547 │ 0.930621 │ 1.12197 │\n│ (4096, 4096) │  (1, 16) │ 14.3881 │   0.899255 │ 0.930336 │ 1.11127 │\n│ (4096, 4096) │  (1, 32) │ 25.9754 │   0.811731 │ 0.930336 │ 1.11127 │\n│ (4096, 4096) │  (1, 64) │ 50.5666 │   0.790102 │ 0.930421 │ 1.11448 │\n│ (4096, 4096) │ (1, 128) │ 94.4984 │   0.738269 │ 0.930421 │ 1.11448 │\n└──────────────┴──────────┴─────────┴────────────┴──────────┴─────────┘","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Slightly differing from the weak scaling results, efficiencies drop below 80% to around 74% at 128 ranks for the strong scaling distributed shallow water model benchmark. This is likely caused by the 128 CPU cores not being sufficiently saturated anymore by the constant 4096^2 grid size thus losing some efficiency overheads.","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"(Image: ss_shallow_water_efficiency)","category":"page"},{"location":"appendix/benchmarks/#Multi-GPU-Shallow-Water-Model","page":"Performance benchmarks","title":"Multi-GPU Shallow Water Model","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"While still a work in progress, it is possible to use CUDA-aware MPI to run the shallow water model on multiple GPUs. Though efficiencies may not be as high as multi-CPU, the multi-GPU architecture is still worthwhile when keeping in mind the baseline speedups generated by using a single GPU. Note that though it is possible for multiple ranks to share the use of a single GPU, efficiencies would significantly decrease and memory may be insufficient. The results below show up to three ranks each using a separate GPU.","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Julia Version 1.6.2\nCommit 1b93d53fc4 (2021-07-14 15:36 UTC)\nPlatform Info:\n  OS: Linux (powerpc64le-unknown-linux-gnu)\n  CPU: unknown\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, pwr9)\nEnvironment:\n  JULIA_MPI_PATH = /home/software/spack/openmpi/3.1.4-nhjzelonyovxks5ydtrxehceqxsbf7ik\n  JULIA_CUDA_USE_BINARYBUILDER = false\n  JULIA_DEPOT_PATH = /nobackup/users/henryguo/projects/henry-test/Oceananigans.jl/benchmark/.julia\n  GPU: Tesla V100-SXM2-32GB\n  \n                              Shallow water model weak scaling benchmark\n┌───────────────┬──────────┬─────────┬─────────┬─────────┬─────────┬──────────┬────────┬─────────┐\n│          size │    ranks │     min │  median │    mean │     max │   memory │ allocs │ samples │\n├───────────────┼──────────┼─────────┼─────────┼─────────┼─────────┼──────────┼────────┼─────────┤\n│   (4096, 256) │   (1, 1) │ 2.702 ms│ 2.728 ms│ 2.801 ms│ 3.446 ms│ 2.03 MiB │   5535 │      10 │\n│   (4096, 512) │   (1, 2) │ 3.510 ms│ 3.612 ms│ 4.287 ms│16.546 ms│ 2.03 MiB │   5859 │      20 │\n│   (4096, 768) │   (1, 3) │ 3.553 ms│ 3.653 ms│ 5.195 ms│39.152 ms│ 2.03 MiB │   5859 │      30 │\n└───────────────┴──────────┴─────────┴─────────┴─────────┴─────────┴──────────┴────────┴─────────┘\n\n                Shallow water model weak scaling speedup\n┌───────────────┬──────────┬──────────┬────────────┬──────────┬─────────┐\n│          size │    ranks │ slowdown │ efficiency │   memory │  allocs │\n├───────────────┼──────────┼──────────┼────────────┼──────────┼─────────┤\n│   (4096, 256) │   (1, 1) │      1.0 │        1.0 │      1.0 │     1.0 │\n│   (4096, 512) │   (1, 2) │  1.32399 │   0.755293 │  1.00271 │ 1.05854 │\n│   (4096, 768) │   (1, 3) │  1.33901 │   0.746818 │  1.00271 │ 1.05854 │\n└───────────────┴──────────┴──────────┴────────────┴──────────┴─────────┘","category":"page"},{"location":"appendix/benchmarks/#Distributed-Nonhydrostatic-Model","page":"Performance benchmarks","title":"Distributed Nonhydrostatic Model","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Similar to the distributed shallow water model benchmark results shown above, the distributed nonhydrostatic model was also benchmarked with the strong and weak scaling methods.","category":"page"},{"location":"appendix/benchmarks/#Weak-Scaling-Nonhydrostatic-Model","page":"Performance benchmarks","title":"Weak Scaling Nonhydrostatic Model","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Weak scaling efficiencies can be improved for the nonhydrostatic model.","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Oceananigans v0.60.1\nJulia Version 1.6.1\nCommit 6aaedecc44 (2021-04-23 05:59 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, broadwell)\nEnvironment:\n  JULIA_MPI_PATH = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Compiler/intel2020/openmpi/4.0.3\n  EBVERSIONJULIA = 1.6.1\n  JULIA_DEPOT_PATH = :\n  JULIA_MPI_BINARY = system\n  JULIA_MPI_LIBRARY = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Compiler/intel2020/openmpi/4.0.3/lib64/libmpi.so\n  EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1\n  JULIA_MPI_ABI = OpenMPI\n  EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1/easybuild/avx2-Core-julia-1.6.1-easybuild-devel\n  JULIA_LOAD_PATH = :\n  JULIA_MPIEXEC = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Compiler/intel2020/openmpi/4.0.3/bin/mpiexec\n\n                                    Nonhydrostatic model weak scaling benchmark\n┌──────────────────┬─────────────┬────────────┬────────────┬────────────┬────────────┬──────────┬────────┬─────────┐\n│             size │       ranks │        min │     median │       mean │        max │   memory │ allocs │ samples │\n├──────────────────┼─────────────┼────────────┼────────────┼────────────┼────────────┼──────────┼────────┼─────────┤\n│   (128, 128, 16) │   (1, 1, 1) │  33.568 ms │  34.087 ms │  34.173 ms │  34.894 ms │ 2.05 MiB │   2762 │      10 │\n│   (128, 128, 32) │   (1, 2, 1) │  36.650 ms │  37.161 ms │  37.393 ms │  42.411 ms │ 1.99 MiB │   3096 │      20 │\n│   (128, 128, 64) │   (1, 4, 1) │  41.861 ms │  43.440 ms │  46.176 ms │  97.578 ms │ 1.99 MiB │   3136 │      40 │\n│  (128, 128, 128) │   (1, 8, 1) │  59.995 ms │  64.110 ms │  68.021 ms │ 138.422 ms │ 1.99 MiB │   3216 │      80 │\n│  (128, 128, 256) │  (1, 16, 1) │  62.633 ms │  71.266 ms │  74.775 ms │ 164.206 ms │ 2.01 MiB │   3376 │     160 │\n│  (128, 128, 512) │  (1, 32, 1) │ 108.253 ms │ 135.611 ms │ 139.384 ms │ 225.336 ms │ 2.04 MiB │   3722 │     320 │\n│ (128, 128, 1024) │  (1, 64, 1) │ 138.504 ms │ 181.043 ms │ 186.386 ms │ 335.170 ms │ 2.12 MiB │   4372 │     640 │\n│ (128, 128, 2048) │ (1, 128, 1) │ 218.592 ms │ 285.293 ms │ 290.989 ms │ 434.878 ms │ 2.39 MiB │   5652 │    1280 │\n└──────────────────┴─────────────┴────────────┴────────────┴────────────┴────────────┴──────────┴────────┴─────────┘\n\n                   Nonhydrostatic model weak scaling speedup\n┌──────────────────┬─────────────┬──────────┬────────────┬──────────┬─────────┐\n│             size │       ranks │  speedup │ efficiency │   memory │  allocs │\n├──────────────────┼─────────────┼──────────┼────────────┼──────────┼─────────┤\n│   (128, 128, 16) │   (1, 1, 1) │      1.0 │        1.0 │      1.0 │     1.0 │\n│   (128, 128, 32) │   (1, 2, 1) │ 0.917292 │   0.917292 │ 0.968543 │ 1.12093 │\n│   (128, 128, 64) │   (1, 4, 1) │ 0.784698 │   0.784698 │ 0.969719 │ 1.13541 │\n│  (128, 128, 128) │   (1, 8, 1) │ 0.531697 │   0.531697 │ 0.972279 │ 1.16437 │\n│  (128, 128, 256) │  (1, 16, 1) │ 0.478315 │   0.478315 │ 0.978143 │  1.2223 │\n│  (128, 128, 512) │  (1, 32, 1) │ 0.251361 │   0.251361 │ 0.992878 │ 1.34757 │\n│ (128, 128, 1024) │  (1, 64, 1) │ 0.188283 │   0.188283 │  1.03539 │ 1.58291 │\n│ (128, 128, 2048) │ (1, 128, 1) │ 0.119482 │   0.119482 │  1.16791 │ 2.04634 │\n└──────────────────┴─────────────┴──────────┴────────────┴──────────┴─────────┘","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"(Image: ws_nonhydrostatic_efficiency)","category":"page"},{"location":"appendix/benchmarks/#Strong-Scaling-Nonhydrostatic-Model","page":"Performance benchmarks","title":"Strong Scaling Nonhydrostatic Model","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Strong scaling efficiencies can also be improved for the nonhydrostatic model.","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Oceananigans v0.60.1\nJulia Version 1.6.1\nCommit 6aaedecc44 (2021-04-23 05:59 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, broadwell)\nEnvironment:\n  JULIA_MPI_PATH = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Compiler/intel2020/openmpi/4.0.3\n  EBVERSIONJULIA = 1.6.1\n  JULIA_DEPOT_PATH = :\n  JULIA_MPI_BINARY = system\n  JULIA_MPI_LIBRARY = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Compiler/intel2020/openmpi/4.0.3/lib64/libmpi.so\n  EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1\n  JULIA_MPI_ABI = OpenMPI\n  EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1/easybuild/avx2-Core-julia-1.6.1-easybuild-devel\n  JULIA_LOAD_PATH = :\n  JULIA_MPIEXEC = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Compiler/intel2020/openmpi/4.0.3/bin/mpiexec\n\n                                   Nonhydrostatic model strong scaling benchmark\n┌─────────────────┬─────────────┬────────────┬────────────┬────────────┬────────────┬──────────┬────────┬─────────┐\n│            size │       ranks │        min │     median │       mean │        max │   memory │ allocs │ samples │\n├─────────────────┼─────────────┼────────────┼────────────┼────────────┼────────────┼──────────┼────────┼─────────┤\n│ (256, 256, 256) │   (1, 1, 1) │    3.049 s │    3.053 s │    3.053 s │    3.057 s │ 2.05 MiB │   2762 │       2 │\n│ (256, 256, 256) │   (1, 2, 1) │    1.609 s │    1.610 s │    1.611 s │    1.620 s │ 1.99 MiB │   3096 │       8 │\n│ (256, 256, 256) │   (1, 4, 1) │ 814.290 ms │ 817.305 ms │ 818.685 ms │ 833.792 ms │ 1.99 MiB │   3136 │      28 │\n│ (256, 256, 256) │   (1, 8, 1) │ 434.521 ms │ 439.352 ms │ 443.049 ms │ 508.913 ms │ 1.99 MiB │   3216 │      80 │\n│ (256, 256, 256) │  (1, 16, 1) │ 251.632 ms │ 272.364 ms │ 277.555 ms │ 370.059 ms │ 2.01 MiB │   3376 │     160 │\n│ (256, 256, 256) │  (1, 32, 1) │ 182.380 ms │ 233.322 ms │ 247.325 ms │ 441.971 ms │ 2.04 MiB │   3696 │     320 │\n│ (256, 256, 256) │  (1, 64, 1) │ 119.546 ms │ 178.933 ms │ 204.036 ms │ 564.097 ms │ 2.12 MiB │   4346 │     640 │\n│ (256, 256, 256) │ (1, 128, 1) │  73.802 ms │ 120.147 ms │ 136.395 ms │ 378.697 ms │ 2.39 MiB │   5626 │    1280 │\n└─────────────────┴─────────────┴────────────┴────────────┴────────────┴────────────┴──────────┴────────┴─────────┘\n\n                 Nonhydrostatic model strong scaling speedup\n┌─────────────────┬─────────────┬─────────┬────────────┬──────────┬─────────┐\n│            size │       ranks │ speedup │ efficiency │   memory │  allocs │\n├─────────────────┼─────────────┼─────────┼────────────┼──────────┼─────────┤\n│ (256, 256, 256) │   (1, 1, 1) │     1.0 │        1.0 │      1.0 │     1.0 │\n│ (256, 256, 256) │   (1, 2, 1) │ 1.89655 │   0.948276 │ 0.968543 │ 1.12093 │\n│ (256, 256, 256) │   (1, 4, 1) │ 3.73522 │   0.933804 │ 0.969719 │ 1.13541 │\n│ (256, 256, 256) │   (1, 8, 1) │ 6.94845 │   0.868556 │ 0.972279 │ 1.16437 │\n│ (256, 256, 256) │  (1, 16, 1) │ 11.2086 │   0.700536 │ 0.978143 │  1.2223 │\n│ (256, 256, 256) │  (1, 32, 1) │ 13.0841 │   0.408879 │ 0.992685 │ 1.33816 │\n│ (256, 256, 256) │  (1, 64, 1) │ 17.0612 │   0.266582 │  1.03519 │  1.5735 │\n│ (256, 256, 256) │ (1, 128, 1) │  25.409 │   0.198508 │  1.16772 │ 2.03693 │\n└─────────────────┴─────────────┴─────────┴────────────┴──────────┴─────────┘","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"(Image: ss_nonhydrostatic_efficiency)","category":"page"},{"location":"appendix/benchmarks/#Multithreading","page":"Performance benchmarks","title":"Multithreading","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Oceananigans can also achieve parallelism via multithreading. Though its efficiencies are less than that of the MPI distributed architectures, its simple setup still makes it a viable option for achieving speedups on simple systems.","category":"page"},{"location":"appendix/benchmarks/#Weak-Scaling-Multithreaded-Shallow-Water-Model","page":"Performance benchmarks","title":"Weak Scaling Multithreaded Shallow Water Model","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"The initial drop and then rise in efficiencies going from 1 to 2 to 4 threads is likely caused by the 2 threads being automatically allocated onto only one physical CPU core. Though one physical CPU core may contain 2 logical cores each capable of running a separate thread, having 2 threads run on one core will still reduce efficiencies as many resources such as caches and buses must be shared by both threads. Note that there are as many CPU cores allocated as the maximum number of threads.","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Oceananigans v0.58.9\nJulia Version 1.6.0\nCommit f9720dc2eb (2021-03-24 12:55 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, broadwell)\nEnvironment:\n  EBVERSIONJULIA = 1.6.0\n  JULIA_DEPOT_PATH = :\n  EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0\n  EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel\n  JULIA_LOAD_PATH = :\n\n                  Shallow water model weak scaling with multithreading benchmark\n┌───────────────┬─────────┬─────────┬─────────┬─────────┬─────────┬───────────┬─────────┬─────────┐\n│          size │ threads │     min │  median │    mean │     max │    memory │  allocs │ samples │\n├───────────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼─────────┼─────────┤\n│   (8192, 512) │       1 │ 1.458 s │ 1.458 s │ 1.458 s │ 1.458 s │  1.37 MiB │    2318 │       4 │\n│  (8192, 1024) │       2 │ 2.925 s │ 2.989 s │ 2.989 s │ 3.052 s │ 18.06 MiB │ 1076944 │       2 │\n│  (8192, 2048) │       4 │ 2.296 s │ 2.381 s │ 2.397 s │ 2.515 s │ 13.60 MiB │  760190 │       3 │\n│  (8192, 4096) │       8 │ 2.347 s │ 2.369 s │ 2.377 s │ 2.415 s │ 16.36 MiB │  891860 │       3 │\n│  (8192, 8192) │      16 │ 2.407 s │ 2.548 s │ 2.517 s │ 2.595 s │ 17.44 MiB │  863941 │       3 │\n│ (8192, 16384) │      32 │ 3.023 s │ 3.069 s │ 3.069 s │ 3.115 s │ 23.03 MiB │ 1034063 │       2 │\n└───────────────┴─────────┴─────────┴─────────┴─────────┴─────────┴───────────┴─────────┴─────────┘\n\n        Shallow water model weak multithreading scaling speedup\n┌───────────────┬─────────┬──────────┬────────────┬─────────┬─────────┐\n│          size │ threads │ slowdown │ efficiency │  memory │  allocs │\n├───────────────┼─────────┼──────────┼────────────┼─────────┼─────────┤\n│   (8192, 512) │       1 │      1.0 │        1.0 │     1.0 │     1.0 │\n│  (8192, 1024) │       2 │  2.04972 │   0.487872 │ 13.2156 │ 464.601 │\n│  (8192, 2048) │       4 │  1.63302 │   0.612363 │ 9.95278 │ 327.951 │\n│  (8192, 4096) │       8 │  1.62507 │   0.615359 │ 11.9706 │ 384.754 │\n│  (8192, 8192) │      16 │  1.74747 │   0.572257 │  12.755 │  372.71 │\n│ (8192, 16384) │      32 │  2.10486 │    0.47509 │  16.846 │ 446.101 │\n└───────────────┴─────────┴──────────┴────────────┴─────────┴─────────┘","category":"page"},{"location":"appendix/benchmarks/#Strong-Scaling-Multithreaded-Nonhydrostatic-Model","page":"Performance benchmarks","title":"Strong Scaling Multithreaded Nonhydrostatic Model","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"The notable and continuous decrease in efficiencies for the strong scaling nonhydrostatic model is likely caused by the 256^3 grid not sufficiently saturating 32 threads running on 32 CPUs. At the time this benchmark was produced, multithreading for both nonhydrostatic and shallow water models is still an active area of improvement. Please use the appropriate scripts found in benchmarks to obtain more recent and hopefully ameliorated benchmark results.","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Oceananigans v0.58.9\nJulia Version 1.6.1\nCommit 6aaedecc44 (2021-04-23 05:59 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, broadwell)\nEnvironment:\n  EBVERSIONJULIA = 1.6.1\n  JULIA_DEPOT_PATH = :\n  EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1\n  EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1/easybuild/avx2-Core-julia-1.6.1-easybuild-devel\n  JULIA_LOAD_PATH = :\n\n                                     Multithreading benchmarks\n┌──────┬─────────┬────────────┬────────────┬────────────┬────────────┬──────────┬────────┬─────────┐\n│ size │ threads │        min │     median │       mean │        max │   memory │ allocs │ samples │\n├──────┼─────────┼────────────┼────────────┼────────────┼────────────┼──────────┼────────┼─────────┤\n│  256 │       1 │    2.496 s │    2.637 s │    2.637 s │    2.777 s │ 1.70 MiB │   2251 │       2 │\n│  256 │       2 │    2.385 s │    2.618 s │    2.618 s │    2.851 s │ 7.03 MiB │ 342397 │       2 │\n│  256 │       4 │    1.320 s │    1.321 s │    1.333 s │    1.371 s │ 3.69 MiB │ 113120 │       4 │\n│  256 │       8 │ 850.438 ms │ 855.292 ms │ 855.952 ms │ 861.966 ms │ 3.31 MiB │  65709 │       6 │\n│  256 │      16 │ 642.225 ms │ 645.458 ms │ 648.685 ms │ 674.259 ms │ 3.60 MiB │  40992 │       8 │\n│  256 │      32 │ 680.938 ms │ 694.376 ms │ 701.272 ms │ 746.599 ms │ 4.88 MiB │  36729 │       8 │\n└──────┴─────────┴────────────┴────────────┴────────────┴────────────┴──────────┴────────┴─────────┘\n\n     Nonhydrostatic Strong Scaling Multithreading speedup\n┌──────┬─────────┬──────────┬────────────┬─────────┬─────────┐\n│ size │ threads │ slowdown │ efficiency │  memory │  allocs │\n├──────┼─────────┼──────────┼────────────┼─────────┼─────────┤\n│  256 │       1 │      1.0 │        1.0 │     1.0 │     1.0 │\n│  256 │       2 │ 0.992966 │   0.503542 │ 4.14014 │ 152.109 │\n│  256 │       4 │ 0.501089 │   0.498913 │ 2.17724 │ 50.2532 │\n│  256 │       8 │ 0.324366 │   0.385367 │ 1.94899 │  29.191 │\n│  256 │      16 │ 0.244788 │   0.255323 │ 2.12262 │ 18.2106 │\n│  256 │      32 │ 0.263339 │   0.118668 │ 2.87624 │ 16.3167 │\n└──────┴─────────┴──────────┴────────────┴─────────┴─────────┘","category":"page"},{"location":"appendix/benchmarks/#Tracers","page":"Performance benchmarks","title":"Tracers","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"This benchmark tests the performance impacts of running with various amounts of active and passive tracers and compares the difference in speedup going from CPU to GPU. Number of tracers are listed in the tracers column as (active, passive). ","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Oceananigans v0.58.1\nJulia Version 1.6.0\nCommit f9720dc2eb (2021-03-24 12:55 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake)\nEnvironment:\n  EBVERSIONJULIA = 1.6.0\n  JULIA_DEPOT_PATH = :\n  EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0\n  EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel\n  JULIA_LOAD_PATH = :\n  GPU: Tesla V100-SXM2-32GB\n\n                                       Arbitrary tracers benchmarks\n┌───────────────┬─────────┬───────────┬───────────┬───────────┬───────────┬────────────┬────────┬─────────┐\n│ Architectures │ tracers │       min │    median │      mean │       max │     memory │ allocs │ samples │\n├───────────────┼─────────┼───────────┼───────────┼───────────┼───────────┼────────────┼────────┼─────────┤\n│           CPU │  (0, 0) │   1.439 s │   1.440 s │   1.440 s │   1.441 s │ 908.03 KiB │   1656 │       4 │\n│           CPU │  (0, 1) │   1.539 s │   1.574 s │   1.575 s │   1.613 s │   1.24 MiB │   1942 │       4 │\n│           CPU │  (0, 2) │   1.668 s │   1.669 s │   1.670 s │   1.671 s │   1.76 MiB │   2291 │       3 │\n│           CPU │  (1, 0) │   1.527 s │   1.532 s │   1.532 s │   1.536 s │   1.24 MiB │   1942 │       4 │\n│           CPU │  (2, 0) │   1.690 s │   1.697 s │   1.695 s │   1.698 s │   1.77 MiB │   2301 │       3 │\n│           CPU │  (2, 3) │   2.234 s │   2.239 s │   2.241 s │   2.251 s │   3.59 MiB │   3928 │       3 │\n│           CPU │  (2, 5) │   2.755 s │   2.838 s │   2.838 s │   2.921 s │   5.18 MiB │   4908 │       2 │\n│           CPU │ (2, 10) │   3.588 s │   3.748 s │   3.748 s │   3.908 s │  10.39 MiB │   7682 │       2 │\n│           GPU │  (0, 0) │  9.702 ms │ 12.755 ms │ 12.458 ms │ 12.894 ms │   1.59 MiB │  12321 │      10 │\n│           GPU │  (0, 1) │ 13.863 ms │ 13.956 ms │ 14.184 ms │ 16.297 ms │   2.20 MiB │  14294 │      10 │\n│           GPU │  (0, 2) │ 15.166 ms │ 15.230 ms │ 15.700 ms │ 19.893 ms │   2.93 MiB │  15967 │      10 │\n│           GPU │  (1, 0) │ 13.740 ms │ 13.838 ms │ 14.740 ms │ 22.940 ms │   2.20 MiB │  14278 │      10 │\n│           GPU │  (2, 0) │ 15.103 ms │ 15.199 ms │ 16.265 ms │ 25.906 ms │   2.93 MiB │  15913 │      10 │\n│           GPU │  (2, 3) │ 13.981 ms │ 18.856 ms │ 18.520 ms │ 20.519 ms │   5.56 MiB │  17974 │      10 │\n│           GPU │  (2, 5) │ 15.824 ms │ 21.211 ms │ 21.064 ms │ 24.897 ms │   7.86 MiB │  23938 │      10 │\n│           GPU │ (2, 10) │ 22.085 ms │ 27.236 ms │ 28.231 ms │ 38.295 ms │  15.02 MiB │  31086 │      10 │\n└───────────────┴─────────┴───────────┴───────────┴───────────┴───────────┴────────────┴────────┴─────────┘\n\n  Arbitrary tracers CPU to GPU speedup\n┌─────────┬─────────┬─────────┬─────────┐\n│ tracers │ speedup │  memory │  allocs │\n├─────────┼─────────┼─────────┼─────────┤\n│  (0, 0) │ 112.881 │ 1.78792 │ 7.44022 │\n│  (0, 1) │ 112.761 │ 1.77743 │ 7.36045 │\n│  (0, 2) │ 109.618 │  1.6627 │ 6.96945 │\n│  (1, 0) │ 110.717 │ 1.77723 │ 7.35221 │\n│  (2, 0) │ 111.678 │ 1.66267 │ 6.91569 │\n│  (2, 3) │ 118.737 │ 1.55043 │ 4.57587 │\n│  (2, 5) │ 133.803 │  1.5155 │ 4.87734 │\n│ (2, 10) │ 137.615 │ 1.44535 │  4.0466 │\n└─────────┴─────────┴─────────┴─────────┘\n\n       Arbitrary tracers relative performance (CPU)\n┌───────────────┬─────────┬──────────┬─────────┬─────────┐\n│ Architectures │ tracers │ slowdown │  memory │  allocs │\n├───────────────┼─────────┼──────────┼─────────┼─────────┤\n│           CPU │  (0, 0) │      1.0 │     1.0 │     1.0 │\n│           CPU │  (0, 1) │  1.09293 │ 1.39873 │ 1.17271 │\n│           CPU │  (0, 2) │  1.15948 │ 1.99019 │ 1.38345 │\n│           CPU │  (1, 0) │  1.06409 │ 1.39873 │ 1.17271 │\n│           CPU │  (2, 0) │  1.17887 │ 1.99054 │ 1.38949 │\n│           CPU │  (2, 3) │  1.55493 │ 4.04677 │ 2.37198 │\n│           CPU │  (2, 5) │  1.97115 │ 5.84537 │ 2.96377 │\n│           CPU │ (2, 10) │   2.6031 │ 11.7179 │ 4.63889 │\n└───────────────┴─────────┴──────────┴─────────┴─────────┘\n\n       Arbitrary tracers relative performance (GPU)\n┌───────────────┬─────────┬──────────┬─────────┬─────────┐\n│ Architectures │ tracers │ slowdown │  memory │  allocs │\n├───────────────┼─────────┼──────────┼─────────┼─────────┤\n│           GPU │  (0, 0) │      1.0 │     1.0 │     1.0 │\n│           GPU │  (0, 1) │   1.0941 │ 1.39053 │ 1.16013 │\n│           GPU │  (0, 2) │  1.19399 │ 1.85081 │ 1.29592 │\n│           GPU │  (1, 0) │  1.08489 │ 1.39037 │ 1.15883 │\n│           GPU │  (2, 0) │  1.19157 │ 1.85109 │ 1.29153 │\n│           GPU │  (2, 3) │  1.47824 │ 3.50924 │ 1.45881 │\n│           GPU │  (2, 5) │  1.66293 │ 4.95474 │ 1.94286 │\n│           GPU │ (2, 10) │  2.13524 │ 9.47276 │ 2.52301 │\n└───────────────┴─────────┴──────────┴─────────┴─────────┘","category":"page"},{"location":"appendix/benchmarks/#Turbulence-closures","page":"Performance benchmarks","title":"Turbulence closures","text":"","category":"section"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"This benchmark tests the performance impacts of various turbulent diffusivity closures and large eddy simulation (LES) models as well as how much speedup they experience going from CPU to GPU.","category":"page"},{"location":"appendix/benchmarks/","page":"Performance benchmarks","title":"Performance benchmarks","text":"Oceananigans v0.58.1\nJulia Version 1.6.0\nCommit f9720dc2eb (2021-03-24 12:55 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake)\nEnvironment:\n  EBVERSIONJULIA = 1.6.0\n  JULIA_DEPOT_PATH = :\n  EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0\n  EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel\n  JULIA_LOAD_PATH = :\n  GPU: Tesla V100-SXM2-32GB\n\n                                                  Turbulence closure benchmarks\n┌───────────────┬──────────────────────────────────┬───────────┬───────────┬───────────┬───────────┬──────────┬────────┬─────────┐\n│ Architectures │                         Closures │       min │    median │      mean │       max │   memory │ allocs │ samples │\n├───────────────┼──────────────────────────────────┼───────────┼───────────┼───────────┼───────────┼──────────┼────────┼─────────┤\n│           CPU │ AnisotropicBiharmonicDiffusivity │   3.634 s │   3.637 s │   3.637 s │   3.639 s │ 1.77 MiB │   2316 │       2 │\n│           CPU │           AnisotropicDiffusivity │   2.045 s │   2.052 s │   2.059 s │   2.079 s │ 1.77 MiB │   2316 │       3 │\n│           CPU │    AnisotropicMinimumDissipation │   3.240 s │   3.240 s │   3.240 s │   3.241 s │ 2.09 MiB │   2763 │       2 │\n│           CPU │             IsotropicDiffusivity │   2.342 s │   2.344 s │   2.344 s │   2.345 s │ 1.77 MiB │   2316 │       3 │\n│           CPU │                 SmagorinskyLilly │   3.501 s │   3.504 s │   3.504 s │   3.507 s │ 2.03 MiB │   2486 │       2 │\n│           CPU │              TwoDimensionalLeith │   4.813 s │   4.820 s │   4.820 s │   4.828 s │ 1.88 MiB │   2481 │       2 │\n│           GPU │ AnisotropicBiharmonicDiffusivity │ 24.699 ms │ 24.837 ms │ 26.946 ms │ 46.029 ms │ 3.16 MiB │  29911 │      10 │\n│           GPU │           AnisotropicDiffusivity │ 16.115 ms │ 16.184 ms │ 16.454 ms │ 18.978 ms │ 2.97 MiB │  17169 │      10 │\n│           GPU │    AnisotropicMinimumDissipation │ 15.858 ms │ 25.856 ms │ 24.874 ms │ 26.014 ms │ 3.57 MiB │  24574 │      10 │\n│           GPU │             IsotropicDiffusivity │ 14.442 ms │ 17.415 ms │ 17.134 ms │ 17.513 ms │ 2.99 MiB │  19135 │      10 │\n│           GPU │                 SmagorinskyLilly │ 16.315 ms │ 23.969 ms │ 23.213 ms │ 24.059 ms │ 3.86 MiB │  24514 │      10 │\n│           GPU │              TwoDimensionalLeith │ 34.470 ms │ 34.628 ms │ 35.535 ms │ 43.798 ms │ 3.56 MiB │  45291 │      10 │\n└───────────────┴──────────────────────────────────┴───────────┴───────────┴───────────┴───────────┴──────────┴────────┴─────────┘\n\n              Turbulence closure CPU to GPU speedup\n┌──────────────────────────────────┬─────────┬─────────┬─────────┐\n│                         Closures │ speedup │  memory │  allocs │\n├──────────────────────────────────┼─────────┼─────────┼─────────┤\n│ AnisotropicBiharmonicDiffusivity │ 146.428 │ 1.78781 │ 12.9149 │\n│           AnisotropicDiffusivity │ 126.804 │ 1.67787 │ 7.41321 │\n│    AnisotropicMinimumDissipation │ 125.324 │ 1.70856 │ 8.89396 │\n│             IsotropicDiffusivity │ 134.607 │ 1.69269 │ 8.26209 │\n│                 SmagorinskyLilly │ 146.187 │ 1.89602 │ 9.86082 │\n│              TwoDimensionalLeith │ 139.196 │ 1.89218 │ 18.2551 │\n└──────────────────────────────────┴─────────┴─────────┴─────────┘\n","category":"page"},{"location":"model_setup/setting_initial_conditions/#Setting-initial-conditions","page":"Setting initial conditions","title":"Setting initial conditions","text":"","category":"section"},{"location":"model_setup/setting_initial_conditions/","page":"Setting initial conditions","title":"Setting initial conditions","text":"Initial conditions are imposed after model construction. This can be easily done using the set! functionality that allows the setting of initial conditions using constant values, arrays, or functions.","category":"page"},{"location":"model_setup/setting_initial_conditions/","page":"Setting initial conditions","title":"Setting initial conditions","text":"DocTestSetup = quote\n    using Oceananigans\nend","category":"page"},{"location":"model_setup/setting_initial_conditions/","page":"Setting initial conditions","title":"Setting initial conditions","text":"julia> grid = RectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1));\n\njulia> model = NonhydrostaticModel(grid=grid);\n\njulia> set!(model, u=0.1, v=1.5)","category":"page"},{"location":"model_setup/setting_initial_conditions/","page":"Setting initial conditions","title":"Setting initial conditions","text":"julia> grid = RectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1));\n\njulia> model = NonhydrostaticModel(grid=grid, buoyancy=SeawaterBuoyancy(), tracers=(:T, :S));\n\njulia> ∂T∂z = 0.01;\n\njulia> ϵ(σ) = σ * randn();\n\njulia> T₀(x, y, z) = ∂T∂z * z + ϵ(1e-8);\n\njulia> set!(model, T=T₀)","category":"page"},{"location":"model_setup/setting_initial_conditions/","page":"Setting initial conditions","title":"Setting initial conditions","text":"tip: Divergence-free velocity fields\nNote that as part of the time-stepping algorithm, the velocity field is made divergence-free at every time step. So if a model is not initialized with a divergence-free velocity field, it may change on the first time step. As a result tracers may not be conserved up to machine precision at the first time step.","category":"page"},{"location":"model_setup/tracers/#Tracers","page":"Tracers","title":"Tracers","text":"","category":"section"},{"location":"model_setup/tracers/","page":"Tracers","title":"Tracers","text":"The tracers to be advected around can be specified via a list of symbols. By default the model doesn't evolve any tracers.","category":"page"},{"location":"model_setup/tracers/","page":"Tracers","title":"Tracers","text":"DocTestSetup = quote\n    using Oceananigans\nend","category":"page"},{"location":"model_setup/tracers/","page":"Tracers","title":"Tracers","text":"julia> grid = RectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1));\n\njulia> model = NonhydrostaticModel(; grid)\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\n├── grid: 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo\n├── timestepper: RungeKutta3TimeStepper\n├── advection scheme: Centered reconstruction order 2\n├── tracers: ()\n├── closure: Nothing\n├── buoyancy: Nothing\n└── coriolis: Nothing","category":"page"},{"location":"model_setup/tracers/","page":"Tracers","title":"Tracers","text":"But tracers can be added with the tracers keyword. For example, to add conservative temperature T and absolute salinity S:","category":"page"},{"location":"model_setup/tracers/","page":"Tracers","title":"Tracers","text":"julia> model = NonhydrostaticModel(; grid, tracers=(:T, :S))\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\n├── grid: 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo\n├── timestepper: RungeKutta3TimeStepper\n├── advection scheme: Centered reconstruction order 2\n├── tracers: (T, S)\n├── closure: Nothing\n├── buoyancy: Nothing\n└── coriolis: Nothing","category":"page"},{"location":"model_setup/tracers/","page":"Tracers","title":"Tracers","text":"whose fields can be accessed via model.tracers.T and model.tracers.S.","category":"page"},{"location":"model_setup/tracers/","page":"Tracers","title":"Tracers","text":"julia> model.tracers.T\n16×16×16 Field{Center, Center, Center} on RectilinearGrid on CPU\n├── grid: 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo\n├── boundary conditions: FieldBoundaryConditions\n│   └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux\n└── data: 22×22×22 OffsetArray(::Array{Float64, 3}, -2:19, -2:19, -2:19) with eltype Float64 with indices -2:19×-2:19×-2:19\n    └── max=0.0, min=0.0, mean=0.0\n\njulia> model.tracers.S\n16×16×16 Field{Center, Center, Center} on RectilinearGrid on CPU\n├── grid: 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo\n├── boundary conditions: FieldBoundaryConditions\n│   └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux\n└── data: 22×22×22 OffsetArray(::Array{Float64, 3}, -2:19, -2:19, -2:19) with eltype Float64 with indices -2:19×-2:19×-2:19\n    └── max=0.0, min=0.0, mean=0.0","category":"page"},{"location":"model_setup/tracers/","page":"Tracers","title":"Tracers","text":"An arbitrary number of tracers may be simulated. For example, to simulate C_1, CO₂, and nitrogen as additional passive tracers,","category":"page"},{"location":"model_setup/tracers/","page":"Tracers","title":"Tracers","text":"julia> model = NonhydrostaticModel(; grid, tracers=(:T, :S, :C₁, :CO₂, :nitrogen))\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\n├── grid: 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo\n├── timestepper: RungeKutta3TimeStepper\n├── advection scheme: Centered reconstruction order 2\n├── tracers: (T, S, C₁, CO₂, nitrogen)\n├── closure: Nothing\n├── buoyancy: Nothing\n└── coriolis: Nothing","category":"page"},{"location":"model_setup/tracers/","page":"Tracers","title":"Tracers","text":"info: Active versus passive tracers\nAn active tracer is a tracer whose distribution affects the evolution of momentum and other tracers. Typical ocean models evolve conservative temperature and absolute salinity as active tracers, which effect momentum through buoyancy forces. Passive tracers are \"passive\" in the sense that their distribution does not affect the evolution of other tracers or flow quantities.","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"EditURL = \"../../../examples/tilted_bottom_boundary_layer.jl\"","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/#Tilted-bottom-boundary-layer-example","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer example","text":"","category":"section"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"This example simulates a two-dimensional oceanic bottom boundary layer in a domain that's tilted with respect to gravity. We simulate the perturbation away from a constant along-slope (y-direction) velocity constant density stratification. This perturbation develops into a turbulent bottom boundary layer due to momentum loss at the bottom boundary modeled with a quadratic drag law.","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"This example illustrates","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"changing the direction of gravitational acceleration in the buoyancy model;\nchanging the axis of rotation for Coriolis forces.","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/#Install-dependencies","page":"Tilted bottom boundary layer","title":"Install dependencies","text":"","category":"section"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"using Pkg\npkg\"add Oceananigans, NCDatasets, CairoMakie\"","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/#The-domain","page":"Tilted bottom boundary layer","title":"The domain","text":"","category":"section"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"We create a grid with finer resolution near the bottom,","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"using Oceananigans\nusing Oceananigans.Units\n\nLx = 200meters\nLz = 100meters\nNx = 64\nNz = 64\n\n# Creates a grid with near-constant spacing `refinement * Lz / Nz`\n# near the bottom:\nrefinement = 1.8 # controls spacing near surface (higher means finer spaced)\nstretching = 10  # controls rate of stretching at bottom\n\n# \"Warped\" height coordinate\nh(k) = (Nz + 1 - k) / Nz\n\n# Linear near-surface generator\nζ(k) = 1 + (h(k) - 1) / refinement\n\n# Bottom-intensified stretching function\nΣ(k) = (1 - exp(-stretching * h(k))) / (1 - exp(-stretching))\n\n# Generating function\nz_faces(k) = - Lz * (ζ(k) * Σ(k) - 1)\n\ngrid = RectilinearGrid(topology = (Periodic, Flat, Bounded),\n                       size = (Nx, Nz),\n                       x = (0, Lx),\n                       z = z_faces)","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"64×1×64 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo\n├── Periodic x ∈ [0.0, 200.0)  regularly spaced with Δx=3.125\n├── Flat y                     \n└── Bounded  z ∈ [-0.0, 100.0] variably spaced with min(Δz)=0.868817, max(Δz)=6.55496","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Let's make sure the grid spacing is both finer and near-uniform at the bottom,","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"using CairoMakie\n\nlines(zspacings(grid, Center()), znodes(grid, Center()),\n      axis = (ylabel = \"Depth (m)\",\n              xlabel = \"Vertical spacing (m)\"))\n\nscatter!(zspacings(grid, Center()), znodes(grid, Center()))\n","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"(Image: )","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/#Tilting-the-domain","page":"Tilted bottom boundary layer","title":"Tilting the domain","text":"","category":"section"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"We use a domain that's tilted with respect to gravity by","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"θ = 3 # degrees","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"3","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"so that x is the along-slope direction, z is the across-slope direction that is perpendicular to the bottom, and the unit vector anti-aligned with gravity is","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"ĝ = [sind(θ), 0, cosd(θ)]","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"3-element Vector{Float64}:\n 0.052335956242943835\n 0.0\n 0.9986295347545738","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Changing the vertical direction impacts both the gravity_unit_vector for Buoyancy as well as the rotation_axis for Coriolis forces,","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"buoyancy = Buoyancy(model = BuoyancyTracer(), gravity_unit_vector = -ĝ)\ncoriolis = ConstantCartesianCoriolis(f = 1e-4, rotation_axis = ĝ)","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"ConstantCartesianCoriolis{Float64}: fx = 5.23e-06, fy = 0.00e+00, fz = 9.99e-05","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"where above we used a constant Coriolis parameter f = 10^-4  rms^-1. The tilting also affects the kind of density stratified flows we can model. In particular, a constant density stratification in the tilted coordinate system","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"@inline constant_stratification(x, z, t, p) = p.N² * (x * p.ĝ[1] + z * p.ĝ[3])","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"constant_stratification (generic function with 1 method)","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"is not periodic in x. Thus we cannot explicitly model a constant stratification on an x-periodic grid such as the one used here. Instead, we simulate periodic perturbations away from the constant density stratification by imposing a constant stratification as a BackgroundField,","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"N² = 1e-5 # s⁻² # background vertical buoyancy gradient\nB∞_field = BackgroundField(constant_stratification, parameters=(; ĝ, N² = N²))","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"BackgroundField{typeof(Main.var\"##269\".constant_stratification), @NamedTuple{ĝ::Vector{Float64}, N²::Float64}}\n├── func: constant_stratification (generic function with 1 method)\n└── parameters: (ĝ = [0.052335956242943835, 0.0, 0.9986295347545738], N² = 1.0e-5)","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"We choose to impose a bottom boundary condition of zero total diffusive buoyancy flux across the seafloor,","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"_z B = _z b + N^2 costheta = 0","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"This shows that to impose a no-flux boundary condition on the total buoyancy field B, we must apply a boundary condition to the perturbation buoyancy b,","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"_z b = - N^2 costheta","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"∂z_b_bottom = - N² * cosd(θ)\nnegative_background_diffusive_flux = GradientBoundaryCondition(∂z_b_bottom)\nb_bcs = FieldBoundaryConditions(bottom = negative_background_diffusive_flux)","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Oceananigans.FieldBoundaryConditions, with boundary conditions\n├── west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── bottom: GradientBoundaryCondition: -9.9863e-6\n├── top: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n└── immersed: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/#Bottom-drag-and-along-slope-interior-velocity","page":"Tilted bottom boundary layer","title":"Bottom drag and along-slope interior velocity","text":"","category":"section"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"We impose bottom drag that follows Monin–Obukhov theory:","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"V∞ = 0.1 # m s⁻¹\nz₀ = 0.1 # m (roughness length)\nκ = 0.4  # von Karman constant\n\nz₁ = first(znodes(grid, Center())) # Closest grid center to the bottom\ncᴰ = (κ / log(z₁ / z₀))^2 # Drag coefficient\n\n@inline drag_u(x, t, u, v, p) = - p.cᴰ * √(u^2 + (v + p.V∞)^2) * u\n@inline drag_v(x, t, u, v, p) = - p.cᴰ * √(u^2 + (v + p.V∞)^2) * (v + p.V∞)\n\ndrag_bc_u = FluxBoundaryCondition(drag_u, field_dependencies=(:u, :v), parameters=(; cᴰ, V∞))\ndrag_bc_v = FluxBoundaryCondition(drag_v, field_dependencies=(:u, :v), parameters=(; cᴰ, V∞))\n\nu_bcs = FieldBoundaryConditions(bottom = drag_bc_u)\nv_bcs = FieldBoundaryConditions(bottom = drag_bc_v)","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Oceananigans.FieldBoundaryConditions, with boundary conditions\n├── west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── bottom: FluxBoundaryCondition: ContinuousBoundaryFunction drag_v at (Nothing, Nothing, Nothing)\n├── top: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n└── immersed: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Note that, similar to the buoyancy boundary conditions, we had to include the background flow in the drag calculation.","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Let us also create BackgroundField for the along-slope interior velocity:","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"V∞_field = BackgroundField(V∞)","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"BackgroundField{Float64, Nothing}\n├── func: 0.1\n└── parameters: nothing","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/#Create-the-NonhydrostaticModel","page":"Tilted bottom boundary layer","title":"Create the NonhydrostaticModel","text":"","category":"section"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"We are now ready to create the model. We create a NonhydrostaticModel with an UpwindBiasedFifthOrder advection scheme, a RungeKutta3 timestepper, and a constant viscosity and diffusivity. Here we use a smallish value of 10^-4  rmm^2 rms^-1.","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"ν = 1e-4\nκ = 1e-4\nclosure = ScalarDiffusivity(ν=ν, κ=κ)\n\nmodel = NonhydrostaticModel(; grid, buoyancy, coriolis, closure,\n                            timestepper = :RungeKutta3,\n                            advection = UpwindBiasedFifthOrder(),\n                            tracers = :b,\n                            boundary_conditions = (u=u_bcs, v=v_bcs, b=b_bcs),\n                            background_fields = (; b=B∞_field, v=V∞_field))","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\n├── grid: 64×1×64 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo\n├── timestepper: RungeKutta3TimeStepper\n├── advection scheme: FluxFormAdvection{3, Float64, UpwindBiased{3, Float64, Nothing, Nothing, Nothing, UpwindBiased{2, Float64, Nothing, Nothing, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{2, Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}}, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, UpwindBiased{3, Float64, Nothing, Nothing, Nothing, UpwindBiased{2, Float64, Nothing, Nothing, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{2, Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}}}\n├── tracers: b\n├── closure: ScalarDiffusivity{ExplicitTimeDiscretization}(ν=0.0001, κ=(b=0.0001,))\n├── buoyancy: BuoyancyTracer with ĝ = (-0.052336, -0.0, -0.99863)\n└── coriolis: ConstantCartesianCoriolis{Float64}","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Let's introduce a bit of random noise at the bottom of the domain to speed up the onset of turbulence:","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"noise(x, z) = 1e-3 * randn() * exp(-(10z)^2 / grid.Lz^2)\nset!(model, u=noise, w=noise)","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/#Create-and-run-a-simulation","page":"Tilted bottom boundary layer","title":"Create and run a simulation","text":"","category":"section"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"We are now ready to create the simulation. We begin by setting the initial time step conservatively, based on the smallest grid size of our domain and either an advective or diffusive time scaling, depending on which is shorter.","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Δt₀ = 0.5 * minimum([minimum_zspacing(grid) / V∞, minimum_zspacing(grid)^2/κ])\nsimulation = Simulation(model, Δt = Δt₀, stop_time = 1day)","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Simulation of NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\n├── Next time step: 4.344 seconds\n├── Elapsed wall time: 0 seconds\n├── Wall time per iteration: NaN days\n├── Stop time: 1 day\n├── Stop iteration : Inf\n├── Wall time limit: Inf\n├── Callbacks: OrderedDict with 4 entries:\n│   ├── stop_time_exceeded => Callback of stop_time_exceeded on IterationInterval(1)\n│   ├── stop_iteration_exceeded => Callback of stop_iteration_exceeded on IterationInterval(1)\n│   ├── wall_time_limit_exceeded => Callback of wall_time_limit_exceeded on IterationInterval(1)\n│   └── nan_checker => Callback of NaNChecker for u on IterationInterval(100)\n├── Output writers: OrderedDict with no entries\n└── Diagnostics: OrderedDict with no entries","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"We use a TimeStepWizard to adapt our time-step,","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"wizard = TimeStepWizard(max_change=1.1, cfl=0.7)\nsimulation.callbacks[:wizard] = Callback(wizard, IterationInterval(4))","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Callback of TimeStepWizard(cfl=0.7, max_Δt=Inf, min_Δt=0.0) on IterationInterval(4)","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"and also we add another callback to print a progress message,","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"using Printf\n\nstart_time = time_ns() # so we can print the total elapsed wall time\n\nprogress_message(sim) =\n    @printf(\"Iteration: %04d, time: %s, Δt: %s, max|w|: %.1e m s⁻¹, wall time: %s\\n\",\n            iteration(sim), prettytime(time(sim)),\n            prettytime(sim.Δt), maximum(abs, sim.model.velocities.w),\n            prettytime((time_ns() - start_time) * 1e-9))\n\nsimulation.callbacks[:progress] = Callback(progress_message, IterationInterval(200))","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Callback of progress_message on IterationInterval(200)","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/#Add-outputs-to-the-simulation","page":"Tilted bottom boundary layer","title":"Add outputs to the simulation","text":"","category":"section"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"We add outputs to our model using the NetCDFOutputWriter,","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"u, v, w = model.velocities\nb = model.tracers.b\nB∞ = model.background_fields.tracers.b\n\nB = b + B∞\nV = v + V∞\nωy = ∂z(u) - ∂x(w)\n\noutputs = (; u, V, w, B, ωy)\n\nsimulation.output_writers[:fields] = NetCDFOutputWriter(model, outputs;\n                                                        filename = joinpath(@__DIR__, \"tilted_bottom_boundary_layer.nc\"),\n                                                        schedule = TimeInterval(20minutes),\n                                                        overwrite_existing = true)","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"NetCDFOutputWriter scheduled on TimeInterval(20 minutes):\n├── filepath: /var/lib/buildkite-agent/builds/tartarus-15/clima/oceananigans/docs/src/literated/tilted_bottom_boundary_layer.nc\n├── dimensions: zC(64), zF(65), xC(64), yF(1), xF(64), yC(1), time(0)\n├── 5 outputs: (B, w, ωy, V, u)\n└── array type: Array{Float64}\n├── file_splitting: NoFileSplitting\n└── file size: 19.2 KiB","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Now we just run it!","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"run!(simulation)","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"[ Info: Initializing simulation...\nIteration: 0000, time: 0 seconds, Δt: 4.778 seconds, max|w|: 9.5e-04 m s⁻¹, wall time: 15.078 seconds\n[ Info:     ... simulation initialization complete (10.591 seconds)\n[ Info: Executing initial time step...\n[ Info:     ... initial time step complete (5.034 seconds).\nIteration: 0200, time: 3.549 hours, Δt: 1.425 minutes, max|w|: 5.4e-03 m s⁻¹, wall time: 24.101 seconds\nIteration: 0400, time: 8.667 hours, Δt: 1.227 minutes, max|w|: 7.3e-03 m s⁻¹, wall time: 26.012 seconds\nIteration: 0600, time: 13.073 hours, Δt: 1.452 minutes, max|w|: 4.5e-03 m s⁻¹, wall time: 27.925 seconds\nIteration: 0800, time: 16.992 hours, Δt: 1.180 minutes, max|w|: 6.8e-03 m s⁻¹, wall time: 29.963 seconds\nIteration: 1000, time: 20.714 hours, Δt: 1.371 minutes, max|w|: 5.7e-03 m s⁻¹, wall time: 32.061 seconds\n[ Info: Simulation is stopping after running for 27.418 seconds.\n[ Info: Simulation time 1 day equals or exceeds stop time 1 day.\n","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/#Visualize-the-results","page":"Tilted bottom boundary layer","title":"Visualize the results","text":"","category":"section"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"First we load the required package to load NetCDF output files and define the coordinates for plotting using existing objects:","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"using NCDatasets, CairoMakie\n\nxb, yb, zb = nodes(B)\nxω, yω, zω = nodes(ωy)\nxv, yv, zv = nodes(V)","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"([1.5625, 4.6875, 7.8125, 10.9375, 14.0625, 17.1875, 20.3125, 23.4375, 26.5625, 29.6875, 32.8125, 35.9375, 39.0625, 42.1875, 45.3125, 48.4375, 51.5625, 54.6875, 57.8125, 60.9375, 64.0625, 67.1875, 70.3125, 73.4375, 76.5625, 79.6875, 82.8125, 85.9375, 89.0625, 92.1875, 95.3125, 98.4375, 101.5625, 104.6875, 107.8125, 110.9375, 114.0625, 117.1875, 120.3125, 123.4375, 126.5625, 129.6875, 132.8125, 135.9375, 139.0625, 142.1875, 145.3125, 148.4375, 151.5625, 154.6875, 157.8125, 160.9375, 164.0625, 167.1875, 170.3125, 173.4375, 176.5625, 179.6875, 182.8125, 185.9375, 189.0625, 192.1875, 195.3125, 198.4375], nothing, [0.4344083608847693, 1.303282217470314, 2.1722793473188617, 3.041419168936904, 3.9107241431416084, 4.780220246692868, 5.649937519111903, 6.519910693894487, 7.390179927024476, 8.26079163764491, 9.131799477986252, 10.00326545222724, 10.875261206921866, 11.747869519021842, 12.621186011421164, 13.495321130420056, 14.370402424632783, 15.24657717074116, 16.124015398230675, 17.00291337296054, 17.88349760825156, 18.766029482284154, 19.650810552161538, 20.538188668213625, 21.428565007224726, 22.322402160523495, 23.22023343257072, 24.122673528152244, 25.030430831905008, 25.944321513097137, 26.865285721823064, 27.794406180595843, 28.732929518320184, 29.682290742481506, 30.64414130083751, 31.62038124678409, 32.61319609381579, 33.62509902514256, 34.65897921569778, 35.71815712673464, 36.80644774933731, 37.92823290397964, 39.08854385039015, 40.29315562720595, 41.548694726134066, 42.86276191262984, 44.24407223660885, 45.702614534695954, 47.24983301231516, 48.89883381190526, 50.66461982505285, 52.56435739360966, 54.61767896995204, 56.84702627115933, 59.27803896724765, 61.93999449018695, 64.86630513774502, 68.09507927238374, 71.66975407682737, 75.63980801853194, 80.06156188607441, 84.99907797852119, 90.52516773625328, 96.72251877439135])","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Read in the simulation's output_writer for the two-dimensional fields and then create an animation showing the y-component of vorticity.","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"ds = NCDataset(simulation.output_writers[:fields].filepath, \"r\")\n\nfig = Figure(size = (800, 600))\n\naxis_kwargs = (xlabel = \"Across-slope distance (m)\",\n               ylabel = \"Slope-normal\\ndistance (m)\",\n               limits = ((0, Lx), (0, Lz)),\n               )\n\nax_ω = Axis(fig[2, 1]; title = \"Along-slope vorticity\", axis_kwargs...)\nax_v = Axis(fig[3, 1]; title = \"Along-slope velocity (v)\", axis_kwargs...)\n\nn = Observable(1)\n\nωy = @lift ds[\"ωy\"][:, 1, :, $n]\nB = @lift ds[\"B\"][:, 1, :, $n]\nhm_ω = heatmap!(ax_ω, xω, zω, ωy, colorrange = (-0.015, +0.015), colormap = :balance)\nColorbar(fig[2, 2], hm_ω; label = \"s⁻¹\")\nct_b = contour!(ax_ω, xb, zb, B, levels=-1e-3:0.5e-4:1e-3, color=:black)\n\nV = @lift ds[\"V\"][:, 1, :, $n]\nV_max = @lift maximum(abs, ds[\"V\"][:, 1, :, $n])\n\nhm_v = heatmap!(ax_v, xv, zv, V, colorrange = (-V∞, +V∞), colormap = :balance)\nColorbar(fig[3, 2], hm_v; label = \"m s⁻¹\")\nct_b = contour!(ax_v, xb, zb, B, levels=-1e-3:0.5e-4:1e-3, color=:black)\n\ntimes = collect(ds[\"time\"])\ntitle = @lift \"t = \" * string(prettytime(times[$n]))\nfig[1, :] = Label(fig, title, fontsize=20, tellwidth=false)\n\nfig","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"(Image: )","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Finally, we record a movie.","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"frames = 1:length(times)\n\nrecord(fig, \"tilted_bottom_boundary_layer.mp4\", frames, framerate=12) do i\n    n[] = i\nend","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"(Image: )","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Don't forget to close the NetCDF file!","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"close(ds)","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"closed Dataset","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"","category":"page"},{"location":"literated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"EditURL = \"../../../examples/convecting_plankton.jl\"","category":"page"},{"location":"literated/convecting_plankton/#Plankton-mixing-and-blooming","page":"Convecting plankton","title":"Plankton mixing and blooming","text":"","category":"section"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"In this example, we simulate the mixing of phytoplankton by convection that decreases in time and eventually shuts off, thereby precipitating a phytoplankton bloom. A similar scenario was simulated by Taylor and Ferrari (2011), providing evidence that the \"critical turbulence hypothesis\" explains the explosive bloom of oceanic phytoplankton observed in spring.","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"The phytoplankton in our model are advected, diffuse, grow, and die according to","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"_t P + boldsymbolv cdot nabla P - κ ²P = μ₀ exp(z  λ) - m  P  ","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"where boldsymbolv is the turbulent velocity field, κ is an isotropic diffusivity,  μ₀ is the phytoplankton growth rate at the surface, λ is the scale over which sunlight attenuates away from the surface, and m is the mortality rate of phytoplankton due to viruses and grazing by zooplankton. We use Oceananigans' Forcing abstraction to implement the phytoplankton dynamics described by the right side of the phytoplankton equation above.","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"This example demonstrates","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"How to use a user-defined forcing function to simulate the dynamics of phytoplankton growth in sunlight and grazing by zooplankton.\nHow to set time-dependent boundary conditions.\nHow to use the TimeStepWizard to adapt the simulation time-step.\nHow to use Average to diagnose spatial averages of model fields.","category":"page"},{"location":"literated/convecting_plankton/#Install-dependencies","page":"Convecting plankton","title":"Install dependencies","text":"","category":"section"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"using Pkg\npkg\"add Oceananigans, CairoMakie\"","category":"page"},{"location":"literated/convecting_plankton/#The-grid","page":"Convecting plankton","title":"The grid","text":"","category":"section"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"We use a two-dimensional grid with 64² points, 3² halo points for high-order advection, 1 m grid spacing, and a Flat y-direction:","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"using Oceananigans\nusing Oceananigans.Units: minutes, hour, hours, day\n\ngrid = RectilinearGrid(size=(64, 64), extent=(64, 64), halo=(3, 3), topology=(Periodic, Flat, Bounded))","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"64×1×64 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo\n├── Periodic x ∈ [0.0, 64.0)  regularly spaced with Δx=1.0\n├── Flat y                    \n└── Bounded  z ∈ [-64.0, 0.0] regularly spaced with Δz=1.0","category":"page"},{"location":"literated/convecting_plankton/#Boundary-conditions","page":"Convecting plankton","title":"Boundary conditions","text":"","category":"section"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"We impose a surface buoyancy flux that's initially constant and then decays to zero,","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"buoyancy_flux(x, t, params) = params.initial_buoyancy_flux * exp(-t^4 / (24 * params.shut_off_time^4))\n\nbuoyancy_flux_parameters = (initial_buoyancy_flux = 1e-8, # m² s⁻³\n                                    shut_off_time = 2hours)\n\nbuoyancy_flux_bc = FluxBoundaryCondition(buoyancy_flux, parameters = buoyancy_flux_parameters)","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"FluxBoundaryCondition: ContinuousBoundaryFunction buoyancy_flux at (Nothing, Nothing, Nothing)","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"The fourth power in the argument of exp above helps keep the buoyancy flux relatively constant during the first phase of the simulation. We produce a plot of this time-dependent buoyancy flux for the visually-oriented,","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"using CairoMakie\nset_theme!(Theme(fontsize = 24, linewidth=2))\n\ntimes = range(0, 12hours, length=100)\n\nfig = Figure(size = (800, 300))\nax = Axis(fig[1, 1]; xlabel = \"Time (hours)\", ylabel = \"Surface buoyancy flux (m² s⁻³)\")\n\nflux_time_series = [buoyancy_flux(0, t, buoyancy_flux_parameters) for t in times]\nlines!(ax, times ./ hour, flux_time_series)\n\nfig","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"(Image: )","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"The buoyancy flux effectively shuts off after 6 hours of simulation time.","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"info: The flux convention in Oceananigans.jl\nFluxes are defined by the direction a quantity is carried: positive velocities produce positive fluxes, while negative velocities produce negative fluxes. Diffusive fluxes are defined with the same convention. A positive flux at the top boundary transports buoyancy upwards, out of the domain. This means that a positive flux of buoyancy at the top boundary reduces the buoyancy of near-surface fluid, causing convection.","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"The initial condition and bottom boundary condition impose the constant buoyancy gradient","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"N² = 1e-4 # s⁻²\n\nbuoyancy_gradient_bc = GradientBoundaryCondition(N²)","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"GradientBoundaryCondition: 0.0001","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"In summary, the buoyancy boundary conditions impose a destabilizing flux at the top and a stable buoyancy gradient at the bottom:","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"buoyancy_bcs = FieldBoundaryConditions(top = buoyancy_flux_bc, bottom = buoyancy_gradient_bc)","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"Oceananigans.FieldBoundaryConditions, with boundary conditions\n├── west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── bottom: GradientBoundaryCondition: 0.0001\n├── top: FluxBoundaryCondition: ContinuousBoundaryFunction buoyancy_flux at (Nothing, Nothing, Nothing)\n└── immersed: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)","category":"page"},{"location":"literated/convecting_plankton/#Phytoplankton-dynamics:-light-dependent-growth-and-uniform-mortality","page":"Convecting plankton","title":"Phytoplankton dynamics: light-dependent growth and uniform mortality","text":"","category":"section"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"We use a simple model for the growth of phytoplankton in sunlight and decay due to viruses and grazing by zooplankton,","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"growing_and_grazing(x, z, t, P, params) = (params.μ₀ * exp(z / params.λ) - params.m) * P","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"with parameters","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"plankton_dynamics_parameters = (μ₀ = 1/day,   # surface growth rate\n                                 λ = 5,       # sunlight attenuation length scale (m)\n                                 m = 0.1/day) # mortality rate due to virus and zooplankton grazing","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"(μ₀ = 1.1574074074074073e-5, λ = 5, m = 1.1574074074074074e-6)","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"We tell Forcing that our plankton model depends on the plankton concentration P and the chosen parameters,","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"plankton_dynamics = Forcing(growing_and_grazing, field_dependencies = :P,\n                            parameters = plankton_dynamics_parameters)","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"ContinuousForcing{@NamedTuple{μ₀::Float64, λ::Int64, m::Float64}}\n├── func: growing_and_grazing (generic function with 1 method)\n├── parameters: (μ₀ = 1.1574074074074073e-5, λ = 5, m = 1.1574074074074074e-6)\n└── field dependencies: (:P,)","category":"page"},{"location":"literated/convecting_plankton/#The-model","page":"Convecting plankton","title":"The model","text":"","category":"section"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"The name \"P\" for phytoplankton is specified in the constructor for NonhydrostaticModel. We additionally specify a fifth-order advection scheme, third-order Runge-Kutta time-stepping, isotropic viscosity and diffusivities, and Coriolis forces appropriate for planktonic convection at mid-latitudes on Earth.","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"model = NonhydrostaticModel(; grid,\n                            advection = UpwindBiasedFifthOrder(),\n                            timestepper = :RungeKutta3,\n                            closure = ScalarDiffusivity(ν=1e-4, κ=1e-4),\n                            coriolis = FPlane(f=1e-4),\n                            tracers = (:b, :P), # P for Plankton\n                            buoyancy = BuoyancyTracer(),\n                            forcing = (; P=plankton_dynamics),\n                            boundary_conditions = (; b=buoyancy_bcs))","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\n├── grid: 64×1×64 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo\n├── timestepper: RungeKutta3TimeStepper\n├── advection scheme: FluxFormAdvection{3, Float64, UpwindBiased{3, Float64, Nothing, Nothing, Nothing, UpwindBiased{2, Float64, Nothing, Nothing, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{2, Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}}, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, UpwindBiased{3, Float64, Nothing, Nothing, Nothing, UpwindBiased{2, Float64, Nothing, Nothing, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{2, Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}}}\n├── tracers: (b, P)\n├── closure: ScalarDiffusivity{ExplicitTimeDiscretization}(ν=0.0001, κ=(b=0.0001, P=0.0001))\n├── buoyancy: BuoyancyTracer with ĝ = NegativeZDirection()\n└── coriolis: FPlane{Float64}(f=0.0001)","category":"page"},{"location":"literated/convecting_plankton/#Initial-condition","page":"Convecting plankton","title":"Initial condition","text":"","category":"section"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"We set the initial phytoplankton at P = 1  rmμM. For buoyancy, we use a stratification that's mixed near the surface and linearly stratified below, superposed with surface-concentrated random noise.","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"mixed_layer_depth = 32 # m\n\nstratification(z) = z < -mixed_layer_depth ? N² * z : - N² * mixed_layer_depth\nnoise(z) = 1e-4 * N² * grid.Lz * randn() * exp(z / 4)\ninitial_buoyancy(x, z) = stratification(z) + noise(z)\n\nset!(model, b=initial_buoyancy, P=1)","category":"page"},{"location":"literated/convecting_plankton/#Simulation-with-adaptive-time-stepping,-logging,-and-output","page":"Convecting plankton","title":"Simulation with adaptive time-stepping, logging, and output","text":"","category":"section"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"We build a simulation","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"simulation = Simulation(model, Δt=2minutes, stop_time=24hours)","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"Simulation of NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\n├── Next time step: 2 minutes\n├── Elapsed wall time: 0 seconds\n├── Wall time per iteration: NaN days\n├── Stop time: 1 day\n├── Stop iteration : Inf\n├── Wall time limit: Inf\n├── Callbacks: OrderedDict with 4 entries:\n│   ├── stop_time_exceeded => Callback of stop_time_exceeded on IterationInterval(1)\n│   ├── stop_iteration_exceeded => Callback of stop_iteration_exceeded on IterationInterval(1)\n│   ├── wall_time_limit_exceeded => Callback of wall_time_limit_exceeded on IterationInterval(1)\n│   └── nan_checker => Callback of NaNChecker for u on IterationInterval(100)\n├── Output writers: OrderedDict with no entries\n└── Diagnostics: OrderedDict with no entries","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"with a TimeStepWizard that limits the time-step to 2 minutes, and adapts the time-step such that CFL (Courant-Freidrichs-Lewy) number hovers around 1.0,","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"conjure_time_step_wizard!(simulation, cfl=1.0, max_Δt=2minutes)","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"We also add a callback that prints the progress of the simulation,","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"using Printf\n\nprogress(sim) = @printf(\"Iteration: %d, time: %s, Δt: %s\\n\",\n                        iteration(sim), prettytime(sim), prettytime(sim.Δt))\n\nadd_callback!(simulation, progress, IterationInterval(100))","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"and a basic JLD2OutputWriter that writes velocities and both the two-dimensional and horizontally-averaged plankton concentration,","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"outputs = (w = model.velocities.w,\n           P = model.tracers.P,\n           avg_P = Average(model.tracers.P, dims=(1, 2)))\n\nsimulation.output_writers[:simple_output] =\n    JLD2OutputWriter(model, outputs,\n                     schedule = TimeInterval(20minutes),\n                     filename = \"convecting_plankton.jld2\",\n                     overwrite_existing = true)","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"JLD2OutputWriter scheduled on TimeInterval(20 minutes):\n├── filepath: ./convecting_plankton.jld2\n├── 3 outputs: (w, P, avg_P)\n├── array type: Array{Float64}\n├── including: [:grid, :coriolis, :buoyancy, :closure]\n├── file_splitting: NoFileSplitting\n└── file size: 32.7 KiB","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"info: Using multiple output writers\nBecause each output writer is associated with a single output schedule, it often makes sense to use different output writers for different types of output. For example, smaller outputs that consume less disk space may be written more frequently without threatening the capacity of your hard drive. An arbitrary number of output writers may be added to simulation.output_writers.","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"The simulation is set up. Let there be plankton:","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"run!(simulation)","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"[ Info: Initializing simulation...\nIteration: 0, time: 0 seconds, Δt: 2 minutes\n[ Info:     ... simulation initialization complete (11.204 seconds)\n[ Info: Executing initial time step...\n[ Info:     ... initial time step complete (3.712 seconds).\nIteration: 100, time: 2.447 hours, Δt: 43.972 seconds\nIteration: 200, time: 3.620 hours, Δt: 49.575 seconds\nIteration: 300, time: 4.725 hours, Δt: 46.307 seconds\nIteration: 400, time: 5.923 hours, Δt: 46.390 seconds\nIteration: 500, time: 7.261 hours, Δt: 52.583 seconds\nIteration: 600, time: 8.596 hours, Δt: 52.082 seconds\nIteration: 700, time: 9.994 hours, Δt: 53.251 seconds\nIteration: 800, time: 11.449 hours, Δt: 1.037 minutes\nIteration: 900, time: 13.152 hours, Δt: 1.163 minutes\nIteration: 1000, time: 15.034 hours, Δt: 1.117 minutes\nIteration: 1100, time: 17 hours, Δt: 1.388 minutes\nIteration: 1200, time: 19.454 hours, Δt: 1.848 minutes\nIteration: 1300, time: 22.667 hours, Δt: 2 minutes\n[ Info: Simulation is stopping after running for 44.215 seconds.\n[ Info: Simulation time 1 day equals or exceeds stop time 1 day.\n","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"Notice how the time-step is reduced at early times, when turbulence is strong, and increases again towards the end of the simulation when turbulence fades.","category":"page"},{"location":"literated/convecting_plankton/#Visualizing-the-solution","page":"Convecting plankton","title":"Visualizing the solution","text":"","category":"section"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"We'd like to a make a plankton movie. First we load the output file and build a time-series of the buoyancy flux,","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"filepath = simulation.output_writers[:simple_output].filepath\n\nw_timeseries = FieldTimeSeries(filepath, \"w\")\nP_timeseries = FieldTimeSeries(filepath, \"P\")\navg_P_timeseries = FieldTimeSeries(filepath, \"avg_P\")\n\ntimes = w_timeseries.times\nbuoyancy_flux_time_series = [buoyancy_flux(0, t, buoyancy_flux_parameters) for t in times]\nnothing # hide","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"Now, we animate plankton mixing and blooming,","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"using CairoMakie\n\n@info \"Making a movie about plankton...\"\n\nn = Observable(1)\n\ntitle = @lift @sprintf(\"t = %s\", prettytime(times[$n]))\n\nwn = @lift w_timeseries[$n]\nPn = @lift P_timeseries[$n]\navg_Pn = @lift avg_P_timeseries[$n]\n\nw_lim = maximum(abs, interior(w_timeseries))\nw_lims = (-w_lim, w_lim)\n\nP_lims = (0.95, 1.1)\n\nfig = Figure(size = (1200, 1000))\n\nax_w = Axis(fig[2, 2]; xlabel = \"x (m)\", ylabel = \"z (m)\", aspect = 1)\nax_P = Axis(fig[3, 2]; xlabel = \"x (m)\", ylabel = \"z (m)\", aspect = 1)\nax_b = Axis(fig[2, 3]; xlabel = \"Time (hours)\", ylabel = \"Buoyancy flux (m² s⁻³)\", yaxisposition = :right)\n\nax_avg_P = Axis(fig[3, 3]; xlabel = \"Plankton concentration (μM)\", ylabel = \"z (m)\", yaxisposition = :right)\nxlims!(ax_avg_P, 0.85, 1.3)\n\nfig[1, 1:3] = Label(fig, title, tellwidth=false)\n\nhm_w = heatmap!(ax_w, wn; colormap = :balance, colorrange = w_lims)\nColorbar(fig[2, 1], hm_w; label = \"Vertical velocity (m s⁻¹)\", flipaxis = false)\n\nhm_P = heatmap!(ax_P, Pn; colormap = :matter, colorrange = P_lims)\nColorbar(fig[3, 1], hm_P; label = \"Plankton 'concentration'\", flipaxis = false)\n\nlines!(ax_b, times ./ hour, buoyancy_flux_time_series; linewidth = 1, color = :black, alpha = 0.4)\n\nb_flux_point = @lift Point2(times[$n] / hour, buoyancy_flux_time_series[$n])\nscatter!(ax_b, b_flux_point; marker = :circle, markersize = 16, color = :black)\nlines!(ax_avg_P, avg_Pn)\n\nfig","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"(Image: )","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"And, finally, we record a movie.","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"frames = 1:length(times)\n\n@info \"Making an animation of convecting plankton...\"\n\nrecord(fig, \"convecting_plankton.mp4\", frames, framerate=8) do i\n    n[] = i\nend","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"[ Info: Making an animation of convecting plankton...\n","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"(Image: )","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"","category":"page"},{"location":"literated/convecting_plankton/","page":"Convecting plankton","title":"Convecting plankton","text":"This page was generated using Literate.jl.","category":"page"},{"location":"model_setup/lagrangian_particles/#Lagrangian-particle-tracking","page":"Lagrangian particles","title":"Lagrangian particle tracking","text":"","category":"section"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"Models can keep track of the location and properties of neutrally buoyant particles. Particles are advected with the flow field using forward Euler time-stepping at every model iteration.","category":"page"},{"location":"model_setup/lagrangian_particles/#Simple-particles","page":"Lagrangian particles","title":"Simple particles","text":"","category":"section"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"If you just need to keep of particle locations (x y z) then you can construct some Lagrangian particles using the regular LagrangianParticles constructor","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"DocTestSetup = quote\n    using Oceananigans\nend","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"grid = RectilinearGrid(size=(10, 10, 10), extent=(1, 1, 1));\n\nn_particles = 10;\n\nx₀ = zeros(n_particles);\n\ny₀ = rand(n_particles);\n\nz₀ = -0.5 * ones(n_particles);\n\nlagrangian_particles = LagrangianParticles(x=x₀, y=y₀, z=z₀)\n\n# output\n10 LagrangianParticles with eltype Particle:\n├── 3 properties: (:x, :y, :z)\n├── particle-wall restitution coefficient: 1.0\n├── 0 tracked fields: ()\n└── dynamics: no_dynamics","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"then pass it to a model constructor","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"model = NonhydrostaticModel(grid=grid, particles=lagrangian_particles)\n\n# output\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\n├── grid: 10×10×10 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo\n├── timestepper: RungeKutta3TimeStepper\n├── advection scheme: Centered reconstruction order 2\n├── tracers: ()\n├── closure: Nothing\n├── buoyancy: Nothing\n├── coriolis: Nothing\n└── particles: 10 LagrangianParticles with eltype Particle and properties (:x, :y, :z)","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"warn: Lagrangian particles on GPUs\nRemember to use CuArray instead of regular Array when storing particle locations and properties on the GPU.","category":"page"},{"location":"model_setup/lagrangian_particles/#Custom-particles","page":"Lagrangian particles","title":"Custom particles","text":"","category":"section"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"If you want to keep track of custom properties, such as the species or DNA of a Lagrangian particle representing a microbe in an agent-based model, then you can create your own custom particle type and pass a StructArray to the LagrangianParticles constructor.","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"using Oceananigans\nusing StructArrays\n\nstruct LagrangianMicrobe{T, S, D}\n    x :: T\n    y :: T\n    z :: T\n    species :: S\n    dna :: D\nend\n\nn_particles = 3;\n\nx₀ = zeros(n_particles);\n\ny₀ = rand(n_particles);\n\nz₀ = -0.5 * ones(n_particles);\n\nspecies = [:rock, :paper, :scissors]\n\ndna = [\"TATACCCC\", \"CCTAGGAC\", \"CGATTTAA\"]\n\nparticles = StructArray{LagrangianMicrobe}((x₀, y₀, z₀, species, dna));\n\nlagrangian_particles = LagrangianParticles(particles)\n\n# output\n3 LagrangianParticles with eltype LagrangianMicrobe:\n├── 5 properties: (:x, :y, :z, :species, :dna)\n├── particle-wall restitution coefficient: 1.0\n├── 0 tracked fields: ()\n└── dynamics: no_dynamics","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"warn: Custom properties on GPUs\nNot all data types can be passed to GPU kernels. If you intend to advect particles on the GPU make sure particle properties consist of only simple data types. The symbols and strings in this example won't work on the GPU.","category":"page"},{"location":"model_setup/lagrangian_particles/#Writing-particle-properties-to-disk","page":"Lagrangian particles","title":"Writing particle properties to disk","text":"","category":"section"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"Particle properties can be written to disk using JLD2 or NetCDF.","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"When writing to JLD2 you can pass model.particles as part of the named tuple of outputs.","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"DocTestFilters = r\"└── file size: [0-9]*.[0-9]* KiB\"","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"JLD2OutputWriter(model, (particles=model.particles,), filename=\"particles\", schedule=TimeInterval(15))\n\n# output\nJLD2OutputWriter scheduled on TimeInterval(15 seconds):\n├── filepath: ./particles.jld2\n├── 1 outputs: particles\n├── array type: Array{Float64}\n├── including: [:grid, :coriolis, :buoyancy, :closure]\n├── file_splitting: NoFileSplitting\n└── file size: 17.6 KiB","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"When writing to NetCDF you should write particles to a separate file as the NetCDF dimensions differ for particle trajectories. You can just pass model.particles straight to NetCDFOutputWriter:","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"NetCDFOutputWriter(model, model.particles, filename=\"particles.nc\", schedule=TimeInterval(15))\n\n# output\nNetCDFOutputWriter scheduled on TimeInterval(15 seconds):\n├── filepath: ./particles.nc\n├── dimensions: particle_id(10), time(0)\n├── 1 outputs: particles\n└── array type: Array{Float64}\n├── file_splitting: NoFileSplitting\n└── file size: 9.9 KiB","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"warn: Outputting custom particle properties to NetCDF\nNetCDF does not support arbitrary data types. If you need to write custom particle properties to disk that are not supported by NetCDF then you should use JLD2 (which should support almost any Julia data type).","category":"page"},{"location":"model_setup/lagrangian_particles/","page":"Lagrangian particles","title":"Lagrangian particles","text":"DocTestFilters = nothing","category":"page"},{"location":"model_setup/diagnostics/#Diagnostics","page":"Diagnostics","title":"Diagnostics","text":"","category":"section"},{"location":"model_setup/diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"Diagnostics are a set of general utilities that can be called on-demand during time-stepping to compute quantities of interest you may want to save to disk, such as the horizontal average of the temperature, the maximum velocity, or to produce a time series of salinity. They also include utilities for diagnosing model health, such as the CFL number or to check for NaNs.","category":"page"},{"location":"model_setup/diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"Diagnostics are stored as a list of diagnostics in simulation.diagnostics. Diagnostics can be specified at model creation time or be specified at any later time and appended (or assigned with a key value pair) to simulation.diagnostics.","category":"page"},{"location":"model_setup/diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"Most diagnostics can be run at specified frequencies (e.g. every 25 time steps) or specified intervals (e.g. every 15 minutes of simulation time). If you'd like to run a diagnostic on demand then do not specify any intervals (and do not add it to simulation.diagnostics).","category":"page"},{"location":"model_setup/legacy_grids/#Grids","page":"Grid","title":"Grids","text":"","category":"section"},{"location":"model_setup/legacy_grids/","page":"Grid","title":"Grid","text":"The grids currently supported are:","category":"page"},{"location":"model_setup/legacy_grids/","page":"Grid","title":"Grid","text":"RectilinearGrids with either constant or variable grid spacings and\nLatitudeLongitudeGrid on the sphere.","category":"page"},{"location":"model_setup/legacy_grids/#RectilinearGrid","page":"Grid","title":"RectilinearGrid","text":"","category":"section"},{"location":"model_setup/legacy_grids/","page":"Grid","title":"Grid","text":"A RectilinearGrid is constructed by specifying the size of the grid (a Tuple specifying the number of grid points in each direction) and either the extent (a Tuple specifying the physical extent of the grid in each direction), or by prescribing x, y, and z. Keyword arguments x, y, and z could be either (i) 2-Tuples that define the the end points in each direction, or (ii) arrays or functions of the corresponding indices i, j, or k that specify the locations of cell faces in the x-, y-, or z-direction, respectively.","category":"page"},{"location":"model_setup/legacy_grids/","page":"Grid","title":"Grid","text":"A regular rectilinear grid with N_x times N_y times N_z = 32 times 64 times 256 grid points and an extent of L_x = 128 meters, L_y = 256 meters, and L_z = 512 meters is constructed by","category":"page"},{"location":"model_setup/legacy_grids/","page":"Grid","title":"Grid","text":"DocTestSetup = quote\n    using Oceananigans\nend","category":"page"},{"location":"model_setup/legacy_grids/","page":"Grid","title":"Grid","text":"julia> grid = RectilinearGrid(size = (32, 64, 256), extent = (128, 256, 512))\n32×64×256 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo\n├── Periodic x ∈ [0.0, 128.0)  regularly spaced with Δx=4.0\n├── Periodic y ∈ [0.0, 256.0)  regularly spaced with Δy=4.0\n└── Bounded  z ∈ [-512.0, 0.0] regularly spaced with Δz=2.0","category":"page"},{"location":"model_setup/legacy_grids/","page":"Grid","title":"Grid","text":"info: Default domain\nWhen using the extent keyword, e.g., extent = (Lx, Ly, Lz), then the x in 0 L_x, y in 0 L_y, and z in -L_z 0 – a sensible choice for oceanographic applications.","category":"page"},{"location":"model_setup/legacy_grids/#Specifying-the-grid's-architecture","page":"Grid","title":"Specifying the grid's architecture","text":"","category":"section"},{"location":"model_setup/legacy_grids/","page":"Grid","title":"Grid","text":"The first positional argument in either RectilinearGrid or LatitudeLongitudeGrid is the grid's architecture. By default architecture = CPU(). By providing GPU() as the architecture argument we can construct the grid on GPU:","category":"page"},{"location":"model_setup/legacy_grids/","page":"Grid","title":"Grid","text":"julia> grid = RectilinearGrid(GPU(), size = (32, 64, 256), extent = (128, 256, 512))\n32×64×256 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo\n├── Periodic x ∈ [0.0, 128.0)  regularly spaced with Δx=4.0\n├── Periodic y ∈ [0.0, 256.0)  regularly spaced with Δy=4.0\n└── Bounded  z ∈ [-512.0, 0.0] regularly spaced with Δz=2.0","category":"page"},{"location":"model_setup/legacy_grids/#Specifying-the-grid's-topology","page":"Grid","title":"Specifying the grid's topology","text":"","category":"section"},{"location":"model_setup/legacy_grids/","page":"Grid","title":"Grid","text":"Another crucial keyword is a 3-Tuple that specifies the grid's topology. In each direction the grid may be Periodic, Bounded or Flat. By default, both the RectilinearGrid and the RectilinearGrid constructors  assume the grid topology is horizontally-periodic and bounded in the vertical, such that topology = (Periodic, Periodic, Bounded).","category":"page"},{"location":"model_setup/legacy_grids/","page":"Grid","title":"Grid","text":"A \"channel\" model that is periodic in the x-direction and wall-bounded in the y- and z-dimensions is build with,","category":"page"},{"location":"model_setup/legacy_grids/","page":"Grid","title":"Grid","text":"julia> grid = RectilinearGrid(topology = (Periodic, Bounded, Bounded), size = (64, 64, 32), extent = (1e4, 1e4, 1e3))\n64×64×32 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3×3×3 halo\n├── Periodic x ∈ [0.0, 10000.0) regularly spaced with Δx=156.25\n├── Bounded  y ∈ [0.0, 10000.0] regularly spaced with Δy=156.25\n└── Bounded  z ∈ [-1000.0, 0.0] regularly spaced with Δz=31.25","category":"page"},{"location":"model_setup/legacy_grids/","page":"Grid","title":"Grid","text":"The Flat topology comes in handy when running problems with fewer than 3 dimensions. As an example, to use a two-dimensional horizontal, doubly periodic domain the topology is (Periodic, Periodic, Flat). In that case, the size and extent are 2-tuples, e.g.,","category":"page"},{"location":"model_setup/legacy_grids/","page":"Grid","title":"Grid","text":"julia> grid = RectilinearGrid(topology = (Periodic, Periodic, Flat), size = (32, 32), extent = (10, 20))\n32×32×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo\n├── Periodic x ∈ [0.0, 10.0) regularly spaced with Δx=0.3125\n├── Periodic y ∈ [0.0, 20.0) regularly spaced with Δy=0.625\n└── Flat z","category":"page"},{"location":"model_setup/legacy_grids/#Specifying-domain-end-points","page":"Grid","title":"Specifying domain end points","text":"","category":"section"},{"location":"model_setup/legacy_grids/","page":"Grid","title":"Grid","text":"To specify a domain with a different origin than the default, the x, y, and z keyword arguments must be used. For example, a grid with x in -100 100 meters, y in 0 125 meters, and z in -pi pi meters is constructed via","category":"page"},{"location":"model_setup/legacy_grids/","page":"Grid","title":"Grid","text":"julia> grid = RectilinearGrid(size = (32, 16, 256), x = (-100, 100), y = (0, 12.5), z = (-π, π))\n32×16×256 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo\n├── Periodic x ∈ [-100.0, 100.0)     regularly spaced with Δx=6.25\n├── Periodic y ∈ [0.0, 12.5)         regularly spaced with Δy=0.78125\n└── Bounded  z ∈ [-3.14159, 3.14159] regularly spaced with Δz=0.0245437","category":"page"},{"location":"model_setup/legacy_grids/#Grids-with-non-regular-spacing-in-some-of-the-directions","page":"Grid","title":"Grids with non-regular spacing in some of the directions","text":"","category":"section"},{"location":"model_setup/legacy_grids/","page":"Grid","title":"Grid","text":"For a \"channel\" model, as the one we constructed above, one would probably like to have finer resolution near the channel walls. We construct a grid that has non-regular spacing in the bounded dimensions, here y and z by prescribing functions for y and z keyword arguments.","category":"page"},{"location":"model_setup/legacy_grids/","page":"Grid","title":"Grid","text":"For example, we can use the Chebychev nodes, which are more closely stacked near boundaries, to prescribe the y- and z-faces.","category":"page"},{"location":"model_setup/legacy_grids/","page":"Grid","title":"Grid","text":"julia> Nx, Ny, Nz = 64, 64, 32;\n\njulia> Lx, Ly, Lz = 1e4, 1e4, 1e3;\n\njulia> chebychev_spaced_y_faces(j) = - Ly/2 * cos(π * (j - 1) / Ny);\n\njulia> chebychev_spaced_z_faces(k) = - Lz/2 - Lz/2 * cos(π * (k - 1) / Nz);\n\njulia> grid = RectilinearGrid(size = (Nx, Ny, Nz),\n                              topology = (Periodic, Bounded, Bounded),\n                              x = (0, Lx),\n                              y = chebychev_spaced_y_faces,\n                              z = chebychev_spaced_z_faces)\n64×64×32 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3×3×3 halo\n├── Periodic x ∈ [0.0, 10000.0)    regularly spaced with Δx=156.25\n├── Bounded  y ∈ [-5000.0, 5000.0] variably spaced with min(Δy)=6.02272, max(Δy)=245.338\n└── Bounded  z ∈ [-1000.0, 0.0]    variably spaced with min(Δz)=2.40764, max(Δz)=49.0086","category":"page"},{"location":"model_setup/legacy_grids/","page":"Grid","title":"Grid","text":"using Oceananigans\nusing CairoMakie\nCairoMakie.activate!(type = \"svg\")\nNx, Ny, Nz = 64, 64, 32\nLx, Ly, Lz = 1e4, 1e4, 1e3\nchebychev_spaced_y_faces(j) = - Ly/2 * cos(π * (j - 1) / Ny);\nchebychev_spaced_z_faces(k) = - Lz/2 - Lz/2 * cos(π * (k - 1) / Nz);\ngrid = RectilinearGrid(size = (Nx, Ny, Nz),\n                              topology = (Periodic, Bounded, Bounded),\n                              x = (0, Lx),\n                              y = chebychev_spaced_y_faces,\n                              z = chebychev_spaced_z_faces)","category":"page"},{"location":"model_setup/legacy_grids/","page":"Grid","title":"Grid","text":"We can easily visualize the spacings of y and z directions. We can use, e.g., ynodes and yspacings to extract the positions and spacings of the nodes from the grid.","category":"page"},{"location":"model_setup/legacy_grids/","page":"Grid","title":"Grid","text":" yᶜ = ynodes(grid, Center())\nΔyᶜ = yspacings(grid, Center())\n\n zᶜ = znodes(grid, Center())\nΔzᶜ = zspacings(grid, Center())\n\nusing CairoMakie\n\nfig = Figure(size=(800, 900))\n\nax1 = Axis(fig[1, 1]; xlabel = \"y (m)\", ylabel = \"y-spacing (m)\", limits = (nothing, (0, 250)))\nlines!(ax1, yᶜ, Δyᶜ)\nscatter!(ax1, yᶜ, Δyᶜ)\n\nax2 = Axis(fig[2, 1]; xlabel = \"z-spacing (m)\", ylabel = \"z (m)\", limits = ((0, 50), nothing))\nlines!(ax2, zᶜ, Δzᶜ)\nscatter!(ax2, zᶜ, Δzᶜ)\n\nsave(\"plot_stretched_grid.svg\", fig); nothing #hide","category":"page"},{"location":"model_setup/legacy_grids/","page":"Grid","title":"Grid","text":"(Image: )","category":"page"},{"location":"model_setup/legacy_grids/#LatitudeLongitudeGrid","page":"Grid","title":"LatitudeLongitudeGrid","text":"","category":"section"},{"location":"model_setup/legacy_grids/","page":"Grid","title":"Grid","text":"A simple latitude-longitude grid with Float64 type can be constructed by","category":"page"},{"location":"model_setup/legacy_grids/","page":"Grid","title":"Grid","text":"julia> grid = LatitudeLongitudeGrid(size = (36, 34, 25),\n                                    longitude = (-180, 180),\n                                    latitude = (-85, 85),\n                                    z = (-1000, 0))\n36×34×25 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics\n├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=10.0\n├── latitude:  Bounded  φ ∈ [-85.0, 85.0]   regularly spaced with Δφ=5.0\n└── z:         Bounded  z ∈ [-1000.0, 0.0]  regularly spaced with Δz=40.0","category":"page"},{"location":"model_setup/legacy_grids/","page":"Grid","title":"Grid","text":"For more examples see RectilinearGrid and LatitudeLongitudeGrid.","category":"page"},{"location":"model_setup/number_type/#Number-type","page":"Number type","title":"Number type","text":"","category":"section"},{"location":"model_setup/number_type/","page":"Number type","title":"Number type","text":"Passing Float64 or Float32 to the grid constructor causes the grid to store all numbers with 64-bit or 32-bit floating point precision.","category":"page"},{"location":"model_setup/number_type/","page":"Number type","title":"Number type","text":"note: Avoiding mixed-precision operations\nWhen not using Float64 be careful to not mix different precisions as it could introduce implicit type conversions which can negatively effect performance. You can pass the number type desires to many constructors to enforce the type you want: e.g. RectilinearGrid(CPU(), Float32; size=(16, 16, 16), extent=(1, 1, 1)) and ScalarDiffusivity(Float16; κ=1//7, ν=2//7).","category":"page"},{"location":"model_setup/number_type/","page":"Number type","title":"Number type","text":"warning: Effect of floating point precision on simulation accuracy\nWhile we run many tests with both Float32 and Float64 it is not clear whether Float32 is precise enough to provide similar accuracy in all use cases. If accuracy is a concern, stick to Float64.We will be actively investigating the possibility of using lower precision floating point numbers such as Float32 and Float16 for fluid dynamics as well as the use of alternative number types such as Posits and Sonums.","category":"page"},{"location":"quick_start/#Quick-start","page":"Quick start","title":"Quick start","text":"","category":"section"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"This code:","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"using CairoMakie\nCairoMakie.activate!(type = \"png\")","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"using Oceananigans\n\ngrid = RectilinearGrid(size = (128, 128),\n                       x = (0, 2π),\n                       y = (0, 2π),\n                       topology = (Periodic, Periodic, Flat))\n\nmodel = NonhydrostaticModel(; grid, advection=WENO())\n\nϵ(x, y) = 2rand() - 1\nset!(model, u=ϵ, v=ϵ)\n\nsimulation = Simulation(model; Δt=0.01, stop_iteration=100)\nrun!(simulation)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"runs 100 time steps of a two-dimensional turbulence simulation with 128² finite volume cells and a fifth-order upwinded WENO advection scheme. It's quite similar to the two-dimensional turbulence example.","category":"page"},{"location":"quick_start/#Visualization","page":"Quick start","title":"Visualization","text":"","category":"section"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"They say that a Makie visualization is worth a thousand Unicode characters, so let's plot vorticity,","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"using CairoMakie\n\nu, v, w = model.velocities\nζ = Field(∂x(v) - ∂y(u))\ncompute!(ζ)\n\nheatmap(ζ, axis=(; aspect=1))","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"A few more time-steps, and it's starting to get a little diffuse!","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"simulation.stop_iteration += 400\nrun!(simulation)\n\ncompute!(ζ)\nheatmap(ζ, axis=(; aspect=1))","category":"page"},{"location":"quick_start/#They-always-cheat-with-too-simple-\"quick\"-starts","page":"Quick start","title":"They always cheat with too-simple \"quick\" starts","text":"","category":"section"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"Fine, we'll re-run this code on the GPU. But we're a little greedy, so we'll also crank up the resolution, throw in a TimeStepWizard to update simulation.Δt adaptively, and add a passive tracer initially concentrated in the center of the domain which will make for an even prettier figure of the final state:","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"using CairoMakie\nCairoMakie.activate!(type = \"png\")","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"using Oceananigans\nusing CairoMakie\n\ngrid = RectilinearGrid(GPU(),\n                       size = (1024, 1024),\n                       x = (-π, π),\n                       y = (-π, π),\n                       topology = (Periodic, Periodic, Flat))\n\nmodel = NonhydrostaticModel(; grid, advection=WENO(), tracers=:c)\n\nδ = 0.5\ncᵢ(x, y) = exp(-(x^2 + y^2) / 2δ^2)\nϵ(x, y) = 2rand() - 1\nset!(model, u=ϵ, v=ϵ, c=cᵢ)\n\nsimulation = Simulation(model; Δt=1e-3, stop_time=10)\nconjure_time_step_wizard!(simulation, cfl=0.2, IterationInterval(10))\nrun!(simulation)\n\nu, v, w = model.velocities\nζ = Field(∂x(v) - ∂y(u))\ncompute!(ζ)\n\nfig = Figure(size=(1200, 600))\naxζ = Axis(fig[1, 1], aspect=1, title=\"vorticity\")\naxc = Axis(fig[1, 2], aspect=1, title=\"tracer\")\nheatmap!(axζ, ζ, colormap=:balance)\nheatmap!(axc, model.tracers.c)\ncurrent_figure()","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"See how we did that? We passed the positional argument GPU() to RectilinearGrid. (This only works if a GPU is available, of course, and CUDA.jl is configured.)","category":"page"},{"location":"quick_start/#Well,-that-was-tantalizing","page":"Quick start","title":"Well, that was tantalizing","text":"","category":"section"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"But you'll need to know a lot more to become a productive, Oceananigans-wielding computational scientist (spherical grids, forcing, boundary conditions, turbulence closures, output writing, actually labeling your axes... 🤯). It'd be best to move on to the one-dimensional diffusion example.","category":"page"},{"location":"physics/nonhydrostatic_model/#Nonhydrostatic-model","page":"Nonhydrostatic model","title":"Nonhydrostatic model","text":"","category":"section"},{"location":"physics/nonhydrostatic_model/","page":"Nonhydrostatic model","title":"Nonhydrostatic model","text":"The NonhydrostaticModel solves the incompressible Navier-Stokes equations under the Boussinesq approximation and an arbitrary number of tracer conservation equations. Physics associated with individual terms in the momentum and tracer conservation equations – the background rotation rate of the equation's reference frame, gravitational effects associated with buoyant tracers under the Boussinesq approximation, generalized stresses and tracer fluxes associated with viscous and diffusive physics, and arbitrary \"forcing functions\" – are determined by the whims of the user.","category":"page"},{"location":"physics/nonhydrostatic_model/#The-momentum-conservation-equation","page":"Nonhydrostatic model","title":"The momentum conservation equation","text":"","category":"section"},{"location":"physics/nonhydrostatic_model/","page":"Nonhydrostatic model","title":"Nonhydrostatic model","text":"The equations governing the conservation of momentum in a rotating fluid, including buoyancy via the Boussinesq approximation and including the averaged effects of surface gravity waves at the top of the domain via the Craik-Leibovich approximation are","category":"page"},{"location":"physics/nonhydrostatic_model/","page":"Nonhydrostatic model","title":"Nonhydrostatic model","text":"    beginalign\n    partial_t boldsymbolv  = - left ( boldsymbolv boldsymbolcdot boldsymbolnabla right ) boldsymbolv\n                        - left ( boldsymbolV boldsymbolcdot boldsymbolnabla right ) boldsymbolv\n                        - left ( boldsymbolv boldsymbolcdot boldsymbolnabla right ) boldsymbolV nonumber \n                         qquad\n                        - left ( boldsymbolf - boldsymbolnabla times boldsymbolu^S right ) times boldsymbolv \n                        - boldsymbolnabla p\n                        + b boldsymbolhat g\n                        - boldsymbolnabla boldsymbolcdot boldsymboltau\n                        + partial_t boldsymbolu^S\n                        + boldsymbolF_v  \n    labeleqmomentum\n    endalign","category":"page"},{"location":"physics/nonhydrostatic_model/","page":"Nonhydrostatic model","title":"Nonhydrostatic model","text":"where b boldsymbolhat g the is the buoyancy (a vector whose default direction is upward),  boldsymboltau is the kinematic stress tensor, boldsymbolF_v denotes an internal forcing of the velocity field boldsymbolv, p is the kinematic  pressure, boldsymbolu^S is the horizontal, two-dimensional 'Stokes drift' velocity field associated with surface gravity  waves, and boldsymbolf is the Coriolis parameter, or the background vorticity associated  with the specified rate of rotation of the frame of reference.","category":"page"},{"location":"physics/nonhydrostatic_model/","page":"Nonhydrostatic model","title":"Nonhydrostatic model","text":"The terms that appear on the right-hand side of the momentum conservation equation are (in order):","category":"page"},{"location":"physics/nonhydrostatic_model/","page":"Nonhydrostatic model","title":"Nonhydrostatic model","text":"momentum advection: left ( boldsymbolv boldsymbolcdot boldsymbolnabla right )  boldsymbolv,\nadvection of resolved momentum by the background velocity field boldsymbolV:  left ( boldsymbolV boldsymbolcdot boldsymbolnabla right ) boldsymbolv,\nadvection of background momentum by resolved velocity: left ( boldsymbolv boldsymbolcdot  boldsymbolnabla right ) boldsymbolV,\nCoriolis: boldsymbolf times boldsymbolv,\nthe effective background rotation rate due to surface waves: - left ( boldsymbolnabla times  boldsymbolu^S right ) times boldsymbolv,\nkinematic pressure gradient: boldsymbolnabla p,\nbuoyant acceleration: b,\nvertical unit vector (pointing to the direction opposite to gravity): boldsymbolhat g,\nmolecular or turbulence viscous stress: boldsymbolnabla boldsymbolcdot boldsymboltau,\na source of momentum due to forcing or damping of surface waves: partial_t boldsymbolu^S, and\nan arbitrary internal source of momentum: boldsymbolF_v.","category":"page"},{"location":"physics/nonhydrostatic_model/#The-tracer-conservation-equation","page":"Nonhydrostatic model","title":"The tracer conservation equation","text":"","category":"section"},{"location":"physics/nonhydrostatic_model/","page":"Nonhydrostatic model","title":"Nonhydrostatic model","text":"The conservation law for tracers is","category":"page"},{"location":"physics/nonhydrostatic_model/","page":"Nonhydrostatic model","title":"Nonhydrostatic model","text":"    beginalign\n    partial_t c = - boldsymbolv boldsymbolcdot boldsymbolnabla c\n                   - boldsymbolV boldsymbolcdot boldsymbolnabla c\n                   - boldsymbolv boldsymbolcdot boldsymbolnabla C\n                   - boldsymbolnabla boldsymbolcdot boldsymbolq_c\n                   + F_c  \n    labeleqtracer\n    endalign","category":"page"},{"location":"physics/nonhydrostatic_model/","page":"Nonhydrostatic model","title":"Nonhydrostatic model","text":"where boldsymbolq_c is the diffusive flux of c and F_c is an arbitrary source term. An arbitrary tracers are permitted and thus an arbitrary number of tracer equations can be solved simultaneously alongside with the momentum equations.","category":"page"},{"location":"physics/nonhydrostatic_model/","page":"Nonhydrostatic model","title":"Nonhydrostatic model","text":"From left to right, the terms that appear on the right-hand side of the tracer conservation equation are","category":"page"},{"location":"physics/nonhydrostatic_model/","page":"Nonhydrostatic model","title":"Nonhydrostatic model","text":"tracer advection: boldsymbolv boldsymbolcdot boldsymbolnabla c,\ntracer advection by the background velocity field, boldsymbolV: boldsymbolV boldsymbolcdot boldsymbolnabla c,\nadvection of the background tracer field, C, by the resolved velocity field: boldsymbolv boldsymbolcdot boldsymbolnabla C,\nmolecular or turbulent diffusion: boldsymbolnabla boldsymbolcdot boldsymbolq_c, and\nan arbitrary internal source of tracer: F_c.","category":"page"},{"location":"model_setup/overview/#Model-setup","page":"Overview","title":"Model setup","text":"","category":"section"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"This section describes all the options and features that can be used to set up a model. For  more detailed information consult the API documentation.","category":"page"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"Each structure covered in this section can be constructed and passed to the models' constructors.  For examples of model construction, see the examples. The validation experiments provide more  advanced examples.","category":"page"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"For reference, here are all the option or keyword arguments that can be passed to the currently implemented models. See the different sections on the sidebar for more  details and examples for each keyword argument.","category":"page"},{"location":"model_setup/overview/#NonhydrostaticModel","page":"Overview","title":"NonhydrostaticModel","text":"","category":"section"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"NonhydrostaticModel","category":"page"},{"location":"model_setup/overview/#Oceananigans.Models.NonhydrostaticModels.NonhydrostaticModel","page":"Overview","title":"Oceananigans.Models.NonhydrostaticModels.NonhydrostaticModel","text":"NonhydrostaticModel(;           grid,\n                                clock = Clock{eltype(grid)}(time = 0),\n                            advection = CenteredSecondOrder(),\n                             buoyancy = nothing,\n                             coriolis = nothing,\n                         stokes_drift = nothing,\n                  forcing::NamedTuple = NamedTuple(),\n                              closure = nothing,\n      boundary_conditions::NamedTuple = NamedTuple(),\n                              tracers = (),\n                          timestepper = :RungeKutta3,\n        background_fields::NamedTuple = NamedTuple(),\n        particles::ParticlesOrNothing = nothing,\nbiogeochemistry::AbstractBGCOrNothing = nothing,\n                           velocities = nothing,\n              nonhydrostatic_pressure = CenterField(grid),\n         hydrostatic_pressure_anomaly = DefaultHydrostaticPressureAnomaly(),\n                   diffusivity_fields = nothing,\n                      pressure_solver = nothing,\n                     auxiliary_fields = NamedTuple())\n\nConstruct a model for a non-hydrostatic, incompressible fluid on grid, using the Boussinesq approximation when buoyancy != nothing. By default, all Bounded directions are rigid and impenetrable.\n\nKeyword arguments\n\ngrid: (required) The resolution and discrete geometry on which the model is solved. The         architecture (CPU/GPU) that the model is solved on is inferred from the architecture         of the grid. Note that the grid needs to be regularly spaced in the horizontal         dimensions, x and y.\nadvection: The scheme that advects velocities and tracers. See Oceananigans.Advection.\nbuoyancy: The buoyancy model. See Oceananigans.BuoyancyModels.\ncoriolis: Parameters for the background rotation rate of the model.\nstokes_drift: Parameters for Stokes drift fields associated with surface waves. Default: nothing.\nforcing: NamedTuple of user-defined forcing functions that contribute to solution tendencies.\nclosure: The turbulence closure for model. See Oceananigans.TurbulenceClosures.\nboundary_conditions: NamedTuple containing field boundary conditions.\ntracers: A tuple of symbols defining the names of the modeled tracers, or a NamedTuple of            preallocated CenterFields.\ntimestepper: A symbol that specifies the time-stepping method. Either :QuasiAdamsBashforth2 or                :RungeKutta3 (default).\nbackground_fields: NamedTuple with background fields (e.g., background flow). Default: nothing.\nparticles: Lagrangian particles to be advected with the flow. Default: nothing.\nbiogeochemistry: Biogeochemical model for tracers.\nvelocities: The model velocities. Default: nothing.\nnonhydrostatic_pressure: The nonhydrostatic pressure field. Default: CenterField(grid).\nhydrostatic_pressure_anomaly: An optional field that stores the part of the nonhydrostatic pressure                                 in hydrostatic balance with the buoyancy field. If CenterField(grid) (default), the anomaly is precomputed by                                 vertically integrating the buoyancy field. In this case, the nonhydrostatic_pressure represents                                 only the part of pressure that deviates from the hydrostatic anomaly. If nothing, the anomaly                                 is not computed. \ndiffusivity_fields: Diffusivity fields. Default: nothing.\npressure_solver: Pressure solver to be used in the model. If nothing (default), the model constructor chooses the default based on the grid provide.\nauxiliary_fields: NamedTuple of auxiliary fields. Default: nothing         \n\n\n\n\n\n","category":"type"},{"location":"model_setup/overview/#HydrostaticFreeSurfaceModel","page":"Overview","title":"HydrostaticFreeSurfaceModel","text":"","category":"section"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"HydrostaticFreeSurfaceModel","category":"page"},{"location":"model_setup/overview/#Oceananigans.Models.HydrostaticFreeSurfaceModels.HydrostaticFreeSurfaceModel","page":"Overview","title":"Oceananigans.Models.HydrostaticFreeSurfaceModels.HydrostaticFreeSurfaceModel","text":"HydrostaticFreeSurfaceModel(; grid,\n                            clock = Clock{eltype(grid)}(time = 0),\n               momentum_advection = VectorInvariant(),\n                 tracer_advection = CenteredSecondOrder(),\n                         buoyancy = SeawaterBuoyancy(eltype(grid)),\n                         coriolis = nothing,\n                     free_surface = default_free_surface(grid, gravitational_acceleration=g_Earth),\n              forcing::NamedTuple = NamedTuple(),\n                          closure = nothing,\n  boundary_conditions::NamedTuple = NamedTuple(),\n                          tracers = (:T, :S),\n    particles::ParticlesOrNothing = nothing,\n\nbiogeochemistry::AbstractBGCOrNothing = nothing,                            velocities = nothing,                              pressure = nothing,                    diffusivityfields = nothing,                      auxiliaryfields = NamedTuple(),     )\n\nConstruct a hydrostatic model with a free surface on grid.\n\nKeyword arguments\n\ngrid: (required) The resolution and discrete geometry on which model is solved. The         architecture (CPU/GPU) that the model is solved is inferred from the architecture         of the grid.\nmomentum_advection: The scheme that advects velocities. See Oceananigans.Advection.\ntracer_advection: The scheme that advects tracers. See Oceananigans.Advection.\nbuoyancy: The buoyancy model. See Oceananigans.BuoyancyModels.\ncoriolis: Parameters for the background rotation rate of the model.\nfree_surface: The free surface model. The default free-surface solver depends on the                 geometry of the grid. If the grid is a RectilinearGrid that is                 regularly spaced in the horizontal the default is an ImplicitFreeSurface                 solver with solver_method = :FFTBasedPoissonSolver. In all other cases,                 the default is a SplitExplicitFreeSurface.\ntracers: A tuple of symbols defining the names of the modeled tracers, or a NamedTuple of            preallocated CenterFields.\nforcing: NamedTuple of user-defined forcing functions that contribute to solution tendencies.\nclosure: The turbulence closure for model. See Oceananigans.TurbulenceClosures.\nboundary_conditions: NamedTuple containing field boundary conditions.\nparticles: Lagrangian particles to be advected with the flow. Default: nothing.\nbiogeochemistry: Biogeochemical model for tracers.\nvelocities: The model velocities. Default: nothing.\npressure: Hydrostatic pressure field. Default: nothing.\ndiffusivity_fields: Diffusivity fields. Default: nothing.\nauxiliary_fields: NamedTuple of auxiliary fields. Default: nothing.\n\n\n\n\n\n","category":"type"},{"location":"model_setup/overview/#ShallowWaterModel","page":"Overview","title":"ShallowWaterModel","text":"","category":"section"},{"location":"model_setup/overview/","page":"Overview","title":"Overview","text":"ShallowWaterModel","category":"page"},{"location":"model_setup/overview/#Oceananigans.Models.ShallowWaterModels.ShallowWaterModel","page":"Overview","title":"Oceananigans.Models.ShallowWaterModels.ShallowWaterModel","text":"ShallowWaterModel(; grid,\n                    gravitational_acceleration,\n                          clock = Clock{eltype(grid)}(time = 0),\n             momentum_advection = UpwindBiasedFifthOrder(),\n               tracer_advection = WENO(),\n                 mass_advection = WENO(),\n                       coriolis = nothing,\n            forcing::NamedTuple = NamedTuple(),\n                        closure = nothing,\n                     bathymetry = nothing,\n                        tracers = (),\n             diffusivity_fields = nothing,\nboundary_conditions::NamedTuple = NamedTuple(),\n            timestepper::Symbol = :RungeKutta3,\n                    formulation = ConservativeFormulation())\n\nConstruct a shallow water model on grid with gravitational_acceleration constant.\n\nKeyword arguments\n\ngrid: (required) The resolution and discrete geometry on which model is solved. The         architecture (CPU/GPU) that the model is solve is inferred from the architecture         of the grid.\ngravitational_acceleration: (required) The gravitational acceleration constant.\nclock: The clock for the model.\nmomentum_advection: The scheme that advects velocities. See Oceananigans.Advection. Default: UpwindBiasedFifthOrder().\ntracer_advection: The scheme that advects tracers. See Oceananigans.Advection. Default: WENO().\nmass_advection: The scheme that advects the mass equation. See Oceananigans.Advection. Default: WENO().\ncoriolis: Parameters for the background rotation rate of the model.\nforcing: NamedTuple of user-defined forcing functions that contribute to solution tendencies.\nclosure: The turbulence closure for model. See Oceananigans.TurbulenceClosures.\nbathymetry: The bottom bathymetry.\ntracers: A tuple of symbols defining the names of the modeled tracers, or a NamedTuple of            preallocated CenterFields.\ndiffusivity_fields: Stores diffusivity fields when the closures require a diffusivity to be                       calculated at each timestep.\nboundary_conditions: NamedTuple containing field boundary conditions.\ntimestepper: A symbol that specifies the time-stepping method. Either :QuasiAdamsBashforth2 or                :RungeKutta3 (default).\nformulation: Whether the dynamics are expressed in conservative form (ConservativeFormulation();                default) or in non-conservative form with a vector-invariant formulation for the                non-linear terms (VectorInvariantFormulation()).\n\nwarning: Formulation-grid compatibility requirements\nThe ConservativeFormulation() requires RectilinearGrid. Use VectorInvariantFormulation() with LatitudeLongitudeGrid.\n\n\n\n\n\n","category":"type"},{"location":"physics/buoyancy_and_equations_of_state/#Buoyancy-model-and-equations-of-state","page":"Buoyancy models and equations of state","title":"Buoyancy model and equations of state","text":"","category":"section"},{"location":"physics/buoyancy_and_equations_of_state/","page":"Buoyancy models and equations of state","title":"Buoyancy models and equations of state","text":"The buoyancy model determines the relationship between tracers and the buoyancy b in the momentum equation.","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/#Buoyancy-tracer","page":"Buoyancy models and equations of state","title":"Buoyancy tracer","text":"","category":"section"},{"location":"physics/buoyancy_and_equations_of_state/","page":"Buoyancy models and equations of state","title":"Buoyancy models and equations of state","text":"The simplest buoyancy model uses buoyancy b itself as a tracer: b obeys the tracer conservation equation and is used directly in the momentum equations.","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/#Seawater-buoyancy","page":"Buoyancy models and equations of state","title":"Seawater buoyancy","text":"","category":"section"},{"location":"physics/buoyancy_and_equations_of_state/","page":"Buoyancy models and equations of state","title":"Buoyancy models and equations of state","text":"For seawater buoyancy is, in general, modeled as a function of conservative temperature T, absolute salinity S, and depth below the ocean surface d via","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/","page":"Buoyancy models and equations of state","title":"Buoyancy models and equations of state","text":"    beginequation\n    b = - fracgrho_0 rho left (T S d right )  \n    labeleqseawater-buoyancy\n    endequation","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/","page":"Buoyancy models and equations of state","title":"Buoyancy models and equations of state","text":"where g is gravitational acceleration, rho_0 is the reference density. The function rho(T S d) in the seawater buoyancy relationship that links conservative temperature, salinity, and depth to the density perturbation is called the equation of state. Both T and S obey the tracer conservation equation.","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/#Linear-equation-of-state","page":"Buoyancy models and equations of state","title":"Linear equation of state","text":"","category":"section"},{"location":"physics/buoyancy_and_equations_of_state/","page":"Buoyancy models and equations of state","title":"Buoyancy models and equations of state","text":"Buoyancy is determined from a linear equation of state via","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/","page":"Buoyancy models and equations of state","title":"Buoyancy models and equations of state","text":"    b = g left ( alpha T - beta S right )  ","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/","page":"Buoyancy models and equations of state","title":"Buoyancy models and equations of state","text":"where g is gravitational acceleration, alpha is the thermal expansion coefficient, and beta is the haline contraction coefficient.","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/#Nonlinear-equation-of-state","page":"Buoyancy models and equations of state","title":"Nonlinear equation of state","text":"","category":"section"},{"location":"physics/buoyancy_and_equations_of_state/","page":"Buoyancy models and equations of state","title":"Buoyancy models and equations of state","text":"Buoyancy is determined by the simplified equations of state introduced by Roquet et al. (2015).","category":"page"},{"location":"model_setup/boundary_conditions/#model_step_bcs","page":"Boundary conditions","title":"Boundary conditions","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Boundary conditions are intimately related to the grid topology, and only need to be considered in directions with Bounded topology or across immersed boundaries. In Bounded directions, tracer and momentum fluxes are conservative or \"zero flux\" by default. Non-default boundary conditions are therefore required to specify non-zero fluxes of tracers and momentum across Bounded directions, and across immersed boundaries when using ImmersedBoundaryGrid.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"See Numerical implementation of boundary conditions for more details.","category":"page"},{"location":"model_setup/boundary_conditions/#Example:-no-slip-conditions-on-every-boundary","page":"Boundary conditions","title":"Example: no-slip conditions on every boundary","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"DocTestSetup = quote\n   using Oceananigans\n\n   using Random\n   Random.seed!(1234)\nend","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> using Oceananigans\n\njulia> grid = RectilinearGrid(size=(16, 16, 16), x=(0, 2π), y=(0, 1), z=(0, 1), topology=(Periodic, Bounded, Bounded))\n16×16×16 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3×3×3 halo\n├── Periodic x ∈ [0.0, 6.28319) regularly spaced with Δx=0.392699\n├── Bounded  y ∈ [0.0, 1.0]     regularly spaced with Δy=0.0625\n└── Bounded  z ∈ [0.0, 1.0]     regularly spaced with Δz=0.0625\n\njulia> no_slip_bc = ValueBoundaryCondition(0.0)\nValueBoundaryCondition: 0.0","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"A \"no-slip\" BoundaryCondition specifies that velocity components tangential to Bounded directions decay to 0 at the boundary, leading to a viscous loss of momentum.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> no_slip_field_bcs = FieldBoundaryConditions(no_slip_bc);\n\njulia> model = NonhydrostaticModel(; grid, boundary_conditions=(u=no_slip_field_bcs, v=no_slip_field_bcs, w=no_slip_field_bcs))\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\n├── grid: 16×16×16 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3×3×3 halo\n├── timestepper: RungeKutta3TimeStepper\n├── advection scheme: Centered reconstruction order 2\n├── tracers: ()\n├── closure: Nothing\n├── buoyancy: Nothing\n└── coriolis: Nothing\n\njulia> model.velocities.u.boundary_conditions\nOceananigans.FieldBoundaryConditions, with boundary conditions\n├── west: PeriodicBoundaryCondition\n├── east: PeriodicBoundaryCondition\n├── south: ValueBoundaryCondition: 0.0\n├── north: ValueBoundaryCondition: 0.0\n├── bottom: ValueBoundaryCondition: 0.0\n├── top: ValueBoundaryCondition: 0.0\n└── immersed: FluxBoundaryCondition: Nothing","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Boundary conditions are passed to FieldBoundaryCondition to build boundary conditions for each field individually, and then onto the model constructor (here NonhydrotaticModel) via the  keyword argument boundary_conditions. The model constructor then \"interprets\" the input and builds appropriate boundary conditions for the grid topology, given the user-specified no_slip default boundary condition for Bounded directions. In the above example, note that the west and east boundary conditions are PeriodicBoundaryCondition because the x-topology of the grid is Periodic.","category":"page"},{"location":"model_setup/boundary_conditions/#Example:-specifying-boundary-conditions-on-individual-boundaries","page":"Boundary conditions","title":"Example: specifying boundary conditions on individual boundaries","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"To specify no-slip boundary conditions on every Bounded direction except the surface, we write","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> free_slip_surface_bcs = FieldBoundaryConditions(no_slip_bc, top=FluxBoundaryCondition(nothing));\n\njulia> model = NonhydrostaticModel(; grid, boundary_conditions=(u=free_slip_surface_bcs, v=free_slip_surface_bcs, w=no_slip_field_bcs));\n\njulia> model.velocities.u.boundary_conditions\nOceananigans.FieldBoundaryConditions, with boundary conditions\n├── west: PeriodicBoundaryCondition\n├── east: PeriodicBoundaryCondition\n├── south: ValueBoundaryCondition: 0.0\n├── north: ValueBoundaryCondition: 0.0\n├── bottom: ValueBoundaryCondition: 0.0\n├── top: FluxBoundaryCondition: Nothing\n└── immersed: FluxBoundaryCondition: Nothing\n\njulia> model.velocities.v.boundary_conditions\nOceananigans.FieldBoundaryConditions, with boundary conditions\n├── west: PeriodicBoundaryCondition\n├── east: PeriodicBoundaryCondition\n├── south: OpenBoundaryCondition{Nothing}: Nothing\n├── north: OpenBoundaryCondition{Nothing}: Nothing\n├── bottom: ValueBoundaryCondition: 0.0\n├── top: FluxBoundaryCondition: Nothing\n└── immersed: FluxBoundaryCondition: Nothing","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Now both u and v have FluxBoundaryCondition(nothing) at the top boundary, which is Oceananigans lingo for \"no-flux boundary condition\".","category":"page"},{"location":"model_setup/boundary_conditions/#Boundary-condition-classifications","page":"Boundary conditions","title":"Boundary condition classifications","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"There are three primary boundary condition classifications:","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"FluxBoundaryCondition specifies fluxes directly.\nSome applications of FluxBoundaryCondition are:\nsurface momentum fluxes due to wind, or \"wind stress\";\nlinear or quadratic bottom drag;\nsurface temperature fluxes due to heating or cooling;\nsurface salinity fluxes due to precipitation and evaporation;\nrelaxation boundary conditions that restores a field to some boundary distribution over a given time-scale.\nValueBoundaryCondition (Dirichlet) specifies the value of a field on the given boundary, which when used in combination with a turbulence closure results in a flux across the boundary.\nNote: Do not use ValueBoundaryCondition on a wall-normal velocity component (see the note below about ImpenetrableBoundaryCondition).\nSome applications of ValueBoundaryCondition are:\nno-slip boundary condition for wall-tangential velocity components via ValueBoundaryCondition(0);\nsurface temperature distribution, where heat fluxes in and out of the domain at a rate controlled by the near-surface temperature gradient and the temperature diffusivity;\nconstant velocity tangential to a boundary as in a driven-cavity flow (for example),  where the top boundary is moving. Momentum will flux into the domain do the difference between the top boundary velocity and the interior velocity, and the prescribed viscosity.\nGradientBoundaryCondition (Neumann) specifies the gradient of a field on a boundary. For example, if there is a known diffusivity, we can express FluxBoundaryCondition(flux) using GradientBoundaryCondition(-flux / diffusivity) (aka \"Neumann\" boundary condition).","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"In addition to these primary boundary conditions, ImpenetrableBoundaryCondition applies to velocity components in wall-normal directions.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"warn: `ImpenetrableBoundaryCondition`\nImpenetrableBoundaryCondition is internally enforced for fields created inside the model constructor. As a result, ImpenetrableBoundaryCondition is only used for additional velocity components that are not evolved by a model, such as a velocity component used for (AdvectiveForcing)[@ref].","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Finally, note that Periodic boundary conditions are internally enforced for Periodic directions, and DefaultBoundaryConditions may exist before boundary conditions are \"materialized\" by a model.","category":"page"},{"location":"model_setup/boundary_conditions/#Default-boundary-conditions","page":"Boundary conditions","title":"Default boundary conditions","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"The default boundary condition in Bounded directions is no-flux, or FluxBoundaryCondition(nothing). The default boundary condition can be changed by passing a positional argument to FieldBoundaryConditions, as in","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> no_slip_bc = ValueBoundaryCondition(0.0)\nValueBoundaryCondition: 0.0\n\njulia> free_slip_surface_bcs = FieldBoundaryConditions(no_slip_bc, top=FluxBoundaryCondition(nothing))\nOceananigans.FieldBoundaryConditions, with boundary conditions\n├── west: DefaultBoundaryCondition (ValueBoundaryCondition: 0.0)\n├── east: DefaultBoundaryCondition (ValueBoundaryCondition: 0.0)\n├── south: DefaultBoundaryCondition (ValueBoundaryCondition: 0.0)\n├── north: DefaultBoundaryCondition (ValueBoundaryCondition: 0.0)\n├── bottom: DefaultBoundaryCondition (ValueBoundaryCondition: 0.0)\n├── top: FluxBoundaryCondition: Nothing\n└── immersed: DefaultBoundaryCondition (ValueBoundaryCondition: 0.0)","category":"page"},{"location":"model_setup/boundary_conditions/#Boundary-condition-structures","page":"Boundary conditions","title":"Boundary condition structures","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Oceananigans uses a hierarchical structure to express boundary conditions:","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Each boundary of each field has one BoundaryCondition\nEach field has seven BoundaryCondition (west, east, south, north, bottom, top and immersed)\nA set of FieldBoundaryConditions, up to one for each field, are grouped into a NamedTuple and passed to the model constructor.","category":"page"},{"location":"model_setup/boundary_conditions/#Specifying-boundary-conditions-for-a-model","page":"Boundary conditions","title":"Specifying boundary conditions for a model","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Boundary conditions are defined at model construction time by passing a NamedTuple of FieldBoundaryConditions specifying non-default boundary conditions for fields such as velocities and tracers.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Fields for which boundary conditions are not specified are assigned a default boundary conditions.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"A few illustrations are provided below. See the examples for further illustrations of boundary condition specification.","category":"page"},{"location":"model_setup/boundary_conditions/#Creating-individual-boundary-conditions-with-BoundaryCondition","page":"Boundary conditions","title":"Creating individual boundary conditions with BoundaryCondition","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Boundary conditions may be specified with constants, functions, or arrays. In this section we illustrate usage of the different BoundaryCondition constructors.","category":"page"},{"location":"model_setup/boundary_conditions/#1.-Constant-Value-(Dirchlet)-boundary-condition","page":"Boundary conditions","title":"1. Constant Value (Dirchlet) boundary condition","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> constant_T_bc = ValueBoundaryCondition(20.0)\nValueBoundaryCondition: 20.0","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"A constant Value boundary condition can be used to specify constant tracer (such as temperature), or a constant tangential velocity component at a boundary. Note that boundary conditions on the normal velocity component must use the Open boundary condition type.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Finally, note that ValueBoundaryCondition(condition) is an alias for BoundaryCondition(Value, condition).","category":"page"},{"location":"model_setup/boundary_conditions/#2.-Constant-Flux-boundary-condition","page":"Boundary conditions","title":"2. Constant Flux boundary condition","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> ρ₀ = 1027;  # Reference density [kg/m³]\n\njulia> τₓ = 0.08;  # Wind stress [N/m²]\n\njulia> wind_stress_bc = FluxBoundaryCondition(-τₓ/ρ₀)\nFluxBoundaryCondition: -7.78968e-5","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"A constant Flux boundary condition can be imposed on tracers and tangential velocity components that can be used, for example, to specify cooling, heating, evaporation, or wind stress at the ocean surface.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"info: The flux convention in Oceananigans\nOceananigans uses the convention that positive fluxes produce transport in the positive direction (east, north, and up for x, y, z). This means, for example, that a negative flux of momentum or velocity at a top boundary, such as in the above example, produces currents in the positive direction, because it prescribes a downwards flux of momentum into the domain from the top. Likewise, a positive temperature flux at the top boundary causes cooling, because it transports heat upwards, out of the domain. Conversely, a positive flux at a bottom boundary acts to increase the interior values of a quantity.","category":"page"},{"location":"model_setup/boundary_conditions/#3.-Spatially-and-temporally-varying-flux","page":"Boundary conditions","title":"3. Spatially- and temporally-varying flux","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Boundary conditions may be specified by functions,","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> @inline surface_flux(x, y, t) = cos(2π * x) * cos(t);\n\njulia> top_tracer_bc = FluxBoundaryCondition(surface_flux)\nFluxBoundaryCondition: ContinuousBoundaryFunction surface_flux at (Nothing, Nothing, Nothing)","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"info: Boundary condition functions\nBy default, a function boundary condition is called with the signaturef(ξ, η, t)where t is time and ξ, η are spatial coordinates that vary along the boundary:f(y, z, t) on x-boundaries;\nf(x, z, t) on y-boundaries;\nf(x, y, t) on z-boundaries.Alternative function signatures are specified by keyword arguments to BoundaryCondition, as illustrated in subsequent examples.","category":"page"},{"location":"model_setup/boundary_conditions/#4.-Spatially-and-temporally-varying-flux-with-parameters","page":"Boundary conditions","title":"4. Spatially- and temporally-varying flux with parameters","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Boundary condition functions may be 'parameterized',","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> @inline wind_stress(x, y, t, p) = - p.τ * cos(p.k * x) * cos(p.ω * t); # function with parameters\n\njulia> top_u_bc = FluxBoundaryCondition(wind_stress, parameters=(k=4π, ω=3.0, τ=1e-4))\nFluxBoundaryCondition: ContinuousBoundaryFunction wind_stress at (Nothing, Nothing, Nothing)","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"info: Boundary condition functions with parameters\nThe keyword argument parameters above specifies that wind_stress is called with the signature wind_stress(x, y, t, parameters). In principle, parameters is arbitrary. However, relatively simple objects such as floating point numbers or NamedTuples must be used when running on the GPU.","category":"page"},{"location":"model_setup/boundary_conditions/#5.-'Field-dependent'-boundary-conditions","page":"Boundary conditions","title":"5. 'Field-dependent' boundary conditions","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Boundary conditions may also depend on model fields. For example, a linear drag boundary condition is implemented with","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> @inline linear_drag(x, y, t, u) = - 0.2 * u\nlinear_drag (generic function with 1 method)\n\njulia> u_bottom_bc = FluxBoundaryCondition(linear_drag, field_dependencies=:u)\nFluxBoundaryCondition: ContinuousBoundaryFunction linear_drag at (Nothing, Nothing, Nothing)","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"field_dependencies specifies the name of the dependent fields either with a Symbol or Tuple of Symbols.","category":"page"},{"location":"model_setup/boundary_conditions/#6.-'Field-dependent'-boundary-conditions-with-parameters","page":"Boundary conditions","title":"6. 'Field-dependent' boundary conditions with parameters","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"When boundary conditions depends on fields and parameters, their functions take the form","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> @inline quadratic_drag(x, y, t, u, v, drag_coeff) = - drag_coeff * u * sqrt(u^2 + v^2)\nquadratic_drag (generic function with 1 method)\n\njulia> u_bottom_bc = FluxBoundaryCondition(quadratic_drag, field_dependencies=(:u, :v), parameters=1e-3)\nFluxBoundaryCondition: ContinuousBoundaryFunction quadratic_drag at (Nothing, Nothing, Nothing)","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Put differently, ξ, η, t come first in the function signature, followed by field dependencies, followed by parameters is !isnothing(parameters).","category":"page"},{"location":"model_setup/boundary_conditions/#7.-Discrete-form-boundary-condition-with-parameters","page":"Boundary conditions","title":"7. Discrete-form boundary condition with parameters","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Discrete field data may also be accessed directly from boundary condition functions using the discrete_form. For example:","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"@inline filtered_drag(i, j, grid, clock, model_fields) =\n    @inbounds - 0.05 * (model_fields.u[i-1, j, 1] + 2 * model_fields.u[i, j, 1] + model_fields.u[i-1, j, 1])\n\nu_bottom_bc = FluxBoundaryCondition(filtered_drag, discrete_form=true)\n\n# output\nFluxBoundaryCondition: DiscreteBoundaryFunction with filtered_drag","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"info: The 'discrete form' for boundary condition functions\nThe argument discrete_form=true indicates to BoundaryCondition that filtered_drag uses the 'discrete form'. Boundary condition functions that use the 'discrete form' are called with the signaturef(i, j, grid, clock, model_fields)where i, j are grid indices that vary along the boundary, grid is model.grid, clock is the model.clock, and model_fields is a NamedTuple containing u, v, w and the fields in model.tracers. The signature is similar for x and y boundary conditions expect that i, j is replaced with j, k and i, k respectively.","category":"page"},{"location":"model_setup/boundary_conditions/#8.-Discrete-form-boundary-condition-with-parameters","page":"Boundary conditions","title":"8. Discrete-form boundary condition with parameters","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> Cd = 0.2; # drag coefficient\n\njulia> @inline linear_drag(i, j, grid, clock, model_fields, Cd) = @inbounds - Cd * model_fields.u[i, j, 1];\n\njulia> u_bottom_bc = FluxBoundaryCondition(linear_drag, discrete_form=true, parameters=Cd)\nFluxBoundaryCondition: DiscreteBoundaryFunction linear_drag with parameters 0.2","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"info: Inlining and avoiding bounds-checking in boundary condition functions\nBoundary condition functions should be decorated with @inline when running on CPUs for performance reasons. On the GPU, all functions are force-inlined by default. In addition, the annotation @inbounds should be used when accessing the elements of an array in a boundary condition function (such as model_fields.u[i, j, 1] in the above example). Using @inbounds will avoid a relatively expensive check that the index i, j, 1 is 'in bounds'.","category":"page"},{"location":"model_setup/boundary_conditions/#9.-A-random,-spatially-varying,-constant-in-time-temperature-flux-specified-by-an-array","page":"Boundary conditions","title":"9. A random, spatially-varying, constant-in-time temperature flux specified by an array","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> Nx = Ny = 16;  # Number of grid points.\n\njulia> Q = randn(Nx, Ny); # temperature flux\n\njulia> white_noise_T_bc = FluxBoundaryCondition(Q)\nFluxBoundaryCondition: 16×16 Matrix{Float64}","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"When running on the GPU, Q must be converted to a CuArray.","category":"page"},{"location":"model_setup/boundary_conditions/#Building-boundary-conditions-on-a-field","page":"Boundary conditions","title":"Building boundary conditions on a field","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"To create a set of FieldBoundaryConditions for a temperature field, we write","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> T_bcs = FieldBoundaryConditions(top = ValueBoundaryCondition(20.0),\n                                       bottom = GradientBoundaryCondition(0.01))\nOceananigans.FieldBoundaryConditions, with boundary conditions\n├── west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── bottom: GradientBoundaryCondition: 0.01\n├── top: ValueBoundaryCondition: 20.0\n└── immersed: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"If the grid is, e.g., horizontally-periodic, then each horizontal DefaultBoundaryCondition is converted to PeriodicBoundaryCondition inside the model's constructor, before assigning the boundary conditions to temperature T.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"In general, boundary condition defaults are inferred from the field location and topology(grid).","category":"page"},{"location":"model_setup/boundary_conditions/#Specifying-model-boundary-conditions","page":"Boundary conditions","title":"Specifying model boundary conditions","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"To specify non-default boundary conditions, a named tuple of FieldBoundaryConditions objects is passed to the keyword argument boundary_conditions in the NonhydrostaticModel constructor. The keys of boundary_conditions indicate the field to which the boundary condition is applied. Below, non-default boundary conditions are imposed on the u-velocity and tracer c.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"julia> topology = (Periodic, Periodic, Bounded);\n\njulia> grid = RectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1), topology=topology);\n\njulia> u_bcs = FieldBoundaryConditions(top = ValueBoundaryCondition(+0.1),\n                                       bottom = ValueBoundaryCondition(-0.1));\n\njulia> c_bcs = FieldBoundaryConditions(top = ValueBoundaryCondition(20.0),\n                                       bottom = GradientBoundaryCondition(0.01));\n\njulia> model = NonhydrostaticModel(grid=grid, boundary_conditions=(u=u_bcs, c=c_bcs), tracers=:c)\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\n├── grid: 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo\n├── timestepper: RungeKutta3TimeStepper\n├── advection scheme: Centered reconstruction order 2\n├── tracers: c\n├── closure: Nothing\n├── buoyancy: Nothing\n└── coriolis: Nothing\n\njulia> model.velocities.u\n16×16×16 Field{Face, Center, Center} on RectilinearGrid on CPU\n├── grid: 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo\n├── boundary conditions: FieldBoundaryConditions\n│   └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Value, top: Value, immersed: ZeroFlux\n└── data: 22×22×22 OffsetArray(::Array{Float64, 3}, -2:19, -2:19, -2:19) with eltype Float64 with indices -2:19×-2:19×-2:19\n    └── max=0.0, min=0.0, mean=0.0\n\njulia> model.tracers.c\n16×16×16 Field{Center, Center, Center} on RectilinearGrid on CPU\n├── grid: 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo\n├── boundary conditions: FieldBoundaryConditions\n│   └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Gradient, top: Value, immersed: ZeroFlux\n└── data: 22×22×22 OffsetArray(::Array{Float64, 3}, -2:19, -2:19, -2:19) with eltype Float64 with indices -2:19×-2:19×-2:19\n    └── max=0.0, min=0.0, mean=0.0","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Notice that the specified non-default boundary conditions have been applied at top and bottom of both model.velocities.u and model.tracers.c.","category":"page"},{"location":"model_setup/boundary_conditions/#Immersed-boundary-conditions","page":"Boundary conditions","title":"Immersed boundary conditions","text":"","category":"section"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Immersed boundary conditions are supported experimentally. A no-slip boundary condition is specified with","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"DocTestFilters = r\"┌ Warning:[\\s\\S]*\\.jl:[0-9]*\"","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"# Generate a simple ImmersedBoundaryGrid\nhill(x, y) = 0.1 + 0.1 * exp(-x^2 - y^2)\nunderlying_grid = RectilinearGrid(size=(32, 32, 16), x=(-3, 3), y=(-3, 3), z=(0, 1), topology=(Periodic, Periodic, Bounded))\ngrid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(hill))\n\n# Create a no-slip boundary condition for velocity fields.\n# Note that the no-slip boundary condition is _only_ applied on immersed boundaries.\nvelocity_bcs = FieldBoundaryConditions(immersed=ValueBoundaryCondition(0))\nmodel = NonhydrostaticModel(; grid, boundary_conditions=(u=velocity_bcs, v=velocity_bcs, w=velocity_bcs))\n\n# Insepct the boundary condition on the vertical velocity:\nmodel.velocities.w.boundary_conditions.immersed\n\n# output\nImmersedBoundaryCondition:\n├── west: ValueBoundaryCondition: 0.0\n├── east: ValueBoundaryCondition: 0.0\n├── south: ValueBoundaryCondition: 0.0\n├── north: ValueBoundaryCondition: 0.0\n├── bottom: Nothing\n└── top: Nothing","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"warning: `NonhydrostaticModel` on `ImmersedBoundaryGrid`\nThe pressure solver for NonhydrostaticModel is approximate, and is unable to produce a velocity field that is simultaneously divergence-free while also satisfying impenetrability on the immersed boundary. As a result, simulated dynamics with NonhydrostaticModel can exhibit egregiously unphysical errors and should be interpreted with caution.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"An ImmersedBoundaryCondition encapsulates boundary conditions on each potential boundary-facet of a boundary-adjacent cell. Boundary conditions on specific faces of immersed-boundary-adjacent cells may also be specified by manually building an ImmersedBoundaryCondition:","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"bottom_drag_bc = ImmersedBoundaryCondition(bottom=ValueBoundaryCondition(0))\n\n# output\nImmersedBoundaryCondition:\n├── west: Nothing\n├── east: Nothing\n├── south: Nothing\n├── north: Nothing\n├── bottom: ValueBoundaryCondition: 0\n└── top: Nothing","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"The ImmersedBoundaryCondition may then be incorporated into the boundary conditions for a Field by prescribing it to the immersed boundary label,","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"velocity_bcs = FieldBoundaryConditions(immersed=bottom_drag_bc)\n\n# output\nOceananigans.FieldBoundaryConditions, with boundary conditions\n├── west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── bottom: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── top: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n└── immersed: ImmersedBoundaryCondition with west=Nothing, east=Nothing, south=Nothing, north=Nothing, bottom=Value, top=Nothing","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"warning: `ImmersedBoundaryCondition`\nImmersedBoundaryCondition is experimental. Therefore, one should use it only when a finer level of control over the boundary conditions at the immersed boundary is required, and the user is familiar with the implementation of boundary  conditions on staggered grids. For all other cases , using the immersed argument of FieldBoundaryConditions is preferred.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"A boundary condition that depends on the fields may be prescribed using the immersed keyword argument in FieldBoundaryConditions. We illustrate field-dependent boundary conditions with an example that imposes linear bottom drag on u on both the bottom facets of cells adjacent to an immersed boundary, and the bottom boundary of the underlying grid.","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"First we create the boundary condition for the grid's bottom:","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"@inline linear_drag(x, y, t, u) = - 0.2 * u\ndrag_u = FluxBoundaryCondition(linear_drag, field_dependencies=:u)\n\n# output\nFluxBoundaryCondition: ContinuousBoundaryFunction linear_drag at (Nothing, Nothing, Nothing)","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Next, we create the immersed boundary condition by adding the argument z to linear_drag and imposing drag only on \"bottom\" facets of cells that neighbor immersed cells:","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"@inline immersed_linear_drag(x, y, z, t, u) = - 0.2 * u\nimmersed_drag_u = FluxBoundaryCondition(immersed_linear_drag, field_dependencies=:u)\n\nu_immersed_bc = ImmersedBoundaryCondition(bottom = immersed_drag_u)\n\n# output\nImmersedBoundaryCondition:\n├── west: Nothing\n├── east: Nothing\n├── south: Nothing\n├── north: Nothing\n├── bottom: FluxBoundaryCondition: ContinuousBoundaryFunction immersed_linear_drag at (Nothing, Nothing, Nothing)\n└── top: Nothing","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Finally, we combine the two:","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"u_bcs = FieldBoundaryConditions(bottom = drag_u, immersed = u_immersed_bc)\n\n# output\nOceananigans.FieldBoundaryConditions, with boundary conditions\n├── west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n├── bottom: FluxBoundaryCondition: ContinuousBoundaryFunction linear_drag at (Nothing, Nothing, Nothing)\n├── top: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)\n└── immersed: ImmersedBoundaryCondition with west=Nothing, east=Nothing, south=Nothing, north=Nothing, bottom=Flux, top=Nothing","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"warning: Positional argument requirements\nNote the difference between the arguments required for the function within the bottom boundary condition versus the arguments for the function within the immersed boundary condition. E.g., x, y, t in linear_drag() versus x, y, z, t in immersed_linear_drag().","category":"page"},{"location":"model_setup/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"DocTestFilters = nothing","category":"page"},{"location":"gallery/#Gallery","page":"Gallery","title":"Gallery","text":"","category":"section"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"Collection of cool movies!","category":"page"},{"location":"gallery/#[Deep-convection](https://www.youtube.com/watch?vkpUrxnKKMjI)","page":"Gallery","title":"Deep convection","text":"","category":"section"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"An idealized simulation of deep convection in the ocean. The simulation employs a resolution of 256x256x128 volumes in a 2x2x1 km horizontally periodic domain. Heat is sucked out of the ocean surface within a cooling disk of radius 600 m at a rate of 800 W/m² which cools the surface water and making it denser. This cold dense water then sinks into the ocean interior, initiating a convective process that penetrates deep into the ocean.","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"This deep convection process can happen when a cold storm passes through warmer waters, which happens for example in the Labrador Sea.","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"The video shows the temperature field and the domain is sliced in half so the convection happening under the cooling disk is clear.","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"(Image: Watch deep convection in action)","category":"page"},{"location":"gallery/#[Free-convection](https://www.youtube.com/watch?vyq4op9h3xcU)","page":"Gallery","title":"Free convection","text":"","category":"section"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"An idealized simulation of free convection in the ocean. The simulation employs a resolution of 256x256x256 volumes in a 100x100x100 m horizontally periodic domain. Heat is sucked out of the ocean surface at a rate of 75 W/m² which cools the surface water and making it denser. This cold dense water then sinks into the ocean interior, initiating a convective process that keeps mixing the upper layer of the ocean. This \"mixed layer\" has a relatively constant temperature and keeps deepening as the surface is cooled.","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"The video shows the temperature field and the domain is sliced in half.","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"(Image: Watch free convection in action)","category":"page"},{"location":"gallery/#[Winds-blowing-over-the-ocean](https://www.youtube.com/watch?vIRncfbvuiy8)","page":"Gallery","title":"Winds blowing over the ocean","text":"","category":"section"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"An idealized simulation of a strong wind stress acting on the surface of a stratified ocean. The simulation employs a resolution of 256x256x256 volumes in a 100x100x100 m horizontally periodic domain. A pretty strong wind stress of 0.1 N/m² is applied in the x direction which mechanically mixes the upper layer of the ocean. This leads to a \"mixed layer\" of constant temperature near the surface of the ocean. You can also see the onset of Kelvin-Helmholtz instabilities as the mechanical mixing sets in.","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"The video shows the temperature field in the top 25 meters and the domain is sliced in half for visualization. The line plots show the horizontally averaged temperature profile (top right), horizontally averaged turbulent kinetic energy (middle right), and the horizontally averaged buoyancy flux (or temperature flux).","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"(Image: Watch winds blowing over the ocean)","category":"page"},{"location":"gallery/#[Free-convection-with-wind-stress](https://www.youtube.com/watch?vob6OMQgPfI4)","page":"Gallery","title":"Free convection with wind stress","text":"","category":"section"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"An idealized simulation of a strong wind stress acting on the surface of a stratified ocean along with a cooling flux that sucks heat out of the surface. The simulation employs a resolution of 256x256x256 volumes in a 100x100x100 m horizontally periodic domain. A pretty strong wind stress of 0.1 N/m² is applied in the x direction which mechanically mixes the upper layer of the ocean. Also, heat is sucked out of the ocean surface at a rate of 75 W/m² which cools the surface water and making it denser. This cold dense water then sinks into the ocean interior, initiating a convective process that keeps mixing the upper layer of the ocean. This leads to a \"mixed layer\" of constant temperature near the surface of the ocean. You can also see the onset of Kelvin-Helmholtz instabilities as the mechanical mixing sets in.","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"The video shows the temperature field and the domain is sliced in half for visualization. The line plots show the horizontally averaged temperature profile (top right), horizontally averaged turbulent kinetic energy (middle right), and the horizontally averaged buoyancy flux (or temperature flux). The unusual periodic prism colormap is used to show the fine details at the surface as it cools and the layers of different temperatures (the isopycnals) being perturbed by internal waves.","category":"page"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"(Image: Watch free convection with wind stress in action)","category":"page"},{"location":"physics/shallow_water_model/#Shallow-water-model","page":"Shallow water model","title":"Shallow water model","text":"","category":"section"},{"location":"physics/shallow_water_model/","page":"Shallow water model","title":"Shallow water model","text":"The ShallowWaterModel simulates the shallow water dynamics for a fluid of constant density but with varying fluid depth h(x y t) and whose velocity only varies in the horizontal, boldsymbolu(x y t) = u(x y t) boldsymbolhat x + v(x y t) boldsymbolhat y.","category":"page"},{"location":"physics/shallow_water_model/","page":"Shallow water model","title":"Shallow water model","text":"ShallowWaterModel allows users to prescribe the shallow water dynamics using two different formulations: VectorInvariantFormulation() and ConservativeFormulation().","category":"page"},{"location":"physics/shallow_water_model/","page":"Shallow water model","title":"Shallow water model","text":"The VectorInvariantFormulation uses the horizontal velocity boldsymbolu and the total depth of the fluid, h, as the dynamical variables. Furthermore, the advective terms are rewritten via the vector identity:","category":"page"},{"location":"physics/shallow_water_model/","page":"Shallow water model","title":"Shallow water model","text":"boldsymbolu boldsymbolcdot boldsymbolnabla boldsymbolu = (boldsymbolnabla times boldsymbolu) times boldsymbolu + boldsymbolnabla left( frac12 boldsymbolu boldsymbolcdot boldsymbolu right )  ","category":"page"},{"location":"physics/shallow_water_model/","page":"Shallow water model","title":"Shallow water model","text":"Thus, the shallow water dynamics in vector-invariant form become:","category":"page"},{"location":"physics/shallow_water_model/","page":"Shallow water model","title":"Shallow water model","text":"beginalign\n  partial_t boldsymbolu + (zeta boldsymbolhat z + boldsymbolf)  timesboldsymbolu  = \n  - boldsymbolnabla left  g (h +b) + frac12 boldsymbolu cdot boldsymbolu right    \n  partial_t h + boldsymbolnabla boldsymbolcdot (boldsymbolu h)  = 0  \nendalign","category":"page"},{"location":"physics/shallow_water_model/","page":"Shallow water model","title":"Shallow water model","text":"where zeta(x y t) =  partial_x v - partial_y u is the vertical component of the relative vorticity.","category":"page"},{"location":"physics/shallow_water_model/","page":"Shallow water model","title":"Shallow water model","text":"The elevation of the bottom bathymetry, measured with respect to the free-surface at rest, is b(x y). The free-surface elevation eta is then:","category":"page"},{"location":"physics/shallow_water_model/","page":"Shallow water model","title":"Shallow water model","text":"eta(x y t) = h(x y t) + b(x y)  ","category":"page"},{"location":"physics/shallow_water_model/","page":"Shallow water model","title":"Shallow water model","text":"The ConservativeFormulation() uses the volume transport along each direction boldsymbolu h = (u h v h) and the total depth of the fluid h as the dynamical variables.  The shallow water dynamics in conservative form is:","category":"page"},{"location":"physics/shallow_water_model/","page":"Shallow water model","title":"Shallow water model","text":"beginalign\n  partial_t (boldsymbolu h) + boldsymbolnabla boldsymbolcdot left ( boldsymbolu boldsymbolu h right ) + boldsymbolf times (boldsymbolu h)  = - g h boldsymbolnabla left ( h + b right )  \n  partial_t h + boldsymbolnabla boldsymbolcdot (boldsymbolu h)  = 0  \nendalign","category":"page"},{"location":"physics/shallow_water_model/","page":"Shallow water model","title":"Shallow water model","text":"where boldsymbolnabla boldsymbolcdot left ( boldsymbolu boldsymbolu h right ) denotes a vector whose components are boldsymbolnabla boldsymbolcdot (boldsymbolu boldsymbolu h)_i = boldsymbolnabla boldsymbolcdot (u_i boldsymbolu h). We can retrieve the flow velocities by dividing the corresponding transport by the fluid's height, e.g., v = vh / h.","category":"page"},{"location":"model_setup/background_fields/#Background-fields","page":"Background fields","title":"Background fields","text":"","category":"section"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"BackgroundFields are velocity and tracer fields around which the resolved velocity and tracer fields evolve. Only the advective terms associated with the interaction between background and resolved fields are included. For example, tracer advection is described by","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"boldsymbolnabla boldsymbolcdot left ( boldsymbolv c right )  ","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"where boldsymbolv is the resolved velocity field and c is the resolved tracer field corresponding to model.tracers.c. ","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"When a background field C is provided, the tracer advection term becomes","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"boldsymbolnabla boldsymbolcdot left ( boldsymbolv c right ) \n    + boldsymbolnabla boldsymbolcdot left ( boldsymbolv C right )  ","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"When both a background field velocity field boldsymbolU and a background tracer field C are provided, then the tracer advection term becomes","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"boldsymbolnabla boldsymbolcdot left ( boldsymbolv c right ) \n    + boldsymbolnabla boldsymbolcdot left ( boldsymbolv C right )\n    + boldsymbolnabla boldsymbolcdot left ( boldsymbolU c right )  ","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"Notice that the term boldsymbolnabla boldsymbolcdot left ( boldsymbolU C right )  is neglected: only the terms describing the advection of resolved tracer by the background  velocity field and the advection of background tracer by the resolved velocity field are included. An analogous statement holds for the advection of background momentum by the resolved velocity field. Other possible terms associated with the Coriolis force, buoyancy, turbulence closures, and surface waves acting on background fields are neglected.","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"compat: Model compatibility\nBackgroundFields are only supported by NonhydrostaticModel.","category":"page"},{"location":"model_setup/background_fields/#Specifying-background-fields","page":"Background fields","title":"Specifying background fields","text":"","category":"section"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"BackgroundFields are defined by functions of (x y z t) and optional parameters. A  simple example is","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"using Oceananigans\n\nU(x, y, z, t) = 0.2 * z\n\ngrid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))\n\nmodel = NonhydrostaticModel(grid = grid, background_fields = (u=U,))\n\nmodel.background_fields.velocities.u\n\n# output\nFunctionField located at (Face, Center, Center)\n├── func: U (generic function with 1 method)\n├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo\n├── clock: Clock{Float64, Float64}(time=0 seconds, iteration=0, last_Δt=Inf days)\n└── parameters: nothing","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"BackgroundFields are specified by passing them to the kwarg background_fields in the NonhydrostaticModel constructor. The kwarg background_fields expects a NamedTuple of fields, which are internally sorted into velocities and tracers, wrapped in FunctionFields, and assigned their appropriate locations.","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"BackgroundFields with parameters require using the BackgroundField wrapper:","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"using Oceananigans\n\nparameters = (α=3.14, N=1.0, f=0.1)\n\n# Background fields are defined via function of x, y, z, t, and optional parameters\nU(x, y, z, t, α) = α * z\nB(x, y, z, t, p) = - p.α * p.f * y + p.N^2 * z \n\nU_field = BackgroundField(U, parameters=parameters.α)\nB_field = BackgroundField(B, parameters=parameters)\n\n# output\nBackgroundField{typeof(B), @NamedTuple{α::Float64, N::Float64, f::Float64}}\n├── func: B (generic function with 1 method)\n└── parameters: (α = 3.14, N = 1.0, f = 0.1)","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"When inserted into NonhydrostaticModel, we get","category":"page"},{"location":"model_setup/background_fields/","page":"Background fields","title":"Background fields","text":"grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))\n\nmodel = NonhydrostaticModel(grid = grid, background_fields = (u=U_field, b=B_field),\n                            tracers=:b, buoyancy=BuoyancyTracer())\n\nmodel.background_fields.tracers.b\n\n# output\nFunctionField located at (Center, Center, Center)\n├── func: B (generic function with 1 method)\n├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo\n├── clock: Clock{Float64, Float64}(time=0 seconds, iteration=0, last_Δt=Inf days)\n└── parameters: (α = 3.14, N = 1.0, f = 0.1)","category":"page"},{"location":"model_setup/callbacks/#Callbacks","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"A Callback can be used to execute an arbitrary user-defined function on the simulation at user-defined times.","category":"page"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"For example, we can specify a callback which displays the run time every 2 iterations:","category":"page"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"DocTestSetup = quote\n    using Oceananigans\nend","category":"page"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"using Oceananigans\n\nmodel = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)))\n\nsimulation = Simulation(model, Δt=1, stop_iteration=10)\n\nshow_time(sim) = @info \"Time is $(prettytime(sim.model.clock.time))\"\n\nsimulation.callbacks[:total_A] = Callback(show_time, IterationInterval(2))\n\nsimulation","category":"page"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"Now when simulation runs the simulation the callback is called.","category":"page"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"run!(simulation)","category":"page"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"We can also use the convenience add_callback!:","category":"page"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"add_callback!(simulation, show_time, name=:total_A_via_convenience, IterationInterval(2))\n\nsimulation","category":"page"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"The keyword argument callsite determines the moment at which the callback is executed. By default, callsite = TimeStepCallsite(), indicating execution after the completion of a timestep. The other options are callsite = TendencyCallsite() that executes the callback after the tendencies are computed but before taking a timestep and callsite = UpdateStateCallsite() that executes the callback within update_state!, after auxiliary variables have been computed (for multi-stage time-steppers, update_state! may be called multiple times per timestep).","category":"page"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"As an example of a callback with callsite = TendencyCallsite() , we show below how we can manually add to the tendency field of one of the velocity components. Here we've chosen the :u field using parameters:","category":"page"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"using Oceananigans\n\nmodel = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)))\n\nsimulation = Simulation(model, Δt=1, stop_iteration=10)\n\nfunction modify_tendency!(model, params)\n    model.timestepper.Gⁿ[params.c] .+= params.δ\n    return nothing\nend\n\nsimulation.callbacks[:modify_u] = Callback(modify_tendency!, IterationInterval(1),\n                                           callsite = TendencyCallsite(),\n                                           parameters = (c = :u, δ = 1))\n\nrun!(simulation)","category":"page"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"Above there is no forcing at all, but due to the callback the u-velocity is increased.","category":"page"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"@info model.velocities.u","category":"page"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"note: Example only for illustration purposes\nThe above is a redundant example since it could be implemented better with a simple forcing function. We include it here though for illustration purposes of how one can use callbacks.","category":"page"},{"location":"model_setup/callbacks/#Functions","page":"Callbacks","title":"Functions","text":"","category":"section"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"Callback functions can only take one or two parameters sim - a simulation, or model for state callbacks, and optionally may also accept a NamedTuple of parameters.","category":"page"},{"location":"model_setup/callbacks/#Scheduling","page":"Callbacks","title":"Scheduling","text":"","category":"section"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"The time that callbacks are called at are specified by schedule functions which can be:","category":"page"},{"location":"model_setup/callbacks/","page":"Callbacks","title":"Callbacks","text":"IterationInterval : runs every n iterations\nTimeInterval : runs every ns of model run time\nSpecifiedTimes : runs at the specified times\nWallTimeInterval : runs every ns of wall time","category":"page"},{"location":"physics/coriolis_forces/#Coriolis-forces","page":"Coriolis forces","title":"Coriolis forces","text":"","category":"section"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"The Coriolis model controls the manifestation of the term boldsymbolf times boldsymbolv in the momentum equation.","category":"page"},{"location":"physics/coriolis_forces/#f-plane-approximation","page":"Coriolis forces","title":"f-plane approximation","text":"","category":"section"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"Under an f-plane approximation[3] the reference frame in which the momentum and tracer equations are solved rotates at a constant rate.","category":"page"},{"location":"physics/coriolis_forces/#The-traditional-f-plane-approximation","page":"Coriolis forces","title":"The traditional f-plane approximation","text":"","category":"section"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"In the traditional f-plane approximation, the coordinate system rotates around a vertical axis such that","category":"page"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"    boldsymbolf = f boldsymbolhat z  ","category":"page"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"where f is constant and determined by the user.","category":"page"},{"location":"physics/coriolis_forces/#The-arbitrary-axis-constant-Coriolis-approximation","page":"Coriolis forces","title":"The arbitrary-axis constant-Coriolis approximation","text":"","category":"section"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"In this approximation, the coordinate system rotates around an axis in the xyz-plane, such that","category":"page"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"    boldsymbolf = f_x boldsymbolhat x + f_y boldsymbolhat y + f_z boldsymbolhat z  ","category":"page"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"where f_x, f_y, and f_z are constants determined by the user.","category":"page"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"[3]: The f-plane approximation is used to model the effects of Earth's rotation on anisotropic    fluid motion in a plane tangent to the Earth's surface. In this case, the projection of    the Earth's rotation vector at latitude varphi and onto a coordinate system in which    x y z correspond to the directions east, north, and up is   boldsymbolf approx frac4 pitextday left ( cos varphi boldsymbolhat y + sin varphi boldsymbolhat z right )     where the Earth's rotation rate is approximately 2 pi  textday. The traditional    f-plane approximation neglects the y-component of this projection, which is appropriate    for fluid motions with large horizontal-to-vertical aspect ratios.","category":"page"},{"location":"physics/coriolis_forces/#\\beta-plane-approximation","page":"Coriolis forces","title":"beta-plane approximation","text":"","category":"section"},{"location":"physics/coriolis_forces/#The-traditional-\\beta-plane-approximation","page":"Coriolis forces","title":"The traditional beta-plane approximation","text":"","category":"section"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"Under the traditional beta-plane approximation, the rotation axis is vertical as for the f-plane approximation, but f is expanded in a Taylor series around a central latitude  such that","category":"page"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"    boldsymbolf = left ( f_0 + beta y right ) boldsymbolhat z  ","category":"page"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"where f_0 is the planetary vorticity at some central latitude, and beta is the planetary vorticity gradient. The beta-plane model is not periodic in y and thus can be used only in domains that are bounded in the y-direction.","category":"page"},{"location":"physics/coriolis_forces/#The-non-traditional-\\beta-plane-approximation","page":"Coriolis forces","title":"The non-traditional beta-plane approximation","text":"","category":"section"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"The non-traditional beta-plane approximation accounts for the latitudinal variation of both the locally vertical and the locally horizontal components of the rotation vector","category":"page"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"    boldsymbolf = left 2Omegacosvarphi_0 left( 1 -  fraczR right) + gamma y right boldsymbolhat y\n           + left 2Omegasinvarphi_0 left( 1 + 2fraczR right) + beta  y right boldsymbolhat z  ","category":"page"},{"location":"physics/coriolis_forces/","page":"Coriolis forces","title":"Coriolis forces","text":"as can be found in the paper by Dellar (2011), where beta = 2 Omega cos varphi_0  R and gamma = -4 Omega sin varphi_0  R.","category":"page"},{"location":"model_setup/coriolis/#Coriolis","page":"Coriolis (rotation)","title":"Coriolis","text":"","category":"section"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"The Coriolis option determines whether the fluid experiences the effect of the Coriolis force, or rotation. Currently three options are available: no rotation, f-plane, and beta-plane.","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"info: Coriolis vs. rotation\nIf you are wondering why this option is called \"Coriolis\" it is because rotational effects could include the Coriolis and centripetal forces, both of which arise in non-inertial reference frames. But here the model only considers the Coriolis force.","category":"page"},{"location":"model_setup/coriolis/#No-rotation","page":"Coriolis (rotation)","title":"No rotation","text":"","category":"section"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"By default there is no rotation. This can be made explicit by passing coriolis = nothing to a model constructor.","category":"page"},{"location":"model_setup/coriolis/#Traditional-f-plane","page":"Coriolis (rotation)","title":"Traditional f-plane","text":"","category":"section"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"To set up an f-plane with, for example, Coriolis parameter f = 10^-4 texts^-1","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"DocTestSetup = quote\n    using Oceananigans\nend","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"julia> coriolis = FPlane(f=1e-4)\nFPlane{Float64}(f=0.0001)","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"An f-plane can also be specified at some latitude on a spherical planet with a planetary rotation rate. For example, to specify an f-plane at a latitude of varphi = 45textN on Earth which has a rotation rate of Omega = 7292115 times 10^-5 texts^-1","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"julia> coriolis = FPlane(rotation_rate=7.292115e-5, latitude=45)\nFPlane{Float64}(f=0.000103126)","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"in which case the value of f is given by 2Omegasinvarphi.","category":"page"},{"location":"model_setup/coriolis/#Coriolis-term-for-constant-rotation-in-a-Cartesian-coordinate-system","page":"Coriolis (rotation)","title":"Coriolis term for constant rotation in a Cartesian coordinate system","text":"","category":"section"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"One can use ConstantCartesianCoriolis to set up a Coriolis acceleration term where the Coriolis parameter is constant and the rotation axis is arbitrary. For example, with boldsymbolf = (0 f_y f_z) = (0 2 1) times 10^-4 texts^-1,","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"julia> coriolis = ConstantCartesianCoriolis(fx=0, fy=2e-4, fz=1e-4)\nConstantCartesianCoriolis{Float64}: fx = 0.00e+00, fy = 2.00e-04, fz = 1.00e-04","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"Or alternatively, the same result can be achieved by specifying the magnitude of the Coriolis frequency f and the rotation_axis. So another way to get a Coriolis acceleration with the same values is:","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"julia> rotation_axis = (0, 2e-4, 1e-4)./√(2e-4^2 + 1e-4^2) # rotation_axis has to be a unit vector\n(0.0, 0.8944271909999159, 0.4472135954999579)\n\njulia> coriolis = ConstantCartesianCoriolis(f=√(2e-4^2+1e-4^2), rotation_axis=rotation_axis)\nConstantCartesianCoriolis{Float64}: fx = 0.00e+00, fy = 2.00e-04, fz = 1.00e-04","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"An f-plane with non-traditional Coriolis terms can also be specified at some latitude on a spherical planet with a planetary rotation rate. For example, to specify an f-plane at a latitude of varphi = 45textN on Earth which has a rotation rate of Omega = 7292115 times 10^-5 texts^-1","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"julia> coriolis = ConstantCartesianCoriolis(rotation_rate=7.292115e-5, latitude=45)\nConstantCartesianCoriolis{Float64}: fx = 0.00e+00, fy = 1.03e-04, fz = 1.03e-04","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"in which case f_z = 2Omegasinvarphi and f_y = 2Omegacosvarphi.","category":"page"},{"location":"model_setup/coriolis/#Traditional-\\beta-plane","page":"Coriolis (rotation)","title":"Traditional beta-plane","text":"","category":"section"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"To set up a beta-plane the background rotation rate f_0 and the beta parameter must be specified. For example, a beta-plane with f_0 = 10^-4 texts^-1 and beta = 15 times 10^-11 texts^-1textm^-1 can be set up with","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"julia> coriolis = BetaPlane(f₀=1e-4, β=1.5e-11)\nBetaPlane{Float64}(f₀=0.0001, β=1.5e-11)","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"Alternatively, a beta-plane can also be set up at some latitude on a spherical planet with a planetary rotation rate and planetary radius. For example, to specify a beta-plane at a latitude of varphi = 10^circS on Earth which has a rotation rate of Omega = 7292115 times 10^-5 texts^-1 and a radius of R = 6371 textkm","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"julia> coriolis = BetaPlane(rotation_rate=7.292115e-5, latitude=-10, radius=6371e3)\nBetaPlane{Float64}(f₀=-2.53252e-5, β=2.25438e-11)","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"in which case f_0 = 2Omegasinvarphi and beta = 2Omegacosvarphi  R.","category":"page"},{"location":"model_setup/coriolis/#Non-traditional-\\beta-plane","page":"Coriolis (rotation)","title":"Non-traditional beta-plane","text":"","category":"section"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"A non-traditional beta-plane requires either 5 parameters (by default Earth's radius and rotation rate are used):","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"julia> NonTraditionalBetaPlane(fz=1e-4, fy=2e-4, β=4e-11, γ=-8e-11)\nNonTraditionalBetaPlane{Float64}(fz = 1.00e-04, fy = 2.00e-04, β = 4.00e-11, γ = -8.00e-11, R = 6.37e+06)","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"or the rotation rate, radius, and latitude:","category":"page"},{"location":"model_setup/coriolis/","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"julia> NonTraditionalBetaPlane(rotation_rate=5.31e-5, radius=252.1e3, latitude=10)\nNonTraditionalBetaPlane{Float64}(fz = 1.84e-05, fy = 1.05e-04, β = 4.15e-10, γ = -1.46e-10, R = 2.52e+05)","category":"page"},{"location":"numerical_implementation/boundary_conditions/#numerical_bcs","page":"Boundary conditions","title":"Numerical implementation of boundary conditions","text":"","category":"section"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"We adopt a mixed approach for implementing boundary conditions that uses both halo regions and \"direct\" imposition of boundary conditions, depending on the condition prescribed.","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"We illustrate how boundary conditions are implemented by considering the tracer equation","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"    beginalign\n    partial_t c = - boldsymbolv boldsymbolcdot boldsymbolnabla c\n                   - boldsymbolnabla boldsymbolcdot boldsymbolq_c\n                   + F_c  \n    labeleqtracer\n    endalign","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"where boldsymbolq_c is the diffusive flux of c and F_c is an arbitrary source term.","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"See Model setup: boundary conditions for how to create and use these boundary conditions in Oceananigans.","category":"page"},{"location":"numerical_implementation/boundary_conditions/#Gradient-boundary-conditions","page":"Boundary conditions","title":"Gradient boundary conditions","text":"","category":"section"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Users impose gradient boundary conditions by prescribing the gradient gamma of a field  c across an external boundary partial Omega_b. The prescribed gradient gamma  may be a constant, discrete array of values, or an arbitrary function. The gradient boundary  condition is enforced setting the value of halo points located outside the domain interior  such that","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"    beginequation\n    labeleqgradient-bc\n    hatboldsymboln boldsymbolcdot boldsymbolnabla c _partial Omega_b = gamma  \n    endequation","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"where hatboldsymboln is the vector normal to partial Omega_b.","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Across the bottom boundary in z, for example, this requires that","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"    beginequation\n    labeleqlinear-extrapolation\n    c_i j 0 = c_i j 1 + gamma_i j 1 tfrac12 left ( Delta z_i j 1 + Delta z_i j 0 right )  \n    endequation","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"where Delta z_i j 1 = Delta z_i j 0 are the heights of the finite volume at i j and k=1 and k=0. This prescription implies that the z-derivative of c across the boundary at k=1 is","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"    beginequation\n    partial_z c  _i j 1 equiv\n        fracc_i j 1 - c_i j 0tfrac12 left ( Delta z_i j 1 + Delta z_i j 0 right )\n            = gamma_i j 1  \n    endequation","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"as prescribed by the user.","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Gradient boundary conditions are represented by the Gradient type.","category":"page"},{"location":"numerical_implementation/boundary_conditions/#Value-boundary-conditions","page":"Boundary conditions","title":"Value boundary conditions","text":"","category":"section"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Users impose value boundary conditions by prescribing c^b, the value of c on the external boundary partial Omega_b. The value c^b may be a constant, array of discrete values, or an arbitrary function. To enforce a value boundary condition, the gradient associated with the difference between c^b and c at boundary-adjacent nodes is diagnosed and used to set the value of the c halo point located outside the boundary.","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"At the bottom boundary in z, for example, this means that the gradient of c is determined by","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"    beginequation\n    gamma = fracc_i j 1 - c^b_i j 1tfrac12 Delta z_i j 1  \n    endequation","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"which is then used to set the halo point c_i j 0 via linear extrapolation.","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Value boundary conditions are represented by the Value type.","category":"page"},{"location":"numerical_implementation/boundary_conditions/#Flux-boundary-conditions","page":"Boundary conditions","title":"Flux boundary conditions","text":"","category":"section"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Users impose flux boundary conditions by prescribing the flux q_c  _b of c across the external boundary partial Omega_b. The flux q_c  _b may be a constant, array  of discrete values, or arbitrary function. To explain how flux boundary conditions are imposed  in Oceananigans.jl, we note that the average of the tracer conservation equation over a finite  volume yields","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"    beginequation\n    labeleqdcdt\n    partial_t c_i j k = - frac1V_i j k oint_partial Omega_i j k (boldsymbolv c + boldsymbolq_c) \n                                                     boldsymbolcdot hatboldsymboln   mathrmd S\n                             + frac1V_i j k int_V_i j k F_c  mathrmd V  \n    endequation","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"where the surface integral over partial Omega_i j k averages the flux of c across  the six faces of the finite volume. The right-hand-side of \\eqref{eq:dc/dt} above is denoted as  G_c _i j k.","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"An external boundary of a finite volume is associated with a no-penetration condition such that hatboldsymboln boldsymbolcdot boldsymbolv  _partial Omega_b = 0, where  hatboldsymboln is the vector normal to partial Omega_b. Furthermore, the closures  currently available in Oceananigans.jl have the property that boldsymbolq_c propto boldsymbolnabla c. Thus setting hatboldsymboln boldsymbolcdot boldsymbolnabla c  _partial Omega_b = 0  on the external boundary implies that the total flux of c across the external boundary is","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"    beginequation\n    hatboldsymboln boldsymbolcdot left ( boldsymbolv c + boldsymbolq_c right ) _partial Omega_b = 0  \n    endequation","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Oceananigans.jl exploits this fact to define algorithm that prescribe fluxes across external  boundaries partial Omega_b:","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Impose a constant gradient hatboldsymboln boldsymbolcdot boldsymbolnabla c   _partial Omega_b = 0 across external boundaries via using halo points (similar  to \\eqref{eq:gradient-bc}), which ensures that the evaluation of G_c in boundary-adjacent cells does not include fluxes across the external boundary, and;\nAdd the prescribed flux to the boundary-adjacent volumes prior to calculating G_c:  G_c  _b = G_c  _b - fracA_bV_b q_c  _b  textsign(hatboldsymboln),  where G_c  _b denotes values of G_c in boundary-adjacent volumes, q_c  _b  is the flux prescribed along the boundary, V_b is the volume of the boundary-adjacent  cell, and A_b is the area of the external boundary of the boundary-adjacent cell.\nThe factor textsign(hatboldsymboln) is -1 and +1 on \"left\" and \"right\"  boundaries, and accounts for the fact that a positive flux on a left boundary where  textsign(hatboldsymboln) = -1 implies an \"inward\" flux of c that increases  interior values of c, whereas a positive flux on a right boundary where  textsign(hatboldsymboln) = 1 implies an \"outward\" flux that decreases interior values of c.","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Flux boundary conditions are represented by the Flux type.","category":"page"},{"location":"numerical_implementation/boundary_conditions/#Open-boundary-conditions","page":"Boundary conditions","title":"Open boundary conditions","text":"","category":"section"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Open boundary conditions directly specify the value of the halo points. Typically this is used to impose no penetration boundary conditions, i.e. setting wall normal velocity components on  to zero on the boundary. ","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"The nuance here is that open boundaries behave differently for fields on face points in the  boundary direction due to the staggered grid. For example, the u-component of velocity lies on (Face, Center, Center) points so for open west or east boundaries the  point specified by the boundary condition is the point lying on the boundary, where as for a  tracer on (Center, Center, Center) points the open boundary condition specifies a point outside of the domain (hence the difference with Value boundary conditions).","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"The other important detail is that open (including no-penetration) boundary conditions are the  only conditions used on wall normal velocities when the domain is not periodic. This means that  their value affects the pressure calculation for nonhydrostatic models as it is involved in  calculating the divergence in the boundary adjacent center point (as described in the  fractional step method documentation). Usually boundary points are filled for the predictor velocity (i.e. before the pressure is calculated), and on the corrected field (i.e. after the pressure correction is applied), but for open boundaries this would result in the boundary adjacent center point becoming divergent so open boundaries are only filled for the  predictor velocity and stay the same after the pressure correction (so the boundary point is filled with the final corrected velocity at the predictor step).","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"The restriction arrises as the boundary condition is specifying the wall normal velocity,  hatboldsymbolncdotboldsymbolu, which leads to the pressure boundary condition","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"    beginequation\n    labeleqpressure_boundary_condition\n    Delta t  hatboldsymbolncdotboldsymbolnablap^n+1big _partialOmega = leftDelta t  hatboldsymbolncdotboldsymbolu^star - hatboldsymbolncdotboldsymbolu^n+1right\n    endequation","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"implying that there is a pressure gradient across the boundary. Since we solve the pressure poisson  equation (nabla^2p^n+1=fracboldsymbolnablacdotboldsymbolu^starDelta t) using the method described by Schumann and Sweet (1988) we have to move inhomogeneus boundary conditions on the pressure to the right hand side. In order to do this we define a new field phi where","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"    beginequation\n    labeleqmodified_pressure_field\n    phi = p^n+1 quad textinside quad Omega quad textbut quad boldsymbolnabla cdot boldsymbolnabla phi  big _partialOmega = 0\n    endequation","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"This moves the boundary condition to the right hand side as phi becomes","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"    beginequation\n    labeleqmodified_pressure_poisson\n    boldsymbolnabla^2phi^n+1 = boldsymbolnablacdotleftfracboldsymbolu^starDelta t - deltaleft(boldsymbolx - boldsymbolx_Omegaright)boldsymbolnablapright\n    endequation","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Given the boundary condition on pressure given above, we can define a new modified predictor velocity which is equal to the predictor velocity within the domain but shares boundary conditions with the  corrected field,","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"    beginequation\n    labeleqquasi_predictor_velocity\n    tildeboldsymbolu^star=boldsymbolu^star + deltaleft(boldsymbolx - boldsymbolx_Omegaright)(boldsymbolu^n+1 - boldsymbolu^star)\n    endequation","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"The modified pressure poisson equation becomes nabla^2p^n+1=fracboldsymbolnablacdottildeboldsymbolu^starDelta t which can easily be solved. ","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Perhaps a more intuitive way to consider this is to recall that the corrector step projects boldsymbolu^star to the space of divergenece free velocity by applying","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"    beginequation\n    labeleqpressure_correction_step\n    boldsymbolu^n+1 = boldsymbolu^star - Delta tboldsymbolnablap^n+1\n    endequation","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"but we have changed p^n+1 to phi and boldsymbolu^star to tildeboldsymbolu^star so for boldsymbolnablaphi big _partialOmega = 0 the modified predictor velocity must equal the corrected velocity on the boundary.","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"For simple open boundary conditions such as no penetration or a straight forward prescription of a known velocity at t^n+1 this is simple to implement as we just set the boundary condition on the predictor velocity and don't change it after the correction. But some open boundary methods calculate the boundary value based on the interior solution. As a simple example, if we wanted to  set the wall normal veloicty gradient to zero at the west boundary then we would set the boundary  point to","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"    beginequation\n    labeleqzero_wall_normal_velocity_gradient\n    u^star_1jk approx u^star_3jk + (u^star_2jk - u^star_jk4)  2 + mathcalO(Delta x^2)\n    endequation","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"but we then pressure correct the interior so a new mathcalO(Delta t) error is introduced as","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"    beginequation\n    beginalign\n    u^n+1_1jk approx u^n+1_3jk + (u^n+1_2jk - u^n+1_jk4)  2 + mathcalO(Delta x^2)\n    = u^star_1jk - Delta t left(boldsymbolnablap^n+1_3jk + (boldsymbolnablap^n+1_2jk - boldsymbolnablap^n+1_4jk)  2right) + mathcalO(Delta x^2)\n    approx u^star_1jk + mathcalO(Delta x^2) + mathcalO(Delta t)\n    endalign\n    endequation","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"This is prefered to a divergent interior solution as open boundary conditions (except no penetration) are typlically already unphysical and only used in an attempt to allow information to enter or exit the domain.","category":"page"},{"location":"numerical_implementation/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Open boundary conditions are represented by the Open type.","category":"page"},{"location":"numerical_implementation/pressure_decomposition/#pressure_decomposition","page":"Pressure decomposition","title":"Pressure decomposition","text":"","category":"section"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"In the numerical implementation of the momentum equations in the NonhydrostaticModel, the kinematic pressure p is split into \"background\" and \"dynamic\" parts via","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"    beginequation\n    labeleqpressure\n    p(boldsymbolx t) = p_textbackground(boldsymbolx t) + p(boldsymbolx t)  \n    endequation","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"The background pressure component in \\eqref{eq:pressure} is defined so that the vertical component of its gradient balances the background density field:","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"    beginalign\n    partial_z p_texttotal hydrostatic  = - g left ( 1 + fracrho_*rho_0 right )  \n    endalign","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"Above, we use the notation introduced in the Boussinesq approximation section.","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"Optionally, we may further decompose the dynamic pressure perturbation p into a \"hydrostatic anomaly\" and \"nonhydrostatic\" part:","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"    beginalign\n    p(boldsymbolx t) = p_rmhyd(boldsymbol(x) t) + p_rmnon(boldsymbolx t)  \n    endalign","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"where","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"    beginalign\n    partial_z p_rmhyd equiv underbrace- g fracrhorho_0_= b  \n    endalign","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"With this pressure decomposition, the kinematic pressure gradient that appears in the momentum equations (after we've employed the the Boussinesq approximation) becomes","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"    beginalign\n    boldsymbolnabla p = - g fracrhorho_0 hat boldsymbolz + boldsymbolnabla p\n                          = - g fracrhorho_0 hat boldsymbolz + boldsymbolnabla p_rmnon + boldsymbolnabla_h p_rmhyd  \n    endalign","category":"page"},{"location":"numerical_implementation/pressure_decomposition/","page":"Pressure decomposition","title":"Pressure decomposition","text":"where boldsymbolnabla_h equiv boldsymbolhat x partial_x +  boldsymbolhat y partial_y.","category":"page"}]
}

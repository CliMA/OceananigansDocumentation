var documenterSearchIndex = {"docs":
[{"location":"numerical_implementation/time_stepping/#Time-stepping-and-the-fractional-step-method-1","page":"Time stepping","title":"Time-stepping and the fractional step method","text":"","category":"section"},{"location":"numerical_implementation/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"The time-integral of the momentum equation with the pressure decomposition from time step n at t = t_n  to time step n+1 at t_n+1 is","category":"page"},{"location":"numerical_implementation/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"    tageqmomentum-time-integral\n    bmu^n+1 - bmu^n = \n        int_t_n^t_n+1 Big  - bmnabla phi_rmnon \n                                    - bmnabla_ h phi_rmhyd \n                                    - left ( bmu bmcdot bmnabla right ) bmu \n                                    - bmf times bmu \n                                    + bmnabla bmcdot bmtau \n                                    + bmF_bmu Big   rmd t  ","category":"page"},{"location":"numerical_implementation/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"where the superscript n and n+1 imply evaluation at t_n and t_n+1,  such that bmu^n equiv bmu(t=t_n). The crux of the fractional step method is to treat the pressure term  bmnabla phi_rmnon implicitly using the approximation","category":"page"},{"location":"numerical_implementation/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"int_t_n^t_n+1 bmnabla phi_rmnon  rmd t approx \n    Delta t bmnabla phi_rmnon^n+1  ","category":"page"},{"location":"numerical_implementation/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"while treating the rest of the terms on the right hand side of \\eqref{eq:momentum-time-integral} explicitly. The implicit treatment of pressure ensures that the velocity field obtained at time step n+1 is divergence-free.","category":"page"},{"location":"numerical_implementation/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"To effect such a fractional step method, we define an intermediate velocity field bmu^star such that","category":"page"},{"location":"numerical_implementation/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"    tageqintermediate-velocity-field\n    bmu^star - bmu^n = int_t_n^t_n+1 bmG_bmu  rmd t  ","category":"page"},{"location":"numerical_implementation/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"where","category":"page"},{"location":"numerical_implementation/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"bmG_bmu equiv - bmnabla_h phi_rmhyd \n                       - left ( bmu bmcdot bmnabla right ) bmu \n                       - bmf times bmu \n                       + bmnabla bmcdot bmtau \n                       + bmF_bmu","category":"page"},{"location":"numerical_implementation/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"collects all terms on the right side of the time-integral of the momentum equation except the contribution  of non-hydrostatic pressure bmnabla phi_n. The integral on the right of the equation for bmu^star may be approximated by a variety of  explicit methods: for example, a forward Euler method uses","category":"page"},{"location":"numerical_implementation/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"    int_t_n^t_n+1 G  rmd t approx Delta t G^n  \n    tageqforward-euler","category":"page"},{"location":"numerical_implementation/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"for any time-dependent function G(t), while a second-order Adams-Bashforth method uses the approximation","category":"page"},{"location":"numerical_implementation/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"    tageqadams-bashforth\n    int_t_n^t_n+1 G  rmd t approx \n        Delta t left  left ( tfrac32 + chi right ) G^n \n        - left ( tfrac12 + chi right ) G^n-1 right   ","category":"page"},{"location":"numerical_implementation/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"where chi is a parameter. Ascher et al. (1995) claim that chi = tfrac18 is optimal;  chi=-tfrac12 yields the forward Euler scheme.","category":"page"},{"location":"numerical_implementation/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"Combining the equations for bmu^star and the time integral of the momentum equation yields","category":"page"},{"location":"numerical_implementation/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"    tageqfractional-step\n    bmu^n+1 - bmu^star = - Delta t bmnabla phi_rmnon^n+1  rmd t  ","category":"page"},{"location":"numerical_implementation/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"Taking the divergence of fractional step equation and requiring that  bmnabla bmcdot bmu^n+1 = 0 yields a Poisson equation for the potential  phi_rmnon at time-step n+1:","category":"page"},{"location":"numerical_implementation/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"    bmnabla^2 phi_rmnon^n+1 = fracbmnabla bmcdot bmu^starDelta t  ","category":"page"},{"location":"numerical_implementation/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"With bmu^star and phi_rmnon, bmu^n+1 is then computed via the fractional step equation.","category":"page"},{"location":"numerical_implementation/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"Tracers are stepped forward explicitly via","category":"page"},{"location":"numerical_implementation/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"    tageqtracer-timestep\n    c^n+1 - c^n = int_t_n^t_n+1 G_c  rmd t  ","category":"page"},{"location":"numerical_implementation/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"where ","category":"page"},{"location":"numerical_implementation/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"    G_c equiv - bmnabla bmcdot left ( bmu c right ) - bmnabla bmcdot bmq_c + F_c  ","category":"page"},{"location":"numerical_implementation/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"and the same forward Euler or Adams-Bashforth scheme as for the explicit evaluation of the time-integral of bmG_u is used to evaluate the integral of G_c.","category":"page"},{"location":"numerical_implementation/turbulence_closures/#Turbulence-closures-1","page":"Turbulence closures","title":"Turbulence closures","text":"","category":"section"},{"location":"numerical_implementation/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"To truly simulate and resolve turbulence at high Reynolds number (so basically all interesting flows) would require you resolve all motions down to the \\citet{Kolmogorov41} length scale eta = (nu^3  varepsilon)^14 where nu is the kinematic viscosity and varepsilon the average rate of dissipation of turbulence kinetic energy per unit mass.","category":"page"},{"location":"numerical_implementation/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"As pointed out way back by \\citet{Corrsin61}, to run a simulation on a horizontal domain about 10 times the size of an \"average eddy\" with 100 vertical levels and where the grid spacing is given by eta would require the computer to store on the order of 10^14 variables.[1] This is still impractical today, although may be within reach in less than a decade. He ends by suggesting the use of an analog rather digital computer–-a tank of water.","category":"page"},{"location":"numerical_implementation/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"[1]: And even then, eta gives the maximum allowable grid spacing. There is significant flow structure smaller than eta.","category":"page"},{"location":"numerical_implementation/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"To have any hope of simulating high Reynolds number flows we need some way of resolving the sub-grid scale motions.[2]","category":"page"},{"location":"numerical_implementation/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"[2]: In reality there is no need to resolve all motions down to the Kolmogorov length scale to achieve acceptable accuracy. Perhaps good results can be achieved if 80\\% of the kinetic energy is resolved \\citep[\\S13]{Pope00}.","category":"page"},{"location":"numerical_implementation/turbulence_closures/#Reynolds-averaged-Navier–Stokes-equations-1","page":"Turbulence closures","title":"Reynolds-averaged Navier–Stokes equations","text":"","category":"section"},{"location":"numerical_implementation/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"Following \\citet{Reynolds1895} we can decompose flow variables such as velocity bmu into the mean component overlinebmu and the fluctuating component bmu^prime so that bmu = overlinebmu + bmu^prime [see \\citet[\\S4]{Pope00} for a modern discussion].","category":"page"},{"location":"numerical_implementation/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"Expressing the Navier-Stokes equations in tensor notation","category":"page"},{"location":"numerical_implementation/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"beginaligned\n    partial_i u_i = 0 \n    partial_t u_i + u_j partial_j u_i = f_i - alphapartial_i p + nu partial_j partial_j u_i\nendaligned","category":"page"},{"location":"numerical_implementation/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"where alpha = rho^-1 is the specific volume and f_i represents external forces. We can plug in the Reynolds decomposition for bmu and after some manipulation arrive at the following form for the Reynolds-averaged Navier-Stokes equations","category":"page"},{"location":"numerical_implementation/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"beginaligned\n    partial_i overlineu_i = 0 \n    partial_t overlineu_i + overlineu_j partial_j overlineu_i = overlinef_i -\n    partial_j left(-alphaoverlinepdelta_ij + 2nu overlineS_ij - overlineu_i^prime u_j^primeright)\nendaligned","category":"page"},{"location":"numerical_implementation/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"where","category":"page"},{"location":"numerical_implementation/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"overlineS_ij = frac12 ( partial_j overlineu_i + partial_i overlineu_j )","category":"page"},{"location":"numerical_implementation/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"is the mean rate of strain tensor.","category":"page"},{"location":"numerical_implementation/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"Thanks to the non-linearity of the Navier-Stokes equations, even when averaged we are left with pesky fluctuation terms which form the components of the Reynolds stress tensor","category":"page"},{"location":"numerical_implementation/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"tau_ij = rho overlineu_i^prime u_j^prime","category":"page"},{"location":"numerical_implementation/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"Attempting to close the equations leads to the closure problem: the time evolution of the Reynolds stresses depends on  triple covariances overlineu_i^prime u_j^prime u_k^prime and covariances with pressure, which depend on quadruple covariances and so on \\citep{Chou45}.","category":"page"},{"location":"numerical_implementation/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"This is kind of hopeless so we will have to find some way to model the Reynolds stresses.","category":"page"},{"location":"numerical_implementation/turbulence_closures/#Gradient-diffusion-hypothesis-and-eddy-viscosity-models-1","page":"Turbulence closures","title":"Gradient-diffusion hypothesis and eddy viscosity models","text":"","category":"section"},{"location":"numerical_implementation/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"The gradient-diffusion hypothesis, due to \\citet{Boussinesq1877}, assumes that the transport of scalar fluxes such as overlinebmu^prime c^prime and overlineu_i^prime u_j^prime occurs down the mean scalar gradient grad c as if they are being diffused \\citep[\\S4.4]{Pope00}. This is in analogy with how momentum transfer by molecular motion in a gas can be described by a molecular viscosity.","category":"page"},{"location":"numerical_implementation/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"Taking this assumption we can express the Reynolds stresses and turbulent tracer fluxes in terms of the mean variables and close the equations","category":"page"},{"location":"numerical_implementation/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"overlinebmu^prime c^prime = -kappa_e nabla overlinec\nquad textand quad\noverlineu_i^prime u_j^prime = -2nu_e overlineS_ij","category":"page"},{"location":"numerical_implementation/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"where nu_e = nu_e(bmx t) is the turbulent or eddy viscosity and kappa_e = kappa_e(bmx t) is the eddy diffusivity.","category":"page"},{"location":"numerical_implementation/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"The effective diffusivity ends up being the sum of the molecular and eddy diffusivities. So just by using an elevated value for the viscosity and diffusivity, you are already using an eddy viscosity model.","category":"page"},{"location":"numerical_implementation/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"The eddy viscosity model is simple and for that reason is very popular. It can work well even with a constant eddy diffusivity. However, it does assume that the flux is aligned down gradient, which is not true even in simple turbulent flows as the physics of turbulence is quite different from that of colliding molecules leading to the viscous stress law \\citep[\\S4.4,10.1]{Pope00}. So we might want something a little bit more sophisticated.","category":"page"},{"location":"generated/two_dimensional_turbulence/#","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"EditURL = \"https://github.com/climate-machine/Oceananigans.jl/blob/master/examples/two_dimensional_turbulence.jl\"","category":"page"},{"location":"generated/two_dimensional_turbulence/#Two-dimensional-turbulence-example-1","page":"Two-dimensional turbulence","title":"Two dimensional turbulence example","text":"","category":"section"},{"location":"generated/two_dimensional_turbulence/#","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"In this example, we initialize a random velocity field and observe its viscous, turbulent decay in a two-dimensional domain. This example demonstrates:","category":"page"},{"location":"generated/two_dimensional_turbulence/#","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"How to run a model with no buoyancy equation or tracers;\nHow to create user-defined fields\nHow to use differentiation functions","category":"page"},{"location":"generated/two_dimensional_turbulence/#Model-setup-1","page":"Two-dimensional turbulence","title":"Model setup","text":"","category":"section"},{"location":"generated/two_dimensional_turbulence/#","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"For this example, we need Plots for plotting and Statistics for setting up a random initial condition with zero mean velocity.","category":"page"},{"location":"generated/two_dimensional_turbulence/#","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"using Oceananigans, Oceananigans.AbstractOperations\nusing Plots, Statistics","category":"page"},{"location":"generated/two_dimensional_turbulence/#","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"In addition to importing plotting and statistics packages, we import some types from Oceananigans that will aid in the calculation and visualization of voriticty.","category":"page"},{"location":"generated/two_dimensional_turbulence/#","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"using Oceananigans: Face, Cell","category":"page"},{"location":"generated/two_dimensional_turbulence/#","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Face and Cell represent \"locations\" on the staggered grid. We instantiate the model with a simple isotropic diffusivity.","category":"page"},{"location":"generated/two_dimensional_turbulence/#","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"model = IncompressibleModel(\n        grid = RegularCartesianGrid(size=(128, 128, 1), length=(2π, 2π, 2π)),\n    buoyancy = nothing,\n     tracers = nothing,\n     closure = ConstantIsotropicDiffusivity(ν=1e-3, κ=1e-3)\n)\nnothing # hide","category":"page"},{"location":"generated/two_dimensional_turbulence/#Setting-initial-conditions-1","page":"Two-dimensional turbulence","title":"Setting initial conditions","text":"","category":"section"},{"location":"generated/two_dimensional_turbulence/#","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Our initial condition randomizes u and v. We also ensure that both have zero mean for purely aesthetic reasons.","category":"page"},{"location":"generated/two_dimensional_turbulence/#","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"u₀ = rand(size(model.grid)...)\nu₀ .-= mean(u₀)\n\nset!(model, u=u₀, v=u₀)","category":"page"},{"location":"generated/two_dimensional_turbulence/#Calculating-vorticity-1","page":"Two-dimensional turbulence","title":"Calculating vorticity","text":"","category":"section"},{"location":"generated/two_dimensional_turbulence/#","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Next we create an object called an Operation that represents a vorticity calculation. We'll use this object to calculate vorticity on-line as the simulation progresses.","category":"page"},{"location":"generated/two_dimensional_turbulence/#","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"u, v, w = model.velocities\nnothing # hide","category":"page"},{"location":"generated/two_dimensional_turbulence/#","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Create an object that represents the 'operation' required to compute vorticity.","category":"page"},{"location":"generated/two_dimensional_turbulence/#","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"vorticity_operation = ∂x(v) - ∂y(u)\nnothing # hide","category":"page"},{"location":"generated/two_dimensional_turbulence/#","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"The instance vorticity_operation is a binary subtraction between two derivative operations acting on OffsetArrays (the underyling representation of u, and v). In order to use vorticity_operation we create a field ω to store the result of the operation, and a Computation object for coordinate the computation of vorticity and storage in ω:","category":"page"},{"location":"generated/two_dimensional_turbulence/#","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"ω = Field(Face, Face, Cell, model.architecture, model.grid)\n\nvorticity_computation = Computation(vorticity_operation, ω)\nnothing # hide","category":"page"},{"location":"generated/two_dimensional_turbulence/#","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"We ask for computation of vorticity by writing compute!(vorticity_computation) as shown below.","category":"page"},{"location":"generated/two_dimensional_turbulence/#Visualizing-the-simulation-1","page":"Two-dimensional turbulence","title":"Visualizing the simulation","text":"","category":"section"},{"location":"generated/two_dimensional_turbulence/#","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Finally, we run the model and animate the vorticity field.","category":"page"},{"location":"generated/two_dimensional_turbulence/#","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"simulation = Simulation(model, Δt=0.1, stop_iteration=0)\n\nanim = @animate for i=1:100\n    simulation.stop_iteration += 10\n    run!(simulation)\n\n    compute!(vorticity_computation)\n\n    x, y = model.grid.xF, model.grid.yF\n    heatmap(x, y, interior(ω)[:, :, 1], xlabel=\"x\", ylabel=\"y\",\n            color=:balance, clims=(-0.1, 0.1))\nend\n\nmp4(anim, \"2d_turbulence_vorticity.mp4\", fps = 15) # hide","category":"page"},{"location":"generated/two_dimensional_turbulence/#","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"","category":"page"},{"location":"generated/two_dimensional_turbulence/#","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"This page was generated using Literate.jl.","category":"page"},{"location":"model_setup/output_writers/#Output-writers-1","page":"Output writers","title":"Output writers","text":"","category":"section"},{"location":"model_setup/output_writers/#","page":"Output writers","title":"Output writers","text":"Saving model data to disk can be done in a flexible manner using output writers. The two main output writers currently implemented are a NetCDF output writer (relying on NCDatasets.jl) and a JLD2 output writer (relying on JLD2.jl).","category":"page"},{"location":"model_setup/output_writers/#","page":"Output writers","title":"Output writers","text":"Output writers are stored as a list of output writers in simulation.output_writers. Output writers can be specified at model creation time or be specified at any later time and appended (or assigned with a key value pair) to simulation.output_writers.","category":"page"},{"location":"model_setup/output_writers/#NetCDF-output-writer-1","page":"Output writers","title":"NetCDF output writer","text":"","category":"section"},{"location":"model_setup/output_writers/#","page":"Output writers","title":"Output writers","text":"Model data can be saved to NetCDF files along with associated metadata. The NetCDF output writer is generally used by passing it a dictionary of (label, field) pairs and any indices for slicing if you don't want to save the full 3D field.","category":"page"},{"location":"model_setup/output_writers/#","page":"Output writers","title":"Output writers","text":"The following example shows how to construct NetCDF output writers for two different kinds of outputs (3D fields and slices) along with output attributes","category":"page"},{"location":"model_setup/output_writers/#","page":"Output writers","title":"Output writers","text":"Nx = Ny = Nz = 16\nmodel = Model(grid=RegularCartesianGrid(size=(Nx, Ny, Nz), length=(1, 1, 1)))\nsimulation = Simulation(model, Δt=12, stop_time=3600)\n\nfields = Dict(\n    \"u\" => model.velocities.u,\n    \"T\" => model.tracers.T\n)\n\noutput_attributes = Dict(\n    \"u\" => Dict(\"longname\" => \"Velocity in the x-direction\", \"units\" => \"m/s\"),\n    \"T\" => Dict(\"longname\" => \"Temperature\", \"units\" => \"C\")\n)\n\nsimulation.output_writers[:field_writer] =\n    NetCDFOutputWriter(model, fields; filename=\"output_fields.nc\",\n                       interval=6hour, output_attributes=output_attributes)\n\nsimulation.output_writers[:surface_slice_writer] =\n    NetCDFOutputWriter(model, fields; filename=\"output_surface_xy_slice.nc\",\n                       interval=5minute, output_attributes=output_attributes,\n                       zC=Nz, zF=Nz)","category":"page"},{"location":"model_setup/output_writers/#","page":"Output writers","title":"Output writers","text":"See NetCDFOutputWriter for more details and options.","category":"page"},{"location":"model_setup/output_writers/#JLD2-output-writer-1","page":"Output writers","title":"JLD2 output writer","text":"","category":"section"},{"location":"model_setup/output_writers/#","page":"Output writers","title":"Output writers","text":"JLD2 is a an HDF5 compatible file format written in pure Julia and is generally pretty fast. JLD2 files can be opened in Python with the h5py package.","category":"page"},{"location":"model_setup/output_writers/#","page":"Output writers","title":"Output writers","text":"The JLD2 output writer is generally used by passing it a dictionary or named tuple of (label, function) pairs where the functions have a single input model. Whenever output needs to be written, the functions will be called and the output of the function will be saved to the JLD2 file. For example, to write out 3D fields for w and T and a horizontal average of T every 1 hour of simulation time to a file called some_data.jld2","category":"page"},{"location":"model_setup/output_writers/#","page":"Output writers","title":"Output writers","text":"model = Model(grid=RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1)))\nsimulation = Simulation(model, Δt=12, stop_time=3600)\n\nfunction init_save_some_metadata(file, model)\n    file[\"author\"] = \"Chim Riggles\"\n    file[\"parameters/coriolis_parameter\"] = 1e-4\n    file[\"parameters/density\"] = 1027\nend\n\nT_avg =  HorizontalAverage(model.tracers.T)\n\noutputs = Dict(\n    :w => model -> model.velocities.u,\n    :T => model -> model.tracers.T,\n    :T_avg => model -> T_avg(model)\n)\n\njld2_writer = JLD2OutputWriter(model, outputs, init=init_save_some_metadata, interval=1hour, prefix=\"some_data\")\n\npush!(simulation.output_writers, jld2_writer)","category":"page"},{"location":"model_setup/output_writers/#","page":"Output writers","title":"Output writers","text":"See JLD2OutputWriter for more details and options.","category":"page"},{"location":"model_setup/clock/#Clock-1","page":"Clock","title":"Clock","text":"","category":"section"},{"location":"model_setup/clock/#","page":"Clock","title":"Clock","text":"The clock holds the current iteration number and time. By default the model starts at iteration number 0 and time 0","category":"page"},{"location":"model_setup/clock/#","page":"Clock","title":"Clock","text":"using Oceananigans # hide\nclock = Clock(0.0, 0)","category":"page"},{"location":"model_setup/clock/#","page":"Clock","title":"Clock","text":"but can be modified if you wish to start the model clock at some other time. If you want iteration 0 to correspond to t = 3600 seconds, then you can construct","category":"page"},{"location":"model_setup/clock/#","page":"Clock","title":"Clock","text":"using Oceananigans # hide\nclock = Clock(3600.0, 0)","category":"page"},{"location":"model_setup/clock/#","page":"Clock","title":"Clock","text":"and pass it to the model.","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#Turbulent-diffusivity-closures-and-large-eddy-simulation-models-1","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and large eddy simulation models","text":"","category":"section"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"A turbulent diffusivty closure representing the effects of viscous dissipation and diffusion can be passed via the closure keyword.","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"See turbulence closures and large eddy simulation for more details on turbulent diffusivity closures.","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#Constant-isotropic-diffusivity-1","page":"Turbulent diffusivity closures and LES models","title":"Constant isotropic diffusivity","text":"","category":"section"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"To use constant isotropic values for the viscosity ν and diffusivity κ you can use ConstantIsotropicDiffusivity","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"closure = ConstantIsotropicDiffusivity(ν=1e-2, κ=1e-2)","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#Constant-anisotropic-diffusivity-1","page":"Turbulent diffusivity closures and LES models","title":"Constant anisotropic diffusivity","text":"","category":"section"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"To specify constant values for the horizontal and vertical viscosities, nu_h and nu_v, and horizontal and vertical diffusivities, kappa_h and kappa_v, you can use ConstantAnisotropicDiffusivity","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"closure = ConstantAnisotropicDiffusivity(νh=1e-3, νv=5e-2, κh=2e-3, κv=1e-1)","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#Smagorinsky-Lilly-1","page":"Turbulent diffusivity closures and LES models","title":"Smagorinsky-Lilly","text":"","category":"section"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"To use the Smagorinsky-Lilly LES closure, no parameters are required","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"closure = SmagorinskyLilly()","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"although they may be specified. By default, the background viscosity and diffusivity are assumed to be the molecular values for seawater. For more details see SmagorinskyLilly.","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#Anisotropic-minimum-dissipation-1","page":"Turbulent diffusivity closures and LES models","title":"Anisotropic minimum dissipation","text":"","category":"section"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"To use the constant anisotropic minimum dissipation (AMD) LES closure, no parameters are required","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"closure = AnisotropicMinimumDissipation()","category":"page"},{"location":"model_setup/turbulent_diffusivity_closures_and_les_models/#","page":"Turbulent diffusivity closures and LES models","title":"Turbulent diffusivity closures and LES models","text":"although they may be specified. By default, the background viscosity and diffusivity are assumed to be the molecular values for seawater. For more details see AnisotropicMinimumDissipation.","category":"page"},{"location":"verification/stratified_couette_flow/#Stratified-Couette-flow-1","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"","category":"section"},{"location":"verification/stratified_couette_flow/#","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"In regular plane Couette flow, a viscous fluid is situated between two infinite, parallel plates and usually the top plate moves at some constant velocity generating a linear velocity profile in steady state \\citep[\\S4.2–4.3]{Batchelor00}.","category":"page"},{"location":"verification/stratified_couette_flow/#","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"In stratified Couette flow, the plates are additionally held at fixed temperatures to provide a stable stratification. It is a canonical geometry in which to investigate the dynamics of stratified shear flows as it exhibits a transition to turbulence, intermittent turbulence, coherent structures, and diapycnal mixing among other rich behavior \\citep{Zhou17}.","category":"page"},{"location":"verification/stratified_couette_flow/#","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"In this test we follow \\citet{Vreugdenhil18} who use stratified Couette flow as a test of their large-eddy simulation model. We will compare our results to theirs and the direct numerical simulation results of \\citet{Deusebio15} and \\citet{Zhou17}.","category":"page"},{"location":"verification/stratified_couette_flow/#Simulation-setup-1","page":"Stratified Couette flow","title":"Simulation setup","text":"","category":"section"},{"location":"verification/stratified_couette_flow/#","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"In our setup replicating that of \\citet{Vreugdenhil18}, a domain of size (L_x L_y L_z)h = (4pi 2pi 2) is bounded in the vertical z-direction by two infinite, parallel plates or walls at z = pm h with horizontal velocity u = pm U_w and constant temperature theta = pm Theta_w where theta denotes temperature in this section. The resulting flow is governed by the Reynolds, Richardson, and Prandtl numbers","category":"page"},{"location":"verification/stratified_couette_flow/#","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"textRe = fracU_w hnu quad\ntextRi = fracalpha g Theta_w hU_w^2 quad\ntextPr = fracnukappa","category":"page"},{"location":"verification/stratified_couette_flow/#","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"where nu is the kinematic viscosity, kappa is the thermal diffusivity, alpha is the thermal expansion coefficient, and g is the gravitational acceleration.","category":"page"},{"location":"verification/stratified_couette_flow/#","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"Defining horizontal averages for velocity U = langle u rangle and Theta = langle theta rangle we can define the friction velocity u_tau and friction temperature theta_tau at the wall by","category":"page"},{"location":"verification/stratified_couette_flow/#","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"u_tau^2 = fractau_wrho_0\n         = nu leftvert fracpartial Upartial z rightvert_z = pm h quad\ntheta_tau = fracq_wu_tau\n            = frackappau_tau leftvert fracpartialThetapartial z rightvert_z = pm h","category":"page"},{"location":"verification/stratified_couette_flow/#","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"where tau_w is the wall stress and q_w = u_tau theta_tau is the wall heat flux.","category":"page"},{"location":"verification/stratified_couette_flow/#","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"From here the friction Reynolds number and the Nusselt number can be defined","category":"page"},{"location":"verification/stratified_couette_flow/#","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"textRe_tau = fracu_tau hnu quad textNu = fracq_w hkappa Theta_w","category":"page"},{"location":"verification/stratified_couette_flow/#","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"which can be computed and compared.","category":"page"},{"location":"verification/stratified_couette_flow/#Velocity-and-temperature-1","page":"Stratified Couette flow","title":"Velocity and temperature","text":"","category":"section"},{"location":"verification/stratified_couette_flow/#","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"(Image: Velocity and temperature profiles) (Image: Velocity and temperature horizontal slices)","category":"page"},{"location":"verification/stratified_couette_flow/#\\mathrm{Re}_\\tau-and-\\mathrm{Nu}-values-1","page":"Stratified Couette flow","title":"mathrmRe_tau and mathrmNu values","text":"","category":"section"},{"location":"verification/stratified_couette_flow/#","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"(Image: Re and Nu comparison plots) (Image: Re and Nu time series plots)","category":"page"},{"location":"verification/stratified_couette_flow/#LES-viscosity-and-diffusivity-1","page":"Stratified Couette flow","title":"LES viscosity and diffusivity","text":"","category":"section"},{"location":"verification/stratified_couette_flow/#","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"(Image: LES profiles)","category":"page"},{"location":"generated/ocean_convection_with_plankton/#","page":"Ocean convection with plankton","title":"Ocean convection with plankton","text":"EditURL = \"https://github.com/climate-machine/Oceananigans.jl/blob/master/examples/ocean_convection_with_plankton.jl\"","category":"page"},{"location":"generated/ocean_convection_with_plankton/#Ocean-convection-example-1","page":"Ocean convection with plankton","title":"Ocean convection example","text":"","category":"section"},{"location":"generated/ocean_convection_with_plankton/#","page":"Ocean convection with plankton","title":"Ocean convection with plankton","text":"In this example, two-dimensional convection into a stratified fluid mixes a phytoplankton-like tracer. This example demonstrates how","category":"page"},{"location":"generated/ocean_convection_with_plankton/#","page":"Ocean convection with plankton","title":"Ocean convection with plankton","text":"to set boundary conditions;\nto defined and insert a user-defined forcing function into a simulation.\nto use the TimeStepWizard to manage and adapt the simulation time-step.","category":"page"},{"location":"generated/ocean_convection_with_plankton/#","page":"Ocean convection with plankton","title":"Ocean convection with plankton","text":"To begin, we load Oceananigans, a plotting package, and a few miscellaneous useful packages.","category":"page"},{"location":"generated/ocean_convection_with_plankton/#","page":"Ocean convection with plankton","title":"Ocean convection with plankton","text":"using Random, Printf, Plots\nusing Oceananigans, Oceananigans.Utils","category":"page"},{"location":"generated/ocean_convection_with_plankton/#Parameters-1","page":"Ocean convection with plankton","title":"Parameters","text":"","category":"section"},{"location":"generated/ocean_convection_with_plankton/#","page":"Ocean convection with plankton","title":"Ocean convection with plankton","text":"We choose a modest two-dimensional resolution of 128² in a 64² m² domain , implying a resolution of 0.5 m. Our fluid is initially stratified with a squared buoyancy frequency","category":"page"},{"location":"generated/ocean_convection_with_plankton/#","page":"Ocean convection with plankton","title":"Ocean convection with plankton","text":"$ N² = 10⁻⁵ \\rm{s⁻²} $","category":"page"},{"location":"generated/ocean_convection_with_plankton/#","page":"Ocean convection with plankton","title":"Ocean convection with plankton","text":"and a surface buoyancy flux","category":"page"},{"location":"generated/ocean_convection_with_plankton/#","page":"Ocean convection with plankton","title":"Ocean convection with plankton","text":"$ Q_b = 10⁻⁸ \\rm{m³ s⁻²} $","category":"page"},{"location":"generated/ocean_convection_with_plankton/#","page":"Ocean convection with plankton","title":"Ocean convection with plankton","text":"Because we use the physics-based convection whereby buoyancy flux by a positive vertical velocity implies positive flux, a positive buoyancy flux at the top of the domain carries buoyancy out of the fluid and causes convection. Finally, we end the simulation after 1 day.","category":"page"},{"location":"generated/ocean_convection_with_plankton/#","page":"Ocean convection with plankton","title":"Ocean convection with plankton","text":"Nz = 128\nLz = 64.0\nN² = 1e-5\nQb = 1e-8\nend_time = day / 2\nnothing # hide","category":"page"},{"location":"generated/ocean_convection_with_plankton/#Creating-boundary-conditions-1","page":"Ocean convection with plankton","title":"Creating boundary conditions","text":"","category":"section"},{"location":"generated/ocean_convection_with_plankton/#","page":"Ocean convection with plankton","title":"Ocean convection with plankton","text":"Create boundary conditions. Note that temperature is buoyancy in our problem.","category":"page"},{"location":"generated/ocean_convection_with_plankton/#","page":"Ocean convection with plankton","title":"Ocean convection with plankton","text":"grid = RegularCartesianGrid(size = (Nz, 1, Nz), length = (Lz, Lz, Lz))\n\nbuoyancy_bcs = TracerBoundaryConditions(grid,    top = BoundaryCondition(Flux, Qb),\n                                              bottom = BoundaryCondition(Gradient, N²))\nnothing # hide","category":"page"},{"location":"generated/ocean_convection_with_plankton/#Define-a-forcing-function-1","page":"Ocean convection with plankton","title":"Define a forcing function","text":"","category":"section"},{"location":"generated/ocean_convection_with_plankton/#","page":"Ocean convection with plankton","title":"Ocean convection with plankton","text":"Our forcing function roughly corresponds to the growth of phytoplankton in light (with a penetration depth of 16 meters here), and death due to natural mortality at a rate of 1 phytoplankton unit per second.","category":"page"},{"location":"generated/ocean_convection_with_plankton/#","page":"Ocean convection with plankton","title":"Ocean convection with plankton","text":"growth_and_decay = SimpleForcing((x, y, z, t) -> exp(z/16))\n\n# Instantiate the model\nmodel = IncompressibleModel(\n                   grid = grid,\n                closure = ConstantIsotropicDiffusivity(ν=1e-4, κ=1e-4),\n               coriolis = FPlane(f=1e-4),\n                tracers = (:b, :plankton),\n               buoyancy = BuoyancyTracer(),\n                forcing = ModelForcing(plankton=growth_and_decay),\n    boundary_conditions = (b=buoyancy_bcs,)\n)\nnothing # hide\n\n# Set initial condition. Initial velocity and salinity fluctuations needed for AMD.\nΞ(z) = randn() * z / Lz * (1 + z / Lz) # noise\nb₀(x, y, z) = N² * z + N² * Lz * 1e-6 * Ξ(z)\nset!(model, b=b₀)\n\n# A wizard for managing the simulation time-step.\nwizard = TimeStepWizard(cfl=0.1, Δt=1.0, max_change=1.1, max_Δt=90.0)\nnothing # hide","category":"page"},{"location":"generated/ocean_convection_with_plankton/#","page":"Ocean convection with plankton","title":"Ocean convection with plankton","text":"Set up and run the simulation:","category":"page"},{"location":"generated/ocean_convection_with_plankton/#","page":"Ocean convection with plankton","title":"Ocean convection with plankton","text":"simulation = Simulation(model, Δt=wizard, stop_iteration=0, progress_frequency=100)\n\nanim = @animate for i = 1:100\n    simulation.stop_iteration += 100\n    walltime = @elapsed run!(simulation)\n\n    # Print a progress message\n    @printf(\"progress: %.1f %%, i: %04d, t: %s, Δt: %s, wall time: %s\\n\",\n            model.clock.time / end_time * 100, model.clock.iteration,\n            prettytime(model.clock.time), prettytime(wizard.Δt), prettytime(walltime))\n\n    # Coordinate arrays for plotting\n    xC, zF, zC = model.grid.zC, model.grid.zF, model.grid.zC\n\n    # Fields to plot (converted to 2D arrays).\n    w = Array(interior(model.velocities.w))[:, 1, :]\n    p = Array(interior(model.tracers.plankton))[:, 1, :]\n\n    # Plot the fields.\n    w_plot = heatmap(xC, zF, w', xlabel=\"x (m)\", ylabel=\"z (m)\", color=:balance, clims=(-1e-2, 1e-2))\n    p_plot = heatmap(xC, zC, p', xlabel=\"x (m)\", ylabel=\"z (m)\", color=:matter) #, legend=false)\n\n    # Arrange the plots side-by-side.\n    plot(w_plot, p_plot, layout=(1, 2), size=(1000, 400),\n         title=[\"vertical velocity (m/s)\" \"Plankton concentration\"])\nend\n\nmp4(anim, \"ocean_convection_with_plankton.mp4\", fps = 15) # hide","category":"page"},{"location":"generated/ocean_convection_with_plankton/#","page":"Ocean convection with plankton","title":"Ocean convection with plankton","text":"","category":"page"},{"location":"generated/ocean_convection_with_plankton/#","page":"Ocean convection with plankton","title":"Ocean convection with plankton","text":"This page was generated using Literate.jl.","category":"page"},{"location":"model_setup/grids/#Grids-1","page":"Grid","title":"Grids","text":"","category":"section"},{"location":"model_setup/grids/#","page":"Grid","title":"Grid","text":"Currently only a regular Cartesian grid with constant grid spacings is supported. The spacing can be different for each dimension.","category":"page"},{"location":"model_setup/grids/#","page":"Grid","title":"Grid","text":"When constructing a RegularCartesianGrid the number of grid points (or size of the grid) and the physical length of each dimension (or length of the grid) must be passed as tuples.","category":"page"},{"location":"model_setup/grids/#","page":"Grid","title":"Grid","text":"A regular Cartesian grid with N_x times N_y times N_z = 64 times 32 times 16 grid points and a length of L_x = 200 meters, L_y = 100 meters, and L_z = 100 meters is constructed using","category":"page"},{"location":"model_setup/grids/#","page":"Grid","title":"Grid","text":"using Oceananigans # hide\ngrid = RegularCartesianGrid(size=(64, 32, 16), length=(200, 100, 100))","category":"page"},{"location":"model_setup/grids/#","page":"Grid","title":"Grid","text":"info: Default domain\nBy default x in 0 L_x, y in 0 L_y, and z in -L_z 0 which is common for oceanographic applications.","category":"page"},{"location":"model_setup/grids/#Specifying-the-grid's-topology-1","page":"Grid","title":"Specifying the grid's topology","text":"","category":"section"},{"location":"model_setup/grids/#","page":"Grid","title":"Grid","text":"You can also pass a tuple denoting the grid's topology. Each dimension can be either Periodic, Bounded, or Flat. By default, the RegularCartesianGrid constructor assumes a horizontally periodic grid topology, topology = (Periodic, Periodic, Bounded). To specify a channel model that is periodic in the x-dimension and wall-bounded in the y- and z-dimensions:","category":"page"},{"location":"model_setup/grids/#","page":"Grid","title":"Grid","text":"using Oceananigans # hide\ngrid = RegularCartesianGrid(size=(64, 32, 16), length=(200, 100, 100), topology=(Periodic, Bounded, Bounded))","category":"page"},{"location":"model_setup/grids/#Specifying-the-domain-1","page":"Grid","title":"Specifying the domain","text":"","category":"section"},{"location":"model_setup/grids/#","page":"Grid","title":"Grid","text":"To specify a different domain, the x, y, and z keyword arguments can be used instead of length. For example, to use the domain x in -100 100 meters, y in -50 50 meters, and z in 0 100 meters","category":"page"},{"location":"model_setup/grids/#","page":"Grid","title":"Grid","text":"using Oceananigans # hide\ngrid = RegularCartesianGrid(size=(64, 32, 16), x=(-100, 100), y=(-50, 50), z=(0, 100))","category":"page"},{"location":"model_setup/grids/#Two-dimensional-grids-1","page":"Grid","title":"Two-dimensional grids","text":"","category":"section"},{"location":"model_setup/grids/#","page":"Grid","title":"Grid","text":"Two-dimensional grids can be constructed by setting the number of grid points along the flat dimension to be 1. A two-dimensional grid in the xz-plane can be constructed using","category":"page"},{"location":"model_setup/grids/#","page":"Grid","title":"Grid","text":"using Oceananigans # hide\ngrid = RegularCartesianGrid(size=(64, 1, 16), length=(200, 1, 100), topology=(Periodic, Flat, Bounded))","category":"page"},{"location":"model_setup/grids/#","page":"Grid","title":"Grid","text":"In this case the length of the y dimension must be specified but does not matter so we just set it to 1.","category":"page"},{"location":"model_setup/grids/#","page":"Grid","title":"Grid","text":"2D grids can be used to simulate xy, xz, and yz planes.","category":"page"},{"location":"model_setup/grids/#One-dimensional-grids-1","page":"Grid","title":"One-dimensional grids","text":"","category":"section"},{"location":"model_setup/grids/#","page":"Grid","title":"Grid","text":"One-dimensional grids can be constructed in a similar manner, most commonly used to set up vertical column models. For example, to set up a 1D model with N_z grid points","category":"page"},{"location":"model_setup/grids/#","page":"Grid","title":"Grid","text":"using Oceananigans # hide\ngrid = RegularCartesianGrid(size=(1, 1, 90), length=(1, 1, 1000), topology=(Flat, Flat, Bounded))","category":"page"},{"location":"model_setup/grids/#","page":"Grid","title":"Grid","text":"The length of the x and y dimensions must be specified but do not matter.","category":"page"},{"location":"model_setup/grids/#","page":"Grid","title":"Grid","text":"warning: One-dimensional horizontal models\nWe only test one-dimensional vertical models and cannot guarantee that one-dimensional horizontal models will work as expected.","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"EditURL = \"https://github.com/climate-machine/Oceananigans.jl/blob/master/examples/ocean_wind_mixing_and_convection.jl\"","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#Wind-and-convection-driven-mixing-in-an-ocean-surface-boundary-layer-1","page":"Ocean wind mixing and convection","title":"Wind and convection-driven mixing in an ocean surface boundary layer","text":"","category":"section"},{"location":"generated/ocean_wind_mixing_and_convection/#","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"This example simulates mixing by three-dimensional turbulence in an ocean surface boundary layer driven by atmospheric winds and convection. It demonstrates:","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"how to use the SeawaterBuoyancy model for buoyancy with a linear equation of state;\nhow to use a turbulence closure for large eddy simulation;\nhow to use a function to impose a boundary condition;","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"In addition to Oceananigans.jl we need Plots for plotting, Random for generating random initial conditions, and Printf for printing progress messages. We also need Oceananigans.OutputWriters and Oceananigans.Diagnostics to access some nice features for writing output data to disk.","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"using Random, Printf, Plots\n\nusing Oceananigans, Oceananigans.OutputWriters, Oceananigans.Diagnostics, Oceananigans.Utils,\n      Oceananigans.BoundaryConditions","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#Model-parameters-1","page":"Ocean wind mixing and convection","title":"Model parameters","text":"","category":"section"},{"location":"generated/ocean_wind_mixing_and_convection/#","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Here we use an isotropic, cubic grid with Nz grid points and grid spacing Δz = 1 meter. We specify fluxes of heat, momentum, and salinity via","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"A temperature flux Qᵀ at the top of the domain, which is related to heat flux  by Qᵀ = Qʰ / (ρ₀ * cᴾ), where Qʰ is the heat flux, ρ₀ is a reference density,  and cᴾ is the heat capacity of seawater. With a reference density  ρ₀ = 1026 kg m⁻³and heat capacity cᴾ = 3991, our chosen temperature flux of  Qᵀ = 5 × 10⁻⁵ K m⁻¹ s⁻¹ corresponds to a heat flux of Qʰ = 204.7 W m⁻², a  relatively powerful cooling rate.\nA velocity flux Qᵘ at the top of the domain, which is related  to the x momentum flux τˣ via τˣ = ρ₀ * Qᵘ, where ρ₀ is a reference density.  Our chosen value of Qᵘ = -2 × 10⁻⁵ m² s⁻² roughly corresponds to atmospheric winds  of uᵃ = 2.9 m s⁻¹ in the positive x-direction, using the parameterization  τ = 0.0025 * |uᵃ| * uᵃ.\nAn evaporation rate evaporation = 10⁻⁷ m s⁻¹, or approximately 0.1 millimeter per  hour.","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Finally, we use an initial temperature gradient of ∂T/∂z = 0.005 K m⁻¹, which implies an iniital buoyancy frequency N² = α * g * ∂T/∂z = 9.8 × 10⁻⁶ s⁻² with a thermal expansion coefficient α = 2 × 10⁻⁴ K⁻¹ and gravitational acceleration g = 9.81 s⁻². Note that, by default, the SeawaterBuoyancy model uses a gravitational acceleration gᴱᵃʳᵗʰ = 9.80665 s⁻².","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"         Nz = 32       # Number of grid points in x, y, z\n         Δz = 1.0      # Grid spacing in x, y, z (meters)\n         Qᵀ = 5e-5     # Temperature flux at surface\n         Qᵘ = -2e-5    # Velocity flux at surface\n       ∂T∂z = 0.005    # Initial vertical temperature gradient\nevaporation = 1e-7     # Mass-specific evaporation rate [m s⁻¹]\n          f = 1e-4     # Coriolis parameter\n          α = 2e-4     # Thermal expansion coefficient\n          β = 8e-4     # Haline contraction coefficient\nnothing # hide","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#Boundary-conditions-1","page":"Ocean wind mixing and convection","title":"Boundary conditions","text":"","category":"section"},{"location":"generated/ocean_wind_mixing_and_convection/#","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Here we define Flux boundary conditions at the surface for u, T, and S, and a Gradient boundary condition on T that maintains a constant stratification at the bottom. Our flux boundary condition for salinity uses a function that calculates the salinity flux in terms of the evaporation rate.","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"grid = RegularCartesianGrid(size=(Nz, Nz, Nz), length=(Δz*Nz, Δz*Nz, Δz*Nz))\n\nu_bcs = UVelocityBoundaryConditions(grid, top = BoundaryCondition(Flux, Qᵘ))\n\nT_bcs = TracerBoundaryConditions(grid,    top = BoundaryCondition(Flux, Qᵀ),\n                                       bottom = BoundaryCondition(Gradient, ∂T∂z))\n\n# Salinity flux: Qˢ = - E * S\n@inline Qˢ(i, j, grid, clock, state, p) = @inbounds -p.evaporation * state.tracers.S[i, j, 1]\n\nS_bcs = TracerBoundaryConditions(grid, top = ParameterizedBoundaryCondition(Flux, Qˢ, (evaporation=evaporation,)))\nnothing # hide","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#Model-instantiation-1","page":"Ocean wind mixing and convection","title":"Model instantiation","text":"","category":"section"},{"location":"generated/ocean_wind_mixing_and_convection/#","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We instantiate a horizontally-periodic Model on the CPU with on a RegularCartesianGrid, using a FPlane model for rotation (constant rotation rate), a linear equation of state for temperature and salinity, the Anisotropic Minimum Dissipation closure to model the effects of unresolved turbulence, and the previously defined boundary conditions for u, T, and S.","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"model = IncompressibleModel(       architecture = CPU(),\n                                           grid = grid,\n                                       coriolis = FPlane(f=f),\n                                       buoyancy = SeawaterBuoyancy(equation_of_state=LinearEquationOfState(α=α, β=β)),\n                                        closure = AnisotropicMinimumDissipation(),\n                            boundary_conditions = (u=u_bcs, T=T_bcs, S=S_bcs))\nnothing # hide","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Notes:","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"To use the Smagorinsky-Lilly turbulence closure (with a constant model coefficient) rather than AnisotropicMinimumDissipation, use closure = ConstantSmagorinsky() in the model constructor.\nTo change the architecture to GPU, replace the architecture keyword argument with architecture = GPU()`","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#Initial-conditions-1","page":"Ocean wind mixing and convection","title":"Initial conditions","text":"","category":"section"},{"location":"generated/ocean_wind_mixing_and_convection/#","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Our initial condition for temperature consists of a linear stratification superposed with random noise damped at the walls, while our initial condition for velocity consists only of random noise.","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"# Random noise damped at top and bottom\nΞ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz) # noise\n\n# Temperature initial condition: a stable density tradient with random noise superposed.\nT₀(x, y, z) = 20 + ∂T∂z * z + ∂T∂z * model.grid.Lz * 1e-6 * Ξ(z)\n\n# Velocity initial condition: random noise scaled by the friction velocity.\nu₀(x, y, z) = sqrt(abs(Qᵘ)) * 1e-1 * Ξ(z)\n\nset!(model, u=u₀, w=u₀, T=T₀, S=35)","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#Set-up-output-1","page":"Ocean wind mixing and convection","title":"Set up output","text":"","category":"section"},{"location":"generated/ocean_wind_mixing_and_convection/#","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"We set up an output writer that saves all velocity fields, tracer fields, and the subgrid turbulent diffusivity associated with model.closure. The prefix keyword argument to JLD2OutputWriter indicates that output will be saved in ocean_wind_mixing_and_convection.jld2.","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"# Create a NamedTuple containing all the fields to be outputted.\nfields_to_output = merge(model.velocities, model.tracers, (νₑ=model.diffusivities.νₑ,))\n\n# Instantiate a JLD2OutputWriter to write fields. We will add it to the simulation before\n# running it.\nfield_writer = JLD2OutputWriter(model, FieldOutputs(fields_to_output); interval=hour/4,\n                                prefix=\"ocean_wind_mixing_and_convection\", force=true)","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#Running-the-simulation-1","page":"Ocean wind mixing and convection","title":"Running the simulation","text":"","category":"section"},{"location":"generated/ocean_wind_mixing_and_convection/#","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"To run the simulation, we instantiate a TimeStepWizard to ensure stable time-stepping with a Courant-Freidrichs-Lewy (CFL) number of 0.2.","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"wizard = TimeStepWizard(cfl=0.2, Δt=1.0, max_change=1.1, max_Δt=5.0)\nnothing # hide","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"A diagnostic that returns the maximum absolute value of w by calling wmax(model):","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"wmax = FieldMaximum(abs, model.velocities.w)\nnothing # hide","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"Finally, we set up and run the the simulation.","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"simulation = Simulation(model, Δt=wizard, stop_iteration=0, progress_frequency=10)\nsimulation.output_writers[:fields] = field_writer\n\nanim = @animate for i in 1:100\n    # Run the simulation forward\n    simulation.stop_iteration += 10\n    walltime = @elapsed run!(simulation)\n\n    # Print a progress message\n    @printf(\"i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\\n\",\n            model.clock.iteration, prettytime(model.clock.time), prettytime(wizard.Δt),\n            wmax(model), prettytime(walltime))\n\n    # Coordinate arrays for plotting\n    xC, zF, zC = model.grid.zC, model.grid.zF, model.grid.zC\n\n    # Slices to plots.\n    jhalf = floor(Int, model.grid.Ny/2)\n    w = Array(interior(model.velocities.w))[:, jhalf, :]\n    T = Array(interior(model.tracers.T))[:, jhalf, :]\n    S = Array(interior(model.tracers.S))[:, jhalf, :]\n\n    # Plot the slices.\n    w_plot = heatmap(xC, zF, w', xlabel=\"x (m)\", ylabel=\"z (m)\", color=:balance, clims=(-3e-2, 3e-2))\n    T_plot = heatmap(xC, zC, T', xlabel=\"x (m)\", ylabel=\"z (m)\", color=:thermal, clims=(19.75, 20))\n    S_plot = heatmap(xC, zC, S', xlabel=\"x (m)\", ylabel=\"z (m)\", color=:haline, clims=(34.99, 35.01))\n\n    # Arrange the plots side-by-side.\n    plot(w_plot, T_plot, S_plot, layout=(1, 3), size=(1600, 400),\n         title=[\"vertical velocity (m/s)\" \"temperature (C)\" \"salinity (g/kg)\"])\nend\n\nmp4(anim, \"ocean_wind_mixing_and_convection.mp4\", fps = 15) # hide","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"","category":"page"},{"location":"generated/ocean_wind_mixing_and_convection/#","page":"Ocean wind mixing and convection","title":"Ocean wind mixing and convection","text":"This page was generated using Literate.jl.","category":"page"},{"location":"model_setup/model_parameters/#Parameters-1","page":"Model parameters","title":"Parameters","text":"","category":"section"},{"location":"model_setup/model_parameters/#","page":"Model parameters","title":"Model parameters","text":"A user-defined object (could be anything) can be passed via the parameters keyword to be accessed by forcing functions and boundary condition functions.","category":"page"},{"location":"model_setup/checkpointing/#Checkpointing-1","page":"Checkpointing","title":"Checkpointing","text":"","category":"section"},{"location":"model_setup/checkpointing/#","page":"Checkpointing","title":"Checkpointing","text":"A checkpointer can be used to serialize the entire model state to a file from which the model can be restored at any time. This is useful if you'd like to periodically checkpoint when running long simulations in case of crashes or cluster time limits, but also if you'd like to restore from a checkpoint and try out multiple scenarios.","category":"page"},{"location":"model_setup/checkpointing/#","page":"Checkpointing","title":"Checkpointing","text":"For example, to periodically checkpoint the model state to disk every 1,000,000 seconds of simulation time to files of the form model_checkpoint_iteration12500.jld2 where 12500 is the iteration number (automatically filled in)","category":"page"},{"location":"model_setup/checkpointing/#","page":"Checkpointing","title":"Checkpointing","text":"model = Model(grid=RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1)))\nmodel.output_writers[:checkpointer] = Checkpointer(model; interval=1e6, prefix=\"model_checkpoint\")","category":"page"},{"location":"model_setup/checkpointing/#","page":"Checkpointing","title":"Checkpointing","text":"The default options should provide checkpoint files that are easy to restore from in most cases. For more advanced options and features, see Checkpointer.","category":"page"},{"location":"model_setup/checkpointing/#Restoring-from-a-checkpoint-file-1","page":"Checkpointing","title":"Restoring from a checkpoint file","text":"","category":"section"},{"location":"model_setup/checkpointing/#","page":"Checkpointing","title":"Checkpointing","text":"To restore the model from a checkpoint file, for example model_checkpoint_12345.jld2, simply call","category":"page"},{"location":"model_setup/checkpointing/#","page":"Checkpointing","title":"Checkpointing","text":"model = restore_from_checkpoint(\"model_checkpoint_12345.jld2\")","category":"page"},{"location":"model_setup/checkpointing/#","page":"Checkpointing","title":"Checkpointing","text":"which will create a new model object that is identical to the one that was serialized to disk. You can continue time stepping after restoring from a checkpoint.","category":"page"},{"location":"model_setup/checkpointing/#","page":"Checkpointing","title":"Checkpointing","text":"You can pass additional parameters to the Model constructor. See restore_from_checkpoint for more information.","category":"page"},{"location":"model_setup/checkpointing/#Restoring-with-functions-1","page":"Checkpointing","title":"Restoring with functions","text":"","category":"section"},{"location":"model_setup/checkpointing/#","page":"Checkpointing","title":"Checkpointing","text":"JLD2 cannot serialize functions to disk. so if you used forcing functions, boundary conditions containing functions, or the model included references to functions then they will not be serialized to the checkpoint file. When restoring from a checkpoint file, any model property that contained functions must be manually restored via keyword arguments to restore_from_checkpoint.","category":"page"},{"location":"model_setup/forcing_functions/#Forcing-functions-1","page":"Forcing functions","title":"Forcing functions","text":"","category":"section"},{"location":"model_setup/forcing_functions/#","page":"Forcing functions","title":"Forcing functions","text":"Can be used to implement anything you wish, as long as it can be expressed as extra terms in the momentum equation or tracer evolution equations.","category":"page"},{"location":"model_setup/forcing_functions/#","page":"Forcing functions","title":"Forcing functions","text":"Forcing functions will be called with the signature","category":"page"},{"location":"model_setup/forcing_functions/#","page":"Forcing functions","title":"Forcing functions","text":"f(i, j, k, grid, t, U, C, p)","category":"page"},{"location":"model_setup/forcing_functions/#","page":"Forcing functions","title":"Forcing functions","text":"where i, j, k is the grid index, grid is model.grid, t is the model.clock.time, U is the named tuple model.velocities, C is the named tuple C.tracers, and p is the user-defined model.parameters.","category":"page"},{"location":"model_setup/forcing_functions/#","page":"Forcing functions","title":"Forcing functions","text":"Once you have defined all the forcing functions needed by the model, ModelForcing can be used to create a named tuple of forcing functions that can be passed to the Model constructor.","category":"page"},{"location":"model_setup/forcing_functions/#","page":"Forcing functions","title":"Forcing functions","text":"Some examples:","category":"page"},{"location":"model_setup/forcing_functions/#","page":"Forcing functions","title":"Forcing functions","text":"Implementing a sponge layer at the bottom of the domain that damps the velocity (to filter out waves) with an","category":"page"},{"location":"model_setup/forcing_functions/#","page":"Forcing functions","title":"Forcing functions","text":"e-folding length scale of 1% of the domain height.","category":"page"},{"location":"model_setup/forcing_functions/#","page":"Forcing functions","title":"Forcing functions","text":"using Oceananigans # hide\nN, L = 16, 100\ngrid = RegularCartesianGrid(size=(N, N, N), length=(L, L, L))\n\nconst τ⁻¹ = 1 / 60  # Damping/relaxation time scale [s⁻¹].\nconst Δμ = 0.01L    # Sponge layer width [m] set to 1% of the domain height.\n@inline μ(z, Lz) = τ⁻¹ * exp(-(z+Lz) / Δμ)\n\n@inline Fu(i, j, k, grid, t, U, C, p) = @inbounds -μ(grid.zC[k], grid.Lz) * U.u[i, j, k]\n@inline Fv(i, j, k, grid, t, U, C, p) = @inbounds -μ(grid.zC[k], grid.Lz) * U.v[i, j, k]\n@inline Fw(i, j, k, grid, t, U, C, p) = @inbounds -μ(grid.zF[k], grid.Lz) * U.w[i, j, k]\n\nforcing = ModelForcing(u=Fu, v=Fv, w=Fw)\nmodel = Model(grid=grid, forcing=forcing)\nnothing # hide","category":"page"},{"location":"model_setup/forcing_functions/#","page":"Forcing functions","title":"Forcing functions","text":"Implementing a point source of fresh meltwater from ice shelf melting via a relaxation term","category":"page"},{"location":"model_setup/forcing_functions/#","page":"Forcing functions","title":"Forcing functions","text":"using Oceananigans # hide\nNx = Ny = Nz = 16\nLx = Ly = Lz = 1000\ngrid = RegularCartesianGrid(size=(Nx, Ny, Nz), length=(Lx, Ly, Lz))\n\nλ = 1/(1minute)  # Relaxation timescale [s⁻¹].\n\n# Temperature and salinity of the meltwater outflow.\nT_source = -1\nS_source = 33.95\n\n# Index of the point source at the middle of the southern wall.\nsource_index = (Int(Nx/2), 1, Int(Nz/2))\n\n# Point source\n@inline T_point_source(i, j, k, grid, time, U, C, p) =\n    @inbounds ifelse((i, j, k) == p.source_index, -p.λ * (C.T[i, j, k] - p.T_source), 0)\n\n@inline S_point_source(i, j, k, grid, time, U, C, p) =\n    @inbounds ifelse((i, j, k) == p.source_index, -p.λ * (C.S[i, j, k] - p.S_source), 0)\n\nparams = (source_index=source_index, T_source=T_source, S_source=S_source, λ=λ)\n\nforcing = ModelForcing(T=T_point_source, S=S_point_source)","category":"page"},{"location":"model_setup/forcing_functions/#","page":"Forcing functions","title":"Forcing functions","text":"You can also define a forcing as a function of (x, y, z, t) or (x, y, z, t, params) using the SimpleForcing","category":"page"},{"location":"model_setup/forcing_functions/#","page":"Forcing functions","title":"Forcing functions","text":"constructor.","category":"page"},{"location":"model_setup/forcing_functions/#","page":"Forcing functions","title":"Forcing functions","text":"using Oceananigans # hide\nconst a = 2.1\nfun_forcing(x, y, z, t) = a * exp(z) * cos(t)\nu_forcing = SimpleForcing(fun_forcing)\n\nparameterized_forcing(x, y, z, t, p) = p.μ * exp(z/p.λ) * cos(p.ω*t)\nv_forcing = SimpleForcing(parameterized_forcing, parameters=(μ=42, λ=0.1, ω=π))\n\nforcing = ModelForcing(u=u_forcing, v=v_forcing)\n\ngrid = RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1))\nmodel = Model(grid=grid, forcing=forcing)\nnothing # hide","category":"page"},{"location":"numerical_implementation/finite_volume/#Finite-volume-method-on-a-staggered-grid-1","page":"Finite volume method","title":"Finite volume method on a staggered grid","text":"","category":"section"},{"location":"numerical_implementation/finite_volume/#","page":"Finite volume method","title":"Finite volume method","text":"The Oceananigans.jl staggered grid is defined by a Cartesian array of cuboids of horizontal dimensions  Delta x_i j k Delta y_i j k and vertical dimension  Delta z_i j k, where (i j k) index the location of each cell in the staggered grid. Note that the indices (i j k) increase with increasing coordinate (x y z).","category":"page"},{"location":"numerical_implementation/finite_volume/#","page":"Finite volume method","title":"Finite volume method","text":"(Image: Schematic of staggered grid) A schematic of \\texttt{Oceananigans.jl} finite volumes for a two-dimensional staggered grid in (x z). Tracers c and pressure p are defined at the center of the control volume. The u control volumes are  centered on the left and right edges of the pressure control volume while the w control volumes are centered  on the top and bottom edges of the pressure control volumes. The indexing convention places the i^rmth  u-node on cell x-faces to the left of the i tracer point at cell centers.","category":"page"},{"location":"numerical_implementation/finite_volume/#","page":"Finite volume method","title":"Finite volume method","text":"Dropping explicit indexing, the areas of cell faces are given by","category":"page"},{"location":"numerical_implementation/finite_volume/#","page":"Finite volume method","title":"Finite volume method","text":"    A_x = Delta y Delta z quad A_y = Delta x Delta z quad A_z = Delta x Delta y","category":"page"},{"location":"numerical_implementation/finite_volume/#","page":"Finite volume method","title":"Finite volume method","text":"so that each cell encloses a volume V = Delta x Delta y Delta z.","category":"page"},{"location":"numerical_implementation/finite_volume/#","page":"Finite volume method","title":"Finite volume method","text":"A finite volume method discretizes a continuous quantity c by considering its average over a finite volume:","category":"page"},{"location":"numerical_implementation/finite_volume/#","page":"Finite volume method","title":"Finite volume method","text":"    c_i j k equiv frac1V_i j k int c(bmx)  rmd V_i j k  ","category":"page"},{"location":"numerical_implementation/finite_volume/#","page":"Finite volume method","title":"Finite volume method","text":"The finite volumes that discretize each of u, v, and w are located on a grid which is \"staggered\"  with respect to the grid that defines tracer finite volumes.  The nodes, or central points of the velocity finite volumes are co-located with the faces of the tracer  finite volume. In particular, the u-nodes are located in the center of the \"x-face\" (east of the tracer point),  v-nodes are located on y-faces south of the tracer point, and w-nodes are located on  z-faces downwards from the tracer point.","category":"page"},{"location":"installation_instructions/#Installation-instructions-1","page":"Installation instructions","title":"Installation instructions","text":"","category":"section"},{"location":"installation_instructions/#","page":"Installation instructions","title":"Installation instructions","text":"You can install the latest version of Oceananigans using the built-in package manager (accessed by pressing ] in the Julia command prompt) to add the package and instantiate/build all dependencies","category":"page"},{"location":"installation_instructions/#","page":"Installation instructions","title":"Installation instructions","text":"julia>]\n(v1.3) pkg> add Oceananigans\n(v1.3) pkg> instantiate","category":"page"},{"location":"installation_instructions/#","page":"Installation instructions","title":"Installation instructions","text":"We recommend installing Oceananigans with the built-in Julia package manager, because this installs a stable, tagged release. Oceananigans.jl can be updated to the latest tagged release from the package manager by typing","category":"page"},{"location":"installation_instructions/#","page":"Installation instructions","title":"Installation instructions","text":"(v1.3) pkg> update Oceananigans","category":"page"},{"location":"installation_instructions/#","page":"Installation instructions","title":"Installation instructions","text":"At this time, updating should be done with care, as Oceananigans is under rapid development and breaking changes to the user API occur often. But if anything does happen, please open an issue!","category":"page"},{"location":"installation_instructions/#","page":"Installation instructions","title":"Installation instructions","text":"But if anything does happen or your code stops working, please open an issue and ask! We're more than happy to help with getting your simulations up and running.","category":"page"},{"location":"installation_instructions/#","page":"Installation instructions","title":"Installation instructions","text":"warn: Use Julia 1.3 or newer\nOceananigans requires at least Julia v1.3 to run.Installing Oceananigans with an older version of Julia will install an older version of Oceananigans (the latest version compatible with your version of Julia).","category":"page"},{"location":"verification/lid_driven_cavity/#Lid-driven-cavity-1","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"","category":"section"},{"location":"verification/lid_driven_cavity/#","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"The lid-driven cavity test problem has been used for a long time as a simple verification test for computational fluid dynamics codes. First described by \\citet{Burggraf66}, the fluid is contained in a square cavity with Dirchlet boundary conditions on all four sides. The top wall moves with some velocity U while the other three walls are stationary. The solution reaches a laminar steady-state whose properties can be compared with a huge amount of existing data. The canonical database is given by \\citet{Ghia82} who report detailed information on the velocity fields as well as the streamline and vorticity contours at various Reynolds numbers. More accurate data is reported by \\citet{Botella98}, \\citet{Erturk05}, and \\citet{Bruneau06}.","category":"page"},{"location":"numerical_implementation/poisson_solvers/#Poisson-solvers-1","page":"Poisson solvers","title":"Poisson solvers","text":"","category":"section"},{"location":"numerical_implementation/poisson_solvers/#The-elliptic-problem-for-the-pressure-1","page":"Poisson solvers","title":"The elliptic problem for the pressure","text":"","category":"section"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"The pressure field is obtained by taking the divergence of the horizontal component of the momentum equation \\eqref{eq:momentumStar} and invoking the vertical component to yield an elliptic Poisson equation for the non-hydrostatic kinematic pressure","category":"page"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"nabla^2phi_NH = fracnabla cdot bmu^nDelta t + nabla cdot bmG_bmu equiv mathscrF","category":"page"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"along with homogenous Neumann boundary conditions bmu cdot bmhatn = 0 (Neumann on phi for wall-bounded directions and periodic otherwise) and where mathscrF denotes the source term for the Poisson equation.","category":"page"},{"location":"numerical_implementation/poisson_solvers/#Direct-method-1","page":"Poisson solvers","title":"Direct method","text":"","category":"section"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"Discretizing elliptic problems that can be solved via a classical separation-of-variables approach, such as Poisson's equation, results in a linear system of equations Mbmx = bmy where M is a real symmetric matrix of block tridiagonal form. This allows for the matrix to be decomposed and solved efficiently, provided that the eigenvalues and eigenvectors of the blocks are known \\citep[\\S2]{Buzbee70}. In the case of Poisson's equation on a rectangle, \\citet{Hockney65} has taken advantage of the fact that the fast Fourier transform can be used to perform the matrix multiplication steps resulting in an even more efficient method. \\citet{Schumann88} describe the implementation of such an algorithm for Poisson's equation on a staggered grid with Dirichlet, Neumann, and periodic boundary conditions.","category":"page"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"The method can be explained easily by taking the Fourier transform of both sides of \\eqref{eq:poisson-pressure} to yield","category":"page"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"-(k_x^2 + k_y^2 + k_z^2) widehatphi_NH = widehatmathscrF\nquad implies quad\nwidehatphi_NH = - fracwidehatmathscrFk_x^2 + k_y^2 + k_z^2","category":"page"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"where widehatcdot denotes the Fourier component. Here k_x, k_y, and k_z are the wavenumbers. However, when solving the equation on a staggered grid we require a solution for phi_NH that is second-order accurate such that when when its Laplacian is computed, nabla^2phi_NH matches mathscrF to machine precision. This is crucial to ensure that the projection step in \\S\\ref{sec:fractional-step} works. To do this, the wavenumbers are replaced by eigenvalues lambda_x, lambda_y, and lambda_z satisfying the discrete form of Poisson's equation with appropriate boundary conditions. Thus, Poisson's equation's is diagonalized in Fourier space and the Fourier coefficients of the solution are easily solved for","category":"page"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"widehatphi_NH(i j k) = - fracwidehatmathscrF(i j k)lambda^x_i + lambda^y_j + lambda^z_k","category":"page"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"The eigenvalues are given by \\citet{Schumann88} and can also be tediously derived by plugging in the definition of the discrete Fourier transform into \\eqref{eq:poisson-spectral}","category":"page"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"beginaligned\n    lambda^x_i = 4fracN_x^2L_x^2 sin^2 left  frac(i-1)piN_x  right  quad i=01 dotsN_x-1 \n    lambda^x_j = 4fracN_y^2L_y^2 sin^2 left  frac(j-1)piN_y  right  quad j=01 dotsN_y-1 \n    lambda^x_k = 4fracN_z^2L_z^2 sin^2 left  frac(k-1)pi2N_z right  quad k=01 dotsN_z-1\nendaligned","category":"page"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"where lambda_x and lambda_y correspond to periodic boundary conditions in the horizontal and lambda_z to Neumann boundary conditions in the vertical.","category":"page"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"There is also an ambiguity in the solution to Poisson's equation as it's only defined up to a constant. To resolve this we choose the solution with zero mean by setting the zeroth Fourier coefficient phi_000 (corresponding to k_x = k_y = k_z = 0) to zero. This also has the added benefit of discarding the zero eigenvalue so we don't divide by it.","category":"page"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"The Fast Fourier transforms are computed using FFTW.jl \\citep{Frigo98,Frigo05} on the CPU and using the cuFFT library on the GPU. Along wall-bouded dimensions, the cosine transform is used. In particular, as the transforms are performed on a staggered grid, DCT-II (REDFT10) is used to perform the forward cosine transform and DCT-III (REDFT01) is used to perform the inverse cosine transform.","category":"page"},{"location":"numerical_implementation/poisson_solvers/#Direct-method-with-a-vertically-stretched-grid-1","page":"Poisson solvers","title":"Direct method with a vertically stretched grid","text":"","category":"section"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"Using Fourier transforms for all three dimensions results in a method requiring mathcalO(N log_2 N) operations where N is the total number of grid points. This algorithm can be made even more efficient by solving a tridiagonal system along one of the dimensions and utilizing cyclic reduction. This results in the Fourier analysis cyclic reduction or textFACR(ell) algorithm (with ell cyclic reduction steps) which requires only mathcalO(N log_2log_2 N) operations provided the optimal number of cyclic reduction steps is taken, which is ell = log_2 log_2 n where n is the number of grid points in the cyclic reduction dimension. The FACR algorithm was first developed by \\citet{Hockney69} and is well reviewed by \\citet{Swarztrauber77} then further benchmarked and extended by \\citet{Temperton79} and \\citet{Temperton80}.","category":"page"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"Furthermore, the FACR algorithm removes the restriction that the grid is uniform in one of the dimensions so it can be utilized to implement a fast Poisson solver for vertically stretched grids if the cyclic reduction is applied in the along the vertical dimension.","category":"page"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"Expanding phi_NH and mathscrF into Fourier modes along the x and y directions","category":"page"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"phi_ijk = sum_m=1^N_x sum_n=1^N_y tildephi_mnk  e^-i2pi im  N_x   e^-i2pi jn  N_y","category":"page"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"and recalling that Fourier transforms do partial_x rightarrow ik_x and partial_y rightarrow ik_y we can write \\eqref{eq:poisson-pressure} as","category":"page"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"sum_m=1^N_x sum_n=1^N_y\nleftlbrace\n    partial_z^2 tildephi_mnk - (k_x^2 + k_y^2) tildephi_mnk - tildemathscrF_mnk\nrightrbrace e^-i2pi im  N_x  e^-i2pi jn  N_y = 0","category":"page"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"Discretizing the partial_z^2 derivative and equating the term inside the brackets to zero we arrive at N_xtimes N_y symmetric tridiagonal systems of N_z linear equations for the Fourier modes:","category":"page"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"fractildephi_mnk-1Delta z^F_k-1\n- leftlbrace frac1Delta z^F_k-1 + frac1Delta z^F_k + Delta z^C_k (k_x^2 + k_y^2) rightrbrace\n  tildephi_mnk\n+ fractildephi_mnk+1Delta z^F_k\n= Delta z^C_k tildemathscrF_mnk","category":"page"},{"location":"numerical_implementation/poisson_solvers/#Cosine-transforms-on-the-GPU-1","page":"Poisson solvers","title":"Cosine transforms on the GPU","text":"","category":"section"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"Unfortunately cuFFT does not provide cosine transforms and so we must write our own fast cosine transforms for the GPU. We implemented the fast 1D and 2D cosine transforms described by \\citet{Makhoul80} which compute it by applying the regular Fourier transform to a permuted version of the array.","category":"page"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"In this section we will be using the DCT-II as the definition of the forward cosine transform for a real signal of length N","category":"page"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"  textDCT(X) quad Y_k = 2 sum_j=0^N-1 cos left fracpi(j + frac12)kN right X_j","category":"page"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"and the DCT-III as the definition of the inverse cosine transform","category":"page"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"  textIDCT(X) quad Y_k = X_0 + 2 sum_j=1^N-1 cos left fracpi j (k + frac12)N right X_j","category":"page"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"and will use omega_M = e^-2pi iM to denote the M^textth root of unity, sometimes called the twiddle factors in the context of FFT algorithms.","category":"page"},{"location":"numerical_implementation/poisson_solvers/#D-fast-cosine-transform-1","page":"Poisson solvers","title":"1D fast cosine transform","text":"","category":"section"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"To calculate \\eqref{eq:FCT} using the fast Fourier transform, we first permute the input signal along the appropriate dimension by ordering the odd elements first followed by the even elements to produce a permuted signal","category":"page"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"    X^prime_n =\n    begincases\n        displaystyle X_2N quad 0 le n le left fracN-12 right \n        displaystyle X_2N - 2n - 1 quad left fracN+12 right le n le N-1\n    endcases","category":"page"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"where a indicates the integer part of a. This should produce, for example,","category":"page"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"    (a b c d e f g h) quad rightarrow quad (a c e g h f d b)","category":"page"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"after which \\eqref{eq:FCT} is computed using","category":"page"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"  Y = textDCT(X) = 2 textRe leftlbrace omega_4N^k textFFT lbrace X^prime rbrace rightrbrace","category":"page"},{"location":"numerical_implementation/poisson_solvers/#D-fast-inverse-cosine-transform-1","page":"Poisson solvers","title":"1D fast inverse cosine transform","text":"","category":"section"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"The inverse \\eqref{eq:IFCT} can be computed using","category":"page"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"  Y = textIDCT(X) = textRe leftlbrace omega_4N^-k textIFFT lbrace X rbrace rightrbrace","category":"page"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"after which the inverse permutation of \\eqref{eq:permutation} must be applied.","category":"page"},{"location":"numerical_implementation/poisson_solvers/#D-fast-cosine-transform-2","page":"Poisson solvers","title":"2D fast cosine transform","text":"","category":"section"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"Unfortunately, the 1D algorithm cannot be applied dimension-wise so the 2D algorithm is  more complicated. Thankfully though, the permutation \\eqref{eq:permutation} can be applied dimension-wise. The forward cosine transform for a real signal of length N_1 times N_2 is then given by","category":"page"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"Y_k_1 k_2 = textDCT(X_n_1 n_2) =\n2 textRe leftlbrace\n    omega_4N_1^k left( omega_4N_2^k tildeX + omega_4N_2^-k tildeX^- right)\nrightrbrace","category":"page"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"where tildeX = textFFT(X^prime) and tildeX^- indicates that tildeX is indexed in reverse.","category":"page"},{"location":"numerical_implementation/poisson_solvers/#D-fast-inverse-cosine-transform-2","page":"Poisson solvers","title":"2D fast inverse cosine transform","text":"","category":"section"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"The inverse can be computed using","category":"page"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"Y_k_1 k_2 = textIDCT(X_n_1 n_2) =\nfrac14 textRe leftlbrace\n    omega_4N_1^-k omega_4N_2^-k\n    left( tildeX - M_1 M_2 tildeX^-- right)\n    - i left( M_1 tildeX^-+ + M_2 tildeX^+- right)\nrightrbrace","category":"page"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"where tildeX = textIFFT(X) here, tildeX^-+ is indexed in reverse along the first dimension, tildeX^-+ along the second dimension, and tildeX^-- along both. M_1 and M_2 are masks of lengths N_1 and N_2 respectively, both containing ones except at the first element where M_0 = 0. Afterwards, the inverse permutation of \\eqref{eq:permutation} must be applied.","category":"page"},{"location":"numerical_implementation/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"Due to the extra steps involved in calculating the cosine transform in 2D, running with two wall-bounded dimensions typically slows the model down by a factor of 2. Switching to the FACR algorithm may help here as a 2D cosine transform won't be necessary anymore.","category":"page"},{"location":"using_gpus/#Using-GPUs-1","page":"Using GPUs","title":"Using GPUs","text":"","category":"section"},{"location":"using_gpus/#","page":"Using GPUs","title":"Using GPUs","text":"A big feature of Oceananigans is being able to run on graphical processing units (GPUs) for increased performance. Depending on your CPU and GPU combination, speedups of >150x are possible, for example on Google Cloud where running on GPUs is more cost-effective. See the performance benchmarks for more details.","category":"page"},{"location":"using_gpus/#","page":"Using GPUs","title":"Using GPUs","text":"See Architecture for instructions on setting up a model on a GPU.","category":"page"},{"location":"using_gpus/#","page":"Using GPUs","title":"Using GPUs","text":"Oceananigans does not yet support distributed parallelism (multi-CPU or multi-GPU).","category":"page"},{"location":"using_gpus/#","page":"Using GPUs","title":"Using GPUs","text":"tip: Running on GPUs\nIf you are having issues with running Oceananigans on a GPU or setting things up, please open an issue and we'll do our best to help out!","category":"page"},{"location":"using_gpus/#When-to-use-a-GPU-1","page":"Using GPUs","title":"When to use a GPU","text":"","category":"section"},{"location":"using_gpus/#","page":"Using GPUs","title":"Using GPUs","text":"GPUs are very useful for running large simulations. If your simulation uses over 1,000,000 grid points, you will probably benefit significantly from running your simulation on a GPU.","category":"page"},{"location":"using_gpus/#","page":"Using GPUs","title":"Using GPUs","text":"GPU simulations tend to be memory-limited. That is, you'll probably fill the GPU's memory long before the model becomes unbearably slow. High-end GPUs such as the Nvidia Tesla V100 only come with up to 32 GB of memory. On a GPU with 16 GB of memory, you can run a simulation (with 2 tracers) with up to ~50 million grid points.","category":"page"},{"location":"using_gpus/#Getting-access-to-GPUs-1","page":"Using GPUs","title":"Getting access to GPUs","text":"","category":"section"},{"location":"using_gpus/#","page":"Using GPUs","title":"Using GPUs","text":"If you don't have a GPU there are a few resources you can try to acquire a GPU from.","category":"page"},{"location":"using_gpus/#","page":"Using GPUs","title":"Using GPUs","text":"In general, to get good performance you'll want a GPU with good 64-bit floating point performance although Oceananigans can be used with 32-bit floats. Most recent gaming GPUs should work but might have poor 64-bit float performance.","category":"page"},{"location":"using_gpus/#","page":"Using GPUs","title":"Using GPUs","text":"If you have access to any supercomputer clusters, check to see if they have any GPUs. See also this Stack Overflow post: Where can I get access to GPU cluster for educational purpose?","category":"page"},{"location":"using_gpus/#","page":"Using GPUs","title":"Using GPUs","text":"Cloud computing providers such as Google Cloud and Amazon EC2 allow you to rent GPUs per hour. Sometimes they offer free trials or credits that can be used towards GPUs although they seem to be getting less common.","category":"page"},{"location":"using_gpus/#","page":"Using GPUs","title":"Using GPUs","text":"See the Julia on Google Colab: Free GPU-Accelerated Shareable Notebooks post on the Julia Discourse.","category":"page"},{"location":"using_gpus/#","page":"Using GPUs","title":"Using GPUs","text":"Code Ocean also has GPU support and allows you to spin up capsules with pretty decent Tesla K80 GPUs for free (for now) if you want to play around with them. They may not be powerful enough for huge simulations though. You'll want to use their \"Ubuntu Linux with GPU support (18.04.3)\" with the ability to compile CUDA code. Then you'll have to install Julia manually.","category":"page"},{"location":"using_gpus/#I-have-a-GPU.-Now-what?-1","page":"Using GPUs","title":"I have a GPU. Now what?","text":"","category":"section"},{"location":"using_gpus/#","page":"Using GPUs","title":"Using GPUs","text":"Make sure you have an Nvidia GPU that is CUDA compatible: https://developer.nvidia.com/cuda-gpus. Most recent GPUs should be but older GPUs and many laptop GPUs may not be.","category":"page"},{"location":"using_gpus/#","page":"Using GPUs","title":"Using GPUs","text":"Then download and install the CUDA Toolkit: https://developer.nvidia.com/cuda-downloads","category":"page"},{"location":"using_gpus/#","page":"Using GPUs","title":"Using GPUs","text":"Once the CUDA Toolkit is installed, you might have to build Oceananigans again","category":"page"},{"location":"using_gpus/#","page":"Using GPUs","title":"Using GPUs","text":"julia>]\n(v1.3) pkg> build Oceananigans","category":"page"},{"location":"using_gpus/#","page":"Using GPUs","title":"Using GPUs","text":"The Ocean wind mixing and convection is a good example to test out on the GPU.","category":"page"},{"location":"physics/surface_gravity_waves/#Surface-gravity-waves-and-the-Craik-Leibovich-approximation-1","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"","category":"section"},{"location":"physics/surface_gravity_waves/#","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"In Oceananiagns.jl, users model the effects of surface waves by specifying spatial and temporal gradients of the Stokes drift velocity field. At the moment, only uniform unidirectional Stokes drift fields are supported, in which case","category":"page"},{"location":"physics/surface_gravity_waves/#","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"    bmu^S = u^S(z t) hatbmx + v^S(z t) hatbmy  ","category":"page"},{"location":"physics/surface_gravity_waves/#","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"Surface waves are modeled in Oceananigans.jl by the Craik-Leibovich approximation, which governs interior motions under a surface gravity wave field that have been time- or phase-averaged over the rapid oscillations of the surface waves. The oscillatory vertical and horizontal motions associated with surface waves themselves, therefore, are not present in the resolved velocity field bmu, and only the steady, averaged effect of surface waves that manifests over several or more wave oscillations are modeled.","category":"page"},{"location":"physics/surface_gravity_waves/#","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"In Oceananigans.jl with surface waves, the resolved velocity field bmu is the Lagrangian-mean velocity field. The Lagrangian-mean velocity field at a particular location (x y z) is average velocity of a fluid particle whose average position is (x y z) at time t. The average position of a fluid particle bmxi(t) = (xi eta zeta) is thus governed by","category":"page"},{"location":"physics/surface_gravity_waves/#","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"    partial_t bmxi + bmu(bmxi t) bmcdot bmnabla bmxi = bmu(bmxi t)  ","category":"page"},{"location":"physics/surface_gravity_waves/#","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"which is the same relationship that holds when surface waves are not present and bmu ceases to be an averaged velocity field. The simplicity of the governing equations for Lagrangian-mean momentum is the main reason we use a Lagrangian-mean formulation in Oceananigans.jl, rather than an Eulerian-mean formulation: for example, the tracer conservation equation is unchanged by the inclusion of surface wave effects. Moreover, because the effect of surface waves manifests either as a bulk forcing of Lagrangian-mean momentum or as a modification to the effective background rotation rate of the interior fluid similar to any bulk forcing or Coriolis force, we do not explicitly include the effects of surface waves in turbulence closures that model the effects of subgrid turbulence. More specifically, the effect of steady surface waves does not effect the conservation of Lagrangian-mean turbulent kinetic energy.","category":"page"},{"location":"physics/surface_gravity_waves/#","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"The Lagrangian-mean velocity field bmu contrasts with the Eulerian-mean velocity field bmu^E, which is the fluid velocity averaged at the fixed Eulerian position (x y z). The surface wave Stokes drift field supplied by the user is, in fact, defined by the difference between the Eulerian- and Lagrangian-mean velocity:","category":"page"},{"location":"physics/surface_gravity_waves/#","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"    bmu^S equiv bmu - bmu^E  ","category":"page"},{"location":"physics/surface_gravity_waves/#","page":"Surface gravity waves and the Craik-Leibovich approximation","title":"Surface gravity waves and the Craik-Leibovich approximation","text":"The Stokes drift velocity field is typically prescribed for idealized scenarios, or determined from a wave model for the evolution of surface waves under time-dependent atmospheric winds in more realistic cases.","category":"page"},{"location":"#Oceananigans.jl-1","page":"Home","title":"Oceananigans.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A fast and friendly incompressible fluid flow solver in Julia that can be run in 1-3 dimensions on CPUs and GPUs.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Oceananigans.jl is a fast and friendly incompressible fluid flow solver written in Julia that can be run in 1-3 dimensions on CPUs and GPUs. It simulates the rotating Boussinesq equations in rectangular domains with some special features for fluids stratified by both temperature and salinity (oceans!) –- but can also be used without rotation, stratification, with arbitrary tracers, and arbitrary user-defined forcing functions.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"We strive for a user interface that makes Oceananigans.jl as friendly and intuitive to use as possible, allowing users to focus on the science. Internally, we have attempted to write the underlying algorithm so that the code runs as fast as possible for the configuration chosen by the user –- from simple two-dimensional setups to complex three-dimensional simulations –- and so that as much code as possible is shared between the CPU and GPU algorithms.","category":"page"},{"location":"#Getting-help-1","page":"Home","title":"Getting help","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"If you are interested in using Oceananigans.jl or are trying to figure out how to use it, please feel free to ask us questions and get in touch! If you're trying to set up a model then check out the examples and model setup documentation. Please feel free to open an issue if you have any questions, comments, suggestions, etc!","category":"page"},{"location":"numerical_implementation/spatial_operators/#Spatial-operators-1","page":"Spatial operators","title":"Spatial operators","text":"","category":"section"},{"location":"numerical_implementation/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"To calculate the various terms and perform the time-stepping, discrete difference and interpolation operators must be designed from which all the terms, such as momentum advection and Laplacian diffusion, may be constructed. Much of the material in this section is derived from \\citet{Marshall97FV}.","category":"page"},{"location":"numerical_implementation/spatial_operators/#Differences-1","page":"Spatial operators","title":"Differences","text":"","category":"section"},{"location":"numerical_implementation/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"Difference operators act as the discrete form of the derivative operator. Care must be taken when calculating differences on a staggered grid. For example, the the difference of a cell-centered variable such as temperature T lies on the faces  in the direction of the difference, and vice versa. In principle, there are three difference operators, one for each  direction","category":"page"},{"location":"numerical_implementation/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"  delta_x f = f_E - f_W quad\n  delta_y f = f_N - f_S  quad\n  delta_z f = f_T - f_B ","category":"page"},{"location":"numerical_implementation/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"where the E and W subscripts indicate that the value is evaluated the eastern or western wall of the cell, N and S indicate the northern and southern walls, and T and B indicate the top and bottom walls.","category":"page"},{"location":"numerical_implementation/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"Additionally, two delta operators must be defined for each direction to account for the staggered nature of the grid. One for taking the difference of a cell-centered variable and projecting it onto the cell faces","category":"page"},{"location":"numerical_implementation/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"beginaligned\n    delta_x^faa f_ijk = f_ijk - f_i-1jk \n    delta_y^afa f_ijk = f_ijk - f_ij-1k \n    delta_z^aaf f_ijk = f_ijk - f_ijk-1\nendaligned","category":"page"},{"location":"numerical_implementation/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"and another for taking the difference of a face-centered variable and projecting it onto the cell centers","category":"page"},{"location":"numerical_implementation/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"beginaligned\n    delta_x^caa f_ijk = f_i+1jk - f_ijk \n    delta_y^aca f_ijk = f_ij+1k - f_ijk \n    delta_z^aac f_ijk = f_ijk+1 - f_ijk\nendaligned","category":"page"},{"location":"numerical_implementation/spatial_operators/#Interpolation-1","page":"Spatial operators","title":"Interpolation","text":"","category":"section"},{"location":"numerical_implementation/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"In order to add or multiply variables that are defined at different points they are interpolated. In our case, linear interpolation or averaging is employed. Once again, there are two averaging operators, one for each direction, \\begin{equation}   \\overline{f}^x = \\frac{fE + fW}{2} , \\quad   \\overline{f}^y = \\frac{fN + fS}{2} , \\quad   \\overline{f}^z = \\frac{fT + fB}{2} \\end{equation}","category":"page"},{"location":"numerical_implementation/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"Additionally, three averaging operators must be defined for each direction. One for taking the average of a cell-centered  variable and projecting it onto the cell faces","category":"page"},{"location":"numerical_implementation/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"beginaligned\n    overlinef_ijk^faa = fracf_ijk + f_i-1jk2 \n    overlinef_ijk^afa = fracf_ijk + f_ij-1k2 \n    overlinef_ijk^aaf = fracf_ijk + f_ijk-12\nendaligned","category":"page"},{"location":"numerical_implementation/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"and another for taking the average of a face-centered variable and projecting it onto the cell centers","category":"page"},{"location":"numerical_implementation/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"beginaligned\n    overlinef_ijk^caa = fracf_i+1jk + f_ijk2 \n    overlinef_ijk^aca = fracf_ij+1k + f_ijk2 \n    overlinef_ijk^aac = fracf_ijk+1 + f_ijk2\nendaligned","category":"page"},{"location":"numerical_implementation/spatial_operators/#Divergence-and-flux-divergence-1","page":"Spatial operators","title":"Divergence and flux divergence","text":"","category":"section"},{"location":"numerical_implementation/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"The divergence of the flux of a cell-centered quantity over the cell can be calculated as","category":"page"},{"location":"numerical_implementation/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"nabla cdot bmf\n= frac1V left delta_x^faa (A_x f_x)\n                   + delta_y^afa (A_y f_y)\n                   + delta_z^aaf (A_z f_z) right","category":"page"},{"location":"numerical_implementation/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"where bmf = (f_x f_y f_z) is the flux with components defined normal to the faces, and V is the volume of the cell. The presence of a solid boundary is indicated by setting the appropriate flux normal to the boundary to zero.","category":"page"},{"location":"numerical_implementation/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"A similar divergence operator can be defined for a face-centered quantity. The divergence of the flux of T over a cell,  nabla cdot (bmu T), required in the evaluation of G_T, for example, is then","category":"page"},{"location":"numerical_implementation/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"renewcommanddiv1 nabla cdot left ( 1 right )\ndivbmu T\n= frac1V left delta_x^caa (A_x u overlineT^faa)\n                   + delta_y^aca (A_y v overlineT^afa)\n                   + delta_z^aac (A_z w overlineT^aaf) right","category":"page"},{"location":"numerical_implementation/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"where T is interpolated onto the cell faces where it can be multiplied by the velocities, which are then differenced and  projected onto the cell centers where they added together and then added to G_T which also lives at the cell centers.","category":"page"},{"location":"numerical_implementation/spatial_operators/#Momentum-advection-1","page":"Spatial operators","title":"Momentum advection","text":"","category":"section"},{"location":"numerical_implementation/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"The advection terms that make up the mathbfG terms in equations \\eqref{eq:horizontalMomentum} and \\eqref{eq:verticalMomentum} can be mathematically written as, e.g,","category":"page"},{"location":"numerical_implementation/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"renewcommanddiv1 nabla cdot left ( 1 right )\nbmu cdot nabla u\n    = divubmu - u(underbracenablacdotbmu_=0)\n    = divubmu","category":"page"},{"location":"numerical_implementation/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"which can then be discretized similarly to the flux divergence operator, however, they must be discretized differently for each direction.","category":"page"},{"location":"numerical_implementation/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"For example, the x-momentum advection operator is discretized as","category":"page"},{"location":"numerical_implementation/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"bmu cdot nabla u\n= frac1overlineV^x left\n    delta_x^faa left( overlineA_x u^caa overlineu^caa right)\n  + delta_y^afa left( overlineA_y v^aca overlineu^aca right)\n  + delta_z^aaf left( overlineA_z w^aac overlineu^aac right)\nright","category":"page"},{"location":"numerical_implementation/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"where overlineV^x is the average of the volumes of the cells on either side of the face in question. Calculating partial(uu)partial x can be performed by interpolating A_x u and u onto the cell centers then multiplying them and differencing them back onto the faces. However, in the case of the the two other terms, partial(vu)partial y and partial(wu)partial z, the two variables must be interpolated onto the cell edges to be multiplied then differenced back onto the cell faces.","category":"page"},{"location":"numerical_implementation/spatial_operators/#Discretization-of-isotropic-diffusion-operators-1","page":"Spatial operators","title":"Discretization of isotropic diffusion operators","text":"","category":"section"},{"location":"numerical_implementation/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"An isotropic viscosity operator acting on vertical momentum is discretized via","category":"page"},{"location":"numerical_implementation/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"    bmnabla left ( nu_e bmnabla w right )\n    = frac1V left\n          delta_x^faa left( nu_e overlineA_x^caa delta_x^caa w right)\n        + delta_y^afa left( nu_e overlineA_y^aca delta_y^aca w right)\n        + delta_z^aaf left( nu_e overlineA_z^aac delta_z^aac w right)\n    right ","category":"page"},{"location":"numerical_implementation/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"where nu is the kinematic viscosity.","category":"page"},{"location":"numerical_implementation/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"An isotropic diffusion operator acting on a tracer c, on the other hand, is discretized via","category":"page"},{"location":"numerical_implementation/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"   bmnabla bmcdot left ( kappa_e bmnabla c right ) =\n    = frac1V left\n        delta_x^caa left( kappa_e A_x delta_x^faa c right)\n      + delta_y^aca left( kappa_e A_y delta_y^afa c right)\n      + delta_z^aac left( kappa_e A_z delta_z^aaf c right)\n    right","category":"page"},{"location":"numerical_implementation/spatial_operators/#Vertical-integrals-1","page":"Spatial operators","title":"Vertical integrals","text":"","category":"section"},{"location":"numerical_implementation/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"Vertical integrals are converted into sums along each column. For example, the hydrostatic pressure anomaly is","category":"page"},{"location":"numerical_implementation/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"    p_HY^prime = int_-L_z^0 b^prime  dz","category":"page"},{"location":"numerical_implementation/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"where b^prime is the buoyancy perturbation. Converting it into a sum that we compute from the top downwards we get","category":"page"},{"location":"numerical_implementation/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"    p_HY^prime(k) =\n        begincases\n            - overlineb_N_z^prime^aaf Delta z^F_N_z                quad k = N_z \n            p_HY^prime(k+1) - overlineb_k+1^prime^aaf Delta z^F_k  quad 1 le k le N_z - 1\n        endcases","category":"page"},{"location":"numerical_implementation/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"where we converted the sum into a recursive definition for p_HY^prime(k) in terms of p_HY^prime(k+1) so that the integral may be computed with mathcalO(N_z) operations by a single thread.","category":"page"},{"location":"numerical_implementation/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"The vertical velocity w may be computed from u and v via the continuity equation","category":"page"},{"location":"numerical_implementation/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"    w = - int_-L_z^0 left(fracpartial upartial x + fracpartial vpartial y right)  dz","category":"page"},{"location":"numerical_implementation/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"to satisfy the incompressibility condition nablacdotbmu = 0 to numerical precision. This also involves computing a vertical integral, in this case evaluated from the bottom up","category":"page"},{"location":"numerical_implementation/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"    w_k =\n        begincases\n            0  quad k = 1 \n            w_k-1 - left( partial_x^caa u + partial_y^aca v right) Delta z^C_k  quad 2 le k le N_z\n        endcases","category":"page"},{"location":"contributing/#Contributors-Guide-1","page":"Contributor's guide","title":"Contributors Guide","text":"","category":"section"},{"location":"contributing/#","page":"Contributor's guide","title":"Contributor's guide","text":"Thank you for considering contributing to Oceananigans! This short guide will give you ideas on how you can contribute and help you make a contribution.","category":"page"},{"location":"contributing/#","page":"Contributor's guide","title":"Contributor's guide","text":"Please feel free to ask us questions and chat with us at any time if you're unsure about anything.","category":"page"},{"location":"contributing/#What-can-I-do?-1","page":"Contributor's guide","title":"What can I do?","text":"","category":"section"},{"location":"contributing/#","page":"Contributor's guide","title":"Contributor's guide","text":"Tackle an existing issue. We keep a list of good first issues that are self-contained and suitable for a newcomer to try and work on.\nTry to run Oceananigans and play around with it to simulate your favorite fluids and ocean physics. If you run into any problems or find it difficult to use or understand, please open an issue!\nWrite up an example or tutorial on how to do something useful with Oceananigans, like how to set up a new physical configuration.\nImprove documentation or comments if you found something hard to use.\nImplement a new feature if you need it to use Oceananigans.","category":"page"},{"location":"contributing/#","page":"Contributor's guide","title":"Contributor's guide","text":"If you're interested in working on something, let us know by commenting on existing issues or by opening a new issue if. This is to make sure no one else is working on the same issue and so we can help and guide you in case there is anything you need to know beforehand.","category":"page"},{"location":"contributing/#Ground-Rules-1","page":"Contributor's guide","title":"Ground Rules","text":"","category":"section"},{"location":"contributing/#","page":"Contributor's guide","title":"Contributor's guide","text":"Each pull request should consist of a logical collection of changes. You can include multiple bug fixes in a single pull request, but they should be related. For unrelated changes, please submit multiple pull requests.\nDo not commit changes to files that are irrelevant to your feature or bugfix (eg: .gitignore).\nBe willing to accept criticism and work on improving your code; we don't want to break other users' code, so care must be taken not to introduce bugs. We discuss pull requests and keep working on them until we believe we've done a good job.\nBe aware that the pull request review process is not immediate, and is generally proportional to the size of the pull request.","category":"page"},{"location":"contributing/#Reporting-a-bug-1","page":"Contributor's guide","title":"Reporting a bug","text":"","category":"section"},{"location":"contributing/#","page":"Contributor's guide","title":"Contributor's guide","text":"The easiest way to get involved is to report issues you encounter when using Oceananigans or by requesting something you think is missing.","category":"page"},{"location":"contributing/#","page":"Contributor's guide","title":"Contributor's guide","text":"Head over to the issues page.\nSearch to see if your issue already exists or has even been solved previously.\nIf you indeed have a new issue or request, click the \"New Issue\" button.\nPlease be as specific as possible. Include the version of the code you were using, as well as what operating system you are running. The output of Julia's versioninfo() and ] status is helpful to include. If possible, include complete, minimal example code that reproduces the problem.","category":"page"},{"location":"contributing/#Setting-up-your-development-environment-1","page":"Contributor's guide","title":"Setting up your development environment","text":"","category":"section"},{"location":"contributing/#","page":"Contributor's guide","title":"Contributor's guide","text":"Install Julia on your system.\nInstall git on your system if it is not already there (install XCode command line tools on a Mac or git bash on Windows).\nLogin to your GitHub account and make a fork of the Oceananigans repository by clicking the \"Fork\" button.\nClone your fork of the Oceananigans repository (in terminal on Mac/Linux or git shell/ GUI on Windows) in the location you'd like to keep it.\ngit clone https://github.com/your-user-name/Oceananigans.jl.git\nNavigate to that folder in the terminal or in Anaconda Prompt if you're on Windows.\nConnect your repository to the upstream (main project).\ngit remote add oceananigans https://github.com/climate-machine/Oceananigans.jl.git\nCreate the development environment by opening Julia via julia --project then typing in ] instantiate. This will install all the dependencies in the Project.toml file.\nYou can test to make sure Oceananigans works by typing in ] test which will run all the tests (this can take a while).","category":"page"},{"location":"contributing/#","page":"Contributor's guide","title":"Contributor's guide","text":"Your development environment is now ready!","category":"page"},{"location":"contributing/#Pull-Requests-1","page":"Contributor's guide","title":"Pull Requests","text":"","category":"section"},{"location":"contributing/#","page":"Contributor's guide","title":"Contributor's guide","text":"Changes and contributions should be made via GitHub pull requests against the master branch.","category":"page"},{"location":"contributing/#","page":"Contributor's guide","title":"Contributor's guide","text":"When you're done making changes, commit the changes you made. Chris Beams has written a guide on how to write good commit messages.","category":"page"},{"location":"contributing/#","page":"Contributor's guide","title":"Contributor's guide","text":"When you think your changes are ready to be merged into the main repository, push to your fork and submit a pull request.","category":"page"},{"location":"contributing/#","page":"Contributor's guide","title":"Contributor's guide","text":"Working on your first Pull Request? You can learn how from this free video series How to Contribute to an Open Source Project on GitHub, Aaron Meurer's tutorial on the git workflow, or the guide “How to Contribute to Open Source\".","category":"page"},{"location":"contributing/#Documentation-1","page":"Contributor's guide","title":"Documentation","text":"","category":"section"},{"location":"contributing/#","page":"Contributor's guide","title":"Contributor's guide","text":"Now that you've made your awesome contribution, it's time to tell the world how to use it. Writing documentation strings is really important to make sure others use your functionality properly. Didn't write new functions? That's fine, but be sure that the documentation for the code you touched is still in great shape. It is not uncommon to find some strange wording or clarification that you can take care of while you are here.","category":"page"},{"location":"contributing/#Credits-1","page":"Contributor's guide","title":"Credits","text":"","category":"section"},{"location":"contributing/#","page":"Contributor's guide","title":"Contributor's guide","text":"This contributor's guide is heavily based on the excellent MetPy contributor's guide.","category":"page"},{"location":"function_index/#Index-1","page":"Function index","title":"Index","text":"","category":"section"},{"location":"function_index/#","page":"Function index","title":"Function index","text":"","category":"page"},{"location":"verification/taylor_green_vortex/#Taylor-Green-vortex-1","page":"Taylor-Green vortex","title":"Taylor-Green vortex","text":"","category":"section"},{"location":"verification/taylor_green_vortex/#","page":"Taylor-Green vortex","title":"Taylor-Green vortex","text":"An exact solution to the two-dimensional incompressible Navier-Stokes equations is given by \\citet{Taylor37} describing the unsteady flow of a vortex decaying under viscous dissipation. The viscous terms balance the time derivatives while the nonlinear advection terms balance the pressure gradient term. We use the doubly-periodic solution described by \\citet[p. 310]{Hesthaven07}","category":"page"},{"location":"verification/taylor_green_vortex/#","page":"Taylor-Green vortex","title":"Taylor-Green vortex","text":"beginaligned\n  u(x y t) = -sin(2pi y) e^-4pi^2nu t \n  v(x y t) =  sin(2pi x) e^-4pi^2nu t \n  p(x y t) = -cos(2pi x) cos(2pi y) e^-8pi^2nu t\nendaligned","category":"page"},{"location":"physics/turbulence_closures/#Turbulence-closures-1","page":"Turbulence closures","title":"Turbulence closures","text":"","category":"section"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"The turbulence closure selected by the user determines the form of stress divergence bmnabla bmcdot bmtau and diffusive flux divergence bmnabla bmcdot bmq_c in the momentum and tracer conservation equations.","category":"page"},{"location":"physics/turbulence_closures/#Constant-isotropic-diffusivity-1","page":"Turbulence closures","title":"Constant isotropic diffusivity","text":"","category":"section"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"In a constant isotropic diffusivity model, the kinematic stress tensor is defined","category":"page"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"tau_ij = - nu Sigma_ij  ","category":"page"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"where nu is a constant viscosity and Sigma_ij equiv tfrac12 left ( u_i j + u_j i right ) is the strain-rate tensor. The divergence of bmtau is then","category":"page"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"bmnabla bmcdot bmtau = -nu bmnabla^2 bmu  ","category":"page"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"Similarly, the diffusive tracer flux is bmq_c = - kappa bmnabla c for tracer diffusivity kappa, and the diffusive tracer flux divergence is","category":"page"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"bmnabla bmcdot bmq_c = - kappa bmnabla^2 c  ","category":"page"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"Each tracer may have a unique diffusivity kappa.","category":"page"},{"location":"physics/turbulence_closures/#Constant-anisotropic-diffusivity-1","page":"Turbulence closures","title":"Constant anisotropic diffusivity","text":"","category":"section"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"In Oceananigans.jl, a constant anisotropic diffusivity implies a constant tensor diffusivity nu_j k and stress bmtau_ij = nu_j k u_i k with non-zero components nu_11 = nu_22 = nu_h and nu_33 = nu_v. With this form the kinematic stress divergence becomes","category":"page"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"bmnabla bmcdot bmtau = - left  nu_h left ( partial_x^2 + partial_y^2 right )\n                                    + nu_v partial_z^2 right  bmu  ","category":"page"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"and diffusive flux divergence","category":"page"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"bmnabla bmcdot bmq_c = - left  kappa_h left ( partial_x^2 + partial_y^2 right )\n                                    + kappa_v partial_z^2 right  c  ","category":"page"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"in terms of the horizontal viscosities and diffusivities nu_h and kappa_h and the vertical viscosity and diffusivities nu_v and kappa_v. Each tracer may have a unique diffusivity components kappa_h and kappa_v.","category":"page"},{"location":"physics/turbulence_closures/#Constant-anisotropic-biharmonic-diffusivity-1","page":"Turbulence closures","title":"Constant anisotropic biharmonic diffusivity","text":"","category":"section"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"In Oceananigans.jl, a constant anisotropic biharmonic diffusivity implies a constant tensor diffusivity nu_j k and stress bmtau_ij = nu_j k partial_k^3 u_i with non-zero components nu_11 = nu_22 = nu_h and nu_33 = nu_v. With this form the kinematic stress divergence becomes","category":"page"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"bmnabla bmcdot bmtau = - left  nu_h left ( partial_x^2 + partial_y^2 right )^2\n                                    + nu_v partial_z^4 right  bmu  ","category":"page"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"and diffusive flux divergence","category":"page"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"bmnabla bmcdot bmq_c = - left  kappa_h left ( partial_x^2 + partial_y^2 right )^2\n                                    + kappa_v partial_z^4 right  c  ","category":"page"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"in terms of the horizontal biharmonic viscosities and diffusivities nu_h and kappa_h and the vertical biharmonic viscosity and diffusivities nu_v and kappa_v. Each tracer may have a unique diffusivity components kappa_h and kappa_v.","category":"page"},{"location":"physics/turbulence_closures/#Smagorinsky-Lilly-turbulence-closure-1","page":"Turbulence closures","title":"Smagorinsky-Lilly turbulence closure","text":"","category":"section"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"In the turbulence closure proposed by Lilly (1962) and Smagorinsky (1963), the subgrid stress associated with unresolved turbulent motions is modeled diffusively via","category":"page"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"tau_ij = nu_e Sigma_ij  ","category":"page"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"where Sigma_ij = tfrac12 left ( u_i j + u_j i right ) is the resolved strain rate. The eddy viscosity is given by","category":"page"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"    nu_e = left ( C Delta_f right )^2 sqrt Sigma^2   Upsilon(Ri) + nu  \n    tageqsmagorinsky-viscosity","category":"page"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"where Delta_f is the \"filter width\" associated with the finite volume grid spacing, C is a user-specified model constant, Sigma^2 equiv Sigma_ij Sigmaij, and nu is a constant isotropic background viscosity. The factor Upsilon(Ri) reduces nu_e in regions of strong stratification where the resolved gradient Richardson number Ri equiv N^2  Sigma^2 is large via","category":"page"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"    Upsilon(Ri) = sqrt1 - min left ( 1 C_b N^2  Sigma^2 right )  ","category":"page"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"where N^2 = max left (0 partial_z b right ) is the squared buoyancy frequency for stable stratification with partial_z b  0 and C_b is a user-specified constant. Roughly speaking, the filter width for the Smagorinsky-Lilly closure is taken as","category":"page"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"Delta_f(bmx) = left ( Delta x Delta y Delta z right)^13  ","category":"page"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"where Delta x, Delta y, and Delta z are the grid spacing in the bmhat x, bmhat y, and bmhat z directions at location bmx = (x y z).","category":"page"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"The effect of subgrid turbulence on tracer mixing is also modeled diffusively via","category":"page"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"bmq_c = kappa_e bmnabla c  ","category":"page"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"where the eddy diffusivity kappa_e is","category":"page"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"kappa_e = fracnu_e - nuPr + kappa  ","category":"page"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"where Pr is a turbulent Prandtl number and kappa is a constant isotropic background diffusivity. Both Pr and kappa may be set independently for each tracer.","category":"page"},{"location":"physics/turbulence_closures/#Anisotropic-minimum-dissipation-(AMD)-turbulence-closure-1","page":"Turbulence closures","title":"Anisotropic minimum dissipation (AMD) turbulence closure","text":"","category":"section"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"Oceananigans.jl uses the anisotropic minimum dissipation (AMD) model proposed by Verstappen18 and described and tested by Vreugdenhil18. The AMD model uses an eddy diffusivity hypothesis similar the Smagorinsky-Lilly model. In the AMD model, the eddy viscosity and diffusivity for each tracer are defined in terms of eddy viscosity and diffusivity \\emph{predictors} nu_e^dagger and kappa_e^dagger, such that","category":"page"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"    nu_e = max left ( 0 nu_e^dagger right ) + nu\n    quad textand quad\n    kappa_e = max left ( 0 kappa_e^dagger right ) + kappa","category":"page"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"to ensure that nu_e ge 0 and kappa_e ge 0, where nu and kappa are the constant isotropic background viscosity and diffusivities for each tracer. The eddy viscosity predictor is","category":"page"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"    tageqnu-dagger\n    nu_e^dagger = -(C Delta_f)^2\n    frac\n        left( hatpartial_k hatu_i right) left( hatpartial_k hatu_j right) hatSigma_ij\n        + C_b hatdelta_i3 left( hatpartial_k hatu_i right) hatpartial_k b\n        left( hatpartial_l hatu_m right) left( hatpartial_l hatu_m right)","category":"page"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"while the eddy diffusivity predictor for tracer c is","category":"page"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"    tageqkappa-dagger\n    kappa_e^dagger = -(C Delta_f)^2\n    frac\n        left( hatpartial_k hatu_i right) left( hatpartial_k c right) hatpartial_i c\n        left( hatpartial_l c right) left( hatpartial_l c right)  ","category":"page"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"In the definitions of the eddy viscosity and eddy diffusivity predictor, C and C_b are user-specified model constants, Delta_f is a \"filter width\" associated with the finite volume grid spacing, and the hat decorators on partial derivatives, velocities, and the Kronecker delta hat delta_i3 are defined such that","category":"page"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"    hat partial_i equiv Delta_i partial_i qquad\n    hatu_i(x t) equiv fracu_i(x t)Delta_i quad textand quad\n    hatdelta_i3 equiv fracdelta_i3Delta_3  ","category":"page"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"A velocity gradient, for example, is therefore hatpartial_i hatu_j(x t) = fracDelta_iDelta_j partial_i u_j(x t), while the normalized strain tensor is","category":"page"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"    hatSigma_ij =\n        frac12 left hatpartial_i hatu_j(x t) + hatpartial_j hatu_i(x t) right  ","category":"page"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"The filter width Delta_f in that appears in the viscosity and diffusivity predictors is taken as the square root of the harmonic mean of the squares of the filter widths in each direction:","category":"page"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"    frac1Delta_f^2 = frac13 left(   frac1Delta x^2\n                                              + frac1Delta y^2\n                                              + frac1Delta z^2 right)  ","category":"page"},{"location":"physics/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"The constant C_b permits the \"buoyancy modification\" term it multiplies to be omitted from a calculation. By default we use the model constants C=112 and C_b=0.","category":"page"},{"location":"benchmarks/#Performance-benchmarks-1","page":"Performance benchmarks","title":"Performance benchmarks","text":"","category":"section"},{"location":"benchmarks/#","page":"Performance benchmarks","title":"Performance benchmarks","text":"The performance benchmarking scripts in the benchmarks directory of the git repository can be run to benchmark Oceananigans.jl on your machine. They use TimerOutputs.jl to nicely format the benchmarks.","category":"page"},{"location":"benchmarks/#Static-ocean-1","page":"Performance benchmarks","title":"Static ocean","text":"","category":"section"},{"location":"benchmarks/#","page":"Performance benchmarks","title":"Performance benchmarks","text":"This is a benchmark of a simple \"static ocean\" configuration. The time stepping and Poisson solver still takes the same amount of time whether the ocean is static or active, so it should be indicative of actual performance. It tests the performance of a bare-bones model.","category":"page"},{"location":"benchmarks/#","page":"Performance benchmarks","title":"Performance benchmarks","text":"Julia Version 1.3.0\r\nCommit 46ce4d7933 (2019-11-26 06:09 UTC)\r\nPlatform Info:\r\n  OS: Linux (x86_64-pc-linux-gnu)\r\n  CPU: Intel(R) Xeon(R) CPU E5-2603 v4 @ 1.70GHz\r\n  WORD_SIZE: 64\r\n  LIBM: libopenlibm\r\n  LLVM: libLLVM-6.0.1 (ORCJIT, broadwell)\r\n  GPU: Tesla V100-PCIE-32GB\r\n\r\n ──────────────────────────────────────────────────────────────────────────────────────\r\n        Static ocean benchmarks                Time                   Allocations      \r\n                                       ──────────────────────   ───────────────────────\r\n           Tot / % measured:                 153s / 77.9%           7.36GiB / 0.91%    \r\n\r\n Section                       ncalls     time   %tot     avg     alloc   %tot      avg\r\n ──────────────────────────────────────────────────────────────────────────────────────\r\n  32× 32× 32  (CPU, Float32)       10   78.7ms  0.07%  7.87ms    768KiB  1.09%  76.8KiB\r\n  32× 32× 32  (CPU, Float64)       10   79.0ms  0.07%  7.90ms    768KiB  1.09%  76.8KiB\r\n  32× 32× 32  (GPU, Float32)       10   41.3ms  0.03%  4.13ms   7.83MiB  11.4%   802KiB\r\n  32× 32× 32  (GPU, Float64)       10   42.6ms  0.04%  4.26ms   7.84MiB  11.4%   803KiB\r\n  64× 64× 64  (CPU, Float32)       10    685ms  0.58%  68.5ms    768KiB  1.09%  76.8KiB\r\n  64× 64× 64  (CPU, Float64)       10    674ms  0.57%  67.4ms    768KiB  1.09%  76.8KiB\r\n  64× 64× 64  (GPU, Float32)       10   44.1ms  0.04%  4.41ms   7.84MiB  11.4%   802KiB\r\n  64× 64× 64  (GPU, Float64)       10   43.4ms  0.04%  4.34ms   7.84MiB  11.4%   803KiB\r\n 128×128×128  (CPU, Float32)       10    5.72s  4.82%   572ms    768KiB  1.09%  76.8KiB\r\n 128×128×128  (CPU, Float64)       10    5.59s  4.70%   559ms    768KiB  1.09%  76.8KiB\r\n 128×128×128  (GPU, Float32)       10   54.0ms  0.05%  5.40ms   7.84MiB  11.4%   802KiB\r\n 128×128×128  (GPU, Float64)       10   54.6ms  0.05%  5.46ms   7.84MiB  11.4%   803KiB\r\n 256×256×256  (CPU, Float32)       10    54.3s  45.7%   5.43s    768KiB  1.09%  76.8KiB\r\n 256×256×256  (CPU, Float64)       10    50.8s  42.8%   5.08s    768KiB  1.09%  76.8KiB\r\n 256×256×256  (GPU, Float32)       10    305ms  0.26%  30.5ms   7.84MiB  11.4%   802KiB\r\n 256×256×256  (GPU, Float64)       10    303ms  0.26%  30.3ms   7.84MiB  11.4%   803KiB\r\n ──────────────────────────────────────────────────────────────────────────────────────\r\n\r\nCPU Float64 -> Float32 speedup:\r\n 32× 32× 32 : 1.004\r\n 64× 64× 64 : 0.985\r\n128×128×128 : 0.976\r\n256×256×256 : 0.936\r\n\r\nGPU Float64 -> Float32 speedup:\r\n 32× 32× 32 : 1.031\r\n 64× 64× 64 : 0.985\r\n128×128×128 : 1.012\r\n256×256×256 : 0.994\r\n\r\nCPU -> GPU speedup:\r\n 32× 32× 32  (Float32): 1.904\r\n 32× 32× 32  (Float64): 1.853\r\n 64× 64× 64  (Float32): 15.531\r\n 64× 64× 64  (Float64): 15.527\r\n128×128×128  (Float32): 106.054\r\n128×128×128  (Float64): 102.323\r\n256×256×256  (Float32): 177.938\r\n256×256×256  (Float64): 167.630","category":"page"},{"location":"benchmarks/#Eddying-channel-1","page":"Performance benchmarks","title":"Eddying channel","text":"","category":"section"},{"location":"benchmarks/#","page":"Performance benchmarks","title":"Performance benchmarks","text":"This benchmark tests the channel model configuration which can be slower due to the use of a more complicated algorithm for the pressure solver in the current version of Oceananigans.","category":"page"},{"location":"benchmarks/#","page":"Performance benchmarks","title":"Performance benchmarks","text":"Julia Version 1.3.0\r\nCommit 46ce4d7933 (2019-11-26 06:09 UTC)\r\nPlatform Info:\r\n  OS: Linux (x86_64-pc-linux-gnu)\r\n  CPU: Intel(R) Xeon(R) CPU E5-2603 v4 @ 1.70GHz\r\n  WORD_SIZE: 64\r\n  LIBM: libopenlibm\r\n  LLVM: libLLVM-6.0.1 (ORCJIT, broadwell)\r\n  GPU: Tesla V100-PCIE-32GB\r\n\r\n ──────────────────────────────────────────────────────────────────────────────────────\r\n       Eddying channel benchmarks              Time                   Allocations      \r\n                                       ──────────────────────   ───────────────────────\r\n           Tot / % measured:                 112s / 61.5%           9.67GiB / 0.38%    \r\n\r\n Section                       ncalls     time   %tot     avg     alloc   %tot      avg\r\n ──────────────────────────────────────────────────────────────────────────────────────\r\n  32× 32× 32  (CPU, Float32)        5   45.1ms  0.07%  9.03ms    389KiB  1.02%  77.8KiB\r\n  32× 32× 32  (CPU, Float64)        5   48.4ms  0.07%  9.68ms    389KiB  1.02%  77.8KiB\r\n  32× 32× 32  (GPU, Float32)        5   33.1ms  0.05%  6.62ms   4.07MiB  10.9%   834KiB\r\n  32× 32× 32  (GPU, Float64)        5   32.1ms  0.05%  6.42ms   4.08MiB  10.9%   835KiB\r\n  64× 64× 64  (CPU, Float32)        5    377ms  0.55%  75.5ms    389KiB  1.02%  77.8KiB\r\n  64× 64× 64  (CPU, Float64)        5    379ms  0.55%  75.7ms    389KiB  1.02%  77.8KiB\r\n  64× 64× 64  (GPU, Float32)        5   44.7ms  0.06%  8.93ms   4.15MiB  11.1%   850KiB\r\n  64× 64× 64  (GPU, Float64)        5   44.1ms  0.06%  8.82ms   4.15MiB  11.1%   850KiB\r\n 128×128×128  (CPU, Float32)        5    3.17s  4.60%   635ms    389KiB  1.02%  77.8KiB\r\n 128×128×128  (CPU, Float64)        5    3.19s  4.62%   637ms    389KiB  1.02%  77.8KiB\r\n 128×128×128  (GPU, Float32)        5   75.2ms  0.11%  15.0ms   4.29MiB  11.5%   880KiB\r\n 128×128×128  (GPU, Float64)        5   75.1ms  0.11%  15.0ms   4.30MiB  11.5%   880KiB\r\n 256×256×256  (CPU, Float32)        5    31.5s  45.7%   6.30s    389KiB  1.02%  77.8KiB\r\n 256×256×256  (CPU, Float64)        5    29.2s  42.3%   5.83s    389KiB  1.02%  77.8KiB\r\n 256×256×256  (GPU, Float32)        5    391ms  0.57%  78.1ms   4.59MiB  12.3%   940KiB\r\n 256×256×256  (GPU, Float64)        5    368ms  0.53%  73.6ms   4.59MiB  12.3%   940KiB\r\n ──────────────────────────────────────────────────────────────────────────────────────\r\n\r\nCPU Float64 -> Float32 speedup:\r\n 32× 32× 32 : 1.072\r\n 64× 64× 64 : 1.003\r\n128×128×128 : 1.004\r\n256×256×256 : 0.926\r\n\r\nGPU Float64 -> Float32 speedup:\r\n 32× 32× 32 : 0.970\r\n 64× 64× 64 : 0.987\r\n128×128×128 : 0.999\r\n256×256×256 : 0.943\r\n\r\nCPU -> GPU speedup:\r\n 32× 32× 32  (Float32): 1.364\r\n 32× 32× 32  (Float64): 1.508\r\n 64× 64× 64  (Float32): 8.449\r\n 64× 64× 64  (Float64): 8.588\r\n128×128×128  (Float32): 42.209\r\n128×128×128  (Float64): 42.411\r\n256×256×256  (Float32): 80.638\r\n256×256×256  (Float64): 79.211","category":"page"},{"location":"benchmarks/#Tracers-1","page":"Performance benchmarks","title":"Tracers","text":"","category":"section"},{"location":"benchmarks/#","page":"Performance benchmarks","title":"Performance benchmarks","text":"This benchmark tests the performance impacts of running with various amounts of active and passive tracers.","category":"page"},{"location":"benchmarks/#","page":"Performance benchmarks","title":"Performance benchmarks","text":"Julia Version 1.3.0\r\nCommit 46ce4d7933 (2019-11-26 06:09 UTC)\r\nPlatform Info:\r\n  OS: Linux (x86_64-pc-linux-gnu)\r\n  CPU: Intel(R) Xeon(R) CPU E5-2603 v4 @ 1.70GHz\r\n  WORD_SIZE: 64\r\n  LIBM: libopenlibm\r\n  LLVM: libLLVM-6.0.1 (ORCJIT, broadwell)\r\n  GPU: Tesla V100-PCIE-32GB\r\n\r\n ───────────────────────────────────────────────────────────────────────────────────────────────────────────\r\n                      Tracer benchmarks                             Time                   Allocations      \r\n                                                            ──────────────────────   ───────────────────────\r\n                      Tot / % measured:                          37.6s / 9.69%           7.64GiB / 1.12%    \r\n\r\n Section                                            ncalls     time   %tot     avg     alloc   %tot      avg\r\n ───────────────────────────────────────────────────────────────────────────────────────────────────────────\r\n  32× 32× 32 0 active +  0 passive (CPU, Float64)       10   60.0ms  1.65%  6.00ms    574KiB  0.64%  57.4KiB\r\n  32× 32× 32 0 active +  1 passive (CPU, Float64)       10   68.4ms  1.88%  6.84ms    667KiB  0.74%  66.7KiB\r\n  32× 32× 32 0 active +  2 passive (CPU, Float64)       10   76.8ms  2.11%  7.68ms    768KiB  0.85%  76.8KiB\r\n  32× 32× 32 1 active +  0 passive (CPU, Float64)       10   69.2ms  1.90%  6.92ms    667KiB  0.74%  66.7KiB\r\n  32× 32× 32 2 active +  0 passive (CPU, Float64)       10   78.7ms  2.16%  7.87ms    768KiB  0.85%  76.8KiB\r\n  32× 32× 32 2 active +  3 passive (CPU, Float64)       10    104ms  2.86%  10.4ms   1.03MiB  1.17%   106KiB\r\n  32× 32× 32 2 active +  5 passive (CPU, Float64)       10    123ms  3.38%  12.3ms   1.22MiB  1.39%   125KiB\r\n  32× 32× 32 2 active + 10 passive (CPU, Float64)       10    177ms  4.86%  17.7ms   1.69MiB  1.92%   173KiB\r\n 256×256×256 0 active +  0 passive (GPU, Float64)       10    237ms  6.50%  23.7ms   5.43MiB  6.17%   556KiB\r\n 256×256×256 0 active +  1 passive (GPU, Float64)       10    266ms  7.29%  26.6ms   6.62MiB  7.52%   678KiB\r\n 256×256×256 0 active +  2 passive (GPU, Float64)       10    297ms  8.16%  29.7ms   7.83MiB  8.89%   801KiB\r\n 256×256×256 1 active +  0 passive (GPU, Float64)       10    268ms  7.35%  26.8ms   6.62MiB  7.52%   678KiB\r\n 256×256×256 2 active +  0 passive (GPU, Float64)       10    303ms  8.32%  30.3ms   7.84MiB  8.91%   803KiB\r\n 256×256×256 2 active +  3 passive (GPU, Float64)       10    403ms  11.1%  40.3ms   11.5MiB  13.1%  1.15MiB\r\n 256×256×256 2 active +  5 passive (GPU, Float64)       10    472ms  13.0%  47.2ms   14.1MiB  16.0%  1.41MiB\r\n 256×256×256 2 active + 10 passive (GPU, Float64)       10    641ms  17.6%  64.1ms   20.8MiB  23.6%  2.08MiB\r\n ───────────────────────────────────────────────────────────────────────────────────────────────────────────","category":"page"},{"location":"benchmarks/#Turbulence-closures-1","page":"Performance benchmarks","title":"Turbulence closures","text":"","category":"section"},{"location":"benchmarks/#","page":"Performance benchmarks","title":"Performance benchmarks","text":"This benchmark tests the performance impacts of various turbulence closures and large eddy simulation (LES) models.","category":"page"},{"location":"benchmarks/#","page":"Performance benchmarks","title":"Performance benchmarks","text":"Julia Version 1.3.0\r\nCommit 46ce4d7933 (2019-11-26 06:09 UTC)\r\nPlatform Info:\r\n  OS: Linux (x86_64-pc-linux-gnu)\r\n  CPU: Intel(R) Xeon(R) CPU E5-2603 v4 @ 1.70GHz\r\n  WORD_SIZE: 64\r\n  LIBM: libopenlibm\r\n  LLVM: libLLVM-6.0.1 (ORCJIT, broadwell)\r\n  GPU: Tesla V100-PCIE-32GB\r\n\r\n ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\r\n                    Turbulence closure benchmarks                            Time                   Allocations      \r\n                                                                     ──────────────────────   ───────────────────────\r\n                          Tot / % measured:                               31.0s / 78.5%           1.31GiB / 3.92%    \r\n\r\n Section                                                     ncalls     time   %tot     avg     alloc   %tot      avg\r\n ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\r\n  32× 32× 32 ConstantAnisotropicDiffusivity (CPU, Float64)       10   78.1ms  0.32%  7.81ms    769KiB  1.42%  76.9KiB\r\n  32× 32× 32 ConstantAnisotropicDiffusivity (GPU, Float64)       10   43.0ms  0.18%  4.30ms   7.86MiB  14.9%   805KiB\r\n  32× 32× 32 ConstantIsotropicDiffusivity (CPU, Float64)         10   78.7ms  0.32%  7.87ms    768KiB  1.42%  76.8KiB\r\n  32× 32× 32 ConstantIsotropicDiffusivity (GPU, Float64)         10   44.5ms  0.18%  4.45ms   7.84MiB  14.9%   803KiB\r\n  32× 32× 32 SmagorinskyLilly (CPU, Float64)                     10    189ms  0.78%  18.9ms    778KiB  1.44%  77.8KiB\r\n  32× 32× 32 SmagorinskyLilly (GPU, Float64)                     10   45.7ms  0.19%  4.57ms   8.43MiB  16.0%   863KiB\r\n 128×128×128 ConstantAnisotropicDiffusivity (CPU, Float64)       10    5.54s  22.8%   554ms    769KiB  1.42%  76.9KiB\r\n 128×128×128 ConstantAnisotropicDiffusivity (GPU, Float64)       10   53.5ms  0.22%  5.35ms   7.86MiB  14.9%   805KiB\r\n 128×128×128 ConstantIsotropicDiffusivity (CPU, Float64)         10    5.53s  22.7%   553ms    768KiB  1.42%  76.8KiB\r\n 128×128×128 ConstantIsotropicDiffusivity (GPU, Float64)         10   54.1ms  0.22%  5.41ms   7.84MiB  14.9%   803KiB\r\n 128×128×128 SmagorinskyLilly (CPU, Float64)                     10    12.6s  51.8%   1.26s    778KiB  1.44%  77.8KiB\r\n 128×128×128 SmagorinskyLilly (GPU, Float64)                     10   75.6ms  0.31%  7.56ms   8.43MiB  16.0%   863KiB\r\n ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"EditURL = \"https://github.com/climate-machine/Oceananigans.jl/blob/master/examples/internal_wave.jl\"","category":"page"},{"location":"generated/internal_wave/#Internal-wave-example-1","page":"Internal wave","title":"Internal wave example","text":"","category":"section"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"In this example, we initialize an internal wave packet in two-dimensions and watch it propagate.","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"using Oceananigans, Plots, Printf","category":"page"},{"location":"generated/internal_wave/#Numerical,-domain,-and-internal-wave-parameters-1","page":"Internal wave","title":"Numerical, domain, and internal wave parameters","text":"","category":"section"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"First, we pick some numerical and physical parameters for our model and its rotation rate.","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"Nx = 128 # resolution\nLx = 2π  # domain extent\nnothing # hide","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"We set up an internal wave with the pressure field","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"$ p(x, y, z, t) = a(x, z) cos(kx + mz - ω t) $.","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"where m is the vertical wavenumber, k is the horizontal wavenumber, ω is the wave frequncy, and a(x, z) is a Gaussian envelope.","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"# Non-dimensional internal wave parameters\nm = 16      # vertical wavenumber\nk = 1       # horizontal wavenumber\nN = 1       # buoyancy frequency\nf = 0.2     # inertial frequency\nnothing # hide","category":"page"},{"location":"generated/internal_wave/#A-Gaussian-wavepacket-1","page":"Internal wave","title":"A Gaussian wavepacket","text":"","category":"section"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"Next, we set up an initial condition corresponding to a propagating wave packet with a Gaussian envelope. The internal wave dispersion relation yields","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"ω² = (N^2 * k^2 + f^2 * m^2) / (k^2 + m^2)\n\n# and thus\nω = sqrt(ω²)\nnothing # hide","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"The internal wave polarization relations follow from the linearized Boussinesq equations,","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"U = k * ω   / (ω^2 - f^2)\nV = k * f   / (ω^2 - f^2)\nW = m * ω   / (ω^2 - N^2)\nB = m * N^2 / (ω^2 - N^2)\nnothing # hide","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"Finally, we set-up a small-amplitude, Gaussian envelope for the wave packet","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"# Some Gaussian parameters\nA, x₀, z₀, δ = 1e-9, Lx/2, -Lx/2, Lx/15\n\n# A Gaussian envelope\na(x, z) = A * exp( -( (x - x₀)^2 + (z - z₀)^2 ) / 2δ^2 )\nnothing # hide","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"Create initial condition functions","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"u₀(x, y, z) = a(x, z) * U * cos(k*x + m*z)\nv₀(x, y, z) = a(x, z) * V * sin(k*x + m*z)\nw₀(x, y, z) = a(x, z) * W * cos(k*x + m*z)\nb₀(x, y, z) = a(x, z) * B * sin(k*x + m*z) + N^2 * z\nnothing # hide","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"We are now ready to instantiate our model on a uniform grid. We give the model a constant rotation rate with background vorticity f, use temperature as a buoyancy tracer, and use a small constant viscosity and diffusivity to stabilize the model.","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"model = IncompressibleModel(\n        grid = RegularCartesianGrid(size=(Nx, 1, Nx), length=(Lx, Lx, Lx)),\n     closure = ConstantIsotropicDiffusivity(ν=1e-6, κ=1e-6),\n    coriolis = FPlane(f=f),\n     tracers = :b,\n    buoyancy = BuoyancyTracer()\n)\nnothing # hide","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"We initialize the velocity and buoyancy fields with our internal wave initial condition.","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"set!(model, u=u₀, v=v₀, w=w₀, b=b₀)","category":"page"},{"location":"generated/internal_wave/#A-wave-packet-on-the-loose-1","page":"Internal wave","title":"A wave packet on the loose","text":"","category":"section"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"Finally, we release the packet and watch it go!","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"simulation = Simulation(model, Δt = 0.001 * 2π/ω, stop_iteration = 0,\n                        progress_frequency = 20)\n\nanim = @animate for i=1:100\n    simulation.stop_iteration += 20\n    run!(simulation)\n\n    x, z = model.grid.xC, model.grid.zF\n    w = model.velocities.w\n    heatmap(x, z, w.data[1:Nx, 1, 1:Nx+1]', title=@sprintf(\"t = %.2f\", model.clock.time),\n            xlabel=\"x\", ylabel=\"z\", c=:balance, clims=(-1e-8, 1e-8))\nend\n\nmp4(anim, \"internal_wave.mp4\", fps = 15) # hide","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"This page was generated using Literate.jl.","category":"page"},{"location":"physics/navier_stokes_and_tracer_conservation/#Navier-Stokes-and-tracer-conservation-equations-1","page":"Navier-Stokes and tracer conservation equations","title":"Navier-Stokes and tracer conservation equations","text":"","category":"section"},{"location":"physics/navier_stokes_and_tracer_conservation/#","page":"Navier-Stokes and tracer conservation equations","title":"Navier-Stokes and tracer conservation equations","text":"Oceananigans.jl solves the incompressible Navier-Stokes equations and an arbitrary number of tracer conservation equations. Physics associated with individual terms in the momentum and tracer conservation equations –- the background rotation rate of the equation's reference frame, gravitational effects associated with buoyant tracers under the Boussinesq approximation[1], generalized stresses and tracer fluxes associated with viscous and diffusive physics, and arbitrary \"forcing functions\" –- are determined by the whims of the user.","category":"page"},{"location":"physics/navier_stokes_and_tracer_conservation/#","page":"Navier-Stokes and tracer conservation equations","title":"Navier-Stokes and tracer conservation equations","text":"[1]: Named after Boussinesq (1903) although used earlier by Oberbeck (1879), the Boussinesq   approximation neglects density differences in the momentum equation except when associated   with the gravitational term. It is an accurate approximation for many flows, and especially   so for oceanic flows where density differences are very small. See Vallis (2017, section 2.4)   for an oceanographic introduction to the Boussinesq equations and Vallis (2017, Section 2.A)   for an asymptotic derivation. See Kundu (2015, Section 4.9) for an engineering   introduction.","category":"page"},{"location":"library/#Library-1","page":"Library","title":"Library","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"Documenting the public user interface.","category":"page"},{"location":"library/#Architectures-1","page":"Library","title":"Architectures","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"Modules = [Oceananigans.Architectures]\nPrivate = false\nPages   = [\"Architectures.jl\"]","category":"page"},{"location":"library/#Oceananigans.Architectures.AbstractArchitecture","page":"Library","title":"Oceananigans.Architectures.AbstractArchitecture","text":"AbstractArchitecture\n\nAbstract supertype for architectures supported by Oceananigans.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Architectures.CPU","page":"Library","title":"Oceananigans.Architectures.CPU","text":"CPU <: AbstractArchitecture\n\nRun Oceananigans on a single-core of a CPU.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Architectures.GPU","page":"Library","title":"Oceananigans.Architectures.GPU","text":"GPU <: AbstractArchitecture\n\nRun Oceananigans on a single NVIDIA CUDA GPU.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Architectures.@hascuda-Tuple{Any}","page":"Library","title":"Oceananigans.Architectures.@hascuda","text":"@hascuda expr\n\nA macro to compile and execute expr only if CUDA is installed and available. Generally used to wrap expressions that can only be compiled if CuArrays and CUDAnative can be loaded.\n\n\n\n\n\n","category":"macro"},{"location":"library/#Boundary-conditions-1","page":"Library","title":"Boundary conditions","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"Modules = [Oceananigans.BoundaryConditions]\nPrivate = false\nPages   = [\n    \"BoundaryConditions/BoundaryConditions.jl\",\n    \"BoundaryConditions/boundary_condition_types.jl\",\n    \"BoundaryConditions/boundary_condition.jl\",\n    \"BoundaryConditions/coordinate_boundary_conditions.jl\",\n    \"BoundaryConditions/field_boundary_conditions.jl\",\n    \"BoundaryConditions/solution_boundary_conditions.jl\",\n    \"BoundaryConditions/model_boundary_conditions.jl\",\n    \"BoundaryConditions/tracer_boundary_conditions.jl\",\n    \"BoundaryConditions/tendency_boundary_conditions.jl\",\n    \"BoundaryConditions/pressure_boundary_conditions.jl\",\n    \"BoundaryConditions/boundary_function.jl\",\n    \"BoundaryConditions/show_boundary_conditions.jl\",\n    \"BoundaryConditions/zero_halo_regions.jl\",\n    \"BoundaryConditions/fill_halo_regions.jl\",\n    \"BoundaryConditions/apply_flux_bcs.jl\",\n    \"BoundaryConditions/apply_value_gradient_bcs.jl\",\n    \"BoundaryConditions/apply_flux_periodic_no_penetration_bcs.jl\"\n]","category":"page"},{"location":"library/#Oceananigans.BoundaryConditions.BCType","page":"Library","title":"Oceananigans.BoundaryConditions.BCType","text":"BCType\n\nAbstract supertype for boundary condition types.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.BoundaryConditions.Flux","page":"Library","title":"Oceananigans.BoundaryConditions.Flux","text":"Flux\n\nA type specifying a boundary condition on the flux of a field.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.BoundaryConditions.Gradient","page":"Library","title":"Oceananigans.BoundaryConditions.Gradient","text":"Gradient\n\nA type specifying a boundary condition on the derivative or gradient of a field. Also called a Neumann boundary condition.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.BoundaryConditions.NoPenetration","page":"Library","title":"Oceananigans.BoundaryConditions.NoPenetration","text":"NoPenetration\n\nA type specifying a no-penetration boundary condition for a velocity component that is normal to a wall.\n\nThus NoPenetration can only be applied to u along x, v along y, or w along z. For all other cases –- fields located at (Cell, Cell, Cell), or u, v, and w in (y, z), (x, z), and (x, y), respectively, either Value, Gradient, or Flux conditions must be used.\n\nA condition may not be specified with a NoPenetration boundary condition.\n\nNote that this differs from a zero Value boundary condition as Value imposes values at the cell centers (and could apply to tracers) while a no-penetration boundary condition only applies to normal velocity components at a wall, where the velocity at the cell face collocated at the wall is known and set to zero.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.BoundaryConditions.Value","page":"Library","title":"Oceananigans.BoundaryConditions.Value","text":"Value\n\nA type specifying a boundary condition on the value of a field. Also called a Dirchlet boundary condition.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.BoundaryConditions.BoundaryCondition","page":"Library","title":"Oceananigans.BoundaryConditions.BoundaryCondition","text":"BoundaryCondition{C<:BCType}(condition)\n\nConstruct a boundary condition of type C with a condition that may be given by a number, an array, or a function with signature:\n\ncondition(i, j, grid, time, iteration, U, Φ, parameters) = # function definition\n\nthat returns a number and where i and j are indices along the boundary.\n\nBoundary condition types include Periodic, Flux, Value, Gradient, and NoPenetration.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.BoundaryConditions.CoordinateBoundaryConditions","page":"Library","title":"Oceananigans.BoundaryConditions.CoordinateBoundaryConditions","text":"CoordinateBoundaryConditions(left, right)\n\nA set of two BoundaryConditions to be applied along a coordinate x, y, or z.\n\nThe left boundary condition is applied on the negative or lower side of the coordinate while the right boundary condition is applied on the positive or higher side.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.BoundaryConditions.FieldBoundaryConditions","page":"Library","title":"Oceananigans.BoundaryConditions.FieldBoundaryConditions","text":"FieldBoundaryConditions\n\nAn alias for NamedTuple{(:x, :y, :z)} that represents a set of three CoordinateBoundaryConditions applied to a field along x, y, and z.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.BoundaryConditions.FieldBoundaryConditions-Tuple{Any,Any,Any}","page":"Library","title":"Oceananigans.BoundaryConditions.FieldBoundaryConditions","text":"FieldBoundaryConditions(x, y, z)\n\nConstruct a FieldBoundaryConditions using a CoordinateBoundaryCondition for each of the x, y, and z coordinates.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.BoundaryConditions.FieldBoundaryConditions-Tuple{Any,Any}","page":"Library","title":"Oceananigans.BoundaryConditions.FieldBoundaryConditions","text":"FieldBoundaryConditions(grid, loc;\n      east = DefaultBoundaryCondition(topology(grid)[1], loc[1]),\n      west = DefaultBoundaryCondition(topology(grid)[1], loc[1]),\n     south = DefaultBoundaryCondition(topology(grid)[2], loc[2]),\n     north = DefaultBoundaryCondition(topology(grid)[2], loc[2]),\n    bottom = DefaultBoundaryCondition(topology(grid)[3], loc[3]),\n       top = DefaultBoundaryCondition(topology(grid)[3], loc[3]))\n\nConstruct FieldBoundaryConditions for a field with location loc (a 3-tuple of Face or Cell) defined on grid (the grid's topology is what defined the default boundary conditions that are imposed).\n\nSpecific boundary conditions can be applied along the x dimension with the west and east kwargs, along the y-dimension with the south and north kwargs, and along the z-dimension with the bottom and top kwargs.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.BoundaryConditions.BoundaryFunction","page":"Library","title":"Oceananigans.BoundaryConditions.BoundaryFunction","text":"    BoundaryFunction{B, X1, X2}(func, parameters=nothing)\n\nA wrapper for the user-defined boundary condition function func, on the boundary specified by symbol B and at location (X1, X2), and with parameters.\n\nExample\n\njulia> using Oceananigans, Oceananigans.BoundaryConditions, Oceananigans.Fields\n\njulia> toptracerflux = BoundaryFunction{:z, Cell, Cell}((x, y, t) -> cos(2π*x) * cos(t)) (::BoundaryFunction{:z,Cell,Cell,var\"#7#8\",Nothing}) (generic function with 1 method)\n\njulia> toptracerbc = BoundaryCondition(Flux, toptracerflux);\n\njulia> flux_func(x, y, t, p) = cos(p.k * x) * cos(p.ω * t); # function with parameters\n\njulia> parameterizeduvelocityflux = BoundaryFunction{:z, Face, Cell}(fluxfunc, (k=4π, ω=3.0)) (::BoundaryFunction{:z,Face,Cell,typeof(flux_func),NamedTuple{(:k, :ω),Tuple{Float64,Float64}}}) (generic function with 1 method)\n\njulia> topubc = BoundaryCondition(Flux, parameterizeduvelocity_flux);\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.BoundaryConditions.TracerBoundaryCondition-Tuple{Any,Any,Vararg{Any,N} where N}","page":"Library","title":"Oceananigans.BoundaryConditions.TracerBoundaryCondition","text":"TracerBoundaryCondition(bctype, B, args...)\n\nReturns a BoundaryCondition of type bctype, that applies the function func to a tracer on the boundary B, which is one of :x, :y, :z. The boundary function has the signature\n\n`func(ξ, η, t)`\n\nwhere t is time, and ξ and η are coordinates along the boundary, eg: (y, z) for B = :x, (x, z) for B = :y, or (x, y) for B = :z.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.BoundaryConditions.UVelocityBoundaryCondition-Tuple{Any,Any,Vararg{Any,N} where N}","page":"Library","title":"Oceananigans.BoundaryConditions.UVelocityBoundaryCondition","text":"UVelocityBoundaryCondition(bctype, B, args...)\n\nReturns a BoundaryCondition of type bctype, that applies the function func to u, the x-velocity field, on the boundary B, which is one of :x, :y, :z. The boundary function has the signature\n\n`func(ξ, η, t)`\n\nwhere t is time, and ξ and η are coordinates along the boundary, eg: (y, z) for B = :x, (x, z) for B = :y, or (x, y) for B = :z.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.BoundaryConditions.VVelocityBoundaryCondition-Tuple{Any,Any,Vararg{Any,N} where N}","page":"Library","title":"Oceananigans.BoundaryConditions.VVelocityBoundaryCondition","text":"VVelocityBoundaryCondition(bctype, B, args...)\n\nReturns a BoundaryCondition of type bctype, that applies the function func to v, the y-velocity field, on the boundary B, which is one of :x, :y, :z. The boundary function has the signature\n\n`func(ξ, η, t)`\n\nwhere t is time, and ξ and η are coordinates along the boundary, eg: (y, z) for B = :x, (x, z) for B = :y, or (x, y) for B = :z.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.BoundaryConditions.WVelocityBoundaryCondition-Tuple{Any,Any,Vararg{Any,N} where N}","page":"Library","title":"Oceananigans.BoundaryConditions.WVelocityBoundaryCondition","text":"VVelocityBoundaryCondition(bctype, B, args...)\n\nReturns a BoundaryCondition of type bctype, that applies the function func to w, the z-velocity field, on the boundary B, which is one of :x, :y, :z. The boundary function has the signature\n\n`func(ξ, η, t)`\n\nwhere t is time, and ξ and η are coordinates along the boundary, eg: (y, z) for B = :x, (x, z) for B = :y, or (x, y) for B = :z.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.BoundaryConditions.fill_halo_regions!-Tuple{AbstractArray,Any,Any,Vararg{Any,N} where N}","page":"Library","title":"Oceananigans.BoundaryConditions.fill_halo_regions!","text":"Fill halo regions in x, y, and z for a given field.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.BoundaryConditions.fill_halo_regions!-Tuple{Union{Tuple, NamedTuple},Any,Vararg{Any,N} where N}","page":"Library","title":"Oceananigans.BoundaryConditions.fill_halo_regions!","text":"fill_halo_regions!(fields, arch)\n\nFill halo regions for each field in the tuple fields according to their boundary conditions, possibly recursing into fields if it is a nested tuple-of-tuples.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.BoundaryConditions.apply_y_bcs!-Tuple{Any,Any,Any,Vararg{Any,N} where N}","page":"Library","title":"Oceananigans.BoundaryConditions.apply_y_bcs!","text":"apply_y_bcs!(Gc, arch, grid, args...)\n\nApply flux boundary conditions to a field c by adding the associated flux divergence to the source term Gc at the left and right.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.BoundaryConditions.apply_z_bcs!-Tuple{Any,Any,Any,Vararg{Any,N} where N}","page":"Library","title":"Oceananigans.BoundaryConditions.apply_z_bcs!","text":"apply_z_bcs!(Gc, arch, grid, args...)\n\nApply flux boundary conditions to a field c by adding the associated flux divergence to the source term Gc at the top and bottom.\n\n\n\n\n\n","category":"method"},{"location":"library/#Buoyancy-1","page":"Library","title":"Buoyancy","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"Modules = [Oceananigans.Buoyancy]\nPrivate = false\nPages   = [\n    \"Buoyancy/no_buoyancy.jl\",\n    \"Buoyancy/buoyancy_tracer.jl\",\n    \"Buoyancy/seawater_buoyancy.jl\",\n    \"Buoyancy/Buoyancy.jl\",\n    \"Buoyancy/linear_equation_of_state.jl\",\n    \"Buoyancy/nonlinear_equation_of_state.jl\",\n    \"Buoyancy/roquet_idealized_nonlinear_eos.jl\",\n    \"Buoyancy/show_buoyancy.jl\",\n    \"Buoyancy/buoyancy_utils.jl\"\n]","category":"page"},{"location":"library/#Oceananigans.Buoyancy.SeawaterBuoyancy","page":"Library","title":"Oceananigans.Buoyancy.SeawaterBuoyancy","text":"SeawaterBuoyancy{FT, EOS, T, S} <: AbstractBuoyancy{EOS}\n\nBuoyancy model for seawater. T and S are either nothing if both temperature and salinity are active, or of type FT if temperature or salinity are constant, respectively.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Buoyancy.SeawaterBuoyancy","page":"Library","title":"Oceananigans.Buoyancy.SeawaterBuoyancy","text":"SeawaterBuoyancy([FT=Float64;] gravitational_acceleration = g_Earth,\n                              equation_of_state = LinearEquationOfState(FT), \n                              constant_temperature = false, constant_salinity = false)\n\nReturns parameters for a temperature- and salt-stratified seawater buoyancy model with a gravitational_acceleration constant (typically called 'g'), and an equation_of_state that related temperature and salinity (or conservative temperature and absolute salinity) to density anomalies and buoyancy. If either temperature or salinity are specified, buoyancy is calculated\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Buoyancy.∂x_b-Tuple{Any,Any,Any,Any,SeawaterBuoyancy,Any}","page":"Library","title":"Oceananigans.Buoyancy.∂x_b","text":"∂x_b(i, j, k, grid, b::SeawaterBuoyancy, C)\n\nReturns the x-derivative of buoyancy for temperature and salt-stratified water,\n\n_x b = g ( α _x Θ - β _x sᴬ ) \n\nwhere g is gravitational acceleration, α is the thermal expansion coefficient, β is the haline contraction coefficient, Θ is conservative temperature, and sᴬ is absolute salinity.\n\nNote: In Oceananigans, model.tracers.T is conservative temperature and model.tracers.S is absolute salinity.\n\nNote that ∂x_Θ, ∂x_sᴬ, α, and β are all evaluated at cell interfaces in x and cell centers in y and z.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Buoyancy.∂y_b-Tuple{Any,Any,Any,Any,SeawaterBuoyancy,Any}","page":"Library","title":"Oceananigans.Buoyancy.∂y_b","text":"∂y_b(i, j, k, grid, b::SeawaterBuoyancy, C)\n\nReturns the y-derivative of buoyancy for temperature and salt-stratified water,\n\n_y b = g ( α _y Θ - β _y sᴬ ) \n\nwhere g is gravitational acceleration, α is the thermal expansion coefficient, β is the haline contraction coefficient, Θ is conservative temperature, and sᴬ is absolute salinity.\n\nNote: In Oceananigans, model.tracers.T is conservative temperature and model.tracers.S is absolute salinity.\n\nNote that ∂y_Θ, ∂y_sᴬ, α, and β are all evaluated at cell interfaces in y and cell centers in x and z.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Buoyancy.∂z_b-Tuple{Any,Any,Any,Any,SeawaterBuoyancy,Any}","page":"Library","title":"Oceananigans.Buoyancy.∂z_b","text":"∂z_b(i, j, k, grid, b::SeawaterBuoyancy, C)\n\nReturns the vertical derivative of buoyancy for temperature and salt-stratified water,\n\n_z b = N^2 = g ( α _z Θ - β _z sᴬ ) \n\nwhere g is gravitational acceleration, α is the thermal expansion coefficient, β is the haline contraction coefficient, Θ is conservative temperature, and sᴬ is absolute salinity.\n\nNote: In Oceananigans, model.tracers.T is conservative temperature and model.tracers.S is absolute salinity.\n\nNote that ∂z_Θ, ∂z_sᴬ, α, and β are all evaluated at cell interfaces in z and cell centers in x and y.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Buoyancy.BuoyancyTracer","page":"Library","title":"Oceananigans.Buoyancy.BuoyancyTracer","text":"BuoyancyTracer <: AbstractBuoyancy{Nothing}\n\nType indicating that the tracer b represents buoyancy.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Buoyancy.LinearEquationOfState","page":"Library","title":"Oceananigans.Buoyancy.LinearEquationOfState","text":"LinearEquationOfState{FT} <: AbstractEquationOfState\n\nLinear equation of state for seawater.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Buoyancy.LinearEquationOfState","page":"Library","title":"Oceananigans.Buoyancy.LinearEquationOfState","text":"LinearEquationOfState([FT=Float64;] α=1.67e-4, β=7.80e-4)\n\nReturns parameters for a linear equation of state for seawater with thermal expansion coefficient α [K⁻¹] and haline contraction coefficient β [ppt⁻¹]. The buoyancy perturbation associated with a linear equation of state is\n\n    b = g (α T - β S)\n\nDefault constants are taken from Table 1.2 (page 33) of Vallis, \"Atmospheric and Oceanic Fluid Dynamics: Fundamentals and Large-Scale Circulation\" (2ed, 2017).\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Buoyancy.RoquetIdealizedNonlinearEquationOfState","page":"Library","title":"Oceananigans.Buoyancy.RoquetIdealizedNonlinearEquationOfState","text":"RoquetIdealizedNonlinearEquationOfState{F, C, T} <: AbstractNonlinearEquationOfState\n\nParameters associated with the idealized nonlinear equation of state proposed by Roquet et al., \"Defining a Simplified yet 'Realistic' Equation of State for Seawater\", Journal of Physical Oceanography (2015).\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Buoyancy.RoquetIdealizedNonlinearEquationOfState","page":"Library","title":"Oceananigans.Buoyancy.RoquetIdealizedNonlinearEquationOfState","text":"RoquetIdealizedNonlinearEquationOfState([FT=Float64,] flavor, ρ₀=1024.6,\n                                        polynomial_coeffs=optimized_roquet_coeffs[flavor])\n\nReturns parameters for the idealized polynomial nonlinear equation of state with reference density ρ₀ and polynomial_coeffs proposed by Roquet et al., \"Defining a Simplified yet 'Realistic' Equation of State for Seawater\", Journal of Physical Oceanography (2015). The default reference density is ρ₀ = 1024.6 kg m⁻³, the average surface density of seawater in the world ocean.\n\nThe flavor of the nonlinear equation of state is a symbol that selects a set of optimized polynomial coefficients defined in Table 2 of Roquet et al., \"Defining a Simplified yet 'Realistic' Equation of State for Seawater\", Journal of Physical Oceanography (2015), and further discussed in the text surrounding equations (12)–(15). The optimization minimizes errors in estimated horizontal density gradient estiamted from climatological temperature and salinity distributions between the 5 simplified forms chosen by Roquet et. al and the full-fledged TEOS-10 equation of state.\n\nThe equations of state define the density anomaly ρ′, and have the polynomial form\n\n`ρ′(T, S, D) = Σᵢⱼₐ Rᵢⱼₐ Tⁱ Sʲ Dᵃ`,\n\nwhere T is conservative temperature, S is absolute salinity, and D is the geopotential depth, currently just D = -z. The Rᵢⱼₐ are constant coefficients.\n\nFlavors of idealized nonlinear equations of state\n\n- `:linear`: a linear equation of state, `ρ′ = R₁₀₀ * T + R₀₁₀ * S`\n\n- `:cabbeling`: includes quadratic temperature term,\n                `ρ′ = R₁₀₀ * T + R₀₁₀ * S + R₀₂₀ * T^2`\n\n- `:cabbeling_thermobaricity`: includes 'thermobaricity' term,\n                               `ρ′ = R₁₀₀ * T + R₀₁₀ * S + R₀₂₀ * T^2 + R₀₁₁ * T * D`\n\n- `:freezing`: same as `:cabbeling_thermobaricity` with modified constants to increase\n               accuracy near freezing\n\n- `:second_order`: includes quadratic salinity, halibaricity, and thermohaline term,\n                   `ρ′ = R₁₀₀ * T + R₀₁₀ * S + R₀₂₀ * T^2 + R₀₁₁ * T * D`\n                         + R₂₀₀ * S^2 + R₁₀₁ * S * D + R₁₁₀ * S * T`\n\nExample\n\njulia> using Oceananigans\n\njulia> eos = Oceananigans.RoquetIdealizedNonlinearEquationOfState(:cabbeling);\n\njulia> eos.polynomial_coeffs (R₀₁₀ = -0.0844, R₁₀₀ = 0.7718, R₀₂₀ = -0.004561, R₀₁₁ = 0.0, R₂₀₀ = 0.0, R₁₀₁ = 0.0, R₁₁₀ = 0.0)\n\nReferences\n\n- Roquet et al., \"Defining a Simplified yet 'Realistic' Equation of State for\n  Seawater\", Journal of Physical Oceanography (2015).\n\n- \"Thermodynamic Equation of State for Seawater\" (TEOS-10), http://www.teos-10.org\n\n\n\n\n\n","category":"type"},{"location":"library/#Coriolis-1","page":"Library","title":"Coriolis","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"Modules = [Oceananigans.Coriolis]\nPrivate = false\nPages   = [\n    \"Coriolis/Coriolis.jl\",\n    \"Coriolis/no_rotation.jl\",\n    \"Coriolis/f_plane.jl\",\n    \"Coriolis/beta_plane.jl\"\n]","category":"page"},{"location":"library/#Oceananigans.Coriolis.FPlane","page":"Library","title":"Oceananigans.Coriolis.FPlane","text":"FPlane{FT} <: AbstractRotation\n\nA parameter object for constant rotation around a vertical axis.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Coriolis.FPlane","page":"Library","title":"Oceananigans.Coriolis.FPlane","text":"FPlane([FT=Float64;] f=nothing, rotation_rate=Ω_Earth, latitude=nothing)\n\nReturns a parameter object for constant rotation at the angular frequency f/2, and therefore with background vorticity f, around a vertical axis. If f is not specified, it is calculated from rotation_rate and latitude according to the relation `f = 2rotation_ratesind(latitude).\n\nBy default, rotation_rate is assumed to be Earth's.\n\nAlso called FPlane, after the \"f-plane\" approximation for the local effect of a planet's rotation in a planar coordinate system tangent to the planet's surface.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Coriolis.NonTraditionalFPlane","page":"Library","title":"Oceananigans.Coriolis.NonTraditionalFPlane","text":"NonTraditionalFPlane{FT} <: AbstractRotation\n\nA Coriolis implementation that facilitates non-traditional Coriolis terms in the zonal and vertical momentum equations along with the traditional Coriolis terms.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Coriolis.NonTraditionalFPlane","page":"Library","title":"Oceananigans.Coriolis.NonTraditionalFPlane","text":"NonTraditionalFPlane([FT=Float64;] fz=nothing, fy=nothing,\n                                   rotation_rate=Ω_Earth, latitude=nothing)\n\nReturns a parameter object for constant rotation about an axis in the y-z plane with y- and z-components fy/2 and fz/2, and the background vorticity is (0, fy, fz).\n\nIn oceanography fz and fy represent the components of planetary voriticity which are perpendicular and parallel to the ocean surface in a domain in which x, y, z  correspond to the directions east, north, and up.\n\nIf fz and fy are not specified, they are calculated from rotation_rate and latitude according to the relations fz = 2*rotation_rate*sind(latitude) and fy = 2*rotation_rate*cosd(latitude), respectively. By default, rotation_rate is assumed to be Earth's.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Coriolis.BetaPlane","page":"Library","title":"Oceananigans.Coriolis.BetaPlane","text":"BetaPlane{T} <: AbstractRotation\n\nA parameter object for meridionally increasing Coriolis parameter (f = f₀ + βy).\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Coriolis.BetaPlane","page":"Library","title":"Oceananigans.Coriolis.BetaPlane","text":"BetaPlane([T=Float64;] f₀=nothing, β=nothing,\n                       rotation_rate=Ω_Earth, latitude=nothing, radius=R_Earth)\n\nA parameter object for meridionally increasing Coriolis parameter (f = f₀ + βy).\n\nThe user may specify both f₀ and β, or the three parameters rotation_rate, latitude, and radius that specify the rotation rate and radius of a planet, and the central latitude at which the β-plane approximation is to be made.\n\nBy default, the rotation_rate and planet radius is assumed to be Earth's.\n\n\n\n\n\n","category":"type"},{"location":"library/#Diagnostics-1","page":"Library","title":"Diagnostics","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"Modules = [Oceananigans.Diagnostics]\nPrivate = false\nPages   = [\n    \"Diagnostics/Diagnostics.jl\",\n    \"Diagnostics/diagnostics_kernels.jl\",\n    \"Diagnostics/horizontal_average.jl\",\n    \"Diagnostics/timeseries.jl\",\n    \"Diagnostics/cfl.jl\",\n    \"Diagnostics/field_maximum.jl\",\n    \"Diagnostics/nan_checker.jl\"\n]","category":"page"},{"location":"library/#Oceananigans.Diagnostics.HorizontalAverage","page":"Library","title":"Oceananigans.Diagnostics.HorizontalAverage","text":"HorizontalAverage{F, R, P, I, Ω} <: AbstractDiagnostic\n\nA diagnostic for computing horizontal average of a field.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Diagnostics.HorizontalAverage-Tuple{Any}","page":"Library","title":"Oceananigans.Diagnostics.HorizontalAverage","text":"HorizontalAverage(model, field; frequency=nothing, interval=nothing, return_type=Array)\n\nConstruct a HorizontalAverage of field.\n\nAfter the horizontal average is computed it will be stored in the result property.\n\nThe HorizontalAverage can be used as a callable object that computes and returns the horizontal average.\n\nA frequency or interval (or both) can be passed to indicate how often to run this diagnostic if it is part of model.diagnostics. frequency is a number of iterations while interval is a time interval in units of model.clock.time.\n\nA return_type can be used to specify the type returned when the HorizontalAverage is used as a callable object. The default return_type=Array is useful when running a GPU model and you want to save the output to disk by passing it to an output writer.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Diagnostics.run_diagnostic-Tuple{Any,HorizontalAverage}","page":"Library","title":"Oceananigans.Diagnostics.run_diagnostic","text":"run_diagnostic(model, havg::HorizontalAverage{NTuple{1}})\n\nCompute the horizontal average of havg.field and store the result in havg.result.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Diagnostics.CFL","page":"Library","title":"Oceananigans.Diagnostics.CFL","text":"CFL{D, S}\n\nAn object for computing the Courant-Freidrichs-Lewy (CFL) number.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Diagnostics.CFL-Tuple{Any}","page":"Library","title":"Oceananigans.Diagnostics.CFL","text":"CFL(Δt [, timescale=Oceananigans.cell_advection_timescale])\n\nReturns an object for computing the Courant-Freidrichs-Lewy (CFL) number associated with time step or TimeStepWizard Δt and timescale.\n\nSee also AdvectiveCFL and DiffusiveCFL.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Diagnostics.AdvectiveCFL-Tuple{Any}","page":"Library","title":"Oceananigans.Diagnostics.AdvectiveCFL","text":"AdvectiveCFL(Δt)\n\nReturns an object for computing the Courant-Freidrichs-Lewy (CFL) number associated with time step or TimeStepWizard Δt and the time scale for advection across a cell.\n\nExample\n\njulia> model = IncompressibleModel(grid=RegularCartesianGrid(size=(16, 16, 16), length=(8, 8, 8)));\n\njulia> cfl = AdvectiveCFL(1.0);\n\njulia> data(model.velocities.u) .= π;\n\njulia> cfl(model)\n6.283185307179586\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Diagnostics.DiffusiveCFL-Tuple{Any}","page":"Library","title":"Oceananigans.Diagnostics.DiffusiveCFL","text":"DiffusiveCFL(Δt)\n\nReturns an object for computing the diffusive Courant-Freidrichs-Lewy (CFL) number associated with time step or TimeStepWizard Δt and the time scale for diffusion across a cell associated with model.closure.\n\nThe maximum diffusive CFL number among viscosity and all tracer diffusivities is returned.\n\nExample\n\njulia> model = IncompressibleModel(grid=RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1)));\n\njulia> dcfl = DiffusiveCFL(0.1);\n\njulia> dcfl(model)\n2.688e-5\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Diagnostics.FieldMaximum","page":"Library","title":"Oceananigans.Diagnostics.FieldMaximum","text":"FieldMaximum(mapping, field)\n\nAn object for calculating the maximum of a mapping function applied element-wise to field.\n\nExamples\n\njulia> model = IncompressibleModel(grid=RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1)));\n\njulia> max_abs_u = FieldMaximum(abs, model.velocities.u);\n\njulia> max_w² = FieldMaximum(x->x^2, model.velocities.w);\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Diagnostics.NaNChecker","page":"Library","title":"Oceananigans.Diagnostics.NaNChecker","text":"NaNChecker{F} <: AbstractDiagnostic\n\nA diagnostic that checks for NaN values and aborts the simulation if any are found.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Diagnostics.NaNChecker-Tuple{Any}","page":"Library","title":"Oceananigans.Diagnostics.NaNChecker","text":"NaNChecker(model; frequency, fields)\n\nConstruct a NaNChecker for model. fields should be a Dict{Symbol,Field}. A frequency should be passed to indicate how often to check for NaNs (in number of iterations).\n\n\n\n\n\n","category":"method"},{"location":"library/#Fields-1","page":"Library","title":"Fields","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"Modules = [Oceananigans.Fields]\nPrivate = false\nPages   = [\n    \"Fields/Fields.jl\",\n    \"Fields/field.jl\",\n    \"Fields/set!.jl\",\n    \"Fields/show_fields.jl\",\n    \"Fields/field_utils.jl\"\n]","category":"page"},{"location":"library/#Oceananigans.Fields.AbstractField","page":"Library","title":"Oceananigans.Fields.AbstractField","text":"AbstractField{X, Y, Z, A, G}\n\nAbstract supertype for fields located at (X, Y, Z) with data stored in a container of type A. The field is defined on a grid G.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Fields.Field","page":"Library","title":"Oceananigans.Fields.Field","text":"Field{X, Y, Z, A, G, B} <: AbstractField{X, Y, Z, A, G}\n\nA field defined at the location (X, Y, Z), each of which can be either Cell or Face, and with data stored in a container of type A (typically an array). The field is defined on a grid G and has field boundary conditions B.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Fields.Field","page":"Library","title":"Oceananigans.Fields.Field","text":"Field(X, Y, Z, arch, grid, [  bcs = FieldBoundaryConditions(grid, (X, Y, Z)),\n                             data = zeros(arch, grid, (X, Y, Z)) ] )\n\nConstruct a Field on grid with data on architecture arch with boundary conditions bcs. Each of (X, Y, Z) is either Cell or Face and determines  the field's location in (x, y, z).\n\nExample\n\njulia> ω = Field(Face, Face, Cell, CPU(), RegularCartesianmodel.grid)\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Fields.Field-Tuple{Tuple,Vararg{Any,N} where N}","page":"Library","title":"Oceananigans.Fields.Field","text":"Field(L::Tuple, arch, grid, data, bcs)\n\nConstruct a Field at the location defined by the 3-tuple L, whose elements are Cell or Face.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Fields.CellField","page":"Library","title":"Oceananigans.Fields.CellField","text":"CellField([ FT=eltype(grid) ], arch::AbstractArchitecture, grid, \n          [  bcs = TracerBoundaryConditions(grid),\n            data = zeros(FT, arch, grid, (Cell, Cell, Cell) ] )\n\nReturn a Field{Cell, Cell, Cell} on architecture arch and grid containing data with field boundary conditions bcs.\n\n\n\n\n\n","category":"function"},{"location":"library/#Oceananigans.Fields.XFaceField","page":"Library","title":"Oceananigans.Fields.XFaceField","text":"XFaceField([ FT=eltype(grid) ], arch::AbstractArchitecture, grid,\n           [  bcs = UVelocityBoundaryConditions(grid),\n             data = zeros(FT, arch, grid, (Face, Cell, Cell) ] )\n\nReturn a Field{Face, Cell, Cell} on architecture arch and grid containing data with field boundary conditions bcs.\n\n\n\n\n\n","category":"function"},{"location":"library/#Oceananigans.Fields.YFaceField","page":"Library","title":"Oceananigans.Fields.YFaceField","text":"YFaceField([ FT=eltype(grid) ], arch::AbstractArchitecture, grid,\n           [  bcs = VVelocityBoundaryConditions(grid),\n             data = zeros(FT, arch, grid, (Cell, Face, Cell)) ] )\n\nReturn a Field{Cell, Face, Cell} on architecture arch and grid containing data with field boundary conditions bcs.\n\n\n\n\n\n","category":"function"},{"location":"library/#Oceananigans.Fields.ZFaceField","page":"Library","title":"Oceananigans.Fields.ZFaceField","text":"ZFaceField([ FT=eltype(grid) ], arch::AbstractArchitecture, grid,\n           [  bcs = WVelocityBoundaryConditions(grid),\n             data = zeros(FT, arch, grid, (Cell, Cell, Face)) ] )\n\nReturn a Field{Cell, Cell, Face} on architecture arch and grid containing data with field boundary conditions bcs.\n\n\n\n\n\n","category":"function"},{"location":"library/#Oceananigans.Fields.data-Tuple{Any}","page":"Library","title":"Oceananigans.Fields.data","text":"Returns f.data for f::Field or f for `f::AbstractArray.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Fields.interior-Union{Tuple{Field{X,Y,Z,A,G,B} where B where G where A}, Tuple{Z}, Tuple{Y}, Tuple{X}} where Z where Y where X","page":"Library","title":"Oceananigans.Fields.interior","text":"Returns a view of f that excludes halo points.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Fields.interiorparent-Union{Tuple{Field{X,Y,Z,A,G,B} where B where G where A}, Tuple{Z}, Tuple{Y}, Tuple{X}} where Z where Y where X","page":"Library","title":"Oceananigans.Fields.interiorparent","text":"Returns a reference (not a view) to the interior points of field.data.parent.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Fields.location-Union{Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}, Tuple{Z}, Tuple{Y}, Tuple{X}} where Z where Y where X","page":"Library","title":"Oceananigans.Fields.location","text":"Returns the location (X, Y, Z) of an AbstractField{X, Y, Z}.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Fields.set!-Tuple{Any}","page":"Library","title":"Oceananigans.Fields.set!","text":"set!(model; kwargs...)\n\nSet velocity and tracer fields of model. The keyword arguments kwargs... take the form name=data, where name refers to one of the fields of model.velocities or model.tracers, and the data may be an array, a function with arguments (x, y, z), or any data type for which a set!(ϕ::AbstractField, data) function exists.\n\nExample\n\nmodel = IncompressibleModel(grid=RegularCartesianGrid(size=(32, 32, 32), length=(1, 1, 1))\n\n# Set u to a parabolic function of z, v to random numbers damped\n# at top and bottom, and T to some silly array of half zeros,\n# half random numbers.\n\nu₀(x, y, z) = z/model.grid.Lz * (1 + z/model.grid.Lz)\nv₀(x, y, z) = 1e-3 * rand() * u₀(x, y, z)\n\nT₀ = rand(size(model.grid)...)\nT₀[T₀ .< 0.5] .= 0\n\nset!(model, u=u₀, v=v₀, T=T₀)\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Fields.set!-Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A<:(OffsetArrays.OffsetArray{T,D,#s99} where #s99<:Array where D where T) where Z where Y where X,Array}","page":"Library","title":"Oceananigans.Fields.set!","text":"Set the CPU field u to the array v.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Fields.set!-Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A<:(OffsetArrays.OffsetArray{T,D,#s99} where #s99<:Array where D where T) where Z where Y where X,Function}","page":"Library","title":"Oceananigans.Fields.set!","text":"Set the CPU field u data to the function f(x, y, z).\n\n\n\n\n\n","category":"method"},{"location":"library/#Forcing-1","page":"Library","title":"Forcing","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"Modules = [Oceananigans.Forcing]\nPrivate = false\nPages   = [\n    \"Forcing/Forcing.jl\",\n    \"Forcing/simple_forcing.jl\",\n    \"Forcing/model_forcing.jl\"\n]","category":"page"},{"location":"library/#Oceananigans.Forcing.SimpleForcing","page":"Library","title":"Oceananigans.Forcing.SimpleForcing","text":"SimpleForcing{X, Y, Z, F, P}\n\nCallable object for specifying 'simple' forcings of x, y, z, t and optionally parameters of type P at location X, Y, Z.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Forcing.SimpleForcing-Tuple{Tuple,Function}","page":"Library","title":"Oceananigans.Forcing.SimpleForcing","text":"SimpleForcing([location=(Cell, Cell, Cell),] forcing; parameters=nothing)\n\nConstruct forcing for a field at location using forcing::Function, and optionally with parameters. If parameters=nothing, forcing must have the signature\n\n`forcing(x, y, z, t)`;\n\notherwise it must have the signature\n\n`forcing(x, y, z, t, parameters)`.\n\nExamples\n\njulia> const a = 2.1\n\njulia> fun_forcing(x, y, z, t) = a * exp(z) * cos(t)\n\njulia> u_forcing = SimpleForcing(fun_forcing)\n\njulia> parameterized_forcing(x, y, z, t, p) = p.μ * exp(z/p.λ) * cos(p.ω*t)\n\njulia> v_forcing = SimpleForcing(parameterized_forcing, parameters=(μ=42, λ=0.1, ω=π))\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Forcing.ModelForcing-Tuple{}","page":"Library","title":"Oceananigans.Forcing.ModelForcing","text":"ModelForcing(; u=zeroforcing, v=zeroforcing, w=zeroforcing, tracer_forcings...)\n\nReturn a named tuple of forcing functions for each solution field.\n\nExample\n\njulia> u_forcing = SimpleForcing((x, y, z, t) -> exp(z) * cos(t))\n\njulia> model = IncompressibleModel(forcing=ModelForcing(u=u_forcing))\n\n\n\n\n\n","category":"method"},{"location":"library/#Grids-1","page":"Library","title":"Grids","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"Modules = [Oceananigans.Grids]\nPrivate = false\nPages   = [\n    \"Grids/Grids.jl\",\n    \"Grids/grid_utils.jl\",\n    \"Grids/regular_cartesian_grid.jl\"\n]","category":"page"},{"location":"library/#Oceananigans.Grids.AbstractGrid","page":"Library","title":"Oceananigans.Grids.AbstractGrid","text":"AbstractGrid{FT, TX, TY, TZ}\n\nAbstract supertype for grids with elements of type FT and topology {TX, TY, TZ}.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Grids.AbstractTopology","page":"Library","title":"Oceananigans.Grids.AbstractTopology","text":"AbstractTopology\n\nAbstract supertype for grid topologies.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Grids.Bounded","page":"Library","title":"Oceananigans.Grids.Bounded","text":"Bounded\n\nGrid topology for bounded dimensions. These could be wall-bounded dimensions or dimensions\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Grids.Flat","page":"Library","title":"Oceananigans.Grids.Flat","text":"Flat\n\nGrid topology for flat dimensions, generally with one grid point, along which the solution is uniform and does not vary.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Grids.Periodic","page":"Library","title":"Oceananigans.Grids.Periodic","text":"Periodic\n\nGrid topology for periodic dimensions.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Grids.RegularCartesianGrid","page":"Library","title":"Oceananigans.Grids.RegularCartesianGrid","text":"RegularCartesianGrid{FT, TX, TY, TZ, R} <: AbstractGrid{FT, TX, TY, TZ}\n\nA Cartesian grid with with constant grid spacings Δx, Δy, and Δz between cell centers and cell faces, elements of type FT, topology {TX, TY, TZ}, and coordinate ranges of type R.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Grids.RegularCartesianGrid","page":"Library","title":"Oceananigans.Grids.RegularCartesianGrid","text":"RegularCartesianGrid([FT=Float64]; size, length, topology=(Periodic, Periodic, Bounded),\n                     x=nothing, y=nothing, z=nothing)\n\nCreates a RegularCartesianGrid with size = (Nx, Ny, Nz) grid points.\n\nThe physical length of the domain can be specified via x, y, and z keyword arguments indicating the left and right endpoints of each dimensions, e.g. x=(-π, π) or via the length argument, e.g. length=(Lx, Ly, Lz) which specifies the length of each dimension in which case 0 ≤ x ≤ Lx, 0 ≤ y ≤ Ly, and -Lz ≤ z ≤ 0.\n\nA grid topology may be specified via a tuple assigning one of Periodic, Bounded, andFlatto each dimension. By default, a horizontally periodic grid topology(Periodic, Periodic, Flat)` is assumed.\n\nConstants are stored using floating point values of type FT. By default this is Float64. Make sure to specify the desired FT if not using Float64.\n\nGrid properties\n\n(xC, yC, zC)::AbstractRange: (x, y, z) coordinates of cell centers\n(xF, yF, zF)::AbstractRange: (x, y, z) coordinates of cell faces\n(Hx, Hy, Hz)::Int: Halo size in the (x, y, z)-direction\n(Tx, Ty, Tz)::Int: \"Total\" grid size (interior + halo points) in the (x, y, z)-direction\n\nExamples\n\njulia> grid = RegularCartesianGrid(size=(32, 32, 32), length=(1, 2, 3))\nRegularCartesianGrid{Float64}\ndomain: x ∈ [0.0, 1.0], y ∈ [0.0, 2.0], z ∈ [0.0, -3.0]\n  resolution (Nx, Ny, Nz) = (32, 32, 32)\n   halo size (Hx, Hy, Hz) = (1, 1, 1)\ngrid spacing (Δx, Δy, Δz) = (0.03125, 0.0625, 0.09375)\n\njulia> grid = RegularCartesianGrid(Float32; size=(32, 32, 16), x=(0, 8), y=(-10, 10), z=(-π, π))\nRegularCartesianGrid{Float32}\ndomain: x ∈ [0.0, 8.0], y ∈ [-10.0, 10.0], z ∈ [3.141592653589793, -3.141592653589793]\n  resolution (Nx, Ny, Nz) = (32, 32, 16)\n   halo size (Hx, Hy, Hz) = (1, 1, 1)\ngrid spacing (Δx, Δy, Δz) = (0.25f0, 0.625f0, 0.3926991f0)\n\n\n\n\n\n","category":"type"},{"location":"library/#Models-1","page":"Library","title":"Models","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"Modules = [Oceananigans.Models]\nPrivate = false\nPages   = [\n    \"Models/Models.jl\",\n    \"Models/clock.jl\",\n    \"Models/model.jl\",\n    \"Models/channel_model.jl\",\n    \"Models/non_dimensional_model.jl\",\n    \"Models/show_models.jl\",\n    \"Models/model_utils.jl\"\n]","category":"page"},{"location":"library/#Oceananigans.Models.state-Tuple{Any}","page":"Library","title":"Oceananigans.Models.state","text":"state(model)\n\nReturns a NamedTuple with fields velocities, tracers, diffusivities, tendencies  corresponding to NamedTuples of OffsetArrays that reference each of the field's data.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Models.Clock","page":"Library","title":"Oceananigans.Models.Clock","text":"Clock{T<:Number}\n\nClock{T}(time, iteration)\n\nKeeps track of the current time and iteration number. The time::T can be either a number of a DateTime object.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Models.NonDimensionalModel-Tuple{}","page":"Library","title":"Oceananigans.Models.NonDimensionalModel","text":"NonDimensionalModel(; N, L, Re, Pr=0.7, Ro=Inf, float_type=Float64, kwargs...)\n\nConstruct a \"Non-dimensional\" Model with resolution N, domain extent L, precision float_type, and the four non-dimensional numbers:\n\n* `Re = U λ / ν` (Reynolds number)\n* `Pr = U λ / κ` (Prandtl number)\n* `Ro = U / f λ` (Rossby number)\n\nfor characteristic velocity scale U, length-scale λ, viscosity ν, tracer diffusivity κ, and Coriolis parameter f. Buoyancy is scaled with λ U², so that the Richardson number is Ri=B, where B is a non-dimensional buoyancy scale set by the user via initial conditions or forcing.\n\nNote that N, L, and Re are required.\n\nAdditional kwargs are passed to the regular IncompressibleModel constructor.\n\n\n\n\n\n","category":"method"},{"location":"library/#Output-writers-1","page":"Library","title":"Output writers","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"Modules = [Oceananigans.OutputWriters]\nPrivate = false\nPages   = [\n    \"OutputWriters/OutputWriters.jl\",\n    \"OutputWriters/output_writer_utils.jl\",\n    \"OutputWriters/jld2_output_writer.jl\",\n    \"OutputWriters/netcdf_output_writer.jl\",\n    \"OutputWriters/checkpointer.jl\"\n]","category":"page"},{"location":"library/#Oceananigans.OutputWriters.FieldOutput","page":"Library","title":"Oceananigans.OutputWriters.FieldOutput","text":"FieldOutput([return_type=Array], field)\n\nReturns a FieldOutput type intended for use with the JLD2OutputWriter. Calling FieldOutput(model) returns return_type(field.data.parent).\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.OutputWriters.JLD2OutputWriter","page":"Library","title":"Oceananigans.OutputWriters.JLD2OutputWriter","text":"JLD2OutputWriter{F, I, O, IF, IN, KW} <: AbstractOutputWriter\n\nAn output writer for writing to JLD2 files.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.OutputWriters.JLD2OutputWriter-Tuple{Any,Any}","page":"Library","title":"Oceananigans.OutputWriters.JLD2OutputWriter","text":"JLD2OutputWriter(model, outputs; interval=nothing, frequency=nothing, dir=\".\",\n                 prefix=\"\", init=noinit, including=[:grid, :coriolis, :buoyancy, :closure],\n                 part=1, max_filesize=Inf, force=false, async=false, verbose=false, jld2_kw=Dict{Symbol, Any}())\n\nConstruct a JLD2OutputWriter that writes label, func pairs in outputs (which can be a Dict or NamedTuple) to a JLD2 file, where label is a symbol that labels the output and func is a function of the form func(model) that returns the data to be saved.\n\nKeyword arguments\n\nfrequency::Int   : Save output every n model iterations.\ninterval::Int    : Save output every t units of model clock time.\ndir::String      : Directory to save output to. Default: \".\" (current working directory).\nprefix::String   : Descriptive filename prefixed to all output files. Default: \"\".\ninit::Function   : A function of the form init(file, model) that runs when a JLD2 output file is initialized.                      Default: noinit(args...) = nothing.\nincluding::Array : List of model properties to save with every file. By default, the grid, equation of state,                      Coriolis parameters, buoyancy parameters, and turbulence closure parameters are saved.\npart::Int        : The starting part number used if max_filesize is finite. Default: 1.\nmax_filesize::Int: The writer will stop writing to the output file once the file size exceeds max_filesize, and                      write to a new one with a consistent naming scheme ending in part1, part2, etc. Defaults to                      Inf.\nforce::Bool      : Remove existing files if their filenames conflict. Default: false.\nasync::Bool      : Write output asynchronously. Default: false.\nverbose::Bool    : Log what the output writer is doing with statistics on compute/write times and file sizes.                      Default: false.\njld2_kw::Dict    : Dict of kwargs to be passed to jldopen when data is written.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.OutputWriters.FieldOutputs-Tuple{Any}","page":"Library","title":"Oceananigans.OutputWriters.FieldOutputs","text":"FieldOutputs(fields)\n\nReturns a dictionary of FieldOutput objects with key, value pairs corresponding to each name and value in the NamedTuple fields. Intended for use with JLD2OutputWriter.\n\nExamples\n\njulia> output_writer = JLD2OutputWriter(model, FieldOutputs(model.velocities), frequency=1);\n\njulia> keys(output_writer.outputs)\nBase.KeySet for a Dict{Symbol,FieldOutput{UnionAll,F} where F} with 3 entries. Keys:\n  :w\n  :v\n  :u\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.OutputWriters.NetCDFOutputWriter","page":"Library","title":"Oceananigans.OutputWriters.NetCDFOutputWriter","text":"NetCDFOutputWriter <: AbstractOutputWriter\n\nAn output writer for writing to NetCDF files.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.OutputWriters.write_grid_and_attributes-Tuple{Any}","page":"Library","title":"Oceananigans.OutputWriters.write_grid_and_attributes","text":"write_grid_and_attributes(model; filename=\"grid.nc\", mode=\"c\",\n                          compression=0, attributes=Dict(), slice_kw...)\n\nWrites grid and global attributes to filename. By default writes information to a standalone grid.nc file.\n\nKeyword arguments\n\nfilename  : File name to be saved under.\nmode: NetCDF file is opened in either clobber (\"c\") or append (\"a\") mode. Default: \"c\".\ncompression: Defines the compression level of data from 0-9. Default: 0.\nattributes: Global attributes. Default: Dict().\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.OutputWriters.write_output-Tuple{Any,NetCDFOutputWriter}","page":"Library","title":"Oceananigans.OutputWriters.write_output","text":"write_output(model, OutputWriter)\n\nWrites output to the netcdf file at specified intervals. Increments the time dimension every time an output is written to the file.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.OutputWriters.Checkpointer","page":"Library","title":"Oceananigans.OutputWriters.Checkpointer","text":"Checkpointer{I, T, P, A} <: AbstractOutputWriter\n\nAn output writer for checkpointing models to a JLD2 file from which models can be restored.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.OutputWriters.Checkpointer-Tuple{Any}","page":"Library","title":"Oceananigans.OutputWriters.Checkpointer","text":"Checkpointer(model; frequency=nothing, interval=nothing, dir=\".\",\n             prefix=\"checkpoint\", force=false, verbose=false,\n             properties = [:architecture, :boundary_conditions, :grid, :clock, :coriolis,\n                           :buoyancy, :closure, :velocities, :tracers, :timestepper])\n\nConstruct a Checkpointer that checkpoints the model to a JLD2 file every so often as specified by frequency or interval. The model.clock.iteration is included in the filename to distinguish between multiple checkpoint files.\n\nNote that extra model properties can be safely specified, but removing crucial properties such as :velocities will make restoring from the checkpoint impossible.\n\nThe checkpoint file is generated by serializing model properties to JLD2. However, functions cannot be serialized to disk (at least not with JLD2). So if a model property contains a reference somewhere in its hierarchy it will not be included in the checkpoint file (and you will have to manually restore them).\n\nKeyword arguments\n\nfrequency::Int   : Save output every n model iterations.\ninterval::Int    : Save output every t units of model clock time.\ndir::String      : Directory to save output to. Default: \".\" (current working directory).\nprefix::String   : Descriptive filename prefixed to all output files. Default: \"checkpoint\".\nforce::Bool      : Remove existing files if their filenames conflict. Default: false.\nverbose::Bool    : Log what the output writer is doing with statistics on compute/write times and file sizes.                      Default: false.\nproperties::Array: List of model properties to checkpoint.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.OutputWriters.restore_from_checkpoint-Tuple{Any}","page":"Library","title":"Oceananigans.OutputWriters.restore_from_checkpoint","text":"restore_from_checkpoint(filepath; kwargs=Dict())\n\nRestore a model from the checkpoint file stored at filepath. kwargs can be passed to the model constructor, which can be especially useful if you need to manually restore forcing functions or boundary conditions that rely on functions.\n\n\n\n\n\n","category":"method"},{"location":"library/#Time-steppers-1","page":"Library","title":"Time steppers","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"Modules = [Oceananigans.TimeSteppers]\nPrivate = false\nPages   = [\n    \"TimeSteppers/TimeSteppers.jl\",\n    \"TimeSteppers/kernels.jl\",\n    \"TimeSteppers/adams_bashforth.jl\"\n]","category":"page"},{"location":"library/#Oceananigans.TimeSteppers.AdamsBashforthTimeStepper","page":"Library","title":"Oceananigans.TimeSteppers.AdamsBashforthTimeStepper","text":"AdamsBashforthTimeStepper(float_type, arch, grid, tracers, χ=0.125;\n                          Gⁿ = TendencyFields(arch, grid, tracers),\n                          G⁻ = TendencyFields(arch, grid, tracers))\n\nReturn an AdamsBashforthTimeStepper object with tendency fields on arch and grid with AB2 parameter χ. The tendency fields can be specified via optional kwargs.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.TimeSteppers.time_step!-Tuple{IncompressibleModel{#s35,E,A,G,T,B,R,SW,U,C,Φ,F,S,K} where K where S where F where Φ where C where U where SW where R where B where T where G where A<:Oceananigans.Architectures.AbstractArchitecture where E where #s35<:AdamsBashforthTimeStepper,Any}","page":"Library","title":"Oceananigans.TimeSteppers.time_step!","text":"time_step!(model::IncompressibleModel{<:AdamsBashforthTimeStepper}, Δt; euler=false)\n\nStep forward model one time step Δt with a 2nd-order Adams-Bashforth method and pressure-correction substep. Setting euler=true will take a forward Euler time step.\n\n\n\n\n\n","category":"method"},{"location":"library/#Simulations-1","page":"Library","title":"Simulations","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"Modules = [Oceananigans.Simulations]\nPrivate = false\nPages   = [\"Simulations.jl\"]","category":"page"},{"location":"library/#Oceananigans.Simulations.Simulation-Tuple{Any}","page":"Library","title":"Oceananigans.Simulations.Simulation","text":"Simulation(model; Δt,\n     stop_criteria = Function[iteration_limit_exceeded, stop_time_exceeded, wall_time_limit_exceeded],\n    stop_iteration = Inf,\n         stop_time = Inf,\n   wall_time_limit = Inf,\n       diagnostics = OrderedDict{Symbol, AbstractDiagnostic}(),\n    output_writers = OrderedDict{Symbol, AbstractOutputWriter}(),\n          progress = nothing,\nprogress_frequency = 1,\n        parameters = nothing)\n\nConstruct an Oceananigans.jl Simulation for a model with time step Δt.\n\nKeyword arguments\n\nΔt: Required keyword argument specifying the simulation time step. Can be a Number for constant time steps or a TimeStepWizard for adaptive time-stepping.\nstop_criteria: A list of functions or callable objects (each taking a single argument, the simulation). If any of the functions return true when the stop criteria is evaluated the simulation will stop.\nstop_iteration: Stop the simulation after this many iterations.\nstop_time: Stop the simulation once this much model clock time has passed.\nwall_time_limit: Stop the simulation if it's been running for longer than this many  seconds of wall clock time.\nprogress: A function with a single argument, the simulation. Will be called every progress_frequency iterations. Useful for logging simulation health.\nprogress_frequency: How often to update the time step, check stop criteria, and call progress function (in number of iterations).\nparameters: Parameters that can be accessed in the progress function.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Simulations.run!-Tuple{Any}","page":"Library","title":"Oceananigans.Simulations.run!","text":"run!(simulation)\n\nRun a simulation until one of the stop criteria evaluates to true. The simulation will then stop.\n\n\n\n\n\n","category":"method"},{"location":"library/#Tubrulence-closures-1","page":"Library","title":"Tubrulence closures","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"Modules = [Oceananigans.TurbulenceClosures]\nPrivate = false\nPages   = [\n    \"TurbulenceClosures/TurbulenceClosures.jl\",\n    \"TurbulenceClosures/turbulence_closure_utils.jl\",\n    \"TurbulenceClosures/closure_operators.jl\",\n    \"TurbulenceClosures/viscous_dissipation_operators.jl\",\n    \"TurbulenceClosures/diffusion_operators.jl\",\n    \"TurbulenceClosures/velocity_tracer_gradients.jl\",\n    \"TurbulenceClosures/closure_tuples.jl\",\n    \"TurbulenceClosures/turbulence_closure_diagnostics.jl\",\n    \"TurbulenceClosures/turbulence_closure_implementations/anisotropic_biharmonic_diffusivity.jl\",\n    \"TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl\",\n    \"TurbulenceClosures/turbulence_closure_implementations/constant_isotropic_diffusivity.jl\",\n    \"TurbulenceClosures/turbulence_closure_implementations/verstappen_anisotropic_minimum_dissipation.jl\",\n    \"TurbulenceClosures/turbulence_closure_implementations/blasius_smagorinsky.jl\",\n    \"TurbulenceClosures/turbulence_closure_implementations/constant_anisotropic_diffusivity.jl\",\n    \"TurbulenceClosures/turbulence_closure_implementations/rozema_anisotropic_minimum_dissipation.jl\",\n    \"TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl\"\n]","category":"page"},{"location":"library/#Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation","page":"Library","title":"Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation","text":"AnisotropicMinimumDissipation\n\nAn alias for VerstappenAnisotropicMinimumDissipation.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.TurbulenceClosures.ConstantSmagorinsky","page":"Library","title":"Oceananigans.TurbulenceClosures.ConstantSmagorinsky","text":"ConstantSmagorinsky\n\nAn alias for SmagorinskyLilly.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.TurbulenceClosures.IsotropicViscosity","page":"Library","title":"Oceananigans.TurbulenceClosures.IsotropicViscosity","text":"IsotropicViscosity{FT} <: TurbulenceClosure{FT}\n\nAbstract supertype for turbulence closures that are defined by an isotropic viscosity and isotropic diffusivities with model parameters stored as properties of type FT.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.TurbulenceClosures.∂ⱼ_2ν_Σ₁ⱼ-Tuple{Any,Any,Any,Any,IsotropicViscosity,Any,Any}","page":"Library","title":"Oceananigans.TurbulenceClosures.∂ⱼ_2ν_Σ₁ⱼ","text":"∂ⱼ_2ν_Σ₁ⱼ(i, j, k, grid, closure, U, diffusivities)\n\nReturn the x-component of the turbulent diffusive flux divergence:\n\n∂x(2 ν Σ₁₁) + ∂y(2 ν Σ₁₁) + ∂z(2 ν Σ₁₁)\n\nat the location fcc.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.TurbulenceClosures.∂ⱼ_2ν_Σ₂ⱼ-Tuple{Any,Any,Any,Any,IsotropicViscosity,Any,Any}","page":"Library","title":"Oceananigans.TurbulenceClosures.∂ⱼ_2ν_Σ₂ⱼ","text":"∂ⱼ_2ν_Σ₂ⱼ(i, j, k, grid, closure, U, diffusivities)\n\nReturn the y-component of the turbulent diffusive flux divergence:\n\n∂x(2 ν Σ₂₁) + ∂y(2 ν Σ₂₂) + ∂z(2 ν Σ₂₂)\n\nat the location ccf.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.TurbulenceClosures.∂ⱼ_2ν_Σ₃ⱼ-Tuple{Any,Any,Any,Any,IsotropicViscosity,Any,Any}","page":"Library","title":"Oceananigans.TurbulenceClosures.∂ⱼ_2ν_Σ₃ⱼ","text":"∂ⱼ_2ν_Σ₃ⱼ(i, j, k, grid, closure, diffusivities)\n\nReturn the z-component of the turbulent diffusive flux divergence:\n\n∂x(2 ν Σ₃₁) + ∂y(2 ν Σ₃₂) + ∂z(2 ν Σ₃₃)\n\nat the location ccf.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.TurbulenceClosures.AnisotropicBiharmonicDiffusivity","page":"Library","title":"Oceananigans.TurbulenceClosures.AnisotropicBiharmonicDiffusivity","text":"AnisotropicBiharmonicDiffusivity{FT, KH, KV}\n\nParameters for anisotropic biharmonic diffusivity models.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.TurbulenceClosures.AnisotropicBiharmonicDiffusivity","page":"Library","title":"Oceananigans.TurbulenceClosures.AnisotropicBiharmonicDiffusivity","text":"AnisotropicBiharmonicDiffusivity(; νh, νv, κh, κv)\n\nReturns parameters for a fourth-order, anisotropic biharmonic diffusivity closure with constant horizontal and vertical biharmonic viscosities νh, νv and constant horizontal and vertical tracer biharmonic diffusivities κh, κv. κh and κv may be NamedTuples with fields corresponding to each tracer, or a single number to be a applied to all tracers. The tracer flux divergence associated with an anisotropic biharmonic diffusivity is, for example\n\n    ᵢ κᵢⱼ ⱼc = (κh ⁴h + κv ⁴z) c\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.TurbulenceClosures.SmagorinskyLilly","page":"Library","title":"Oceananigans.TurbulenceClosures.SmagorinskyLilly","text":"SmagorinskyLilly{FT} <: AbstractSmagorinsky{FT}\n\nParameters for the Smagorinsky-Lilly turbulence closure.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.TurbulenceClosures.SmagorinskyLilly","page":"Library","title":"Oceananigans.TurbulenceClosures.SmagorinskyLilly","text":"SmagorinskyLilly([FT=Float64;] C=0.23, Pr=1, ν=1.05e-6, κ=1.46e-7)\n\nReturn a SmagorinskyLilly type associated with the turbulence closure proposed by Lilly (1962) and Smagorinsky (1958, 1963), which has an eddy viscosity of the form\n\n`νₑ = (C * Δᶠ)² * √(2Σ²) * √(1 - Cb * N² / Σ²) + ν`,\n\nand an eddy diffusivity of the form\n\n`κₑ = (νₑ - ν) / Pr + κ`\n\nwhere Δᶠ is the filter width, Σ² = ΣᵢⱼΣᵢⱼ is the double dot product of the strain tensor Σᵢⱼ, Pr is the turbulent Prandtl number, and N² is the total buoyancy gradient, and Cb is a constant the multiplies the Richardson number modification to the eddy viscosity.\n\nKeyword arguments\n\n- `C`  : Model constant\n- `Cb` : Buoyancy term multipler (`Cb = 0` turns it off, `Cb ≠ 0` turns it on.\n         Typically `Cb=1/Pr`.)\n- `Pr` : Turbulent Prandtl numbers for each tracer. Either a constant applied to every\n         tracer, or a `NamedTuple` with fields for each tracer individually.\n- `ν`  : Constant background viscosity for momentum\n- `κ`  : Constant background diffusivity for tracer. Can either be a single number\n         applied to all tracers, or `NamedTuple` of diffusivities corresponding to each\n         tracer.\n\nReferences\n\nSmagorinsky, J. \"On the numerical integration of the primitive equations of motion for     baroclinic flow in a closed region.\" Monthly Weather Review (1958)\n\nLilly, D. K. \"On the numerical simulation of buoyant convection.\" Tellus (1962)\n\nSmagorinsky, J. \"General circulation experiments with the primitive equations: I.     The basic experiment.\" Monthly weather review (1963)\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.TurbulenceClosures.∇_κ_∇c-Tuple{Any,Any,Any,Any,Oceananigans.TurbulenceClosures.AbstractSmagorinsky,Any,Any,Any,Vararg{Any,N} where N}","page":"Library","title":"Oceananigans.TurbulenceClosures.∇_κ_∇c","text":"∇_κ_∇c(i, j, k, grid, c, closure, diffusivities)\n\nReturn the diffusive flux divergence ∇ ⋅ (κ ∇ c) for the turbulence closure, where c is an array of scalar data located at cell centers.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.TurbulenceClosures.ConstantIsotropicDiffusivity","page":"Library","title":"Oceananigans.TurbulenceClosures.ConstantIsotropicDiffusivity","text":"ConstantIsotropicDiffusivity{FT, K}\n\nParameters for constant isotropic diffusivity models.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.TurbulenceClosures.ConstantIsotropicDiffusivity","page":"Library","title":"Oceananigans.TurbulenceClosures.ConstantIsotropicDiffusivity","text":"ConstantIsotropicDiffusivity([FT=Float64;] ν, κ)\n\nReturns parameters for a constant isotropic diffusivity model with constant viscosity ν and constant thermal diffusivities κ for each tracer field in tracers ν and the fields of κ may represent molecular diffusivities in cases that all flow features are explicitly resovled, or turbulent eddy diffusivities that model the effect of unresolved, subgrid-scale turbulence. κ may be a NamedTuple with fields corresponding to each tracer, or a single number to be a applied to all tracers.\n\nBy default, a molecular viscosity of ν = 1.05×10⁻⁶ m² s⁻¹ and a molecular thermal diffusivity of κ = 1.46×10⁻⁷ m² s⁻¹ is used for each tracer. These molecular values are the approximate viscosity and thermal diffusivity for seawater at 20°C and 35 psu, according to Sharqawy et al., \"Thermophysical properties of seawater: A review of existing correlations and data\" (2010).\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.TurbulenceClosures.VerstappenAnisotropicMinimumDissipation","page":"Library","title":"Oceananigans.TurbulenceClosures.VerstappenAnisotropicMinimumDissipation","text":"VerstappenAnisotropicMinimumDissipation{FT} <: AbstractAnisotropicMinimumDissipation{FT}\n\nParameters for the anisotropic minimum dissipation large eddy simulation model proposed by Verstappen (2018) and described by Vreugdenhil & Taylor (2018).\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.TurbulenceClosures.VerstappenAnisotropicMinimumDissipation","page":"Library","title":"Oceananigans.TurbulenceClosures.VerstappenAnisotropicMinimumDissipation","text":"VerstappenAnisotropicMinimumDissipation(FT=Float64; C=1/12, Cν=nothing, Cκ=nothing,\n                                        Cb=0.0, ν=ν₀, κ=κ₀)\n\nReturns parameters of type FT for the VerstappenAnisotropicMinimumDissipation turbulence closure.\n\nKeyword arguments\n\n- `C`  : Poincaré constant for both eddy viscosity and eddy diffusivities. `C` is overridden\n         for eddy viscosity or eddy diffusivity if `Cν` or `Cκ` are set, respecitvely.\n- `Cν` : Poincaré constant for momentum eddy viscosity.\n- `Cκ` : Poincaré constant for tracer eddy diffusivities. If one number or function, the same\n         number or function is applied to all tracers. If a `NamedTuple`, it must possess\n         a field specifying the Poncaré constant for every tracer.\n- `Cb` : Buoyancy modification multiplier (`Cb = 0` turns it off, `Cb = 1` turns it on)\n- `ν`  : Constant background viscosity for momentum.\n- `κ`  : Constant background diffusivity for tracer. If a single number, the same background\n         diffusivity is applied to all tracers. If a `NamedTuple`, it must possess a field\n         specifying a background diffusivity for every tracer.\n\nBy default: C = Cν = Cκ = 1/12, which is appropriate for a finite-volume method employing a second-order advection scheme, Cb = 0, which terms off the buoyancy modification term, the molecular viscosity of seawater at 20 deg C and 35 psu is used for ν, and the molecular diffusivity of heat in seawater at 20 deg C and 35 psu is used for κ.\n\nCν or Cκ may be constant numbers, or functions of x, y, z.\n\nExample\n\njulia> prettydiffusiveclosure = AnisotropicMinimumDissipation(C=1/2) VerstappenAnisotropicMinimumDissipation{Float64} turbulence closure with:            Poincaré constant for momentum eddy viscosity Cν: 0.5     Poincaré constant for tracer(s) eddy diffusivit(ies) Cκ: 0.5                         Buoyancy modification multiplier Cb: 0.0                 Background diffusivit(ies) for tracer(s), κ: 1.46e-7              Background kinematic viscosity for momentum, ν: 1.05e-6\n\njulia> const Δz = 0.5; # grid resolution at surface\n\njulia> surfaceenhancedtracerC(x, y, z) = 1/12 * (1 + exp((z + Δz/2) / 8Δz)) surfaceenhancedtracerC (generic function with 1 method)\n\njulia> fancyclosure = AnisotropicMinimumDissipation(Cκ=surfaceenhancedtracerC) VerstappenAnisotropicMinimumDissipation{Float64} turbulence closure with:            Poincaré constant for momentum eddy viscosity Cν: 0.08333333333333333     Poincaré constant for tracer(s) eddy diffusivit(ies) Cκ: surfaceenhancedtracer_C                         Buoyancy modification multiplier Cb: 0.0                 Background diffusivit(ies) for tracer(s), κ: 1.46e-7              Background kinematic viscosity for momentum, ν: 1.05e-6\n\njulia> tracerspecificclosure = AnisotropicMinimumDissipation(Cκ=(c₁=1/12, c₂=1/6)) VerstappenAnisotropicMinimumDissipation{Float64} turbulence closure with:            Poincaré constant for momentum eddy viscosity Cν: 0.08333333333333333     Poincaré constant for tracer(s) eddy diffusivit(ies) Cκ: (c₁ = 0.08333333333333333, c₂ = 0.16666666666666666)                         Buoyancy modification multiplier Cb: 0.0                 Background diffusivit(ies) for tracer(s), κ: 1.46e-7              Background kinematic viscosity for momentum, ν: 1.05e-6\n\nReferences\n\nVreugdenhil C., and Taylor J. (2018), \"Large-eddy simulations of stratified plane Couette     flow using the anisotropic minimum-dissipation model\", Physics of Fluids 30, 085104.\n\nVerstappen, R. (2018), \"How much eddy dissipation is needed to counterbalance the nonlinear     production of small, unresolved scales in a large-eddy simulation of turbulence?\",     Computers & Fluids 176, pp. 276-284.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.TurbulenceClosures.∇_κ_∇c-Union{Tuple{tracer_index}, Tuple{Any,Any,Any,Any,Oceananigans.TurbulenceClosures.AbstractAnisotropicMinimumDissipation,Any,Val{tracer_index},Any,Vararg{Any,N} where N}} where tracer_index","page":"Library","title":"Oceananigans.TurbulenceClosures.∇_κ_∇c","text":"∇_κ_∇c(i, j, k, grid, c, tracer_index, closure, diffusivities)\n\nReturn the diffusive flux divergence ∇ ⋅ (κ ∇ c) for the turbulence closure, where c is an array of scalar data located at cell centers.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.TurbulenceClosures.BlasiusSmagorinsky","page":"Library","title":"Oceananigans.TurbulenceClosures.BlasiusSmagorinsky","text":"BlasiusSmagorinsky{ML, FT}\n\nParameters for the version of the Smagorinsky closure used in the UK Met Office code Blasius, according to Polton and Belcher (2007).\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.TurbulenceClosures.BlasiusSmagorinsky","page":"Library","title":"Oceananigans.TurbulenceClosures.BlasiusSmagorinsky","text":"BlasiusSmagorinsky(FT=Float64; Pr=1.0, ν=1.05e-6, κ=1.46e-7)\n\nReturns a BlasiusSmagorinsky closure object of type FT.\n\nKeyword arguments\n\n- `Pr` : Turbulent Prandtl numbers for each tracer. Either a constant applied to every\n         tracer, or a `NamedTuple` with fields for each tracer individually.\n- `ν`  : Constant background viscosity for momentum\n- `κ`  : Constant background diffusivity for tracer. Can either be a single number\n         applied to all tracers, or `NamedTuple` of diffusivities corresponding to each\n         tracer.\n\nReferences\n\nPolton, J. A., and Belcher, S. E. (2007), \"Langmuir turbulence and deeply penetrating jets     in an unstratified mixed layer.\" Journal of Geophysical Research: Oceans.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.TurbulenceClosures.ConstantAnisotropicDiffusivity","page":"Library","title":"Oceananigans.TurbulenceClosures.ConstantAnisotropicDiffusivity","text":"ConstantAnisotropicDiffusivity{FT, KH, KV}\n\nParameters for constant anisotropic diffusivity models.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.TurbulenceClosures.ConstantAnisotropicDiffusivity","page":"Library","title":"Oceananigans.TurbulenceClosures.ConstantAnisotropicDiffusivity","text":"ConstantAnisotropicDiffusivity(; νh, νv, κh, κv)\n\nReturns parameters for a constant anisotropic diffusivity closure with constant horizontal and vertical viscosities νh, νv and constant horizontal and vertical tracer diffusivities κh, κv. κh and κv may be NamedTuples with fields corresponding to each tracer, or a single number to be a applied to all tracers.\n\nBy default, a viscosity of ν = 1.05×10⁻⁶ m² s⁻¹ is used for both the horizontal and vertical viscosity, and a diffusivity of κ = 1.46×10⁻⁷ m² s⁻¹ is used for the horizontal and vertical diffusivities applied to every tracer. These values are the approximate viscosity and thermal diffusivity for seawater at 20°C and 35 psu, according to Sharqawy et al., \"Thermophysical properties of seawater: A review of existing correlations and data\" (2010).\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.TurbulenceClosures.RozemaAnisotropicMinimumDissipation","page":"Library","title":"Oceananigans.TurbulenceClosures.RozemaAnisotropicMinimumDissipation","text":"RozemaAnisotropicMinimumDissipation(FT=Float64; C=0.33, ν=1.05e-6, κ=1.46e-7)\n\nReturns a RozemaAnisotropicMinimumDissipation closure object of type FT with\n\n* `C` : Poincaré constant\n* `ν` : 'molecular' background viscosity\n* `κ` : 'molecular' background diffusivity for each tracer\n\nSee Rozema et al., \" (2015)\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.TurbulenceClosures.TwoDimensionalLeith","page":"Library","title":"Oceananigans.TurbulenceClosures.TwoDimensionalLeith","text":"TwoDimensionalLeith{FT} <: AbstractLeith{FT}\n\nParameters for the 2D Leith turbulence closure.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.TurbulenceClosures.TwoDimensionalLeith","page":"Library","title":"Oceananigans.TurbulenceClosures.TwoDimensionalLeith","text":"TwoDimensionalLeith([FT=Float64;] C=0.3, C_Redi=1, C_GM=1)\n\nReturn a TwoDimensionalLeith type associated with the turbulence closure proposed by Leith (1965) and Fox-Kemper & Menemenlis (2008) which has an eddy viscosity of the form\n\n`νₑ = (C * Δᶠ)³ * √(ζ² + (∇h ∂z w)²)`\n\nand an eddy diffusivity of the form...\n\nwhere Δᶠ is the filter width, ζ² = (∂x v - ∂y u)² is the squared vertical vorticity, and C is a model constant.\n\nKeyword arguments\n\n- `C`      : Model constant\n- `C_Redi` : Coefficient for down-gradient tracer diffusivity for each tracer.\n             Either a constant applied to every tracer, or a `NamedTuple` with fields\n             for each tracer individually.\n- `C_GM`   : Coefficient for down-gradient tracer diffusivity for each tracer.\n             Either a constant applied to every tracer, or a `NamedTuple` with fields\n             for each tracer individually.\n\nReferences\n\nLeith, C. E. (1968). \"Diffusion Approximation for Two‐Dimensional Turbulence\", The Physics of     Fluids 11, 671. doi: 10.1063/1.1691968\n\nFox‐Kemper, B., & D. Menemenlis (2008), \"Can large eddy simulation techniques improve mesoscale rich     ocean models?\", in Ocean Modeling in an Eddying Regime, Geophys. Monogr. Ser., vol. 177, pp. 319–337.     doi:10.1029/177GM19\n\nPearson, B. et al. (2017) , \"Evaluation of scale-aware subgrid mesoscale eddy models in a global eddy     rich model\", Ocean Modelling 115, 42-58. doi: 10.1016/j.ocemod.2017.05.007\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.TurbulenceClosures.∇_κ_∇c-Tuple{Any,Any,Any,Any,Oceananigans.TurbulenceClosures.AbstractLeith,Any,Any,Any,Any,Any}","page":"Library","title":"Oceananigans.TurbulenceClosures.∇_κ_∇c","text":"∇_κ_∇c(i, j, k, grid, c, closure, diffusivities)\n\nReturn the diffusive flux divergence ∇ ⋅ (κ ∇ c) for the turbulence closure, where c is an array of scalar data located at cell centers.\n\n\n\n\n\n","category":"method"},{"location":"library/#Utilities-1","page":"Library","title":"Utilities","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"Modules = [Oceananigans.Utils]\nPrivate = false\nPages   = [\n    \"Utils/Utils.jl\",\n    \"Utils/adapt_structure.jl\",\n    \"Utils/units.jl\",\n    \"Utils/loop_macros.jl\",\n    \"Utils/launch_config.jl\",\n    \"Utils/pretty_time.jl\",\n    \"Utils/pretty_filesize.jl\",\n    \"Utils/time_step_wizard.jl\",\n    \"Utils/tuple_utils.jl\",\n    \"Utils/ordered_dict_show.jl\",\n    \"Utils/cell_advection_timescale.jl\",\n    \"Utils/output_writer_diagnostic_utils.jl\",\n    \"Utils/with_tracers.jl\"\n]","category":"page"},{"location":"library/#Oceananigans.Utils.GiB","page":"Library","title":"Oceananigans.Utils.GiB","text":"GiB\n\nA Float64 constant equal to 1024MiB. Useful for increasing the clarity of scripts, e.g. max_filesize = 50GiB.\n\n\n\n\n\n","category":"constant"},{"location":"library/#Oceananigans.Utils.KiB","page":"Library","title":"Oceananigans.Utils.KiB","text":"KiB\n\nA Float64 constant equal to 1024.0. Useful for increasing the clarity of scripts, e.g. max_filesize = 250KiB.\n\n\n\n\n\n","category":"constant"},{"location":"library/#Oceananigans.Utils.MiB","page":"Library","title":"Oceananigans.Utils.MiB","text":"MiB\n\nA Float64 constant equal to 1024KiB. Useful for increasing the clarity of scripts, e.g. max_filesize = 100MiB.\n\n\n\n\n\n","category":"constant"},{"location":"library/#Oceananigans.Utils.TiB","page":"Library","title":"Oceananigans.Utils.TiB","text":"TiB\n\nA Float64 constant equal to 1024GiB. Useful for increasing the clarity of scripts, e.g. max_filesize = 2TiB.\n\n\n\n\n\n","category":"constant"},{"location":"library/#Oceananigans.Utils.day","page":"Library","title":"Oceananigans.Utils.day","text":"day\n\nA Float64 constant equal to 24hour. Useful for increasing the clarity of scripts, e.g. Δt = 0.5day.\n\n\n\n\n\n","category":"constant"},{"location":"library/#Oceananigans.Utils.hour","page":"Library","title":"Oceananigans.Utils.hour","text":"hour\n\nA Float64 constant equal to 60minute. Useful for increasing the clarity of scripts, e.g. Δt = 3hour.\n\n\n\n\n\n","category":"constant"},{"location":"library/#Oceananigans.Utils.kilometer","page":"Library","title":"Oceananigans.Utils.kilometer","text":"kilometer\n\nA Float64 constant equal to 1000meter. Useful for increasing the clarity of scripts, e.g. Lx = 250kilometer.\n\n\n\n\n\n","category":"constant"},{"location":"library/#Oceananigans.Utils.meter","page":"Library","title":"Oceananigans.Utils.meter","text":"meter\n\nA Float64 constant equal to 1.0. Useful for increasing the clarity of scripts, e.g. Lx = 100meter.\n\n\n\n\n\n","category":"constant"},{"location":"library/#Oceananigans.Utils.minute","page":"Library","title":"Oceananigans.Utils.minute","text":"minute\n\nA Float64 constant equal to 60second. Useful for increasing the clarity of scripts, e.g. Δt = 15minute.\n\n\n\n\n\n","category":"constant"},{"location":"library/#Oceananigans.Utils.second","page":"Library","title":"Oceananigans.Utils.second","text":"second\n\nA Float64 constant equal to 1.0. Useful for increasing the clarity of scripts, e.g. Δt = 1second.\n\n\n\n\n\n","category":"constant"},{"location":"library/#Oceananigans.Utils.prettytime-Tuple{Any}","page":"Library","title":"Oceananigans.Utils.prettytime","text":"prettytime(t)\n\nConvert a floating point value t representing an amount of time in seconds to a more human-friendly formatted string with three decimal places. Depending on the value of t the string will be formatted to show t in nanoseconds (ns), microseconds (μs), milliseconds (ms), seconds (s), minutes (min), hours (hr), or days (day).\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Utils.pretty_filesize","page":"Library","title":"Oceananigans.Utils.pretty_filesize","text":"pretty_filesize(s, suffix=\"B\")\n\nConvert a floating point value s representing a file size to a more human-friendly formatted string with one decimal places with a suffix defaulting to \"B\". Depending on the value of s the string will be formatted to show s using an SI prefix from bytes, kiB (1024 bytes), MiB (1024² bytes), and so on up to YiB (1024⁸ bytes).\n\n\n\n\n\n","category":"function"},{"location":"library/#Oceananigans.Utils.update_Δt!-Tuple{Any,Any}","page":"Library","title":"Oceananigans.Utils.update_Δt!","text":"update_Δt!(wizard, model)\n\nCompute wizard.Δt given the velocities and diffusivities of model, and the parameters of wizard.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Utils.cell_advection_timescale-NTuple{4,Any}","page":"Library","title":"Oceananigans.Utils.cell_advection_timescale","text":"Returns the time-scale for advection on a regular grid across a single grid cell.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Utils.validate_interval-Tuple{Any,Any}","page":"Library","title":"Oceananigans.Utils.validate_interval","text":"validate_interval(frequency, interval)\n\nEnsure that frequency and interval are not both nothing.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Utils.with_tracers-Tuple{Any,NamedTuple,Any}","page":"Library","title":"Oceananigans.Utils.with_tracers","text":"with_tracers(tracer_names, initial_tuple, tracer_default)\n\nCreate a tuple corresponding to the solution variables u, v, w, and tracer_names. initial_tuple is a NamedTuple that at least has fields u, v, and w, and may have some fields corresponding to the names in tracer_names. tracer_default is a function that produces a default tuple value for each tracer if not included in initial_tuple.\n\n\n\n\n\n","category":"method"},{"location":"library/#Abstract-operations-1","page":"Library","title":"Abstract operations","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"Modules = [Oceananigans, Oceananigans.AbstractOperations]\nPrivate = false\nPages   = [\n    \"AbstractOperations/AbstractOperations.jl\",\n    \"AbstractOperations/unary_operations.jl\",\n    \"AbstractOperations/binary_operations.jl\",\n    \"AbstractOperations/multiary_operations.jl\",\n    \"AbstractOperations/derivatives.jl\",\n    \"AbstractOperations/function_fields.jl\",\n    \"AbstractOperations/computations.jl\",\n    \"AbstractOperations/interpolation_utils.jl\",\n    \"AbstractOperations/show_abstract_operations.jl\",\n    \"AbstractOperations/grid_validation.jl\"\n]","category":"page"},{"location":"library/#Oceananigans.AbstractOperations.@unary-Tuple","page":"Library","title":"Oceananigans.AbstractOperations.@unary","text":"@unary op1 op2 op3...\n\nTurn each unary function in the list (op1, op2, op3...) into a unary operator on Oceananigans.Fields for use in AbstractOperations.\n\nNote: a unary function is a function with one argument: for example, sin(x) is a unary function.\n\nAlso note: a unary function in Base must be imported to be extended: use import Base: op; @unary op.\n\nExample\n\njulia> squareit(x) = x^2 squareit (generic function with 1 method)\n\njulia> @unary squareit 7-element Array{Any,1}:  :sqrt  :sin  :cos  :exp  :tanh  :-  :squareit\n\njulia> c = Field(Cell, Cell, Cell, CPU(), RegularCartesianGrid((1, 1, 16), (1, 1, 1)));\n\njulia> square_it(c) UnaryOperation at (Cell, Cell, Cell) ├── grid: RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}} │   ├── size: (1, 1, 16) │   └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [0.0, -1.0] └── tree:\n\nsquare_it at (Cell, Cell, Cell) via identity └── OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}\n\n\n\n\n\n","category":"macro"},{"location":"library/#Oceananigans.AbstractOperations.@binary-Tuple","page":"Library","title":"Oceananigans.AbstractOperations.@binary","text":"@binary op1 op2 op3...\n\nTurn each binary function in the list (op1, op2, op3...) into a binary operator on Oceananigans.Fields for use in AbstractOperations.\n\nNote: a binary function is a function with two arguments: for example, +(x, y) is a binary function.\n\nAlso note: a binary function in Base must be imported to be extended: use import Base: op; @binary op.\n\nExample\n\n```jldoctest julia> plusortimes(x, y) = x < 0 ? x + y : x * y plusortimes (generic function with 1 method)\n\njulia> @binary plusortimes 6-element Array{Any,1}:  :+  :-  :/  :^  :*  :plusortimes\n\njulia> c, d = (Field(Cell, Cell, Cell, CPU(), RegularCartesianGrid((1, 1, 16), (1, 1, 1))) for i = 1:2);\n\njulia> plusortimes(c, d) BinaryOperation at (Cell, Cell, Cell) ├── grid: RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}} │   ├── size: (1, 1, 16) │   └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [0.0, -1.0] └── tree:\n\nplusortimes at (Cell, Cell, Cell) via Oceananigans.AbstractOperations.identity ├── OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}} └── OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}\n\n\n\n\n\n","category":"macro"},{"location":"library/#Oceananigans.AbstractOperations.@multiary-Tuple","page":"Library","title":"Oceananigans.AbstractOperations.@multiary","text":"@multiary op1 op2 op3...\n\nTurn each multiary operator in the list (op1, op2, op3...) into a multiary operator on Oceananigans.Fields for use in AbstractOperations.\n\nNote that a multiary operator:     * is a function with two or more arguments: for example, +(x, y, z) is a multiary function;     * must be imported to be extended if part of Base: use import Base: op; @multiary op;     * can only be called on Oceananigans.Fields if the \"location\" is noted explicitly; see example.\n\nExample\n\n```jldoctest julia> harmonicplus(a, b, c) = 1/3 * (1/a + 1/b + 1/c) harmonicplus(generic function with 1 method)\n\njulia> @multiary harmonicplus 3-element Array{Any,1}:  :+  :*  :harmonicplus\n\njulia> c, d, e = Tuple(Field(Cell, Cell, Cell, CPU(), RegularCartesianGrid((1, 1, 16), (1, 1, 1))) for i = 1:3);\n\njulia> harmonic_plus(c, d, e) # this calls the original function, which in turn returns a (correct) operation tree BinaryOperation at (Cell, Cell, Cell) ├── grid: RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}} │   ├── size: (1, 1, 16) │   └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [0.0, -1.0] └── tree:\n\nat (Cell, Cell, Cell) via Oceananigans.AbstractOperations.identity\n\n├── 0.3333333333333333 └── + at (Cell, Cell, Cell) via Oceananigans.AbstractOperations.identity     ├── + at (Cell, Cell, Cell) via Oceananigans.AbstractOperations.identity     │   ├── / at (Cell, Cell, Cell) via Oceananigans.AbstractOperations.identity     │   │   ├── 1     │   │   └── OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}     │   └── / at (Cell, Cell, Cell) via Oceananigans.AbstractOperations.identity         │   ├── 1         │   └── OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}     └── / at (Cell, Cell, Cell) via Oceananigans.AbstractOperations.identity         ├── 1         └── OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}\n\njulia> @at (Cell, Cell, Cell) harmonic_plus(c, d, e) # this returns a MultiaryOperation as expected MultiaryOperation at (Cell, Cell, Cell) ├── grid: RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}} │   ├── size: (1, 1, 16) │   └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [0.0, -1.0] └── tree:\n\nharmonic_plus at (Cell, Cell, Cell) ├── OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}} ├── OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}} └── OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}\n\n\n\n\n\n","category":"macro"},{"location":"library/#Oceananigans.AbstractOperations.∂x-Tuple{Union{Type{Oceananigans.Cell}, Type{Oceananigans.Face}}}","page":"Library","title":"Oceananigans.AbstractOperations.∂x","text":"Return the x-derivative function acting at (X, Any, Any).\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.AbstractOperations.∂x-Union{Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}, Tuple{Z}, Tuple{Y}, Tuple{X}} where Z where Y where X","page":"Library","title":"Oceananigans.AbstractOperations.∂x","text":"∂x(a::AbstractField)\n\nReturn an abstract representation of a x-derivative acting on a.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.AbstractOperations.∂x-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{Tuple,Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}} where Z where Y where X","page":"Library","title":"Oceananigans.AbstractOperations.∂x","text":"∂x(L::Tuple, a::AbstractField)\n\nReturn an abstract representation of an x-derivative acting on a followed by interpolation to L, where L is a 3-tuple of Faces and Cells.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.AbstractOperations.∂y-Tuple{Union{Type{Oceananigans.Cell}, Type{Oceananigans.Face}}}","page":"Library","title":"Oceananigans.AbstractOperations.∂y","text":"Return the y-derivative function acting at (Any, Y, Any).\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.AbstractOperations.∂y-Union{Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}, Tuple{Z}, Tuple{Y}, Tuple{X}} where Z where Y where X","page":"Library","title":"Oceananigans.AbstractOperations.∂y","text":"∂y(a::AbstractField)\n\nReturn an abstract representation of a y-derivative acting on a.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.AbstractOperations.∂y-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{Tuple,Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}} where Z where Y where X","page":"Library","title":"Oceananigans.AbstractOperations.∂y","text":"∂y(L::Tuple, a::AbstractField)\n\nReturn an abstract representation of a y-derivative acting on a followed by interpolation to L, where L is a 3-tuple of Faces and Cells.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.AbstractOperations.∂z-Tuple{Union{Type{Oceananigans.Cell}, Type{Oceananigans.Face}}}","page":"Library","title":"Oceananigans.AbstractOperations.∂z","text":"Return the z-derivative function acting at (Any, Any, Z).\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.AbstractOperations.∂z-Union{Tuple{Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}, Tuple{Z}, Tuple{Y}, Tuple{X}} where Z where Y where X","page":"Library","title":"Oceananigans.AbstractOperations.∂z","text":"∂z(a::AbstractField)\n\nReturn an abstract representation of a z-derivative acting on a.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.AbstractOperations.∂z-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{Tuple,Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A}} where Z where Y where X","page":"Library","title":"Oceananigans.AbstractOperations.∂z","text":"∂z(L::Tuple, a::AbstractField)\n\nReturn an abstract representation of a z-derivative acting on a followed by interpolation to L, where L is a 3-tuple of Faces and Cells.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.AbstractOperations.Computation","page":"Library","title":"Oceananigans.AbstractOperations.Computation","text":"Computation{T, R, O, G}\n\nRepresents an operation performed over the elements of a field.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.AbstractOperations.Computation-Tuple","page":"Library","title":"Oceananigans.AbstractOperations.Computation","text":"(computation::Computation)(args...)\n\nPerforms the compute(computation) and returns the result if isnothing(return_type), or the result after being converted to return_type.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.AbstractOperations.Computation-Tuple{Any,Any}","page":"Library","title":"Oceananigans.AbstractOperations.Computation","text":"Computation(operation, result; return_type=Array)\n\nReturns a Computation representing an operation performed over the elements of operation.grid and stored in result. return_type specifies the output type when the Computation instances is called as a function.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.AbstractOperations.compute!-Tuple{Computation}","page":"Library","title":"Oceananigans.AbstractOperations.compute!","text":"compute!(computation::Computation)\n\nPerform a computation. The result is stored in computation.result.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.AbstractOperations.@at-Tuple{Any,Any}","page":"Library","title":"Oceananigans.AbstractOperations.@at","text":"@at location abstract_operation\n\nModify the abstract_operation so that it returns values at location, where location is a 3-tuple of Faces and Cells.\n\n\n\n\n\n","category":"macro"},{"location":"model_setup/architecture/#Architecture-1","page":"Architecture","title":"Architecture","text":"","category":"section"},{"location":"model_setup/architecture/#","page":"Architecture","title":"Architecture","text":"Passing architecture = CPU() or architecture = GPU() to the Model constructor will determine whether the model is time stepped on a CPU or GPU.","category":"page"},{"location":"model_setup/architecture/#","page":"Architecture","title":"Architecture","text":"Ideally a set up or simulation script does not need to be modified to run on a GPU but we are still smoothing out rough edges. Generally the CPU wants Array objects while the GPU wants CuArray objects.","category":"page"},{"location":"model_setup/architecture/#","page":"Architecture","title":"Architecture","text":"tip: Running on GPUs\nIf you are having issues with running Oceananigans on a GPU, please open an issue and we'll do our best to help out.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#Large-eddy-simulation-1","page":"Large eddy simulation","title":"Large eddy simulation","text":"","category":"section"},{"location":"numerical_implementation/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"The idea behind large eddy simulation (LES) is to resolve the \"large eddies\" while modeling the effect of unresolved sub-grid scale motions. This is done usually be assuming eddy viscosity and eddy diffusivity models and providing an estimate for the eddy viscosity nu_e and diffusivity kappa_e.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"Much of the early work on LES was motivated by the study of atmospheric boundary layer turbulence, being developed by \\citet{Smagorinsky63} and \\citet{Lilly66}, then first implemented by \\citet{Deardorff70,Deardorff74}.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"In the LES framework, the Navier-Stokes equations are averaged in the same way as \\citet{Reynolds1895} except that the mean field overlinebmu is obtained via convolution with a filter convolution kernel~G","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"overlinebmu(bmx t) = G star bmu =\n  int_-infty^infty int_-infty^infty\n  bmu(bmx^prime t) G(bmx - bmx^prime t - tau)  dbmx^prime  dtau","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"as described by \\citet{Leonard75} who introduced the general filtering formalism.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"The overlineu_i^prime u_j^prime terms are now components of what is called the sub-grid scale (SGS) stress tensor tau^textSGS_ij, which looks the same as the Reynolds stress tensor so we will drop the SGS superscript.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"It is probably important to note that the large eddy simulation filtering operation does not satisfy the properties of a Reynolds operator \\citep[\\S 2.1]{sagaut06} and that in general, the filtered residual is not zero: overlinebmu^prime(bmx t) ne 0.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"\\citet[\\S13.2]{Pope00} lists a number of popular choices for the filter function G. For practical reasons we simply employ the box kernel","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"  G_Delta = G(bmx t) = frac1Delta H left( frac12Delta - bmx right) delta(t - t_n)","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"where H is the Heaviside function, Delta is the grid spacing, and t_n is the current time step. With \\eqref{eq:box-kernel} we get back the averaging operator originally used by \\citet{Deardorff70}","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"overlinebmu(x y z t) =\n  frac1Delta x Delta y Delta z\n  int_x - frac12Delta x^x + frac12Delta x\n  int_y - frac12Delta y^y + frac12Delta y\n  int_z - frac12Delta z^z + frac12Delta z\n  bmu(xi eta zeta t)  dxi  deta  dzeta","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"which if evaluated at the cell centers just returns the cell averages we already compute in the finite volume method.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#Smagorinsky-Lilly-model-1","page":"Large eddy simulation","title":"Smagorinsky-Lilly model","text":"","category":"section"},{"location":"numerical_implementation/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"\\citet{Smagorinsky63} estimated the eddy viscosity nu_e via a characteristic length scale Delta times a velocity scale given by Delta overlineS where overlineS = sqrt2overlineS_ijoverlineS_ij. Thus the SGS stress tensor is given by","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"tau_ij = -2nu_e overlineS_ij = -2 (C_s Delta)^2 overlineS overlineS_ij","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"where C_s is a dimensionless constant. The grid spacing is usually used for the characteristic length scale Delta. The eddy diffusivities are calculated via kappa_e = nu_e  textPr_t where the turbulent Prandtl number textPr_t is usually chosen to be mathcalO(1) from experimental observations.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"Assuming that the SGS energy cascade is equal to the overall dissipation rate varepsilon from the \\citet{Kolmogorov41} theory, \\citet{Lilly66} was able to derive a value of","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"C_s = left( frac32C_Kpi^frac43 right)^-frac34 approx 016","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"using an empirical value of C_K approx 16 for the Kolmogorov constant. This seems reasonable for isotropic turbulence if the grid spacing Delta falls in the inertial range. In practice, C_s is a tunable parameter.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"Due to the presence of the constant C_s, the model is sometimes referred to as the \\emph{constant Smagorinsky} model in contrast to \\emph{dynamic Smagorinsky} models that dynamically compute C_s to account for effects such as buoyant convection.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#Anisotropic-minimum-dissipation-models-1","page":"Large eddy simulation","title":"Anisotropic minimum dissipation models","text":"","category":"section"},{"location":"numerical_implementation/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"Minimum-dissipation eddy-viscosity models are a class of LES closures that use the minimum eddy dissipation required to dissipate the energy of sub-grid scale motion. \\citet{Rozema15} proposed the first minimum-dissipation model appropriate for use on anisotropic grids, termed the \\emph{anisotropic minimum dissipation} (AMD) model.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"It has a number of desirable properties over Smagorinsky-type closures: it is more cost-effective than dynamic Smagorinsky, it appropriately switches off in laminar and transitional flows, and it is consistent with the exact SGS stress tensor on both isotropic and anisotropic grids. \\citet{Abkar16} extended the AMD model to model SGS scalar fluxes for tracer transport. \\citet{Abkar17} further extended the model to include a buoyancy term that accounts for the contribution of buoyant forces to the production and suppression of turbulence.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"\\citet{Vreugdenhil18} derive a modified AMD model by following the requirement suggested by \\citet{Verstappen18}, which entail normalising the displacement, the velocity, and the velocity gradient by the filter width to ensure that the resulting eddy dissipation properly counteracts the spurious kinetic energy transferred by convective nonlinearity, to derive a modified AMD model.","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"The eddy viscosity and diffusivity are defined in terms of eddy viscosity and diffusivity \\emph{predictors} nu_e^dagger and kappa_e^dagger, such that","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"nu_e = textmax lbrace 0 nu_e^dagger rbrace\nquad textand quad\nkappa_e = textmax lbrace 0 kappa_e^dagger rbrace","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"to ensure that nu_e ge 0 and kappa_e ge 0. Leaving out the overlines and understanding that all variables represent the resolved/filtered variables, the eddy viscosity predictor is given by","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"nu_e^dagger = -(CDelta)^2\n  frac\n    left( hatpartial_k hatu_i right) left( hatpartial_k hatu_j right) hatS_ij\n    + C_bhatdelta_i3 alpha g left( hatpartial_k hatu_i right) hatpartial_k theta\n    left( hatpartial_l hatu_m right) left( hatpartial_l hatu_m right)","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"and the eddy diffusivity predictor by","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"kappa_e^dagger = -(CDelta)^2\nfrac\n    left( hatpartial_k hatu_i right) left( hatpartial_k hattheta right) hatpartial_i theta\n    left( hatpartial_l hattheta right) left( hatpartial_l hattheta right)","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"where","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"  hatx_i = fracx_iDelta_i quad\n  hatu_i(hatx t) = fracu_i(x t)Delta_i quad\n  hatpartial_i hatu_j(hatx t) = fracDelta_iDelta_j partial_i u_j(x t) quad\n  hatdelta_i3 = fracdelta_i3Delta 3","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"so that the normalized rate of strain tensor is","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"hatS_ij =\n  frac12 left hatpartial_i hatu_j(hatx t) + hatpartial_j hatu_i(hatx t) right","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"In equations \\eqref{eq:nu-dagger}–\\eqref{eq:S-hat} C is a modified Poincaré \"constant\" that is independent from the filter width Delta but does depend on the accuracy of the discretization method used. \\citet{Abkar16} cite C^2 = frac112 for a spectral method and C^2 = frac13 for a second-order accurate scheme. Delta_i is the filter width in the x_i-direction, and Delta is given by the square root of the harmonic mean of the squares of the filter widths in each direction","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"    frac1Delta^2 = frac13 left( frac1Delta x^2 + frac1Delta y^2 + frac1Delta z^2 right)","category":"page"},{"location":"numerical_implementation/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"The term multiplying C_b is the buoyancy modification introduced by \\citet{Abkar17} and is small for weakly stratified flows. We have introduced the C_b constant so that the buoyancy modification term may be turned on and off.","category":"page"},{"location":"physics/boundary_conditions/#Boundary-conditions-1","page":"Boundary conditions","title":"Boundary conditions","text":"","category":"section"},{"location":"physics/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"In Oceananigans.jl the user may impose \\textit{no-penetration}, \\textit{flux}, \\textit{gradient} (Neumann), and \\textit{value} (Dirichlet) boundary conditions in bounded, non-periodic directions. Note that the only boundary condition available for a velocity field normal to the bounded direction is \\textit{no-penetration}.","category":"page"},{"location":"physics/boundary_conditions/#Flux-boundary-conditions-1","page":"Boundary conditions","title":"Flux boundary conditions","text":"","category":"section"},{"location":"physics/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"A flux boundary condition prescribes flux of a quantity normal to the boundary. For a tracer c this corresponds to prescribing","category":"page"},{"location":"physics/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"q_c  _b equiv bmq_c bmcdot hatbmn  _partial Omega_b  ","category":"page"},{"location":"physics/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"where partial Omega_b is an external boundary.","category":"page"},{"location":"physics/boundary_conditions/#Gradient-(Neumann)-boundary-condition-1","page":"Boundary conditions","title":"Gradient (Neumann) boundary condition","text":"","category":"section"},{"location":"physics/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"A gradient boundary condition prescribes the gradient of a field normal to the boundary. For a tracer c this prescribes","category":"page"},{"location":"physics/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"gamma equiv bmnabla c bmcdot hatbmn  _partial Omega_b  ","category":"page"},{"location":"physics/boundary_conditions/#Value-(Dirichlet)-boundary-condition-1","page":"Boundary conditions","title":"Value (Dirichlet) boundary condition","text":"","category":"section"},{"location":"physics/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"A value boundary condition prescribes the value of a field on a boundary; for a tracer this prescribes","category":"page"},{"location":"physics/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"c_b equiv c  _partial Omega_b  ","category":"page"},{"location":"physics/boundary_conditions/#No-penetration-boundary-condition-1","page":"Boundary conditions","title":"No penetration boundary condition","text":"","category":"section"},{"location":"physics/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"A no penetration boundary condition prescribes the velocity component normal to a boundary to be 0, so that","category":"page"},{"location":"physics/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"bmhatn bmcdot bmu  _partial Omega_b = 0  ","category":"page"},{"location":"generated/one_dimensional_diffusion/#","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"EditURL = \"https://github.com/climate-machine/Oceananigans.jl/blob/master/examples/one_dimensional_diffusion.jl\"","category":"page"},{"location":"generated/one_dimensional_diffusion/#Simple-diffusion-example-1","page":"One-dimensional diffusion","title":"Simple diffusion example","text":"","category":"section"},{"location":"generated/one_dimensional_diffusion/#","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"This script provides our simplest example of Oceananigans.jl functionality: the diffusion of a one-dimensional Gaussian. This example demonstrates","category":"page"},{"location":"generated/one_dimensional_diffusion/#","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"how to load Oceananigans.jl;\nhow to instantiate an Oceananigans.jl model;\nhow to set an initial condition with a function;\nhow to time-step a model forward, and finally\nhow to look at results.","category":"page"},{"location":"generated/one_dimensional_diffusion/#Using-Oceananigans.jl-1","page":"One-dimensional diffusion","title":"Using Oceananigans.jl","text":"","category":"section"},{"location":"generated/one_dimensional_diffusion/#","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"To use Oceananigans.jl after it has been installed, we bring Oceananigans.jl functions and names into our 'namespace' by writing","category":"page"},{"location":"generated/one_dimensional_diffusion/#","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"using Oceananigans","category":"page"},{"location":"generated/one_dimensional_diffusion/#","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"We also use Plots.jl for plotting and Printf to format plot legends:","category":"page"},{"location":"generated/one_dimensional_diffusion/#","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"using Plots, Printf","category":"page"},{"location":"generated/one_dimensional_diffusion/#Instantiating-and-configuring-a-model-1","page":"One-dimensional diffusion","title":"Instantiating and configuring a model","text":"","category":"section"},{"location":"generated/one_dimensional_diffusion/#","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"To begin using Oceananigans, we instantiate an incompressible model by calling the IncompressibleModel constructor:","category":"page"},{"location":"generated/one_dimensional_diffusion/#","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"model = IncompressibleModel(\n    grid = RegularCartesianGrid(size = (1, 1, 128), x = (0, 1), y = (0, 1), z = (-0.5, 0.5)),\n    closure = ConstantIsotropicDiffusivity(κ = 1.0)\n)\nnothing # hide","category":"page"},{"location":"generated/one_dimensional_diffusion/#","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"The keyword arguments grid and closure indicate that our model grid is Cartesian with uniform grid spacing, that our diffusive stress and tracer fluxes are determined by diffusion with a constant diffusivity κ (note that we do not use viscosity in this example).","category":"page"},{"location":"generated/one_dimensional_diffusion/#","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Note that by default, a Model has no-flux boundary condition on all variables. Next, we set an initial condition on our \"passive tracer\", temperature. Our objective is to observe the diffusion of a Gaussian.","category":"page"},{"location":"generated/one_dimensional_diffusion/#","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"# Build a Gaussian initial condition function with width `δ`:\nδ = 0.1\nTᵢ(x, y, z) = exp( -z^2 / (2δ^2) )\n\n# Set `model.tracers.T` to the function `Tᵢ`:\nset!(model, T=Tᵢ)","category":"page"},{"location":"generated/one_dimensional_diffusion/#Running-your-first-Model-1","page":"One-dimensional diffusion","title":"Running your first Model","text":"","category":"section"},{"location":"generated/one_dimensional_diffusion/#","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Finally, we time-step the model forward using the function time_step!, with a time-step size that ensures numerical stability.","category":"page"},{"location":"generated/one_dimensional_diffusion/#","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"# Time-scale for diffusion across a grid cell\ncell_diffusion_time_scale = model.grid.Δz^2 / model.closure.κ.T\n\n# We create a `Simulation` which will handle time stepping the model. It will\n# execute `Nt` time steps with step size `Δt` using a second-order Adams-Bashforth method.\nsimulation = Simulation(model, Δt = 0.1 * cell_diffusion_time_scale, stop_iteration = 1000)\nrun!(simulation)","category":"page"},{"location":"generated/one_dimensional_diffusion/#Visualizing-the-results-1","page":"One-dimensional diffusion","title":"Visualizing the results","text":"","category":"section"},{"location":"generated/one_dimensional_diffusion/#","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"We use Plots.jl to look at the results. Tracers are defined at cell centers so we use zC as the z-coordinate when plotting it. Fields are stored as 3D arrays in Oceananigans so we plot interior(T)[1, 1, :] which will return a 1D array.","category":"page"},{"location":"generated/one_dimensional_diffusion/#","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"# A convenient function for generating a label with the current model time\ntracer_label(model) = @sprintf(\"t = %.3f\", model.clock.time)\n\n# Plot initial condition\nzC = model.grid.zC\np = plot(Tᵢ.(0, 0, zC), zC, linewidth=2, label=\"t = 0\",\n         xlabel=\"Tracer concentration\", ylabel=\"z\")\n\n# Plot current solution\nT = model.tracers.T\nplot!(p, interior(T)[1, 1, :], zC, linewidth=2, label=tracer_label(model))","category":"page"},{"location":"generated/one_dimensional_diffusion/#","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Interesting! We can keep running the simulation and animate the tracer concentration to see the Gaussian diffusing.","category":"page"},{"location":"generated/one_dimensional_diffusion/#","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"anim = @animate for i=1:100\n    simulation.stop_iteration += 100\n    run!(simulation)\n\n    plot(interior(T)[1, 1, :], zC, linewidth=2, title=tracer_label(model),\n         label=\"\", xlabel=\"Tracer concentration\", ylabel=\"z\", xlims=(0, 1))\nend\n\nmp4(anim, \"1d_diffusion.mp4\", fps = 15) # hide","category":"page"},{"location":"generated/one_dimensional_diffusion/#","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"","category":"page"},{"location":"generated/one_dimensional_diffusion/#","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"This page was generated using Literate.jl.","category":"page"},{"location":"appendix/fractional_step/#Fractional-step-method-1","page":"Fractional step method","title":"Fractional step method","text":"","category":"section"},{"location":"appendix/fractional_step/#","page":"Fractional step method","title":"Fractional step method","text":"Solving the momentum equation \\eqref{eq:momentumFV} coupled with the continuity equation \\eqref{eq:continuityFV} can be cumbersome so instead we employ a fractional step method. To approximate the solution of the coupled system we first solve an approximation to the discretized momentum equation \\eqref{eq:momentumFV} for an intermediate velocity field bmu^star without worrying about satisfying the incompressibility constraint. We then project bmu^star onto the space of divergence-free velocity fields to obtain a value for bmu^n+1 that satisfies \\eqref{eq:continuityFV}.","category":"page"},{"location":"appendix/fractional_step/#","page":"Fractional step method","title":"Fractional step method","text":"We thus discretize the momentum equation as","category":"page"},{"location":"appendix/fractional_step/#","page":"Fractional step method","title":"Fractional step method","text":"renewcommanddiv1 nabla cdotp left ( 1 right )\nfracbmu^star - bmu^nDelta t\n  = - left bmu cdot nablabmu right^n+frac12\n  - 2bmOmegatimesbmu^n+frac12\n  + divnunablabmu^n+frac12\n  + bmF^n+frac12","category":"page"},{"location":"appendix/fractional_step/#","page":"Fractional step method","title":"Fractional step method","text":"where the superscript n + frac12 indicates that these terms are evaluated at time step n + frac12, which we compute explicitly (see \\S\\ref{sec:time-stepping}).","category":"page"},{"location":"appendix/fractional_step/#","page":"Fractional step method","title":"Fractional step method","text":"The projection is then performed","category":"page"},{"location":"appendix/fractional_step/#","page":"Fractional step method","title":"Fractional step method","text":"   bmu^n+1 = bmu^star - Delta t nabla phi^n+1","category":"page"},{"location":"appendix/fractional_step/#","page":"Fractional step method","title":"Fractional step method","text":"to obtain a divergence-free velocity field bmu^n+1. Here the projection is performed by solving an elliptic problem for the pressure phi^n+1 with the boundary condition","category":"page"},{"location":"appendix/fractional_step/#","page":"Fractional step method","title":"Fractional step method","text":"newcommanduvec1boldsymbolhattextbf1\n  bmhatn cdotp nablaphi^n+1 _partialOmega = 0","category":"page"},{"location":"appendix/fractional_step/#","page":"Fractional step method","title":"Fractional step method","text":"\\citet{Orszag86} and \\citet{Brown01} raise an important issue regarding these fractional step methods, which is that \"while the velocity can be reliably computed to second-order accuracy in time and space, the pressure is typically only first-order accurate in the L_infty-norm.\" The numerical boundary conditions must be carefully accounted for to ensure the second-order accuracy promised by the fractional step methods.","category":"page"},{"location":"appendix/fractional_step/#","page":"Fractional step method","title":"Fractional step method","text":"We are currently investigating whether our projection method is indeed second-order accurate in both velocity and pressure (see \\S\\ref{sec:forced-flow}). However, it may not matter too much for simulating high Reynolds number geophysical fluids as \\citet{Brown01} conclude that \"Quite often, semi-implicit projection methods are applied to problems in which the viscosity is small. Since the predicted first-order errors in the pressure are scaled by nu, it is not clear whether the improved pressure-update formula is beneficial in such situations. ... Finally, in some applications of projection methods, second-order accuracy in the pressure may not be relevant or in some cases even possible due to the treatment of other terms in the equations.\"","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#Buoyancy-and-equation-of-state-1","page":"Buoyancy and equation of state","title":"Buoyancy and equation of state","text":"","category":"section"},{"location":"model_setup/buoyancy_and_equation_of_state/#","page":"Buoyancy and equation of state","title":"Buoyancy and equation of state","text":"The buoyancy option selects how buoyancy is treated. There are currently three options:","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#","page":"Buoyancy and equation of state","title":"Buoyancy and equation of state","text":"No buoyancy (and no gravity).\nEvolve buoyancy as a tracer.\nSeawater buoyancy: evolve temperature T and salinity S as tracers with a value for the gravitational acceleration g and an appropriate equation of state.","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#No-buoyancy-1","page":"Buoyancy and equation of state","title":"No buoyancy","text":"","category":"section"},{"location":"model_setup/buoyancy_and_equation_of_state/#","page":"Buoyancy and equation of state","title":"Buoyancy and equation of state","text":"To turn off buoyancy (and gravity) simply pass","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#","page":"Buoyancy and equation of state","title":"Buoyancy and equation of state","text":"buoyancy = nothing","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#","page":"Buoyancy and equation of state","title":"Buoyancy and equation of state","text":"to the Model constructor. In this case, you will probably also want to explicitly specify which tracers to evolve. In particular, you probably will not want to evolve temperature and salinity, which are included by default. To specify no tracers, also pass","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#","page":"Buoyancy and equation of state","title":"Buoyancy and equation of state","text":"tracers = ()","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#","page":"Buoyancy and equation of state","title":"Buoyancy and equation of state","text":"to the Model constructor.","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#Buoyancy-as-a-tracer-1","page":"Buoyancy and equation of state","title":"Buoyancy as a tracer","text":"","category":"section"},{"location":"model_setup/buoyancy_and_equation_of_state/#","page":"Buoyancy and equation of state","title":"Buoyancy and equation of state","text":"To directly evolve buoyancy as a tracer simply pass","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#","page":"Buoyancy and equation of state","title":"Buoyancy and equation of state","text":"using Oceananigans # hide\nbuoyancy = BuoyancyTracer()","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#","page":"Buoyancy and equation of state","title":"Buoyancy and equation of state","text":"to the Model constructor. Buoyancy :b must be included as a tracer, for example, by also passing","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#","page":"Buoyancy and equation of state","title":"Buoyancy and equation of state","text":"tracers = (:b)","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#Seawater-buoyancy-1","page":"Buoyancy and equation of state","title":"Seawater buoyancy","text":"","category":"section"},{"location":"model_setup/buoyancy_and_equation_of_state/#","page":"Buoyancy and equation of state","title":"Buoyancy and equation of state","text":"To evolve temperature T and salinity S and diagnose the buoyancy, you can pass","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#","page":"Buoyancy and equation of state","title":"Buoyancy and equation of state","text":"using Oceananigans # hide\nbuoyancy = SeawaterBuoyancy()","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#","page":"Buoyancy and equation of state","title":"Buoyancy and equation of state","text":"which is also the default. Without any options specified, a value of g = 980665  textms^2 is used for the gravitational acceleration (corresponding to standard gravity) along with a linear equation of state with thermal expansion and haline contraction coefficients suitable for water.","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#","page":"Buoyancy and equation of state","title":"Buoyancy and equation of state","text":"If, for example, you wanted to simulate fluids on another planet such as Europa where g = 13  textms^2, then use","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#","page":"Buoyancy and equation of state","title":"Buoyancy and equation of state","text":"using Oceananigans # hide\nbuoyancy = SeawaterBuoyancy(gravitational_acceleration=1.3)","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#","page":"Buoyancy and equation of state","title":"Buoyancy and equation of state","text":"When using SeawaterBuoyancy temperature :T and salinity :S tracers must be specified","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#","page":"Buoyancy and equation of state","title":"Buoyancy and equation of state","text":"tracers = (:T, :S)","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#Linear-equation-of-state-1","page":"Buoyancy and equation of state","title":"Linear equation of state","text":"","category":"section"},{"location":"model_setup/buoyancy_and_equation_of_state/#","page":"Buoyancy and equation of state","title":"Buoyancy and equation of state","text":"To use non-default thermal expansion and haline contraction coefficients, say alpha = 2 times 10^-3  textK^-1 and beta = 5 times 10^-4 textppt^-1 corresponding to some other fluid, then use","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#","page":"Buoyancy and equation of state","title":"Buoyancy and equation of state","text":"using Oceananigans # hide\nbuoyancy = SeawaterBuoyancy(equation_of_state = LinearEquationOfState(α=1.67e-4, β=7.80e-4))","category":"page"},{"location":"model_setup/buoyancy_and_equation_of_state/#Idealized-nonlinear-equation-of-state-1","page":"Buoyancy and equation of state","title":"Idealized nonlinear equation of state","text":"","category":"section"},{"location":"model_setup/buoyancy_and_equation_of_state/#","page":"Buoyancy and equation of state","title":"Buoyancy and equation of state","text":"Instead of a linear equation of state, five idealized nonlinear equation of state as described by Roquet et al. (2015) may be specified. See RoquetIdealizedNonlinearEquationOfState.","category":"page"},{"location":"physics/boussinesq_approximation/#The-Boussinesq-approximation-1","page":"The Boussinesq approximation","title":"The Boussinesq approximation","text":"","category":"section"},{"location":"physics/boussinesq_approximation/#","page":"The Boussinesq approximation","title":"The Boussinesq approximation","text":"In Oceananigans.jl the fluid density rho is, in general, decomposed into three components:","category":"page"},{"location":"physics/boussinesq_approximation/#","page":"The Boussinesq approximation","title":"The Boussinesq approximation","text":"    rho(bmx t) = rho_0 + rho_*(z) + rho(bmx t)  ","category":"page"},{"location":"physics/boussinesq_approximation/#","page":"The Boussinesq approximation","title":"The Boussinesq approximation","text":"where rho_0 is a constant 'reference' density, rho_*(z) is a background density profile typically associated with the hydrostatic compression of seawater in the deep ocean, and rho(bmx t) is the dynamic component of density corresponding to inhomogeneous distributions of a buoyant tracer such as temperature or salinity. The fluid buoyancy, associated with the buoyant acceleration of fluid, is defined in terms of rho as","category":"page"},{"location":"physics/boussinesq_approximation/#","page":"The Boussinesq approximation","title":"The Boussinesq approximation","text":"    b = - fracg rhorho_0  ","category":"page"},{"location":"physics/boussinesq_approximation/#","page":"The Boussinesq approximation","title":"The Boussinesq approximation","text":"where g is gravitational acceleration.","category":"page"},{"location":"physics/boussinesq_approximation/#","page":"The Boussinesq approximation","title":"The Boussinesq approximation","text":"The Boussinesq approximation is valid when rho_* + rho ll rho_0, which implies the fluid is approximately incompressible[2] In this case, the mass conservation equation reduces to the continuity equation","category":"page"},{"location":"physics/boussinesq_approximation/#","page":"The Boussinesq approximation","title":"The Boussinesq approximation","text":"    bmnabla bmcdot bmu = partial_x u + partial_y v + partial_z w = 0  \n    tageqcontinuity","category":"page"},{"location":"physics/boussinesq_approximation/#","page":"The Boussinesq approximation","title":"The Boussinesq approximation","text":"[2]: Incompressible fluids do not support acoustic waves.","category":"page"},{"location":"physics/boussinesq_approximation/#The-momentum-conservation-equation-1","page":"The Boussinesq approximation","title":"The momentum conservation equation","text":"","category":"section"},{"location":"physics/boussinesq_approximation/#","page":"The Boussinesq approximation","title":"The Boussinesq approximation","text":"The equations governing the conservation of momentum in a rotating fluid, including buoyancy via the Boussinesq approximation and including the averaged effects of surface gravity waves at the top of the domain via the Craik-Leibovich approximation are","category":"page"},{"location":"physics/boussinesq_approximation/#","page":"The Boussinesq approximation","title":"The Boussinesq approximation","text":"    partial_t bmu + left ( bmu bmcdot bmnabla right ) bmu\n        + left ( bmf - bmnabla times bmu^S right ) times bmu = - bmnabla phi + b bmhat z\n        - bmnabla bmcdot bmtau - partial_t bmu^S + bmF_u  \n    tageqmomentum","category":"page"},{"location":"physics/boussinesq_approximation/#","page":"The Boussinesq approximation","title":"The Boussinesq approximation","text":"where b is buoyancy, bmtau is the kinematic stress tensor, bmF_u denotes an internal forcing of the velocity field bmu, phi is the potential associated with kinematic and constant hydrostatic contributions to pressure, bmu^S is the 'Stokes drift' velocity field associated with surface gravity waves, and bmf is Coriolis parameter, or the background vorticity associated with the specified rate of rotation of the frame of reference.","category":"page"},{"location":"physics/boussinesq_approximation/#The-tracer-conservation-equation-1","page":"The Boussinesq approximation","title":"The tracer conservation equation","text":"","category":"section"},{"location":"physics/boussinesq_approximation/#","page":"The Boussinesq approximation","title":"The Boussinesq approximation","text":"The conservation law for tracers in Oceananigans.jl is","category":"page"},{"location":"physics/boussinesq_approximation/#","page":"The Boussinesq approximation","title":"The Boussinesq approximation","text":"    partial_t c + bmu bmcdot bmnabla c = - bmnabla bmcdot bmq_c + F_c  \n    tageqtracer","category":"page"},{"location":"physics/boussinesq_approximation/#","page":"The Boussinesq approximation","title":"The Boussinesq approximation","text":"where bmq_c is the diffusive flux of c and F_c is an arbitrary source term. Oceananigans.jl permits arbitrary tracers and thus an arbitrary number of tracer equations to be solved simultaneously with the momentum equations.","category":"page"},{"location":"appendix/staggered_grid/#Staggered-grid-1","page":"Staggered grid","title":"Staggered grid","text":"","category":"section"},{"location":"appendix/staggered_grid/#","page":"Staggered grid","title":"Staggered grid","text":"Velocities u, v, and w are defined on the faces of the cells, which are coincident with three orthogonal coordinate axes (the Cartesian axes in the case of Oceananigans). Pressure p and tracers c are stored at the cell  centers as cell averages. See figure \\ref{fig:staggered_grid} for a schematic of the different control volumes. Other quantities may be defined at other locations. For example, vorticity bmomega = nablatimesbmu is defined at the cell edges.[1]","category":"page"},{"location":"appendix/staggered_grid/#","page":"Staggered grid","title":"Staggered grid","text":"[1]: In 2D it would more correct to say the cell corners. In 3D, variables like vorticity lie at the same vertical levels as the cell-centered variables and so they really lie at the cell edges.","category":"page"},{"location":"appendix/staggered_grid/#","page":"Staggered grid","title":"Staggered grid","text":"(Image: Schematic of control volumes) Figure 1: A schematic of the control volumes in a two-dimensional staggered grid. Note that pressure p (and tracers) is defined at the center of the control volume. The u control volumes are centered on the left and right edges of the pressure control volume while the v control volumes are centered on the top and bottom edges of the pressure control volumes. Figure credit: \\citet{Kumar16}","category":"page"},{"location":"appendix/staggered_grid/#","page":"Staggered grid","title":"Staggered grid","text":"This staggered arrangement of variables is more complicated than the collocated grid arrangement but is greatly beneficial as it avoids the odd-even decoupling between the pressure and velocity if they are stored at the same positions. \\citet[\\S6.1]{Patankar80} discusses this problem in the presence of a zigzag pressure field: on a 1D collocated grid the velocity at the point i is influenced by the pressure at points i-1 and i+1, and a zigzag pressure field will be felt as a uniform pressure, which is obviously wrong and would reduce the accuracy of the solution. The pressure is effectively taken from a coarser grid than what is actually used. The basic problem is that the momentum equations will use the pressure difference between two alternate points when it should be using two adjacent points.","category":"page"},{"location":"appendix/staggered_grid/#","page":"Staggered grid","title":"Staggered grid","text":"From the viewpoint of linear algebra, these spurious pressure modes correspond to solutions in the null space of the pressure projection operator with eigenvalue zero and are thus indistinguishable from a uniform pressure field \\citep{Sani81}.","category":"page"},{"location":"appendix/staggered_grid/#","page":"Staggered grid","title":"Staggered grid","text":"The staggered grid was first introduced by \\citet{Harlow65} with their \\emph{marker and cell} method. In meteorology and oceanography, the staggered grid is usually referred to as the Arakawa C-grid after \\citet{Arakawa77}, who investigated four different staggered grids and the unstaggered A-grid for use in an atmospheric model.","category":"page"},{"location":"appendix/staggered_grid/#","page":"Staggered grid","title":"Staggered grid","text":"\\citet{Arakawa77} investigated the dispersion relation of inertia-gravity waves[2] traveling in the x-direction","category":"page"},{"location":"appendix/staggered_grid/#","page":"Staggered grid","title":"Staggered grid","text":"  omega^2 = f^2 + gHk^2","category":"page"},{"location":"appendix/staggered_grid/#","page":"Staggered grid","title":"Staggered grid","text":"in the linearized rotating shallow-water equations for five grids. Here omega is the angular frequency, H is the height of the fluid and k is the wavenumber in the x-direction. Looking at the effect of spatial discretization error on the frequency of these waves they find that the B and C-grids reproduce the dispersion relation most closely out of the five \\citep[Figure 5]{Arakawa77}. In particular, the dispersion relation for the C-grid is given by","category":"page"},{"location":"appendix/staggered_grid/#","page":"Staggered grid","title":"Staggered grid","text":"  omega^2 = f^2 left cos^2 left( frackDelta2 right)\n             + 4 left( fraclambdaDelta right)^2 sin^2 left( frackDelta2 right) right","category":"page"},{"location":"appendix/staggered_grid/#","page":"Staggered grid","title":"Staggered grid","text":"where lambda is the wavelength and Delta is the grid spacing. Paraphrasing \\citet[p. 184]{Arakawa77}: The wavelength of the shortest resolvable wave is 2Delta with corresponding wavenumber k = piDelta so it is sufficient to evaluate the dispersion relation over the range 0  kDelta  pi. The frequency is monotonically increasing for lambdaDelta  frac12 and monotonically decreasing for lambdaDelta  frac12. For the fourth smallest wave lambdaDelta = frac12 we get omega^2 = f^2 which matches the k = 0 wave. Furthermore, the group velocity is zero for all k. On the other grids, waves with kDelta = pi can behave like pure inertial oscillations or stationary waves, which is bad.","category":"page"},{"location":"appendix/staggered_grid/#","page":"Staggered grid","title":"Staggered grid","text":"The B and C-grids are less oscillatory than the others and quite faithfully simulate geostrophic adjustment. However, the C-grid is the only one that faithfully reproduces the two-dimensional dispersion relation omega^2(k ell), all the other grids have false maxima, and so \\citet{Arakawa77} conclude that the C-grid is best for simulating geostrophic adjustment except for abnormal situations in which lambdaDelta is less than or close to 1. This seems to have held true for most atmospheric and oceanographic simulations as the C-grid is popular and widely used.","category":"page"},{"location":"appendix/staggered_grid/#","page":"Staggered grid","title":"Staggered grid","text":"[2]: Apparently also called Poincaré waves, Sverdrup waves, and \\emph{rotational gravity waves} \\citep[\\S13.9]{Kundu15}.","category":"page"},{"location":"model_setup/setting_initial_conditions/#Setting-initial-conditions-1","page":"Setting initial conditions","title":"Setting initial conditions","text":"","category":"section"},{"location":"model_setup/setting_initial_conditions/#","page":"Setting initial conditions","title":"Setting initial conditions","text":"Initial conditions are imposed after model construction. This can be easily done using the the set! function, which allows the setting of initial conditions using constant values, arrays, or functions.","category":"page"},{"location":"model_setup/setting_initial_conditions/#","page":"Setting initial conditions","title":"Setting initial conditions","text":"set!(model, u=0.1, v=1.5)","category":"page"},{"location":"model_setup/setting_initial_conditions/#","page":"Setting initial conditions","title":"Setting initial conditions","text":"∂T∂z = 0.01\nϵ(σ) = σ * randn()\nT₀(x, y, z) = ∂T∂z * z + ϵ(1e-8)\nset!(model, T=T₀)","category":"page"},{"location":"model_setup/setting_initial_conditions/#","page":"Setting initial conditions","title":"Setting initial conditions","text":"tip: Divergence-free velocity fields\nNote that as part of the time-stepping algorithm, the velocity field is made divergence-free at every time step. So if a model is not initialized with a divergence-free velocity field, it may change on the first time step. As a result tracers may not be conserved up to machine precision at the first time step.","category":"page"},{"location":"model_setup/tracers/#Tracers-1","page":"Tracers","title":"Tracers","text":"","category":"section"},{"location":"model_setup/tracers/#","page":"Tracers","title":"Tracers","text":"The tracers to be advected around can be specified via a list of symbols. By default the model evolves temperature and salinity","category":"page"},{"location":"model_setup/tracers/#","page":"Tracers","title":"Tracers","text":"tracers = (:T, :S)","category":"page"},{"location":"model_setup/tracers/#","page":"Tracers","title":"Tracers","text":"but any number of arbitrary tracers can be appended to this list. For example, to evolve quantities C_1, CO₂, and nitrogen as passive tracers you could set them up as","category":"page"},{"location":"model_setup/tracers/#","page":"Tracers","title":"Tracers","text":"tracers = (:T, :S, :C₁, :CO₂, :nitrogen)","category":"page"},{"location":"model_setup/tracers/#","page":"Tracers","title":"Tracers","text":"info: Active vs. passive tracers\nAn active tracer typically denotes a tracer quantity that affects the fluid dynamics through buoyancy. In the ocean temperature and salinity are active tracers. Passive tracers, on the other hand, typically do not affect the fluid dynamics are are passively advected around by the flow field.","category":"page"},{"location":"model_setup/diagnostics/#Diagnostics-1","page":"Diagnostics","title":"Diagnostics","text":"","category":"section"},{"location":"model_setup/diagnostics/#","page":"Diagnostics","title":"Diagnostics","text":"Diagnostics are a set of general utilities that can be called on-demand during time-stepping to compute quantities of interest you may want to save to disk, such as the horizontal average of the temperature, the maximum velocity, or to produce a time series of salinity. They also include utilities for diagnosing model health, such as the CFL number or to check for NaNs.","category":"page"},{"location":"model_setup/diagnostics/#","page":"Diagnostics","title":"Diagnostics","text":"Diagnostics are stored as a list of diagnostics in simulation.diagnostics. Diagnostics can be specified at model creation time or be specified at any later time and appended (or assigned with a key value pair) to simulation.diagnostics.","category":"page"},{"location":"model_setup/diagnostics/#","page":"Diagnostics","title":"Diagnostics","text":"Most diagnostics can be run at specified frequencies (e.g. every 25 time steps) or specified intervals (e.g. every 15 minutes of simulation time). If you'd like to run a diagnostic on demand then do not specify a frequency or interval (and do not add it to simulation.diagnostics).","category":"page"},{"location":"model_setup/diagnostics/#","page":"Diagnostics","title":"Diagnostics","text":"We describe the HorizontalAverage diagnostic in detail below but see the API documentation for other diagnostics such as TimeSeries, FieldMaximum, CFL, and NaNChecker.","category":"page"},{"location":"model_setup/diagnostics/#Horizontal-averages-1","page":"Diagnostics","title":"Horizontal averages","text":"","category":"section"},{"location":"model_setup/diagnostics/#","page":"Diagnostics","title":"Diagnostics","text":"You can create a HorizontalAverage diagnostic by passing a field to the constructor, e.g.","category":"page"},{"location":"model_setup/diagnostics/#","page":"Diagnostics","title":"Diagnostics","text":"model = Model(grid=RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1)))\nsimulation = Simulation(model, Δt=6, stop_iteration=10)\nT_avg = HorizontalAverage(model.tracers.T)\npush!(simulation.diagnostics, T_avg)","category":"page"},{"location":"model_setup/diagnostics/#","page":"Diagnostics","title":"Diagnostics","text":"which can then be called on-demand via T_avg(model) to return the horizontally averaged temperature. When running on the GPU you may want it to return an Array instead of a CuArray in case you want to save the horizontal average to disk in which case you'd want to construct it like","category":"page"},{"location":"model_setup/diagnostics/#","page":"Diagnostics","title":"Diagnostics","text":"model = Model(grid=RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1)))\nsimulation = Simulation(model, Δt=6, stop_iteration=10)\nT_avg = HorizontalAverage(model.tracers.T, return_type=Array)\npush!(simulation.diagnostics, T_avg)","category":"page"},{"location":"model_setup/diagnostics/#","page":"Diagnostics","title":"Diagnostics","text":"You can also use pass an abstract operator to take the horizontal average of any diagnosed quantity. For example, to compute the horizontal average of the vertical component of vorticity:","category":"page"},{"location":"model_setup/diagnostics/#","page":"Diagnostics","title":"Diagnostics","text":"model = Model(grid=RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1)))\nsimulation = Simulation(model, Δt=6, stop_iteration=10)\nu, v, w = model.velocities\nζ = ∂x(v) - ∂y(u)\nζ_avg = HorizontalAverage(ζ)\nsimulation.diagnostics[:vorticity_profile] = ζ_avg","category":"page"},{"location":"model_setup/diagnostics/#","page":"Diagnostics","title":"Diagnostics","text":"See HorizontalAverage for more details and options.","category":"page"},{"location":"model_setup/number_type/#Number-type-1","page":"Number type","title":"Number type","text":"","category":"section"},{"location":"model_setup/number_type/#","page":"Number type","title":"Number type","text":"Passing float_type=Float64 or float_type=Float32 to the Model constructor causes the model to store all numbers with 64-bit or 32-bit floating point precision.","category":"page"},{"location":"model_setup/number_type/#","page":"Number type","title":"Number type","text":"note: Avoiding mixed-precision operations\nWhen not using Float64 be careful to not mix different precisions as it could introduce implicit type conversions which can negatively effect performance. You can pass the number type desires to many constructors to enforce the type you want: e.g. RegularCartesianGrid(Float32; size=(16, 16, 16), length=(1, 1, 1)) and ConstantIsotropicDiffusivity(Float16; κ=1//7, ν=2//7).","category":"page"},{"location":"model_setup/number_type/#","page":"Number type","title":"Number type","text":"warning: Effect of floating point precision on simulation accuracy\nWhile we run many tests with both Float32 and Float64 it is not clear whether Float32 is precise enough to provide similar accuracy in all use cases. If accuracy is a concern, stick to Float64.We will be actively investigating the possibility of using lower precision floating point numbers such as Float32 and Float16 for fluid dynamics as well as the use of alternative number types such as Posits and Sonums.","category":"page"},{"location":"model_setup/overview/#Model-setup-1","page":"Overview","title":"Model setup","text":"","category":"section"},{"location":"model_setup/overview/#","page":"Overview","title":"Overview","text":"This section describes all the options and features that can be used to set up a model. For more detailed information consult the API documentation.","category":"page"},{"location":"model_setup/overview/#","page":"Overview","title":"Overview","text":"Each structure covered in this section can be constructed and passed to the Model constructor. For examples of model construction, see the examples. The verification experiments provide more advanced examples.","category":"page"},{"location":"model_setup/overview/#","page":"Overview","title":"Overview","text":"For reference, here are all the option or keyword arguments that can be passed to Model. See the different sections on the sidebar for more details and examples for each keyword argument.","category":"page"},{"location":"model_setup/overview/#","page":"Overview","title":"Overview","text":"Model","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/#Buoyancy-model-and-equations-of-state-1","page":"Buoyancy model and equations of state","title":"Buoyancy model and equations of state","text":"","category":"section"},{"location":"physics/buoyancy_and_equations_of_state/#","page":"Buoyancy model and equations of state","title":"Buoyancy model and equations of state","text":"The buoyancy model determines the relationship between tracers and the buoyancy b in the momentum equation.","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/#Buoyancy-tracer-1","page":"Buoyancy model and equations of state","title":"Buoyancy tracer","text":"","category":"section"},{"location":"physics/buoyancy_and_equations_of_state/#","page":"Buoyancy model and equations of state","title":"Buoyancy model and equations of state","text":"The simplest buoyancy model uses buoyancy b itself as a tracer: b obeys the tracer conservation equation and is used directly in the momentum equations in the momentum equation.","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/#Seawater-buoyancy-1","page":"Buoyancy model and equations of state","title":"Seawater buoyancy","text":"","category":"section"},{"location":"physics/buoyancy_and_equations_of_state/#","page":"Buoyancy model and equations of state","title":"Buoyancy model and equations of state","text":"For seawater buoyancy is, in general, modeled as a function of conservative temperature theta, absolute salinity S, and depth below the ocean surface d via","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/#","page":"Buoyancy model and equations of state","title":"Buoyancy model and equations of state","text":"    b = - fracgrho_0 rho left (theta S d right )  \n    tageqseawater-buoyancy","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/#","page":"Buoyancy model and equations of state","title":"Buoyancy model and equations of state","text":"where g is gravitational acceleration, rho_0 is the reference density. The function rho(theta S d) in the seawater buoyancy relationship that links conservative temperature, salinity, and depth to the density perturbation is called the equation of state. Both theta and S obey the tracer conservation equation.","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/#Linear-equation-of-state-1","page":"Buoyancy model and equations of state","title":"Linear equation of state","text":"","category":"section"},{"location":"physics/buoyancy_and_equations_of_state/#","page":"Buoyancy model and equations of state","title":"Buoyancy model and equations of state","text":"Buoyancy is determined from a linear equation of state via","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/#","page":"Buoyancy model and equations of state","title":"Buoyancy model and equations of state","text":"    b = g left ( alpha_theta theta - beta_S S right )  ","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/#","page":"Buoyancy model and equations of state","title":"Buoyancy model and equations of state","text":"where g is gravitational acceleration, alpha_theta is the thermal expansion coefficient, and beta_S is the haline contraction coefficient.","category":"page"},{"location":"physics/buoyancy_and_equations_of_state/#Nonlinear-equation-of-state-1","page":"Buoyancy model and equations of state","title":"Nonlinear equation of state","text":"","category":"section"},{"location":"physics/buoyancy_and_equations_of_state/#","page":"Buoyancy model and equations of state","title":"Buoyancy model and equations of state","text":"Buoyancy is determined by the simplified equations of state introduced by Roquet et al (2015).","category":"page"},{"location":"model_setup/boundary_conditions/#Boundary-conditions-1","page":"Boundary conditions","title":"Boundary conditions","text":"","category":"section"},{"location":"model_setup/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"A boundary condition is applied to each field, dimension, and endpoint. There are left and right boundary conditions for each of the x, y, and z dimensions so each field is associated with 6 boundary conditions. Each of these boundary conditions may be specified individually. Each boundary condition can be specified via a constant value, an array, or a function.","category":"page"},{"location":"model_setup/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"The left and right boundary conditions associated with the x-dimension are called west and east, respectively. For the y-dimension, left and right are called south and north. For the z-dimension, left and right are called bottom and top.","category":"page"},{"location":"model_setup/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"See Numerical implementation of boundary conditions for more details.","category":"page"},{"location":"model_setup/boundary_conditions/#Types-of-boundary-conditions-1","page":"Boundary conditions","title":"Types of boundary conditions","text":"","category":"section"},{"location":"model_setup/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"Periodic\nFlux\nValue\nGradient\nNo-penetration","category":"page"},{"location":"model_setup/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"Notice that open boundary conditions and radiation boundary conditions can be imposed via flux or value boundary conditions defined by a function or array. Or alternatively, through a forcing function which is more flexible.","category":"page"},{"location":"model_setup/boundary_conditions/#Default-boundary-conditions-1","page":"Boundary conditions","title":"Default boundary conditions","text":"","category":"section"},{"location":"model_setup/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"By default, periodic boundary conditions are applied on all fields along periodic dimensions. Otherwise tracers get no-flux boundary conditions and velocities get free-slip and no-penetration boundary conditions.","category":"page"},{"location":"model_setup/boundary_conditions/#Boundary-condition-structures-1","page":"Boundary conditions","title":"Boundary condition structures","text":"","category":"section"},{"location":"model_setup/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"Oceananigans uses a hierarchical structure to expressing boundary conditions.","category":"page"},{"location":"model_setup/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"A BoundaryCondition is associated with every field, dimension, and endpoint.\nBoundary conditions specifying the condition at the left and right endpoints are grouped into CoordinateBoundaryConditions.\nA set of three CoordinateBoundaryConditions specifying the boundary conditions along the x, y, and z dimensions for a single field are grouped into a FieldBoundaryConditions named tuple.\nA set of FieldBoundaryConditions, one for each field, are grouped together into a named tuple and passed to the Model constructor.","category":"page"},{"location":"model_setup/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"Boundary conditions are defined at model construction time by passing a named tuple of FieldBoundaryConditions specifying boundary conditions on every field: velocities (u, v, w) and all tracers.","category":"page"},{"location":"model_setup/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"See the sections below for more details. The examples and verification experiments also provide examples for setting up many different kinds of boundary conditions.","category":"page"},{"location":"model_setup/boundary_conditions/#Creating-individual-boundary-conditions-1","page":"Boundary conditions","title":"Creating individual boundary conditions","text":"","category":"section"},{"location":"model_setup/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"Some examples of creating individual boundary conditions:","category":"page"},{"location":"model_setup/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"A constant Value (Dirchlet) boundary condition, perhaps representing a constant temperature at some boundary.","category":"page"},{"location":"model_setup/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"using Oceananigans # hide\nconstant_T_bc = ValueBoundaryCondition(20)","category":"page"},{"location":"model_setup/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"A constant flux boundary condition, perhaps representing a constant wind stress at some boundary such as the ocean surface.","category":"page"},{"location":"model_setup/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"using Oceananigans # hide\nρ₀ = 1027  # Reference density [kg/m³]\nτₓ = 0.08  # Wind stress [N/m²]\nwind_stress_bc = FluxBoundaryCondition(τₓ/ρ₀)","category":"page"},{"location":"model_setup/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"A spatially varying (white noise) cooling flux to be imposed at some boundary. Note that the boundary condition is given by the array Q here. When running on the GPU, Q must be converted to a CuArray.","category":"page"},{"location":"model_setup/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"using Oceananigans # hide\nNx = Ny = 16  # Number of grid points.\n\nρ₀ = 1027  # Reference density [kg/m³]\ncₚ = 4000  # Heat capacity of water at constant pressure [J/kg/K]\n\nQ  = randn(Nx, Ny) ./ (ρ₀ * cₚ)\n\nwhite_noise_T_bc = FluxBoundaryCondition(Q)","category":"page"},{"location":"model_setup/boundary_conditions/#Specifying-boundary-conditions-with-functions-1","page":"Boundary conditions","title":"Specifying boundary conditions with functions","text":"","category":"section"},{"location":"model_setup/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"You can also specify the boundary condition via a function. For z boundary conditions the function will be called with the signature","category":"page"},{"location":"model_setup/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"f(i, j, grid, time, iteration, U, C, params)","category":"page"},{"location":"model_setup/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"where i, j is the grid index, grid is model.grid, time is the model.clock.time, iteration is the model.clock.iteration, U is the named tuple model.velocities, C is the named tuple C.tracers, and params is the user-defined model.parameters. The signature is similar for x and y boundary conditions expect that i, j is replaced with j, k and i, k respectively.","category":"page"},{"location":"model_setup/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"We can add a fourth example now:","category":"page"},{"location":"model_setup/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"A spatially varying and time-dependent heating representing perhaps a localized source of heating modulated by a diurnal cycle.","category":"page"},{"location":"model_setup/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"using Oceananigans # hide\n@inline Q(i, j, grid, t, I, U, C, params) = @inbounds exp(-(grid.xC[i]^2 + grid.yC[j]^2)) * sin(2π*t)\nlocalized_heating_bc = FluxBoundaryCondition(Q)","category":"page"},{"location":"model_setup/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"info: Performance of functions in boundary conditions\nFor performance reasons, you should define all functions used in boundary conditions as inline functions via the @inline macro. If any arrays are accessed within the function, disabling bounds-checking with @inbounds will also speed things up.","category":"page"},{"location":"model_setup/boundary_conditions/#Specifying-boundary-conditions-on-a-field-1","page":"Boundary conditions","title":"Specifying boundary conditions on a field","text":"","category":"section"},{"location":"model_setup/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"To, for example, create a set of horizontally periodic field boundary conditions","category":"page"},{"location":"model_setup/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"using Oceananigans # hide\ntopology = (Periodic, Periodic, Bounded)\ngrid = RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1), topology=topology)\nT_bcs = TracerBoundaryConditions(grid,    top = ValueBoundaryCondition(20),\n                                       bottom = GradientBoundaryCondition(0.01))","category":"page"},{"location":"model_setup/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"which will create a FieldBoundaryConditions object for temperature T appropriate for horizontally periodic model configurations where the x and y boundary conditions are all periodic.","category":"page"},{"location":"model_setup/boundary_conditions/#Specifying-model-boundary-conditions-1","page":"Boundary conditions","title":"Specifying model boundary conditions","text":"","category":"section"},{"location":"model_setup/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"A named tuple of FieldBoundaryConditions objects must be passed to the Model constructor specifying boundary conditions on all fields. To, for example, impose non-default boundary conditions on the u-velocity and temperature","category":"page"},{"location":"model_setup/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"using Oceananigans # hide\ntopology = (Periodic, Periodic, Bounded)\ngrid = RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1), topology=topology)\n\nu_bcs = UVelocityBoundaryConditions(grid,   top = ValueBoundaryCondition(+0.1),\n                                         bottom = ValueBoundaryCondition(-0.1))\nT_bcs = TracerBoundaryConditions(grid,   top = ValueBoundaryCondition(20),\n                                      bottom = GradientBoundaryCondition(0.01))\n\nmodel_bcs = SolutionBoundaryConditions(u=u_bcs, T=T_bcs)\n\nmodel = Model(grid=grid, boundary_conditions=model_bcs)\nnothing # hide","category":"page"},{"location":"gallery/#Gallery-1","page":"Gallery","title":"Gallery","text":"","category":"section"},{"location":"gallery/#","page":"Gallery","title":"Gallery","text":"Collection of cool movies!","category":"page"},{"location":"gallery/#[Deep-convection](https://www.youtube.com/watch?vkpUrxnKKMjI)-1","page":"Gallery","title":"Deep convection","text":"","category":"section"},{"location":"gallery/#","page":"Gallery","title":"Gallery","text":"An idealized simulation of deep convection in the ocean. The simulation employs a resolution of 256x256x128 volumes in a 2x2x1 km horizontally periodic domain. Heat is sucked out of the ocean surface within a cooling disk of radius 600 m at a rate of 800 W/m² which cools the surface water and making it denser. This cold dense water then sinks into the ocean interior, initiating a convective process that penetrates deep into the ocean.","category":"page"},{"location":"gallery/#","page":"Gallery","title":"Gallery","text":"This deep convection process can happen when a cold storm passes through warmer waters, which happens for example in the Labrador Sea.","category":"page"},{"location":"gallery/#","page":"Gallery","title":"Gallery","text":"The video shows the temperature field and the domain is sliced in half so the convection happening under the cooling disk is clear.","category":"page"},{"location":"gallery/#","page":"Gallery","title":"Gallery","text":"(Image: Watch deep convection in action)","category":"page"},{"location":"gallery/#[Free-convection](https://www.youtube.com/watch?vyq4op9h3xcU)-1","page":"Gallery","title":"Free convection","text":"","category":"section"},{"location":"gallery/#","page":"Gallery","title":"Gallery","text":"An idealized simulation of free convection in the ocean. The simulation employs a resolution of 256x256x256 volumes in a 100x100x100 m horizontally periodic domain. Heat is sucked out of the ocean surface at a rate of 75 W/m² which cools the surface water and making it denser. This cold dense water then sinks into the ocean interior, initiating a convective process that keeps mixing the upper layer of the ocean. This \"mixed layer\" has a relatively constant temperature and keeps deepening as the surface is cooled.","category":"page"},{"location":"gallery/#","page":"Gallery","title":"Gallery","text":"The video shows the temperature field and the domain is sliced in half.","category":"page"},{"location":"gallery/#","page":"Gallery","title":"Gallery","text":"(Image: Watch free convection in action)","category":"page"},{"location":"gallery/#[Winds-blowing-over-the-ocean](https://www.youtube.com/watch?vIRncfbvuiy8)-1","page":"Gallery","title":"Winds blowing over the ocean","text":"","category":"section"},{"location":"gallery/#","page":"Gallery","title":"Gallery","text":"An idealized simulation of a strong wind stress acting on the surface of a stratified ocean. The simulation employs a resolution of 256x256x256 volumes in a 100x100x100 m horizontally periodic domain. A pretty strong wind stress of 0.1 N/m² is applied in the x direction which mechanically mixes the upper layer of the ocean. This leads to a \"mixed layer\" of constant temperature near the surface of the ocean. You can also see the onset of Kelvin-Helmholtz instabilities as the mechanical mixing sets in.","category":"page"},{"location":"gallery/#","page":"Gallery","title":"Gallery","text":"The video shows the temperature field in the top 25 meters and the domain is sliced in half for visualization. The line plots show the horizontally averaged temperature profile (top right), horizontally averaged turbulent kinetic energy (middle right), and the horizontally averaged buoyancy flux (or temperature flux).","category":"page"},{"location":"gallery/#","page":"Gallery","title":"Gallery","text":"(Image: Watch winds blowing over the ocean)","category":"page"},{"location":"gallery/#[Free-convection-with-wind-stress](https://www.youtube.com/watch?vob6OMQgPfI4)-1","page":"Gallery","title":"Free convection with wind stress","text":"","category":"section"},{"location":"gallery/#","page":"Gallery","title":"Gallery","text":"An idealized simulation of a strong wind stress acting on the surface of a stratified ocean along with a cooling flux that sucks heat out of the surface. The simulation employs a resolution of 256x256x256 volumes in a 100x100x100 m horizontally periodic domain. A pretty strong wind stress of 0.1 N/m² is applied in the x direction which mechanically mixes the upper layer of the ocean. Also, heat is sucked out of the ocean surface at a rate of 75 W/m² which cools the surface water and making it denser. This cold dense water then sinks into the ocean interior, initiating a convective process that keeps mixing the upper layer of the ocean. This leads to a \"mixed layer\" of constant temperature near the surface of the ocean. You can also see the onset of Kelvin-Helmholtz instabilities as the mechanical mixing sets in.","category":"page"},{"location":"gallery/#","page":"Gallery","title":"Gallery","text":"The video shows the temperature field and the domain is sliced in half for visualization. The line plots show the horizontally averaged temperature profile (top right), horizontally averaged turbulent kinetic energy (middle right), and the horizontally averaged buoyancy flux (or temperature flux). The unusual periodic prism colormap is used to show the fine details at the surface as it cools and the layers of different temperatures (the isopycnals) being perturbed by internal waves.","category":"page"},{"location":"gallery/#","page":"Gallery","title":"Gallery","text":"(Image: Watch free convection with wind stress in action)","category":"page"},{"location":"model_setup/time_stepping/#Time-stepping-1","page":"Time stepping","title":"Time stepping","text":"","category":"section"},{"location":"model_setup/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"Once you're ready to time step the model simply call","category":"page"},{"location":"model_setup/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"time_step!(model; Δt=10)","category":"page"},{"location":"model_setup/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"to take a single time step with step size 10. To take multiple time steps also pass an Nt keyword argument like","category":"page"},{"location":"model_setup/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"time_step!(model; Δt=10, Nt=50)","category":"page"},{"location":"model_setup/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"By default, time_step! uses a first-order forward Euler time step to take the first time step then uses a second-order Adams-Bashforth method for the remaining time steps (which required knowledge of the previous time step). If you are resuming time-stepping then you should not use a forward Euler initialization time step. This can be done via","category":"page"},{"location":"model_setup/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"time_step!(model; Δt=10)\ntime_step!(model; Δt=10, Nt=50, init_with_euler=false)","category":"page"},{"location":"model_setup/time_stepping/#Adaptive-time-stepping-1","page":"Time stepping","title":"Adaptive time stepping","text":"","category":"section"},{"location":"model_setup/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"Adaptive time stepping can be acomplished using the TimeStepWizard. It can be used to compute time steps based on capping the CFL number at some value. You must remember to update the time step every so often. For example, to cap the CFL number at 0.3 and update the time step every 50 time steps:","category":"page"},{"location":"model_setup/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"wizard = TimeStepWizard(cfl=0.3, Δt=1.0, max_change=1.2, max_Δt=30.0)\n\nwhile model.clock.time < end_time\n    time_step!(model; Δt=wizard.Δt, Nt=50)\n    update_Δt!(wizard, model)\nend","category":"page"},{"location":"model_setup/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"See TimeStepWizard for documentation of other features and options.","category":"page"},{"location":"model_setup/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"warn: Maximum CFL with second-order Adams-Bashforth time stepping\nFor stable time-stepping it is recommended to cap the CFL at 0.3 or smaller, although capping it at 0.5 works well for certain simulations. For some simulations, it may be neccessary to cap the CFL number at 0.1 or lower.","category":"page"},{"location":"model_setup/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"warn: Adaptive time stepping with second-order Adams-Bashforth time stepping\nYou should use an initializer forward Euler time step whenever changing the time step (i.e. init_with_euler=true which is the default value).","category":"page"},{"location":"physics/coriolis_forces/#Coriolis-forces-1","page":"Coriolis forces","title":"Coriolis forces","text":"","category":"section"},{"location":"physics/coriolis_forces/#","page":"Coriolis forces","title":"Coriolis forces","text":"The Coriolis model controls the manifestation of the term bmf times bmu in the momentum equation.","category":"page"},{"location":"physics/coriolis_forces/#The-traditional-and-non-traditional-f-plane-approximation-1","page":"Coriolis forces","title":"The traditional and non-traditional f-plane approximation","text":"","category":"section"},{"location":"physics/coriolis_forces/#","page":"Coriolis forces","title":"Coriolis forces","text":"Under an f-plane approximation[3] the reference frame in which the momentum and tracer equations are solved rotates at a constant rate. ","category":"page"},{"location":"physics/coriolis_forces/#The-traditional-f-plane-approximation-1","page":"Coriolis forces","title":"The traditional f-plane approximation","text":"","category":"section"},{"location":"physics/coriolis_forces/#","page":"Coriolis forces","title":"Coriolis forces","text":"In the traditional f-plane approximation, the coordinate system rotates around a vertical axis such that","category":"page"},{"location":"physics/coriolis_forces/#","page":"Coriolis forces","title":"Coriolis forces","text":"    bmf = f bmhat z","category":"page"},{"location":"physics/coriolis_forces/#","page":"Coriolis forces","title":"Coriolis forces","text":"where f is constant and determined by the user.","category":"page"},{"location":"physics/coriolis_forces/#The-non-traditional-f-plane-approximation-1","page":"Coriolis forces","title":"The non-traditional f-plane approximation","text":"","category":"section"},{"location":"physics/coriolis_forces/#","page":"Coriolis forces","title":"Coriolis forces","text":"In the non-traditional f-plane approximation, the coordinate system rotates around an axis in the yz-plane, such that","category":"page"},{"location":"physics/coriolis_forces/#","page":"Coriolis forces","title":"Coriolis forces","text":"    bmf = f_y bmhat y + f_z bmhat z","category":"page"},{"location":"physics/coriolis_forces/#","page":"Coriolis forces","title":"Coriolis forces","text":"where f_y and f_z are constant and determined by the user.","category":"page"},{"location":"physics/coriolis_forces/#","page":"Coriolis forces","title":"Coriolis forces","text":"[3]: The f-plane approximation is used to model the effects of Earth's rotation on   anisotropic fluid motion in a plane tangent to the Earth's surface. In this case, the projection of Earth's   rotation vector at latitude varphi and onto a coordinate system in which x y z correspond to the    directions east, north, and up is   math       \\bm{f} \\approx \\frac{4 \\pi}{\\text{day}} \\left ( \\cos \\varphi \\bm{\\hat y} + \\sin \\varphi \\bm{\\hat z} \\right ) \\, , $   where the Earth's rotation rate is approximately 2 pi  textday.   The traditional f-plane approximation neglects the y-component of this projection, which is appropriate for    fluid motions with large horizontal-to-vertical aspect ratios.","category":"page"},{"location":"physics/coriolis_forces/#The-\\beta-plane-approximation-1","page":"Coriolis forces","title":"The beta-plane approximation","text":"","category":"section"},{"location":"physics/coriolis_forces/#","page":"Coriolis forces","title":"Coriolis forces","text":"Under the beta-plane approximation, the rotation axis is vertical as for the f-plane approximation, but f is expanded in a Taylor series around a central latitude such that","category":"page"},{"location":"physics/coriolis_forces/#","page":"Coriolis forces","title":"Coriolis forces","text":"    bmf = left ( f_0 + beta y right ) bmhat z  ","category":"page"},{"location":"physics/coriolis_forces/#","page":"Coriolis forces","title":"Coriolis forces","text":"where f_0 is the planetary vorticity at some central latitude, and beta is the planetary vorticity gradient. The beta-plane model is not periodic in y and thus can be used only in domains that are bounded in the y-direction.","category":"page"},{"location":"model_setup/coriolis/#Coriolis-1","page":"Coriolis (rotation)","title":"Coriolis","text":"","category":"section"},{"location":"model_setup/coriolis/#","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"The Coriolis option determines whether the fluid experiences the effect of the Coriolis force, or rotation. Currently three options are available: no rotation, f-plane, and beta-plane.","category":"page"},{"location":"model_setup/coriolis/#","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"info: Coriolis vs. rotation\nIf you are wondering why this option is called \"Coriolis\" it is because rotational effects could include the Coriolis and centripetal forces, both of which arise in non-inertial reference frames. But here the model only considers the Coriolis force.","category":"page"},{"location":"model_setup/coriolis/#","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"To use no rotation, pass","category":"page"},{"location":"model_setup/coriolis/#","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"coriolis = nothing","category":"page"},{"location":"model_setup/coriolis/#f-plane-1","page":"Coriolis (rotation)","title":"f-plane","text":"","category":"section"},{"location":"model_setup/coriolis/#","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"To set up an f-plane with, for example, Coriolis parameter f = 10^-4 texts^-1","category":"page"},{"location":"model_setup/coriolis/#","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"using Oceananigans # hide\ncoriolis = FPlane(f=1e-4)","category":"page"},{"location":"model_setup/coriolis/#","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"An f-plane can also be specified at some latitude on a spherical planet with a planetary rotation rate. For example, to specify an f-plane at a latitude of varphi = 45textN on Earth which has a rotation rate of Omega = 7292115 times 10^-5 texts^-1","category":"page"},{"location":"model_setup/coriolis/#","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"using Oceananigans # hide\ncoriolis = FPlane(rotation_rate=7.292115e-5, latitude=45)","category":"page"},{"location":"model_setup/coriolis/#","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"in which case the value of f is given by 2Omegasinvarphi.","category":"page"},{"location":"model_setup/coriolis/#","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"To set up an f-plane with non-traditional Coriolis terms, for example, with  bmf = (0 f_y f_z) = (0 2 1) times 10^-4 texts^-1,","category":"page"},{"location":"model_setup/coriolis/#","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"using Oceananigans # hide\ncoriolis = NonTraditionalFPlane(fz=1e-4, fy=2e-4)","category":"page"},{"location":"model_setup/coriolis/#","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"An f-plane with non-traditional Coriolis terms can also be specified at some latitude on a spherical planet with a planetary rotation rate. For example, to specify an f-plane at a latitude of varphi = 45textN  on Earth which has a rotation rate of Omega = 7292115 times 10^-5 texts^-1","category":"page"},{"location":"model_setup/coriolis/#","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"using Oceananigans # hide\ncoriolis = NonTraditionalFPlane(rotation_rate=7.292115e-5, latitude=45)","category":"page"},{"location":"model_setup/coriolis/#","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"in which case fz = 2Omegasinvarphi and fy = 2Omegacosvarphi.","category":"page"},{"location":"model_setup/coriolis/#\\beta-plane-1","page":"Coriolis (rotation)","title":"beta-plane","text":"","category":"section"},{"location":"model_setup/coriolis/#","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"To set up a beta-plane the background rotation rate f_0 and the beta parameter must be specified. For example, a beta-plane with f_0 = 10^-4 texts^-1 and beta = 15 times 10^-11 texts^-1textm^-1 can be set up with","category":"page"},{"location":"model_setup/coriolis/#","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"using Oceananigans # hide\ncoriolis = BetaPlane(f₀=1e-4, β=1.5e-11)","category":"page"},{"location":"model_setup/coriolis/#","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"Alternatively, a beta-plane can also be set up at some latitude on a spherical planet with a planetary rotation rate and planetary radius. For example, to specify a beta-plane at a latitude of varphi = 10degreeS on Earth which has a rotation rate of Omega = 7292115 times 10^-5 texts^-1 and a radius of R = 6371 textkm","category":"page"},{"location":"model_setup/coriolis/#","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"using Oceananigans # hide\ncoriolis = BetaPlane(rotation_rate=7.292115e-5, latitude=-10, radius=6371e3)","category":"page"},{"location":"model_setup/coriolis/#","page":"Coriolis (rotation)","title":"Coriolis (rotation)","text":"in which case f_0 = 2Omegasinvarphi and beta = 2Omegacosvarphi  R.","category":"page"},{"location":"numerical_implementation/boundary_conditions/#numerical_bcs-1","page":"Boundary conditions","title":"Numerical implementation of boundary conditions","text":"","category":"section"},{"location":"numerical_implementation/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"We adopt a mixed approach for implementing boundary conditions that uses both halo regions and \"direct\" imposition of boundary conditions, depending on the condition prescribed. We illustrate how boundary conditions are implemented by considering the tracer equation \\eqref{eq:tracer}.","category":"page"},{"location":"numerical_implementation/boundary_conditions/#Gradient-boundary-conditions-1","page":"Boundary conditions","title":"Gradient boundary conditions","text":"","category":"section"},{"location":"numerical_implementation/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"Users impose gradient boundary conditions by prescribing the gradient gamma of a field c across a external boundary partial Omega_b. The prescribed gradient gamma may be a constant, discrete array of values, or an arbitrary function. The gradient boundary condition is enforced setting the value of halo points located outside the domain interior such that","category":"page"},{"location":"numerical_implementation/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"    tageqgradient-bc\n    hatbmn bmcdot bmnabla c _partial Omega_b = gamma  ","category":"page"},{"location":"numerical_implementation/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"where hatbmn is the vector normal to partial Omega_b.","category":"page"},{"location":"numerical_implementation/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"Across the bottom boundary in z, for example, this requires that","category":"page"},{"location":"numerical_implementation/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"    tageqlinear-extrapolation\n    c_i j 0 = c_i j 1 + gamma_i j 1 tfrac12 left ( Delta z_i j 1 + Delta z_i j 0 right )  ","category":"page"},{"location":"numerical_implementation/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"where Delta z_i j 1 = Delta z_i j 0 are the heights of the finite volume at i j and k=1 and k=0. This prescription implies that the z-derivative of c across the boundary at k=1 is","category":"page"},{"location":"numerical_implementation/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"    partial_z c  _i j 1 equiv\n        fracc_i j 1 - c_i j 0tfrac12 left ( Delta z_i j 1 + Delta z_i j 0 right )\n            = gamma_i j 1  ","category":"page"},{"location":"numerical_implementation/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"as prescribed by the user.","category":"page"},{"location":"numerical_implementation/boundary_conditions/#Value-boundary-conditions-1","page":"Boundary conditions","title":"Value boundary conditions","text":"","category":"section"},{"location":"numerical_implementation/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"Users impose value boundary conditions by prescribing c^b, the value of c on the external boundary partial Omega_b. The value c^b may be a constant, array of discrete values, or an arbitrary function. To enforce a value boundary condition, the gradient associated with the difference between c^b and c at boundary-adjacent nodes is diagnosed and used to set the value of the c halo point located outside the boundary.","category":"page"},{"location":"numerical_implementation/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"At the bottom boundary in z, for example, this means that the gradient of c is determined by","category":"page"},{"location":"numerical_implementation/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"gamma = fracc_i j 1 - c^b_i j 1tfrac12 Delta z_i j 1  ","category":"page"},{"location":"numerical_implementation/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"which is then used to set the halo point c_i j 0 via linear extrapolation.","category":"page"},{"location":"numerical_implementation/boundary_conditions/#Flux-boundary-conditions-1","page":"Boundary conditions","title":"Flux boundary conditions","text":"","category":"section"},{"location":"numerical_implementation/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"Users impose flux boundary conditions by prescribing the flux q_c  _b of c across the external boundary partial Omega_b. The flux q_c  _b may be a constant, array of discrete values, or arbitrary function. To explain how flux boundary conditions are imposed in Oceananigans.jl, we note that the average of the tracer conservation equation over a finite volume yields","category":"page"},{"location":"numerical_implementation/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"    partial_t c_i j k = underbrace - frac1V_i j k oint_partial Omega_i j k bmu c + bmq_c  rmd S\n                                          + frac1V_i j k int_V_i j k F_c  rmd V _equiv G_c _i j k  ","category":"page"},{"location":"numerical_implementation/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"where the surface integral over partial Omega_i j k averages the flux of c across the six faces of the finite volume.","category":"page"},{"location":"numerical_implementation/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"An external boundary of a finite volume is associated with a no-penetration condition such that hatbmn bmcdot bmu  _partial Omega_b = 0, where hatbmn is the vector normal to partial Omega_b. Furthermore, the closures currently available in \\texttt{Oceananigans.jl} have the property that bmq_c propto bmnabla c. Thus setting hatbmn bmcdot bmnabla c  _partial Omega_b = 0 on the external boundary implies that the total flux of c across the external boundary is","category":"page"},{"location":"numerical_implementation/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"hatbmn bmcdot left ( bmu c + bmq_c right ) _partial Omega_b = 0  ","category":"page"},{"location":"numerical_implementation/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"Oceananigans.jl exploits this fact to define algorithm that prescribe fluxes across external boundaries partial Omega_b:","category":"page"},{"location":"numerical_implementation/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"Impose a constant gradient hatbmn bmcdot bmnabla c  _partial Omega_b = 0 across external boundaries  via using halo points (similar to \\eqref{eq:gradient-bc}), which ensures that the evaluation of G_c in boundary-adjacent  cells does not include fluxes across the external boundary, and;\nAdd the prescribed flux to the boundary-adjacent volumes prior to calculating G_c\nG_c  _b = G_c  _b - fracA_bV_b q_c  _b  textsign(hatbmn)  \nwhere G_c  _b denotes values of G_c in boundary-adjacent volumes, q_c  _b is the flux prescribed along the boundary,  V_b is the volume of the boundary-adjacent cell, and A_b is the area of the external boundary of the boundary-adjacent cell.\nThe factor textsign(hatbmn) is -1 and +1 on \"left\" and \"right\" boundaries, and accounts for the fact that a positive  flux on a left boundary where textsign(hatbmn) = -1 implies an \"inward\" flux of c that increases interior values of c,  whereas a positive flux on a right boundary where textsign(hatbmn) = 1 implies an \"outward\" flux that decreases interior  values of c.","category":"page"},{"location":"physics/coordinate_system_and_notation/#Coordinate-system-and-notation-1","page":"Coordinate system and notation","title":"Coordinate system and notation","text":"","category":"section"},{"location":"physics/coordinate_system_and_notation/#","page":"Coordinate system and notation","title":"Coordinate system and notation","text":"Oceananigans.jl is formulated in a Cartesian coordinate system bmx = (x y z) with unit vectors bmhat x, bmhat y, and bmhat z, where bmhat x points east, bmhat y points north, and bmhat z points 'upward', opposite the direction of gravitational acceleration. We denote time with t, partial derivatives with respect to time t or a coordinate x with partial_t or partial_x, and denote the gradient operator bmnabla equiv partial_x bmhat x + partial_y bmhat y + partial_z bmhat z. We use u, v, and w to denote the east, north, and vertical velocity components, such that bmu = u bmhat x + v bmhat y + w bmhat z.","category":"page"},{"location":"numerical_implementation/pressure_decomposition/#Pressure-decomposition-1","page":"Pressure decomposition","title":"Pressure decomposition","text":"","category":"section"},{"location":"numerical_implementation/pressure_decomposition/#","page":"Pressure decomposition","title":"Pressure decomposition","text":"In the numerical implementation of the momentum equations, the kinematic potential phi  is split into \"hydrostatic anomaly\" and \"non-hydrostatic\" parts via","category":"page"},{"location":"numerical_implementation/pressure_decomposition/#","page":"Pressure decomposition","title":"Pressure decomposition","text":"    tageqpressure\n    phi(bmx t) = phi_rmhyd(bmx t) + phi_rmnon(bmx t)","category":"page"},{"location":"numerical_implementation/pressure_decomposition/#","page":"Pressure decomposition","title":"Pressure decomposition","text":"The anomalous hydrostatic component of the kinematic potential is defined by ","category":"page"},{"location":"numerical_implementation/pressure_decomposition/#","page":"Pressure decomposition","title":"Pressure decomposition","text":"    tageqhydrostaticpressure\n    partial_z phi_rmhyd equiv -b","category":"page"},{"location":"numerical_implementation/pressure_decomposition/#","page":"Pressure decomposition","title":"Pressure decomposition","text":"such that the sum of the kinematic potential and buoyancy perturbation becomes","category":"page"},{"location":"numerical_implementation/pressure_decomposition/#","page":"Pressure decomposition","title":"Pressure decomposition","text":"    -bmnabla phi + b bmhat z = \n        - bmnabla phi_rmnon\n        - big ( underbracepartial_x bmhat x + partial_y bmhat y _equiv bmnabla_ h big ) phi_rmhyd  ","category":"page"},{"location":"numerical_implementation/pressure_decomposition/#","page":"Pressure decomposition","title":"Pressure decomposition","text":"The hydrostatic pressure anomaly is so named because the \"total\" hydrostatic pressure  contains additional components:","category":"page"},{"location":"numerical_implementation/pressure_decomposition/#","page":"Pressure decomposition","title":"Pressure decomposition","text":"beginaligned\npartial_z phi_texttotal hydrostatic = - g left ( 1 + tfracrho_*rho_0 + tfracrhorho_0 right )   \n                                           = partial_z phi_rmhyd - g left ( 1 + tfracrho_*rho_0 right )  \nendaligned","category":"page"},{"location":"numerical_implementation/pressure_decomposition/#","page":"Pressure decomposition","title":"Pressure decomposition","text":"Under this pressure decomposition the momentum equation becomes","category":"page"},{"location":"numerical_implementation/pressure_decomposition/#","page":"Pressure decomposition","title":"Pressure decomposition","text":"   partial_t bmu + left ( bmu bmcdot bmnabla right ) bmu + bmf times bmu = \n    - bmnabla phi_rmnon - bmnabla_h phi_rmhyd - bmnabla bmcdot bmtau + bmF_u  ","category":"page"},{"location":"numerical_implementation/pressure_decomposition/#","page":"Pressure decomposition","title":"Pressure decomposition","text":"Mathematically, the non-hydrostatic potential phi_rmnon enforces the incompressibility constraint.","category":"page"}]
}

var documenterSearchIndex = {"docs":
[{"location":"subject_index/#Index-1","page":"Index","title":"Index","text":"","category":"section"},{"location":"subject_index/#","page":"Index","title":"Index","text":"","category":"page"},{"location":"generated/two_dimensional_turbulence/#","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"EditURL = \"https://github.com/climate-machine/Oceananigans.jl/blob/master/examples/two_dimensional_turbulence.jl\"","category":"page"},{"location":"generated/two_dimensional_turbulence/#Two-dimensional-turbulence-example-1","page":"Two-dimensional turbulence","title":"Two dimensional turbulence example","text":"","category":"section"},{"location":"generated/two_dimensional_turbulence/#","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"In this example, we initialize a random velocity field and observe its viscous, turbulent decay in a two-dimensional domain. This example demonstrates:","category":"page"},{"location":"generated/two_dimensional_turbulence/#","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"How to run a model with no buoyancy equation or tracers;\nHow to create user-defined fields\nHow to use differentiation functions","category":"page"},{"location":"generated/two_dimensional_turbulence/#","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"For this example, we need PyPlot for plotting and Statistics for setting up a random initial condition with zero mean velocity.","category":"page"},{"location":"generated/two_dimensional_turbulence/#","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"using Oceananigans, PyPlot, Statistics","category":"page"},{"location":"generated/two_dimensional_turbulence/#","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"In addition to importing plotting and statistics packages, we import some types and functions from Oceananigans that will aid in the calculation and visualization of voriticty.","category":"page"},{"location":"generated/two_dimensional_turbulence/#","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"using Oceananigans: Face, Cell\nusing Oceananigans.TurbulenceClosures: ∂x_faa, ∂y_afa","category":"page"},{"location":"generated/two_dimensional_turbulence/#","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"We instantiate the model with a simple isotropic diffusivity","category":"page"},{"location":"generated/two_dimensional_turbulence/#","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"model = Model(\n        grid = RegularCartesianGrid(N=(128, 128, 1), L=(2π, 2π, 2π)),\n    buoyancy = nothing,\n     tracers = nothing,\n     closure = ConstantIsotropicDiffusivity(ν=1e-3, κ=1e-3)\n)","category":"page"},{"location":"generated/two_dimensional_turbulence/#","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Our initial condition randomizes u and v. We also ensure that both have zero mean for purely aesthetic reasons.","category":"page"},{"location":"generated/two_dimensional_turbulence/#","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"u₀ = rand(size(model.grid)...)\nu₀ .-= mean(u₀)\n\nset!(model, u=u₀, v=u₀)","category":"page"},{"location":"generated/two_dimensional_turbulence/#","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Next we define a function for calculating the vertical vorticity associated with the velocity fields u and v.","category":"page"},{"location":"generated/two_dimensional_turbulence/#","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"function vorticity!(ω, u, v)\n    for j = 1:u.grid.Ny, i = 1:u.grid.Nx\n        @inbounds ω.data[i, j, 1] = ∂x_faa(i, j, 1, u.grid, v.data) - ∂y_afa(i, j, 1, u.grid, u.data)\n    end\n    return nothing\nend","category":"page"},{"location":"generated/two_dimensional_turbulence/#","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Finally, we create the vorticity field for storing u and v, initialize a figure, and run the model forward","category":"page"},{"location":"generated/two_dimensional_turbulence/#","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"ω = Field(Face, Face, Cell, model.architecture, model.grid)\n\nclose(\"all\")\nfig, ax = subplots()\n\nfor i = 1:10\n    time_step!(model, Nt=100, Δt=1e-1)\n\n    vorticity!(ω, model.velocities.u, model.velocities.v)\n\n    cla()\n    imshow(data(ω)[:, :, 1])\n    ax.axis(\"off\")\n    pause(0.1)\nend","category":"page"},{"location":"generated/two_dimensional_turbulence/#","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"We can plot out the final vorticity field.","category":"page"},{"location":"generated/two_dimensional_turbulence/#","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"gcf()","category":"page"},{"location":"generated/two_dimensional_turbulence/#","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/equations/#Continuous-equations-1","page":"Continuous equations","title":"Continuous equations","text":"","category":"section"},{"location":"manual/equations/#","page":"Continuous equations","title":"Continuous equations","text":"The governing equations solved by \\texttt{Oceananigans.jl} are the rotating Navier-Stokes equations describing viscous fluid flow with the Boussinesq approximation.[1] The resulting mass conservation equation imposes that the fluid flow is incompressible.[2]","category":"page"},{"location":"manual/equations/#","page":"Continuous equations","title":"Continuous equations","text":"[1]: Named after \\citet{Boussinesq1903} although used earlier by \\citet{Oberbeck1879}, the Boussinesq approximation neglects density differences in the momentum equation except when associated with the gravitational term. It is an accurate approximation for many flows, and especially so for oceanic flows where density differences  are very small. See \\citet[\\S2.4]{Vallis17} for an oceanographic introduction to the Boussinesq equations and \\citet[\\S2.A]{Vallis17} for an asymptotic derivation. See \\citet[\\S4.9]{Kundu15} for an engineering introduction.}","category":"page"},{"location":"manual/equations/#","page":"Continuous equations","title":"Continuous equations","text":"[2]: Incompressibility rules out density and pressure waves like sound or shock waves.","category":"page"},{"location":"manual/equations/#Rotating-Boussinesq-equations-1","page":"Continuous equations","title":"Rotating Boussinesq equations","text":"","category":"section"},{"location":"manual/equations/#","page":"Continuous equations","title":"Continuous equations","text":"The rotating Boussinesq equations can be written as","category":"page"},{"location":"manual/equations/#","page":"Continuous equations","title":"Continuous equations","text":"  Dbmut + 2bmOmegatimesbmu + frac1rho_0 grad p - divnu grad bmu\n    + g fracrhoprimerho_0 hatbmk - bmF = 0 labeleqmomentum","category":"page"},{"location":"manual/equations/#","page":"Continuous equations","title":"Continuous equations","text":"along with the mass conservation equation","category":"page"},{"location":"manual/equations/#","page":"Continuous equations","title":"Continuous equations","text":"    grad cdot bmu = 0  labeleqcontinuity","category":"page"},{"location":"manual/equations/#","page":"Continuous equations","title":"Continuous equations","text":"where uveci uvecj uveck are the standard Cartesian basis vectors, bmu = (u v w) is the fluid flow velocity field, bmOmega is the rotation vector, p is the pressure, nu is the kinematic viscosity, g is the gravitational acceleration, rho_0 is a reference density describing the base state of the Boussinesq fluid whereas rhoprime = rho - rho_0 denotes density variations, and F = (F_u F_v F_w) includes forcing terms (or rather, the sources and sinks). Dbmqt = pbmqt + bmucdotgradbmq is the  material derivative and grad = (partial_x partial_y partial_z) is the del operator.","category":"page"},{"location":"manual/equations/#","page":"Continuous equations","title":"Continuous equations","text":"Tracer quantities c such as temperature and salinity satisfy an advection-diffusion equation","category":"page"},{"location":"manual/equations/#","page":"Continuous equations","title":"Continuous equations","text":"Dct - divkappa_c grad c + F_c = 0  labeleqtracer","category":"page"},{"location":"manual/equations/#","page":"Continuous equations","title":"Continuous equations","text":"where c is any tracer, kappa_c is the tracer diffusivity, and F_c is a forcing term.","category":"page"},{"location":"manual/equations/#","page":"Continuous equations","title":"Continuous equations","text":"Tracer quantities, for example temperature T and salinity S in oceanographic applications, are related to the density rho and pressure p by an appropriate equation of state","category":"page"},{"location":"manual/equations/#","page":"Continuous equations","title":"Continuous equations","text":"  rho = rho(T S p)","category":"page"},{"location":"manual/equations/#","page":"Continuous equations","title":"Continuous equations","text":"which may take multiple forms.","category":"page"},{"location":"manual/equations/#","page":"Continuous equations","title":"Continuous equations","text":"In order to discretize and discuss the equations, it will be helpful to expand out the material derivative and write out the individual components of the momentum equation \\eqref{eq:momentum} and tracer equation \\eqref{eq:tracer}.","category":"page"},{"location":"manual/equations/#","page":"Continuous equations","title":"Continuous equations","text":"We can write equations for the time derivatives[3] of u, v, w, and c","category":"page"},{"location":"manual/equations/#","page":"Continuous equations","title":"Continuous equations","text":"beginaligned\n  partial_t u = -bmucdotgrad u + fv - partial_x phi + divnu grad u      + F_u labeleqxMomentum \n  partial_t v = -bmucdotgrad v - fu - partial_y phi + divnu grad v      + F_v labeleqyMomentum \n  partial_t w = -bmucdotgrad w      - partial_z phi + divnu grad w + b  + F_w labeleqzMomentum \n  partial_t c = -bmucdotgrad c                        + divkappa_c grad c + F_c labeleqtracer2\nendaligned","category":"page"},{"location":"manual/equations/#","page":"Continuous equations","title":"Continuous equations","text":"where we have rewritten the pressure gradient term as the gradient of the kinematic pressure phi = prho_0 and b = -grhoprimerho_0 is the buoyancy. We have also rewritten 2bmOmegatimesbmu = -fv bmhati + fu bmhatj where f is the Coriolis parameter which on a rotating sphere can be expressed as f = 2 Omega sin varphi where Omega is the rotation rate of the sphere, and varphi is the latitude.[4]","category":"page"},{"location":"manual/equations/#","page":"Continuous equations","title":"Continuous equations","text":"[3]: In the geophysical sciences, the time derivatives are sometimes called the tendencies.","category":"page"},{"location":"manual/equations/#","page":"Continuous equations","title":"Continuous equations","text":"[4]: It is important to note here that the full expression for the Coriolis force is given by  $ 2\\bm{\\Omega}\\times\\bm{u} = (2\\Omega w \\cos\\varphi - 2\\Omega v \\sin \\varphi) \\hat{\\bm{i}}2\\Omega u \\sin\\varphi \\hat{\\bm{j}} - 2\\Omega u \\cos\\varphi \\hat{\\bm{k}} $however the Coriolis terms involving the vertical velocity and cosvarphi term are neglected due to their small contribution in geophysical fluid dynamics on Earth. This is termed the \\emph{traditional approximation} and must be taken with the \\emph{shallow-fluid approximation}, which assumes the depth of the fluid is much shallower than the radius of the sphere on which it evolves, otherwise conservation of energy and angular momentum is not guaranteed. See \\citet[\\S2.2.4]{Vallis17} for an introductory discussion of these approximations, and \\citet{Marshall97HY,White05} for a more detailed discussion.","category":"page"},{"location":"manual/equations/#Hydrostatic-and-non-hydrostatic-momentum-equations-1","page":"Continuous equations","title":"Hydrostatic and non-hydrostatic momentum equations","text":"","category":"section"},{"location":"manual/equations/#","page":"Continuous equations","title":"Continuous equations","text":"As a practical matter to allow the choice between evolving a hydrostatic and non-hydrostatic set of equations, we split the kinematic pressure term into hydrostatic and non-hydrostatic parts,","category":"page"},{"location":"manual/equations/#","page":"Continuous equations","title":"Continuous equations","text":"  phi(x y z) = phi_HY(x y z) + phi_NH(x y z)","category":"page"},{"location":"manual/equations/#","page":"Continuous equations","title":"Continuous equations","text":"We then note that in the hydrostatic approximation, the pressure and buoyancy terms in the vertical momentum equation are in balance ","category":"page"},{"location":"manual/equations/#","page":"Continuous equations","title":"Continuous equations","text":"  partial_z phi_HY = -b","category":"page"},{"location":"manual/equations/#","page":"Continuous equations","title":"Continuous equations","text":"and so the -gradphi + bhatbmk term in the momentum equation can be written as","category":"page"},{"location":"manual/equations/#","page":"Continuous equations","title":"Continuous equations","text":"    -gradphi + bhatbmk\n    = - gradphi_NH - gradphi_HY + b\n    = - gradphi_NH - partial_x phi_HY^prime hatbmi - partial_y phi_HY^prime hatbmj","category":"page"},{"location":"manual/equations/#","page":"Continuous equations","title":"Continuous equations","text":"where partial_x phi_HY = partial_x phi_HY^prime and partial_y phi_HY = partial_y phi_HY^prime as phi_HY^prime denotes the hydrostatic pressure anomaly, which is the component of the pressure  associated with buoyancy.","category":"page"},{"location":"manual/equations/#","page":"Continuous equations","title":"Continuous equations","text":"Thus the components of the momentum equation \\eqref{eq:xMomentum}–\\eqref{eq:zMomentum} can be written as","category":"page"},{"location":"manual/equations/#","page":"Continuous equations","title":"Continuous equations","text":"beginaligned\n  partial_t u = -bmucdotgrad u + fv - partial_x (phi_NH + phi_HY^prime) + divnu grad u + F_u \n  partial_t v = -bmucdotgrad v - fu - partial_y (phi_NH + phi_HY^prime) + divnu grad v + F_v \n  partial_t w = -bmucdotgrad w      - partial_z  phi_NH                  + divnu grad w + F_w \nendaligned","category":"page"},{"location":"manual/equations/#","page":"Continuous equations","title":"Continuous equations","text":"The non-hydrostatic pressure phi_NH is associated with small-scale motions that are not in hydrostatic balance and is numerically responsible for enforcing incompressibility, and thus mass conservation.","category":"page"},{"location":"manual/equations/#","page":"Continuous equations","title":"Continuous equations","text":"Note that we have not invoked the hydrostatic approximation. We are still dealing with a non-hydrostatic set of  equations. We just made use of the hydrostatic approximation to manipulate the equations such that if we want to  evolve a hydrostatic set of equations we can now just neglect the gradphi_NH terms (or multiply them by zero).  So it becomes simple to switch between hydrostatic and non-hydrostatic modes.","category":"page"},{"location":"verification/taylor_green_vortex/#Taylor-Green-vortex-1","page":"Taylor-Green vortex","title":"Taylor-Green vortex","text":"","category":"section"},{"location":"verification/taylor_green_vortex/#","page":"Taylor-Green vortex","title":"Taylor-Green vortex","text":"An exact solution to the two-dimensional incompressible Navier-Stokes equations is given by \\citet{Taylor37} describing the unsteady flow of a vortex decaying under viscous dissipation. The viscous terms balance the time derivatives while the nonlinear advection terms balance the pressure gradient term. We use the doubly-periodic solution described by \\citet[p. 310]{Hesthaven07}","category":"page"},{"location":"verification/taylor_green_vortex/#","page":"Taylor-Green vortex","title":"Taylor-Green vortex","text":"beginaligned\n  u(x y t) = -sin(2pi y) e^-4pi^2nu t \n  v(x y t) =  sin(2pi x) e^-4pi^2nu t \n  p(x y t) = -cos(2pi x) cos(2pi y) e^-8pi^2nu t\nendaligned","category":"page"},{"location":"benchmarks/#Performance-benchmarks-1","page":"Benchmarks","title":"Performance benchmarks","text":"","category":"section"},{"location":"benchmarks/#","page":"Benchmarks","title":"Benchmarks","text":"The benchmarks/benchmarks.jl script can be run to benchmark Oceananigans.jl on your machine. The script times how long a single time step takes on the CPU and GPU using Float32 and Float64 for various model resolutions. It uses TimerOutputs.jl to nicely format the benchmarks. It also prints out CPU->GPU speedups and Float64->Float32 \"speedups\".","category":"page"},{"location":"benchmarks/#","page":"Benchmarks","title":"Benchmarks","text":"Right now it only benchmarks a simple \"static ocean\" configuration. The time stepping and Poisson solver still takes the same amount of time whether the ocean is static or active, so it should be indicative of actual performance.","category":"page"},{"location":"benchmarks/#","page":"Benchmarks","title":"Benchmarks","text":"Here is the script's output when run on a single-core of a Intel Xeon E5-2680 v4 @ 2.40 GHz CPU and on an Nvidia Tesla V100 GPU.","category":"page"},{"location":"benchmarks/#","page":"Benchmarks","title":"Benchmarks","text":"──────────────────────────────────────────────────────────────────────────────────────────────────\r\n            Oceananigans.jl benchmarks                    Time                   Allocations      \r\n                                                  ──────────────────────   ───────────────────────\r\n                Tot / % measured:                       227s / 45.6%           18.7GiB / 0.06%    \r\n\r\nSection                                   ncalls     time   %tot     avg     alloc   %tot      avg\r\n──────────────────────────────────────────────────────────────────────────────────────────────────\r\n256x256x256 static ocean (CPU, Float32)       10    54.4s  52.5%   5.44s   60.0KiB  0.48%  6.00KiB\r\n256x256x256 static ocean (CPU, Float64)       10    36.9s  35.6%   3.69s   77.8KiB  0.62%  7.78KiB\r\n128x128x128 static ocean (CPU, Float32)       10    6.38s  6.16%   638ms   60.0KiB  0.48%  6.00KiB\r\n128x128x128 static ocean (CPU, Float64)       10    4.04s  3.90%   404ms   77.8KiB  0.62%  7.78KiB\r\n 64x 64x 64 static ocean (CPU, Float32)       10    748ms  0.72%  74.8ms   60.0KiB  0.48%  6.00KiB\r\n 64x 64x 64 static ocean (CPU, Float64)       10    412ms  0.40%  41.2ms   77.8KiB  0.62%  7.78KiB\r\n256x256x256 static ocean (GPU, Float64)       10    284ms  0.27%  28.4ms   1.59MiB  12.9%   163KiB\r\n256x256x256 static ocean (GPU, Float32)       10    243ms  0.23%  24.3ms   1.35MiB  11.0%   139KiB\r\n 32x 32x 32 static ocean (CPU, Float32)       10   80.3ms  0.08%  8.03ms   60.0KiB  0.48%  6.00KiB\r\n 32x 32x 32 static ocean (CPU, Float64)       10   45.2ms  0.04%  4.52ms   77.8KiB  0.62%  7.78KiB\r\n128x128x128 static ocean (GPU, Float64)       10   35.9ms  0.03%  3.59ms   1.59MiB  12.9%   163KiB\r\n128x128x128 static ocean (GPU, Float32)       10   32.3ms  0.03%  3.23ms   1.35MiB  11.0%   139KiB\r\n 64x 64x 64 static ocean (GPU, Float64)       10   6.54ms  0.01%   654μs   1.59MiB  12.9%   163KiB\r\n 64x 64x 64 static ocean (GPU, Float32)       10   6.14ms  0.01%   614μs   1.35MiB  11.0%   139KiB\r\n 32x 32x 32 static ocean (GPU, Float64)       10   5.77ms  0.01%   577μs   1.59MiB  12.9%   163KiB\r\n 32x 32x 32 static ocean (GPU, Float32)       10   5.68ms  0.01%   568μs   1.35MiB  11.0%   139KiB\r\n──────────────────────────────────────────────────────────────────────────────────────────────────\r\n\r\nCPU Float64 -> Float32 speedup:\r\n32x 32x 32 static ocean: 0.562\r\n64x 64x 64 static ocean: 0.551\r\n128x128x128 static ocean: 0.633\r\n256x256x256 static ocean: 0.677\r\n\r\nGPU Float64 -> Float32 speedup:\r\n32x 32x 32 static ocean: 1.015\r\n64x 64x 64 static ocean: 1.066\r\n128x128x128 static ocean: 1.114\r\n256x256x256 static ocean: 1.167\r\n\r\nCPU -> GPU speedup:\r\n32x 32x 32 static ocean (Float32): 14.138\r\n32x 32x 32 static ocean (Float64): 7.829\r\n64x 64x 64 static ocean (Float32): 121.806\r\n64x 64x 64 static ocean (Float64): 62.924\r\n128x128x128 static ocean (Float32): 197.906\r\n128x128x128 static ocean (Float64): 112.417\r\n256x256x256 static ocean (Float32): 223.748\r\n256x256x256 static ocean (Float64): 129.923","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"EditURL = \"https://github.com/climate-machine/Oceananigans.jl/blob/master/examples/internal_wave.jl\"","category":"page"},{"location":"generated/internal_wave/#Internal-wave-example-1","page":"Internal wave","title":"Internal wave example","text":"","category":"section"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"In this example, we initialize an internal wave packet in two-dimensions and watch is propagate.","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"using Oceananigans, PyPlot, Printf","category":"page"},{"location":"generated/internal_wave/#Numerical,-domain,-and-internal-wave-parameters-1","page":"Internal wave","title":"Numerical, domain, and internal wave parameters","text":"","category":"section"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"First, we pick some numerical and physical parameters for our model and its rotation rate.","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"Nx = 128 # resolution\nLx = 2π  # domain extent","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"We set up an internal wave with the pressure field","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"$","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"p(x, y, z, t) = a(x, z) cos(kx + mz - \\omega t) $ .","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"where m is the vertical wavenumber, k is the horizontal wavenumber, ω is the wave frequncy, and a(x, z) is a Gaussian envelope.","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"# Non-dimensional internal wave parameters\nm = 16      # vertical wavenumber\nk = 1       # horizontal wavenumber\nN = 1       # buoyancy frequency\nf = 0.2     # inertial frequency","category":"page"},{"location":"generated/internal_wave/#A-Gaussian-wavepacket-1","page":"Internal wave","title":"A Gaussian wavepacket","text":"","category":"section"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"Next, we set up an initial condition corresponding to a propagating wave packet with a Gaussian envelope. The internal wave dispersion relation yields","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"ω² = (N^2 * k^2 + f^2 * m^2) / (k^2 + m^2)\n\n# and thus\nω = sqrt(ω²)","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"The internal wave polarization relations follow from the linearized Boussinesq equations,","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"U = k * ω   / (ω^2 - f^2)\nV = k * f   / (ω^2 - f^2)\nW = m * ω   / (ω^2 - N^2)\nB = m * N^2 / (ω^2 - N^2)","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"Finally, we set-up a small-amplitude, Gaussian envelope for the wave packet","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"# Some Gaussian parameters\nA, x₀, z₀, δ = 1e-9, Lx/2, -Lx/2, Lx/15\n\n# A Gaussian envelope\na(x, z) = A * exp( -( (x - x₀)^2 + (z - z₀)^2 ) / 2δ^2 )","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"Create initial condition functions","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"u₀(x, y, z) = a(x, z) * U * cos(k*x + m*z)\nv₀(x, y, z) = a(x, z) * V * sin(k*x + m*z)\nw₀(x, y, z) = a(x, z) * W * cos(k*x + m*z)\nb₀(x, y, z) = a(x, z) * B * sin(k*x + m*z) + N^2 * z","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"We are now ready to instantiate our model on a uniform grid. We give the model a constant rotation rate with background vorticity f, use temperature as a buoyancy tracer, and use a small constant viscosity and diffusivity to stabilize the model.","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"model = Model(\n        grid = RegularCartesianGrid(N=(Nx, 1, Nx), L=(Lx, Lx, Lx)),\n     closure = ConstantIsotropicDiffusivity(ν=1e-6, κ=1e-6),\n    coriolis = FPlane(f=f),\n     tracers = :b,\n    buoyancy = BuoyancyTracer()\n)","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"We initialize the velocity and buoyancy fields with our internal wave initial condition.","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"set!(model, u=u₀, v=v₀, w=w₀, b=b₀)","category":"page"},{"location":"generated/internal_wave/#Some-plotting-utilities-1","page":"Internal wave","title":"Some plotting utilities","text":"","category":"section"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"To watch the wave packet propagate interactively as the model runs, we build some plotting utilities.","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"xplot(u) = repeat(dropdims(xnodes(u), dims=2), 1, u.grid.Nz)\nzplot(u) = repeat(dropdims(znodes(u), dims=2), u.grid.Nx, 1)\n\nfunction plot_field!(ax, w, t)\n    pcolormesh(xplot(w), zplot(w), data(model.velocities.w)[:, 1, :])\n    xlabel(L\"x\")\n    ylabel(L\"z\")\n    title(@sprintf(\"\\$ \\\\omega t / 2 \\\\pi = %.2f\\$\", t*ω/2π))\n    ax.set_aspect(1)\n    pause(0.1)\n    return nothing\nend\n\nclose(\"all\")\nfig, ax = subplots()","category":"page"},{"location":"generated/internal_wave/#A-wave-packet-on-the-loose-1","page":"Internal wave","title":"A wave packet on the loose","text":"","category":"section"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"Finally, we release the packet:","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"for i = 1:10\n    time_step!(model, Nt = 200, Δt = 0.001 * 2π/ω)\n    plot_field!(ax, model.velocities.w, model.clock.time)\nend","category":"page"},{"location":"generated/internal_wave/#","page":"Internal wave","title":"Internal wave","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/spatial_operators/#Spatial-operators-1","page":"Spatial operators","title":"Spatial operators","text":"","category":"section"},{"location":"manual/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"To calculate the various terms and perform the time-stepping, discrete difference and interpolation operators must be designed from which all the terms, such as momentum advection and Laplacian diffusion, may be constructed. Much of the material in this section is derived from \\citet{Marshall97FV}.","category":"page"},{"location":"manual/spatial_operators/#Differences-1","page":"Spatial operators","title":"Differences","text":"","category":"section"},{"location":"manual/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"Difference operators act as the discrete form of the derivative operator. Care must be taken when calculating differences on a staggered grid. For example, the the difference of a cell-centered variable such as temperature T lies on the faces  in the direction of the difference, and vice versa. In principle, there are three difference operators, one for each  direction","category":"page"},{"location":"manual/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"  delta_x f = f_E - f_W quad\n  delta_y f = f_N - f_S  quad\n  delta_z f = f_T - f_B ","category":"page"},{"location":"manual/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"where the E and W subscripts indicate that the value is evaluated the eastern or western wall of the cell, N and S indicate the northern and southern walls, and T and B indicate the top and bottom walls.","category":"page"},{"location":"manual/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"Additionally, two delta operators must be defined for each direction to account for the staggered nature of the grid. One for taking the difference of a cell-centered variable and projecting it onto the cell faces","category":"page"},{"location":"manual/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"beginaligned\n    delta_x^faa f_ijk = f_ijk - f_i-1jk \n    delta_y^afa f_ijk = f_ijk - f_ij-1k \n    delta_z^aaf f_ijk = f_ijk - f_ijk-1\nendaligned","category":"page"},{"location":"manual/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"and another for taking the difference of a face-centered variable and projecting it onto the cell centers","category":"page"},{"location":"manual/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"beginaligned\n    delta_x^caa f_ijk = f_i+1jk - f_ijk \n    delta_y^aca f_ijk = f_ij+1k - f_ijk \n    delta_z^aac f_ijk = f_ijk+1 - f_ijk\nendaligned","category":"page"},{"location":"manual/spatial_operators/#Interpolation-1","page":"Spatial operators","title":"Interpolation","text":"","category":"section"},{"location":"manual/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"In order to add or multiply variables that are defined at different points they are interpolated. In our case, linear interpolation or averaging is employed. Once again, there are two averaging operators, one for each direction, \\begin{equation}   \\overline{f}^x = \\frac{fE + fW}{2} , \\quad   \\overline{f}^y = \\frac{fN + fS}{2} , \\quad   \\overline{f}^z = \\frac{fT + fB}{2} \\end{equation}","category":"page"},{"location":"manual/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"Additionally, three averaging operators must be defined for each direction. One for taking the average of a cell-centered  variable and projecting it onto the cell faces","category":"page"},{"location":"manual/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"beginaligned\n    overlinef_ijk^faa = fracf_ijk + f_i-1jk2 \n    overlinef_ijk^afa = fracf_ijk + f_ij-1k2 \n    overlinef_ijk^aaf = fracf_ijk + f_ijk-12\nendaligned","category":"page"},{"location":"manual/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"and another for taking the average of a face-centered variable and projecting it onto the cell centers","category":"page"},{"location":"manual/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"beginaligned\n    overlinef_ijk^caa = fracf_i+1jk + f_ijk2 \n    overlinef_ijk^aca = fracf_ij+1k + f_ijk2 \n    overlinef_ijk^aac = fracf_ijk+1 + f_ijk2\nendaligned","category":"page"},{"location":"manual/spatial_operators/#Divergence-and-flux-divergence-1","page":"Spatial operators","title":"Divergence and flux divergence","text":"","category":"section"},{"location":"manual/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"The divergence of the flux of a cell-centered quantity over the cell can be calculated as","category":"page"},{"location":"manual/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"nabla cdot bmf\n= frac1V left delta_x^faa (A_x f_x)\n                   + delta_y^afa (A_y f_y)\n                   + delta_z^aaf (A_z f_z) right","category":"page"},{"location":"manual/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"where bmf = (f_x f_y f_z) is the flux with components defined normal to the faces, and V is the volume of the cell. The presence of a solid boundary is indicated by setting the appropriate flux normal to the boundary to zero.","category":"page"},{"location":"manual/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"A similar divergence operator can be defined for a face-centered quantity. The divergence of the flux of T over a cell,  nabla cdot (bmu T), required in the evaluation of G_T, for example, is then","category":"page"},{"location":"manual/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"renewcommanddiv1 nabla cdot left ( 1 right )\ndivbmu T\n= frac1V left delta_x^caa (A_x u overlineT^faa)\n                   + delta_y^aca (A_y v overlineT^afa)\n                   + delta_z^aac (A_z w overlineT^aaf) right","category":"page"},{"location":"manual/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"where T is interpolated onto the cell faces where it can be multiplied by the velocities, which are then differenced and  projected onto the cell centers where they added together and then added to G_T which also lives at the cell centers.","category":"page"},{"location":"manual/spatial_operators/#Momentum-advection-1","page":"Spatial operators","title":"Momentum advection","text":"","category":"section"},{"location":"manual/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"The advection terms that make up the mathbfG terms in equations \\eqref{eq:horizontalMomentum} and \\eqref{eq:verticalMomentum} can be mathematically written as, e.g,","category":"page"},{"location":"manual/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"renewcommanddiv1 nabla cdot left ( 1 right )\nbmu cdot nabla u\n    = divubmu - u(underbracenablacdotbmu_=0)\n    = divubmu","category":"page"},{"location":"manual/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"which can then be discretized similarly to the flux divergence operator, however, they must be discretized differently for each direction.","category":"page"},{"location":"manual/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"For example, the x-momentum advection operator is discretized as","category":"page"},{"location":"manual/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"bmu cdot nabla u\n= frac1overlineV^x left\n    delta_x^faa left( overlineA_x u^caa overlineu^caa right)\n  + delta_y^afa left( overlineA_y v^aca overlineu^aca right)\n  + delta_z^aaf left( overlineA_z w^aac overlineu^aac right)\nright","category":"page"},{"location":"manual/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"where overlineV^x is the average of the volumes of the cells on either side of the face in question. Calculating partial(uu)partial x can be performed by interpolating A_x u and u onto the cell centers then multiplying them and differencing them back onto the faces. However, in the case of the the two other terms, partial(vu)partial y and partial(wu)partial z, the two variables must be interpolated onto the cell edges to be multiplied then differenced back onto the cell faces.","category":"page"},{"location":"manual/spatial_operators/#Viscous-dissipation-1","page":"Spatial operators","title":"Viscous dissipation","text":"","category":"section"},{"location":"manual/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"Viscous dissipation operators are discretized similarly to the momentum advection operators and so there is a different one for each direction. For example, the vertical diffusion operator is discretized as","category":"page"},{"location":"manual/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"renewcommanddiv1 nabla cdot left ( 1 right )\ndivnu nabla w\n= frac1V left\n      delta_x^faa left( nu_h overlineA_x^caa delta_x^caa w right)\n    + delta_y^afa left( nu_h overlineA_y^aca delta_y^aca w right)\n    + delta_z^aaf left( nu_v overlineA_z^aac delta_z^aac w right)\nright","category":"page"},{"location":"manual/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"where nu is the kinematic viscosity.","category":"page"},{"location":"manual/spatial_operators/#Laplacian-diffusion-1","page":"Spatial operators","title":"Laplacian diffusion","text":"","category":"section"},{"location":"manual/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"Laplacian diffusion is discretized for tracer quantities as","category":"page"},{"location":"manual/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"renewcommanddiv1 nabla cdot left ( 1 right )\ndivkappa nabla T\n= frac1V left\n    delta_x^caa left( kappa_h A_x delta_x^faa T right)\n  + delta_y^aca left( kappa_h A_y delta_y^afa T right)\n  + delta_z^aac left( kappa_v A_z delta_z^aaf T right)\nright","category":"page"},{"location":"manual/spatial_operators/#","page":"Spatial operators","title":"Spatial operators","text":"where kappa is the diffusivity, usually taken to be the eddy diffusivity, and different diffusivities may be taken for the horizontal and vertical directions to account for the differences between horizontal and vertical turbulence.","category":"page"},{"location":"library/#Library-1","page":"Library","title":"Library","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"Documenting the public user interface.","category":"page"},{"location":"library/#Boundary-conditions-1","page":"Library","title":"Boundary conditions","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"Modules = [Oceananigans]\nPrivate = false\nPages   = [\"boundary_conditions.jl\"]","category":"page"},{"location":"library/#Oceananigans.BoundaryCondition","page":"Library","title":"Oceananigans.BoundaryCondition","text":"BoundaryCondition{C<:BCType}(condition)\n\nConstruct a boundary condition of type C with a condition that may be given by a number, an array, or a function with signature:\n\ncondition(i, j, grid, time, iteration, U, Φ, parameters) = # function definition\n\nthat returns a number and where i and j are indices along the boundary.\n\nBoundary condition types include Periodic, Flux, Value, Gradient, and NoPenetration.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.CoordinateBoundaryConditions","page":"Library","title":"Oceananigans.CoordinateBoundaryConditions","text":"CoordinateBoundaryConditions(left, right)\n\nA set of two BoundaryConditions to be applied along a coordinate x, y, or z.\n\nThe left boundary condition is applied on the negative or lower side of the coordinate while the right boundary condition is applied on the positive or higher side.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Dirchlet","page":"Library","title":"Oceananigans.Dirchlet","text":"Dirchlet\n\nAn alias for the Value boundary condition type.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.FieldBoundaryConditions","page":"Library","title":"Oceananigans.FieldBoundaryConditions","text":"FieldBoundaryConditions\n\nAn alias for NamedTuple{(:x, :y, :z)} that represents a set of three CoordinateBoundaryConditions applied to a field along x, y, and z.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.FieldBoundaryConditions-Tuple{Any,Any,Any}","page":"Library","title":"Oceananigans.FieldBoundaryConditions","text":"FieldBoundaryConditions(x, y, z)\n\nConstruct a FieldBoundaryConditions using a CoordinateBoundaryCondition for each of the x, y, and z coordinates.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Flux","page":"Library","title":"Oceananigans.Flux","text":"Flux\n\nA type specifying a boundary condition on the flux of a field.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Gradient","page":"Library","title":"Oceananigans.Gradient","text":"Gradient\n\nA type specifying a boundary condition on the derivative or gradient of a field. Also called a Neumann boundary condition.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Neumann","page":"Library","title":"Oceananigans.Neumann","text":"Neumann\n\nAn alias for the Gradient boundary condition type.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Periodic","page":"Library","title":"Oceananigans.Periodic","text":"Periodic\n\nA type specifying a periodic boundary condition.\n\nA condition may not be specified with a Periodic boundary condition.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Value","page":"Library","title":"Oceananigans.Value","text":"Value\n\nA type specifying a boundary condition on the value of a field. Also called a Dirchlet boundary condition.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.ChannelBCs-Tuple{}","page":"Library","title":"Oceananigans.ChannelBCs","text":"ChannelBCs(; north = BoundaryCondition(Flux, nothing),\n             south = BoundaryCondition(Flux, nothing),\n               top = BoundaryCondition(Flux, nothing),\n            bottom = BoundaryCondition(Flux, nothing))\n\nConstruct FieldBoundaryConditions with Periodic boundary conditions in the x direction and specified north (+y), south (-y), top (+z) and bottom (-z) boundary conditions for u, v, and tracer fields.\n\nChannelBCs cannot be applied to the the vertical velocity w.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.ChannelSolutionBCs-Tuple{}","page":"Library","title":"Oceananigans.ChannelSolutionBCs","text":"ChannelSolutionBCs(u=ChannelBCs(), ...)\n\nConstruct SolutionBoundaryConditions for a reentrant channel model configuration with solution fields u, v, w, T, and S specified by keyword arguments.\n\nBy default ChannelBCs are applied to u, v, T, and S and ChannelBCs(top=NoPenetrationBC(), bottom=NoPenetrationBC()) is applied to w.\n\nUse ChannelBCs when constructing non-default boundary conditions for u, v, w, T, S.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.HorizontallyPeriodicBCs-Tuple{}","page":"Library","title":"Oceananigans.HorizontallyPeriodicBCs","text":"HorizontallyPeriodicBCs(;   top = BoundaryCondition(Flux, nothing),\n                         bottom = BoundaryCondition(Flux, nothing))\n\nConstruct FieldBoundaryConditions with Periodic boundary conditions in the x and y directions and specified top (+z) and bottom (-z) boundary conditions for u, v, and tracer fields.\n\nHorizontallyPeriodicBCs cannot be applied to the the vertical velocity w.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.HorizontallyPeriodicSolutionBCs-Tuple{}","page":"Library","title":"Oceananigans.HorizontallyPeriodicSolutionBCs","text":"HorizontallyPeriodicSolutionBCs(u=HorizontallyPeriodicBCs(), ...)\n\nConstruct SolutionBoundaryConditions for a horizontally-periodic model configuration with solution fields u, v, w, T, and S specified by keyword arguments.\n\nBy default HorizontallyPeriodicBCs are applied to u, v, T, and S and HorizontallyPeriodicBCs(top=NoPenetrationBC(), bottom=NoPenetrationBC()) is applied to w.\n\nUse HorizontallyPeriodicBCs when constructing non-default boundary conditions for u, v, w, T, S.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.SolutionBoundaryConditions-Tuple{Any,Any}","page":"Library","title":"Oceananigans.SolutionBoundaryConditions","text":"SolutionBoundaryConditions(tracers, proposal_bcs)\n\nConstruct a NamedTuple of FieldBoundaryConditions for a model with  fields u, v, w, and tracers from the proposal boundary conditions  proposal_bcs, which must contain the boundary conditions on u, v, and w  and may contain some or all of the boundary conditions on tracers.\n\n\n\n\n\n","category":"method"},{"location":"library/#Buoyancy-1","page":"Library","title":"Buoyancy","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"Modules = [Oceananigans]\nPrivate = false\nPages   = [\"buoyancy.jl\"]","category":"page"},{"location":"library/#Oceananigans.BuoyancyTracer","page":"Library","title":"Oceananigans.BuoyancyTracer","text":"BuoyancyTracer <: AbstractBuoyancy{Nothing}\n\nType indicating that the tracer b represents buoyancy.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.LinearEquationOfState","page":"Library","title":"Oceananigans.LinearEquationOfState","text":"LinearEquationOfState{FT} <: AbstractEquationOfState\n\nLinear equation of state for seawater.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.LinearEquationOfState","page":"Library","title":"Oceananigans.LinearEquationOfState","text":"LinearEquationOfState([FT=Float64;] α=1.67e-4, β=7.80e-4)\n\nReturns parameters for a linear equation of state for seawater with thermal expansion coefficient α [K⁻¹] and haline contraction coefficient β [ppt⁻¹]. The buoyancy perturbation associated with a linear equation of state is\n\n    b = g (αT - βS)\n\nDefault constants are taken from Table 1.2 (page 33) of Vallis, \"Atmospheric and Oceanic Fluid Dynamics: Fundamentals and Large-Scale Circulation\" (2ed, 2017).\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.SeawaterBuoyancy","page":"Library","title":"Oceananigans.SeawaterBuoyancy","text":"SeawaterBuoyancy{G, EOS} <: AbstractBuoyancy{EOS}\n\nBuoyancy model for temperature- and salt-stratified seawater.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.SeawaterBuoyancy","page":"Library","title":"Oceananigans.SeawaterBuoyancy","text":"SeawaterBuoyancy([FT=Float64;] gravitational_acceleration = g_Earth,\n                              equation_of_state = LinearEquationOfState(FT))\n\nReturns parameters for a temperature- and salt-stratified seawater buoyancy model with a gravitational_acceleration constant (typically called 'g'), and an equation_of_state that related temperature and salinity (or conservative temperature and absolute salinity) to density anomalies and buoyancy.\n\n\n\n\n\n","category":"type"},{"location":"library/#Clock-1","page":"Library","title":"Clock","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"Modules = [Oceananigans]\nPrivate = false\nPages   = [\"clock.jl\"]","category":"page"},{"location":"library/#Oceananigans.Clock","page":"Library","title":"Oceananigans.Clock","text":"Clock{T<:Number}\n\nClock{T}(time, iteration)\n\nKeeps track of the current time and iteration number.\n\n\n\n\n\n","category":"type"},{"location":"library/#Coriolis-1","page":"Library","title":"Coriolis","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"Modules = [Oceananigans]\nPrivate = false\nPages   = [\"coriolis.jl\"]","category":"page"},{"location":"library/#Oceananigans.FPlane","page":"Library","title":"Oceananigans.FPlane","text":"FPlane{T} <: AbstractRotation\n\nA parameter object for constant rotation around a vertical axis.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.FPlane","page":"Library","title":"Oceananigans.FPlane","text":"FPlane([T=Float64;] f)\n\nReturns a parameter object for constant rotation at the angular frequency 2f, and therefore with background vorticity f, around a vertical axis.\n\nAlso called FPlane, after the \"f-plane\" approximation for the local effect of  Earth's rotation in a planar coordinate system tangent to the Earth's surface.\n\n\n\n\n\n","category":"type"},{"location":"library/#Diagnostics-1","page":"Library","title":"Diagnostics","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"Modules = [Oceananigans]\nPrivate = false\nPages   = [\"diagnostics.jl\"]","category":"page"},{"location":"library/#Oceananigans.CFL","page":"Library","title":"Oceananigans.CFL","text":"CFL{D, S}\n\nAn object for computing the Courant-Freidrichs-Lewy (CFL) number.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.CFL-Tuple{Any}","page":"Library","title":"Oceananigans.CFL","text":"CFL(Δt [, timescale=Oceananigans.cell_advection_timescale])\n\nReturns an object for computing the Courant-Freidrichs-Lewy (CFL) number associated with time step or TimeStepWizard Δt and timescale.\n\nSee also AdvectiveCFL and DiffusiveCFL\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.FieldMaximum","page":"Library","title":"Oceananigans.FieldMaximum","text":"FieldMaximum(mapping, field)\n\nAn object for calculating the maximum of a mapping function applied element-wise to field.\n\nExamples\n\njulia> model = BasicModel(N=(16, 16, 16), L=(1, 1, 1));\n\njulia> max_abs_u = FieldMaximum(abs, model.velocities.u);\n\njulia> max_w² = FieldMaximum(x->x^2, model.velocities.w);\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.HorizontalAverage","page":"Library","title":"Oceananigans.HorizontalAverage","text":"HorizontalAverage{F, R, P, I, Ω} <: AbstractDiagnostic\n\nA diagnostic for computing horizontal average of a field or the product of multiple fields.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.HorizontalAverage-Tuple{Any,Any}","page":"Library","title":"Oceananigans.HorizontalAverage","text":"HorizontalAverage(model, fields; frequency=nothing, interval=nothing, return_type=Array)\n\nConstruct a HorizontalAverage diagnostic for model.\n\nAfter the horizontal average is computed it will be stored in the profile property.\n\nThe HorizontalAverage can be used as a callable object that computes and returns the horizontal average.\n\nIf a single field is passed to fields the the horizontal average of that single field will be computed. If multiple fields are passed to fields, then the horizontal average of their product will be computed.\n\nA frequency or interval (or both) can be passed to indicate how often to run this diagnostic if it is part of model.diagnostics. frequency is a number of iterations while interval is a time interval in units of model.clock.time.\n\nA return_type can be used to specify the type returned when the HorizontalAverage is used as a callable object. The default return_type=Array is useful when running a GPU model and you want to save the output to disk by passing it to an output writer.\n\nWarning\n\nRight now taking products of multiple fields does not take into account their locations on the staggered grid and no attempt is made to interpolate all the different fields onto a common location before calculating the product.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.NaNChecker","page":"Library","title":"Oceananigans.NaNChecker","text":"NaNChecker{F} <: AbstractDiagnostic\n\nA diagnostic that checks for NaN values and aborts the simulation if any are found.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.NaNChecker-Tuple{Any}","page":"Library","title":"Oceananigans.NaNChecker","text":"NaNChecker(model; frequency, fields)\n\nConstruct a NaNChecker for model. fields should be a Dict{Symbol,Field}. A frequency should be passed to indicate how often to check for NaNs (in number of iterations).\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Timeseries","page":"Library","title":"Oceananigans.Timeseries","text":"Timeseries{D, Ω, I, T, TT} <: AbstractDiagnostic\n\nA diagnostic for collecting and storing timeseries.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Timeseries-Tuple{Any,Any}","page":"Library","title":"Oceananigans.Timeseries","text":"Timeseries(diagnostic, model; frequency=nothing, interval=nothing)\n\nA Timeseries Diagnostic that records a time series of diagnostic(model).\n\nExample\n\njulia> model = BasicModel(N=(16, 16, 16), L=(1, 1, 1));\n\njulia> max_u = Timeseries(FieldMaximum(abs, model.velocities.u), model; frequency=1)\n\njulia> model.diagnostics[:max_u] = max_u; data(model.velocities.u) .= π; time_step!(model, Nt=3, Δt=1e-16)\n\njulia> max_u.data\n3-element Array{Float64,1}:\n 3.141592653589793\n 3.1415926025389127\n 3.1415925323439517\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Timeseries-Tuple{NamedTuple,Any}","page":"Library","title":"Oceananigans.Timeseries","text":"Timeseries(diagnostics::NamedTuple, model; frequency=nothing, interval=nothing)\n\nA Timeseries Diagnostic that records a NamedTuple of time series of diag(model) for each diag in diagnostics.\n\nExample\n\njulia> model = BasicModel(N=(16, 16, 16), L=(1, 1, 1)); Δt = 1.0;\n\njulia> cfl = Timeseries((adv=AdvectiveCFL(Δt), diff=DiffusiveCFL(Δt)), model; frequency=1);\n\njulia> model.diagnostics[:cfl] = cfl; time_step!(model, Nt=3, Δt=Δt)\n\njulia> cfl.data\n(adv = [0.0, 0.0, 0.0, 0.0], diff = [0.0002688, 0.0002688, 0.0002688, 0.0002688])\n\njulia> cfl.adv\n4-element Array{Float64,1}:\n 0.0\n 0.0\n 0.0\n 0.0\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.AdvectiveCFL-Tuple{Any}","page":"Library","title":"Oceananigans.AdvectiveCFL","text":"AdvectiveCFL(Δt)\n\nReturns an object for computing the Courant-Freidrichs-Lewy (CFL) number associated with time step or TimeStepWizard Δt and the time scale for advection across a cell.\n\nExample\n\njulia> model = BasicModel(N=(16, 16, 16), L=(8, 8, 8));\n\njulia> cfl = AdvectiveCFL(1.0);\n\njulia> data(model.velocities.u) .= π;\n\njulia> cfl(model)\n6.283185307179586\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.DiffusiveCFL-Tuple{Any}","page":"Library","title":"Oceananigans.DiffusiveCFL","text":"DiffusiveCFL(Δt)\n\nReturns an object for computing the Courant-Freidrichs-Lewy (CFL) number associated with time step or TimeStepWizard Δt and the time scale for diffusion across a cell associated with model.closure.\n\nExample\n\njulia> model = BasicModel(N=(16, 16, 16), L=(1, 1, 1));\n\njulia> cfl = DiffusiveCFL(0.1);\n\njulia> cfl(model)\n2.688e-5\n\n\n\n\n\n","category":"method"},{"location":"library/#Fields-1","page":"Library","title":"Fields","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"Modules = [Oceananigans]\nPrivate = false\nPages   = [\"fields.jl\"]","category":"page"},{"location":"library/#Oceananigans.CellField","page":"Library","title":"Oceananigans.CellField","text":"CellField\n\nA field defined at the cell centers. Used for pressure and tracers.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.CellField-Tuple{Any,Any,Any}","page":"Library","title":"Oceananigans.CellField","text":"CellField([T=eltype(grid)], arch, grid)\n\nReturn a CellField on architecture arch and grid.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.FaceFieldX","page":"Library","title":"Oceananigans.FaceFieldX","text":"FaceFieldX\n\nA field defined at the faces along the x-direction. Used for horizontal velocity u.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.FaceFieldX-Tuple{Any,Any,Any}","page":"Library","title":"Oceananigans.FaceFieldX","text":"FaceFieldX([T=eltype(grid)], arch, grid)\n\nReturn a FaceFieldX on architecture arch and grid.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.FaceFieldY","page":"Library","title":"Oceananigans.FaceFieldY","text":"FaceFieldY\n\nA field defined at the faces along the y-direction. Used for horizontal velocity v.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.FaceFieldY-Tuple{Any,Any,Any}","page":"Library","title":"Oceananigans.FaceFieldY","text":"FaceFieldY([T=eltype(grid)], arch, grid)\n\nReturn a FaceFieldY on architecture arch and grid.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.FaceFieldZ","page":"Library","title":"Oceananigans.FaceFieldZ","text":"FaceFieldY\n\nA field defined at the faces along the z-direction. Used for vertical velocity w.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.FaceFieldZ-Tuple{Any,Any,Any}","page":"Library","title":"Oceananigans.FaceFieldZ","text":"FaceFieldZ([T=eltype(grid)], arch, grid)\n\nReturn a FaceFieldZ on architecture arch and grid.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Field","page":"Library","title":"Oceananigans.Field","text":"Field{LX, LY, LZ, A, G} <: AbstractField{A, G}\n\nA field defined at the location (LX, LY, LZ) which can be either Cell or Face.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Field-NTuple{5,Any}","page":"Library","title":"Oceananigans.Field","text":"Field(Lx, Ly, Lz, data, grid)\n\nConstruct a Field on grid using the array data with location defined by Lx, Ly, and Lz which are Cell or Face.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Field-Tuple{Tuple,AbstractArray,Any}","page":"Library","title":"Oceananigans.Field","text":"Field(L::Tuple, data::AbstractArray, grid)\n\nConstruct a Field on grid using the array data with location defined by the tuple L of length 3 whose elements are Cell or Face.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.Field-Tuple{Tuple,Oceananigans.AbstractArchitecture,Any}","page":"Library","title":"Oceananigans.Field","text":"Field(L::Tuple, arch::AbstractArchitecture, grid)\n\nConstruct a Field on architecture arch and grid with location defined by the tuple L of length 3 whose elements are Cell or Face.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.data-Tuple{Oceananigans.AbstractField}","page":"Library","title":"Oceananigans.data","text":"Returns a view over the interior points of the field.data.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.set!-Tuple{Oceananigans.AbstractField,Function}","page":"Library","title":"Oceananigans.set!","text":"Set the CPU field u data to the function f(x, y, z).\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.set!-Tuple{Oceananigans.AbstractField{A,G} where G where A<:(OffsetArrays.OffsetArray{T,D,#s70} where #s70<:Array where D where T),Array}","page":"Library","title":"Oceananigans.set!","text":"Set the CPU field u to the array v.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.set!-Tuple{Oceananigans.AbstractModel}","page":"Library","title":"Oceananigans.set!","text":"set!(model; kwargs...)\n\nSet velocity and tracer fields of model. The keyword arguments kwargs... take the form name=data, where name refers to one of the fields of model.velocities or model.tracers, and the data may be an array, a function with arguments (x, y, z), or any data type for which a set!(ϕ::AbstractField, data) function exists.\n\nExample\n\nmodel = Model(grid=RegularCartesianGrid(N=(32, 32, 32), L=(1, 1, 1))\n\n# Set u to a parabolic function of z, v to random numbers damped\n# at top and bottom, and T to some silly array of half zeros,\n# half random numbers.\n\nu₀(x, y, z) = z/model.grid.Lz * (1 + z/model.grid.Lz)\nv₀(x, y, z) = 1e-3 * rand() * u₀(x, y, z)\n\nT₀ = rand(size(model.grid)...)\nT₀[T₀ .< 0.5] .= 0\n\nset!(model, u=u₀, v=v₀, T=T₀)\n\n\n\n\n\n","category":"method"},{"location":"library/#Forcing-1","page":"Library","title":"Forcing","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"Modules = [Oceananigans]\nPrivate = false\nPages   = [\"forcing.jl\"]","category":"page"},{"location":"library/#Oceananigans.SimpleForcing","page":"Library","title":"Oceananigans.SimpleForcing","text":"SimpleForcing{X, Y, Z, F, P}\n\nCallable object for specifying 'simple' forcings of x, y, z, t and optionally parameters of type P at location X, Y, Z.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.SimpleForcing-Tuple{Tuple,Function}","page":"Library","title":"Oceananigans.SimpleForcing","text":"SimpleForcing([location=(Cell, Cell, Cell),] forcing; parameters=nothing)\n\nConstruct forcing for a field at location using forcing::Function, and optionally with parameters. If parameters=nothing, forcing must have the signature\n\n`forcing(x, y, z, t)`;\n\notherwise it must have the signature\n\n`forcing(x, y, z, t, parameters)`.\n\nExamples\n\njulia> const a = 2.1\n\njulia> fun_forcing(x, y, z, t) = a * exp(z) * cos(t)\n\njulia> u_forcing = SimpleForcing(fun_forcing)\n\njulia> parameterized_forcing(x, y, z, t, p) = p.μ * exp(z/p.λ) * cos(p.ω*t)\n\njulia> v_forcing = SimpleForcing(parameterized_forcing, parameters=(μ=42, λ=0.1, ω=π))\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.ModelForcing-Tuple{}","page":"Library","title":"Oceananigans.ModelForcing","text":"ModelForcing(; u=zeroforcing, v=zeroforcing, w=zeroforcing, tracer_forcings...)\n\nReturn a named tuple of forcing functions for each solution field.\n\nExample\n\njulia> u_forcing = SimpleForcing((x, y, z, t) -> exp(z) * cos(t))\n\njulia> model = Model(forcing=ModelForcing(u=u_forcing))\n\n\n\n\n\n","category":"method"},{"location":"library/#Grids-1","page":"Library","title":"Grids","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"Modules = [Oceananigans]\nPrivate = false\nPages   = [\"grids.jl\"]","category":"page"},{"location":"library/#Oceananigans.RegularCartesianGrid","page":"Library","title":"Oceananigans.RegularCartesianGrid","text":"RegularCartesianGrid{T<:AbstractFloat, R<:AbstractRange} <: AbstractGrid{T}\n\nA Cartesian grid with with constant grid spacings Δx, Δy, and Δz between cell centers and cell faces.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.RegularCartesianGrid-Tuple{Any,Any,Any}","page":"Library","title":"Oceananigans.RegularCartesianGrid","text":"RegularCartesianGrid([T=Float64]; N, L)\n\nCreates a RegularCartesianGrid with N = (Nx, Ny, Nz) grid points and domain size L = (Lx, Ly, Lz), where constants are stored using floating point values of type T.\n\nAdditional properties\n\n(xC, yC, zC)::AbstractRange: (x, y, z) coordinates of cell centers\n(xF, yF, zF)::AbstractRange: (x, y, z) coordinates of cell faces\n(Hx, Hy, Hz)::Int: Halo size in the (x, y, z)-direction\n(Tx, Ty, Tz)::Int: \"Total\" grid size (interior + halo points) in the (x, y, z)-direction\n\nExamples\n\njulia> grid = RegularCartesianGrid(N=(32, 32, 32), L=(1, 1, 1))\nRegularCartesianGrid{Float64}\n  resolution (Nx, Ny, Nz) = (32, 32, 32)\n   halo size (Hx, Hy, Hz) = (1, 1, 1)\n      domain (Lx, Ly, Lz) = (1.0, 1.0, 1.0)\ngrid spacing (Δx, Δy, Δz) = (0.03125, 0.03125, 0.03125)\n\njulia> grid = RegularCartesianGrid(Float32; N=(32, 32, 16), L=(8, 8, 2))\nRegularCartesianGrid{Float32}\n  resolution (Nx, Ny, Nz) = (32, 32, 16)\n   halo size (Hx, Hy, Hz) = (1, 1, 1)\n      domain (Lx, Ly, Lz) = (8.0f0, 8.0f0, 2.0f0)\ngrid spacing (Δx, Δy, Δz) = (0.25f0, 0.25f0, 0.125f0)\n\n\n\n\n\n","category":"method"},{"location":"library/#Models-1","page":"Library","title":"Models","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"Modules = [Oceananigans]\nPrivate = false\nPages   = [\"models.jl\"]","category":"page"},{"location":"library/#Oceananigans.Model-Tuple{}","page":"Library","title":"Oceananigans.Model","text":"Model(; grid, kwargs...)\n\nConstruct an Oceananigans.jl model on grid.\n\nKeyword arguments\n\ngrid: (required) The resolution and discrete geometry on which model is solved. Currently the only option is RegularCartesianGrid.\narchitecture: CPU() or GPU(). The computer architecture used to time-step model.\nfloat_type: Float32 or Float64. The floating point type used for model data.\nclosure: The turbulence closure for model. See TurbulenceClosures.\nbuoyancy: Buoyancy model parameters.\ncoriolis: Parameters for the background rotation rate of the model.\nforcing: User-defined forcing functions that contribute to solution tendencies.\nboundary_conditions: User-defined boundary conditions for model fields. Can be eitherSolutionBoundaryConditions or ModelBoundaryConditions. See BoundaryConditions, HorizontallyPeriodicSolutionBCs, and ChannelSolutionBCs.\nparameters: User-defined parameters for use in user-defined forcing functions and boundary condition functions.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.BasicModel-Tuple{}","page":"Library","title":"Oceananigans.BasicModel","text":"BasicModel(; N, L, ν=ν₀, κ=κ₀, float_type=Float64, kwargs...)\n\nConstruct a \"Basic\" Model with resolution N, domain extent L, precision float_type, and constant isotropic viscosity and diffusivity ν, and κ.\n\nAdditional kwargs are passed to the regular Model constructor.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.ChannelModel-Tuple{}","page":"Library","title":"Oceananigans.ChannelModel","text":"ChannelModel(; kwargs...)\n\nConstruct a Model with walls in the y-direction. This is done by imposing FreeSlip boundary conditions in the y-direction instead of Periodic.\n\nkwargs are passed to the regular Model constructor.\n\n\n\n\n\n","category":"method"},{"location":"library/#Output-writers-1","page":"Library","title":"Output writers","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"Modules = [Oceananigans]\nPrivate = false\nPages   = [\"output_writers.jl\"]","category":"page"},{"location":"library/#Oceananigans.Checkpointer","page":"Library","title":"Oceananigans.Checkpointer","text":"Checkpointer{I, T, P, A} <: AbstractOutputWriter\n\nAn output writer for checkpointing models to a JLD2 file from which models can be restored.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.Checkpointer-Tuple{Any}","page":"Library","title":"Oceananigans.Checkpointer","text":"Checkpointer(model; frequency=nothing, interval=nothing, dir=\".\", prefix=\"checkpoint\",\n                    force=false, verbose=false,\n                    properties = [:architecture, :boundary_conditions, :grid, :clock,\n                                  :eos, :constants, :closure, :velocities, :tracers,\n                                  :timestepper])\n\nConstruct a Checkpointer that checkpoints the model to a JLD2 file every so often as specified by frequency or interval. The model.clock.iteration is included in the filename to distinguish between multiple checkpoint files.\n\nNote that extra model properties can be safely specified, but removing crucial properties such as :velocities will make restoring from the checkpoint impossible.\n\nThe checkpoint file is generated by serializing model properties to JLD2. However, functions cannot be serialized to disk (at least not with JLD2). So if a model property contains a reference somewhere in its hierarchy it will not be included in the checkpoint file (and you will have to manually restore them).\n\nKeyword arguments\n\nfrequency::Int   : Save output every n model iterations.\ninterval::Int    : Save output every t units of model clock time.\ndir::String      : Directory to save output to. Default: \".\" (current working directory).\nprefix::String   : Descriptive filename prefixed to all output files. Default: \"checkpoint\".\nforce::Bool      : Remove existing files if their filenames conflict. Default: false.\nverbose::Bool    : Log what the output writer is doing with statistics on compute/write times and file sizes.                      Default: false.\nproperties::Array: List of model properties to checkpoint.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.FieldOutput","page":"Library","title":"Oceananigans.FieldOutput","text":"FieldOutput([return_type=Array], field)\n\nReturns a FieldOutput type intended for use with the JLD2OutputWriter. Calling FieldOutput(model) returns return_type(field.data.parent).\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.JLD2OutputWriter","page":"Library","title":"Oceananigans.JLD2OutputWriter","text":"JLD2OutputWriter{F, I, O, IF, IN, KW} <: AbstractOutputWriter\n\nAn output writer for writing to JLD2 files.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.JLD2OutputWriter-Tuple{Any,Any}","page":"Library","title":"Oceananigans.JLD2OutputWriter","text":"JLD2OutputWriter(model, outputs; interval=nothing, frequency=nothing, dir=\".\",\n                 prefix=\"\", init=noinit, including=[:grid, :coriolis, :buoyancy, :closure],\n                 part=1, max_filesize=Inf, force=false, async=false, verbose=false)\n\nConstruct a JLD2OutputWriter that writes label, func pairs in outputs (which can be a Dict or NamedTuple) to a JLD2 file, where label is a symbol that labels the output and func is a function of the form func(model) that returns the data to be saved.\n\nKeyword arguments\n\nfrequency::Int   : Save output every n model iterations.\ninterval::Int    : Save output every t units of model clock time.\ndir::String      : Directory to save output to. Default: \".\" (current working directory).\nprefix::String   : Descriptive filename prefixed to all output files. Default: \"\".\ninit::Function   : A function of the form init(file, model) that runs when a JLD2 output file is initialized.                      Default: noinit(args...) = nothing.\nincluding::Array : List of model properties to save with every file. By default, the grid, equation of state,                      Coriolis parameters, buoyancy parameters, and turbulence closure parameters are saved.\npart::Int        : The starting part number used if max_filesize is finite. Default: 1.\nmax_filesize::Int: The writer will stop writing to the output file once the file size exceeds max_filesize, and                      write to a new one with a consistent naming scheme ending in part1, part2, etc. Defaults to                      Inf.\nforce::Bool      : Remove existing files if their filenames conflict. Default: false.\nasync::Bool      : Write output asynchronously. Default: false.\nverbose::Bool    : Log what the output writer is doing with statistics on compute/write times and file sizes.                      Default: false.\njld2_kw::Dict    : Dict of kwargs to be passed to jldopen when data is written.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.NetCDFOutputWriter","page":"Library","title":"Oceananigans.NetCDFOutputWriter","text":"NetCDFOutputWriter <: AbstractOutputWriter\n\nAn output writer for writing to NetCDF files.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceananigans.FieldOutputs-Tuple{Any}","page":"Library","title":"Oceananigans.FieldOutputs","text":"FieldOutputs(fields)\n\nReturns a dictionary of FieldOutput objects with key, value pairs corresponding to each name and value in the NamedTuple fields. Intended for use with JLD2OutputWriter.\n\nExamples\n\njulia> output_writer = JLD2OutputWriter(model, FieldOutputs(model.velocities), frequency=1);\n\njulia> keys(output_writer.outputs)\nBase.KeySet for a Dict{Symbol,FieldOutput{UnionAll,F} where F} with 3 entries. Keys:\n  :w\n  :v\n  :u\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.restore_from_checkpoint-Tuple{Any}","page":"Library","title":"Oceananigans.restore_from_checkpoint","text":"restore_from_checkpoint(filepath; kwargs=Dict())\n\nRestore a model from the checkpoint file stored at filepath. kwargs can be passed to the Model constructor, which can be especially useful if you need to manually restore forcing functions or boundary conditions that rely on functions.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.write_grid-Tuple{Any}","page":"Library","title":"Oceananigans.write_grid","text":"write_grid(model; filename=\"grid.nc\", mode=\"c\", \n           compression=0, attributes=Dict(), slice_kw...)\n\nWrites a grid.nc file that contains all the dimensions of the domain.\n\nKeyword arguments\n\n- `filename::String`  : File name to be saved under\n- `mode::String`      : Netcdf file is opened in either clobber (\"c\") or append (\"a\") mode (Default: \"c\" )\n- `compression::Int`  : Defines the compression level of data (0-9, default 0)\n- `attributes::Dict`  : Attributes (default: Dict())\n\n\n\n\n\n","category":"method"},{"location":"library/#Time-steppers-1","page":"Library","title":"Time steppers","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"Modules = [Oceananigans]\nPrivate = false\nPages   = [\"time_steppers.jl\"]","category":"page"},{"location":"library/#Oceananigans.time_step!-Tuple{Any,Any,Any}","page":"Library","title":"Oceananigans.time_step!","text":"time_step!(model, Nt, Δt; init_with_euler=true)\n\nStep forward model Nt time steps with step size Δt.\n\nIf init_with_euler is set to true, then the first step will be taken using a first-order forward Euler method.\n\n\n\n\n\n","category":"method"},{"location":"library/#Utilities-1","page":"Library","title":"Utilities","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"Modules = [Oceananigans]\nPrivate = false\nPages   = [\"utils.jl\"]","category":"page"},{"location":"library/#Oceananigans.pretty_filesize","page":"Library","title":"Oceananigans.pretty_filesize","text":"pretty_filesize(s, suffix=\"B\")\n\nConvert a floating point value s representing a file size to a more human-friendly formatted string with one decimal places with a suffix defaulting to \"B\". Depending on the value of s the string will be formatted to show s using an SI prefix from bytes, kiB (1024 bytes), MiB (1024² bytes), and so on up to YiB (1024⁸ bytes).\n\n\n\n\n\n","category":"function"},{"location":"library/#Oceananigans.prettytime-Tuple{Any}","page":"Library","title":"Oceananigans.prettytime","text":"prettytime(t)\n\nConvert a floating point value t representing an amount of time in seconds to a more human-friendly formatted string with three decimal places. Depending on the value of t the string will be formatted to show t in nanoseconds (ns), microseconds (μs), milliseconds (ms), seconds (s), minutes (min), hours (hr), or days (day).\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceananigans.update_Δt!-Tuple{Any,Any}","page":"Library","title":"Oceananigans.update_Δt!","text":"update_Δt!(wizard, model)\n\nCompute wizard.Δt given the velocities and diffusivities of model, and the parameters of wizard.\n\n\n\n\n\n","category":"method"},{"location":"verification/stratified_couette_flow/#Stratified-Couette-flow-1","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"","category":"section"},{"location":"verification/stratified_couette_flow/#","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"In regular plane Couette flow, a viscous fluid is situated between two infinite, parallel plates and usually the top plate moves at some constant velocity generating a linear velocity profile in steady state \\citep[\\S4.2–4.3]{Batchelor00}.","category":"page"},{"location":"verification/stratified_couette_flow/#","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"In stratified Couette flow, the plates are additionally held at fixed temperatures to provide a stable stratification. It is a canonical geometry in which to investigate the dynamics of stratified shear flows as it exhibits a transition to turbulence, intermittent turbulence, coherent structures, and diapycnal mixing among other rich behavior \\citep{Zhou17}.","category":"page"},{"location":"verification/stratified_couette_flow/#","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"In this test we follow \\citet{Vreugdenhil18} who use stratified Couette flow as a test of their large-eddy simulation model. We will compare our results to theirs and the direct numerical simulation results of \\citet{Deusebio15} and \\citet{Zhou17}.","category":"page"},{"location":"verification/stratified_couette_flow/#","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"In our setup replicating that of \\citet{Vreugdenhil18}, a domain of size (L_x L_y L_z)h = (4pi 2pi 2) is bounded in the vertical z-direction by two infinite, parallel plates or walls at z = pm h with horizontal velocity u = pm U_w and constant temperature theta = pm Theta_w where theta denotes temperature in this section. The resulting flow is governed by the Reynolds, Richardson, and Prandtl numbers","category":"page"},{"location":"verification/stratified_couette_flow/#","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"textRe = fracU_w hnu quad\ntextRi = fracalpha g Theta_w hU_w^2 quad\ntextPr = fracnukappa","category":"page"},{"location":"verification/stratified_couette_flow/#","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"where nu is the kinematic viscosity, kappa is the thermal diffusivity, alpha is the thermal expansion coefficient, and g is the gravitational acceleration.","category":"page"},{"location":"verification/stratified_couette_flow/#","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"Defining horizontal averages for velocity U = langle u rangle and Theta = langle theta rangle we can define the friction velocity u_tau and friction temperature theta_tau at the wall by","category":"page"},{"location":"verification/stratified_couette_flow/#","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"u_tau^2 = fractau_wrho_0\n         = nu leftvert fracpartial Upartial z rightvert_z = pm h quad\ntheta_tau = fracq_wu_tau\n            = frackappau_tau leftvert fracpartialThetapartial z rightvert_z = pm h","category":"page"},{"location":"verification/stratified_couette_flow/#","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"where tau_w is the wall stress and q_w = u_tau theta_tau is the wall heat flux.","category":"page"},{"location":"verification/stratified_couette_flow/#","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"From here the friction Reynolds number and the Nusselt number can be defined","category":"page"},{"location":"verification/stratified_couette_flow/#","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"textRe_tau = fracu_tau hnu quad textNu = fracq_w hkappa Theta_w","category":"page"},{"location":"verification/stratified_couette_flow/#","page":"Stratified Couette flow","title":"Stratified Couette flow","text":"which can be computed and compared.","category":"page"},{"location":"manual/time_stepping/#Time-stepping-1","page":"Time stepping","title":"Time stepping","text":"","category":"section"},{"location":"manual/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"If we combine all the terms that must be evaluated at time step n + frac12 into a variable G, then we have","category":"page"},{"location":"manual/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"renewcommanddiv1 nabla cdotp left ( 1 right )\nbmG_bmu^n\n  = -left bmu cdot nabla bmu right^n - 2bmOmegatimesbmu^n + divnunablabmu^n + bmF^n","category":"page"},{"location":"manual/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"where bmG_bmu = (G_u G_v G_w). Together with \\eqref{eq:projection-step} allows us to write the discretized momentum equation as","category":"page"},{"location":"manual/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"fracbmu^n+1 - bmu^nDelta t\n  = bmG_bmu^n+12 - nabla (phi_HY^prime + phi_NH)^n+1","category":"page"},{"location":"manual/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"where we have brought back the hydrostatic pressure anomaly phi_HY^prime and non-hydrostatic pressure phi_NH.","category":"page"},{"location":"manual/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"Doing the same for tracer quantities yields","category":"page"},{"location":"manual/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"renewcommanddiv1 nabla cdotp left ( 1 right )\nG_c^n = bmu^n cdot nabla c^n + divkappa_c nabla c^n + F_c^n","category":"page"},{"location":"manual/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"and","category":"page"},{"location":"manual/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"fracc^n+1 - c^nDelta t = G_c^n + frac12","category":"page"},{"location":"manual/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"We evaluate the G^n + frac12 terms explicitly using a weighted two-step Adams–Bashforth (AB2) method","category":"page"},{"location":"manual/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"    G^n+frac12 = left( frac32 + chi right) G^n - left( frac12 + chi right) G^n-1 ","category":"page"},{"location":"manual/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"AB2 has the advantage of being quasi-second-order accurate in time and yet does not have a computational mode (???). Furthermore, it can be implemented by evaluating the source terms G only once and storing them for use on the next time step, thus using less memory than higher-order time stepping schemes.","category":"page"},{"location":"manual/time_stepping/#","page":"Time stepping","title":"Time stepping","text":"It turns out that for a second-order accurate approximation of G^n+frac12 we require chi = frac18 \\citep{Ascher95}. Note that chi = 0 reproduces the unweighted Adams-Bashforth method which calculates a second-order accurate approximation of G^n+1. Also note that chi = -frac12 reproduces the first-order accurate forward Euler method, useful for initializing the model when G^n-1 is not available, such as at the first time step.","category":"page"},{"location":"manual/finite_volume/#Finite-volume-method-1","page":"Finite volume method","title":"Finite volume method","text":"","category":"section"},{"location":"manual/finite_volume/#","page":"Finite volume method","title":"Finite volume method","text":"The grid is defined by a Cartesian array of cuboids of horizontal dimensions Delta x Delta y and vertical dimension Delta z. The areas of the cell faces are given by","category":"page"},{"location":"manual/finite_volume/#","page":"Finite volume method","title":"Finite volume method","text":"    A_x = Delta y Delta z quad A_y = Delta x Delta z quad A_z = Delta x Delta y","category":"page"},{"location":"manual/finite_volume/#","page":"Finite volume method","title":"Finite volume method","text":"so that each cell encloses a volume V = Delta x Delta y Delta z.","category":"page"},{"location":"manual/finite_volume/#","page":"Finite volume method","title":"Finite volume method","text":"The cells are indexed by (i j k) where i in 1 2 dots N_x, j in 1 2 dots N_y, and k in 1 2 dots N_z with k=1 corresponding to the top of the domain and k=N_z corresponding to the bottom. This has made a lot of people very angry and been widely regarded as a bad move.","category":"page"},{"location":"manual/finite_volume/#","page":"Finite volume method","title":"Finite volume method","text":"In a finite volume method we work with the average quantity in the control volume, defined by","category":"page"},{"location":"manual/finite_volume/#","page":"Finite volume method","title":"Finite volume method","text":"  overlineu = frac1V int_Omega u(bmx)  dV","category":"page"},{"location":"manual/finite_volume/#","page":"Finite volume method","title":"Finite volume method","text":"where Omega denotes the control volume. We will always deal with the cell-averaged values so we will drop the overlinecdotp notation from now on.","category":"page"},{"location":"manual/finite_volume/#","page":"Finite volume method","title":"Finite volume method","text":"Integrating the momentum equations \\eqref{eq:xMomentum}–\\eqref{eq:zMomentum} over a control volume and approximating the time derivative by a first-order forward Euler formula and evaluating the spatial derivatives at the current time step we get an update formula for the momentum equation","category":"page"},{"location":"manual/finite_volume/#","page":"Finite volume method","title":"Finite volume method","text":"renewcommanddiv1 nabla cdotp left ( 1 right )\nfracbmu^n+1 - bmu^nDelta t\n  = -bmu^n cdotp nablabmu^n - 2bmOmegatimesbmu^n - nablaphi^n + divnunablabmu^n + bmF^n","category":"page"},{"location":"manual/finite_volume/#","page":"Finite volume method","title":"Finite volume method","text":"and doing the same for the tracer equation \\eqref{eq:tracer2} we get","category":"page"},{"location":"manual/finite_volume/#","page":"Finite volume method","title":"Finite volume method","text":"renewcommanddiv1 nabla cdot left ( 1 right )\nfracc^n+1 - c^nDelta t = - bmu^n cdotp nabla c^n + divkappa_c nabla c^n + F_c^n","category":"page"},{"location":"manual/finite_volume/#","page":"Finite volume method","title":"Finite volume method","text":"where n denotes the current time step and n+1 is the next time step. Furthermore, the incompressibility condition","category":"page"},{"location":"manual/finite_volume/#","page":"Finite volume method","title":"Finite volume method","text":"nabla cdotp bmu^n+1 = 0","category":"page"},{"location":"manual/finite_volume/#","page":"Finite volume method","title":"Finite volume method","text":"must be satisfied at all time steps.","category":"page"},{"location":"manual/poisson_solvers/#Poisson-solvers-1","page":"Poisson solvers","title":"Poisson solvers","text":"","category":"section"},{"location":"manual/poisson_solvers/#The-elliptic-problem-for-the-pressure-1","page":"Poisson solvers","title":"The elliptic problem for the pressure","text":"","category":"section"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"The pressure field is obtained by taking the divergence of the horizontal component of the momentum equation \\eqref{eq:momentumStar} and invoking the vertical component to yield an elliptic Poisson equation for the non-hydrostatic kinematic pressure","category":"page"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"nabla^2phi_NH = fracnabla cdot bmu^nDelta t + nabla cdot bmG_bmu equiv mathscrF","category":"page"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"along with homogenous Neumann boundary conditions bmu cdot bmhatn = 0 (Neumann on phi for wall-bounded directions and periodic otherwise) and where mathscrF denotes the source term for the Poisson equation.","category":"page"},{"location":"manual/poisson_solvers/#Direct-method-1","page":"Poisson solvers","title":"Direct method","text":"","category":"section"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"Discretizing elliptic problems that can be solved via a classical separation-of-variables approach, such as Poisson's equation, results in a linear system of equations Mbmx = bmy where M is a real symmetric matrix of block tridiagonal form. This allows for the matrix to be decomposed and solved efficiently, provided that the eigenvalues and eigenvectors of the blocks are known \\citep[\\S2]{Buzbee70}. In the case of Poisson's equation on a rectangle, \\citet{Hockney65} has taken advantage of the fact that the fast Fourier transform can be used to perform the matrix multiplication steps resulting in an even more efficient method. \\citet{Schumann88} describe the implementation of such an algorithm for Poisson's equation on a staggered grid with Dirchlet, Neumann, and periodic boundary conditions.","category":"page"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"The method can be explained easily by taking the Fourier transform of both sides of \\eqref{eq:poisson-pressure} to yield","category":"page"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"-(k_x^2 + k_y^2 + k_z^2) widehatphi_NH = widehatmathscrF\nquad implies quad\nwidehatphi_NH = - fracwidehatmathscrFk_x^2 + k_y^2 + k_z^2","category":"page"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"where widehatcdot denotes the Fourier component. Here k_x, k_y, and k_z are the wavenumbers. However, when solving the equation on a staggered grid we require a solution for phi_NH that is second-order accurate such that when when its Laplacian is computed, nabla^2phi_NH matches mathscrF to machine precision. This is crucial to ensure that the projection step in \\S\\ref{sec:fractional-step} works. To do this, the wavenumbers are replaced by eigenvalues lambda_x, lambda_y, and lambda_z satisfying the discrete form of Poisson's equation with appropriate boundary conditions. Thus, Poisson's equation's is diagonalized in Fourier space and the Fourier coefficients of the solution are easily solved for","category":"page"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"widehatphi_NH(i j k) = - fracwidehatmathscrF(i j k)lambda^x_i + lambda^y_j + lambda^z_k","category":"page"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"The eigenvalues are given by \\citet{Schumann88} and can also be tediously derived by plugging in the definition of the discrete Fourier transform into \\eqref{eq:poisson-spectral}","category":"page"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"beginaligned\n    lambda^x_i = 4fracN_x^2L_x^2 sin^2 left  frac(i-1)piN_x  right  quad i=01 dotsN_x-1 \n    lambda^x_j = 4fracN_y^2L_y^2 sin^2 left  frac(j-1)piN_y  right  quad j=01 dotsN_y-1 \n    lambda^x_k = 4fracN_z^2L_z^2 sin^2 left  frac(k-1)pi2N_z right  quad k=01 dotsN_z-1\nendaligned","category":"page"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"where lambda_x and lambda_y correspond to periodic boundary conditions in the horizontal and lambda_z to Neumann boundary conditions in the vertical.","category":"page"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"There is also an ambiguity in the solution to Poisson's equation as it's only defined up to a constant. To resolve this we choose the solution with zero mean by setting the zeroth Fourier coefficient phi_000 (corresponding to k_x = k_y = k_z = 0) to zero. This also has the added benefit of discarding the zero eigenvalue so we don't divide by it.","category":"page"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"The Fast Fourier transforms are computed using FFTW.jl \\citep{Frigo98,Frigo05} on the CPU and using the cuFFT library on the GPU. Along wall-bouded dimensions, the cosine transform is used. In particular, as the transforms are performed on a staggered grid, DCT-II (REDFT10) is used to perform the forward cosine transform and DCT-III (REDFT01) is used to perform the inverse cosine transform.","category":"page"},{"location":"manual/poisson_solvers/#Direct-method-with-a-vertically-stretched-grid-1","page":"Poisson solvers","title":"Direct method with a vertically stretched grid","text":"","category":"section"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"Using Fourier transforms for all three dimensions results in a method requiring mathcalO(N log_2 N) operations where N is the total number of grid points. This algorithm can be made even more efficient by solving a tridiagonal system along one of the dimensions and utilizing cyclic reduction. This results in the Fourier analysis cyclic reduction or textFACR(ell) algorithm (with ell cyclic reduction steps) which requires only mathcalO(N log_2log_2 N) operations provided the optimal number of cyclic reduction steps is taken, which is ell = log_2 log_2 n where n is the number of grid points in the cyclic reduction dimension. The FACR algorithm was first developed by \\citet{Hockney69} and is well reviewed by \\citet{Swarztrauber77} then further benchmarked and extended by \\citet{Temperton79} and \\citet{Temperton80}.","category":"page"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"Furthermore, the FACR algorithm removes the restriction that the grid is uniform in one of the dimensions so it can be utilized to implement a fast Poisson solver for vertically stretched grids if the cyclic reduction is applied in the along the vertical dimension.","category":"page"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"Expanding phi_NH and mathscrF into Fourier modes along the x and y directions","category":"page"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"phi_ijk = sum_m=1^N_x sum_n=1^N_y tildephi_mnk  e^-i2pi im  N_x   e^-i2pi jn  N_y","category":"page"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"and recalling that Fourier transforms do partial_x rightarrow ik_x and partial_y rightarrow ik_y we can write \\eqref{eq:poisson-pressure} as","category":"page"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"sum_m=1^N_x sum_n=1^N_y\nleftlbrace\n    partial_z^2 tildephi_mnk - (k_x^2 + k_y^2) tildephi_mnk - tildemathscrF_mnk\nrightrbrace e^-i2pi im  N_x  e^-i2pi jn  N_y = 0","category":"page"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"Discretizing the partial_z^2 derivative and equating the term inside the brackets to zero we arrive at N_xtimes N_y symmetric tridiagonal systems of N_z linear equations for the Fourier modes:","category":"page"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"fractildephi_mnk-1Delta z^F_k-1\n- leftlbrace frac11Delta z^F_k-1 + 1Delta z^F_k + Delta z^C_k (k_x^2 + k_y^2) rightrbrace\n  tildephi_mnk\n+ fractildephi_mnk+1Delta z^F_k\n= Delta z^C_k tildemathscrF_mnk","category":"page"},{"location":"manual/poisson_solvers/#Cosine-transforms-on-the-GPU-1","page":"Poisson solvers","title":"Cosine transforms on the GPU","text":"","category":"section"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"Unfortunately cuFFT does not provide cosine transforms and so we must write our own fast cosine transforms for the GPU. We implemented the fast 1D and 2D cosine transforms described by \\citet{Makhoul80} which compute it by applying the regular Fourier transform to a permuted version of the array.","category":"page"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"In this section we will be using the DCT-II as the definition of the forward cosine transform for a real signal of length N","category":"page"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"  textDCT(X) quad Y_k = 2 sum_j=0^N-1 cos left fracpi(j + frac12)kN right X_j","category":"page"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"and the DCT-III as the definition of the inverse cosine transform","category":"page"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"  textIDCT(X) quad Y_k = X_0 + 2 sum_j=1^N-1 cos left fracpi j (k + frac12)N right X_j","category":"page"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"and will use omega_M = e^-2pi iM to denote the M^textth root of unity, sometimes called the twiddle factors in the context of FFT algorithms.","category":"page"},{"location":"manual/poisson_solvers/#D-fast-cosine-transform-1","page":"Poisson solvers","title":"1D fast cosine transform","text":"","category":"section"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"To calculate \\eqref{eq:FCT} using the fast Fourier transform, we first permute the input signal along the appropriate dimension by ordering the odd elements first followed by the even elements to produce a permuted signal","category":"page"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"    X^prime_n =\n    begincases\n        displaystyle X_2N quad 0 le n le left fracN-12 right \n        displaystyle X_2N - 2n - 1 quad left fracN+12 right le n le N-1\n    endcases","category":"page"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"where a indicates the integer part of a. This should produce, for example,","category":"page"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"    (a b c d e f g h) quad rightarrow quad (a c e g h f d b)","category":"page"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"after which \\eqref{eq:FCT} is computed using","category":"page"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"  Y = textDCT(X) = 2 textRe leftlbrace omega_4N^k textFFT lbrace X^prime rbrace rightrbrace","category":"page"},{"location":"manual/poisson_solvers/#D-fast-inverse-cosine-transform-1","page":"Poisson solvers","title":"1D fast inverse cosine transform","text":"","category":"section"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"The inverse \\eqref{eq:IFCT} can be computed using","category":"page"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"  Y = textIDCT(X) = textRe leftlbrace omega_4N^-k textIFFT lbrace X rbrace rightrbrace","category":"page"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"after which the inverse permutation of \\eqref{eq:permutation} must be applied.","category":"page"},{"location":"manual/poisson_solvers/#D-fast-cosine-transform-2","page":"Poisson solvers","title":"2D fast cosine transform","text":"","category":"section"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"Unfortunately, the 1D algorithm cannot be applied dimension-wise so the 2D algorithm is  more complicated. Thankfully though, the permutation \\eqref{eq:permutation} can be applied dimension-wise. The forward cosine transform for a real signal of length N_1 times N_2 is then given by","category":"page"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"Y_k_1 k_2 = textDCT(X_n_1 n_2) =\n2 textRe leftlbrace\n    omega_4N_1^k left( omega_4N_2^k tildeX + omega_4N_2^-k tildeX^- right)\nrightrbrace","category":"page"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"where tildeX = textFFT(X^prime) and tildeX^- indicates that tildeX is indexed in reverse.","category":"page"},{"location":"manual/poisson_solvers/#D-fast-inverse-cosine-transform-2","page":"Poisson solvers","title":"2D fast inverse cosine transform","text":"","category":"section"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"The inverse can be computed using","category":"page"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"Y_k_1 k_2 = textIDCT(X_n_1 n_2) =\nfrac14 textRe leftlbrace\n    omega_4N_1^-k omega_4N_2^-k\n    left( tildeX - M_1 M_2 tildeX^-- right)\n    - i left( M_1 tildeX^-+ + M_2 tildeX^+- right)\nrightrbrace","category":"page"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"where tildeX = textIFFT(X) here, tildeX^-+ is indexed in reverse along the first dimension, tildeX^-+ along the second dimension, and tildeX^-- along both. M_1 and M_2 are masks of lengths N_1 and N_2 respectively, both containing ones except at the first element where M_0 = 0. Afterwards, the inverse permutation of \\eqref{eq:permutation} must be applied.","category":"page"},{"location":"manual/poisson_solvers/#","page":"Poisson solvers","title":"Poisson solvers","text":"Due to the extra steps involved in calculating the cosine transform in 2D, running with two wall-bounded dimensions typically slows the model down by a factor of 2. Switching to the FACR algorithm may help here as a 2D cosine transform won't be neccessary anymore.","category":"page"},{"location":"manual/turbulence_closures/#Turbulence-closures-1","page":"Turbulence closures","title":"Turbulence closures","text":"","category":"section"},{"location":"manual/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"To truly simulate and resolve turbulence at high Reynolds number (so basically all interesting flows) would require you resolve all motions down to the \\citet{Kolmogorov41} length scale eta = (nu^3  varepsilon)^14 where nu is the kinematic viscosity and varepsilon the average rate of dissipation of turbulence kinetic energy per unit mass.","category":"page"},{"location":"manual/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"As pointed out way back by \\citet{Corrsin61}, to run a simulation on a horizontal domain about 10 times the size of an \"average eddy\" with 100 vertical levels and where the grid spacing is given by eta would require the computer to store on the order of 10^14 variables.[1] This is still impractical today, although may be within reach in less than a decade. He ends by suggesting the use of an analog rather digital computer–-a tank of water.","category":"page"},{"location":"manual/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"[1]: And even then, eta gives the maximum allowable grid spacing. There is significant flow structure smaller than eta.","category":"page"},{"location":"manual/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"To have any hope of simulating high Reynolds number flows we need some way of resolving the sub-grid scale motions.[2]","category":"page"},{"location":"manual/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"[2]: In reality there is no need to resolve all motions down to the Kolmogorov length scale to achieve acceptable accuracy. Perhaps good results can be achieved if 80\\% of the kinetic energy is resolved \\citep[\\S13]{Pope00}.","category":"page"},{"location":"manual/turbulence_closures/#Reynolds-averaged-Navier–Stokes-equations-1","page":"Turbulence closures","title":"Reynolds-averaged Navier–Stokes equations","text":"","category":"section"},{"location":"manual/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"Following \\citet{Reynolds1895} we can decompose flow variables such as velocity bmu into the mean component overlinebmu and the fluctuating component bmu^prime so that bmu = overlinebmu + bmu^prime [see \\citet[\\S4]{Pope00} for a modern discussion].","category":"page"},{"location":"manual/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"Expressing the Navier-Stokes equations in tensor notation","category":"page"},{"location":"manual/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"beginaligned\n    partial_i u_i = 0 \n    partial_t u_i + u_j partial_j u_i = f_i - alphapartial_i p + nu partial_j partial_j u_i\nendaligned","category":"page"},{"location":"manual/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"where alpha = rho^-1 is the specific volume and f_i represents external forces. We can plug in the Reynolds decomposition for bmu and after some manipulation arrive at the following form for the Reynolds-averaged Navier-Stokes equations","category":"page"},{"location":"manual/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"beginaligned\n    partial_i overlineu_i = 0 \n    partial_t overlineu_i + overlineu_j partial_j overlineu_i = overlinef_i -\n    partial_j left(-alphaoverlinepdelta_ij + 2nu overlineS_ij - overlineu_i^prime u_j^primeright)\nendaligned","category":"page"},{"location":"manual/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"where","category":"page"},{"location":"manual/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"overlineS_ij = frac12 ( partial_j overlineu_i + partial_i overlineu_j )","category":"page"},{"location":"manual/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"is the mean rate of strain tensor.","category":"page"},{"location":"manual/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"Thanks to the non-linearity of the Navier-Stokes equations, even when averaged we are left with pesky fluctuation terms which form the components of the Reynolds stress tensor","category":"page"},{"location":"manual/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"tau_ij = rho overlineu_i^prime u_j^prime","category":"page"},{"location":"manual/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"Attempting to close the equations leads to the closure problem: the time evolution of the Reynolds stresses depends on  triple covariances overlineu_i^prime u_j^prime u_k^prime and covariances with pressure, which depend on quadruple covariances and so on \\citep{Chou45}.","category":"page"},{"location":"manual/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"This is kind of hopeless so we will have to find some way to model the Reynolds stresses.","category":"page"},{"location":"manual/turbulence_closures/#Gradient-diffusion-hypothesis-and-eddy-viscosity-models-1","page":"Turbulence closures","title":"Gradient-diffusion hypothesis and eddy viscosity models","text":"","category":"section"},{"location":"manual/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"The gradient-diffusion hypothesis, due to \\citet{Boussinesq1877}, assumes that the transport of scalar fluxes such as overlinebmu^prime c^prime and overlineu_i^prime u_j^prime occurs down the mean scalar gradient grad c as if they are being diffused \\citep[\\S4.4]{Pope00}. This is in analogy with how momentum transfer by molecular motion in a gas can be described by a molecular viscosity.","category":"page"},{"location":"manual/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"Taking this assumption we can express the Reynolds stresses and turbulent tracer fluxes in terms of the mean variables and close the equations","category":"page"},{"location":"manual/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"overlinebmu^prime c^prime = -kappa_e nabla overlinec\nquad textand quad\noverlineu_i^prime u_j^prime = -2nu_e overlineS_ij","category":"page"},{"location":"manual/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"where nu_e = nu_e(bmx t) is the turbulent or eddy viscosity and kappa_e = kappa_e(bmx t) is the eddy diffusivity.","category":"page"},{"location":"manual/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"The effective diffusivity ends up being the sum of the molecular and eddy diffusivities. So just by using an elevated value for the viscosity and diffusivity, you are already using an eddy viscosity model.","category":"page"},{"location":"manual/turbulence_closures/#","page":"Turbulence closures","title":"Turbulence closures","text":"The eddy viscosity model is simple and for that reason is very popular. It can work well even with a constant eddy diffusivity. However, it does assume that the flux is aligned down gradient, which is not true even in simple turbulent flows as the physics of turbulence is quite different from that of colliding molecules leading to the viscous stress law \\citep[\\S4.4,10.1]{Pope00}. So we might want something a little bit more sophisticated.","category":"page"},{"location":"manual/staggered_grid/#Staggered-grid-1","page":"Staggered grid","title":"Staggered grid","text":"","category":"section"},{"location":"manual/staggered_grid/#","page":"Staggered grid","title":"Staggered grid","text":"Velocities u, v, and w are defined on the faces of the cells, which are coincident with three orthogonal coordinate axes (the Cartesian axes in the case of Oceananigans). Pressure p and tracers c are stored at the cell  centers as cell averages. See figure \\ref{fig:staggered_grid} for a schematic of the different control volumes. Other quantities may be defined at other locations. For example, vorticity bmomega = nablatimesbmu is defined at the cell edges.[1]","category":"page"},{"location":"manual/staggered_grid/#","page":"Staggered grid","title":"Staggered grid","text":"[1]: In 2D it would more correct to say the cell corners. In 3D, variables like vorticity lie at the same vertical levels as the cell-centered variables and so they really lie at the cell edges.","category":"page"},{"location":"manual/staggered_grid/#","page":"Staggered grid","title":"Staggered grid","text":"(Image: Schematic of control volumes) Figure 1: A schematic of the control volumes in a two-dimensional staggered grid. Note that pressure p (and tracers) is defined at the center of the control volume. The u control volumes are centered on the left and right edges of the pressure control volume while the v control volumes are centered on the top and bottom edges of the pressure control volumes. Figure credit: \\citet{Kumar16}","category":"page"},{"location":"manual/staggered_grid/#","page":"Staggered grid","title":"Staggered grid","text":"This staggered arrangement of variables is more complicated than the collocated grid arrangement but is greatly beneficial as it avoids the odd-even decoupling between the pressure and velocity if they are stored at the same positions. \\citet[\\S6.1]{Patankar80} discusses this problem in the presence of a zigzag pressure field: on a 1D collocated grid the velocity at the point i is influenced by the pressure at points i-1 and i+1, and a zigzag pressure field will be felt as a uniform pressure, which is obviously wrong and would reduce the accuracy of the solution. The pressure is effectively taken from a coarser grid than what is actually used. The basic problem is that the momentum equations will use the pressure difference between two alternate points when it should be using two adjacent points.","category":"page"},{"location":"manual/staggered_grid/#","page":"Staggered grid","title":"Staggered grid","text":"From the viewpoint of linear algebra, these spurious pressure modes correspond to solutions in the null space of the pressure projection operator with eigenvalue zero and are thus indistinguishable from a uniform pressure field \\citep{Sani81}.","category":"page"},{"location":"manual/staggered_grid/#","page":"Staggered grid","title":"Staggered grid","text":"The staggered grid was first introduced by \\citet{Harlow65} with their \\emph{marker and cell} method. In meteorology and oceanography, the staggered grid is usually referred to as the Arakawa C-grid after \\citet{Arakawa77}, who investigated four different staggered grids and the unstaggered A-grid for use in an atmospheric model.","category":"page"},{"location":"manual/staggered_grid/#","page":"Staggered grid","title":"Staggered grid","text":"\\citet{Arakawa77} investigated the dispersion relation of intertia-gravity waves[2] travelling in the x-direction","category":"page"},{"location":"manual/staggered_grid/#","page":"Staggered grid","title":"Staggered grid","text":"  omega^2 = f^2 + gHk^2","category":"page"},{"location":"manual/staggered_grid/#","page":"Staggered grid","title":"Staggered grid","text":"in the linearized rotating shallow-water equations for five grids. Here omega is the angular frequency, H is the height of the fluid and k is the wavenumber in the x-direction. Looking at the effect of spatial discretization error on the frequency of these waves they find that the B and C-grids reproduce the dispersion relation most closely out of the five \\citep[Figure 5]{Arakawa77}. In particular, the dispersion relation for the C-grid is given by","category":"page"},{"location":"manual/staggered_grid/#","page":"Staggered grid","title":"Staggered grid","text":"  omega^2 = f^2 left cos^2 left( frackDelta2 right)\n             + 4 left( fraclambdaDelta right)^2 sin^2 left( frackDelta2 right) right","category":"page"},{"location":"manual/staggered_grid/#","page":"Staggered grid","title":"Staggered grid","text":"where lambda is the wavelength and Delta is the grid spacing. Paraphrasing \\citet[p. 184]{Arakawa77}: The wavelength of the shortest resolvable wave is 2Delta with corresponding wavenumber k = piDelta so it is sufficient to evaluate the dispersion relation over the range 0  kDelta  pi. The frequency is monotonically increasing for lambdaDelta  frac12 and monotonically decreasing for lambdaDelta  frac12. For the fourth smallest wave lambdaDelta = frac12 we get omega^2 = f^2 which matches the k = 0 wave. Furthermore, the group velocity is zero for all k. On the other grids, waves with kDelta = pi can behave like pure intertial oscillations or stationary waves, which is bad.","category":"page"},{"location":"manual/staggered_grid/#","page":"Staggered grid","title":"Staggered grid","text":"The B and C-grids are less oscillatory than the others and quite faithfully simulate geostrophic adjustment. However, the C-grid is the only one that faithfully reproduces the two-dimensional dispersion relation omega^2(k ell), all the other grids have false maxima, and so \\citet{Arakawa77} conclude that the C-grid is best for simulating geostrophic adjustment except for abnormal situations in which lambdaDelta is less than or close to 1. This seems to have held true for most atmospheric and oceanographic simulations as the C-grid is popular and widely used.","category":"page"},{"location":"manual/staggered_grid/#","page":"Staggered grid","title":"Staggered grid","text":"[2]: Apparently also called Poincaré waves, Sverdrup waves, and \\emph{rotational gravity waves} \\citep[\\S13.9]{Kundu15}.","category":"page"},{"location":"verification/lid_driven_cavity/#Lid-driven-cavity-1","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"","category":"section"},{"location":"verification/lid_driven_cavity/#","page":"Lid-driven cavity","title":"Lid-driven cavity","text":"The lid-driven cavity test problem has been used for a long time as a simple verification test for computational fluid dynamics codes. First described by \\citet{Burggraf66}, the fluid is contained in a square cavity with Dirchlet boundary conditions on all four sides. The top wall moves with some velocity U while the other three walls are stationary. The solution reaches a laminar steady-state whose properties can be compared with a huge amount of existing data. The canonical database is given by \\citet{Ghia82} who report detailed information on the velocity fields as well as the streamline and vorticity contours at various Reynolds numbers. More accurate data is reported by \\citet{Botella98}, \\citet{Erturk05}, and \\citet{Bruneau06}.","category":"page"},{"location":"gallery/#Gallery-1","page":"Gallery","title":"Gallery","text":"","category":"section"},{"location":"gallery/#","page":"Gallery","title":"Gallery","text":"Collection of cool movies!","category":"page"},{"location":"gallery/#[Deep-convection](https://www.youtube.com/watch?vkpUrxnKKMjI)-1","page":"Gallery","title":"Deep convection","text":"","category":"section"},{"location":"gallery/#","page":"Gallery","title":"Gallery","text":"An idealized simulation of deep convection in the ocean. The simulation employs a resolution of 256x256x128 volumes in a 2x2x1 km horizontally periodic domain. Heat is sucked out of the ocean surface within a cooling disk of radius 600 m at a rate of 800 W/m² which cools the surface water and making it denser. This cold dense water then sinks into the ocean interior, initiating a convective process that penetrates deep into the ocean.","category":"page"},{"location":"gallery/#","page":"Gallery","title":"Gallery","text":"This deep convection process can happen when a cold storm passes through warmer waters, which happens for example in the Labrador Sea.","category":"page"},{"location":"gallery/#","page":"Gallery","title":"Gallery","text":"The video shows the temperature field and the domain is sliced in half so the convection happening under the cooling disk is clear.","category":"page"},{"location":"gallery/#","page":"Gallery","title":"Gallery","text":"(Image: Watch deep convection in action)","category":"page"},{"location":"gallery/#[Free-convection](https://www.youtube.com/watch?vyq4op9h3xcU)-1","page":"Gallery","title":"Free convection","text":"","category":"section"},{"location":"gallery/#","page":"Gallery","title":"Gallery","text":"An idealized simulation of free convection in the ocean. The simulation employs a resolution of 256x256x256 volumes in a 100x100x100 m horizontally periodic domain. Heat is sucked out of the ocean surface at a rate of 75 W/m² which cools the surface water and making it denser. This cold dense water then sinks into the ocean interior, initiating a convective process that keeps mixing the upper layer of the ocean. This \"mixed layer\" has a relatively constant temperature and keeps deepening as the surface is cooled.","category":"page"},{"location":"gallery/#","page":"Gallery","title":"Gallery","text":"The video shows the temperature field and the domain is sliced in half.","category":"page"},{"location":"gallery/#","page":"Gallery","title":"Gallery","text":"(Image: Watch free convection in action)","category":"page"},{"location":"gallery/#[Winds-blowing-over-the-ocean](https://www.youtube.com/watch?vIRncfbvuiy8)-1","page":"Gallery","title":"Winds blowing over the ocean","text":"","category":"section"},{"location":"gallery/#","page":"Gallery","title":"Gallery","text":"An idealized simulation of a strong wind stress acting on the surface of a stratified ocean. The simulation employs a resolution of 256x256x256 volumes in a 100x100x100 m horizontally periodic domain. A pretty strong wind stress of 0.1 N/m² is applied in the x direction which mechanically mixes the upper layer of the ocean. This leads to a \"mixed layer\" of constant temperature near the surface of the ocean. You can also see the onset of Kelvin-Helmholtz instabilities as the mechanical mixing sets in.","category":"page"},{"location":"gallery/#","page":"Gallery","title":"Gallery","text":"The video shows the temperature field in the top 25 meters and the domain is sliced in half for visualization. The line plots show the horizontally averaged temperature profile (top right), horizontally averaged turbulent kinetic energy (middle right), and the horizontally averaged buoyancy flux (or temperature flux).","category":"page"},{"location":"gallery/#","page":"Gallery","title":"Gallery","text":"(Image: Watch winds blowing over the ocean)","category":"page"},{"location":"gallery/#[Free-convection-with-wind-stress](https://www.youtube.com/watch?vob6OMQgPfI4)-1","page":"Gallery","title":"Free convection with wind stress","text":"","category":"section"},{"location":"gallery/#","page":"Gallery","title":"Gallery","text":"An idealized simulation of a strong wind stress acting on the surface of a stratified ocean along with a cooling flux that sucks heat out of the surface. The simulation employs a resolution of 256x256x256 volumes in a 100x100x100 m horizontally periodic domain. A pretty strong wind stress of 0.1 N/m² is applied in the x direction which mechanically mixes the upper layer of the ocean. Also, heat is sucked out of the ocean surface at a rate of 75 W/m² which cools the surface water and making it denser. This cold dense water then sinks into the ocean interior, initiating a convective process that keeps mixing the upper layer of the ocean. This leads to a \"mixed layer\" of constant temperature near the surface of the ocean. You can also see the onset of Kelvin-Helmholtz instabilities as the mechanical mixing sets in.","category":"page"},{"location":"gallery/#","page":"Gallery","title":"Gallery","text":"The video shows the temperature field and the domain is sliced in half for visualization. The line plots show the horizontally averaged temperature profile (top right), horizontally averaged turbulent kinetic energy (middle right), and the horizontally averaged buoyancy flux (or temperature flux). The unusual periodic prism colormap is used to show the fine details at the surface as it cools and the layers of different temperatures (the isopycnals) being perturbed by internal waves.","category":"page"},{"location":"gallery/#","page":"Gallery","title":"Gallery","text":"(Image: Watch free convection with wind stress in action)","category":"page"},{"location":"manual/boundary_conditions/#Boundary-conditions-1","page":"Boundary conditions","title":"Boundary conditions","text":"","category":"section"},{"location":"manual/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"In finite volume methods, boundary conditions are imposed weakly by adding viscous or diffusive fluxes into grid cells adjacent to the boundary which have the effect of imposing the desired boundary condition.","category":"page"},{"location":"manual/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"Without loss of generality we will consider how to impose boundary conditions in the y-direction assuming it is wall-bounded. The viscous or diffusive fluxes for a variable c show up in the evolution equation as","category":"page"},{"location":"manual/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"    partial_t c = - partial_y (Gamma partial_y c)","category":"page"},{"location":"manual/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"where the flux is given by Gamma partial_y c and Gamma may represent the kinematic viscosity if c is a velocity, or a diffusivity if c is a tracer.","category":"page"},{"location":"manual/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"Upon discretizing the right-hand-side of \\eqref{eq:flux-tendency} at grid cell j we get","category":"page"},{"location":"manual/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"    partial_y (Gamma partial_y c)_j = fracGamma_j (partial_y c)_j - Gamma_j-1 (partial_y c)_j-1Delta y","category":"page"},{"location":"manual/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"but by default, we assume there are no fluxes at the walls so that at the first grid cell we get","category":"page"},{"location":"manual/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"    partial_y (Gamma partial_y c)_1 = fracGamma_1 (partial_y c)_1Delta y - f_w","category":"page"},{"location":"manual/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"where f_w is the flux at the wall, assumed to be f_w = 0 by default.","category":"page"},{"location":"manual/boundary_conditions/#Flux-boundary-conditions-1","page":"Boundary conditions","title":"Flux boundary conditions","text":"","category":"section"},{"location":"manual/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"Suppose we would like to impose a flux at the wall, then this is simply done by setting f_w to be non-zero.","category":"page"},{"location":"manual/boundary_conditions/#Neumann-boundary-conditions-1","page":"Boundary conditions","title":"Neumann boundary conditions","text":"","category":"section"},{"location":"manual/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"Suppose we want to set the gradient partial cpartial y at the wall, which we will denote G = (partial_y c)_w. Then in effect we would like to impose Gamma_w (partial_y c)_w. This can be done by setting f_w = Gamma G  Delta y. An unfortunate consequence of this is that Gamma_w is undefined and left as a modeling choice. This is not a problem unless Gamma varies, such as when using an LES closure.","category":"page"},{"location":"manual/boundary_conditions/#Dirchlet-boundary-conditions-1","page":"Boundary conditions","title":"Dirchlet boundary conditions","text":"","category":"section"},{"location":"manual/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"Suppose we want to set c to be some value V at the wall. Then this can be accomplished by discretizing","category":"page"},{"location":"manual/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"    (partial_y c)_w = fracc_1 - VDelta y  2 quad implies quad f_w = frac2Gamma_wDelta y^2 (V - c_1)","category":"page"},{"location":"manual/boundary_conditions/#","page":"Boundary conditions","title":"Boundary conditions","text":"where we divide by Delta y  2 because that is the distance between the center of the first grid cell and the wall. This can be interpreted as adding a relaxation term to the evolution equation with a very short relaxation timescale of Delta y^2  Gamma_w. Again, Gamma_w is undefined at the wall.","category":"page"},{"location":"generated/simple_diffusion/#","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"EditURL = \"https://github.com/climate-machine/Oceananigans.jl/blob/master/examples/simple_diffusion.jl\"","category":"page"},{"location":"generated/simple_diffusion/#Simple-diffusion-example-1","page":"One-dimensional diffusion","title":"Simple diffusion example","text":"","category":"section"},{"location":"generated/simple_diffusion/#","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"This script provides our simplest example of Oceananigans.jl functionality: the diffusion of a one-dimensional Gaussian. This example demonstrates","category":"page"},{"location":"generated/simple_diffusion/#","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"how to load Oceananigans.jl;\nhow to instantiate an Oceananigans.jl Model;\nhow to set an initial condition with a function;\nhow to time-step a model forward, and finally\nhow to look at results.","category":"page"},{"location":"generated/simple_diffusion/#Using-Oceananigans.jl-1","page":"One-dimensional diffusion","title":"Using Oceananigans.jl","text":"","category":"section"},{"location":"generated/simple_diffusion/#","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"To use Oceananigans.jl after it has been installed, we bring Oceananigans.jl functions and names into our 'namespace' by writing","category":"page"},{"location":"generated/simple_diffusion/#","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"using Oceananigans","category":"page"},{"location":"generated/simple_diffusion/#","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"We also use PyPlot.jl for plotting and Printf to format plot legends:","category":"page"},{"location":"generated/simple_diffusion/#","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"using PyPlot, Printf","category":"page"},{"location":"generated/simple_diffusion/#Instantiating-and-configuring-a-Model-1","page":"One-dimensional diffusion","title":"Instantiating and configuring a Model","text":"","category":"section"},{"location":"generated/simple_diffusion/#","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"To begin using Oceananigans, we instantiate a Model by calling the Model constructor:","category":"page"},{"location":"generated/simple_diffusion/#","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"model = Model(\n    grid = RegularCartesianGrid(N = (1, 1, 128), L = (1, 1, 1)),\n    closure = ConstantIsotropicDiffusivity(κ = 1.0)\n)","category":"page"},{"location":"generated/simple_diffusion/#","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"The keyword arguments grid and closure indicate that our model grid is Cartesian with uniform grid spacing, that our diffusive stress and tracer fluxes are determined by diffusion with a constant diffusivity κ (note that we do not use viscosity in this example).","category":"page"},{"location":"generated/simple_diffusion/#","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Note that by default, a Model has no-flux boundary condition on all variables. Next, we set an initial condition on our \"passive tracer\", temperature. Our objective is to observe the diffusion of a Gaussian.","category":"page"},{"location":"generated/simple_diffusion/#","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"# Build a Gaussian initial condition function with width `δ`:\nδ = 0.1\nTᵢ(x, y, z) = exp( -(z + 0.5)^2 / (2δ^2) )\n\n# Set `model.tracers.T` to the function `Tᵢ`:\nset!(model, T=Tᵢ)","category":"page"},{"location":"generated/simple_diffusion/#Running-your-first-Model-1","page":"One-dimensional diffusion","title":"Running your first Model","text":"","category":"section"},{"location":"generated/simple_diffusion/#","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Finally, we time-step the model forward using the function time_step!, with a time-step size that ensures numerical stability.","category":"page"},{"location":"generated/simple_diffusion/#","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"# Time-scale for diffusion across a grid cell\ncell_diffusion_time_scale = model.grid.Δz^2 / model.closure.κ.T\n\n# The function `time_step!` executes `Nt` time steps with step size `Δt`\n# using a second-order Adams-Bashforth method\ntime_step!(model, Nt = 1000, Δt = 0.1 * cell_diffusion_time_scale)","category":"page"},{"location":"generated/simple_diffusion/#Visualizing-the-results-1","page":"One-dimensional diffusion","title":"Visualizing the results","text":"","category":"section"},{"location":"generated/simple_diffusion/#","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"We use PyPlot.jl to look at the results.","category":"page"},{"location":"generated/simple_diffusion/#","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"# A convenient function for generating a label with the Current model time\ntracer_label(model) = @sprintf(\"\\$ t=%.3f \\$\", model.clock.time)\n\n# Create a figure with `PyPlot.jl`\nclose(\"all\")\nfig, ax = subplots()\ntitle(\"Diffusion of a Gaussian\")\nxlabel(\"Tracer concentration\")\nylabel(L\"z\")\n\n# Plot initial condition\nplot(Tᵢ.(0, 0, model.grid.zC), model.grid.zC, \"--\", label=L\"t=0\")\n\n# Plot current solution\nplot(data(model.tracers.T)[1, 1, :], model.grid.zC, label=tracer_label(model))\nlegend()\ngcf()","category":"page"},{"location":"generated/simple_diffusion/#","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"Interesting! Running the model even longer makes even more interesting results.","category":"page"},{"location":"generated/simple_diffusion/#","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"for i = 1:3\n    time_step!(model, Nt = 1000, Δt = 0.1 * cell_diffusion_time_scale)\n    plot(data(model.tracers.T)[1, 1, :], model.grid.zC, label=tracer_label(model))\nend\n\nlegend()\ngcf()","category":"page"},{"location":"generated/simple_diffusion/#","page":"One-dimensional diffusion","title":"One-dimensional diffusion","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/fractional_step/#Fractional-step-method-1","page":"Fractional step method","title":"Fractional step method","text":"","category":"section"},{"location":"manual/fractional_step/#","page":"Fractional step method","title":"Fractional step method","text":"Solving the momentum equation \\eqref{eq:momentumFV} coupled with the continuity equation \\eqref{eq:continuityFV} can be cumbersome so instead we employ a fractional step method. To approximate the solution of the coupled system we first solve an approximation to the discretized momentum equation \\eqref{eq:momentumFV} for an intermediate velocity field bmu^star without worrying about satisfying the incompressibility constraint. We then project bmu^star onto the space of divergence-free velocity fields to obtain a value for bmu^n+1 that satisfies \\eqref{eq:continuityFV}.","category":"page"},{"location":"manual/fractional_step/#","page":"Fractional step method","title":"Fractional step method","text":"We thus discretize the momentum equation as","category":"page"},{"location":"manual/fractional_step/#","page":"Fractional step method","title":"Fractional step method","text":"renewcommanddiv1 nabla cdotp left ( 1 right )\nfracbmu^star - bmu^nDelta t\n  = - left bmu cdot nablabmu right^n+frac12\n  - 2bmOmegatimesbmu^n+frac12\n  + divnunablabmu^n+frac12\n  + bmF^n+frac12","category":"page"},{"location":"manual/fractional_step/#","page":"Fractional step method","title":"Fractional step method","text":"where the superscript n + frac12 indicates that these terms are evaluated at time step n + frac12, which we compute explicitly (see \\S\\ref{sec:time-stepping}).","category":"page"},{"location":"manual/fractional_step/#","page":"Fractional step method","title":"Fractional step method","text":"The projection is then performed","category":"page"},{"location":"manual/fractional_step/#","page":"Fractional step method","title":"Fractional step method","text":"   bmu^n+1 = bmu^star - Delta t nabla phi^n+1","category":"page"},{"location":"manual/fractional_step/#","page":"Fractional step method","title":"Fractional step method","text":"to obtain a divergence-free velocity field bmu^n+1. Here the projection is performed by solving an elliptic problem for the pressure phi^n+1 with the boundary condition","category":"page"},{"location":"manual/fractional_step/#","page":"Fractional step method","title":"Fractional step method","text":"newcommanduvec1boldsymbolhattextbf1\n  bmhatn cdotp nablaphi^n+1 _partialOmega = 0","category":"page"},{"location":"manual/fractional_step/#","page":"Fractional step method","title":"Fractional step method","text":"\\citet{Orszag86} and \\citet{Brown01} raise an important issue regarding these fractional step methods, which is that \"while the velocity can be reliably computed to second-order accuracy in time and space, the pressure is typically only first-order accurate in the L_infty-norm.\" The numerical boundary conditions must be carefully accounted for to ensure the second-order accuracy promised by the fractional step methods.","category":"page"},{"location":"manual/fractional_step/#","page":"Fractional step method","title":"Fractional step method","text":"We are currently investigating whether our projection method is indeed second-order accurate in both velocity and pressure (see \\S\\ref{sec:forced-flow}). However, it may not matter too much for simulating high Reynolds number geophysical fluids as \\citet{Brown01} conclude that \"Quite often, semi-implicit projection methods are applied to problems in which the viscosity is small. Since the predicted first-order errors in the pressure are scaled by nu, it is not clear whether the improved pressure-update formula is beneficial in such situations. ... Finally, in some applications of projection methods, second-order accuracy in the pressure may not be relevant or in some cases even possible due to the treatment of other terms in the equations.\"","category":"page"},{"location":"#Oceananigans.jl-1","page":"Home","title":"Oceananigans.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A fast and friendly incompressible fluid flow solver in Julia that can be run in 1-3 dimensions on CPUs and GPUs.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Oceananigans.jl is a fast and friendly incompressible fluid flow solver written in Julia that can be run in 1-3 dimensions on CPUs and GPUs. It is designed to solve the rotating Boussinesq equations used in non-hydrostatic ocean modeling but can be used to solve for any incompressible flow.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Our goal is to develop a friendly and intuitive package allowing users to focus on the science. Thanks to high-level, zero-cost abstractions that the Julia programming language makes possible, the model can have the same look and feel no matter the dimension or grid of the underlying simulation, and the same code is shared between the CPU and GPU.","category":"page"},{"location":"#Installation-instructions-1","page":"Home","title":"Installation instructions","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"You can install the latest version of Oceananigans using the built-in package manager (accessed by pressing ] in the Julia command prompt) to add the package and instantiate/build all depdendencies","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia>]\n(v1.1) pkg> add Oceananigans\n(v1.1) pkg> instantiate","category":"page"},{"location":"#","page":"Home","title":"Home","text":"We recommend installing Oceananigans with the built-in Julia package manager, because this installs a stable, tagged release. Oceananigans.jl can be updated to the latest tagged release from the package manager by typing","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(v1.1) pkg> update Oceananigans","category":"page"},{"location":"#","page":"Home","title":"Home","text":"At this time, updating should be done with care, as Oceananigans is under rapid development and breaking changes to the user API occur often. But if anything does happen, please open an issue!","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Note: Oceananigans requires at least Julia v1.1 to run correctly.","category":"page"},{"location":"#Getting-help-1","page":"Home","title":"Getting help","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"If you are interested in using Oceananigans.jl or are trying to figure out how to use it, please feel free to ask us questions and get in touch! Check out the examples and open an issue if you have any questions, comments, suggestions, etc.","category":"page"},{"location":"manual/large_eddy_simulation/#Large-eddy-simulation-1","page":"Large eddy simulation","title":"Large eddy simulation","text":"","category":"section"},{"location":"manual/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"The idea behind large eddy simulation (LES) is to resolve the \"large eddies\" while modeling the effect of unresolved sub-grid scale motions. This is done usually be assuming eddy viscosity and eddy diffusivity models and providing an estimate for the eddy viscosity nu_e and diffusivity kappa_e.","category":"page"},{"location":"manual/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"Much of the early work on LES was motivated by the study of atmospheric boundary layer turbulence, being developed by \\citet{Smagorinsky63} and \\citet{Lilly66}, then first implemented by \\citet{Deardorff70,Deardorff74}.","category":"page"},{"location":"manual/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"In the LES framework, the Navier-Stokes equations are averaged in the same way as \\citet{Reynolds1895} except that the mean field overlinebmu is obtained via convolution with a filter convolution kernel~G","category":"page"},{"location":"manual/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"overlinebmu(bmx t) = G star bmu =\n  int_-infty^infty int_-infty^infty\n  bmu(bmx^prime t) G(bmx - bmx^prime t - tau)  dbmx^prime  dtau","category":"page"},{"location":"manual/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"as described by \\citet{Leonard75} who introduced the general filtering formalism.","category":"page"},{"location":"manual/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"The overlineu_i^prime u_j^prime terms are now components of what is called the sub-grid scale (SGS) stress tensor tau^textSGS_ij, which looks the same as the Reynolds stress tensor so we will drop the SGS superscript.","category":"page"},{"location":"manual/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"It is probably important to note that the large eddy simulation filtering operation does not satisfy the properties of a Reynolds operator \\citep[\\S 2.1]{sagaut06} and that in general, the filtered residual is not zero: overlinebmu^prime(bmx t) ne 0.","category":"page"},{"location":"manual/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"\\citet[\\S13.2]{Pope00} lists a number of popular choices for the filter function G. For practical reasons we simply employ the box kernel","category":"page"},{"location":"manual/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"  G_Delta = G(bmx t) = frac1Delta H left( frac12Delta - bmx right) delta(t - t_n)","category":"page"},{"location":"manual/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"where H is the Heaviside function, Delta is the grid spacing, and t_n is the current time step. With \\eqref{eq:box-kernel} we get back the averaging operator originally used by \\citet{Deardorff70}","category":"page"},{"location":"manual/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"overlinebmu(x y z t) =\n  frac1Delta x Delta y Delta z\n  int_x - frac12Delta x^x + frac12Delta x\n  int_y - frac12Delta y^y + frac12Delta y\n  int_z - frac12Delta z^z + frac12Delta z\n  bmu(xi eta zeta t)  dxi  deta  dzeta","category":"page"},{"location":"manual/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"which if evaluated at the cell centers just returns the cell averages we already compute in the finite volume method.","category":"page"},{"location":"manual/large_eddy_simulation/#Smagorinsky-Lilly-model-1","page":"Large eddy simulation","title":"Smagorinsky-Lilly model","text":"","category":"section"},{"location":"manual/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"\\citet{Smagorinsky63} estimated the eddy viscosity nu_e via a characteristic length scale Delta times a velocity scale given by Delta overlineS where overlineS = sqrt2overlineS_ijoverlineS_ij. Thus the SGS stress tensor is given by","category":"page"},{"location":"manual/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"tau_ij = -2nu_e overlineS_ij = -2 (C_s Delta)^2 overlineS overlineS_ij","category":"page"},{"location":"manual/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"where C_s is a dimensionless constant. The grid spacing is usually used for the characteristic length scale Delta. The eddy diffusivities are calculated via kappa_e = nu_e  textPr_t where the turbulent Prandtl number textPr_t is usually chosen to be mathcalO(1) from experimental observations.","category":"page"},{"location":"manual/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"Assuming that the SGS energy cascade is equal to the overall dissipation rate varepsilon from the \\citet{Kolmogorov41} theory, \\citet{Lilly66} was able to derive a value of","category":"page"},{"location":"manual/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"C_s = left( frac32C_Kpi^frac43 right)^-frac34 approx 016","category":"page"},{"location":"manual/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"using an empirical value of C_K approx 16 for the Kolmogorov constant. This seems reasonable for isotropic turbulence if the grid spacing Delta falls in the intertial range. In practice, C_s is a tunable parameter.","category":"page"},{"location":"manual/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"Due to the presence of the constant C_s, the model is sometimes referred to as the \\emph{constant Smagorinsky} model in contrast to \\emph{dynamic Smagorinsky} models that dynamically compute C_s to account for effects such as buoyant convection.","category":"page"},{"location":"manual/large_eddy_simulation/#Anisotropic-minimum-dissipation-models-1","page":"Large eddy simulation","title":"Anisotropic minimum dissipation models","text":"","category":"section"},{"location":"manual/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"Minimum-dissipation eddy-viscosity models are a class of LES closures that use the minimum eddy dissipation required to dissipate the energy of sub-grid scale motion. \\citet{Rozema15} proposed the first minimum-dissipation model appropriate for use on anisotropic grids, termed the \\emph{anisotropic minimum dissipation} (AMD) model.","category":"page"},{"location":"manual/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"It has a number of desirable properties over Smagorinsky-type closures: it is more cost-effective than dynamic Smagorinsky, it appropriately switches off in laminar and transitional flows, and it is consistent with the exact SGS stress tensor on both isotropic and anisotropic grids. \\citet{Abkar16} extended the AMD model to model SGS scalar fluxes for tracer transport. \\citet{Abkar17} further extended the model to include a buoyancy term that accounts for the contribution of buoyant forces to the production and suppression of turbulence.","category":"page"},{"location":"manual/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"\\citet{Vreugdenhil18} derive a modified AMD model by following the requirement suggested by \\citet{Verstappen18}, which entail normalising the displacement, the velocity, and the velocity gradient by the filter width to ensure that the resulting eddy dissipation properly counteracts the spurious kinetic energy transferred by convective nonlinearity, to derive a modified AMD model.","category":"page"},{"location":"manual/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"The eddy viscosity and diffusivity are defined in terms of eddy viscosity and diffusivity \\emph{predictors} nu_e^dagger and kappa_e^dagger, such that","category":"page"},{"location":"manual/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"nu_e = textmax lbrace 0 nu_e^dagger rbrace\nquad textand quad\nkappa_e = textmax lbrace 0 kappa_e^dagger rbrace","category":"page"},{"location":"manual/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"to ensure that nu_e ge 0 and kappa_e ge 0. Leaving out the overlines and understanding that all variables represent the resolved/filtered variables, the eddy viscosity predictor is given by","category":"page"},{"location":"manual/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"nu_e^dagger = -(CDelta)^2\n  frac\n    left( hatpartial_k hatu_i right) left( hatpartial_k hatu_j right) hatS_ij\n    + C_bhatdelta_i3 alpha g left( hatpartial_k hatu_i right) hatpartial_k theta\n    left( hatpartial_l hatu_m right) left( hatpartial_l hatu_m right)","category":"page"},{"location":"manual/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"and the eddy diffusivity predictor by","category":"page"},{"location":"manual/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"kappa_e^dagger = -(CDelta)^2\nfrac\n    left( hatpartial_k hatu_i right) left( hatpartial_k hattheta right) hatpartial_i theta\n    left( hatpartial_l hattheta right) left( hatpartial_l hattheta right)","category":"page"},{"location":"manual/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"where","category":"page"},{"location":"manual/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"  hatx_i = fracx_iDelta_i quad\n  hatu_i(hatx t) = fracu_i(x t)Delta_i quad\n  hatpartial_i hatu_j(hatx t) = fracDelta_iDelta_j partial_i u_j(x t) quad\n  hatdelta_i3 = fracdelta_i3Delta 3","category":"page"},{"location":"manual/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"so that the normalized rate of strain tensor is","category":"page"},{"location":"manual/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"hatS_ij =\n  frac12 left hatpartial_i hatu_j(hatx t) + hatpartial_j hatu_i(hatx t) right","category":"page"},{"location":"manual/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"In equations \\eqref{eq:nu-dagger}–\\eqref{eq:S-hat} C is a modified Poincaré \"constant\" that is independent from the filter width Delta but does depend on the accuracy of the discretization method used. \\citet{Abkar16} cite C^2 = frac112 for a spectral method and C^2 = frac13 for a second-order accurate scheme. Delta_i is the filter width in the x_i-direction, and Delta is given by the square root of the harmonic mean of the squares of the filter widths in each direction","category":"page"},{"location":"manual/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"    frac1Delta^2 = frac13 left( frac1Delta x^2 + frac1Delta y^2 + frac1Delta z^2 right)","category":"page"},{"location":"manual/large_eddy_simulation/#","page":"Large eddy simulation","title":"Large eddy simulation","text":"The term multiplying C_b is the buoyancy modification introduced by \\citet{Abkar17} and is small for weakly stratified flows. We have introduced the C_b constant so that the buoyancy modification term may be turned on and off.","category":"page"}]
}

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library Â· Oceananigans.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://clima.github.io/OceananigansDocumentation/stable/appendix/library/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Oceananigans.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../installation_instructions/">Installation instructions</a></li><li><a class="tocitem" href="../../using_gpus/">Using GPUs</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/one_dimensional_diffusion/">One-dimensional diffusion</a></li><li><a class="tocitem" href="../../generated/geostrophic_adjustment/">Geostrophic adjustment</a></li><li><a class="tocitem" href="../../generated/two_dimensional_turbulence/">Two-dimensional turbulence</a></li><li><a class="tocitem" href="../../generated/internal_wave/">Internal wave</a></li><li><a class="tocitem" href="../../generated/convecting_plankton/">Convecting plankton</a></li><li><a class="tocitem" href="../../generated/ocean_wind_mixing_and_convection/">Ocean wind mixing and convection</a></li><li><a class="tocitem" href="../../generated/langmuir_turbulence/">Langmuir turbulence</a></li><li><a class="tocitem" href="../../generated/eady_turbulence/">Eady turbulence</a></li><li><a class="tocitem" href="../../generated/kelvin_helmholtz_instability/">Kelvin-Helmholtz instability</a></li><li><a class="tocitem" href="../../generated/shallow_water_Bickley_jet/">Shallow water Bickley jet</a></li><li><a class="tocitem" href="../../generated/horizontal_convection/">Horizontal convection</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Physics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../physics/notation/">Coordinate system and notation</a></li><li><a class="tocitem" href="../../physics/boussinesq/">Boussinesq approximation</a></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label"><code>NonhydrostaticModel</code></span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../physics/nonhydrostatic_model/">Nonhydrostatic model</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-4" type="checkbox"/><label class="tocitem" for="menuitem-5-4"><span class="docs-label"><code>HydrostaticFreeSurfaceModel</code></span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../physics/hydrostatic_free_surface_model/">Hydrostatic model with a free surface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-5" type="checkbox"/><label class="tocitem" for="menuitem-5-5"><span class="docs-label"><code>ShallowWaterModel</code></span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../physics/shallow_water_model/">Shallow water model</a></li></ul></li><li><a class="tocitem" href="../../physics/buoyancy_and_equations_of_state/">Buoyancy models and equations of state</a></li><li><a class="tocitem" href="../../physics/coriolis_forces/">Coriolis forces</a></li><li><a class="tocitem" href="../../physics/turbulence_closures/">Turbulence closures</a></li><li><a class="tocitem" href="../../physics/surface_gravity_waves/">Surface gravity waves and the Craik-Leibovich approximation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Numerical implementation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../numerical_implementation/finite_volume/">Finite volume method</a></li><li><a class="tocitem" href="../../numerical_implementation/spatial_operators/">Spatial operators</a></li><li><a class="tocitem" href="../../numerical_implementation/pressure_decomposition/">Pressure decomposition</a></li><li><a class="tocitem" href="../../numerical_implementation/time_stepping/">Time stepping</a></li><li><a class="tocitem" href="../../numerical_implementation/boundary_conditions/">Boundary conditions</a></li><li><a class="tocitem" href="../../numerical_implementation/poisson_solvers/">Poisson solvers</a></li><li><a class="tocitem" href="../../numerical_implementation/large_eddy_simulation/">Large eddy simulation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Model setup</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_setup/overview/">Overview</a></li><li><a class="tocitem" href="../../model_setup/architecture/">Architecture</a></li><li><a class="tocitem" href="../../model_setup/number_type/">Number type</a></li><li><a class="tocitem" href="../../model_setup/grids/">Grid</a></li><li><a class="tocitem" href="../../model_setup/clock/">Clock</a></li><li><a class="tocitem" href="../../model_setup/coriolis/">Coriolis (rotation)</a></li><li><a class="tocitem" href="../../model_setup/tracers/">Tracers</a></li><li><a class="tocitem" href="../../model_setup/buoyancy_and_equation_of_state/">Buoyancy models and equation of state</a></li><li><a class="tocitem" href="../../model_setup/boundary_conditions/">Boundary conditions</a></li><li><a class="tocitem" href="../../model_setup/forcing_functions/">Forcing functions</a></li><li><a class="tocitem" href="../../model_setup/background_fields/">Background fields</a></li><li><a class="tocitem" href="../../model_setup/turbulent_diffusivity_closures_and_les_models/">Turbulent diffusivity closures and LES models</a></li><li><a class="tocitem" href="../../model_setup/lagrangian_particles/">Lagrangian particles</a></li><li><a class="tocitem" href="../../model_setup/diagnostics/">Diagnostics</a></li><li><a class="tocitem" href="../../model_setup/output_writers/">Output writers</a></li><li><a class="tocitem" href="../../model_setup/checkpointing/">Checkpointing</a></li><li><a class="tocitem" href="../../model_setup/setting_initial_conditions/">Setting initial conditions</a></li></ul></li><li><a class="tocitem" href="../../simulation_tips/">Simulation tips</a></li><li><a class="tocitem" href="../../contributing/">Contributor&#39;s guide</a></li><li><a class="tocitem" href="../../gallery/">Gallery</a></li><li><a class="tocitem" href="../../references/">References</a></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox" checked/><label class="tocitem" for="menuitem-12"><span class="docs-label">Appendix</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../staggered_grid/">Staggered grid</a></li><li><a class="tocitem" href="../fractional_step/">Fractional step method</a></li><li><a class="tocitem" href="../convergence_tests/">Convergence tests</a></li><li><a class="tocitem" href="../benchmarks/">Performance benchmarks</a></li><li class="is-active"><a class="tocitem" href>Library</a><ul class="internal"><li><a class="tocitem" href="#Oceananigans.jl"><span>Oceananigans.jl</span></a></li><li><a class="tocitem" href="#Abstract-operations"><span>Abstract operations</span></a></li><li><a class="tocitem" href="#Advection"><span>Advection</span></a></li><li><a class="tocitem" href="#Architectures"><span>Architectures</span></a></li><li><a class="tocitem" href="#Boundary-conditions"><span>Boundary conditions</span></a></li><li><a class="tocitem" href="#BuoyancyModels"><span>BuoyancyModels</span></a></li><li><a class="tocitem" href="#Coriolis"><span>Coriolis</span></a></li><li><a class="tocitem" href="#Diagnostics"><span>Diagnostics</span></a></li><li><a class="tocitem" href="#Fields"><span>Fields</span></a></li><li><a class="tocitem" href="#Forcings"><span>Forcings</span></a></li><li><a class="tocitem" href="#Grids"><span>Grids</span></a></li><li><a class="tocitem" href="#Immersed-boundaries"><span>Immersed boundaries</span></a></li><li><a class="tocitem" href="#Lagrangian-particle-tracking"><span>Lagrangian particle tracking</span></a></li><li><a class="tocitem" href="#Logger"><span>Logger</span></a></li><li><a class="tocitem" href="#Models"><span>Models</span></a></li><li><a class="tocitem" href="#Output-readers"><span>Output readers</span></a></li><li><a class="tocitem" href="#Output-writers"><span>Output writers</span></a></li><li><a class="tocitem" href="#Simulations"><span>Simulations</span></a></li><li><a class="tocitem" href="#Stokes-drift"><span>Stokes drift</span></a></li><li><a class="tocitem" href="#Time-steppers"><span>Time steppers</span></a></li><li><a class="tocitem" href="#Turbulence-closures"><span>Turbulence closures</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li></ul></li><li><a class="tocitem" href="../function_index/">Function index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Appendix</a></li><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/CliMA/Oceananigans.jl/blob/master/docs/src/appendix/library.md" title="Edit on GitHub"><span class="docs-icon fab">ï‚›</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><p>Documenting the public user interface.</p><h2 id="Oceananigans.jl"><a class="docs-heading-anchor" href="#Oceananigans.jl">Oceananigans.jl</a><a id="Oceananigans.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Oceananigans.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Oceananigans" href="#Oceananigans.Oceananigans"><code>Oceananigans.Oceananigans</code></a> â€” <span class="docstring-category">Module</span></header><section><div><p>Main module for <code>Oceananigans.jl</code> â€“ a Julia software for fast, friendly, flexible, data-driven, ocean-flavored fluid dynamics on CPUs and GPUs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Oceananigans.jl#L1-L4">source</a></section></article><h2 id="Abstract-operations"><a class="docs-heading-anchor" href="#Abstract-operations">Abstract operations</a><a id="Abstract-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-operations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.KernelFunctionOperation-Union{Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Any, Any}} where {LX, LY, LZ}" href="#Oceananigans.AbstractOperations.KernelFunctionOperation-Union{Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Any, Any}} where {LX, LY, LZ}"><code>Oceananigans.AbstractOperations.KernelFunctionOperation</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">KernelFunctionOperation{LX, LY, LZ}(kernel_function, grid; architecture=nothing,
                                    computed_dependencies=(), parameters=nothing)</code></pre><p>Constructs a <code>KernelFunctionOperation</code> at location <code>(LX, LY, LZ)</code> on <code>grid</code> an with an optional iterable of <code>computed_dependencies</code> and arbitrary <code>parameters</code>.</p><p>With <code>isnothing(parameters)</code> (the default), <code>kernel_function</code> is called with</p><pre><code class="language-julia hljs">kernel_function(i, j, k, grid, computed_dependencies...)</code></pre><p>Otherwise <code>kernel_function</code> is called with</p><pre><code class="language-julia hljs">kernel_function(i, j, k, grid, computed_dependencies..., parameters)</code></pre><p><strong>Examples</strong></p><p>Construct a kernel function operation that returns random numbers:</p><pre><code class="language-julia hljs">random_kernel_function(i, j, k, grid) = rand() # use CUDA.rand on the GPU

kernel_op = KernelFunctionOperation{Center, Center, Center}(random_kernel_function, grid; architecture=CPU())</code></pre><p>Construct a kernel function operation using the vertical vorticity operator valid on curvilinear and cubed sphere grids:</p><pre><code class="language-julia hljs">using Oceananigans.Operators: Î¶â‚ƒá¶ á¶ áµƒ # called with signature Î¶â‚ƒá¶ á¶ áµƒ(i, j, k, grid, u, v)

grid = model.grid
u, v, w = model.velocities

Î¶_op = KernelFunctionOperation{Face, Face, Center}(Î¶â‚ƒá¶ á¶ áµƒ, grid, computed_dependencies=(u, v))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/AbstractOperations/kernel_function_operation.jl#L17-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.âˆ‚x-Tuple{Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}}" href="#Oceananigans.AbstractOperations.âˆ‚x-Tuple{Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}}"><code>Oceananigans.AbstractOperations.âˆ‚x</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Return the x-derivative function acting at (<code>X</code>, <code>Y</code>, <code>Any</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/AbstractOperations/derivatives.jl#L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.âˆ‚x-Union{Tuple{Oceananigans.Fields.AbstractField{X, Y, Z, A, G, T, N} where {A&lt;:Union{Nothing, Oceananigans.Architectures.AbstractArchitecture}, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}, Tuple{Z}, Tuple{Y}, Tuple{X}} where {X, Y, Z}" href="#Oceananigans.AbstractOperations.âˆ‚x-Union{Tuple{Oceananigans.Fields.AbstractField{X, Y, Z, A, G, T, N} where {A&lt;:Union{Nothing, Oceananigans.Architectures.AbstractArchitecture}, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}, Tuple{Z}, Tuple{Y}, Tuple{X}} where {X, Y, Z}"><code>Oceananigans.AbstractOperations.âˆ‚x</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">âˆ‚x(a::AbstractField)</code></pre><p>Return an abstract representation of a x-derivative acting on field <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/AbstractOperations/derivatives.jl#L87-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.âˆ‚x-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{Tuple, Oceananigans.Fields.AbstractField{X, Y, Z, A, G, T, N} where {A&lt;:Union{Nothing, Oceananigans.Architectures.AbstractArchitecture}, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}} where {X, Y, Z}" href="#Oceananigans.AbstractOperations.âˆ‚x-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{Tuple, Oceananigans.Fields.AbstractField{X, Y, Z, A, G, T, N} where {A&lt;:Union{Nothing, Oceananigans.Architectures.AbstractArchitecture}, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}} where {X, Y, Z}"><code>Oceananigans.AbstractOperations.âˆ‚x</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">âˆ‚x(L::Tuple, a::AbstractField)</code></pre><p>Return an abstract representation of an x-derivative acting on field <code>a</code> followed by interpolation to <code>L</code>, where <code>L</code> is a 3-tuple of <code>Face</code>s and <code>Center</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/AbstractOperations/derivatives.jl#L59-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.âˆ‚y-Tuple{Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}}" href="#Oceananigans.AbstractOperations.âˆ‚y-Tuple{Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}}"><code>Oceananigans.AbstractOperations.âˆ‚y</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Return the y-derivative function acting at (<code>X</code>, <code>Y</code>, <code>Any</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/AbstractOperations/derivatives.jl#L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.âˆ‚y-Union{Tuple{Oceananigans.Fields.AbstractField{X, Y, Z, A, G, T, N} where {A&lt;:Union{Nothing, Oceananigans.Architectures.AbstractArchitecture}, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}, Tuple{Z}, Tuple{Y}, Tuple{X}} where {X, Y, Z}" href="#Oceananigans.AbstractOperations.âˆ‚y-Union{Tuple{Oceananigans.Fields.AbstractField{X, Y, Z, A, G, T, N} where {A&lt;:Union{Nothing, Oceananigans.Architectures.AbstractArchitecture}, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}, Tuple{Z}, Tuple{Y}, Tuple{X}} where {X, Y, Z}"><code>Oceananigans.AbstractOperations.âˆ‚y</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">âˆ‚y(a::AbstractField)</code></pre><p>Return an abstract representation of a y-derivative acting on field <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/AbstractOperations/derivatives.jl#L94-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.âˆ‚y-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{Tuple, Oceananigans.Fields.AbstractField{X, Y, Z, A, G, T, N} where {A&lt;:Union{Nothing, Oceananigans.Architectures.AbstractArchitecture}, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}} where {X, Y, Z}" href="#Oceananigans.AbstractOperations.âˆ‚y-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{Tuple, Oceananigans.Fields.AbstractField{X, Y, Z, A, G, T, N} where {A&lt;:Union{Nothing, Oceananigans.Architectures.AbstractArchitecture}, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}} where {X, Y, Z}"><code>Oceananigans.AbstractOperations.âˆ‚y</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">âˆ‚y(L::Tuple, a::AbstractField)</code></pre><p>Return an abstract representation of a y-derivative acting on field <code>a</code> followed by interpolation to <code>L</code>, where <code>L</code> is a 3-tuple of <code>Face</code>s and <code>Center</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/AbstractOperations/derivatives.jl#L68-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.âˆ‚z-Tuple{Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}}" href="#Oceananigans.AbstractOperations.âˆ‚z-Tuple{Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}}"><code>Oceananigans.AbstractOperations.âˆ‚z</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Return the z-derivative function acting at (<code>Any</code>, <code>Any</code>, <code>Z</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/AbstractOperations/derivatives.jl#L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.âˆ‚z-Union{Tuple{Oceananigans.Fields.AbstractField{X, Y, Z, A, G, T, N} where {A&lt;:Union{Nothing, Oceananigans.Architectures.AbstractArchitecture}, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}, Tuple{Z}, Tuple{Y}, Tuple{X}} where {X, Y, Z}" href="#Oceananigans.AbstractOperations.âˆ‚z-Union{Tuple{Oceananigans.Fields.AbstractField{X, Y, Z, A, G, T, N} where {A&lt;:Union{Nothing, Oceananigans.Architectures.AbstractArchitecture}, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}, Tuple{Z}, Tuple{Y}, Tuple{X}} where {X, Y, Z}"><code>Oceananigans.AbstractOperations.âˆ‚z</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">âˆ‚z(a::AbstractField)</code></pre><p>Return an abstract representation of a z-derivative acting on field <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/AbstractOperations/derivatives.jl#L100-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.âˆ‚z-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{Tuple, Oceananigans.Fields.AbstractField{X, Y, Z, A, G, T, N} where {A&lt;:Union{Nothing, Oceananigans.Architectures.AbstractArchitecture}, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}} where {X, Y, Z}" href="#Oceananigans.AbstractOperations.âˆ‚z-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{Tuple, Oceananigans.Fields.AbstractField{X, Y, Z, A, G, T, N} where {A&lt;:Union{Nothing, Oceananigans.Architectures.AbstractArchitecture}, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}} where {X, Y, Z}"><code>Oceananigans.AbstractOperations.âˆ‚z</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">âˆ‚z(L::Tuple, a::AbstractField)</code></pre><p>Return an abstract representation of a z-derivative acting on field <code>a</code> followed by  interpolation to <code>L</code>, where <code>L</code> is a 3-tuple of <code>Face</code>s and <code>Center</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/AbstractOperations/derivatives.jl#L77-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.@at-Tuple{Any, Any}" href="#Oceananigans.AbstractOperations.@at-Tuple{Any, Any}"><code>Oceananigans.AbstractOperations.@at</code></a> â€” <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@at location abstract_operation</code></pre><p>Modify the <code>abstract_operation</code> so that it returns values at <code>location</code>, where <code>location</code> is a 3-tuple of <code>Face</code>s and <code>Center</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/AbstractOperations/at.jl#L36-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.@binary-Tuple" href="#Oceananigans.AbstractOperations.@binary-Tuple"><code>Oceananigans.AbstractOperations.@binary</code></a> â€” <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@binary op1 op2 op3...</code></pre><p>Turn each binary function in the list <code>(op1, op2, op3...)</code> into a binary operator on <code>Oceananigans.Fields</code> for use in <code>AbstractOperations</code>.</p><p>Note: a binary function is a function with two arguments: for example, <code>+(x, y)</code> is a binary function.</p><p>Also note: a binary function in <code>Base</code> must be imported to be extended: use <code>import Base: op; @binary op</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans, Oceananigans.AbstractOperations

julia&gt; using Oceananigans.AbstractOperations: BinaryOperation, AbstractGridMetric, choose_location

julia&gt; plus_or_times(x, y) = x &lt; 0 ? x + y : x * y
plus_or_times (generic function with 1 method)

julia&gt; @binary plus_or_times
Set{Any} with 6 elements:
  :+
  :/
  :^
  :-
  :*
  :plus_or_times

julia&gt; c, d = (Field(Center, Center, Center, CPU(), RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))) for i = 1:2);

julia&gt; plus_or_times(c, d)
BinaryOperation at (Center, Center, Center)
â”œâ”€â”€ grid: RectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1)
â”‚   â””â”€â”€ domain: x âˆˆ [0.0, 1.0], y âˆˆ [0.0, 1.0], z âˆˆ [-1.0, 0.0]
â””â”€â”€ tree:
    plus_or_times at (Center, Center, Center)
 Â Â  â”œâ”€â”€ Field located at (Center, Center, Center)
 Â Â  â””â”€â”€ Field located at (Center, Center, Center)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/AbstractOperations/binary_operations.jl#L130-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.@multiary-Tuple" href="#Oceananigans.AbstractOperations.@multiary-Tuple"><code>Oceananigans.AbstractOperations.@multiary</code></a> â€” <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@multiary op1 op2 op3...</code></pre><p>Turn each multiary operator in the list <code>(op1, op2, op3...)</code> into a multiary operator on <code>Oceananigans.Fields</code> for use in <code>AbstractOperations</code>.</p><p>Note that a multiary operator:</p><ul><li>is a function with two or more arguments: for example, <code>+(x, y, z)</code> is a multiary function;</li><li>must be imported to be extended if part of <code>Base</code>: use <code>import Base: op; @multiary op</code>;</li><li>can only be called on <code>Oceananigans.Field</code>s if the &quot;location&quot; is noted explicitly; see example.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans, Oceananigans.AbstractOperations

julia&gt; harmonic_plus(a, b, c) = 1/3 * (1/a + 1/b + 1/c)
harmonic_plus (generic function with 1 method)

julia&gt; c, d, e = Tuple(Field(Center, Center, Center, CPU(), RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))) for i = 1:3);

julia&gt; harmonic_plus(c, d, e) # before magic @multiary transformation
BinaryOperation at (Center, Center, Center)
â”œâ”€â”€ grid: RectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1)
â”‚   â””â”€â”€ domain: x âˆˆ [0.0, 1.0], y âˆˆ [0.0, 1.0], z âˆˆ [-1.0, 0.0]
â””â”€â”€ tree:
    * at (Center, Center, Center)
 Â Â  â”œâ”€â”€ 0.3333333333333333
 Â Â  â””â”€â”€ + at (Center, Center, Center)
 Â Â   Â Â  â”œâ”€â”€ / at (Center, Center, Center)
 Â Â   Â Â  â”‚Â Â  â”œâ”€â”€ 1
 Â Â   Â Â  â”‚Â Â  â””â”€â”€ Field located at (Center, Center, Center)
 Â Â   Â Â  â”œâ”€â”€ / at (Center, Center, Center)
 Â Â   Â Â  â”‚Â Â  â”œâ”€â”€ 1
 Â Â   Â Â  â”‚Â Â  â””â”€â”€ Field located at (Center, Center, Center)
 Â Â   Â Â  â””â”€â”€ / at (Center, Center, Center)
 Â Â   Â Â   Â Â  â”œâ”€â”€ 1
 Â Â   Â Â   Â Â  â””â”€â”€ Field located at (Center, Center, Center)

julia&gt; @multiary harmonic_plus
Set{Any} with 3 elements:
  :+
  :harmonic_plus
  :*

julia&gt; harmonic_plus(c, d, e)
MultiaryOperation at (Center, Center, Center)
â”œâ”€â”€ grid: RectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1)
â”‚   â””â”€â”€ domain: x âˆˆ [0.0, 1.0], y âˆˆ [0.0, 1.0], z âˆˆ [-1.0, 0.0]
â””â”€â”€ tree:
    harmonic_plus at (Center, Center, Center)
 Â Â  â”œâ”€â”€ Field located at (Center, Center, Center)
 Â Â  â”œâ”€â”€ Field located at (Center, Center, Center)
 Â Â  â””â”€â”€ Field located at (Center, Center, Center)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/AbstractOperations/multiary_operations.jl#L59-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.@unary-Tuple" href="#Oceananigans.AbstractOperations.@unary-Tuple"><code>Oceananigans.AbstractOperations.@unary</code></a> â€” <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@unary op1 op2 op3...</code></pre><p>Turn each unary function in the list <code>(op1, op2, op3...)</code> into a unary operator on <code>Oceananigans.Fields</code> for use in <code>AbstractOperations</code>.</p><p>Note: a unary function is a function with one argument: for example, <code>sin(x)</code> is a unary function.</p><p>Also note: a unary function in <code>Base</code> must be imported to be extended: use <code>import Base: op; @unary op</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans, Oceananigans.Grids, Oceananigans.AbstractOperations

julia&gt; square_it(x) = x^2
square_it (generic function with 1 method)

julia&gt; @unary square_it
Set{Any} with 8 elements:
  :sqrt
  :square_it
  :cos
  :exp
  :interpolate_identity
  :-
  :tanh
  :sin

julia&gt; c = Field(Center, Center, Center, CPU(), RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)));

julia&gt; square_it(c)
UnaryOperation at (Center, Center, Center)
â”œâ”€â”€ grid: RectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1)
â”‚   â””â”€â”€ domain: x âˆˆ [0.0, 1.0], y âˆˆ [0.0, 1.0], z âˆˆ [-1.0, 0.0]
â””â”€â”€ tree:
    square_it at (Center, Center, Center) via identity
 Â Â  â””â”€â”€ Field located at (Center, Center, Center)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/AbstractOperations/unary_operations.jl#L39-L79">source</a></section></article><h2 id="Advection"><a class="docs-heading-anchor" href="#Advection">Advection</a><a id="Advection-1"></a><a class="docs-heading-anchor-permalink" href="#Advection" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.CenteredFourthOrder" href="#Oceananigans.Advection.CenteredFourthOrder"><code>Oceananigans.Advection.CenteredFourthOrder</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CenteredFourthOrder &lt;: AbstractCenteredAdvectionScheme{1}</code></pre><p>Centered fourth-order advection scheme.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Advection/centered_fourth_order.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.CenteredSecondOrder" href="#Oceananigans.Advection.CenteredSecondOrder"><code>Oceananigans.Advection.CenteredSecondOrder</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CenteredSecondOrder &lt;: AbstractAdvectionScheme{0}</code></pre><p>Centered second-order advection scheme.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Advection/centered_second_order.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.UpwindBiasedFifthOrder" href="#Oceananigans.Advection.UpwindBiasedFifthOrder"><code>Oceananigans.Advection.UpwindBiasedFifthOrder</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct UpwindBiasedFifthOrder &lt;: AbstractUpwindBiasedAdvectionScheme{2}</code></pre><p>Upwind-biased fifth-order advection scheme.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Advection/upwind_biased_fifth_order.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.UpwindBiasedFirstOrder" href="#Oceananigans.Advection.UpwindBiasedFirstOrder"><code>Oceananigans.Advection.UpwindBiasedFirstOrder</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct UpwindBiasedFirstOrder &lt;: AbstractUpwindBiasedAdvectionScheme{1}</code></pre><p>Upwind-biased first-order advection scheme.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Advection/upwind_biased_first_order.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.UpwindBiasedThirdOrder" href="#Oceananigans.Advection.UpwindBiasedThirdOrder"><code>Oceananigans.Advection.UpwindBiasedThirdOrder</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct UpwindBiasedThirdOrder &lt;: AbstractUpwindBiasedAdvectionScheme{1}</code></pre><p>Upwind-biased third-order advection scheme.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Advection/upwind_biased_third_order.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.WENO5" href="#Oceananigans.Advection.WENO5"><code>Oceananigans.Advection.WENO5</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct WENO5{FT, XT, YT, ZT, XS, YS, ZS, W} &lt;: AbstractUpwindBiasedAdvectionScheme{2}</code></pre><p>Weighted Essentially Non-Oscillatory (WENO) fifth-order advection scheme.</p><ul><li><p><code>coeff_xá¶ áµƒáµƒ::Any</code></p><p>coefficient for ENO reconstruction on x-faces</p></li><li><p><code>coeff_xá¶œáµƒáµƒ::Any</code></p><p>coefficient for ENO reconstruction on x-centers</p></li><li><p><code>coeff_yáµƒá¶ áµƒ::Any</code></p><p>coefficient for ENO reconstruction on y-faces</p></li><li><p><code>coeff_yáµƒá¶œáµƒ::Any</code></p><p>coefficient for ENO reconstruction on y-centers</p></li><li><p><code>coeff_záµƒáµƒá¶ ::Any</code></p><p>coefficient for ENO reconstruction on z-faces</p></li><li><p><code>coeff_záµƒáµƒá¶œ::Any</code></p><p>coefficient for ENO reconstruction on z-centers</p></li><li><p><code>smooth_xá¶ áµƒáµƒ::Any</code></p><p>coefficient for WENO smoothness indicators on x-faces</p></li><li><p><code>smooth_xá¶œáµƒáµƒ::Any</code></p><p>coefficient for WENO smoothness indicators on x-centers</p></li><li><p><code>smooth_yáµƒá¶ áµƒ::Any</code></p><p>coefficient for WENO smoothness indicators on y-faces</p></li><li><p><code>smooth_yáµƒá¶œáµƒ::Any</code></p><p>coefficient for WENO smoothness indicators on y-centers</p></li><li><p><code>smooth_záµƒáµƒá¶ ::Any</code></p><p>coefficient for WENO smoothness indicators on z-faces</p></li><li><p><code>smooth_záµƒáµƒá¶œ::Any</code></p><p>coefficient for WENO smoothness indicators on z-centers</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Advection/weno_fifth_order.jl#L20-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.WENO5" href="#Oceananigans.Advection.WENO5"><code>Oceananigans.Advection.WENO5</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WENO5([FT = Float64;] grid = nothing, stretched_smoothness = false, zweno = false)</code></pre><p>Construct a fifth-order weigthed essentially non-oscillatory advection scheme. The constructor allows construction of WENO schemes on either uniform or stretched grids.</p><p><strong>Keyword arguments</strong></p><ul><li><code>grid</code>: (defaults to <code>nothing</code>)</li><li><code>stretched_smoothness</code>: When <code>true</code> it results in computing the coefficients for the smoothness indicators Î²â‚€, Î²â‚ and Î²â‚‚ so that they account for the stretched <code>grid</code>. (defaults to <code>false</code>)</li><li><code>zweno</code>: When <code>true</code> implement a Z-WENO formulation for the WENO weights calculation. (defaults to <code>false</code>)</li></ul><div class="admonition is-category-warn"><header class="admonition-header">No support for WENO5 on curvilinear grids</header><div class="admonition-body"><p>Currently, WENO 5th-order advection schemes don&#39;t work for for curvilinear grids. Providing <code>WENO5(::AbstractCurvilinearGrid)</code> defaults to uniform setting, i.e. <code>WENO5(::AbstractCurvilinearGrid) = WENO5()</code>.</p></div></div><p>Not providing any keyword argument, <code>WENO5()</code> defaults to the uniform 5th-order coefficients (&quot;uniform setting) in all directions, using a JS-WENO formulation.</p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; WENO5()
â”Œ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended
â”” @ Oceananigans.Advection .../src/Advection/weno_fifth_order.jl:90
WENO5 advection scheme with:
    â”œâ”€â”€ X regular
    â”œâ”€â”€ Y regular
    â””â”€â”€ Z regular</code></pre><p><code>WENO5(grid = grid)</code> defaults to uniform interpolation coefficient for each of the grid directions that is uniform (<code>typeof(Î”c) &lt;: Number</code>) while it precomputes the ENO coefficients for reconstruction for all grid directions that are stretched. (After testing &quot;on-the-fly&quot; calculation of coefficients for stretched directions ended up being way too expensive and, therefore, is not supported.)</p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = RectilinearGrid(size = (3, 4, 5), x = (0, 1), y = (0, 1), z = [-10, -9, -7, -4, -1.5, 0]);

julia&gt; WENO5(grid = grid)
WENO5 advection scheme with:
    â”œâ”€â”€ X regular
    â”œâ”€â”€ Y regular
    â””â”€â”€ Z stretched</code></pre><p><code>WENO5(grid = grid, stretched_smoothness = true)</code> behaves similarly to <code>WENO5(grid = grid)</code> but, additionally, it also computes the smoothness indicators coefficients, <span>$Î²â‚€$</span>, <span>$Î²â‚$</span>, and <span>$Î²â‚‚$</span>, taking into account the stretched dimensions.</p><p><code>WENO5(zweno = true)</code> implements a Z-WENO formulation for the WENO weights calculation</p><p><strong>Comments</strong></p><p>All methods have the roughly the same execution speed except for <code>stretched_smoothness = true</code> that requires more memory and is less computationally efficient, especially on GPUs. In addition, it has not been found to be much impactful on the tested cases. As such, most of the times we urge users to use <code>WENO5(grid = grid)</code>, as this increases accuracy on a stretched mesh  but does decreases memory utilization (and also results in a slight speed-up).</p><p>(The above claims were made after some preliminary tests. Thus, we still users to perform some benchmarks/checks before performing, e.g., a large simulation on a &quot;weirdly&quot; stretched grid.)</p><p>On the other hand, a Z-WENO formulation is <em>most of the times</em> beneficial (also in case of a uniform mesh) with roughly the same performances (just a slight slowdown). The same can be said for the stretched <code>WENO5(grid = grid)</code> formulation in case of stretched grids.</p><p><strong>References</strong></p><p>Shu, Essentially Non-Oscillatory and Weighted Essentially Non-Oscillatory Schemes for Hyperbolic     Conservation Laws, 1997, NASA/CR-97-206253, ICASE Report No. 97-65</p><p>Castro et al, High order weighted essentially non-oscillatory WENO-Z schemes for hyperbolic conservation     laws, 2011, Journal of Computational Physics, 230(5), 1766-1792</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Advection/weno_fifth_order.jl#L56-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.div_Uc-NTuple{7, Any}" href="#Oceananigans.Advection.div_Uc-NTuple{7, Any}"><code>Oceananigans.Advection.div_Uc</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">div_uc(i, j, k, grid, advection, U, c)</code></pre><p>Calculates the divergence of the flux of a tracer quantity <span>$c$</span> being advected by a velocity field, <span>$ğ›â‹…(ğ¯ c)$</span>,</p><pre><code class="nohighlight hljs">1/V * [Î´xá¶œáµƒáµƒ(Ax * u * â„‘xá¶ áµƒáµƒ(c)) + Î´yáµƒá¶œáµƒ(Ay * v * â„‘yáµƒá¶ áµƒ(c)) + Î´záµƒáµƒá¶œ(Az * w * â„‘záµƒáµƒá¶ (c))]</code></pre><p>which ends up at the location <code>ccc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Advection/tracer_advection_operators.jl#L17-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.div_ğ¯u-NTuple{7, Any}" href="#Oceananigans.Advection.div_ğ¯u-NTuple{7, Any}"><code>Oceananigans.Advection.div_ğ¯u</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">div_ğ¯u(i, j, k, grid, advection, U, u)</code></pre><p>Calculate the advection of momentum in the <span>$x$</span>-direction using the conservative form, <span>$ğ›â‹…(ğ¯ u)$</span>,</p><pre><code class="nohighlight hljs">1/Váµ˜ * [Î´xá¶ áµƒáµƒ(â„‘xá¶œáµƒáµƒ(Ax * u) * â„‘xá¶œáµƒáµƒ(u)) + Î´y_fca(â„‘xá¶ áµƒáµƒ(Ay * v) * â„‘yáµƒá¶ áµƒ(u)) + Î´z_fac(â„‘xá¶ áµƒáµƒ(Az * w) * â„‘záµƒáµƒá¶ (u))]</code></pre><p>which ends up at the location <code>fcc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Advection/momentum_advection_operators.jl#L47-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.div_ğ¯v-NTuple{7, Any}" href="#Oceananigans.Advection.div_ğ¯v-NTuple{7, Any}"><code>Oceananigans.Advection.div_ğ¯v</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">div_ğ¯v(i, j, k, grid, advection, U, v)</code></pre><p>Calculate the advection of momentum in the <span>$y$</span>-direction using the conservative form, <span>$ğ›â‹…(ğ¯ v)$</span>,</p><pre><code class="nohighlight hljs">1/VÊ¸ * [Î´x_cfa(â„‘yáµƒá¶ áµƒ(Ax * u) * â„‘xá¶ áµƒáµƒ(v)) + Î´yáµƒá¶ áµƒ(â„‘yáµƒá¶œáµƒ(Ay * v) * â„‘yáµƒá¶œáµƒ(v)) + Î´z_afc(â„‘xá¶ áµƒáµƒ(Az * w) * â„‘záµƒáµƒá¶ (w))]</code></pre><p>which ends up at the location <code>cfc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Advection/momentum_advection_operators.jl#L62-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.div_ğ¯w-NTuple{7, Any}" href="#Oceananigans.Advection.div_ğ¯w-NTuple{7, Any}"><code>Oceananigans.Advection.div_ğ¯w</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">div_ğ¯w(i, j, k, grid, advection, U, w)</code></pre><p>Calculate the advection of momentum in the <span>$z$</span>-direction using the conservative form, <span>$ğ›â‹…(ğ¯ w)$</span>,</p><pre><code class="nohighlight hljs">1/VÊ· * [Î´x_caf(â„‘záµƒáµƒá¶ (Ax * u) * â„‘xá¶ áµƒáµƒ(w)) + Î´y_acf(â„‘záµƒáµƒá¶ (Ay * v) * â„‘yáµƒá¶ áµƒ(w)) + Î´záµƒáµƒá¶ (â„‘záµƒáµƒá¶œ(Az * w) * â„‘záµƒáµƒá¶œ(w))]</code></pre><p>which ends up at the location <code>ccf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Advection/momentum_advection_operators.jl#L77-L85">source</a></section></article><h2 id="Architectures"><a class="docs-heading-anchor" href="#Architectures">Architectures</a><a id="Architectures-1"></a><a class="docs-heading-anchor-permalink" href="#Architectures" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Architectures.AbstractArchitecture" href="#Oceananigans.Architectures.AbstractArchitecture"><code>Oceananigans.Architectures.AbstractArchitecture</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractArchitecture</code></pre><p>Abstract supertype for architectures supported by Oceananigans.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Architectures.jl#L13-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Architectures.AbstractCPUArchitecture" href="#Oceananigans.Architectures.AbstractCPUArchitecture"><code>Oceananigans.Architectures.AbstractCPUArchitecture</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractCPUArchitecture</code></pre><p>Abstract supertype for CPU architectures supported by Oceananigans.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Architectures.jl#L21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Architectures.AbstractGPUArchitecture" href="#Oceananigans.Architectures.AbstractGPUArchitecture"><code>Oceananigans.Architectures.AbstractGPUArchitecture</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractGPUArchitecture</code></pre><p>Abstract supertype for GPU architectures supported by Oceananigans.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Architectures.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Architectures.CPU" href="#Oceananigans.Architectures.CPU"><code>Oceananigans.Architectures.CPU</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CPU &lt;: AbstractArchitecture</code></pre><p>Run Oceananigans on one CPU node. Uses multiple threads if the environment variable <code>JULIA_NUM_THREADS</code> is set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Architectures.jl#L35-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Architectures.GPU" href="#Oceananigans.Architectures.GPU"><code>Oceananigans.Architectures.GPU</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GPU &lt;: AbstractArchitecture</code></pre><p>Run Oceananigans on a single NVIDIA CUDA GPU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Architectures.jl#L43-L47">source</a></section></article><h2 id="Boundary-conditions"><a class="docs-heading-anchor" href="#Boundary-conditions">Boundary conditions</a><a id="Boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-conditions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.BoundaryCondition" href="#Oceananigans.BoundaryConditions.BoundaryCondition"><code>Oceananigans.BoundaryConditions.BoundaryCondition</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct BoundaryCondition{C&lt;:AbstractBoundaryConditionClassification, T}</code></pre><p>Container for boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/BoundaryConditions/boundary_condition.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.BoundaryCondition-Tuple{DataType, Any}" href="#Oceananigans.BoundaryConditions.BoundaryCondition-Tuple{DataType, Any}"><code>Oceananigans.BoundaryConditions.BoundaryCondition</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoundaryCondition(Classification::DataType, condition)</code></pre><p>Construct a boundary condition of type <code>BC</code> with a number or array as a <code>condition</code>.</p><p>Boundary condition types include <code>Periodic</code>, <code>Flux</code>, <code>Value</code>, <code>Gradient</code>, and <code>Open</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/BoundaryConditions/boundary_condition.jl#L13-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.BoundaryCondition-Tuple{DataType, Function}" href="#Oceananigans.BoundaryConditions.BoundaryCondition-Tuple{DataType, Function}"><code>Oceananigans.BoundaryConditions.BoundaryCondition</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoundaryCondition(Classification::DataType, condition::Function;
                  parameters = nothing,
                  discrete_form = false,
                  field_dependencies=())</code></pre><p>Construct a boundary condition of type <code>Classification</code> with a function boundary <code>condition</code>.</p><p>By default, the function boudnary <code>condition</code> is assumed to have the &#39;continuous form&#39; <code>condition(Î¾, Î·, t)</code>, where <code>t</code> is time and <code>Î¾</code> and <code>Î·</code> vary along the boundary. In particular:</p><ul><li>On <code>x</code>-boundaries, <code>condition(y, z, t)</code>.</li><li>On <code>y</code>-boundaries, <code>condition(x, z, t)</code>.</li><li>On <code>z</code>-boundaries, <code>condition(x, y, t)</code>.</li></ul><p>If <code>parameters</code> is not <code>nothing</code>, then function boundary conditions have the form <code>func(Î¾, Î·, t, parameters)</code>, where <code>Î¾</code> and <code>Î·</code> are spatial coordinates varying along the boundary as explained above.</p><p>If <code>discrete_form = true</code>, the function <code>condition</code> is assumed to have the &quot;discrete form&quot;,</p><pre><code class="nohighlight hljs">condition(i, j, grid, clock, model_fields)</code></pre><p>where <code>i</code>, and <code>j</code> are indices that vary along the boundary. If <code>discrete_form = true</code> and <code>parameters</code> is not <code>nothing</code>, the function <code>condition</code> is called with</p><pre><code class="nohighlight hljs">condition(i, j, grid, clock, model_fields, parameters)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/BoundaryConditions/boundary_condition.jl#L22-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.FieldBoundaryConditions-Tuple{Any, Any}" href="#Oceananigans.BoundaryConditions.FieldBoundaryConditions-Tuple{Any, Any}"><code>Oceananigans.BoundaryConditions.FieldBoundaryConditions</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FieldBoundaryConditions(grid, location; kwargs...)</code></pre><p>Return boundary conditions for auxiliary fields (fields whose values are derived from a model&#39;s prognostic fields) on <code>grid</code> and at <code>location</code>.</p><p><strong>Keyword arguments</strong></p><p>Keyword arguments specify boundary conditions on the 6 possible boundaries:</p><ul><li><code>west</code>, left end point in the <code>x</code>-direction where <code>i=1</code></li><li><code>east</code>, right end point in the <code>x</code>-direction where <code>i=grid.Nx</code></li><li><code>south</code>, left end point in the <code>y</code>-direction where <code>j=1</code></li><li><code>north</code>, right end point in the <code>y</code>-direction where <code>j=grid.Ny</code></li><li><code>bottom</code>, right end point in the <code>z</code>-direction where <code>k=1</code></li><li><code>top</code>, right end point in the <code>z</code>-direction where <code>k=grid.Nz</code></li></ul><p>If a boundary condition is unspecified, the default for auxiliary fields and the topology in the boundary-normal direction is used:</p><ul><li><code>PeriodicBoundaryCondition</code> for <code>Periodic</code> directions</li><li><code>GradientBoundaryCondition(0)</code> for <code>Bounded</code> directions and <code>Centered</code>-located fields</li><li><code>nothing</code> for <code>Bounded</code> directions and <code>Face</code>-located fields</li><li><code>nothing</code> for <code>Flat</code> directions and/or <code>Nothing</code>-located fields)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/BoundaryConditions/field_boundary_conditions.jl#L72-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.FieldBoundaryConditions-Tuple{}" href="#Oceananigans.BoundaryConditions.FieldBoundaryConditions-Tuple{}"><code>Oceananigans.BoundaryConditions.FieldBoundaryConditions</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FieldBoundaryConditions(; kwargs...)</code></pre><p>Return a template for boundary conditions on prognostic fields.</p><p><strong>Keyword arguments</strong></p><p>Keyword arguments specify boundary conditions on the 7 possible boundaries:</p><ul><li><code>west</code>, left end point in the <code>x</code>-direction where <code>i=1</code></li><li><code>east</code>, right end point in the <code>x</code>-direction where <code>i=grid.Nx</code></li><li><code>south</code>, left end point in the <code>y</code>-direction where <code>j=1</code></li><li><code>north</code>, right end point in the <code>y</code>-direction where <code>j=grid.Ny</code></li><li><code>bottom</code>, right end point in the <code>z</code>-direction where <code>k=1</code></li><li><code>top</code>, right end point in the <code>z</code>-direction where <code>k=grid.Nz</code></li><li><code>immersed</code>, boundary between solid and fluid for immersed boundaries (experimental support only)</li></ul><p>If a boundary condition is unspecified, the default for prognostic fields and the topology in the boundary-normal direction is used:</p><ul><li><code>PeriodicBoundaryCondition</code> for <code>Periodic</code> directions</li><li><code>NoFluxBoundaryCondition</code> for <code>Bounded</code> directions and <code>Centered</code>-located fields</li><li><code>ImpenetrableBoundaryCondition</code> for <code>Bounded</code> directions and <code>Face</code>-located fields</li><li><code>nothing</code> for <code>Flat</code> directions and/or <code>Nothing</code>-located fields</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/BoundaryConditions/field_boundary_conditions.jl#L35-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.Flux" href="#Oceananigans.BoundaryConditions.Flux"><code>Oceananigans.BoundaryConditions.Flux</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Flux &lt;: AbstractBoundaryConditionClassification</code></pre><p>A classification specifying a boundary condition on the flux of a field.</p><p>The sign convention is such that a positive flux represents the flux of a quantity in the positive direction. For example, a positive vertical flux implies a quantity is fluxed upwards, in the <span>$+z$</span> direction.</p><p>Due to this convention, a positive flux applied to the top boundary specifies that a quantity is fluxed upwards across the top boundary and thus out of the domain. As a result, a positive flux applied to a top boundary leads to a reduction of that quantity in the interior of the domain; for example, a positive, upwards flux of heat at the top of the domain acts to cool the interior of the domain. Conversely, a positive flux applied to the bottom boundary leads to an increase of the quantity in the interior of the domain. The same logic holds for east, west, north, and south boundaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/BoundaryConditions/boundary_condition_classifications.jl#L17-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.Gradient" href="#Oceananigans.BoundaryConditions.Gradient"><code>Oceananigans.BoundaryConditions.Gradient</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Gradient &lt;: AbstractBoundaryConditionClassification</code></pre><p>A classification specifying a boundary condition on the derivative or gradient of a field. Also called a Neumann boundary condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/BoundaryConditions/boundary_condition_classifications.jl#L36-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.Open" href="#Oceananigans.BoundaryConditions.Open"><code>Oceananigans.BoundaryConditions.Open</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Open &lt;: AbstractBoundaryConditionClassification</code></pre><p>A classification that specifies the halo regions of a field directly.</p><p>For fields located at Faces, Open also specifies field value <em>on</em> the boundary.</p><p>Open boundary conditions are used to specify the component of a velocity field normal to a boundary and can also be used to describe nested or linked simulation domains.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/BoundaryConditions/boundary_condition_classifications.jl#L52-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.Value" href="#Oceananigans.BoundaryConditions.Value"><code>Oceananigans.BoundaryConditions.Value</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Value &lt;: AbstractBoundaryConditionClassification</code></pre><p>A classification specifying a boundary condition on the value of a field. Also called a Dirchlet boundary condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/BoundaryConditions/boundary_condition_classifications.jl#L44-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.apply_x_bcs!-Tuple{Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any, Oceananigans.Architectures.AbstractArchitecture, Any, Vararg{Any, N} where N}" href="#Oceananigans.BoundaryConditions.apply_x_bcs!-Tuple{Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any, Oceananigans.Architectures.AbstractArchitecture, Any, Vararg{Any, N} where N}"><code>Oceananigans.BoundaryConditions.apply_x_bcs!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Apply flux boundary conditions to a field <code>c</code> by adding the associated flux divergence to the source term <code>Gc</code> at the left and right.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/BoundaryConditions/apply_flux_bcs.jl#L31-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.apply_y_bcs!-Tuple{Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any, Oceananigans.Architectures.AbstractArchitecture, Any, Vararg{Any, N} where N}" href="#Oceananigans.BoundaryConditions.apply_y_bcs!-Tuple{Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any, Oceananigans.Architectures.AbstractArchitecture, Any, Vararg{Any, N} where N}"><code>Oceananigans.BoundaryConditions.apply_y_bcs!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Apply flux boundary conditions to a field <code>c</code> by adding the associated flux divergence to the source term <code>Gc</code> at the left and right.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/BoundaryConditions/apply_flux_bcs.jl#L38-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.apply_z_bcs!-Tuple{Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any, Oceananigans.Architectures.AbstractArchitecture, Any, Vararg{Any, N} where N}" href="#Oceananigans.BoundaryConditions.apply_z_bcs!-Tuple{Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any, Oceananigans.Architectures.AbstractArchitecture, Any, Vararg{Any, N} where N}"><code>Oceananigans.BoundaryConditions.apply_z_bcs!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Apply flux boundary conditions to a field <code>c</code> by adding the associated flux divergence to the source term <code>Gc</code> at the top and bottom.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/BoundaryConditions/apply_flux_bcs.jl#L45-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.fill_halo_regions!-Tuple{OffsetArrays.OffsetArray, Any, Any, Any, Vararg{Any, N} where N}" href="#Oceananigans.BoundaryConditions.fill_halo_regions!-Tuple{OffsetArrays.OffsetArray, Any, Any, Any, Vararg{Any, N} where N}"><code>Oceananigans.BoundaryConditions.fill_halo_regions!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Fill halo regions in x, y, and z for a given field&#39;s data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/BoundaryConditions/fill_halo_regions.jl#L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.fill_halo_regions!-Tuple{Union{Tuple, NamedTuple}, Any, Vararg{Any, N} where N}" href="#Oceananigans.BoundaryConditions.fill_halo_regions!-Tuple{Union{Tuple, NamedTuple}, Any, Vararg{Any, N} where N}"><code>Oceananigans.BoundaryConditions.fill_halo_regions!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fill_halo_regions!(fields::Union{Tuple, NamedTuple}, arch, args...)</code></pre><p>Fill halo regions for each field in the tuple <code>fields</code> according to their boundary conditions, possibly recursing into <code>fields</code> if it is a nested tuple-of-tuples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/BoundaryConditions/fill_halo_regions.jl#L10-L15">source</a></section></article><h2 id="BuoyancyModels"><a class="docs-heading-anchor" href="#BuoyancyModels">BuoyancyModels</a><a id="BuoyancyModels-1"></a><a class="docs-heading-anchor-permalink" href="#BuoyancyModels" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BuoyancyModels.Buoyancy-Tuple{}" href="#Oceananigans.BuoyancyModels.Buoyancy-Tuple{}"><code>Oceananigans.BuoyancyModels.Buoyancy</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Buoyancy(; model, vertical_unit_vector=ZDirection())</code></pre><p>Uses a given buoyancy <code>model</code> to create buoyancy in a model. The optional keyword argument  <code>vertical_unit_vector</code> can be used to specify the direction opposite to the gravitational acceleration (which we take here to mean the &quot;vertical&quot; direction).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Oceananigans

grid = RectilinearGrid(size=(1, 8, 8), extent=(1, 1000, 100))
Î¸ = 45 # degrees
gÌƒ = (0, sind(Î¸), cosd(Î¸))

buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=gÌƒ)

model = NonhydrostaticModel(grid=grid, buoyancy=buoyancy, tracers=:b)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/BuoyancyModels/buoyancy.jl#L9-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BuoyancyModels.BuoyancyField-Tuple{Any}" href="#Oceananigans.BuoyancyModels.BuoyancyField-Tuple{Any}"><code>Oceananigans.BuoyancyModels.BuoyancyField</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BuoyancyField(model; data=nothing, recompute_safely=true)</code></pre><p>Returns a <code>BuoyancyField</code> corresponding to <code>model.buoyancy</code>. Calling <code>compute!(b::BuoyancyField)</code> computes the current buoyancy field associated with <code>model</code> and stores the result in <code>b.data</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/BuoyancyModels/buoyancy_field.jl#L48-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BuoyancyModels.BuoyancyField-Union{Tuple{C}, Tuple{B}, Tuple{G}, Tuple{A}, Tuple{D}, Tuple{D, A, G, B, C, Bool}} where {D, A, G, B, C}" href="#Oceananigans.BuoyancyModels.BuoyancyField-Union{Tuple{C}, Tuple{B}, Tuple{G}, Tuple{A}, Tuple{D}, Tuple{D, A, G, B, C, Bool}} where {D, A, G, B, C}"><code>Oceananigans.BuoyancyModels.BuoyancyField</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BuoyancyField(data, grid, buoyancy, tracers)</code></pre><p>Returns a <code>BuoyancyField</code> with <code>data</code> on <code>grid</code> corresponding to <code>buoyancy</code> computed from <code>tracers</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/BuoyancyModels/buoyancy_field.jl#L22-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BuoyancyModels.BuoyancyTracer" href="#Oceananigans.BuoyancyModels.BuoyancyTracer"><code>Oceananigans.BuoyancyModels.BuoyancyTracer</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BuoyancyTracer &lt;: AbstractBuoyancyModel{Nothing}</code></pre><p>Type indicating that the tracer <code>b</code> represents buoyancy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/BuoyancyModels/buoyancy_tracer.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BuoyancyModels.LinearEquationOfState" href="#Oceananigans.BuoyancyModels.LinearEquationOfState"><code>Oceananigans.BuoyancyModels.LinearEquationOfState</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinearEquationOfState{FT} &lt;: AbstractEquationOfState</code></pre><p>Linear equation of state for seawater.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/BuoyancyModels/linear_equation_of_state.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BuoyancyModels.LinearEquationOfState" href="#Oceananigans.BuoyancyModels.LinearEquationOfState"><code>Oceananigans.BuoyancyModels.LinearEquationOfState</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinearEquationOfState([FT=Float64;] Î±=1.67e-4, Î²=7.80e-4)</code></pre><p>Returns parameters for a linear equation of state for seawater with thermal expansion coefficient <code>Î±</code> [Kâ»Â¹] and haline contraction coefficient <code>Î²</code> [psuâ»Â¹]. The buoyancy perturbation associated with a linear equation of state is</p><p class="math-container">\[    b = g (Î± T - Î² S)\]</p><p>Default constants are taken from Table 1.2 (page 33) of Vallis, &quot;Atmospheric and Oceanic Fluid Dynamics: Fundamentals and Large-Scale Circulation&quot; (2ed, 2017).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/BuoyancyModels/linear_equation_of_state.jl#L11-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BuoyancyModels.SeawaterBuoyancy" href="#Oceananigans.BuoyancyModels.SeawaterBuoyancy"><code>Oceananigans.BuoyancyModels.SeawaterBuoyancy</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SeawaterBuoyancy{FT, EOS, T, S} &lt;: AbstractBuoyancyModel{EOS}</code></pre><p>BuoyancyModels model for seawater. <code>T</code> and <code>S</code> are either <code>nothing</code> if both temperature and salinity are active, or of type <code>FT</code> if temperature or salinity are constant, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/BuoyancyModels/seawater_buoyancy.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BuoyancyModels.SeawaterBuoyancy" href="#Oceananigans.BuoyancyModels.SeawaterBuoyancy"><code>Oceananigans.BuoyancyModels.SeawaterBuoyancy</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SeawaterBuoyancy([FT=Float64;] gravitational_acceleration = g_Earth,
                              equation_of_state = LinearEquationOfState(FT),
                              constant_temperature = false, constant_salinity = false)</code></pre><p>Returns parameters for a temperature- and salt-stratified seawater buoyancy model with a <code>gravitational_acceleration</code> constant (typically called &#39;g&#39;), and an <code>equation_of_state</code> that related temperature and salinity (or conservative temperature and absolute salinity) to density anomalies and buoyancy.</p><p><code>constant_temperature</code> indicates that buoyancy depends only on salinity. For a nonlinear equation of state, <code>constant_temperature</code> is used as the temperature of the system. The same logic, with the roles of salinity and temperature reversed, holds when <code>constant_salinity</code> is provided.</p><p>For a linear equation of state, the values of <code>constant_temperature</code> or <code>constant_salinity</code> are irrelevant; in this case, <code>constant_temperature=true</code> (and similar for <code>constant_salinity</code>) is valid input.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/BuoyancyModels/seawater_buoyancy.jl#L21-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BuoyancyModels.âˆ‚x_b-Tuple{Any, Any, Any, Any, SeawaterBuoyancy, Any}" href="#Oceananigans.BuoyancyModels.âˆ‚x_b-Tuple{Any, Any, Any, Any, SeawaterBuoyancy, Any}"><code>Oceananigans.BuoyancyModels.âˆ‚x_b</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">âˆ‚x_b(i, j, k, grid, b::SeawaterBuoyancy, C)</code></pre><p>Returns the x-derivative of buoyancy for temperature and salt-stratified water,</p><p class="math-container">\[âˆ‚_x b = g ( Î± âˆ‚_x T - Î² âˆ‚_x S ) ,\]</p><p>where <code>g</code> is gravitational acceleration, <code>Î±</code> is the thermal expansion coefficient, <code>Î²</code> is the haline contraction coefficient, <code>T</code> is conservative temperature, and <code>S</code> is absolute salinity.</p><p>Note: In Oceananigans, <code>model.tracers.T</code> is conservative temperature and <code>model.tracers.S</code> is absolute salinity.</p><p>Note that <code>âˆ‚x_T</code>, <code>âˆ‚x_S</code>, <code>Î±</code>, and <code>Î²</code> are all evaluated at cell interfaces in <code>x</code> and cell centers in <code>y</code> and <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/BuoyancyModels/seawater_buoyancy.jl#L73-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BuoyancyModels.âˆ‚y_b-Tuple{Any, Any, Any, Any, SeawaterBuoyancy, Any}" href="#Oceananigans.BuoyancyModels.âˆ‚y_b-Tuple{Any, Any, Any, Any, SeawaterBuoyancy, Any}"><code>Oceananigans.BuoyancyModels.âˆ‚y_b</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">âˆ‚y_b(i, j, k, grid, b::SeawaterBuoyancy, C)</code></pre><p>Returns the y-derivative of buoyancy for temperature and salt-stratified water,</p><p class="math-container">\[âˆ‚_y b = g ( Î± âˆ‚_y T - Î² âˆ‚_y S ) ,\]</p><p>where <code>g</code> is gravitational acceleration, <code>Î±</code> is the thermal expansion coefficient, <code>Î²</code> is the haline contraction coefficient, <code>T</code> is conservative temperature, and <code>S</code> is absolute salinity.</p><p>Note: In Oceananigans, <code>model.tracers.T</code> is conservative temperature and <code>model.tracers.S</code> is absolute salinity.</p><p>Note that <code>âˆ‚y_T</code>, <code>âˆ‚y_S</code>, <code>Î±</code>, and <code>Î²</code> are all evaluated at cell interfaces in <code>y</code> and cell centers in <code>x</code> and <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/BuoyancyModels/seawater_buoyancy.jl#L99-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BuoyancyModels.âˆ‚z_b-Tuple{Any, Any, Any, Any, SeawaterBuoyancy, Any}" href="#Oceananigans.BuoyancyModels.âˆ‚z_b-Tuple{Any, Any, Any, Any, SeawaterBuoyancy, Any}"><code>Oceananigans.BuoyancyModels.âˆ‚z_b</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">âˆ‚z_b(i, j, k, grid, b::SeawaterBuoyancy, C)</code></pre><p>Returns the vertical derivative of buoyancy for temperature and salt-stratified water,</p><p class="math-container">\[âˆ‚_z b = N^2 = g ( Î± âˆ‚_z T - Î² âˆ‚_z S ) ,\]</p><p>where <code>g</code> is gravitational acceleration, <code>Î±</code> is the thermal expansion coefficient, <code>Î²</code> is the haline contraction coefficient, <code>T</code> is conservative temperature, and <code>S</code> is absolute salinity.</p><p>Note: In Oceananigans, <code>model.tracers.T</code> is conservative temperature and <code>model.tracers.S</code> is absolute salinity.</p><p>Note that <code>âˆ‚z_T</code>, <code>âˆ‚z_S</code>, <code>Î±</code>, and <code>Î²</code> are all evaluated at cell interfaces in <code>z</code> and cell centers in <code>x</code> and <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/BuoyancyModels/seawater_buoyancy.jl#L125-L143">source</a></section></article><h2 id="Coriolis"><a class="docs-heading-anchor" href="#Coriolis">Coriolis</a><a id="Coriolis-1"></a><a class="docs-heading-anchor-permalink" href="#Coriolis" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.BetaPlane" href="#Oceananigans.Coriolis.BetaPlane"><code>Oceananigans.Coriolis.BetaPlane</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BetaPlane{T} &lt;: AbstractRotation</code></pre><p>A parameter object for meridionally increasing Coriolis parameter (<code>f = fâ‚€ + Î² y</code>) that accounts for the variation of the locally vertical component of the rotation vector with latitude.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Coriolis/beta_plane.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.BetaPlane" href="#Oceananigans.Coriolis.BetaPlane"><code>Oceananigans.Coriolis.BetaPlane</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BetaPlane([T=Float64;] fâ‚€=nothing, Î²=nothing,
                       rotation_rate=Î©_Earth, latitude=nothing, radius=R_Earth)</code></pre><p>The user may specify both <code>fâ‚€</code> and <code>Î²</code>, or the three parameters <code>rotation_rate</code>, <code>latitude</code> (in degrees), and <code>radius</code> that specify the rotation rate and radius of a planet, and the central latitude (where <span>$y = 0$</span>) at which the <code>Î²</code>-plane approximation is to be made.</p><p>If <code>fâ‚€</code> and <code>Î²</code> are not specified, they are calculated from <code>rotation_rate</code>, <code>latitude</code>, and <code>radius</code> according to the relations <code>fâ‚€ = 2 * rotation_rate * sind(latitude)</code> and <code>Î² = 2 * rotation_rate * cosd(latitude) / radius</code>.</p><p>By default, the <code>rotation_rate</code> and planet <code>radius</code> is assumed to be Earth&#39;s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Coriolis/beta_plane.jl#L13-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.ConstantCartesianCoriolis" href="#Oceananigans.Coriolis.ConstantCartesianCoriolis"><code>Oceananigans.Coriolis.ConstantCartesianCoriolis</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConstantCartesianCoriolis{FT} &lt;: AbstractRotation</code></pre><p>A Coriolis implementation that accounts for the locally vertical and possibly both local horizontal components of a constant rotation vector. A more general implementation of <a href="#Oceananigans.Coriolis.FPlane"><code>FPlane</code></a>, which only accounts for the locally vertical component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Coriolis/constant_cartesian_coriolis.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.ConstantCartesianCoriolis" href="#Oceananigans.Coriolis.ConstantCartesianCoriolis"><code>Oceananigans.Coriolis.ConstantCartesianCoriolis</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConstantCartesianCoriolis([FT=Float64;] fx=nothing, fy=nothing, fz=nothing,
                                        f=nothing, rotation_axis=ZDirection(), 
                                        rotation_rate=Î©_Earth, latitude=nothing)</code></pre><p>Returns a parameter object for a constant rotation decomposed into the <code>x</code>, <code>y</code> and <code>z</code> directions. In oceanography the components <code>x</code>, <code>y</code>, <code>z</code> correspond to the directions east, north, and up. This rotation can be specified in three different ways:</p><ul><li>Specifying all components <code>fx</code>, <code>fy</code> and <code>fz</code> directly.</li><li>Specifying the Coriolis parameter <code>f</code> and (optionally) a <code>rotation_axis</code> (which defaults to the <code>z</code> direction if not specified).</li><li>Specifying <code>latitude</code> (in degrees) and (optionally) a <code>rotation_rate</code> in radians per second (which defaults to Earth&#39;s rotation rate).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Coriolis/constant_cartesian_coriolis.jl#L16-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.FPlane" href="#Oceananigans.Coriolis.FPlane"><code>Oceananigans.Coriolis.FPlane</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FPlane{FT} &lt;: AbstractRotation</code></pre><p>A parameter object for constant rotation around a vertical axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Coriolis/f_plane.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.FPlane" href="#Oceananigans.Coriolis.FPlane"><code>Oceananigans.Coriolis.FPlane</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FPlane([FT=Float64;] f=nothing, rotation_rate=Î©_Earth, latitude=nothing)</code></pre><p>Returns a parameter object for constant rotation at the angular frequency <code>f/2</code>, and therefore with background vorticity <code>f</code>, around a vertical axis. If <code>f</code> is not specified, it is calculated from <code>rotation_rate</code> and <code>latitude</code> (in degrees) according to the relation <code>f = 2 * rotation_rate * sind(latitude)</code>.</p><p>By default, <code>rotation_rate</code> is assumed to be Earth&#39;s.</p><p>Also called <code>FPlane</code>, after the &quot;f-plane&quot; approximation for the local effect of a planet&#39;s rotation in a planar coordinate system tangent to the planet&#39;s surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Coriolis/f_plane.jl#L10-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.HydrostaticSphericalCoriolis" href="#Oceananigans.Coriolis.HydrostaticSphericalCoriolis"><code>Oceananigans.Coriolis.HydrostaticSphericalCoriolis</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HydrostaticSphericalCoriolis{FT} &lt;: AbstractRotation</code></pre><p>A parameter object for constant rotation around a vertical axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Coriolis/hydrostatic_spherical_coriolis.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.HydrostaticSphericalCoriolis-Union{Tuple{}, Tuple{DataType}, Tuple{S}} where S" href="#Oceananigans.Coriolis.HydrostaticSphericalCoriolis-Union{Tuple{}, Tuple{DataType}, Tuple{S}} where S"><code>Oceananigans.Coriolis.HydrostaticSphericalCoriolis</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HydrostaticSphericalCoriolis([FT=Float64;] rotation_rate=Î©_Earth, scheme=VectorInvariantEnergyConserving()))</code></pre><p>Returns a parameter object for Coriolis forces on a sphere rotating at <code>rotation_rate</code>. By default, <code>rotation_rate</code> is assumed to be Earth&#39;s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Coriolis/hydrostatic_spherical_coriolis.jl#L21-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.NonTraditionalBetaPlane" href="#Oceananigans.Coriolis.NonTraditionalBetaPlane"><code>Oceananigans.Coriolis.NonTraditionalBetaPlane</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NonTraditionalBetaPlane{FT} &lt;: AbstractRotation</code></pre><p>A Coriolis implementation that accounts for the latitudinal variation of both the locally vertical and the locally horizontal components of the rotation vector. The &quot;traditional&quot; approximation in ocean models accounts for only the locally vertical component of the rotation vector (see <a href="#Oceananigans.Coriolis.BetaPlane"><code>BetaPlane</code></a>).</p><p>This implementation is based off of section 5 of Dellar (2011). It conserve energy, angular momentum, and potential vorticity.</p><p><strong>References</strong></p><p>Dellar, P. (2011). Variations on a beta-plane: Derivation of non-traditional     beta-plane equations from Hamilton&#39;s principle on a sphere. Journal of     Fluid Mechanics, 674, 174-195. doi:10.1017/S0022112010006464</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Coriolis/non_traditional_beta_plane.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.NonTraditionalBetaPlane" href="#Oceananigans.Coriolis.NonTraditionalBetaPlane"><code>Oceananigans.Coriolis.NonTraditionalBetaPlane</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NonTraditionalBetaPlane(FT=Float64;
    fz=nothing, fy=nothing, Î²=nothing, Î³=nothing,
    rotation_rate=Î©_Earth, latitude=nothing, radius=R_Earth)</code></pre><p>The user may directly specify <code>fz</code>, <code>fy</code>, <code>Î²</code>, <code>Î³</code>, and <code>radius</code> or the three parameters <code>rotation_rate</code>, <code>latitude</code> (in degrees), and <code>radius</code> that specify the rotation rate and radius of a planet, and the central latitude (where <span>$y = 0$</span>) at which the non-traditional <code>Î²</code>-plane approximation is to be made.</p><p>If <code>fz</code>, <code>fy</code>, <code>Î²</code>, and <code>Î³</code> are not specified, they are calculated from <code>rotation_rate</code>,  <code>latitude</code>, and <code>radius</code> according to the relations <code>fz = 2 * rotation_rate * sind(latitude)</code>, <code>fy = 2 * rotation_rate * cosd(latitude)</code>, <code>Î² = 2 * rotation_rate * cosd(latitude) / radius</code>, and <code>Î³ = - 4 * rotation_rate * sind(latitude) / radius</code>.</p><p>By default, the <code>rotation_rate</code> and planet <code>radius</code> is assumed to be Earth&#39;s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Coriolis/non_traditional_beta_plane.jl#L26-L42">source</a></section></article><h2 id="Diagnostics"><a class="docs-heading-anchor" href="#Diagnostics">Diagnostics</a><a id="Diagnostics-1"></a><a class="docs-heading-anchor-permalink" href="#Diagnostics" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.CFL" href="#Oceananigans.Diagnostics.CFL"><code>Oceananigans.Diagnostics.CFL</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CFL{D, S}</code></pre><p>An object for computing the Courant-Freidrichs-Lewy (CFL) number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Diagnostics/cfl.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.CFL-Tuple{Any}" href="#Oceananigans.Diagnostics.CFL-Tuple{Any}"><code>Oceananigans.Diagnostics.CFL</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CFL(Î”t [, timescale=Oceananigans.cell_advection_timescale])</code></pre><p>Returns an object for computing the Courant-Freidrichs-Lewy (CFL) number associated with time step or <code>TimeStepWizard</code> <code>Î”t</code> and <code>timescale</code>.</p><p>See also <code>AdvectiveCFL</code> and <code>DiffusiveCFL</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Diagnostics/cfl.jl#L14-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.StateChecker-Tuple{Any}" href="#Oceananigans.Diagnostics.StateChecker-Tuple{Any}"><code>Oceananigans.Diagnostics.StateChecker</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">StateChecker(; schedule, fields)</code></pre><p>Returns a <code>StateChecker</code> that logs field information (minimum, maximum, mean) for each field in a named tuple of <code>fields</code> when <code>schedule</code> actuates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Diagnostics/state_checker.jl#L11-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.WindowedSpatialAverage-Tuple{Any}" href="#Oceananigans.Diagnostics.WindowedSpatialAverage-Tuple{Any}"><code>Oceananigans.Diagnostics.WindowedSpatialAverage</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">WindowedSpatialAverage(field; dims, field_slicer=FieldSlicer())</code></pre><p>Builds a <code>WindowedSpatialAverage</code> of <code>field</code> that returns the average of <code>field</code> over a </p><p>slice defined by <code>field_sicer</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; using Oceananigans.Diagnostics: WindowedSpatialAverage

julia&gt; grid = RectilinearGrid(size=(4, 6, 4), extent=(1, 1, 1));

julia&gt; model = NonhydrostaticModel(grid=grid);

julia&gt; set!(model.velocities.u, 1);

julia&gt; slicer = FieldSlicer(j=3:6, k=1);

julia&gt; U_wsa = WindowedSpatialAverage(model.velocities.u; dims=(1, 2), field_slicer=slicer);

julia&gt; simulation = Simulation(model, Î”t=10, stop_iteration=10);

julia&gt; simulation.output_writers[:simple_output] = NetCDFOutputWriter(model, (U_wsa=U_wsa,), 
                                                                      schedule = 10,
                                                                      filepath = &quot;windowed_spatial_average_jldoctest.nc&quot;);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Diagnostics/windowed_spatial_average.jl#L11-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.AdvectiveCFL-Tuple{Any}" href="#Oceananigans.Diagnostics.AdvectiveCFL-Tuple{Any}"><code>Oceananigans.Diagnostics.AdvectiveCFL</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AdvectiveCFL(Î”t)</code></pre><p>Returns an object for computing the Courant-Freidrichs-Lewy (CFL) number associated with time step or <code>TimeStepWizard</code> <code>Î”t</code> and the time scale for advection across a cell.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; model = NonhydrostaticModel(grid=RectilinearGrid(size=(16, 16, 16), length=(8, 8, 8)));

julia&gt; cfl = AdvectiveCFL(1.0);

julia&gt; data(model.velocities.u) .= Ï€;

julia&gt; cfl(model)
6.283185307179586</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Diagnostics/cfl.jl#L26-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.DiffusiveCFL-Tuple{Any}" href="#Oceananigans.Diagnostics.DiffusiveCFL-Tuple{Any}"><code>Oceananigans.Diagnostics.DiffusiveCFL</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DiffusiveCFL(Î”t)</code></pre><p>Returns an object for computing the diffusive Courant-Freidrichs-Lewy (CFL) number associated with time step or <code>TimeStepWizard</code> <code>Î”t</code> and the time scale for diffusion across a cell associated with <code>model.closure</code>.</p><p>The maximum diffusive CFL number among viscosity and all tracer diffusivities is returned.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; model = NonhydrostaticModel(grid=RectilinearGrid(size=(16, 16, 16), length=(1, 1, 1)));

julia&gt; dcfl = DiffusiveCFL(0.1);

julia&gt; dcfl(model)
2.688e-5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Diagnostics/cfl.jl#L48-L68">source</a></section></article><h2 id="Fields"><a class="docs-heading-anchor" href="#Fields">Fields</a><a id="Fields-1"></a><a class="docs-heading-anchor-permalink" href="#Fields" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.AbstractDataField" href="#Oceananigans.Fields.AbstractDataField"><code>Oceananigans.Fields.AbstractDataField</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractDataField{X, Y, Z, A, G, T, N}</code></pre><p>Abstract supertype for fields with concrete data in settable underlying arrays, located at <code>(X, Y, Z)</code> on architecture <code>A</code> and defined on a grid <code>G</code> with eltype <code>T</code> and <code>N</code> dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Fields/abstract_field.jl#L31-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.AbstractField" href="#Oceananigans.Fields.AbstractField"><code>Oceananigans.Fields.AbstractField</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractField{X, Y, Z, A, G, T, N}</code></pre><p>Abstract supertype for fields located at <code>(X, Y, Z)</code> on architecture <code>A</code> and defined on a grid <code>G</code> with eltype <code>T</code> and <code>N</code> dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Fields/abstract_field.jl#L23-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.AveragedField-Tuple{Oceananigans.Fields.AbstractField}" href="#Oceananigans.Fields.AveragedField-Tuple{Oceananigans.Fields.AbstractField}"><code>Oceananigans.Fields.AveragedField</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AveragedField(operand::AbstractField; dims, data=nothing, recompute_safely=false)</code></pre><p>Returns an AveragedField averaged over <code>dims</code>. <code>dims</code> is a tuple of integers indicating spatial dimensions; in a Cartesian coordinate system, <code>1=x,</code>2=y<code>, and</code>3=z`.</p><p><strong>Arguments</strong></p><ul><li><p><code>dims</code>: Tuple of integers specifying the dimensions to average <code>operand</code>.         A single integer is also accepted for averaging over a single dimension.  </p></li><li><p><code>data</code>: An <code>OffsetArray</code> for storing averaged data.         Useful if carefully managing memory allocation.         If unspecified, <code>data</code> is created by <code>Oceananigans.Grids.new_data</code>.</p></li><li><p><code>recompute_safely</code>: A boolean that&#39;s relevant only if the <code>AveragedField</code> is used                     within another computation. If <code>recompute_safely=false</code>,                     <code>AveragedField</code> will <em>not</em> be recomputed before computing any dependent                     computations if <code>AveragedField.status</code> is consistent with the current state of the simulation.                     If <code>recompute_safely=true</code>, <code>AveragedField</code> is always recomputed                     before performing a dependent computation.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; using Oceananigans

julia&gt; grid = RectilinearGrid(size=(2, 2, 2), x=(0, 1), y=(0, 1), z=(0, 1));

julia&gt; c = CenterField(CPU(), grid);

julia&gt; C_xy = AveragedField(c, dims=(1, 2)) # average over x, y
AveragedField over dims=(1, 2) located at (â‹…, â‹…, Center) of Field located at (Center, Center, Center)
â”œâ”€â”€ data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 1, 2)
â”œâ”€â”€ grid: RectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=2, Ny=2, Nz=2)
â”œâ”€â”€ dims: (1, 2)
â”œâ”€â”€ operand: Field located at (Center, Center, Center)
â””â”€â”€ status: time=0.0

julia&gt; C_z = AveragedField(c, dims=3) # averaged over z
AveragedField over dims=(3,) located at (Center, Center, â‹…) of Field located at (Center, Center, Center)
â”œâ”€â”€ data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (2, 2, 1)
â”œâ”€â”€ grid: RectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=2, Ny=2, Nz=2)
â”œâ”€â”€ dims: (3,)
â”œâ”€â”€ operand: Field located at (Center, Center, Center)
â””â”€â”€ status: time=0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Fields/averaged_field.jl#L35-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.BackgroundField" href="#Oceananigans.Fields.BackgroundField"><code>Oceananigans.Fields.BackgroundField</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BackgroundField{F, P}</code></pre><p>Temporary container for storing information about BackgroundFields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Fields/background_fields.jl#L29-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.BackgroundField-Tuple{Any}" href="#Oceananigans.Fields.BackgroundField-Tuple{Any}"><code>Oceananigans.Fields.BackgroundField</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BackgroundField(func; parameters=nothing)</code></pre><p>Returns a <code>BackgroundField</code> to be passed to <code>NonhydrostaticModel</code> for use as a background velocity or tracer field.</p><p>If <code>parameters</code> is not provided, <code>func</code> must be callable with the signature</p><pre><code class="language-julia hljs">func(x, y, z, t)</code></pre><p>If <code>parameters</code> is provided, <code>func</code> must be callable with the signature</p><pre><code class="language-julia hljs">func(x, y, z, t, parameters)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Fields/background_fields.jl#L39-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.ComputedField" href="#Oceananigans.Fields.ComputedField"><code>Oceananigans.Fields.ComputedField</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ComputedField(operand [, arch=nothing]; data = nothing, recompute_safely = true,
              boundary_conditions = ComputedFieldBoundaryConditions(operand.grid, location(operand))</code></pre><p>Return a field whose data is <code>computed</code> from <code>operand</code>. If <code>arch</code>itecture is not supplied it is inferred from <code>operand</code>.</p><p>If the keyword argument <code>data</code> is not provided, memory is allocated to store the result. The <code>arch</code>itecture of <code>data</code> is inferred from <code>operand</code>.</p><p>If <code>data</code> is provided and <code>recompute_safely=false</code>, then &quot;recomputation&quot; of the <code>ComputedField</code> is avoided if possible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Fields/computed_field.jl#L34-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.Field" href="#Oceananigans.Fields.Field"><code>Oceananigans.Fields.Field</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Field(LX, LY, LZ, [arch = CPU()], grid,
      [ bcs = FieldBoundaryConditions(grid, (LX, LY, LZ)),
       data = new_data(eltype(grid), arch, grid, (LX, LY, LZ))])</code></pre><p>Construct a <code>Field</code> on <code>grid</code> with <code>data</code> on architecture <code>arch</code> with boundary conditions <code>bcs</code>. Each of <code>(LX, LY, LZ)</code> is either <code>Center</code> or <code>Face</code> and determines the field&#39;s location in <code>(x, y, z)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; Ï‰ = Field(Face, Face, Center, CPU(), RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)))
Field located at (Face, Face, Center)
â”œâ”€â”€ data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 1, 1)
â”œâ”€â”€ grid: RectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1)
â””â”€â”€ boundary conditions: west=Periodic, east=Periodic, south=Periodic, north=Periodic, bottom=ZeroFlux, top=ZeroFlux, immersed=ZeroFlux</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Fields/field.jl#L15-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.Field-Tuple{Tuple, Vararg{Any, N} where N}" href="#Oceananigans.Fields.Field-Tuple{Tuple, Vararg{Any, N} where N}"><code>Oceananigans.Fields.Field</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Field(L::Tuple, arch, grid, data, bcs)</code></pre><p>Construct a <code>Field</code> at the location defined by the 3-tuple <code>L</code>, whose elements are <code>Center</code> or <code>Face</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Fields/field.jl#L63-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.FieldSlicer" href="#Oceananigans.Fields.FieldSlicer"><code>Oceananigans.Fields.FieldSlicer</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FieldSlicer{I, J, K, W}</code></pre><p>Slices fields along indices with or without halo regions as specified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Fields/field_slicer.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.FieldSlicer-Tuple{}" href="#Oceananigans.Fields.FieldSlicer-Tuple{}"><code>Oceananigans.Fields.FieldSlicer</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FieldSlicer(i=Colon(), j=Colon(), k=Colon(), with_halos=false)</code></pre><p>Returns <code>FieldSlicer</code> that slices a field prior to output or time-averaging.</p><p>The keyword arguments <code>i, j, k</code> prescribe an <code>Integer</code> index, <code>UnitRange</code>, or <code>StepRange</code> of indices in <code>x, y, z</code>, respectively.</p><p>The default for <code>i</code>, <code>j</code>, and <code>k</code> is <code>Colon()</code> which indicates &quot;all indices&quot;.</p><p>The keyword <code>with_halos</code> denotes whether halo data is saved or not. Halo regions are sliced off output for <code>UnitRange</code>, <code>StepRange</code>, and <code>Colon</code> index specifications.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Fields/field_slicer.jl#L17-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.KernelComputedField-Tuple{Any, Any, Any, Any, Oceananigans.AbstractModel}" href="#Oceananigans.Fields.KernelComputedField-Tuple{Any, Any, Any, Any, Oceananigans.AbstractModel}"><code>Oceananigans.Fields.KernelComputedField</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">KernelComputedField(X, Y, Z, kernel, model;
                    boundary_conditions = FieldBoundaryConditions(grid, (X, Y, Z)),
                    computed_dependencies = (),
                    parameters = nothing,
                    data = nothing,
                    recompute_safely = true)</code></pre><p>Builds a <code>KernelComputedField</code> at <code>X, Y, Z</code> computed with <code>kernel</code> and <code>model.architecture</code> and <code>model.grid</code>, with <code>boundary_conditions</code>.</p><p><code>computed_dependencies</code> are an iterable of <code>AbstractField</code>s or other objects on which <code>compute!</code> is called prior to launching <code>kernel</code>.</p><p><code>data</code> is a three-dimensional <code>OffsetArray</code> of scratch space where the kernel computation is stored.</p><p>If <code>data=nothing</code> (the default) then additional memory will be allocated to store the <code>data</code> of <code>KernelComputedField</code>.</p><p>If <code>isnothing(parameters)</code>, <code>kernel</code> is launched with the function signature</p><p><code>kernel(data, grid, computed_dependencies...)</code></p><p>Otherwise, <code>kernel</code> is launched with the function signature</p><p><code>kernel(data, grid, computed_dependencies..., parameters)</code></p><p><code>recompute_safely</code> (default: <code>true</code>) determines whether the <code>KernelComputedField</code> is &quot;recomputed&quot; if embedded in the expression tree of another operation.     - If <code>recompute_safely=true</code>, the <code>KernelComputedField</code> is always recomputed.     - If <code>recompute_safely=false</code>, the <code>KernelComputedField</code> will not be recomputed if its status is up-to-date.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using KernelAbstractions: @index, @kernel
using Oceananigans.Fields: AveragedField, KernelComputedField, compute!
using Oceananigans.Grids: Center, Face

@inline Ïˆâ€²Â²(i, j, k, grid, Ïˆ, Î¨) = @inbounds (Ïˆ[i, j, k] - Î¨[i, j, k])^2
@inline Ïˆâ€²Â²(i, j, k, grid, Ïˆ, Î¨::Number) = @inbounds (Ïˆ[i, j, k] - Î¨)^2

@kernel function compute_variance!(var, grid, Ï•, Î¦)
    i, j, k = @index(Global, NTuple)

    @inbounds var[i, j, k] = Ïˆâ€²Â²(i, j, k, grid, Ï•, Î¦)
end

u, v, w = model.velocities

U = AveragedField(u, dims=(1, 2))
V = AveragedField(v, dims=(1, 2))

uâ€²Â² = KernelComputedField(Face, Center, Center, compute_variance!, model; computed_dependencies=(u, U))
vâ€²Â² = KernelComputedField(Center, Face, Center, compute_variance!, model; computed_dependencies=(v, V))
wâ€²Â² = KernelComputedField(Center, Center, Face, compute_variance!, model; computed_dependencies=(w, 0))

compute!(uâ€²Â²)
compute!(vâ€²Â²)
compute!(wâ€²Â²)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Fields/kernel_computed_field.jl#L36-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.ReducedField-Tuple{DataType, Any, Any, Any, Any, Oceananigans.Grids.AbstractGrid}" href="#Oceananigans.Fields.ReducedField-Tuple{DataType, Any, Any, Any, Any, Oceananigans.Grids.AbstractGrid}"><code>Oceananigans.Fields.ReducedField</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ReducedField(X, Y, Z, arch, grid; dims, data=nothing, boundary_conditions=nothing)</code></pre><p>Returns a <code>ReducedField</code> reduced over <code>dims</code> on <code>grid</code> and <code>arch</code>itecture with <code>boundary_conditions</code>.</p><p>The location <code>(X, Y, Z)</code> may be the parent, three-dimension location or the reduced location.</p><p>If <code>data</code> is specified, it should be an <code>OffsetArray</code> with singleton reduced dimensions; otherwise <code>data</code> is allocated.</p><p>If <code>boundary_conditions</code> are not provided, default boundary conditions are constructed using the reduced location.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Fields/reduced_field.jl#L75-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.ReducedField-Union{Tuple{B}, Tuple{G}, Tuple{D}, Tuple{A}, Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{D, A, G, Any, B}} where {X, Y, Z, A, D, G, B}" href="#Oceananigans.Fields.ReducedField-Union{Tuple{B}, Tuple{G}, Tuple{D}, Tuple{A}, Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{D, A, G, Any, B}} where {X, Y, Z, A, D, G, B}"><code>Oceananigans.Fields.ReducedField</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ReducedField{X, Y, Z}(data, grid, dims)</code></pre><p>Returns a <code>ReducedField</code> at location <code>(X, Y, Z)</code> with <code>data</code> on <code>grid</code> that is reduced over the dimensions in <code>dims</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Fields/reduced_field.jl#L56-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.CenterField-Tuple{Oceananigans.Architectures.AbstractArchitecture, Any, Vararg{Any, N} where N}" href="#Oceananigans.Fields.CenterField-Tuple{Oceananigans.Architectures.AbstractArchitecture, Any, Vararg{Any, N} where N}"><code>Oceananigans.Fields.CenterField</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CenterField([arch=CPU()], grid, args...)</code></pre><p>Returns <code>Field{Center, Center, Center}</code> on <code>arch</code>itecture and <code>grid</code>. Additional arguments are passed to the <code>Field</code> constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Fields/field.jl#L75-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.PressureFields" href="#Oceananigans.Fields.PressureFields"><code>Oceananigans.Fields.PressureFields</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">PressureFields(arch, grid, bcs::NamedTuple)</code></pre><p>Return a <code>NamedTuple</code> with pressure fields <code>pHYâ€²</code> and <code>pNHS</code> initialized as <code>CenterField</code>s on the architecture <code>arch</code> and <code>grid</code>.  Boundary conditions <code>bcs</code> may be specified via a named tuple of <code>FieldBoundaryCondition</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Fields/field_tuples.jl#L73-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.PressureFields-Tuple{NamedTuple{(:pHYâ€², :pNHS), T} where T&lt;:Tuple, Any, Any, Any}" href="#Oceananigans.Fields.PressureFields-Tuple{NamedTuple{(:pHYâ€², :pNHS), T} where T&lt;:Tuple, Any, Any, Any}"><code>Oceananigans.Fields.PressureFields</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PressureFields(proposed_pressures::NamedTuple{(:pHYâ€², :pNHS)}, arch, grid, bcs)</code></pre><p>Return a <code>NamedTuple</code> of pressure fields with, overwriting boundary conditions in <code>proposed_tracer_fields</code> with corresponding fields in the <code>NamedTuple</code> <code>bcs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Fields/field_tuples.jl#L171-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.TendencyFields-Tuple{Any, Any, Any}" href="#Oceananigans.Fields.TendencyFields-Tuple{Any, Any, Any}"><code>Oceananigans.Fields.TendencyFields</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TendencyFields(arch, grid, tracer_names;
               u = XFaceField(arch, grid),
               v = YFaceField(arch, grid),
               w = ZFaceField(arch, grid),
               kwargs...)</code></pre><p>Return a <code>NamedTuple</code> with tendencies for all solution fields (velocity fields and tracer fields), initialized on the architecture <code>arch</code> and <code>grid</code>. Optional <code>kwargs</code> can be specified to assign data arrays to each tendency field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Fields/field_tuples.jl#L107-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.TracerFields-NTuple{4, Any}" href="#Oceananigans.Fields.TracerFields-NTuple{4, Any}"><code>Oceananigans.Fields.TracerFields</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TracerFields(tracer_names, arch, grid, user_bcs)</code></pre><p>Return a <code>NamedTuple</code> with tracer fields specified by <code>tracer_names</code> initialized as <code>CenterField</code>s on the architecture <code>arch</code> and <code>grid</code>. Boundary conditions <code>user_bcs</code> may be specified via a named tuple of <code>FieldBoundaryCondition</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Fields/field_tuples.jl#L37-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.TracerFields-Tuple{Any, Any, Any}" href="#Oceananigans.Fields.TracerFields-Tuple{Any, Any, Any}"><code>Oceananigans.Fields.TracerFields</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TracerFields(tracer_names, arch, grid; kwargs...)</code></pre><p>Return a <code>NamedTuple</code> with tracer fields specified by <code>tracer_names</code> initialized as <code>CenterField</code>s on the architecture <code>arch</code> and <code>grid</code>. Fields may be passed via optional keyword arguments <code>kwargs</code> for each field.</p><p>This function is used by <code>OutputWriters.Checkpointer</code> and <code>TendencyFields</code>. ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Fields/field_tuples.jl#L50-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.TracerFields-Tuple{NamedTuple, Any, Any, Any}" href="#Oceananigans.Fields.TracerFields-Tuple{NamedTuple, Any, Any, Any}"><code>Oceananigans.Fields.TracerFields</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TracerFields(proposed_tracers::NamedTuple, arch, grid, bcs)</code></pre><p>Return a <code>NamedTuple</code> of tracers, overwriting boundary conditions in <code>proposed_tracers</code> with corresponding fields in the <code>NamedTuple</code> <code>bcs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Fields/field_tuples.jl#L155-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.TracerFields-Tuple{NamedTuple{(), Tuple{}}, Any, Any, Any}" href="#Oceananigans.Fields.TracerFields-Tuple{NamedTuple{(), Tuple{}}, Any, Any, Any}"><code>Oceananigans.Fields.TracerFields</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Shortcut constructor for empty tracer fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Fields/field_tuples.jl#L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.VelocityFields" href="#Oceananigans.Fields.VelocityFields"><code>Oceananigans.Fields.VelocityFields</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">VelocityFields(arch, grid, user_bcs = NamedTuple())</code></pre><p>Return a <code>NamedTuple</code> with fields <code>u</code>, <code>v</code>, <code>w</code> initialized on the architecture <code>arch</code> and <code>grid</code>. Boundary conditions <code>bcs</code> may be specified via a named tuple of <code>FieldBoundaryCondition</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Fields/field_tuples.jl#L7-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.VelocityFields-Tuple{NamedTuple{(:u, :v, :w), T} where T&lt;:Tuple, Any, Any, Any}" href="#Oceananigans.Fields.VelocityFields-Tuple{NamedTuple{(:u, :v, :w), T} where T&lt;:Tuple, Any, Any, Any}"><code>Oceananigans.Fields.VelocityFields</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">VelocityFields(proposed_velocities::NamedTuple{(:u, :v, :w)}, arch, grid, bcs)</code></pre><p>Return a <code>NamedTuple</code> of velocity fields, overwriting boundary conditions in <code>proposed_velocities</code> with corresponding fields in the <code>NamedTuple</code> <code>bcs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Fields/field_tuples.jl#L138-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.XFaceField-Tuple{Oceananigans.Architectures.AbstractArchitecture, Vararg{Any, N} where N}" href="#Oceananigans.Fields.XFaceField-Tuple{Oceananigans.Architectures.AbstractArchitecture, Vararg{Any, N} where N}"><code>Oceananigans.Fields.XFaceField</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">XFaceField([arch=CPU()], grid, args...)</code></pre><p>Returns <code>Field{Face, Center, Center}</code> on <code>arch</code>itecture and <code>grid</code>. Additional arguments are passed to the <code>Field</code> constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Fields/field.jl#L83-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.YFaceField-Tuple{Oceananigans.Architectures.AbstractArchitecture, Vararg{Any, N} where N}" href="#Oceananigans.Fields.YFaceField-Tuple{Oceananigans.Architectures.AbstractArchitecture, Vararg{Any, N} where N}"><code>Oceananigans.Fields.YFaceField</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">YFaceField([arch=CPU()], grid, args...)</code></pre><p>Returns <code>Field{Center, Face, Center}</code> on <code>arch</code>itecture and <code>grid</code>. Additional arguments are passed to the <code>Field</code> constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Fields/field.jl#L91-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.ZFaceField-Tuple{Oceananigans.Architectures.AbstractArchitecture, Vararg{Any, N} where N}" href="#Oceananigans.Fields.ZFaceField-Tuple{Oceananigans.Architectures.AbstractArchitecture, Vararg{Any, N} where N}"><code>Oceananigans.Fields.ZFaceField</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ZFaceField([arch=CPU()], grid, args...)</code></pre><p>Returns <code>Field{Center, Center, Face}</code> on <code>arch</code>itecture and <code>grid</code>. Additional arguments are passed to the <code>Field</code> constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Fields/field.jl#L99-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.compute!" href="#Oceananigans.Fields.compute!"><code>Oceananigans.Fields.compute!</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute!(avg::AveragedField, time=nothing)</code></pre><p>Compute the average of <code>avg.operand</code> and store the result in <code>avg.data</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Fields/averaged_field.jl#L100-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.compute!-Tuple{Any}" href="#Oceananigans.Fields.compute!-Tuple{Any}"><code>Oceananigans.Fields.compute!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute!(field)</code></pre><p>Computes <code>field.data</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Fields/abstract_field.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.compute!-Union{Tuple{ComputedField{LX, LY, LZ, S, O, A, D, G, T, C} where {S, O, A, D, G, T, C}}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{ComputedField{LX, LY, LZ, S, O, A, D, G, T, C} where {S, O, A, D, G, T, C}, Any}} where {LX, LY, LZ}" href="#Oceananigans.Fields.compute!-Union{Tuple{ComputedField{LX, LY, LZ, S, O, A, D, G, T, C} where {S, O, A, D, G, T, C}}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{ComputedField{LX, LY, LZ, S, O, A, D, G, T, C} where {S, O, A, D, G, T, C}, Any}} where {LX, LY, LZ}"><code>Oceananigans.Fields.compute!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute!(comp::ComputedField)</code></pre><p>Compute <code>comp.operand</code> and store the result in <code>comp.data</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Fields/computed_field.jl#L73-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.data-Tuple{Any}" href="#Oceananigans.Fields.data-Tuple{Any}"><code>Oceananigans.Fields.data</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Returns <code>f.data</code> for <code>f::Field</code> or <code>f</code> for `f::AbstractArray.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Fields/abstract_field.jl#L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.interior-Union{Tuple{Oceananigans.Fields.AbstractDataField{X, Y, Z, A, G, T, N} where {A, G, T, N}}, Tuple{Z}, Tuple{Y}, Tuple{X}} where {X, Y, Z}" href="#Oceananigans.Fields.interior-Union{Tuple{Oceananigans.Fields.AbstractDataField{X, Y, Z, A, G, T, N} where {A, G, T, N}}, Tuple{Z}, Tuple{Y}, Tuple{X}} where {X, Y, Z}"><code>Oceananigans.Fields.interior</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Returns a view of <code>f</code> that excludes halo points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Fields/abstract_field.jl#L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.interpolate-NTuple{4, Any}" href="#Oceananigans.Fields.interpolate-NTuple{4, Any}"><code>Oceananigans.Fields.interpolate</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">interpolate(field, x, y, z)</code></pre><p>Interpolate <code>field</code> to the physical point <code>(x, y, z)</code> using trilinear interpolation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Fields/interpolate.jl#L68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.regrid!-Tuple{Any, Any}" href="#Oceananigans.Fields.regrid!-Tuple{Any, Any}"><code>Oceananigans.Fields.regrid!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">regrid!(a, b)</code></pre><p>Regrid field <code>b</code> onto the grid of field <code>a</code>. </p><div class="admonition is-warning"><header class="admonition-header">Functionality limitation</header><div class="admonition-body"><p>Currently <code>regrid!</code> only regrids in the vertical <span>$z$</span> direction and works only on grids for which <span>$x$</span> and <span>$y$</span> dimensions are <code>Flat</code>.</p></div></div><p><strong>Example</strong></p><p>Generate a tracer field on a vertically stretched grid and regrid it on a regular grid.</p><pre><code class="language-julia hljs">using Oceananigans

Nz, Lz = 2, 1.0
topology = (Flat, Flat, Bounded)

input_grid = RectilinearGrid(size=Nz, z = [0, Lz/3, Lz], topology=topology)
input_field = CenterField(input_grid)
input_field[1, 1, 1:Nz] = [2, 3]

output_grid = RectilinearGrid(size=Nz, z=(0, Lz), topology=topology)
output_field = CenterField(output_grid)

regrid!(output_field, input_field)

output_field[1, 1, :]

# output
4-element OffsetArray(::Vector{Float64}, 0:3) with eltype Float64 with indices 0:3:
 0.0
 2.333333333333334
 3.0
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Fields/regridding_fields.jl#L9-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.set!-Tuple{Oceananigans.Fields.AbstractField{X, Y, Z, var&quot;#s157&quot;, G, T, N} where {X, Y, Z, var&quot;#s157&quot;&lt;:Oceananigans.Architectures.AbstractCPUArchitecture, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}, Function}" href="#Oceananigans.Fields.set!-Tuple{Oceananigans.Fields.AbstractField{X, Y, Z, var&quot;#s157&quot;, G, T, N} where {X, Y, Z, var&quot;#s157&quot;&lt;:Oceananigans.Architectures.AbstractCPUArchitecture, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}, Function}"><code>Oceananigans.Fields.set!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Set the CPU field <code>u</code> data to the function <code>f(x, y, z)</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Fields/set!.jl#L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.set!-Tuple{Oceananigans.Fields.AbstractField{X, Y, Z, var&quot;#s157&quot;, G, T, N} where {X, Y, Z, var&quot;#s157&quot;&lt;:Oceananigans.Architectures.AbstractCPUArchitecture, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}, Oceananigans.Fields.AbstractField{X, Y, Z, var&quot;#s157&quot;, G, T, N} where {X, Y, Z, var&quot;#s157&quot;&lt;:Oceananigans.Architectures.AbstractGPUArchitecture, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}" href="#Oceananigans.Fields.set!-Tuple{Oceananigans.Fields.AbstractField{X, Y, Z, var&quot;#s157&quot;, G, T, N} where {X, Y, Z, var&quot;#s157&quot;&lt;:Oceananigans.Architectures.AbstractCPUArchitecture, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}, Oceananigans.Fields.AbstractField{X, Y, Z, var&quot;#s157&quot;, G, T, N} where {X, Y, Z, var&quot;#s157&quot;&lt;:Oceananigans.Architectures.AbstractGPUArchitecture, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}"><code>Oceananigans.Fields.set!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Set the CPU field <code>u</code> data to the GPU field data of <code>v</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Fields/set!.jl#L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.set!-Tuple{Oceananigans.Fields.AbstractField{X, Y, Z, var&quot;#s157&quot;, G, T, N} where {X, Y, Z, var&quot;#s157&quot;&lt;:Oceananigans.Architectures.AbstractGPUArchitecture, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}, Oceananigans.Fields.AbstractField{X, Y, Z, var&quot;#s157&quot;, G, T, N} where {X, Y, Z, var&quot;#s157&quot;&lt;:Oceananigans.Architectures.AbstractCPUArchitecture, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}" href="#Oceananigans.Fields.set!-Tuple{Oceananigans.Fields.AbstractField{X, Y, Z, var&quot;#s157&quot;, G, T, N} where {X, Y, Z, var&quot;#s157&quot;&lt;:Oceananigans.Architectures.AbstractGPUArchitecture, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}, Oceananigans.Fields.AbstractField{X, Y, Z, var&quot;#s157&quot;, G, T, N} where {X, Y, Z, var&quot;#s157&quot;&lt;:Oceananigans.Architectures.AbstractCPUArchitecture, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}"><code>Oceananigans.Fields.set!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Set the GPU field <code>u</code> data to the CPU field data of <code>v</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Fields/set!.jl#L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.set!-Tuple{Oceananigans.Fields.AbstractField{X, Y, Z, var&quot;#s157&quot;, G, T, N} where {X, Y, Z, var&quot;#s157&quot;&lt;:Oceananigans.Architectures.AbstractGPUArchitecture, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}, Union{Function, Array}}" href="#Oceananigans.Fields.set!-Tuple{Oceananigans.Fields.AbstractField{X, Y, Z, var&quot;#s157&quot;, G, T, N} where {X, Y, Z, var&quot;#s157&quot;&lt;:Oceananigans.Architectures.AbstractGPUArchitecture, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}, Union{Function, Array}}"><code>Oceananigans.Fields.set!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Set the GPU field <code>u</code> to the array or function <code>v</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Fields/set!.jl#L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.location-Union{Tuple{Oceananigans.Fields.AbstractField{X, Y, Z, A, G, T, N} where {A&lt;:Union{Nothing, Oceananigans.Architectures.AbstractArchitecture}, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}, Tuple{Z}, Tuple{Y}, Tuple{X}} where {X, Y, Z}" href="#Oceananigans.location-Union{Tuple{Oceananigans.Fields.AbstractField{X, Y, Z, A, G, T, N} where {A&lt;:Union{Nothing, Oceananigans.Architectures.AbstractArchitecture}, G&lt;:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}}, Tuple{Z}, Tuple{Y}, Tuple{X}} where {X, Y, Z}"><code>Oceananigans.location</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Returns the location <code>(X, Y, Z)</code> of an <code>AbstractField{X, Y, Z}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Fields/abstract_field.jl#L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.@compute-Tuple{Any}" href="#Oceananigans.Fields.@compute-Tuple{Any}"><code>Oceananigans.Fields.@compute</code></a> â€” <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@compute(exprs...)</code></pre><p>Call compute! on fields after defining them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Fields/abstract_field.jl#L102-L106">source</a></section></article><h2 id="Forcings"><a class="docs-heading-anchor" href="#Forcings">Forcings</a><a id="Forcings-1"></a><a class="docs-heading-anchor-permalink" href="#Forcings" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.ContinuousForcing" href="#Oceananigans.Forcings.ContinuousForcing"><code>Oceananigans.Forcings.ContinuousForcing</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ContinuousForcing{LX, LY, LZ, P, F, D, I, â„‘}</code></pre><p>A callable object that implements a &quot;continuous form&quot; forcing function on a field at the location <code>LX, LY, LZ</code> with optional parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Forcings/continuous_forcing.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.ContinuousForcing-Tuple{Any}" href="#Oceananigans.Forcings.ContinuousForcing-Tuple{Any}"><code>Oceananigans.Forcings.ContinuousForcing</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ContinuousForcing(func; parameters=nothing, field_dependencies=())</code></pre><p>Construct a &quot;continuous form&quot; forcing with optional <code>parameters</code> and optional <code>field_dependencies</code> on other fields in a model.</p><p>If neither <code>parameters</code> nor <code>field_dependencies</code> are provided, then <code>func</code> must be callable with the signature</p><pre><code class="language-julia hljs">func(x, y, z, t)</code></pre><p>where <code>x, y, z</code> are the east-west, north-south, and vertical spatial coordinates, and <code>t</code> is time.</p><p>If <code>field_dependencies</code> are provided, the signature of <code>func</code> must include them. For example, if <code>field_dependencies=(:u, :S)</code> (and <code>parameters</code> are <em>not</em> provided), then <code>func</code> must be callable with the signature</p><pre><code class="language-julia hljs">func(x, y, z, t, u, S)</code></pre><p>where <code>u</code> is assumed to be the <code>u</code>-velocity component, and <code>S</code> is a tracer. Note that any field which does not have the name <code>u</code>, <code>v</code>, or <code>w</code> is assumed to be a tracer and must be present in <code>model.tracers</code>.</p><p>If <code>parameters</code> are provided, then the <em>last</em> argument to <code>func</code> must be <code>parameters</code>. For example, if <code>func</code> has no <code>field_dependencies</code> but does depend on <code>parameters</code>, then it must be callable with the signature</p><pre><code class="language-julia hljs">func(x, y, z, t, parameters)</code></pre><p>With <code>field_dependencies=(:u, :v, :w, :c)</code> and <code>parameters</code>, then <code>func</code> must be callable with the signature</p><pre><code class="language-julia hljs">func(x, y, z, t, u, v, w, c, parameters)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Forcings/continuous_forcing.jl#L48-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.DiscreteForcing" href="#Oceananigans.Forcings.DiscreteForcing"><code>Oceananigans.Forcings.DiscreteForcing</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DiscreteForcing{P, F}</code></pre><p>Wrapper for &quot;discrete form&quot; forcing functions with optional <code>parameters</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Forcings/discrete_forcing.jl#L5-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.DiscreteForcing-Tuple{Any}" href="#Oceananigans.Forcings.DiscreteForcing-Tuple{Any}"><code>Oceananigans.Forcings.DiscreteForcing</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DiscreteForcing(func; parameters=nothing)</code></pre><p>Construct a &quot;discrete form&quot; forcing function with optional parameters. The forcing function is applied at grid point <code>i, j, k</code>.</p><p>When <code>parameters</code> are not specified, <code>func</code> must be callable with the signature</p><pre><code class="nohighlight hljs">`func(i, j, k, grid, clock, model_fields)`</code></pre><p>where <code>grid</code> is <code>model.grid</code>, <code>clock.time</code> is the current simulation time and <code>clock.iteration</code> is the current model iteration, and <code>model_fields</code> is a <code>NamedTuple</code> with <code>u, v, w</code> and the fields in <code>model.tracers</code>.</p><p><em>Note</em> that the index <code>end</code> does <em>not</em> access the final physical grid point of a model field in any direction. The final grid point must be explicitly specified, as in <code>model_fields.u[i, j, grid.Nz]</code>.</p><p>When <code>parameters</code> <em>is</em> specified, <code>func</code> must be callable with the signature.</p><pre><code class="nohighlight hljs">`func(i, j, k, grid, clock, model_fields, parameters)`</code></pre><p><code>parameters</code> is arbitrary in principle, however GPU compilation can place constraints on <code>typeof(parameters)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Forcings/discrete_forcing.jl#L16-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.GaussianMask" href="#Oceananigans.Forcings.GaussianMask"><code>Oceananigans.Forcings.GaussianMask</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GaussianMask{D}(center, width)</code></pre><p>Callable object that returns a Gaussian masking function centered on <code>center</code>, with <code>width</code>, and varying along direction <code>D</code>.</p><p><strong>Examples</strong></p><ul><li>Create a Gaussian mask centered on <code>z=0</code> with width <code>1</code> meter.</li></ul><pre><code class="language-julia hljs">julia&gt; mask = GaussianMask{:z}(center=0, width=1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Forcings/relaxation.jl#L101-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.LinearTarget" href="#Oceananigans.Forcings.LinearTarget"><code>Oceananigans.Forcings.LinearTarget</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinearTarget{D}(intercept, gradient)</code></pre><p>Callable object that returns a Linear target function with <code>intercept</code> and <code>gradient</code>, and varying along direction <code>D</code>.</p><p><strong>Examples</strong></p><ul><li>Create a linear target function varying in <code>z</code>, equal to <code>0</code> at <code>z=0</code> and with gradient 10â»â¶:</li></ul><pre><code class="language-julia hljs">julia&gt; target = LinearTarget{:z}(intercept=0, gradient=1e-6)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Forcings/relaxation.jl#L141-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.Relaxation" href="#Oceananigans.Forcings.Relaxation"><code>Oceananigans.Forcings.Relaxation</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Relaxation{R, M, T}</code></pre><p>Callable object for restoring fields to a <code>target</code> at some <code>rate</code> and within a <code>mask</code>ed region in <code>x, y, z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Forcings/relaxation.jl#L12-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.Relaxation-Tuple{}" href="#Oceananigans.Forcings.Relaxation-Tuple{}"><code>Oceananigans.Forcings.Relaxation</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Relaxation(; rate, mask=onefunction, target=zerofunction)</code></pre><p>Returns a <code>Forcing</code> that restores a field to <code>target(x, y, z, t)</code> at the specified <code>rate</code>, in the region <code>mask(x, y, z)</code>.</p><p>The functions <code>onefunction</code> and <code>zerofunction</code> always return 1 and 0, respectively. Thus the default <code>mask</code> leaves the whole domain uncovered, and the default <code>target</code> is zero.</p><p><strong>Example</strong></p><ul><li>Restore a field to zero on a timescale of &quot;3600&quot; (equal to one hour if the time units of the simulation are seconds).</li></ul><pre><code class="language-julia hljs">using Oceananigans

damping = Relaxation(rate = 1/3600)

# output
Relaxation{Float64, typeof(Oceananigans.Forcings.onefunction), typeof(Oceananigans.Forcings.zerofunction)}
â”œâ”€â”€ rate: 0.0002777777777777778
â”œâ”€â”€ mask: 1
â””â”€â”€ target: 0</code></pre><ul><li>Restore a field to a linear z-gradient within the bottom 1/4 of a domain on a timescale of &quot;60&quot; (equal to one minute if the time units of the simulation are seconds).</li></ul><pre><code class="language-julia hljs">dTdz = 0.001 # â°C mâ»Â¹, temperature gradient

Tâ‚€ = 20 # â°C, surface temperature at z=0

Lz = 100 # m, depth of domain

bottom_sponge_layer = Relaxation(; rate = 1/60,
                                   target = LinearTarget{:z}(intercept=Tâ‚€, gradient=dTdz),
                                   mask = GaussianMask{:z}(center=-Lz, width=Lz/4))

# output
Relaxation{Float64, GaussianMask{:z, Float64}, LinearTarget{:z, Float64}}
â”œâ”€â”€ rate: 0.016666666666666666
â”œâ”€â”€ mask: exp(-(z + 100.0)^2 / (2 * 25.0^2))
â””â”€â”€ target: 20.0 + 0.001 * z</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Forcings/relaxation.jl#L24-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.Forcing-Tuple{Any}" href="#Oceananigans.Forcings.Forcing-Tuple{Any}"><code>Oceananigans.Forcings.Forcing</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Forcing(func; parameters=nothing, field_dependencies=(), discrete_form=false)</code></pre><p>Returns a forcing function added to the tendency of an Oceananigans model field.</p><p>If <code>discrete_form=false</code> (the default), and neither <code>parameters</code> nor <code>field_dependencies</code> are provided, then <code>func</code> must be callable with the signature</p><pre><code class="nohighlight hljs">`func(x, y, z, t)`</code></pre><p>where <code>x, y, z</code> are the east-west, north-south, and vertical spatial coordinates, and <code>t</code> is time. Note that this form is also default in the constructor for <code>NonhydrostaticModel</code>, so that <code>Forcing</code> is not needed.</p><p>If <code>discrete_form=false</code> (the default), and <code>field_dependencies</code> are provided, the signature of <code>func</code> must include them. For example, if <code>field_dependencies=(:u, :S)</code> (and <code>parameters</code> are <em>not</em> provided), then <code>func</code> must be callable with the signature</p><pre><code class="nohighlight hljs">`func(x, y, z, t, u, S)`</code></pre><p>where <code>u</code> is assumed to be the <code>u</code>-velocity component, and <code>S</code> is a tracer. Note that any field which does not have the name <code>u</code>, <code>v</code>, or <code>w</code> is assumed to be a tracer and must be present in <code>model.tracers</code>.</p><p>If <code>discrete_form=false</code> (the default) and <code>parameters</code> are provided, then the <em>last</em> argument to <code>func</code> must be <code>parameters</code>. For example, if <code>func</code> has no <code>field_dependencies</code> but does depend on <code>parameters</code>, then it must be callable with the signature</p><pre><code class="nohighlight hljs">`func(x, y, z, t, parameters)`</code></pre><p>The object <code>parameters</code> is arbitrary in principle, however GPU compilation can place constraints on <code>typeof(parameters)</code>.</p><p>With <code>field_dependencies=(:u, :v, :w, :c)</code> and <code>parameters</code>, then <code>func</code> must be callable with the signature</p><pre><code class="nohighlight hljs">`func(x, y, z, t, u, v, w, c, parameters)`</code></pre><p>If <code>discrete_form=true</code> then <code>func</code> must be callable with the &quot;discrete form&quot;</p><pre><code class="nohighlight hljs">`func(i, j, k, grid, clock, model_fields)`</code></pre><p>where <code>i, j, k</code> is the grid point at which the forcing is applied, <code>grid</code> is <code>model.grid</code>, <code>clock.time</code> is the current simulation time and <code>clock.iteration</code> is the current model iteration, and <code>model_fields</code> is a <code>NamedTuple</code> with <code>u, v, w</code>, the fields in <code>model.tracers</code>, and the fields in <code>model.diffusivity_fields</code>, each of which is an <code>OffsetArray</code>s (or <code>NamedTuple</code>s of <code>OffsetArray</code>s depending on the turbulence closure) of field data.</p><p>When <code>discrete_form=true</code> and <code>parameters</code> <em>is</em> specified, <code>func</code> must be callable with the signature</p><pre><code class="nohighlight hljs">`func(i, j, k, grid, clock, model_fields, parameters)`</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Oceananigans

# Parameterized forcing
parameterized_func(x, y, z, t, p) = p.Î¼ * exp(z / p.Î») * cos(p.Ï‰ * t)

v_forcing = Forcing(parameterized_func, parameters = (Î¼=42, Î»=0.1, Ï‰=Ï€))

# output
ContinuousForcing{NamedTuple{(:Î¼, :Î», :Ï‰), Tuple{Int64, Float64, Irrational{:Ï€}}}}
â”œâ”€â”€ func: parameterized_func
â”œâ”€â”€ parameters: (Î¼ = 42, Î» = 0.1, Ï‰ = Ï€)
â””â”€â”€ field dependencies: ()</code></pre><p>Note that because forcing locations are regularized within the <code>NonhydrostaticModel</code> constructor:</p><pre><code class="language-julia hljs">grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))
model = NonhydrostaticModel(grid=grid, forcing=(v=v_forcing,))

model.forcing.v

# output
ContinuousForcing{NamedTuple{(:Î¼, :Î», :Ï‰), Tuple{Int64, Float64, Irrational{:Ï€}}}} at (Center, Face, Center)
â”œâ”€â”€ func: parameterized_func
â”œâ”€â”€ parameters: (Î¼ = 42, Î» = 0.1, Ï‰ = Ï€)
â””â”€â”€ field dependencies: ()</code></pre><p>After passing through the constructor for <code>NonhydrostaticModel</code>, the <code>v</code>-forcing location information is available and set to <code>Center, Face, Center</code>.</p><pre><code class="language-julia hljs"># Field-dependent forcing
growth_in_sunlight(x, y, z, t, P) = exp(z) * P

plankton_forcing = Forcing(growth_in_sunlight, field_dependencies=:P)

# output
ContinuousForcing{Nothing}
â”œâ”€â”€ func: growth_in_sunlight
â”œâ”€â”€ parameters: nothing
â””â”€â”€ field dependencies: (:P,)</code></pre><pre><code class="language-julia hljs"># Parameterized, field-dependent forcing
tracer_relaxation(x, y, z, t, c, p) = p.Î¼ * exp((z + p.H) / p.Î») * (p.dCdz * z - c) 

c_forcing = Forcing(tracer_relaxation,
                    field_dependencies = :c,
                            parameters = (Î¼=1/60, Î»=10, H=1000, dCdz=1))

# output
ContinuousForcing{NamedTuple{(:Î¼, :Î», :H, :dCdz), Tuple{Float64, Int64, Int64, Int64}}}
â”œâ”€â”€ func: tracer_relaxation
â”œâ”€â”€ parameters: (Î¼ = 0.016666666666666666, Î» = 10, H = 1000, dCdz = 1)
â””â”€â”€ field dependencies: (:c,)</code></pre><pre><code class="language-julia hljs"># Unparameterized discrete-form forcing function
filtered_relaxation(i, j, k, grid, clock, model_fields) =
    @inbounds - (model_fields.c[i-1, j, k] + model_fields.c[i, j, k] + model_fields.c[i+1, j, k]) / 3

filtered_forcing = Forcing(filtered_relaxation, discrete_form=true)

# output
DiscreteForcing{Nothing}
â”œâ”€â”€ func: filtered_relaxation
â””â”€â”€ parameters: nothing</code></pre><pre><code class="language-julia hljs"># Discrete-form forcing function with parameters
masked_damping(i, j, k, grid, clock, model_fields, parameters) = 
    @inbounds - parameters.Î¼ * exp(grid.záµƒáµƒá¶œ[k] / parameters.Î») * model_fields.u[i, j, k]

masked_damping_forcing = Forcing(masked_damping, parameters=(Î¼=42, Î»=Ï€), discrete_form=true)

# output
DiscreteForcing{NamedTuple{(:Î¼, :Î»), Tuple{Int64, Irrational{:Ï€}}}}
â”œâ”€â”€ func: masked_damping
â””â”€â”€ parameters: (Î¼ = 42, Î» = Ï€)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Forcings/forcing.jl#L1-L143">source</a></section></article><h2 id="Grids"><a class="docs-heading-anchor" href="#Grids">Grids</a><a id="Grids-1"></a><a class="docs-heading-anchor-permalink" href="#Grids" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.AbstractCurvilinearGrid" href="#Oceananigans.Grids.AbstractCurvilinearGrid"><code>Oceananigans.Grids.AbstractCurvilinearGrid</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractCurvilinearGrid{FT, TX, TY, TZ}</code></pre><p>Abstract supertype for curvilinear grids with elements of type <code>FT</code> and topology <code>{TX, TY, TZ}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Grids/Grids.jl#L101-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.AbstractGrid" href="#Oceananigans.Grids.AbstractGrid"><code>Oceananigans.Grids.AbstractGrid</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractGrid{FT, TX, TY, TZ}</code></pre><p>Abstract supertype for grids with elements of type <code>FT</code> and topology <code>{TX, TY, TZ}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Grids/Grids.jl#L79-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.AbstractHorizontallyCurvilinearGrid" href="#Oceananigans.Grids.AbstractHorizontallyCurvilinearGrid"><code>Oceananigans.Grids.AbstractHorizontallyCurvilinearGrid</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractHorizontallyCurvilinearGrid{FT, TX, TY, TZ}</code></pre><p>Abstract supertype for horizontally-curvilinear grids with elements of type <code>FT</code> and topology <code>{TX, TY, TZ}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Grids/Grids.jl#L108-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.AbstractRectilinearGrid" href="#Oceananigans.Grids.AbstractRectilinearGrid"><code>Oceananigans.Grids.AbstractRectilinearGrid</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractRectilinearGrid{FT, TX, TY, TZ}</code></pre><p>Abstract supertype for rectilinear grids with elements of type <code>FT</code> and topology <code>{TX, TY, TZ}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Grids/Grids.jl#L94-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.AbstractTopology" href="#Oceananigans.Grids.AbstractTopology"><code>Oceananigans.Grids.AbstractTopology</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractTopology</code></pre><p>Abstract supertype for grid topologies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Grids/Grids.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.AbstractUnderlyingGrid" href="#Oceananigans.Grids.AbstractUnderlyingGrid"><code>Oceananigans.Grids.AbstractUnderlyingGrid</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractUnderlyingGrid{FT, TX, TY, TZ}</code></pre><p>Abstract supertype for &quot;primary&quot; grids (as opposed to grids with immersed boundaries) with elements of type <code>FT</code> and topology <code>{TX, TY, TZ}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Grids/Grids.jl#L86-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.Bounded" href="#Oceananigans.Grids.Bounded"><code>Oceananigans.Grids.Bounded</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Bounded</code></pre><p>Grid topology for bounded dimensions, e.g., wall-bounded dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Grids/Grids.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.Center" href="#Oceananigans.Grids.Center"><code>Oceananigans.Grids.Center</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Center</code></pre><p>A type describing the location at the center of a grid cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Grids/Grids.jl#L29-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.Connected" href="#Oceananigans.Grids.Connected"><code>Oceananigans.Grids.Connected</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Connected</code></pre><p>Grid topology for dimensions that are connected to other models or domains on both sides.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Grids/Grids.jl#L72-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.Face" href="#Oceananigans.Grids.Face"><code>Oceananigans.Grids.Face</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Face</code></pre><p>A type describing the location at the face of a grid cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Grids/Grids.jl#L36-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.Flat" href="#Oceananigans.Grids.Flat"><code>Oceananigans.Grids.Flat</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Flat</code></pre><p>Grid topology for flat dimensions, generally with one grid point, along which the solution is uniform and does not vary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Grids/Grids.jl#L64-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.Periodic" href="#Oceananigans.Grids.Periodic"><code>Oceananigans.Grids.Periodic</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Periodic</code></pre><p>Grid topology for periodic dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Grids/Grids.jl#L50-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.RectilinearGrid" href="#Oceananigans.Grids.RectilinearGrid"><code>Oceananigans.Grids.RectilinearGrid</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RectilinearGrid{FT, TX, TY, TZ, FX, FY, FZ, VX, VY, VZ, Arch} &lt;: AbstractRectilinearGrid{FT, TX, TY, TZ}</code></pre><p>A rectilinear grid with with either constant or varying grid spacings between cell centers and cell faces in all directions. Grid elements of type <code>FT</code>, topology <code>{TX, TY, TZ}</code>, grid spacings of type <code>{FX, FY, FZ}</code> and coordinates in each direction of type <code>{VX, VY, VZ}</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Grids/rectilinear_grid.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.RectilinearGrid" href="#Oceananigans.Grids.RectilinearGrid"><code>Oceananigans.Grids.RectilinearGrid</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RectilinearGrid([FT = Float64];
                architecture = CPU(),
                size,
                x = nothing,
                y = nothing,
                z = nothing,
                halo = nothing,
                extent = nothing,
                topology = (Periodic, Periodic, Bounded))</code></pre><p>Creates a <code>RectilinearGrid</code> with <code>size = (Nx, Ny, Nz)</code> grid points.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>architecture</code>: Specifies whether the array of coordinates, interfaces, and spacings are stored                 on the CPU or GPU. Default: <code>architecture = CPU()</code>.</p></li><li><p><code>size</code> (required): A tuple prescribing the number of grid points in non-<code>Flat</code> directions.                    <code>size</code> is a 3-tuple for 3D models, a 2-tuple for 2D models, and either a                    scalar or 1-tuple for 1D models.</p></li><li><p><code>topology</code>: A 3-tuple <code>(TX, TY, TZ)</code> specifying the topology of the domain.             <code>TX</code>, <code>TY</code>, and <code>TZ</code> specify whether the <code>x</code>-, <code>y</code>-, and <code>z</code> directions are             <code>Periodic</code>, <code>Bounded</code>, or <code>Flat</code>. The topology <code>Flat</code> indicates that a model does             not vary in those directions so that derivatives and interpolation are zero.             The default is <code>topology = (Periodic, Periodic, Bounded)</code>.</p></li><li><p><code>extent</code>: A tuple prescribing the physical extent of the grid in non-<code>Flat</code> directions.           All directions are contructed with regular grid spacing and the domain (in the           case that no direction is <code>Flat</code>) is x âˆˆ (0, Lx), y âˆˆ (0, Ly), and z âˆˆ (-Lz, 0),            which is most appropriate for oceanic applications with z = 0 usually being the           ocean&#39;s surface.</p></li><li><p><code>x</code>, <code>y</code>, and <code>z</code>: Each of <code>x, y, z</code> are either (i) 2-tuples that specify the end points of the domain                    in their respect directions (in which case scalar values may be used in <code>Flat</code>                    directions), or (ii) arrays or functions of the corresponding indices <code>i</code>, <code>j</code>, or <code>k</code>                    that specify the locations of cell faces in the <code>x</code>-, <code>y</code>-, or <code>z</code>-direction, respectively.                    For example, to prescribe the cell faces in <code>z</code> we need to provide a function that takes                    <code>k</code> as argument and retuns the location of the faces for indices <code>k = 1</code> through <code>k = Nz + 1</code>,                    where <code>Nz</code> is the <code>size</code> of the stretched <code>z</code> dimension.</p></li></ul><p><em>Note</em>: <em>Either</em> <code>extent</code>, or all of <code>x</code>, <code>y</code>, and <code>z</code> must be specified.</p><ul><li><code>halo</code>: A tuple of integers that specifies the size of the halo region of cells surrounding         the physical interior for each non-<code>Flat</code> direction.</li></ul><p>The physical extent of the domain can be specified via <code>x</code>, <code>y</code>, and <code>z</code> keyword arguments indicating the left and right endpoints of each dimensions, e.g. <code>x = (-Ï€, Ï€)</code> or via the <code>extent</code> argument, e.g. <code>extent = (Lx, Ly, Lz)</code>, which specifies the extent of each dimension in which case 0 â‰¤ x â‰¤ Lx, 0 â‰¤ y â‰¤ Ly, and -Lz â‰¤ z â‰¤ 0.</p><p>A grid topology may be specified via a tuple assigning one of <code>Periodic</code>, <code>Bounded</code>, and <code>Flat</code> to each dimension. By default, a horizontally periodic grid topology <code>(Periodic, Periodic, Bounded)</code> is assumed.</p><p>Constants are stored using floating point values of type <code>FT</code>. By default this is <code>Float64</code>. Make sure to specify the desired <code>FT</code> if not using <code>Float64</code>.</p><p><strong>Grid properties</strong></p><ul><li><p><code>(Nx, Ny, Nz) :: Int</code>: Number of physical points in the <span>$(x, y, z)$</span>-direction.</p></li><li><p><code>(Hx, Hy, Hz) :: Int</code>: Number of halo points in the <span>$(x, y, z)$</span>-direction.</p></li><li><p><code>(Lx, Ly, Lz) :: FT</code>: Physical extent of the grid in the <span>$(x, y, z)$</span>-direction.</p></li><li><p><code>(Î”xá¶œáµƒáµƒ, Î”yáµƒá¶œáµƒ, Î”záµƒáµƒá¶œ)</code>: Grid spacing in the <span>$(x, y, z)$</span>-direction between cell centers.                          Defined at cell centers in <span>$x$</span>, <span>$y$</span>, and <span>$z$</span>.</p></li><li><p><code>(Î”xá¶ áµƒáµƒ, Î”yáµƒá¶ áµƒ, Î”záµƒáµƒá¶ )</code>: Grid spacing in the <span>$(x, y, z)$</span>-direction between cell faces.                          Defined at cell faces in <span>$x$</span>, <span>$y$</span>, and <span>$z$</span>.</p></li><li><p><code>(xá¶œáµƒáµƒ, yáµƒá¶œáµƒ, záµƒáµƒá¶œ)</code>: <span>$(x, y, z)$</span> coordinates of cell centers.</p></li><li><p><code>(xá¶ áµƒáµƒ, yáµƒá¶ áµƒ, záµƒáµƒá¶ )</code>: <span>$(x, y, z)$</span> coordinates of cell faces.</p></li></ul><p><strong>Examples</strong></p><ul><li>A default grid with <code>Float64</code> type:</li></ul><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = RectilinearGrid(size=(32, 32, 32), extent=(1, 2, 3))
RectilinearGrid{Float64, Periodic, Periodic, Bounded} on the CPU()
                   domain: x âˆˆ [0.0, 1.0], y âˆˆ [0.0, 2.0], z âˆˆ [-3.0, 0.0]
                 topology: (Periodic, Periodic, Bounded)
        size (Nx, Ny, Nz): (32, 32, 32)
        halo (Hx, Hy, Hz): (1, 1, 1)
                grid in x: Regular, with spacing 0.03125
                grid in y: Regular, with spacing 0.0625
                grid in z: Regular, with spacing 0.09375</code></pre><ul><li>A default grid with <code>Float32</code> type:</li></ul><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = RectilinearGrid(Float32; size=(32, 32, 16), x=(0, 8), y=(-10, 10), z=(-Ï€, Ï€))
RectilinearGrid{Float32, Periodic, Periodic, Bounded} on the CPU()
                   domain: x âˆˆ [0.0, 8.0], y âˆˆ [-10.0, 10.0], z âˆˆ [-3.1415927, 3.1415927]
                 topology: (Periodic, Periodic, Bounded)
        size (Nx, Ny, Nz): (32, 32, 16)
        halo (Hx, Hy, Hz): (1, 1, 1)
                grid in x: Regular, with spacing 0.25
                grid in y: Regular, with spacing 0.625
                grid in z: Regular, with spacing 0.3926991</code></pre><ul><li>A two-dimenisional, horizontally-periodic grid:</li></ul><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = RectilinearGrid(size=(32, 32), extent=(2Ï€, 4Ï€), topology=(Periodic, Periodic, Flat))
RectilinearGrid{Float64, Periodic, Periodic, Flat} on the CPU()
                   domain: x âˆˆ [0.0, 6.283185307179586], y âˆˆ [0.0, 12.566370614359172], z âˆˆ [1.0, 1.0]
                 topology: (Periodic, Periodic, Flat)
        size (Nx, Ny, Nz): (32, 32, 1)
        halo (Hx, Hy, Hz): (1, 1, 0)
                grid in x: Regular, with spacing 0.19634954084936207
                grid in y: Regular, with spacing 0.39269908169872414
                grid in z: Flattened</code></pre><ul><li>A one-dimensional &quot;column&quot; grid:</li></ul><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = RectilinearGrid(size=256, z=(-128, 0), topology=(Flat, Flat, Bounded))
RectilinearGrid{Float64, Flat, Flat, Bounded} on the CPU()
                   domain: x âˆˆ [1.0, 1.0], y âˆˆ [1.0, 1.0], z âˆˆ [-128.0, 0.0]
                 topology: (Flat, Flat, Bounded)
        size (Nx, Ny, Nz): (1, 1, 256)
        halo (Hx, Hy, Hz): (0, 0, 1)
                grid in x: Flattened
                grid in y: Flattened
                grid in z: Regular, with spacing 0.5</code></pre><ul><li>A horizontally-periodic regular grid with cell interfaces stretched hyperbolically near the top:</li></ul><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; Ïƒ = 1.1; # stretching factor

julia&gt; Nz = 24; # vertical resolution

julia&gt; Lz = 32; # depth (m)

julia&gt; hyperbolically_spaced_faces(k) = - Lz * (1 - tanh(Ïƒ * (k - 1) / Nz) / tanh(Ïƒ));

julia&gt; grid = RectilinearGrid(size = (32, 32, Nz),
                       x = (0, 64),
                       y = (0, 64),
                       z = hyperbolically_spaced_faces)
RectilinearGrid{Float64, Periodic, Periodic, Bounded} on the CPU()
                   domain: x âˆˆ [0.0, 64.0], y âˆˆ [0.0, 64.0], z âˆˆ [-32.0, -0.0]
                 topology: (Periodic, Periodic, Bounded)
        size (Nx, Ny, Nz): (32, 32, 24)
        halo (Hx, Hy, Hz): (1, 1, 1)
                grid in x: Regular, with spacing 2.0
                grid in y: Regular, with spacing 2.0
                grid in z: Stretched, with spacing min=0.6826950100338962, max=1.8309085743885056</code></pre><ul><li>A three-dimensional grid with regular spacing in x, cell interfaces that are closely spaced close to the boundaries in y (closely mimicing the Chebychev nodes) and cell interfaces stretched in z hyperbolically near the top:</li></ul><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; Nx, Ny, Nz = 32, 30, 24;

julia&gt; Lx, Ly, Lz = 200, 100, 32; # (m)

julia&gt; chebychev_like_spaced_faces(j) = - Ly/2 * cos(Ï€ * (j - 1) / Ny);

julia&gt; Ïƒ = 1.1; # stretching factor

julia&gt; hyperbolically_spaced_faces(k) = - Lz * (1 - tanh(Ïƒ * (k - 1) / Nz) / tanh(Ïƒ));

julia&gt; grid = RectilinearGrid(size = (Nx, Ny, Nz),
                              topology=(Periodic, Bounded, Bounded),
                              x = (0, Lx),
                              y = chebychev_like_spaced_faces,
                              z = hyperbolically_spaced_faces)
RectilinearGrid{Float64, Periodic, Bounded, Bounded} on the CPU()
                   domain: x âˆˆ [0.0, 200.0], y âˆˆ [-50.0, 50.0], z âˆˆ [-32.0, -0.0]
                 topology: (Periodic, Bounded, Bounded)
        size (Nx, Ny, Nz): (32, 30, 24)
        halo (Hx, Hy, Hz): (1, 1, 1)
                grid in x: Regular, with spacing 6.25
                grid in y: Stretched, with spacing min=0.2739052315863262, max=5.22642316338267
                grid in z: Stretched, with spacing min=0.6826950100338962, max=1.8309085743885056</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Grids/rectilinear_grid.jl#L40-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.new_data-NTuple{4, Any}" href="#Oceananigans.Grids.new_data-NTuple{4, Any}"><code>Oceananigans.Grids.new_data</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">new_data([FT=Float64], arch, grid, loc)</code></pre><p>Returns an <code>OffsetArray</code> of zeros of float type <code>FT</code> on <code>arch</code>itecture, with indices corresponding to a field on a <code>grid</code> of <code>size(grid)</code> and located at <code>loc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Grids/new_data.jl#L52-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.nodes-Tuple{Any, Oceananigans.Grids.AbstractGrid}" href="#Oceananigans.Grids.nodes-Tuple{Any, Oceananigans.Grids.AbstractGrid}"><code>Oceananigans.Grids.nodes</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nodes(loc, grid; reshape=false)</code></pre><p>Returns a 3-tuple of views over the interior nodes at the locations in <code>loc</code> in <code>x, y, z</code>.</p><p>If <code>reshape=true</code>, the views are reshaped to 3D arrays with non-singleton dimensions 1, 2, 3 for <code>x, y, z</code>, respectively. These reshaped arrays can then be used in broadcast operations with 3D fields or arrays.</p><p>See <code>xnodes</code>, <code>ynodes</code>, and <code>znodes</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Grids/grid_utils.jl#L246-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.offset_data-Tuple{Any, Oceananigans.Grids.AbstractGrid, Any}" href="#Oceananigans.Grids.offset_data-Tuple{Any, Oceananigans.Grids.AbstractGrid, Any}"><code>Oceananigans.Grids.offset_data</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">offset_data(underlying_data, grid::AbstractGrid, loc)</code></pre><p>Returns an <code>OffsetArray</code> that maps to <code>underlying_data</code> in memory, with offset indices appropriate for the <code>data</code> of a field on a <code>grid</code> of <code>size(grid)</code> and located at <code>loc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Grids/new_data.jl#L42-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.total_size-Tuple{Any, Any}" href="#Oceananigans.Grids.total_size-Tuple{Any, Any}"><code>Oceananigans.Grids.total_size</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">total_size(loc, grid)</code></pre><p>Returns the &quot;total&quot; size of a field at <code>loc</code> on <code>grid</code>. This is a 3-tuple of integers corresponding to the number of grid points contained by <code>f</code> along <code>x, y, z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Grids/grid_utils.jl#L32-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.xnodes-Tuple{Any, Any}" href="#Oceananigans.Grids.xnodes-Tuple{Any, Any}"><code>Oceananigans.Grids.xnodes</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">xnodes(loc, grid, reshape=false)</code></pre><p>Returns a view over the interior <code>loc=Center</code> or <code>loc=Face</code> nodes on <code>grid</code> in the x-direction. For <code>Bounded</code> directions, <code>Face</code> nodes include the boundary points. <code>reshape=false</code> will return a 1D array while <code>reshape=true</code> will return a 3D array with size NxÃ—1Ã—1.</p><p>See <code>znodes</code> for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Grids/grid_utils.jl#L164-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.ynodes-Tuple{Any, Any}" href="#Oceananigans.Grids.ynodes-Tuple{Any, Any}"><code>Oceananigans.Grids.ynodes</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ynodes(loc, grid, reshape=false)</code></pre><p>Returns a view over the interior <code>loc=Center</code> or <code>loc=Face</code> nodes on <code>grid</code> in the y-direction. For <code>Bounded</code> directions, <code>Face</code> nodes include the boundary points. <code>reshape=false</code> will return a 1D array while <code>reshape=true</code> will return a 3D array with size 1Ã—NyÃ—1.</p><p>See <code>znodes</code> for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Grids/grid_utils.jl#L183-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.znodes-Tuple{Any, Any}" href="#Oceananigans.Grids.znodes-Tuple{Any, Any}"><code>Oceananigans.Grids.znodes</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">znodes(loc, grid, reshape=false)</code></pre><p>Returns a view over the interior <code>loc=Center</code> or <code>loc=Face</code> nodes on <code>grid</code> in the z-direction. For <code>Bounded</code> directions, <code>Face</code> nodes include the boundary points. <code>reshape=false</code> will return a 1D array while <code>reshape=true</code> will return a 3D array with size 1Ã—1Ã—Nz.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; horz_periodic_grid = RectilinearGrid(size=(3, 3, 3), extent=(2Ï€, 2Ï€, 1),
                                                 topology=(Periodic, Periodic, Bounded));

julia&gt; zC = znodes(Center, horz_periodic_grid)
3-element view(OffsetArray(::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, 0:4), 1:3) with eltype Float64:
 -0.8333333333333331
 -0.4999999999999999
 -0.16666666666666652</code></pre><pre><code class="language-julia-repl hljs">julia&gt; zF = znodes(Face, horz_periodic_grid)
4-element view(OffsetArray(::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, 0:5), 1:4) with eltype Float64:
 -1.0
 -0.6666666666666666
 -0.33333333333333337
 -4.44089209850063e-17</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Grids/grid_utils.jl#L203-L237">source</a></section></article><h2 id="Immersed-boundaries"><a class="docs-heading-anchor" href="#Immersed-boundaries">Immersed boundaries</a><a id="Immersed-boundaries-1"></a><a class="docs-heading-anchor-permalink" href="#Immersed-boundaries" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.ImmersedBoundaries.AbstractImmersedBoundary" href="#Oceananigans.ImmersedBoundaries.AbstractImmersedBoundary"><code>Oceananigans.ImmersedBoundaries.AbstractImmersedBoundary</code></a> â€” <span class="docstring-category">Type</span></header><section><div><p>AbstractImmersedBoundary</p><p>Abstract supertype for immersed boundary grids.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/ImmersedBoundaries/ImmersedBoundaries.jl#L81-L85">source</a></section></article><h2 id="Lagrangian-particle-tracking"><a class="docs-heading-anchor" href="#Lagrangian-particle-tracking">Lagrangian particle tracking</a><a id="Lagrangian-particle-tracking-1"></a><a class="docs-heading-anchor-permalink" href="#Lagrangian-particle-tracking" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.LagrangianParticleTracking.LagrangianParticles-Tuple{StructArrays.StructArray}" href="#Oceananigans.LagrangianParticleTracking.LagrangianParticles-Tuple{StructArrays.StructArray}"><code>Oceananigans.LagrangianParticleTracking.LagrangianParticles</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LagrangianParticles(particles::StructArray; restitution=1.0, tracked_fields::NamedTuple=NamedTuple(), dynamics=no_dynamics)</code></pre><p>Construct some <code>LagrangianParticles</code> that can be passed to a model. The <code>particles</code> should be a <code>StructArray</code> and can contain custom fields. The coefficient of restitution for particle-wall collisions is specified by <code>restitution</code>.</p><p>A number of <code>tracked_fields</code> may be passed in as a <code>NamedTuple</code> of fields. Each particle will track the value of each field. Each tracked field must have a corresponding particle property. So if <code>T</code> is a tracked field, then <code>T</code> must also be a custom particle property.</p><p><code>dynamics</code> is a function of <code>(lagrangian_particles, model, Î”t)</code> that is called prior to advecting particles. <code>parameters</code> can be accessed inside the <code>dynamics</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/LagrangianParticleTracking/LagrangianParticleTracking.jl#L55-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.LagrangianParticleTracking.LagrangianParticles-Tuple{}" href="#Oceananigans.LagrangianParticleTracking.LagrangianParticles-Tuple{}"><code>Oceananigans.LagrangianParticleTracking.LagrangianParticles</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LagrangianParticles(; x, y, z, restitution=1.0, dynamics=no_dynamics, parameters=nothing)</code></pre><p>Construct some <code>LagrangianParticles</code> that can be passed to a model. The particles will have initial locations <code>x</code>, <code>y</code>, and <code>z</code>. The coefficient of restitution for particle-wall collisions is specified by <code>restitution</code>.</p><p><code>dynamics</code> is a function of <code>(lagrangian_particles, model, Î”t)</code> that is called prior to advecting particles. <code>parameters</code> can be accessed inside the <code>dynamics</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/LagrangianParticleTracking/LagrangianParticleTracking.jl#L34-L42">source</a></section></article><h2 id="Logger"><a class="docs-heading-anchor" href="#Logger">Logger</a><a id="Logger-1"></a><a class="docs-heading-anchor-permalink" href="#Logger" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Logger.OceananigansLogger" href="#Oceananigans.Logger.OceananigansLogger"><code>Oceananigans.Logger.OceananigansLogger</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OceananigansLogger(stream::IO=stdout, level=Logging.Info; show_info_source=false)</code></pre><p>Based on Logging.SimpleLogger, it tries to log all messages in the following format:</p><pre><code class="nohighlight hljs">[yyyy/mm/dd HH:MM:SS.sss] log_level message [-@-&gt; source_file:line_number]</code></pre><p>where the source of the message between the square brackets is included only if <code>show_info_source=true</code> or if the message is not an info level message.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Logger.jl#L26-L35">source</a></section></article><h2 id="Models"><a class="docs-heading-anchor" href="#Models">Models</a><a id="Models-1"></a><a class="docs-heading-anchor-permalink" href="#Models" title="Permalink"></a></h2><h3 id="Non-hydrostatic-models"><a class="docs-heading-anchor" href="#Non-hydrostatic-models">Non-hydrostatic models</a><a id="Non-hydrostatic-models-1"></a><a class="docs-heading-anchor-permalink" href="#Non-hydrostatic-models" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Models.NonhydrostaticModels.NonhydrostaticModel-Tuple{}" href="#Oceananigans.Models.NonhydrostaticModels.NonhydrostaticModel-Tuple{}"><code>Oceananigans.Models.NonhydrostaticModels.NonhydrostaticModel</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NonhydrostaticModel(;
               grid,
       architecture = CPU(),
              clock = Clock{eltype(grid)}(0, 0, 1),
          advection = CenteredSecondOrder(),
           buoyancy = nothing,
           coriolis = nothing,
       stokes_drift = nothing,
            forcing = NamedTuple(),
            closure = nothing,
boundary_conditions = NamedTuple(),
            tracers = (),
        timestepper = :QuasiAdamsBashforth2,
  background_fields = NamedTuple(),
          particles = nothing,
         velocities = nothing,
          pressures = nothing,
 diffusivity_fields = nothing,
    pressure_solver = nothing,
  immersed_boundary = nothing,
   auxiliary_fields = NamedTuple(),
)</code></pre><p>Construct a model for a non-hydrostatic, incompressible fluid, using the Boussinesq approximation when <code>buoyancy != nothing</code>. By default, all Bounded directions are rigid and impenetrable.</p><p><strong>Keyword arguments</strong></p><ul><li><code>grid</code>: (required) The resolution and discrete geometry on which <code>model</code> is solved.</li><li><code>architecture</code>: <code>CPU()</code> or <code>GPU()</code>. The computer architecture used to time-step <code>model</code>.</li><li><code>advection</code>: The scheme that advects velocities and tracers. See <code>Oceananigans.Advection</code>.</li><li><code>buoyancy</code>: The buoyancy model. See <code>Oceananigans.BuoyancyModels</code>.</li><li><code>closure</code>: The turbulence closure for <code>model</code>. See <code>Oceananigans.TurbulenceClosures</code>.</li><li><code>coriolis</code>: Parameters for the background rotation rate of the model.</li><li><code>forcing</code>: <code>NamedTuple</code> of user-defined forcing functions that contribute to solution tendencies.</li><li><code>boundary_conditions</code>: <code>NamedTuple</code> containing field boundary conditions.</li><li><code>tracers</code>: A tuple of symbols defining the names of the modeled tracers, or a <code>NamedTuple</code> of            preallocated <code>CenterField</code>s.</li><li><code>timestepper</code>: A symbol that specifies the time-stepping method. Either <code>:QuasiAdamsBashforth2</code> or                <code>:RungeKutta3</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L46-L88">source</a></section></article><h3 id="Hydrostatic-free-surface-models"><a class="docs-heading-anchor" href="#Hydrostatic-free-surface-models">Hydrostatic free-surface models</a><a id="Hydrostatic-free-surface-models-1"></a><a class="docs-heading-anchor-permalink" href="#Hydrostatic-free-surface-models" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Models.HydrostaticFreeSurfaceModels.HydrostaticFreeSurfaceModel-Tuple{}" href="#Oceananigans.Models.HydrostaticFreeSurfaceModels.HydrostaticFreeSurfaceModel-Tuple{}"><code>Oceananigans.Models.HydrostaticFreeSurfaceModels.HydrostaticFreeSurfaceModel</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HydrostaticFreeSurfaceModel(;
               grid,
       architecture = CPU(),
              clock = Clock{eltype(grid)}(0, 0, 1),
 momentum_advection = CenteredSecondOrder(),
   tracer_advection = CenteredSecondOrder(),
           buoyancy = SeawaterBuoyancy(eltype(grid)),
           coriolis = nothing,
            forcing = NamedTuple(),
            closure = IsotropicDiffusivity(eltype(grid), Î½=Î½â‚€, Îº=Îºâ‚€),
boundary_conditions = NamedTuple(),
            tracers = (:T, :S),
          particles = nothing,
         velocities = nothing,
           pressure = nothing,
 diffusivity_fields = nothing,
   auxiliary_fields = NamedTuple(),
)</code></pre><p>Construct an hydrostatic <code>Oceananigans.jl</code> model with a free surface on <code>grid</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>grid</code>: (required) The resolution and discrete geometry on which <code>model</code> is solved.</li><li><code>architecture</code>: <code>CPU()</code> or <code>GPU()</code>. The computer architecture used to time-step <code>model</code>.</li><li><code>gravitational_acceleration</code>: The gravitational acceleration applied to the free surface</li><li><code>advection</code>: The scheme that advects velocities and tracers. See <code>Oceananigans.Advection</code>.</li><li><code>buoyancy</code>: The buoyancy model. See <code>Oceananigans.BuoyancyModels</code>.</li><li><code>closure</code>: The turbulence closure for <code>model</code>. See <code>Oceananigans.TurbulenceClosures</code>.</li><li><code>coriolis</code>: Parameters for the background rotation rate of the model.</li><li><code>forcing</code>: <code>NamedTuple</code> of user-defined forcing functions that contribute to solution tendencies.</li><li><code>boundary_conditions</code>: <code>NamedTuple</code> containing field boundary conditions.</li><li><code>tracers</code>: A tuple of symbols defining the names of the modeled tracers, or a <code>NamedTuple</code> of            preallocated <code>CenterField</code>s.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl#L50-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Models.HydrostaticFreeSurfaceModels.ImplicitFreeSurface-Tuple{}" href="#Oceananigans.Models.HydrostaticFreeSurfaceModels.ImplicitFreeSurface-Tuple{}"><code>Oceananigans.Models.HydrostaticFreeSurfaceModels.ImplicitFreeSurface</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ImplicitFreeSurface(; solver_method=:Default, gravitational_acceleration=g_Earth, solver_settings...)</code></pre><p>The implicit free surface equation is</p><p class="math-container">\[(âˆ‡Ê° â‹… H âˆ‡Ê° - 1 / (g Î”tÂ²)) Î·â¿âºÂ¹ = âˆ‡Ê° â‹… Qâ˜… / (g Î”t) - Î·â¿ / (g Î”tÂ²) ,\]</p><p>where <span>$H$</span> is depth, <span>$g$</span> is gravitational acceleration, <span>$Î”t$</span> is time step, and <span>$Qâ˜…$</span> is the barotropic volume flux associated with the predictor velocity field.</p><p>This equation can be solved in general using the <code>PreconditionedConjugateGradientSolver</code>.</p><p>In the case that <span>$H$</span> is constant, we divide through to obtain</p><p class="math-container">\[(âˆ‡Â² - 1 / (g H Î”tÂ²)) Î·â¿âºÂ¹ = 1 / (g H Î”t) * (âˆ‡Ê° â‹… Qâ˜… - Î·â¿ / Î”t) ,\]</p><p>The above can be solved with the <code>FFTImplicitFreeSurfaceSolver</code> on grids with regular spacing in <span>$x$</span> and <span>$y$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl#L21-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Models.HydrostaticFreeSurfaceModels.PrescribedVelocityFields-Tuple{}" href="#Oceananigans.Models.HydrostaticFreeSurfaceModels.PrescribedVelocityFields-Tuple{}"><code>Oceananigans.Models.HydrostaticFreeSurfaceModels.PrescribedVelocityFields</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PrescribedVelocityFields(; u=zerofunc, v=zerofunc, w=zerofunc, parameters=nothing)</code></pre><p>Builds <code>PrescribedVelocityFields</code> with prescribed functions <code>u</code>, <code>v</code>, and <code>w</code>.</p><p>If <code>isnothing(parameters)</code>, then <code>u, v, w</code> are called with the signature</p><pre><code class="nohighlight hljs">`u(x, y, z, t) = # something interesting`</code></pre><p>If <code>!isnothing(parameters)</code>, then <code>u, v, w</code> are called with the signature</p><pre><code class="nohighlight hljs">`u(x, y, z, t, parameters) = # something parameterized and interesting`</code></pre><p>In the constructor for <code>HydrostaticFreeSurfaceModel</code>, the functions <code>u, v, w</code> are wrapped in <code>FunctionField</code> and associated with the model&#39;s <code>grid</code> and <code>clock</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Models/HydrostaticFreeSurfaceModels/prescribed_hydrostatic_velocity_fields.jl#L24-L39">source</a></section></article><h3 id="Shallow-water-models"><a class="docs-heading-anchor" href="#Shallow-water-models">Shallow-water models</a><a id="Shallow-water-models-1"></a><a class="docs-heading-anchor-permalink" href="#Shallow-water-models" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Models.ShallowWaterModels.ShallowWaterModel-Tuple{}" href="#Oceananigans.Models.ShallowWaterModels.ShallowWaterModel-Tuple{}"><code>Oceananigans.Models.ShallowWaterModels.ShallowWaterModel</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ShallowWaterModel(;
                           grid,
                           gravitational_acceleration,
  architecture::AbstractArchitecture = CPU(),
                               clock = Clock{eltype(grid)}(0, 0, 1),
                           advection = UpwindBiasedFifthOrder(),
                            coriolis = nothing,
                 forcing::NamedTuple = NamedTuple(),
                             closure = nothing,
                          bathymetry = nothing,
                             tracers = (),
                  diffusivity_fields = nothing,
     boundary_conditions::NamedTuple = NamedTuple(),
                 timestepper::Symbol = :RungeKutta3)</code></pre><p>Construct a shallow water <code>Oceananigans.jl</code> model on <code>grid</code> with <code>gravitational_acceleration</code> constant.</p><p><strong>Keyword arguments</strong></p><ul><li><code>grid</code>: (required) The resolution and discrete geometry on which <code>model</code> is solved.</li><li><code>gravitational_acceleration</code>: (required) The gravitational accelaration constant.</li><li><code>architecture</code>: <code>CPU()</code> or <code>GPU()</code>. The computer architecture used to time-step <code>model</code>.</li><li><code>clock</code>: The <code>clock</code> for the model</li><li><code>advection</code>: The scheme that advects velocities and tracers. See <code>Oceananigans.Advection</code>.</li><li><code>coriolis</code>: Parameters for the background rotation rate of the model.</li><li><code>forcing</code>: <code>NamedTuple</code> of user-defined forcing functions that contribute to solution tendencies.</li><li><code>bathymetry</code>: The bottom bathymetry.</li><li><code>tracers</code>: A tuple of symbols defining the names of the modeled tracers, or a <code>NamedTuple</code> of            preallocated <code>CenterField</code>s.</li><li><code>diffusivity_fields</code>: Stores diffusivity fields when the closures require a diffusivity to be                       calculated at each timestep.</li><li><code>boundary_conditions</code>: <code>NamedTuple</code> containing field boundary conditions.</li><li><code>timestepper</code>: A symbol that specifies the time-stepping method. Either <code>:QuasiAdamsBashforth2</code>,                <code>:RungeKutta3</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Models/ShallowWaterModels/shallow_water_model.jl#L50-L86">source</a></section></article><h2 id="Output-readers"><a class="docs-heading-anchor" href="#Output-readers">Output readers</a><a id="Output-readers-1"></a><a class="docs-heading-anchor-permalink" href="#Output-readers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputReaders.FieldDataset-Tuple{Any}" href="#Oceananigans.OutputReaders.FieldDataset-Tuple{Any}"><code>Oceananigans.OutputReaders.FieldDataset</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FieldDataset(filepath; architecture=CPU(), grid=nothing, backend=InMemory(), metadata_paths=[&quot;metadata&quot;])</code></pre><p>Returns a <code>Dict</code> containing a <code>FieldTimeSeries</code> for each field in the JLD2 file located at <code>filepath</code>. Note that model output must have been saved with halos. The <code>InMemory</code> backend will store the data fully in memory as a 4D multi-dimensional array while the <code>OnDisk</code> backend will lazily load field time snapshots when the <code>FieldTimeSeries</code> is indexed linearly.</p><p><code>metadata_paths</code> is a list of JLD2 paths to look for metadata. By default it looks in <code>file[&quot;metadata&quot;]</code>.</p><p>A <code>grid</code> and <code>ArrayType</code> may be specified to override the grid and array type used in the JLD file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/OutputReaders/field_dataset.jl#L7-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputReaders.FieldTimeSeries-Tuple{Any, Any}" href="#Oceananigans.OutputReaders.FieldTimeSeries-Tuple{Any, Any}"><code>Oceananigans.OutputReaders.FieldTimeSeries</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FieldTimeSeries(path, name;
                architecture = CPU(),
                backend = InMemory(),
                grid = nothing,
                iterations = nothing,
                times = nothing)</code></pre><p>Returns a <code>FieldTimeSeries</code> for the field <code>name</code> describing a field&#39;s time history from a JLD2 file located at <code>path</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>architecture</code>: The architecture on which to store time series data. <code>CPU()</code> by default.</p></li><li><p><code>backend</code>: <code>InMemory()</code> to load data into a 4D array or <code>OnDisk()</code> to lazily load data from disk            when indexing into <code>FieldTimeSeries</code>.</p></li><li><p><code>grid</code>: A grid to associated with data, in the case that the native grid         was not serialized properly.</p></li><li><p><code>iterations</code>: Iterations to load. Defaults to all iterations found in the file.</p></li><li><p><code>times</code>: Save times to load, as determined through an approximate floating point          comparison to recorded save times. Defaults to times associated with <code>iterations</code>.          Takes precedence over <code>iterations</code> if <code>times</code> is specified.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/OutputReaders/field_time_series.jl#L52-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputReaders.FieldTimeSeries-Union{Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Any, Any, Any}, NTuple{4, Any}} where {LX, LY, LZ}" href="#Oceananigans.OutputReaders.FieldTimeSeries-Union{Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Any, Any, Any}, NTuple{4, Any}} where {LX, LY, LZ}"><code>Oceananigans.OutputReaders.FieldTimeSeries</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FieldTimeSeries{LX, LY, LZ}([architecture = CPU()], grid, times, boundary_conditions=nothing)</code></pre><p>Return <code>FieldTimeSeries</code> at location <code>(LX, LY, LZ)</code>, on <code>grid</code>, at <code>times</code>, with <code>boundary_conditions</code>, and initialized with zeros of <code>eltype(grid)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/OutputReaders/field_time_series.jl#L33-L38">source</a></section></article><h2 id="Output-writers"><a class="docs-heading-anchor" href="#Output-writers">Output writers</a><a id="Output-writers-1"></a><a class="docs-heading-anchor-permalink" href="#Output-writers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.AveragedTimeInterval" href="#Oceananigans.OutputWriters.AveragedTimeInterval"><code>Oceananigans.OutputWriters.AveragedTimeInterval</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct AveragedTimeInterval &lt;: AbstractSchedule</code></pre><p>Container for parameters that configure and handle time-averaged output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/OutputWriters/windowed_time_average.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.AveragedTimeInterval-Tuple{Any}" href="#Oceananigans.OutputWriters.AveragedTimeInterval-Tuple{Any}"><code>Oceananigans.OutputWriters.AveragedTimeInterval</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AveragedTimeInterval(interval; window=interval, stride=1)</code></pre><p>Returns a <code>schedule</code> that specifies periodic time-averaging of output. The time <code>window</code> specifies the extent of the time-average, which reoccurs every <code>interval</code>.</p><p><code>output</code> is computed and accumulated into the average every <code>stride</code> iterations during the averaging window. For example, <code>stride=1</code> computs output every iteration, whereas <code>stride=2</code> computes output every other iteration. Time-averages with longer <code>stride</code>s are faster to compute, but less accurate.</p><p>The time-average of <span>$a$</span> is a left Riemann sum corresponding to</p><p><span>$âŸ¨aâŸ© = 1/T \int_{táµ¢-T}^T a \mathrm{d} t ,$</span></p><p>where <span>$âŸ¨aâŸ©$</span> is the time-average of <span>$a$</span>, <span>$T$</span> is the time-window for averaging, and the <span>$táµ¢$</span> are discrete times separated by the time <code>interval</code>. The <span>$táµ¢$</span> specify both the end of the averaging window and the time at which output is written.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Oceananigans.OutputWriters: AveragedTimeInterval
using Oceananigans.Utils: year, years

schedule = AveragedTimeInterval(4years, window=1year)

# output
AveragedTimeInterval(window=1 year, stride=1, interval=4 years)</code></pre><p>An <code>AveragedTimeInterval</code> schedule directs an output writer to time-average its outputs before writing them to disk:</p><pre><code class="language-julia hljs">using Oceananigans
using Oceananigans.OutputWriters: JLD2OutputWriter
using Oceananigans.Utils: minutes

model = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)))

simulation = Simulation(model, Î”t=10minutes, stop_time=30years)

simulation.output_writers[:velocities] = JLD2OutputWriter(model, model.velocities,
                                                          prefix = &quot;averaged_velocity_data&quot;,
                                                          schedule = AveragedTimeInterval(4years, window=1year, stride=2))

# output
JLD2OutputWriter scheduled on TimeInterval(4 years):
â”œâ”€â”€ filepath: ./averaged_velocity_data.jld2
â”œâ”€â”€ 3 outputs: (:u, :v, :w) averaged on AveragedTimeInterval(window=1 year, stride=2, interval=4 years)
â”œâ”€â”€ field slicer: FieldSlicer(:, :, :, with_halos=false)
â”œâ”€â”€ array type: Array{Float32}
â”œâ”€â”€ including: [:grid, :coriolis, :buoyancy, :closure]
â””â”€â”€ max filesize: Inf YiB</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/OutputWriters/windowed_time_average.jl#L23-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.Checkpointer-Tuple{Any}" href="#Oceananigans.OutputWriters.Checkpointer-Tuple{Any}"><code>Oceananigans.OutputWriters.Checkpointer</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Checkpointer(model; schedule,
                    dir = &quot;.&quot;,
                 prefix = &quot;checkpoint&quot;,
                  force = false,
                verbose = false,
                cleanup = false,
             properties = [:architecture, :grid, :clock, :coriolis,
                           :buoyancy, :closure, :velocities, :tracers,
                           :timestepper, :particles]
            )</code></pre><p>Construct a <code>Checkpointer</code> that checkpoints the model to a JLD2 file on <code>schedule.</code> The <code>model.clock.iteration</code> is included in the filename to distinguish between multiple checkpoint files.</p><p>To restart or &quot;pickup&quot; a model from a checkpoint, specify <code>pickup=true</code> when calling <code>run!</code>, ensuring that the checkpoint file is the current working directory. See </p><pre><code class="language-julia hljs">help&gt; run!</code></pre><p>for more details.</p><p>Note that extra model <code>properties</code> can be safely specified, but removing crucial properties such as <code>:velocities</code> will make restoring from the checkpoint impossible.</p><p>The checkpointer attempts to serialize as much of the model to disk as possible, but functions or objects containing functions cannot be serialized at this time.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>schedule</code> (required): Schedule that determines when to checkpoint.</p></li><li><p><code>dir</code>: Directory to save output to. Default: &quot;.&quot; (current working directory).</p></li><li><p><code>prefix</code>: Descriptive filename prefixed to all output files. Default: &quot;checkpoint&quot;.</p></li><li><p><code>force</code>: Remove existing files if their filenames conflict. Default: <code>false</code>.</p></li><li><p><code>verbose</code>: Log what the output writer is doing with statistics on compute/write times            and file sizes. Default: <code>false</code>.</p></li><li><p><code>cleanup</code>: Previous checkpoint files will be deleted once a new checkpoint file is written.            Default: <code>false</code>.</p></li><li><p><code>properties</code>: List of model properties to checkpoint. Some are required.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/OutputWriters/checkpointer.jl#L17-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.JLD2OutputWriter" href="#Oceananigans.OutputWriters.JLD2OutputWriter"><code>Oceananigans.OutputWriters.JLD2OutputWriter</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">JLD2OutputWriter{I, T, O, IF, IN, KW} &lt;: AbstractOutputWriter</code></pre><p>An output writer for writing to JLD2 files.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/OutputWriters/jld2_output_writer.jl#L13-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.JLD2OutputWriter-Tuple{Any, Any}" href="#Oceananigans.OutputWriters.JLD2OutputWriter-Tuple{Any, Any}"><code>Oceananigans.OutputWriters.JLD2OutputWriter</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">JLD2OutputWriter(model, outputs; prefix, schedule,
                          dir = &quot;.&quot;,
                 field_slicer = FieldSlicer(),
                   array_type = Array{Float32},
                 max_filesize = Inf,
                        force = false,
                         init = noinit,
                    including = [:grid, :coriolis, :buoyancy, :closure],
                      verbose = false,
                         part = 1,
                      jld2_kw = Dict{Symbol, Any}())</code></pre><p>Construct a <code>JLD2OutputWriter</code> for an Oceananigans <code>model</code> that writes <code>label, output</code> pairs in <code>outputs</code> to a JLD2 file.</p><p>The argument <code>outputs</code> may be a <code>Dict</code> or <code>NamedTuple</code>. The keys of <code>outputs</code> are symbols or strings that &quot;name&quot; output data. The values of <code>outputs</code> are either <code>AbstractField</code>s, objects that are called with the signature <code>output(model)</code>, or <code>WindowedTimeAverage</code>s of <code>AbstractFields</code>s, functions, or callable objects.</p><p><strong>Keyword arguments</strong></p><p><strong>Filenaming</strong></p><ul><li><p><code>prefix</code> (required): Descriptive filename prefixed to all output files.</p></li><li><p><code>dir</code>: Directory to save output to.        Default: &quot;.&quot; (current working directory).</p></li></ul><p><strong>Output frequency and time-averaging</strong></p><ul><li><code>schedule</code> (required): <code>AbstractSchedule</code> that determines when output is saved.</li></ul><p><strong>Slicing and type conversion prior to output</strong></p><ul><li><p><code>field_slicer</code>: An object for slicing field output in <span>$(x, y, z)$</span>, including omitting halos.                 Has no effect on output that is not a field. <code>field_slicer = nothing</code> means                 no slicing occurs, so that all field data, including halo regions, is saved.                 Default: <code>FieldSlicer()</code>, which slices halo regions.</p></li><li><p><code>array_type</code>: The array type to which output arrays are converted to prior to saving.               Default: <code>Array{Float32}</code>.</p></li></ul><p><strong>File management</strong></p><ul><li><p><code>max_filesize</code>: The writer will stop writing to the output file once the file size exceeds <code>max_filesize</code>,                 and write to a new one with a consistent naming scheme ending in <code>part1</code>, <code>part2</code>, etc.                 Defaults to <code>Inf</code>.</p></li><li><p><code>force</code>: Remove existing files if their filenames conflict.          Default: <code>false</code>.</p></li></ul><p><strong>Output file metadata management</strong></p><ul><li><p><code>init</code>: A function of the form <code>init(file, model)</code> that runs when a JLD2 output file is initialized.         Default: <code>noinit(args...) = nothing</code>.</p></li><li><p><code>including</code>: List of model properties to save with every file.              Default: <code>[:grid, :coriolis, :buoyancy, :closure]</code></p></li></ul><p><strong>Miscellaneous keywords</strong></p><ul><li><p><code>verbose</code>: Log what the output writer is doing with statistics on compute/write times and file sizes.            Default: <code>false</code>.</p></li><li><p><code>part</code>: The starting part number used if <code>max_filesize</code> is finite.         Default: 1.</p></li><li><p><code>jld2_kw</code>: Dict of kwargs to be passed to <code>jldopen</code> when data is written.</p></li></ul><p><strong>Example</strong></p><p>Write out 3D fields for u, v, w, and a tracer c, along with a horizontal average:</p><pre><code class="language-julia hljs">using Oceananigans
using Oceananigans.Utils: hour, minute

model = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)), tracers=(:c,))
simulation = Simulation(model, Î”t=12, stop_time=1hour)

function init_save_some_metadata!(file, model)
    file[&quot;author&quot;] = &quot;Chim Riggles&quot;
    file[&quot;parameters/coriolis_parameter&quot;] = 1e-4
    file[&quot;parameters/density&quot;] = 1027
    return nothing
end

c_avg =  AveragedField(model.tracers.c, dims=(1, 2))

# Note that model.velocities is NamedTuple
simulation.output_writers[:velocities] = JLD2OutputWriter(model, model.velocities,
                                                          prefix = &quot;some_data&quot;,
                                                          schedule = TimeInterval(20minute),
                                                          init = init_save_some_metadata!)

# output
JLD2OutputWriter scheduled on TimeInterval(20 minutes):
â”œâ”€â”€ filepath: ./some_data.jld2
â”œâ”€â”€ 3 outputs: (:u, :v, :w)
â”œâ”€â”€ field slicer: FieldSlicer(:, :, :, with_halos=false)
â”œâ”€â”€ array type: Array{Float32}
â”œâ”€â”€ including: [:grid, :coriolis, :buoyancy, :closure]
â””â”€â”€ max filesize: Inf YiB</code></pre><p>and a time- and horizontal-average of tracer <code>c</code> every 20 minutes of simulation time to a file called <code>some_averaged_data.jld2</code></p><pre><code class="language-julia hljs">simulation.output_writers[:avg_c] = JLD2OutputWriter(model, (; c=c_avg),
                                                     prefix = &quot;some_averaged_data&quot;,
                                                     schedule = AveragedTimeInterval(20minute, window=5minute))

# output
JLD2OutputWriter scheduled on TimeInterval(20 minutes):
â”œâ”€â”€ filepath: ./some_averaged_data.jld2
â”œâ”€â”€ 1 outputs: (:c,) averaged on AveragedTimeInterval(window=5 minutes, stride=1, interval=20 minutes)
â”œâ”€â”€ field slicer: FieldSlicer(:, :, :, with_halos=false)
â”œâ”€â”€ array type: Array{Float32}
â”œâ”€â”€ including: [:grid, :coriolis, :buoyancy, :closure]
â””â”€â”€ max filesize: Inf YiB</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/OutputWriters/jld2_output_writer.jl#L35-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.NetCDFOutputWriter" href="#Oceananigans.OutputWriters.NetCDFOutputWriter"><code>Oceananigans.OutputWriters.NetCDFOutputWriter</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NetCDFOutputWriter{D, O, I, T, S} &lt;: AbstractOutputWriter</code></pre><p>An output writer for writing to NetCDF files.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/OutputWriters/netcdf_output_writer.jl#L114-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.NetCDFOutputWriter-Tuple{Any, Any}" href="#Oceananigans.OutputWriters.NetCDFOutputWriter-Tuple{Any, Any}"><code>Oceananigans.OutputWriters.NetCDFOutputWriter</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NetCDFOutputWriter(model, outputs; filepath, schedule
                               array_type = Array{Float32},
                             field_slicer = FieldSlicer(),
                        global_attributes = Dict(),
                        output_attributes = Dict(),
                               dimensions = Dict(),
                                     mode = nothing,
                              compression = 0,
                                  verbose = false)</code></pre><p>Construct a <code>NetCDFOutputWriter</code> that writes <code>(label, output)</code> pairs in <code>outputs</code> (which should be a <code>Dict</code>) to a NetCDF file, where <code>label</code> is a string that labels the output and <code>output</code> is either a <code>Field</code> (e.g. <code>model.velocities.u</code> or an <code>AveragedField</code>) or a function <code>f(model)</code> that returns something to be written to disk. Custom output requires the spatial <code>dimensions</code> (a <code>Dict</code>) to be manually specified (see examples).</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>filepath</code> (required): Filepath to save output to.</p></li><li><p><code>schedule</code> (required): <code>AbstractSchedule</code> that determines when output is saved.</p></li><li><p><code>array_type</code>: The array type to which output arrays are converted to prior to saving.               Default: Array{Float32}.</p></li><li><p><code>field_slicer</code>: An object for slicing field output in <span>$(x, y, z)$</span>, including omitting halos,                 which can be done with the keyword <code>with_halos</code>.                 Has no effect on output that is not a field. <code>field_slicer = nothing</code> means                 no slicing occurs, so that all field data, including halo regions, is saved.                 Default: <code>FieldSlicer()</code>, which slices halo regions.</p></li><li><p><code>global_attributes</code>: Dict of model properties to save with every file (deafult: <code>Dict()</code>)</p></li><li><p><code>output_attributes</code>: Dict of attributes to be saved with each field variable (reasonable                      defaults are provided for velocities, buoyancy, temperature, and salinity;                      otherwise <code>output_attributes</code> <em>must</em> be user-provided).</p></li><li><p><code>dimensions</code>: A <code>Dict</code> of dimension tuples to apply to outputs (required for function outputs)</p></li><li><p><code>mode</code>: &quot;a&quot; (for append) and &quot;c&quot; (for clobber or create). Default: &quot;c&quot;. See NCDatasets.jl         documentation for more information on the <code>mode</code> option.</p></li><li><p><code>compression</code>: Determines the compression level of data (0-9, default 0)</p></li></ul><p><strong>Examples</strong></p><p>Saving the u velocity field and temperature fields, the full 3D fields and surface 2D slices to separate NetCDF files:</p><pre><code class="language-julia hljs">using Oceananigans

grid = RectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1));

model = NonhydrostaticModel(grid=grid, tracers=:c);

simulation = Simulation(model, Î”t=12, stop_time=3600);

fields = Dict(&quot;u&quot; =&gt; model.velocities.u, &quot;c&quot; =&gt; model.tracers.c);

simulation.output_writers[:field_writer] =
    NetCDFOutputWriter(model, fields, filepath=&quot;fields.nc&quot;, schedule=TimeInterval(60))

# output
NetCDFOutputWriter scheduled on TimeInterval(1 minute):
â”œâ”€â”€ filepath: fields.nc
â”œâ”€â”€ dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0)
â”œâ”€â”€ 2 outputs: [&quot;c&quot;, &quot;u&quot;]
â”œâ”€â”€ field slicer: FieldSlicer(:, :, :, with_halos=false)
â””â”€â”€ array type: Array{Float32}</code></pre><pre><code class="language-julia hljs">simulation.output_writers[:surface_slice_writer] =
    NetCDFOutputWriter(model, fields, filepath=&quot;surface_xy_slice.nc&quot;,
                       schedule=TimeInterval(60), field_slicer=FieldSlicer(k=grid.Nz))

# output
NetCDFOutputWriter scheduled on TimeInterval(1 minute):
â”œâ”€â”€ filepath: surface_xy_slice.nc
â”œâ”€â”€ dimensions: zC(1), zF(1), xC(16), yF(16), xF(16), yC(16), time(0)
â”œâ”€â”€ 2 outputs: [&quot;c&quot;, &quot;u&quot;]
â”œâ”€â”€ field slicer: FieldSlicer(:, :, 16, with_halos=false)
â””â”€â”€ array type: Array{Float32}</code></pre><pre><code class="language-julia hljs">simulation.output_writers[:averaged_profile_writer] =
    NetCDFOutputWriter(model, fields,
                       filepath = &quot;averaged_z_profile.nc&quot;,
                       schedule = AveragedTimeInterval(60, window=20),
                       field_slicer = FieldSlicer(i=1, j=1))

# output
NetCDFOutputWriter scheduled on TimeInterval(1 minute):
â”œâ”€â”€ filepath: averaged_z_profile.nc
â”œâ”€â”€ dimensions: zC(16), zF(17), xC(1), yF(1), xF(1), yC(1), time(0)
â”œâ”€â”€ 2 outputs: [&quot;c&quot;, &quot;u&quot;] averaged on AveragedTimeInterval(window=20 seconds, stride=1, interval=1 minute)
â”œâ”€â”€ field slicer: FieldSlicer(1, 1, :, with_halos=false)
â””â”€â”€ array type: Array{Float32}</code></pre><p><code>NetCDFOutputWriter</code> also accepts output functions that write scalars and arrays to disk, provided that their <code>dimensions</code> are provided:</p><pre><code class="language-julia hljs">using Oceananigans

grid = RectilinearGrid(size=(16, 16, 16), extent=(1, 2, 3));

model = NonhydrostaticModel(grid=grid);

simulation = Simulation(model, Î”t=1.25, stop_iteration=3);

f(model) = model.clock.time^2; # scalar output

g(model) = model.clock.time .* exp.(znodes(Center, grid)); # vector/profile output

h(model) = model.clock.time .* (   sin.(xnodes(Center, grid, reshape=true)[:, :, 1])
                            .*     cos.(ynodes(Face, grid, reshape=true)[:, :, 1])); # xy slice output

outputs = Dict(&quot;scalar&quot; =&gt; f, &quot;profile&quot; =&gt; g, &quot;slice&quot; =&gt; h);

dims = Dict(&quot;scalar&quot; =&gt; (), &quot;profile&quot; =&gt; (&quot;zC&quot;,), &quot;slice&quot; =&gt; (&quot;xC&quot;, &quot;yC&quot;));

output_attributes = Dict(
    &quot;scalar&quot;  =&gt; Dict(&quot;longname&quot; =&gt; &quot;Some scalar&quot;, &quot;units&quot; =&gt; &quot;bananas&quot;),
    &quot;profile&quot; =&gt; Dict(&quot;longname&quot; =&gt; &quot;Some vertical profile&quot;, &quot;units&quot; =&gt; &quot;watermelons&quot;),
    &quot;slice&quot;   =&gt; Dict(&quot;longname&quot; =&gt; &quot;Some slice&quot;, &quot;units&quot; =&gt; &quot;mushrooms&quot;)
);

global_attributes = Dict(&quot;location&quot; =&gt; &quot;Bay of Fundy&quot;, &quot;onions&quot; =&gt; 7);

simulation.output_writers[:things] =
    NetCDFOutputWriter(model, outputs,
                       schedule=IterationInterval(1), filepath=&quot;things.nc&quot;, dimensions=dims, verbose=true,
                       global_attributes=global_attributes, output_attributes=output_attributes)

# output
NetCDFOutputWriter scheduled on IterationInterval(1):
â”œâ”€â”€ filepath: things.nc
â”œâ”€â”€ dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0)
â”œâ”€â”€ 3 outputs: [&quot;profile&quot;, &quot;slice&quot;, &quot;scalar&quot;]
â”œâ”€â”€ field slicer: FieldSlicer(:, :, :, with_halos=false)
â””â”€â”€ array type: Array{Float32}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/OutputWriters/netcdf_output_writer.jl#L131-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.WindowedTimeAverage" href="#Oceananigans.OutputWriters.WindowedTimeAverage"><code>Oceananigans.OutputWriters.WindowedTimeAverage</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WindowedTimeAverage{OP, R, FS} &lt;: AbstractDiagnostic</code></pre><p>An object for computing &#39;windowed&#39; time averages, or moving time-averages of a <code>operand</code> over a specified <code>window</code>, collected on <code>interval</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/OutputWriters/windowed_time_average.jl#L97-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.WindowedTimeAverage" href="#Oceananigans.OutputWriters.WindowedTimeAverage"><code>Oceananigans.OutputWriters.WindowedTimeAverage</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WindowedTimeAverage(operand, model=nothing; schedule, field_slicer=FieldSlicer())</code></pre><p>Returns an object for computing running averages of <code>operand</code> over <code>schedule.window</code> and recurring on <code>schedule.interval</code>, where <code>schedule</code> is an <code>AveragedTimeInterval</code>. During the collection period, averages are computed every <code>schedule.stride</code> iteration.</p><p><code>operand</code> may be a <code>Oceananigans.Field</code> or a function that returns an array or scalar.</p><p>Calling <code>wta(model)</code> for <code>wta::WindowedTimeAverage</code> object returns <code>wta.result</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/OutputWriters/windowed_time_average.jl#L113-L123">source</a></section></article><h2 id="Simulations"><a class="docs-heading-anchor" href="#Simulations">Simulations</a><a id="Simulations-1"></a><a class="docs-heading-anchor-permalink" href="#Simulations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Simulations.Callback-Tuple{Any}" href="#Oceananigans.Simulations.Callback-Tuple{Any}"><code>Oceananigans.Simulations.Callback</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Callback(func, schedule)</code></pre><p>Return <code>Callback</code> that executes <code>func(sim::Simulation)</code> on <code>schedule</code>.</p><p><code>schedule = IterationInterval(1)</code> by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Simulations/callback.jl#L8-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Simulations.Simulation-Tuple{Any}" href="#Oceananigans.Simulations.Simulation-Tuple{Any}"><code>Oceananigans.Simulations.Simulation</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Simulation(model; Î”t,
           stop_iteration = Inf,
           stop_time = Inf,
           wall_time_limit = Inf)</code></pre><p>Construct a <code>Simulation</code> for a <code>model</code> with time step <code>Î”t</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>Î”t</code>: Required keyword argument specifying the simulation time step. Can be a <code>Number</code>       for constant time steps or a <code>TimeStepWizard</code> for adaptive time-stepping.</p></li><li><p><code>stop_iteration</code>: Stop the simulation after this many iterations.</p></li><li><p><code>stop_time</code>: Stop the simulation once this much model clock time has passed.</p></li><li><p><code>wall_time_limit</code>: Stop the simulation if it&#39;s been running for longer than this many                    seconds of wall clock time.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Simulations/simulation.jl#L22-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Simulations.TimeStepWizard" href="#Oceananigans.Simulations.TimeStepWizard"><code>Oceananigans.Simulations.TimeStepWizard</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TimeStepWizard(cfl=0.1, max_change=2.0, min_change=0.5, max_Î”t=Inf, min_Î”t=0.0)</code></pre><p>Callback for adapting simulation time-steps <code>Î”t</code> to maintain the advective Courant-Freidrichs-Lewy (<code>cfl</code>) number, the <code>diffusive_cfl</code>, while maintaining <code>max_Î”t</code>, <code>min_Î”t</code>, and satisfying <code>max_change</code> and <code>min_change</code> criteria so <code>Î”t</code> is not adapted &quot;too quickly&quot;.</p><p>For more information on <code>cfl</code>, see https://en.wikipedia.org/wiki/Courant%E2%80%93Friedrichs%E2%80%93Lewy_condition.</p><p><strong>Example</strong></p><p>To use <code>TimeStepWizard</code>, adapt in a <a href="#Oceananigans.Simulations.Callback-Tuple{Any}"><code>Callback</code></a> and add it to a <code>Simulation</code>:</p><pre><code class="language-julia hljs">julia&gt; simulation = Simulation(model, Î”t=0.9, stop_iteration=100)

julia&gt; wizard = TimeStepWizard(cfl=0.2)

julia&gt; simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(4))</code></pre><p>Then when <code>run!(simulation)</code> is invoked, the time-step <code>simulation.Î”t</code> will be updated every 4 iterations. Note that the name <code>:wizard</code> is unimportant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Simulations/time_step_wizard.jl#L14-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Simulations.iteration-Tuple{Simulation}" href="#Oceananigans.Simulations.iteration-Tuple{Simulation}"><code>Oceananigans.Simulations.iteration</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iteration(sim::Simulation)</code></pre><p>Return the current simulation iteration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Simulations/simulation.jl#L109-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Simulations.run!-Tuple{Any}" href="#Oceananigans.Simulations.run!-Tuple{Any}"><code>Oceananigans.Simulations.run!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">run!(simulation; pickup=false)</code></pre><p>Run a <code>simulation</code> until one of <code>simulation.stop_criteria</code> evaluates <code>true</code>. The simulation will then stop.</p><p><strong>Picking simulations up from a checkpoint</strong></p><p>Simulations are &quot;picked up&quot; from a checkpoint if <code>pickup</code> is either <code>true</code>, a <code>String</code>, or an <code>Integer</code> greater than 0.</p><p>Picking up a simulation sets field and tendency data to the specified checkpoint, leaving all other model properties unchanged.</p><p>Possible values for <code>pickup</code> are:</p><ul><li><p><code>pickup=true</code> picks a simulation up from the latest checkpoint associated with the <code>Checkpointer</code> in <code>simulation.output_writers</code>.</p></li><li><p><code>pickup=iteration::Int</code> picks a simulation up from the checkpointed file associated  with <code>iteration</code> and the <code>Checkpointer</code> in <code>simulation.output_writers</code>.</p></li><li><p><code>pickup=filepath::String</code> picks a simulation up from checkpointer data in <code>filepath</code>.</p></li></ul><p>Note that <code>pickup=true</code> and <code>pickup=iteration</code> fails if <code>simulation.output_writers</code> contains more than one checkpointer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Simulations/run.jl#L60-L86">source</a></section></article><h2 id="Stokes-drift"><a class="docs-heading-anchor" href="#Stokes-drift">Stokes drift</a><a id="Stokes-drift-1"></a><a class="docs-heading-anchor-permalink" href="#Stokes-drift" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.StokesDrift.UniformStokesDrift" href="#Oceananigans.StokesDrift.UniformStokesDrift"><code>Oceananigans.StokesDrift.UniformStokesDrift</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UniformStokesDrift{UZ, VZ, UT, VT} &lt;: AbstractStokesDrift</code></pre><p>Parameter struct for Stokes drift fields associated with surface waves.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/StokesDrift.jl#L41-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.StokesDrift.UniformStokesDrift-Tuple{}" href="#Oceananigans.StokesDrift.UniformStokesDrift-Tuple{}"><code>Oceananigans.StokesDrift.UniformStokesDrift</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">UniformStokesDrift(; âˆ‚z_uË¢=addzero, âˆ‚z_vË¢=addzero, âˆ‚t_uË¢=addzero, âˆ‚t_vË¢=addzero)</code></pre><p>Construct a set of functions that describes the Stokes drift field beneath a uniform surface gravity wave field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/StokesDrift.jl#L55-L60">source</a></section></article><h2 id="Time-steppers"><a class="docs-heading-anchor" href="#Time-steppers">Time steppers</a><a id="Time-steppers-1"></a><a class="docs-heading-anchor-permalink" href="#Time-steppers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TimeSteppers.Clock" href="#Oceananigans.TimeSteppers.Clock"><code>Oceananigans.TimeSteppers.Clock</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Clock{T&lt;:Number}</code></pre><p>Keeps track of the current <code>time</code>, <code>iteration</code> number, and time-stepping <code>stage</code>. <code>stage</code> is updated only for multi-stage time-stepping methods. The <code>time::T</code> can be either a number or a <code>DateTime</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/TimeSteppers/clock.jl#L8-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TimeSteppers.Clock-Tuple{}" href="#Oceananigans.TimeSteppers.Clock-Tuple{}"><code>Oceananigans.TimeSteppers.Clock</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Clock(; time, iteration=0, stage=1)</code></pre><p>Returns a <code>Clock</code> initialized to the zeroth iteration and first time step stage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/TimeSteppers/clock.jl#L30-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TimeSteppers.Clock-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Any}} where T" href="#Oceananigans.TimeSteppers.Clock-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Any}} where T"><code>Oceananigans.TimeSteppers.Clock</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Clock{T}(time, iteration, stage=1)</code></pre><p>Returns a <code>Clock</code> with time of type <code>T</code>, initialized to the first stage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/TimeSteppers/clock.jl#L20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper-Union{Tuple{IT}, Tuple{Any, Any, Any}, NTuple{4, Any}} where IT" href="#Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper-Union{Tuple{IT}, Tuple{Any, Any, Any}, NTuple{4, Any}} where IT"><code>Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">QuasiAdamsBashforth2TimeStepper(arch, grid, tracers, Ï‡=0.1;
                                implicit_solver = nothing,
                                Gâ¿ = TendencyFields(arch, grid, tracers),
                                Gâ» = TendencyFields(arch, grid, tracers))</code></pre><p>Return an QuasiAdamsBashforth2TimeStepper object with tendency fields on <code>arch</code> and <code>grid</code> with AB2 parameter <code>Ï‡</code>. The tendency fields can be specified via optional kwargs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/TimeSteppers/quasi_adams_bashforth_2.jl#L13-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TimeSteppers.RungeKutta3TimeStepper" href="#Oceananigans.TimeSteppers.RungeKutta3TimeStepper"><code>Oceananigans.TimeSteppers.RungeKutta3TimeStepper</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RungeKutta3TimeStepper{FT, TG} &lt;: AbstractTimeStepper</code></pre><p>Holds parameters and tendency fields for a low storage, third-order Runge-Kutta-Wray time-stepping scheme described by Le and Moin (1991).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/TimeSteppers/runge_kutta_3.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TimeSteppers.RungeKutta3TimeStepper-Union{Tuple{TG}, Tuple{TI}, Tuple{Any, Any, Any}} where {TI, TG}" href="#Oceananigans.TimeSteppers.RungeKutta3TimeStepper-Union{Tuple{TG}, Tuple{TI}, Tuple{Any, Any, Any}} where {TI, TG}"><code>Oceananigans.TimeSteppers.RungeKutta3TimeStepper</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RungeKutta3TimeStepper(arch, grid, tracers,
                       Gâ¿ = TendencyFields(arch, grid, tracers),
                       Gâ» = TendencyFields(arch, grid, tracers))</code></pre><p>Return an <code>RungeKutta3TimeStepper</code> object with tendency fields on <code>arch</code> and <code>grid</code>. The tendency fields can be specified via optional kwargs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/TimeSteppers/runge_kutta_3.jl#L20-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TimeSteppers.time_step!-Tuple{Oceananigans.AbstractModel{var&quot;#s1193&quot;} where var&quot;#s1193&quot;&lt;:QuasiAdamsBashforth2TimeStepper, Any}" href="#Oceananigans.TimeSteppers.time_step!-Tuple{Oceananigans.AbstractModel{var&quot;#s1193&quot;} where var&quot;#s1193&quot;&lt;:QuasiAdamsBashforth2TimeStepper, Any}"><code>Oceananigans.TimeSteppers.time_step!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">time_step!(model::AbstractModel{&lt;:QuasiAdamsBashforth2TimeStepper}, Î”t; euler=false)</code></pre><p>Step forward <code>model</code> one time step <code>Î”t</code> with a 2nd-order Adams-Bashforth method and pressure-correction substep. Setting <code>euler=true</code> will take a forward Euler time step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/TimeSteppers/quasi_adams_bashforth_2.jl#L39-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TimeSteppers.time_step!-Tuple{Oceananigans.AbstractModel{var&quot;#s1196&quot;} where var&quot;#s1196&quot;&lt;:RungeKutta3TimeStepper, Any}" href="#Oceananigans.TimeSteppers.time_step!-Tuple{Oceananigans.AbstractModel{var&quot;#s1196&quot;} where var&quot;#s1196&quot;&lt;:RungeKutta3TimeStepper, Any}"><code>Oceananigans.TimeSteppers.time_step!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">time_step!(model::AbstractModel{&lt;:RungeKutta3TimeStepper}, Î”t; euler=false)</code></pre><p>Step forward <code>model</code> one time step <code>Î”t</code> with a 3rd-order Runge-Kutta method. The 3rd-order Runge-Kutta method takes three intermediate substep stages to achieve a single timestep. A pressure correction step is applied at each intermediate stage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/TimeSteppers/runge_kutta_3.jl#L53-L60">source</a></section></article><h2 id="Turbulence-closures"><a class="docs-heading-anchor" href="#Turbulence-closures">Turbulence closures</a><a id="Turbulence-closures-1"></a><a class="docs-heading-anchor-permalink" href="#Turbulence-closures" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.AbstractEddyViscosityClosure" href="#Oceananigans.TurbulenceClosures.AbstractEddyViscosityClosure"><code>Oceananigans.TurbulenceClosures.AbstractEddyViscosityClosure</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractEddyViscosityClosure &lt;: AbstractTurbulenceClosure</code></pre><p>Abstract supertype for turbulence closures that are defined by an isotropic viscosity and isotropic diffusivities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/TurbulenceClosures/abstract_eddy_viscosity_closure.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.AnisotropicBiharmonicDiffusivity" href="#Oceananigans.TurbulenceClosures.AnisotropicBiharmonicDiffusivity"><code>Oceananigans.TurbulenceClosures.AnisotropicBiharmonicDiffusivity</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AnisotropicBiharmonicDiffusivity{FT, KH, KZ}</code></pre><p>Parameters for anisotropic biharmonic diffusivity models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_biharmonic_diffusivity.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.AnisotropicBiharmonicDiffusivity" href="#Oceananigans.TurbulenceClosures.AnisotropicBiharmonicDiffusivity"><code>Oceananigans.TurbulenceClosures.AnisotropicBiharmonicDiffusivity</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AnisotropicBiharmonicDiffusivity([FT=Float64;] Î½x=0, Î½y=0, Î½z=0, Îºx=0, Îºy=0, Îºz=0, Î½h=nothing, Îºh=nothing)</code></pre><p>Returns parameters for a fourth-order, anisotropic biharmonic diffusivity closure with constant x-, y, and z-direction biharmonic viscosities <code>Î½x</code>, <code>Î½y</code>, and <code>Î½z</code>, and constant x-, y, and z-direction biharmonic diffusivities <code>Îºx</code>, <code>Îºy</code>, and <code>Îºz</code>, <code>Îºx</code>, <code>Îºy</code>, and <code>Îºz</code> may be <code>NamedTuple</code>s with fields corresponding to each tracer, or a single number to be a applied to all tracers.</p><p>If <code>Î½h</code> or <code>Îºh</code> are provided, then <code>Î½x = Î½y = Î½h</code> or <code>Îºx = Îºy = Îºh</code>.</p><p>The tracer flux divergence associated with an anisotropic biharmonic diffusivity is, for example</p><p class="math-container">\[    âˆ‚áµ¢ Îºáµ¢â±¼ âˆ‚â±¼c = - [Îºx âˆ‚â´x + Îºy âˆ‚â´y + Îºz âˆ‚â´z] c\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_biharmonic_diffusivity.jl#L17-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.AnisotropicDiffusivity" href="#Oceananigans.TurbulenceClosures.AnisotropicDiffusivity"><code>Oceananigans.TurbulenceClosures.AnisotropicDiffusivity</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AnisotropicDiffusivity{NX, NY, NZ, KX, KY, KZ}</code></pre><p>Parameters for anisotropic diffusivity models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_diffusivity.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.AnisotropicDiffusivity-Union{Tuple{}, Tuple{Any}, Tuple{TD}} where TD" href="#Oceananigans.TurbulenceClosures.AnisotropicDiffusivity-Union{Tuple{}, Tuple{Any}, Tuple{TD}} where TD"><code>Oceananigans.TurbulenceClosures.AnisotropicDiffusivity</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AnisotropicDiffusivity(([FT=Float64;] Î½x=0, Î½y=0, Î½z=0, Îºx=0, Îºy=0, Îºz=0, Î½h=nothing, Îºh=nothing,
                                time_discretization = ExplicitTimeDiscretization())</code></pre><p>Returns parameters for a closure with a diagonal diffusivity tensor with heterogeneous &#39;anisotropic&#39; components labeled by <code>x</code>, <code>y</code>, <code>z</code>. Each component may be a number or function. The tracer diffusivities <code>Îºx</code>, <code>Îºy</code>, and <code>Îºz</code> may be <code>NamedTuple</code>s with fields corresponding to each tracer, or a single number or function to be a applied to all tracers.</p><p>If <code>Î½h</code> or <code>Îºh</code> are provided, then <code>Î½x = Î½y = Î½h</code>, and <code>Îºx = Îºy = Îºh</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_diffusivity.jl#L23-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation" href="#Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation"><code>Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AnisotropicMinimumDissipation{FT} &lt;: AbstractTurbulenceClosure</code></pre><p>Parameters for the &quot;anisotropic minimum dissipation&quot; turbulence closure for large eddy simulation proposed originally by <a href="../../references/#Rozema15">Wybe Rozema, Hyun J. Bae, Parviz Moin, Roel Verstappen (2015)</a> and <a href="../../references/#Abkar16">Mahdi Abkar, Hyun J. Bae, Parviz Moin (2016)</a>, and then modified by <a href="../../references/#Verstappen18">Roel Verstappen (2018)</a>, and finally described and validated for by <a href="../../references/#Vreugdenhil18">Catherine A. Vreugdenhil, John R. Taylor (2018)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation-Union{Tuple{}, Tuple{Any}, Tuple{TD}} where TD" href="#Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation-Union{Tuple{}, Tuple{Any}, Tuple{TD}} where TD"><code>Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AnisotropicMinimumDissipation([FT=Float64;] C=1/12, CÎ½=nothing, CÎº=nothing,
                                            Cb=nothing, Î½=0, Îº=0,
                                            time_discretization=ExplicitTimeDiscretization())</code></pre><p>Returns parameters of type <code>FT</code> for the <code>AnisotropicMinimumDissipation</code> turbulence closure.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>C</code>: PoincareÌ constant for both eddy viscosity and eddy diffusivities. <code>C</code> is overridden      for eddy viscosity or eddy diffusivity if <code>CÎ½</code> or <code>CÎº</code> are set, respecitvely.</p></li><li><p><code>CÎ½</code>: PoincareÌ constant for momentum eddy viscosity.</p></li><li><p><code>CÎº</code>: PoincareÌ constant for tracer eddy diffusivities. If one number or function, the same       number or function is applied to all tracers. If a <code>NamedTuple</code>, it must possess       a field specifying the PoncareÌ constant for every tracer.</p></li><li><p><code>Cb</code>: Buoyancy modification multiplier (<code>Cb = nothing</code> turns it off, <code>Cb = 1</code> was used by <a href="../../references/#Abkar16">Mahdi Abkar, Hyun J. Bae, Parviz Moin (2016)</a>).       <em>Note</em>: that we <em>do not</em> subtract the horizontally-average component before computing this       buoyancy modification term. This implementation differs from <a href="../../references/#Abkar16">Mahdi Abkar, Hyun J. Bae, Parviz Moin (2016)</a>&#39;s proposal       and the impact of this approximation has not been tested or validated.</p></li><li><p><code>Î½</code>: Constant background viscosity for momentum.</p></li><li><p><code>Îº</code>: Constant background diffusivity for tracer. If a single number, the same background      diffusivity is applied to all tracers. If a <code>NamedTuple</code>, it must possess a field      specifying a background diffusivity for every tracer.</p></li><li><p><code>time_discretization</code>: Either <code>ExplicitTimeDiscretization()</code> or <code>VerticallyImplicitTimeDiscretization()</code>,                         which integrates the terms involving only z-derivatives in the                        viscous and diffusive fluxes with an implicit time discretization.</p></li></ul><p>By default: <code>C = CÎ½ = CÎº</code> = 1/12, which is appropriate for a finite-volume method employing a second-order advection scheme, <code>Cb = nothing</code>, which terms off the buoyancy modification term.</p><p><code>CÎ½</code> or <code>CÎº</code> may be constant numbers, or functions of <code>x, y, z</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; pretty_diffusive_closure = AnisotropicMinimumDissipation(C=1/2)
AnisotropicMinimumDissipation{Float64} turbulence closure with:
           PoincareÌ constant for momentum eddy viscosity CÎ½: 0.5
    PoincareÌ constant for tracer(s) eddy diffusivit(ies) CÎº: 0.5
                        Buoyancy modification multiplier Cb: nothing
                Background diffusivit(ies) for tracer(s), Îº: 0.0
             Background kinematic viscosity for momentum, Î½: 0.0</code></pre><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; const Î”z = 0.5; # grid resolution at surface

julia&gt; surface_enhanced_tracer_C(x, y, z) = 1/12 * (1 + exp((z + Î”z/2) / 8Î”z));

julia&gt; fancy_closure = AnisotropicMinimumDissipation(CÎº=surface_enhanced_tracer_C)
AnisotropicMinimumDissipation{Float64} turbulence closure with:
           PoincareÌ constant for momentum eddy viscosity CÎ½: 0.08333333333333333
    PoincareÌ constant for tracer(s) eddy diffusivit(ies) CÎº: surface_enhanced_tracer_C
                        Buoyancy modification multiplier Cb: nothing
                Background diffusivit(ies) for tracer(s), Îº: 0.0
             Background kinematic viscosity for momentum, Î½: 0.0</code></pre><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; tracer_specific_closure = AnisotropicMinimumDissipation(CÎº=(câ‚=1/12, câ‚‚=1/6))
AnisotropicMinimumDissipation{Float64} turbulence closure with:
           PoincareÌ constant for momentum eddy viscosity CÎ½: 0.08333333333333333
    PoincareÌ constant for tracer(s) eddy diffusivit(ies) CÎº: (câ‚ = 0.08333333333333333, câ‚‚ = 0.16666666666666666)
                        Buoyancy modification multiplier Cb: nothing
                Background diffusivit(ies) for tracer(s), Îº: 0.0
             Background kinematic viscosity for momentum, Î½: 0.0</code></pre><p><strong>References</strong></p><p>Vreugdenhil C., and Taylor J. (2018), &quot;Large-eddy simulations of stratified plane Couette     flow using the anisotropic minimum-dissipation model&quot;, Physics of Fluids 30, 085104.</p><p>Verstappen, R. (2018), &quot;How much eddy dissipation is needed to counterbalance the nonlinear     production of small, unresolved scales in a large-eddy simulation of turbulence?&quot;,     Computers &amp; Fluids 176, pp. 276-284.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L34-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.ConvectiveAdjustmentVerticalDiffusivity-Union{Tuple{}, Tuple{Any}, Tuple{TD}} where TD" href="#Oceananigans.TurbulenceClosures.ConvectiveAdjustmentVerticalDiffusivity-Union{Tuple{}, Tuple{Any}, Tuple{TD}} where TD"><code>Oceananigans.TurbulenceClosures.ConvectiveAdjustmentVerticalDiffusivity</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ConvectiveAdjustmentVerticalDiffusivity([FT=Float64;]
                                        convective_Îºz = 0,
                                        convective_Î½z = 0,
                                        background_Îºz = 0,
                                        background_Î½z = 0,
                                        time_discretization = VerticallyImplicitTimeDiscretization())</code></pre><p>The one positional argument determines the floating point type of the free parameters of <code>ConvectiveAdjustmentVerticalDiffusivity</code>. The default is <code>Float64</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>convective_Îºz</code>: Vertical tracer diffusivity in regions with negative (unstable) buoyancy gradients. Either                  a single number, function, array, field, or tuple of diffusivities for each tracer.</p></li><li><p><code>background_Îºz</code>: Vertical tracer diffusivity in regions with zero or positive (stable) buoyancy gradients.</p></li><li><p><code>convective_Î½z</code>: Vertical viscosity in regions with negative (unstable) buoyancy gradients. Either                 a number, function, array, or field.</p></li><li><p><code>background_Îºz</code>: Vertical viscosity in regions with zero or positive (stable) buoyancy gradients.</p></li><li><p><code>time_discretization</code>: Either <code>ExplicitTimeDiscretization</code> or <code>VerticallyImplicitTimeDiscretization</code>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/TurbulenceClosures/turbulence_closure_implementations/convective_adjustment_vertical_diffusivity.jl#L21-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.HorizontallyCurvilinearAnisotropicDiffusivity" href="#Oceananigans.TurbulenceClosures.HorizontallyCurvilinearAnisotropicDiffusivity"><code>Oceananigans.TurbulenceClosures.HorizontallyCurvilinearAnisotropicDiffusivity</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HorizontallyCurvilinearAnisotropicDiffusivity{N, K}</code></pre><p>Holds viscosity and diffusivities for models with prescribed isotropic diffusivities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/TurbulenceClosures/turbulence_closure_implementations/horizontally_curvilinear_anisotropic_diffusivity.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.HorizontallyCurvilinearAnisotropicDiffusivity" href="#Oceananigans.TurbulenceClosures.HorizontallyCurvilinearAnisotropicDiffusivity"><code>Oceananigans.TurbulenceClosures.HorizontallyCurvilinearAnisotropicDiffusivity</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HorizontallyCurvilinearAnisotropicDiffusivity([FT=Float64;] Î½h=0, Îºh=0, Î½z=0, Îºz=0,
                                              time_discretization = ExplicitTimeDiscretization())</code></pre><p>Returns parameters for an anisotropic diffusivity model on curvilinear grids.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>Î½h</code>: Horizontal viscosity. <code>Number</code>, <code>AbstractArray</code>, or <code>Function(x, y, z, t)</code>.</p></li><li><p><code>Î½z</code>: Vertical viscosity. <code>Number</code>, <code>AbstractArray</code>, or <code>Function(x, y, z, t)</code>.</p></li><li><p><code>Îºh</code>: Horizontal diffusivity. <code>Number</code>, <code>AbstractArray</code>, or <code>Function(x, y, z, t)</code>, or       <code>NamedTuple</code> of diffusivities with entries for each tracer.</p></li><li><p><code>Îºz</code>: Vertical diffusivity. <code>Number</code>, <code>AbstractArray</code>, or <code>Function(x, y, z, t)</code>, or       <code>NamedTuple</code> of diffusivities with entries for each tracer.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/TurbulenceClosures/turbulence_closure_implementations/horizontally_curvilinear_anisotropic_diffusivity.jl#L20-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.IsopycnalSkewSymmetricDiffusivity" href="#Oceananigans.TurbulenceClosures.IsopycnalSkewSymmetricDiffusivity"><code>Oceananigans.TurbulenceClosures.IsopycnalSkewSymmetricDiffusivity</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IsopycnalSkewSymmetricDiffusivity([FT=Float64;]
                                  Îº_skew = 0,
                                  Îº_symmetric = 0,
                                  isopycnal_tensor = SmallSlopeIsopycnalTensor(),
                                  slope_limiter = nothing)</code></pre><p>Return parameters for an isopycnal skew-symmetric tracer diffusivity with skew diffusivity <code>Îº_skew</code> and symmetric diffusivity <code>Îº_symmetric</code> using an <code>isopycnal_tensor</code> for calculating the isopycnal slopes, and optionally applying a <code>slope_limiter</code>. Both <code>Îº_skew</code> and <code>Îº_symmetric</code> may be constants, arrays, fields, or functions of <code>(x, y, z, t)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/TurbulenceClosures/turbulence_closure_implementations/isopycnal_skew_symmetric_diffusivity.jl#L20-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.IsotropicDiffusivity-Union{Tuple{}, Tuple{Any}, Tuple{TD}} where TD" href="#Oceananigans.TurbulenceClosures.IsotropicDiffusivity-Union{Tuple{}, Tuple{Any}, Tuple{TD}} where TD"><code>Oceananigans.TurbulenceClosures.IsotropicDiffusivity</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">IsotropicDiffusivity([FT=Float64;] Î½=0, Îº=0, time_discretization = ExplicitTimeDiscretization())</code></pre><p>Returns parameters for an isotropic diffusivity model with viscosity <code>Î½</code> and thermal diffusivities <code>Îº</code> for each tracer field in <code>tracers</code> <code>Î½</code> and the fields of <code>Îº</code> may be constants, arrays, fields, or functions of <code>(x, y, z, t)</code>.</p><p><code>Îº</code> may be a <code>NamedTuple</code> with fields corresponding to each tracer, or a single number to be a applied to all tracers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/TurbulenceClosures/turbulence_closure_implementations/isotropic_diffusivity.jl#L12-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.SmagorinskyLilly-Union{Tuple{}, Tuple{Any}, Tuple{TD}} where TD" href="#Oceananigans.TurbulenceClosures.SmagorinskyLilly-Union{Tuple{}, Tuple{Any}, Tuple{TD}} where TD"><code>Oceananigans.TurbulenceClosures.SmagorinskyLilly</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SmagorinskyLilly([FT=Float64;] C=0.16, Pr=1, Î½=0, Îº=0,
                               time_discretization=ExplicitTimeDiscretization())</code></pre><p>Return a <code>SmagorinskyLilly</code> type associated with the turbulence closure proposed by Lilly (1962) and Smagorinsky (1958, 1963), which has an eddy viscosity of the form</p><pre><code class="nohighlight hljs">    Î½â‚‘ = (C * Î”á¶ )Â² * âˆš(2Î£Â²) * âˆš(1 - Cb * NÂ² / Î£Â²) + Î½,</code></pre><p>and an eddy diffusivity of the form</p><pre><code class="nohighlight hljs">Îºâ‚‘ = (Î½â‚‘ - Î½) / Pr + Îº ,</code></pre><p>where <code>Î”á¶ </code> is the filter width, <code>Î£Â² = Î£áµ¢â±¼Î£áµ¢â±¼</code> is the double dot product of the strain tensor <code>Î£áµ¢â±¼</code>, <code>Pr</code> is the turbulent Prandtl number, and <code>NÂ²</code> is the total buoyancy gradient, and <code>Cb</code> is a constant the multiplies the Richardson number modification to the eddy viscosity.</p><p><strong>Keyword arguments</strong></p><ul><li><code>C</code>: Smagorinsky constant. Default value is 0.16 as obtained by Lilly (1966).</li><li><code>Cb</code>: Buoyancy term multipler based on Lilly (1962) (<code>Cb = 0</code> turns it off, <code>Cb â‰  0</code> turns it on.       Typically, and according to the original work by Lilly (1962), <code>Cb=1/Pr</code>.)</li><li><code>Pr</code>: Turbulent Prandtl numbers for each tracer. Either a constant applied to every       tracer, or a <code>NamedTuple</code> with fields for each tracer individually.</li><li><code>Î½</code>: Constant background viscosity for momentum.</li><li><code>Îº</code>: Constant background diffusivity for tracer. Can either be a single number      applied to all tracers, or <code>NamedTuple</code> of diffusivities corresponding to each      tracer.</li><li><code>time_discretization</code>: Either <code>ExplicitTimeDiscretization()</code> or <code>VerticallyImplicitTimeDiscretization()</code>,                         which integrates the terms involving only <span>$z$</span>-derivatives in the                        viscous and diffusive fluxes with an implicit time discretization.</li></ul><p><strong>References</strong></p><p>Smagorinsky, J. &quot;On the numerical integration of the primitive equations of motion for     baroclinic flow in a closed region.&quot; Monthly Weather Review (1958)</p><p>Lilly, D. K. &quot;On the numerical simulation of buoyant convection.&quot; Tellus (1962)</p><p>Smagorinsky, J. &quot;General circulation experiments with the primitive equations: I.     The basic experiment.&quot; Monthly weather review (1963)</p><p>Lilly, D. K. &quot;The representation of small-scale turbulence in numerical simulation experiments.&quot;      NCAR Manuscript No. 281, 0, 1966.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl#L20-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.TwoDimensionalLeith" href="#Oceananigans.TurbulenceClosures.TwoDimensionalLeith"><code>Oceananigans.TurbulenceClosures.TwoDimensionalLeith</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TwoDimensionalLeith([FT=Float64;] C=0.3, C_Redi=1, C_GM=1)</code></pre><p>Return a <code>TwoDimensionalLeith</code> type associated with the turbulence closure proposed by Leith (1965) and Fox-Kemper &amp; Menemenlis (2008) which has an eddy viscosity of the form</p><pre><code class="language-julia hljs">Î½â‚‘ = (C * Î”á¶ )Â³ * âˆš(|âˆ‡â‚• Î¶|Â² + |âˆ‡â‚• âˆ‚w/âˆ‚z|Â²)</code></pre><p>and an eddy diffusivity of the form...</p><p>where <code>Î”á¶ </code> is the filter width, <code>Î¶ = âˆ‚v/âˆ‚x - âˆ‚u/âˆ‚y</code> is the vertical vorticity, and <code>C</code> is a model constant.</p><p><strong>Keyword arguments</strong></p><ul><li><code>C</code>: Model constant</li><li><code>C_Redi</code>: Coefficient for down-gradient tracer diffusivity for each tracer.           Either a constant applied to every tracer, or a <code>NamedTuple</code> with fields           for each tracer individually.</li><li><code>C_GM</code>: Coefficient for down-gradient tracer diffusivity for each tracer.         Either a constant applied to every tracer, or a <code>NamedTuple</code> with fields         for each tracer individually.</li></ul><p><strong>References</strong></p><p>Leith, C. E. (1968). &quot;Diffusion Approximation for Twoâ€Dimensional Turbulence&quot;, The Physics of     Fluids 11, 671. doi: 10.1063/1.1691968</p><p>Foxâ€Kemper, B., &amp; D. Menemenlis (2008), &quot;Can large eddy simulation techniques improve mesoscale rich     ocean models?&quot;, in Ocean Modeling in an Eddying Regime, Geophys. Monogr. Ser., vol. 177, pp. 319â€“337.     doi: 10.1029/177GM19</p><p>Pearson, B. et al. (2017) , &quot;Evaluation of scale-aware subgrid mesoscale eddy models in a global eddy     rich model&quot;, Ocean Modelling 115, 42-58. doi: 10.1016/j.ocemod.2017.05.007</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl#L20-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.âˆ‡_dot_qá¶œ-Tuple{Any, Any, Any, Any, Oceananigans.TurbulenceClosures.AbstractTurbulenceClosure, Any, Any, Vararg{Any, N} where N}" href="#Oceananigans.TurbulenceClosures.âˆ‡_dot_qá¶œ-Tuple{Any, Any, Any, Any, Oceananigans.TurbulenceClosures.AbstractTurbulenceClosure, Any, Any, Vararg{Any, N} where N}"><code>Oceananigans.TurbulenceClosures.âˆ‡_dot_qá¶œ</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">âˆ‡_dot_qá¶œ(i, j, k, grid, clock, closure::AbstractTurbulenceClosure, c, ::Val{tracer_index}, args...)</code></pre><p>Calculates the divergence of the diffusive flux <code>qá¶œ</code> for a tracer <code>c</code> via</p><pre><code class="nohighlight hljs">1/V * [Î´xá¶œáµƒáµƒ(Ax * diffusive_flux_x) + Î´yáµƒá¶œáµƒ(Ay * diffusive_flux_y) + Î´záµƒáµƒá¶œ(Az * diffusive_flux_z)]</code></pre><p>which will end up at the location <code>ccc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/TurbulenceClosures/diffusion_operators.jl#L36-L44">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.cell_advection_timescale-NTuple{4, Any}" href="#Oceananigans.Utils.cell_advection_timescale-NTuple{4, Any}"><code>Oceananigans.Utils.cell_advection_timescale</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Returns the time-scale for advection on a regular grid across a single grid cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Utils/cell_advection_timescale.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.launch!-Tuple{Any, Any, Any, Any, Vararg{Any, N} where N}" href="#Oceananigans.Utils.launch!-Tuple{Any, Any, Any, Any, Vararg{Any, N} where N}"><code>Oceananigans.Utils.launch!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">launch!(arch, grid, layout, kernel!, args...; dependencies=nothing, kwargs...)</code></pre><p>Launches <code>kernel!</code>, with arguments <code>args</code> and keyword arguments <code>kwargs</code>, over the <code>dims</code> of <code>grid</code> on the architecture <code>arch</code>.</p><p>Returns an <code>event</code> token associated with the <code>kernel!</code> launch.</p><p>The keyword argument <code>dependencies</code> is an <code>Event</code> or <code>MultiEvent</code> specifying prior kernels that must complete before <code>kernel!</code> is launched.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Utils/kernel_launching.jl#L73-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.pretty_filesize" href="#Oceananigans.Utils.pretty_filesize"><code>Oceananigans.Utils.pretty_filesize</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pretty_filesize(s, suffix=&quot;B&quot;)</code></pre><p>Convert a floating point value <code>s</code> representing a file size to a more human-friendly formatted string with one decimal places with a <code>suffix</code> defaulting to &quot;B&quot;. Depending on the value of <code>s</code> the string will be formatted to show <code>s</code> using an SI prefix from bytes, kiB (1024 bytes), MiB (1024Â² bytes), and so on up to YiB (1024â¸ bytes).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Utils/pretty_filesize.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.prettytime-Tuple{Any}" href="#Oceananigans.Utils.prettytime-Tuple{Any}"><code>Oceananigans.Utils.prettytime</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prettytime(t)</code></pre><p>Convert a floating point value <code>t</code> representing an amount of time in seconds to a more human-friendly formatted string with three decimal places. Depending on the value of <code>t</code> the string will be formatted to show <code>t</code> in nanoseconds (ns), microseconds (Î¼s), milliseconds (ms), seconds, minutes, hours, days, or years.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Utils/pretty_time.jl#L8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.with_tracers-Tuple{Any, NamedTuple, Any}" href="#Oceananigans.Utils.with_tracers-Tuple{Any, NamedTuple, Any}"><code>Oceananigans.Utils.with_tracers</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">with_tracers(tracer_names, initial_tuple, tracer_default)</code></pre><p>Create a tuple corresponding to the solution variables <code>u</code>, <code>v</code>, <code>w</code>, and <code>tracer_names</code>. <code>initial_tuple</code> is a <code>NamedTuple</code> that at least has fields <code>u</code>, <code>v</code>, and <code>w</code>, and may have some fields corresponding to the names in <code>tracer_names</code>. <code>tracer_default</code> is a function that produces a default tuple value for each tracer if not included in <code>initial_tuple</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/a4c27e0f01a003296ff181d4079fa9a5e35b911b/src/Utils/with_tracers.jl#L1-L9">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../benchmarks/">Â« Performance benchmarks</a><a class="docs-footer-nextpage" href="../function_index/">Function index Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Friday 3 December 2021 01:11">Friday 3 December 2021</span>. Using Julia version 1.6.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

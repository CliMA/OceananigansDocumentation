<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · Oceananigans.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://clima.github.io/OceananigansDocumentation/stable/appendix/library/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Oceananigans.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../quick_start/">Quick start</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/one_dimensional_diffusion/">One-dimensional diffusion</a></li><li><a class="tocitem" href="../../generated/two_dimensional_turbulence/">Two-dimensional turbulence</a></li><li><a class="tocitem" href="../../generated/internal_wave/">Internal wave</a></li><li><a class="tocitem" href="../../generated/convecting_plankton/">Convecting plankton</a></li><li><a class="tocitem" href="../../generated/ocean_wind_mixing_and_convection/">Ocean wind mixing and convection</a></li><li><a class="tocitem" href="../../generated/langmuir_turbulence/">Langmuir turbulence</a></li><li><a class="tocitem" href="../../generated/baroclinic_adjustment/">Baroclinic adjustment</a></li><li><a class="tocitem" href="../../generated/kelvin_helmholtz_instability/">Kelvin-Helmholtz instability</a></li><li><a class="tocitem" href="../../generated/shallow_water_Bickley_jet/">Shallow water Bickley jet</a></li><li><a class="tocitem" href="../../generated/horizontal_convection/">Horizontal convection</a></li><li><a class="tocitem" href="../../generated/tilted_bottom_boundary_layer/">Tilted bottom boundary layer</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Physics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../physics/notation/">Coordinate system and notation</a></li><li><a class="tocitem" href="../../physics/boussinesq/">Boussinesq approximation</a></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label"><code>NonhydrostaticModel</code></span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../physics/nonhydrostatic_model/">Nonhydrostatic model</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label"><code>HydrostaticFreeSurfaceModel</code></span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../physics/hydrostatic_free_surface_model/">Hydrostatic model with a free surface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label"><code>ShallowWaterModel</code></span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../physics/shallow_water_model/">Shallow water model</a></li></ul></li><li><a class="tocitem" href="../../physics/boundary_conditions/">Boundary conditions</a></li><li><a class="tocitem" href="../../physics/buoyancy_and_equations_of_state/">Buoyancy models and equations of state</a></li><li><a class="tocitem" href="../../physics/coriolis_forces/">Coriolis forces</a></li><li><a class="tocitem" href="../../physics/turbulence_closures/">Turbulence closures</a></li><li><a class="tocitem" href="../../physics/surface_gravity_waves/">Surface gravity waves and the Craik-Leibovich approximation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Numerical implementation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../numerical_implementation/finite_volume/">Finite volume method</a></li><li><a class="tocitem" href="../../numerical_implementation/spatial_operators/">Spatial operators</a></li><li><a class="tocitem" href="../../numerical_implementation/pressure_decomposition/">Pressure decomposition</a></li><li><a class="tocitem" href="../../numerical_implementation/time_stepping/">Time stepping</a></li><li><a class="tocitem" href="../../numerical_implementation/boundary_conditions/">Boundary conditions</a></li><li><a class="tocitem" href="../../numerical_implementation/elliptic_solvers/">Elliptic solvers</a></li><li><a class="tocitem" href="../../numerical_implementation/large_eddy_simulation/">Large eddy simulation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Model setup</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_setup/overview/">Overview</a></li><li><a class="tocitem" href="../../model_setup/architecture/">Architecture</a></li><li><a class="tocitem" href="../../model_setup/number_type/">Number type</a></li><li><a class="tocitem" href="../../model_setup/grids/">Grid</a></li><li><a class="tocitem" href="../../model_setup/clock/">Clock</a></li><li><a class="tocitem" href="../../model_setup/coriolis/">Coriolis (rotation)</a></li><li><a class="tocitem" href="../../model_setup/tracers/">Tracers</a></li><li><a class="tocitem" href="../../model_setup/buoyancy_and_equation_of_state/">Buoyancy models and equation of state</a></li><li><a class="tocitem" href="../../model_setup/boundary_conditions/">Boundary conditions</a></li><li><a class="tocitem" href="../../model_setup/forcing_functions/">Forcing functions</a></li><li><a class="tocitem" href="../../model_setup/background_fields/">Background fields</a></li><li><a class="tocitem" href="../../model_setup/turbulent_diffusivity_closures_and_les_models/">Turbulent diffusivity closures and LES models</a></li><li><a class="tocitem" href="../../model_setup/lagrangian_particles/">Lagrangian particles</a></li><li><a class="tocitem" href="../../model_setup/diagnostics/">Diagnostics</a></li><li><a class="tocitem" href="../../model_setup/output_writers/">Output writers</a></li><li><a class="tocitem" href="../../model_setup/checkpointing/">Checkpointing</a></li><li><a class="tocitem" href="../../model_setup/setting_initial_conditions/">Setting initial conditions</a></li></ul></li><li><a class="tocitem" href="../../simulation_tips/">Simulation tips</a></li><li><a class="tocitem" href="../../contributing/">Contributor&#39;s guide</a></li><li><a class="tocitem" href="../../gallery/">Gallery</a></li><li><a class="tocitem" href="../../references/">References</a></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox" checked/><label class="tocitem" for="menuitem-11"><span class="docs-label">Appendix</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../staggered_grid/">Staggered grid</a></li><li><a class="tocitem" href="../fractional_step/">Fractional step method</a></li><li><a class="tocitem" href="../convergence_tests/">Convergence tests</a></li><li><a class="tocitem" href="../benchmarks/">Performance benchmarks</a></li><li class="is-active"><a class="tocitem" href>Library</a><ul class="internal"><li><a class="tocitem" href="#Oceananigans.jl"><span>Oceananigans.jl</span></a></li><li><a class="tocitem" href="#Abstract-operations"><span>Abstract operations</span></a></li><li><a class="tocitem" href="#Advection"><span>Advection</span></a></li><li><a class="tocitem" href="#Architectures"><span>Architectures</span></a></li><li><a class="tocitem" href="#Boundary-conditions"><span>Boundary conditions</span></a></li><li><a class="tocitem" href="#Buoyancy-models"><span>Buoyancy models</span></a></li><li><a class="tocitem" href="#Coriolis"><span>Coriolis</span></a></li><li><a class="tocitem" href="#Diagnostics"><span>Diagnostics</span></a></li><li><a class="tocitem" href="#Distributed"><span>Distributed</span></a></li><li><a class="tocitem" href="#Fields"><span>Fields</span></a></li><li><a class="tocitem" href="#Forcings"><span>Forcings</span></a></li><li><a class="tocitem" href="#Grids"><span>Grids</span></a></li><li><a class="tocitem" href="#Immersed-boundaries"><span>Immersed boundaries</span></a></li><li><a class="tocitem" href="#Logger"><span>Logger</span></a></li><li><a class="tocitem" href="#Models"><span>Models</span></a></li><li><a class="tocitem" href="#MultiRegion"><span>MultiRegion</span></a></li><li><a class="tocitem" href="#Operators"><span>Operators</span></a></li><li><a class="tocitem" href="#Output-readers"><span>Output readers</span></a></li><li><a class="tocitem" href="#Output-writers"><span>Output writers</span></a></li><li><a class="tocitem" href="#Simulations"><span>Simulations</span></a></li><li><a class="tocitem" href="#Solvers"><span>Solvers</span></a></li><li><a class="tocitem" href="#Stokes-drift"><span>Stokes drift</span></a></li><li><a class="tocitem" href="#Time-steppers"><span>Time steppers</span></a></li><li><a class="tocitem" href="#Turbulence-closures"><span>Turbulence closures</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li><li><a class="tocitem" href="#Units"><span>Units</span></a></li></ul></li><li><a class="tocitem" href="../function_index/">Function index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Appendix</a></li><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/CliMA/Oceananigans.jl/blob/main/docs/src/appendix/library.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><p>Documenting the public user interface.</p><h2 id="Oceananigans.jl"><a class="docs-heading-anchor" href="#Oceananigans.jl">Oceananigans.jl</a><a id="Oceananigans.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Oceananigans.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Oceananigans" href="#Oceananigans.Oceananigans"><code>Oceananigans.Oceananigans</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Main module for <code>Oceananigans.jl</code> – a Julia software for fast, friendly, flexible, data-driven, ocean-flavored fluid dynamics on CPUs and GPUs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Oceananigans.jl#L1-L4">source</a></section></article><h2 id="Abstract-operations"><a class="docs-heading-anchor" href="#Abstract-operations">Abstract operations</a><a id="Abstract-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-operations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.volume" href="#Oceananigans.AbstractOperations.volume"><code>Oceananigans.AbstractOperations.volume</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">volume = VolumeMetric()</code></pre><p>Instance of <code>VolumeMetric</code> that generates <code>BinaryOperation</code>s between <code>AbstractField</code>s and their cell volumes. Summing this <code>BinaryOperation</code> yields an integral of <code>AbstractField</code> over the domain.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; using Oceananigans.AbstractOperations: volume

julia&gt; c = CenterField(RectilinearGrid(size=(2, 2, 2), extent=(1, 2, 3)));

julia&gt; c .= 1;

julia&gt; c_dV = c * volume
BinaryOperation at (Center, Center, Center)
├── grid: 2×2×2 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo
└── tree:
    * at (Center, Center, Center)
    ├── 2×2×2 Field{Center, Center, Center} on RectilinearGrid on CPU
    └── Vᶜᶜᶜ at (Center, Center, Center)

julia&gt; c_dV[1, 1, 1]
0.75

julia&gt; sum(c_dV)
6.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/AbstractOperations/grid_metrics.jl#L70-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.Δz" href="#Oceananigans.AbstractOperations.Δz"><code>Oceananigans.AbstractOperations.Δz</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">Δz = ZSpacingMetric()</code></pre><p>Instance of <code>ZSpacingMetric</code> that generates <code>BinaryOperation</code>s between <code>AbstractField</code>s and the vertical grid spacing evaluated at the same location as the <code>AbstractField</code>. </p><p><code>Δx</code> and <code>Δy</code> play a similar role for horizontal grid spacings.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; using Oceananigans.AbstractOperations: Δz

julia&gt; c = CenterField(RectilinearGrid(size=(1, 1, 1), extent=(1, 2, 3)));

julia&gt; c_dz = c * Δz # returns BinaryOperation between Field and GridMetricOperation
BinaryOperation at (Center, Center, Center)
├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo
└── tree:
    * at (Center, Center, Center)
    ├── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU
    └── Δzᶜᶜᶜ at (Center, Center, Center)

julia&gt; c .= 1;

julia&gt; c_dz[1, 1, 1]
3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/AbstractOperations/grid_metrics.jl#L31-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.Average-Tuple{Oceananigans.Fields.AbstractField}" href="#Oceananigans.AbstractOperations.Average-Tuple{Oceananigans.Fields.AbstractField}"><code>Oceananigans.AbstractOperations.Average</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Average(field::AbstractField; condition = nothing, mask = 0, dims=:)</code></pre><p>Return <code>Reduction</code> representing a spatial average of <code>field</code> over <code>dims</code>.</p><p>Over regularly-spaced dimensions this is equivalent to a numerical <code>mean!</code>.</p><p>Over dimensions of variable spacing, <code>field</code> is multiplied by the appropriate grid length, area or volume, and divided by the total spatial extent of the interval.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/AbstractOperations/metric_field_reductions.jl#L48-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.BinaryOperation-Union{Tuple{G}, Tuple{IB}, Tuple{IA}, Tuple{B}, Tuple{A}, Tuple{O}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{O, A, B, IA, IB, G}} where {LX, LY, LZ, O, A, B, IA, IB, G}" href="#Oceananigans.AbstractOperations.BinaryOperation-Union{Tuple{G}, Tuple{IB}, Tuple{IA}, Tuple{B}, Tuple{A}, Tuple{O}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{O, A, B, IA, IB, G}} where {LX, LY, LZ, O, A, B, IA, IB, G}"><code>Oceananigans.AbstractOperations.BinaryOperation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BinaryOperation{LX, LY, LZ}(op, a, b, ▶a, ▶b, grid)</code></pre><p>Return an abstract representation of the binary operation <code>op(▶a(a), ▶b(b))</code> on <code>grid</code>, where <code>▶a</code> and <code>▶b</code> interpolate <code>a</code> and <code>b</code> to locations <code>(LX, LY, LZ)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/AbstractOperations/binary_operations.jl#L11-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.ConditionalOperation-Tuple{Oceananigans.Fields.AbstractField}" href="#Oceananigans.AbstractOperations.ConditionalOperation-Tuple{Oceananigans.Fields.AbstractField}"><code>Oceananigans.AbstractOperations.ConditionalOperation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ConditionalOperation(operand::AbstractField;
                     func = identity,
                     condition = nothing,
                     mask = 0)</code></pre><p>Return an abstract representation of a masking procedure applied when <code>condition</code> is satisfied on a field described by <code>func(operand)</code>.</p><p><strong>Positional arguments</strong></p><ul><li><code>operand</code>: The <code>AbstractField</code> to be masked (it must have a <code>grid</code> property!)</li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>func</code>: A unary transformation applied element-wise to the field <code>operand</code> at locations where         <code>condition == true</code>. Default is <code>identity</code>.</p></li><li><p><code>condition</code>: either a function of <code>(i, j, k, grid, operand)</code> returning a Boolean,              or a 3-dimensional Boolean <code>AbstractArray</code>. At locations where <code>condition == false</code>,              operand will be masked by <code>mask</code></p></li><li><p><code>mask</code>: the scalar mask</p></li></ul><p><code>condition_operand</code> is a convenience function used to construct a <code>ConditionalOperation</code></p><p><code>condition_operand(func::Function, operand::AbstractField, condition, mask) = ConditionalOperation(operand; func, condition, mask)</code></p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; using Oceananigans.Fields: condition_operand

julia&gt; c = CenterField(RectilinearGrid(size=(2, 1, 1), extent=(1, 1, 1)));

julia&gt; f(i, j, k, grid, c) = i &lt; 2; d = condition_operand(cos, c, f, 10)
ConditionalOperation at (Center, Center, Center)
├── operand: 2×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU
├── grid: 2×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo
├── func: cos (generic function with 30 methods)
├── condition: f (generic function with 1 method)
└── mask: 10

julia&gt; d[1, 1, 1]
1.0

julia&gt; d[2, 1, 1]
10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/AbstractOperations/conditional_operations.jl#L20-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.Derivative-Union{Tuple{G}, Tuple{AD}, Tuple{IN}, Tuple{A}, Tuple{D}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{D, A, IN, AD, G}} where {LX, LY, LZ, D, A, IN, AD, G}" href="#Oceananigans.AbstractOperations.Derivative-Union{Tuple{G}, Tuple{AD}, Tuple{IN}, Tuple{A}, Tuple{D}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{D, A, IN, AD, G}} where {LX, LY, LZ, D, A, IN, AD, G}"><code>Oceananigans.AbstractOperations.Derivative</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Derivative{LX, LY, LZ}(∂, arg, ▶, grid)</code></pre><p>Return an abstract representation of the derivative <code>∂</code> on <code>arg</code>, and subsequent interpolation by <code>▶</code> on <code>grid</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/AbstractOperations/derivatives.jl#L10-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.Integral-Tuple{Oceananigans.Fields.AbstractField}" href="#Oceananigans.AbstractOperations.Integral-Tuple{Oceananigans.Fields.AbstractField}"><code>Oceananigans.AbstractOperations.Integral</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Integral(field; dims=:)</code></pre><p>Return a <code>Reduction</code> representing a spatial integral of <code>field</code> over <code>dims</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/AbstractOperations/metric_field_reductions.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.KernelFunctionOperation-Union{Tuple{G}, Tuple{K}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{K, G, Vararg{Any}}} where {LX, LY, LZ, K, G}" href="#Oceananigans.AbstractOperations.KernelFunctionOperation-Union{Tuple{G}, Tuple{K}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{K, G, Vararg{Any}}} where {LX, LY, LZ, K, G}"><code>Oceananigans.AbstractOperations.KernelFunctionOperation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">KernelFunctionOperation{LX, LY, LZ}(kernel_function, grid, arguments...)</code></pre><p>Construct a <code>KernelFunctionOperation</code> at location <code>(LX, LY, LZ)</code> on <code>grid</code> with <code>arguments</code>.</p><p><code>kernel_function</code> is called with</p><pre><code class="language-julia hljs">kernel_function(i, j, k, grid, arguments...)</code></pre><p>Note that <code>compute!(kfo::KernelFunctionOperation)</code> calls <code>compute!</code> on all <code>kfo.arguments</code>.</p><p><strong>Examples</strong></p><p>Construct a <code>KernelFunctionOperation</code> that returns random numbers:</p><pre><code class="language-julia hljs">using Oceananigans

grid = RectilinearGrid(size=(1, 8, 8), extent=(1, 1, 1));

random_kernel_function(i, j, k, grid) = rand(); # use CUDA.rand on the GPU

kernel_op = KernelFunctionOperation{Center, Center, Center}(random_kernel_function, grid)

# output

KernelFunctionOperation at (Center, Center, Center)
├── grid: 1×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo
├── kernel_function: random_kernel_function (generic function with 1 method)
└── arguments: ()</code></pre><p>Construct a <code>KernelFunctionOperation</code> using the vertical vorticity operator used internally to compute vertical vorticity on all grids:</p><pre><code class="language-julia hljs">using Oceananigans.Operators: ζ₃ᶠᶠᶜ # called with signature ζ₃ᶠᶠᶜ(i, j, k, grid, u, v)

model = HydrostaticFreeSurfaceModel(; grid);

u, v, w = model.velocities;

ζ_op = KernelFunctionOperation{Face, Face, Center}(ζ₃ᶠᶠᶜ, grid, u, v)

# output

KernelFunctionOperation at (Face, Face, Center)
├── grid: 1×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo
├── kernel_function: ζ₃ᶠᶠᶜ (generic function with 1 method)
└── arguments: (&quot;1×8×8 Field{Face, Center, Center} on RectilinearGrid on CPU&quot;, &quot;1×8×8 Field{Center, Face, Center} on RectilinearGrid on CPU&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/AbstractOperations/kernel_function_operation.jl#L8-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.UnaryOperation-Union{Tuple{G}, Tuple{IN}, Tuple{A}, Tuple{O}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{O, A, IN, G}} where {LX, LY, LZ, O, A, IN, G}" href="#Oceananigans.AbstractOperations.UnaryOperation-Union{Tuple{G}, Tuple{IN}, Tuple{A}, Tuple{O}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{O, A, IN, G}} where {LX, LY, LZ, O, A, IN, G}"><code>Oceananigans.AbstractOperations.UnaryOperation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">UnaryOperation{LX, LY, LZ}(op, arg, ▶, grid)</code></pre><p>Returns an abstract <code>UnaryOperation</code> representing the action of <code>op</code> on <code>arg</code>, and subsequent interpolation by <code>▶</code> on <code>grid</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/AbstractOperations/unary_operations.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.∂x-Tuple{Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}}" href="#Oceananigans.AbstractOperations.∂x-Tuple{Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}}"><code>Oceananigans.AbstractOperations.∂x</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the <span>$x$</span>-derivative function acting at (<code>X</code>, <code>Y</code>, <code>Any</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/AbstractOperations/derivatives.jl#L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.∂x-Union{Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Tuple, Oceananigans.Fields.AbstractField{LX, LY, LZ}}} where {LX, LY, LZ}" href="#Oceananigans.AbstractOperations.∂x-Union{Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Tuple, Oceananigans.Fields.AbstractField{LX, LY, LZ}}} where {LX, LY, LZ}"><code>Oceananigans.AbstractOperations.∂x</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∂x(L::Tuple, arg::AbstractField)</code></pre><p>Return an abstract representation of an <span>$x$</span>-derivative acting on field <code>arg</code> followed by interpolation to <code>L</code>, where <code>L</code> is a 3-tuple of <code>Face</code>s and <code>Center</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/AbstractOperations/derivatives.jl#L59-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.∂x-Union{Tuple{Oceananigans.Fields.AbstractField{LX, LY, LZ}}, Tuple{LZ}, Tuple{LY}, Tuple{LX}} where {LX, LY, LZ}" href="#Oceananigans.AbstractOperations.∂x-Union{Tuple{Oceananigans.Fields.AbstractField{LX, LY, LZ}}, Tuple{LZ}, Tuple{LY}, Tuple{LX}} where {LX, LY, LZ}"><code>Oceananigans.AbstractOperations.∂x</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∂x(arg::AbstractField)</code></pre><p>Return an abstract representation of a <span>$x$</span>-derivative acting on field <code>arg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/AbstractOperations/derivatives.jl#L88-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.∂y-Tuple{Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}}" href="#Oceananigans.AbstractOperations.∂y-Tuple{Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}}"><code>Oceananigans.AbstractOperations.∂y</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the <span>$y$</span>-derivative function acting at (<code>X</code>, <code>Y</code>, <code>Any</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/AbstractOperations/derivatives.jl#L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.∂y-Union{Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Tuple, Oceananigans.Fields.AbstractField{LX, LY, LZ}}} where {LX, LY, LZ}" href="#Oceananigans.AbstractOperations.∂y-Union{Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Tuple, Oceananigans.Fields.AbstractField{LX, LY, LZ}}} where {LX, LY, LZ}"><code>Oceananigans.AbstractOperations.∂y</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∂y(L::Tuple, arg::AbstractField)</code></pre><p>Return an abstract representation of a <span>$y$</span>-derivative acting on field <code>arg</code> followed by interpolation to <code>L</code>, where <code>L</code> is a 3-tuple of <code>Face</code>s and <code>Center</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/AbstractOperations/derivatives.jl#L68-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.∂y-Union{Tuple{Oceananigans.Fields.AbstractField{LX, LY, LZ}}, Tuple{LZ}, Tuple{LY}, Tuple{LX}} where {LX, LY, LZ}" href="#Oceananigans.AbstractOperations.∂y-Union{Tuple{Oceananigans.Fields.AbstractField{LX, LY, LZ}}, Tuple{LZ}, Tuple{LY}, Tuple{LX}} where {LX, LY, LZ}"><code>Oceananigans.AbstractOperations.∂y</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∂y(arg::AbstractField)</code></pre><p>Return an abstract representation of a <span>$y$</span>-derivative acting on field <code>arg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/AbstractOperations/derivatives.jl#L95-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.∂z-Tuple{Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}}" href="#Oceananigans.AbstractOperations.∂z-Tuple{Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}, Union{Type{Nothing}, Type{Center}, Type{Face}}}"><code>Oceananigans.AbstractOperations.∂z</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the <span>$z$</span>-derivative function acting at (<code>Any</code>, <code>Any</code>, <code>Z</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/AbstractOperations/derivatives.jl#L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.∂z-Union{Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Tuple, Oceananigans.Fields.AbstractField{LX, LY, LZ}}} where {LX, LY, LZ}" href="#Oceananigans.AbstractOperations.∂z-Union{Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Tuple, Oceananigans.Fields.AbstractField{LX, LY, LZ}}} where {LX, LY, LZ}"><code>Oceananigans.AbstractOperations.∂z</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∂z(L::Tuple, arg::AbstractField)</code></pre><p>Return an abstract representation of a <span>$z$</span>-derivative acting on field <code>arg</code> followed by  interpolation to <code>L</code>, where <code>L</code> is a 3-tuple of <code>Face</code>s and <code>Center</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/AbstractOperations/derivatives.jl#L77-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.∂z-Union{Tuple{Oceananigans.Fields.AbstractField{LX, LY, LZ}}, Tuple{LZ}, Tuple{LY}, Tuple{LX}} where {LX, LY, LZ}" href="#Oceananigans.AbstractOperations.∂z-Union{Tuple{Oceananigans.Fields.AbstractField{LX, LY, LZ}}, Tuple{LZ}, Tuple{LY}, Tuple{LX}} where {LX, LY, LZ}"><code>Oceananigans.AbstractOperations.∂z</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∂z(arg::AbstractField)</code></pre><p>Return an abstract representation of a <span>$z$</span>-derivative acting on field <code>arg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/AbstractOperations/derivatives.jl#L102-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.@at-Tuple{Any, Any}" href="#Oceananigans.AbstractOperations.@at-Tuple{Any, Any}"><code>Oceananigans.AbstractOperations.@at</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@at location abstract_operation</code></pre><p>Modify the <code>abstract_operation</code> so that it returns values at <code>location</code>, where <code>location</code> is a 3-tuple of <code>Face</code>s and <code>Center</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/AbstractOperations/at.jl#L36-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.@binary-Tuple" href="#Oceananigans.AbstractOperations.@binary-Tuple"><code>Oceananigans.AbstractOperations.@binary</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@binary op1 op2 op3...</code></pre><p>Turn each binary function in the list <code>(op1, op2, op3...)</code> into a binary operator on <code>Oceananigans.Fields</code> for use in <code>AbstractOperations</code>.</p><p>Note: a binary function is a function with two arguments: for example, <code>+(x, y)</code> is a binary function.</p><p>Also note: a binary function in <code>Base</code> must be imported to be extended: use <code>import Base: op; @binary op</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans, Oceananigans.AbstractOperations

julia&gt; using Oceananigans.AbstractOperations: BinaryOperation, AbstractGridMetric, choose_location

julia&gt; plus_or_times(x, y) = x &lt; 0 ? x + y : x * y
plus_or_times (generic function with 1 method)

julia&gt; @binary plus_or_times
Set{Any} with 6 elements:
  :+
  :/
  :^
  :-
  :*
  :plus_or_times

julia&gt; c, d = (CenterField(RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))) for i = 1:2);

julia&gt; plus_or_times(c, d)
BinaryOperation at (Center, Center, Center)
├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo
└── tree:
    plus_or_times at (Center, Center, Center)
    ├── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU
    └── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/AbstractOperations/binary_operations.jl#L138-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.@multiary-Tuple" href="#Oceananigans.AbstractOperations.@multiary-Tuple"><code>Oceananigans.AbstractOperations.@multiary</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@multiary op1 op2 op3...</code></pre><p>Turn each multiary operator in the list <code>(op1, op2, op3...)</code> into a multiary operator on <code>Oceananigans.Fields</code> for use in <code>AbstractOperations</code>.</p><p>Note that a multiary operator:</p><ul><li>is a function with two or more arguments: for example, <code>+(x, y, z)</code> is a multiary function;</li><li>must be imported to be extended if part of <code>Base</code>: use <code>import Base: op; @multiary op</code>;</li><li>can only be called on <code>Oceananigans.Field</code>s if the &quot;location&quot; is noted explicitly; see example.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans, Oceananigans.AbstractOperations

julia&gt; harmonic_plus(a, b, c) = 1/3 * (1/a + 1/b + 1/c)
harmonic_plus (generic function with 1 method)

julia&gt; c, d, e = Tuple(CenterField(RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))) for i = 1:3);

julia&gt; harmonic_plus(c, d, e) # before magic @multiary transformation
BinaryOperation at (Center, Center, Center)
├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo
└── tree:
    * at (Center, Center, Center)
    ├── 0.3333333333333333
    └── + at (Center, Center, Center)
        ├── / at (Center, Center, Center)
        │   ├── 1
        │   └── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU
        ├── / at (Center, Center, Center)
        │   ├── 1
        │   └── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU
        └── / at (Center, Center, Center)
            ├── 1
            └── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU

julia&gt; @multiary harmonic_plus
Set{Any} with 3 elements:
  :+
  :harmonic_plus
  :*

julia&gt; harmonic_plus(c, d, e)
MultiaryOperation at (Center, Center, Center)
├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo
└── tree:
    harmonic_plus at (Center, Center, Center)
    ├── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU
    ├── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU
    └── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/AbstractOperations/multiary_operations.jl#L59-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.AbstractOperations.@unary-Tuple" href="#Oceananigans.AbstractOperations.@unary-Tuple"><code>Oceananigans.AbstractOperations.@unary</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@unary op1 op2 op3...</code></pre><p>Turn each unary function in the list <code>(op1, op2, op3...)</code> into a unary operator on <code>Oceananigans.Fields</code> for use in <code>AbstractOperations</code>.</p><p>Note: a unary function is a function with one argument: for example, <code>sin(x)</code> is a unary function.</p><p>Also note: a unary function in <code>Base</code> must be imported to be extended: use <code>import Base: op; @unary op</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans, Oceananigans.Grids, Oceananigans.AbstractOperations

julia&gt; square_it(x) = x^2
square_it (generic function with 1 method)

julia&gt; @unary square_it
Set{Any} with 10 elements:
  :+
  :sqrt
  :square_it
  :cos
  :exp
  :interpolate_identity
  :-
  :tanh
  :sin
  :abs

julia&gt; c = CenterField(RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)));

julia&gt; square_it(c)
UnaryOperation at (Center, Center, Center)
├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo
└── tree:
    square_it at (Center, Center, Center) via identity
    └── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/AbstractOperations/unary_operations.jl#L39-L80">source</a></section></article><h2 id="Advection"><a class="docs-heading-anchor" href="#Advection">Advection</a><a id="Advection-1"></a><a class="docs-heading-anchor-permalink" href="#Advection" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.Centered" href="#Oceananigans.Advection.Centered"><code>Oceananigans.Advection.Centered</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Centered{N, FT, XT, YT, ZT, CA} &lt;: AbstractCenteredAdvectionScheme{N, FT}</code></pre><p>Centered reconstruction scheme.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Advection/centered_reconstruction.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.UpwindBiased" href="#Oceananigans.Advection.UpwindBiased"><code>Oceananigans.Advection.UpwindBiased</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct UpwindBiasedFifthOrder &lt;: AbstractUpwindBiasedAdvectionScheme{3}</code></pre><p>Upwind-biased fifth-order advection scheme.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Advection/upwind_biased_reconstruction.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.VectorInvariant-Union{Tuple{}, Tuple{FT}, Tuple{N}} where {N, FT}" href="#Oceananigans.Advection.VectorInvariant-Union{Tuple{}, Tuple{FT}, Tuple{N}} where {N, FT}"><code>Oceananigans.Advection.VectorInvariant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">VectorInvariant(; vorticity_scheme::AbstractAdvectionScheme{N, FT} = EnstrophyConservingScheme(), 
                  vorticity_stencil  = VelocityStencil(),
                  vertical_scheme    = EnergyConservingScheme()) where {N, FT}</code></pre><p>Construct a vector invariant momentum advection scheme of order <code>N * 2 - 1</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>vorticity_scheme</code>: Scheme used for <code>Center</code> reconstruction of vorticity, options are upwind advection schemes                     - <code>UpwindBiased()</code> and <code>WENO()</code> - in addition to an <code>EnergyConservingScheme()</code> and an <code>EnstrophyConservingScheme()</code>                     (defaults to <code>EnstrophyConservingScheme()</code>).</li><li><code>vorticity_stencil</code>: Stencil used for smoothness indicators in case of a <code>WENO</code> upwind reconstruction. Choices are between <code>VelocityStencil</code>                      which uses the horizontal velocity field to diagnose smoothness and <code>DefaultStencil</code> which uses the variable                      being transported (defaults to <code>VelocityStencil()</code>)</li><li><code>vertical_scheme</code>: Scheme used for vertical advection of horizontal momentum and upwinding of divergence and kinetic energy gradient. Defaults to <code>EnergyConservingScheme()</code>.)</li><li><code>upwinding</code>: Treatment of upwinding in case of Upwinding reconstruction of divergence and kinetic energy gradient. Choices are between                        <code>CrossAndSelfUpwinding()</code>, <code>OnlySelfUpwinding()</code>, and <code>VelocityUpwinding()</code> (defaults to <code>OnlySelfUpwinding()</code>).</li><li><code>multi_dimensional_stencil</code> : if <code>true</code>, use a horizontal two dimensional stencil for the reconstruction of vorticity, divergence and kinetic energy gradient.                               The tangential direction is <em>always</em> treated with a 5th-order centered WENO reconstruction.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; VectorInvariant()
Vector Invariant, Dimension-by-dimension reconstruction 
 Vorticity flux scheme: 
 └── EnstrophyConservingScheme{Float64} 
 Vertical advection / Divergence flux scheme: 
 └── EnergyConservingScheme{Float64}
</code></pre><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; VectorInvariant(vorticity_scheme = WENO(), vertical_scheme = WENO(order = 3))
Vector Invariant, Dimension-by-dimension reconstruction 
 Vorticity flux scheme: 
 ├── WENO reconstruction order 5 
 └── smoothness ζ: Oceananigans.Advection.VelocityStencil()
 Vertical advection / Divergence flux scheme: 
 ├── WENO reconstruction order 3
 └── upwinding treatment: OnlySelfUpwinding 
 KE gradient and Divergence flux cross terms reconstruction: 
 └── Centered reconstruction order 2
 Smoothness measures: 
 ├── smoothness δU: FunctionStencil f = divergence_smoothness
 ├── smoothness δV: FunctionStencil f = divergence_smoothness
 ├── smoothness δu²: FunctionStencil f = u_smoothness
 └── smoothness δv²: FunctionStencil f = v_smoothness
      </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Advection/vector_invariant_advection.jl#L21-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.WENO" href="#Oceananigans.Advection.WENO"><code>Oceananigans.Advection.WENO</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WENO([FT=Float64;] 
     order = 5,
     grid = nothing, 
     zweno = true, 
     bounds = nothing)</code></pre><p>Construct a weigthed essentially non-oscillatory advection scheme of order <code>order</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>order</code>: The order of the WENO advection scheme. Default: 5</li><li><code>grid</code>: (defaults to <code>nothing</code>)</li><li><code>zweno</code>: When <code>true</code> implement a Z-WENO formulation for the WENO weights calculation.          (defaults to <code>true</code>)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; WENO()
WENO reconstruction order 5
 Smoothness formulation: 
    └── Z-weno  
 Boundary scheme: 
    └── WENO reconstruction order 3
 Symmetric scheme: 
    └── Centered reconstruction order 4
 Directions:
    ├── X regular 
    ├── Y regular 
    └── Z regular</code></pre><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; Nx, Nz = 16, 10;

julia&gt; Lx, Lz = 1e4, 1e3;

julia&gt; chebychev_spaced_z_faces(k) = - Lz/2 - Lz/2 * cos(π * (k - 1) / Nz);

julia&gt; grid = RectilinearGrid(size = (Nx, Nz), halo = (4, 4), topology=(Periodic, Flat, Bounded),
                              x = (0, Lx), z = chebychev_spaced_z_faces);

julia&gt; WENO(grid; order=7)
WENO reconstruction order 7
 Smoothness formulation: 
    └── Z-weno  
 Boundary scheme: 
    └── WENO reconstruction order 5
 Symmetric scheme: 
    └── Centered reconstruction order 6
 Directions:
    ├── X regular 
    ├── Y regular 
    └── Z stretched</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Advection/weno_reconstruction.jl#L41-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.div_Uc-NTuple{7, Any}" href="#Oceananigans.Advection.div_Uc-NTuple{7, Any}"><code>Oceananigans.Advection.div_Uc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">div_uc(i, j, k, grid, advection, U, c)</code></pre><p>Calculate the divergence of the flux of a tracer quantity <span>$c$</span> being advected by a velocity field, <span>$𝛁⋅(𝐯 c)$</span>,</p><pre><code class="nohighlight hljs">1/V * [δxᶜᵃᵃ(Ax * u * ℑxᶠᵃᵃ(c)) + δyᵃᶜᵃ(Ay * v * ℑyᵃᶠᵃ(c)) + δzᵃᵃᶜ(Az * w * ℑzᵃᵃᶠ(c))]</code></pre><p>which ends up at the location <code>ccc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Advection/tracer_advection_operators.jl#L19-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.div_𝐯u-NTuple{7, Any}" href="#Oceananigans.Advection.div_𝐯u-NTuple{7, Any}"><code>Oceananigans.Advection.div_𝐯u</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">div_𝐯u(i, j, k, grid, advection, U, u)</code></pre><p>Calculate the advection of momentum in the <span>$x$</span>-direction using the conservative form, <span>$𝛁⋅(𝐯 u)$</span>,</p><pre><code class="nohighlight hljs">1/Vᵘ * [δxᶠᵃᵃ(ℑxᶜᵃᵃ(Ax * u) * ℑxᶜᵃᵃ(u)) + δy_fca(ℑxᶠᵃᵃ(Ay * v) * ℑyᵃᶠᵃ(u)) + δz_fac(ℑxᶠᵃᵃ(Az * w) * ℑzᵃᵃᶠ(u))]</code></pre><p>which ends up at the location <code>fcc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Advection/momentum_advection_operators.jl#L43-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.div_𝐯v-NTuple{7, Any}" href="#Oceananigans.Advection.div_𝐯v-NTuple{7, Any}"><code>Oceananigans.Advection.div_𝐯v</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">div_𝐯v(i, j, k, grid, advection, U, v)</code></pre><p>Calculate the advection of momentum in the <span>$y$</span>-direction using the conservative form, <span>$𝛁⋅(𝐯 v)$</span>,</p><pre><code class="nohighlight hljs">1/Vʸ * [δx_cfa(ℑyᵃᶠᵃ(Ax * u) * ℑxᶠᵃᵃ(v)) + δyᵃᶠᵃ(ℑyᵃᶜᵃ(Ay * v) * ℑyᵃᶜᵃ(v)) + δz_afc(ℑxᶠᵃᵃ(Az * w) * ℑzᵃᵃᶠ(w))]</code></pre><p>which ends up at the location <code>cfc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Advection/momentum_advection_operators.jl#L60-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Advection.div_𝐯w-NTuple{7, Any}" href="#Oceananigans.Advection.div_𝐯w-NTuple{7, Any}"><code>Oceananigans.Advection.div_𝐯w</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">div_𝐯w(i, j, k, grid, advection, U, w)</code></pre><p>Calculate the advection of momentum in the <span>$z$</span>-direction using the conservative form, <span>$𝛁⋅(𝐯 w)$</span>,</p><pre><code class="nohighlight hljs">1/Vʷ * [δx_caf(ℑzᵃᵃᶠ(Ax * u) * ℑxᶠᵃᵃ(w)) + δy_acf(ℑzᵃᵃᶠ(Ay * v) * ℑyᵃᶠᵃ(w)) + δzᵃᵃᶠ(ℑzᵃᵃᶜ(Az * w) * ℑzᵃᵃᶜ(w))]</code></pre><p>which ends up at the location <code>ccf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Advection/momentum_advection_operators.jl#L77-L86">source</a></section></article><h2 id="Architectures"><a class="docs-heading-anchor" href="#Architectures">Architectures</a><a id="Architectures-1"></a><a class="docs-heading-anchor-permalink" href="#Architectures" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Architectures.AbstractArchitecture" href="#Oceananigans.Architectures.AbstractArchitecture"><code>Oceananigans.Architectures.AbstractArchitecture</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractArchitecture</code></pre><p>Abstract supertype for architectures supported by Oceananigans.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Architectures.jl#L12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Architectures.CPU" href="#Oceananigans.Architectures.CPU"><code>Oceananigans.Architectures.CPU</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CPU &lt;: AbstractArchitecture</code></pre><p>Run Oceananigans on one CPU node. Uses multiple threads if the environment variable <code>JULIA_NUM_THREADS</code> is set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Architectures.jl#L19-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Architectures.GPU" href="#Oceananigans.Architectures.GPU"><code>Oceananigans.Architectures.GPU</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GPU &lt;: AbstractArchitecture</code></pre><p>Run Oceananigans on a single NVIDIA CUDA GPU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Architectures.jl#L27-L31">source</a></section></article><h2 id="Boundary-conditions"><a class="docs-heading-anchor" href="#Boundary-conditions">Boundary conditions</a><a id="Boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-conditions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.BoundaryCondition" href="#Oceananigans.BoundaryConditions.BoundaryCondition"><code>Oceananigans.BoundaryConditions.BoundaryCondition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct BoundaryCondition{C&lt;:AbstractBoundaryConditionClassification, T}</code></pre><p>Container for boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/BoundaryConditions/boundary_condition.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.BoundaryCondition-Tuple{DataType, Any}" href="#Oceananigans.BoundaryConditions.BoundaryCondition-Tuple{DataType, Any}"><code>Oceananigans.BoundaryConditions.BoundaryCondition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoundaryCondition(Classification::DataType, condition)</code></pre><p>Construct a boundary condition of type <code>BC</code> with a number or array as a <code>condition</code>.</p><p>Boundary condition types include <code>Periodic</code>, <code>Flux</code>, <code>Value</code>, <code>Gradient</code>, and <code>Open</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/BoundaryConditions/boundary_condition.jl#L13-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.BoundaryCondition-Tuple{DataType, Function}" href="#Oceananigans.BoundaryConditions.BoundaryCondition-Tuple{DataType, Function}"><code>Oceananigans.BoundaryConditions.BoundaryCondition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoundaryCondition(Classification::DataType, condition::Function;
                  parameters = nothing,
                  discrete_form = false,
                  field_dependencies=())</code></pre><p>Construct a boundary condition of type <code>Classification</code> with a function boundary <code>condition</code>.</p><p>By default, the function boudnary <code>condition</code> is assumed to have the &#39;continuous form&#39; <code>condition(ξ, η, t)</code>, where <code>t</code> is time and <code>ξ</code> and <code>η</code> vary along the boundary. In particular:</p><ul><li>On <code>x</code>-boundaries, <code>condition(y, z, t)</code>.</li><li>On <code>y</code>-boundaries, <code>condition(x, z, t)</code>.</li><li>On <code>z</code>-boundaries, <code>condition(x, y, t)</code>.</li></ul><p>If <code>parameters</code> is not <code>nothing</code>, then function boundary conditions have the form <code>func(ξ, η, t, parameters)</code>, where <code>ξ</code> and <code>η</code> are spatial coordinates varying along the boundary as explained above.</p><p>If <code>discrete_form = true</code>, the function <code>condition</code> is assumed to have the &quot;discrete form&quot;,</p><pre><code class="nohighlight hljs">condition(i, j, grid, clock, model_fields)</code></pre><p>where <code>i</code>, and <code>j</code> are indices that vary along the boundary. If <code>discrete_form = true</code> and <code>parameters</code> is not <code>nothing</code>, the function <code>condition</code> is called with</p><pre><code class="nohighlight hljs">condition(i, j, grid, clock, model_fields, parameters)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/BoundaryConditions/boundary_condition.jl#L22-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.FieldBoundaryConditions" href="#Oceananigans.BoundaryConditions.FieldBoundaryConditions"><code>Oceananigans.BoundaryConditions.FieldBoundaryConditions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FieldBoundaryConditions(; kwargs...)</code></pre><p>Return a template for boundary conditions on prognostic fields.</p><p><strong>Keyword arguments</strong></p><p>Keyword arguments specify boundary conditions on the 7 possible boundaries:</p><ul><li><code>west</code>: left end point in the <code>x</code>-direction where <code>i = 1</code></li><li><code>east</code>: right end point in the <code>x</code>-direction where <code>i = grid.Nx</code></li><li><code>south</code>: left end point in the <code>y</code>-direction where <code>j = 1</code></li><li><code>north</code>: right end point in the <code>y</code>-direction where <code>j = grid.Ny</code></li><li><code>bottom</code>: right end point in the <code>z</code>-direction where <code>k = 1</code></li><li><code>top</code>: right end point in the <code>z</code>-direction where <code>k = grid.Nz</code></li><li><code>immersed</code>: boundary between solid and fluid for immersed boundaries</li></ul><p>If a boundary condition is unspecified, the default for prognostic fields and the topology in the boundary-normal direction is used:</p><ul><li><code>PeriodicBoundaryCondition</code> for <code>Periodic</code> directions</li><li><code>NoFluxBoundaryCondition</code> for <code>Bounded</code> directions and <code>Centered</code>-located fields</li><li><code>ImpenetrableBoundaryCondition</code> for <code>Bounded</code> directions and <code>Face</code>-located fields</li><li><code>nothing</code> for <code>Flat</code> directions and/or <code>Nothing</code>-located fields</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/BoundaryConditions/field_boundary_conditions.jl#L65-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.FieldBoundaryConditions" href="#Oceananigans.BoundaryConditions.FieldBoundaryConditions"><code>Oceananigans.BoundaryConditions.FieldBoundaryConditions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FieldBoundaryConditions(grid, location, indices=(:, :, :);
                        west     = default_auxiliary_bc(topology(grid, 1)(), location[1]()),
                        east     = default_auxiliary_bc(topology(grid, 1)(), location[1]()),
                        south    = default_auxiliary_bc(topology(grid, 2)(), location[2]()),
                        north    = default_auxiliary_bc(topology(grid, 2)(), location[2]()),
                        bottom   = default_auxiliary_bc(topology(grid, 3)(), location[3]()),
                        top      = default_auxiliary_bc(topology(grid, 3)(), location[3]()),
                        immersed = NoFluxBoundaryCondition())</code></pre><p>Return boundary conditions for auxiliary fields (fields whose values are derived from a model&#39;s prognostic fields) on <code>grid</code> and at <code>location</code>.</p><p><strong>Keyword arguments</strong></p><p>Keyword arguments specify boundary conditions on the 6 possible boundaries:</p><ul><li><code>west</code>, left end point in the <code>x</code>-direction where <code>i = 1</code></li><li><code>east</code>, right end point in the <code>x</code>-direction where <code>i = grid.Nx</code></li><li><code>south</code>, left end point in the <code>y</code>-direction where <code>j = 1</code></li><li><code>north</code>, right end point in the <code>y</code>-direction where <code>j = grid.Ny</code></li><li><code>bottom</code>, right end point in the <code>z</code>-direction where <code>k = 1</code></li><li><code>top</code>, right end point in the <code>z</code>-direction where <code>k = grid.Nz</code></li><li><code>immersed</code>: boundary between solid and fluid for immersed boundaries</li></ul><p>If a boundary condition is unspecified, the default for auxiliary fields and the topology in the boundary-normal direction is used:</p><ul><li><code>PeriodicBoundaryCondition</code> for <code>Periodic</code> directions</li><li><code>GradientBoundaryCondition(0)</code> for <code>Bounded</code> directions and <code>Centered</code>-located fields</li><li><code>nothing</code> for <code>Bounded</code> directions and <code>Face</code>-located fields</li><li><code>nothing</code> for <code>Flat</code> directions and/or <code>Nothing</code>-located fields</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/BoundaryConditions/field_boundary_conditions.jl#L101-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.Flux" href="#Oceananigans.BoundaryConditions.Flux"><code>Oceananigans.BoundaryConditions.Flux</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Flux &lt;: AbstractBoundaryConditionClassification</code></pre><p>A classification specifying a boundary condition on the flux of a field.</p><p>The sign convention is such that a positive flux represents the flux of a quantity in the positive direction. For example, a positive vertical flux implies a quantity is fluxed upwards, in the <span>$+z$</span> direction.</p><p>Due to this convention, a positive flux applied to the top boundary specifies that a quantity is fluxed upwards across the top boundary and thus out of the domain. As a result, a positive flux applied to a top boundary leads to a reduction of that quantity in the interior of the domain; for example, a positive, upwards flux of heat at the top of the domain acts to cool the interior of the domain. Conversely, a positive flux applied to the bottom boundary leads to an increase of the quantity in the interior of the domain. The same logic holds for east, west, north, and south boundaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/BoundaryConditions/boundary_condition_classifications.jl#L17-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.Gradient" href="#Oceananigans.BoundaryConditions.Gradient"><code>Oceananigans.BoundaryConditions.Gradient</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Gradient &lt;: AbstractBoundaryConditionClassification</code></pre><p>A classification specifying a boundary condition on the derivative or gradient of a field. Also called a Neumann boundary condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/BoundaryConditions/boundary_condition_classifications.jl#L36-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.Open" href="#Oceananigans.BoundaryConditions.Open"><code>Oceananigans.BoundaryConditions.Open</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Open &lt;: AbstractBoundaryConditionClassification</code></pre><p>A classification that specifies the halo regions of a field directly.</p><p>For fields located at Faces, Open also specifies field value <em>on</em> the boundary.</p><p>Open boundary conditions are used to specify the component of a velocity field normal to a boundary and can also be used to describe nested or linked simulation domains.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/BoundaryConditions/boundary_condition_classifications.jl#L52-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.Value" href="#Oceananigans.BoundaryConditions.Value"><code>Oceananigans.BoundaryConditions.Value</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Value &lt;: AbstractBoundaryConditionClassification</code></pre><p>A classification specifying a boundary condition on the value of a field. Also called a Dirchlet boundary condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/BoundaryConditions/boundary_condition_classifications.jl#L44-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.apply_x_bcs!-Tuple{Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any, Oceananigans.Architectures.AbstractArchitecture, Vararg{Any}}" href="#Oceananigans.BoundaryConditions.apply_x_bcs!-Tuple{Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any, Oceananigans.Architectures.AbstractArchitecture, Vararg{Any}}"><code>Oceananigans.BoundaryConditions.apply_x_bcs!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Apply flux boundary conditions to a field <code>c</code> by adding the associated flux divergence to the source term <code>Gc</code> at the left and right.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/BoundaryConditions/apply_flux_bcs.jl#L31-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.apply_y_bcs!-Tuple{Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any, Oceananigans.Architectures.AbstractArchitecture, Vararg{Any}}" href="#Oceananigans.BoundaryConditions.apply_y_bcs!-Tuple{Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any, Oceananigans.Architectures.AbstractArchitecture, Vararg{Any}}"><code>Oceananigans.BoundaryConditions.apply_y_bcs!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Apply flux boundary conditions to a field <code>c</code> by adding the associated flux divergence to the source term <code>Gc</code> at the left and right.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/BoundaryConditions/apply_flux_bcs.jl#L38-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.apply_z_bcs!-Tuple{Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any, Oceananigans.Architectures.AbstractArchitecture, Vararg{Any}}" href="#Oceananigans.BoundaryConditions.apply_z_bcs!-Tuple{Any, Oceananigans.Grids.AbstractGrid, Any, Any, Any, Oceananigans.Architectures.AbstractArchitecture, Vararg{Any}}"><code>Oceananigans.BoundaryConditions.apply_z_bcs!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Apply flux boundary conditions to a field <code>c</code> by adding the associated flux divergence to the source term <code>Gc</code> at the top and bottom.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/BoundaryConditions/apply_flux_bcs.jl#L45-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BoundaryConditions.fill_halo_regions!-Tuple{Union{Tuple{Vararg{OffsetArrays.OffsetArray, var&quot;#s236&quot;}} where var&quot;#s236&quot;, OffsetArrays.OffsetArray}, Any, Any, Any, Any, Vararg{Any}}" href="#Oceananigans.BoundaryConditions.fill_halo_regions!-Tuple{Union{Tuple{Vararg{OffsetArrays.OffsetArray, var&quot;#s236&quot;}} where var&quot;#s236&quot;, OffsetArrays.OffsetArray}, Any, Any, Any, Any, Vararg{Any}}"><code>Oceananigans.BoundaryConditions.fill_halo_regions!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Fill halo regions in <span>$x$</span>, <span>$y$</span>, and <span>$z$</span> for a given field&#39;s data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/BoundaryConditions/fill_halo_regions.jl#L51">source</a></section></article><h2 id="Buoyancy-models"><a class="docs-heading-anchor" href="#Buoyancy-models">Buoyancy models</a><a id="Buoyancy-models-1"></a><a class="docs-heading-anchor-permalink" href="#Buoyancy-models" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BuoyancyModels.Buoyancy-Tuple{}" href="#Oceananigans.BuoyancyModels.Buoyancy-Tuple{}"><code>Oceananigans.BuoyancyModels.Buoyancy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Buoyancy(; model, gravity_unit_vector=NegativeZDirection())</code></pre><p>Construct a <code>buoyancy</code> given a buoyancy <code>model</code>. Optional keyword argument <code>gravity_unit_vector</code> can be used to specify the direction of gravity (default <code>NegativeZDirection()</code>). The buoyancy acceleration acts in the direction opposite to gravity.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">
using Oceananigans

grid = RectilinearGrid(size=(1, 8, 8), extent=(1, 1, 1))

θ = 45 # degrees
g̃ = (0, sind(θ), cosd(θ));

buoyancy = Buoyancy(model=BuoyancyTracer(), gravity_unit_vector=g̃)

model = NonhydrostaticModel(grid=grid, buoyancy=buoyancy, tracers=:b)

# output

┌ Warning: The meaning of `gravity_unit_vector` changed in version 0.80.0.
│ In versions 0.79 and earlier, `gravity_unit_vector` indicated the direction _opposite_ to gravity.
│ In versions 0.80.0 and later, `gravity_unit_vector` indicates the direction of gravitational acceleration.
└ @ Oceananigans.BuoyancyModels ~/builds/tartarus-16/clima/oceananigans/src/BuoyancyModels/buoyancy.jl:48
NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)
├── grid: 1×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo
├── timestepper: QuasiAdamsBashforth2TimeStepper
├── tracers: b
├── closure: Nothing
├── buoyancy: BuoyancyTracer with ĝ = Tuple{Float64, Float64, Float64}
└── coriolis: Nothing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/BuoyancyModels/buoyancy.jl#L8-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BuoyancyModels.BuoyancyTracer" href="#Oceananigans.BuoyancyModels.BuoyancyTracer"><code>Oceananigans.BuoyancyModels.BuoyancyTracer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BuoyancyTracer &lt;: AbstractBuoyancyModel{Nothing}</code></pre><p>Type indicating that the tracer <code>b</code> represents buoyancy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/BuoyancyModels/buoyancy_tracer.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BuoyancyModels.LinearEquationOfState" href="#Oceananigans.BuoyancyModels.LinearEquationOfState"><code>Oceananigans.BuoyancyModels.LinearEquationOfState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinearEquationOfState([FT=Float64;] thermal_expansion=1.67e-4, haline_contraction=7.80e-4)</code></pre><p>Return <code>LinearEquationOfState</code> for <code>SeawaterBuoyancy</code> with <code>thermal_expansion</code> coefficient and <code>haline_contraction</code> coefficient. The buoyancy perturbation <span>$b$</span> for <code>LinearEquationOfState</code> is</p><p class="math-container">\[    b = g (α T - β S),\]</p><p>where <span>$g$</span> is gravitational acceleration, <span>$α$</span> is <code>thermal_expansion</code>, <span>$β$</span> is <code>haline_contraction</code>, <span>$T$</span> is temperature, and <span>$S$</span> is practical salinity units.</p><p>Default constants in units inverse Kelvin and practical salinity units for <code>thermal_expansion</code> and <code>haline_contraction</code>, respectively, are taken from Table 1.2 (page 33) of Vallis, &quot;Atmospheric and Oceanic Fluid Dynamics: Fundamentals and Large-Scale Circulation&quot; (2nd ed, 2017).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/BuoyancyModels/linear_equation_of_state.jl#L17-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BuoyancyModels.LinearEquationOfState" href="#Oceananigans.BuoyancyModels.LinearEquationOfState"><code>Oceananigans.BuoyancyModels.LinearEquationOfState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinearEquationOfState{FT} &lt;: AbstractEquationOfState</code></pre><p>Linear equation of state for seawater.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/BuoyancyModels/linear_equation_of_state.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BuoyancyModels.SeawaterBuoyancy" href="#Oceananigans.BuoyancyModels.SeawaterBuoyancy"><code>Oceananigans.BuoyancyModels.SeawaterBuoyancy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SeawaterBuoyancy([FT = Float64;]
                 gravitational_acceleration = g_Earth,
                 equation_of_state = LinearEquationOfState(FT),
                 constant_temperature = false,
                 constant_salinity = false)</code></pre><p>Returns parameters for a temperature- and salt-stratified seawater buoyancy model with a <code>gravitational_acceleration</code> constant (typically called <span>$g$</span>), and an <code>equation_of_state</code> that related temperature and salinity (or conservative temperature and absolute salinity) to density anomalies and buoyancy.</p><p><code>constant_temperature</code> indicates that buoyancy depends only on salinity. For a nonlinear equation of state, <code>constant_temperature</code> is used as the temperature of the system. The same logic, with the roles of salinity and temperature reversed, holds when <code>constant_salinity</code> is provided.</p><p>For a linear equation of state, the values of <code>constant_temperature</code> or <code>constant_salinity</code> are irrelevant; in this case, <code>constant_temperature=true</code> (and similar for <code>constant_salinity</code>) is valid input.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/BuoyancyModels/seawater_buoyancy.jl#L42-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BuoyancyModels.SeawaterBuoyancy" href="#Oceananigans.BuoyancyModels.SeawaterBuoyancy"><code>Oceananigans.BuoyancyModels.SeawaterBuoyancy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SeawaterBuoyancy{FT, EOS, T, S} &lt;: AbstractBuoyancyModel{EOS}</code></pre><p>BuoyancyModels model for seawater. <code>T</code> and <code>S</code> are either <code>nothing</code> if both temperature and salinity are active, or of type <code>FT</code> if temperature or salinity are constant, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/BuoyancyModels/seawater_buoyancy.jl#L4-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BuoyancyModels.∂x_b-Tuple{Any, Any, Any, Any, SeawaterBuoyancy, Any}" href="#Oceananigans.BuoyancyModels.∂x_b-Tuple{Any, Any, Any, Any, SeawaterBuoyancy, Any}"><code>Oceananigans.BuoyancyModels.∂x_b</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∂x_b(i, j, k, grid, b::SeawaterBuoyancy, C)</code></pre><p>Returns the <span>$x$</span>-derivative of buoyancy for temperature and salt-stratified water,</p><p class="math-container">\[∂_x b = g ( α ∂_x T - β ∂_x S ) ,\]</p><p>where <span>$g$</span> is gravitational acceleration, <span>$α$</span> is the thermal expansion coefficient, <span>$β$</span> is the haline contraction coefficient, <span>$T$</span> is conservative temperature, and <span>$S$</span> is absolute salinity.</p><p>Note: In Oceananigans, <code>model.tracers.T</code> is conservative temperature and <code>model.tracers.S</code> is absolute salinity.</p><p>Note that <span>$∂_x T$</span> (<code>∂x_T</code>), <span>$∂_x S$</span> (<code>∂x_S</code>), <span>$α$</span>, and <span>$β$</span> are all evaluated at cell interfaces in <code>x</code> and cell centers in <code>y</code> and <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/BuoyancyModels/seawater_buoyancy.jl#L100-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BuoyancyModels.∂y_b-Tuple{Any, Any, Any, Any, SeawaterBuoyancy, Any}" href="#Oceananigans.BuoyancyModels.∂y_b-Tuple{Any, Any, Any, Any, SeawaterBuoyancy, Any}"><code>Oceananigans.BuoyancyModels.∂y_b</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∂y_b(i, j, k, grid, b::SeawaterBuoyancy, C)</code></pre><p>Returns the <span>$y$</span>-derivative of buoyancy for temperature and salt-stratified water,</p><p class="math-container">\[∂_y b = g ( α ∂_y T - β ∂_y S ) ,\]</p><p>where <span>$g$</span> is gravitational acceleration, <span>$α$</span> is the thermal expansion coefficient, <span>$β$</span> is the haline contraction coefficient, <span>$T$</span> is conservative temperature, and <span>$S$</span> is absolute salinity.</p><p>Note: In Oceananigans, <code>model.tracers.T</code> is conservative temperature and <code>model.tracers.S</code> is absolute salinity.</p><p>Note that <span>$∂_y T$</span> (<code>∂y_T</code>), <span>$∂_y S$</span> (<code>∂y_S</code>), <span>$α$</span>, and <span>$β$</span> are all evaluated at cell interfaces in <code>y</code> and cell centers in <code>x</code> and <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/BuoyancyModels/seawater_buoyancy.jl#L126-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.BuoyancyModels.∂z_b-Tuple{Any, Any, Any, Any, SeawaterBuoyancy, Any}" href="#Oceananigans.BuoyancyModels.∂z_b-Tuple{Any, Any, Any, Any, SeawaterBuoyancy, Any}"><code>Oceananigans.BuoyancyModels.∂z_b</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∂z_b(i, j, k, grid, b::SeawaterBuoyancy, C)</code></pre><p>Returns the vertical derivative of buoyancy for temperature and salt-stratified water,</p><p class="math-container">\[∂_z b = N^2 = g ( α ∂_z T - β ∂_z S ) ,\]</p><p>where <span>$g$</span> is gravitational acceleration, <span>$α$</span> is the thermal expansion coefficient, <span>$β$</span> is the haline contraction coefficient, <span>$T$</span> is conservative temperature, and <span>$S$</span> is absolute salinity.</p><p>Note: In Oceananigans, <code>model.tracers.T</code> is conservative temperature and <code>model.tracers.S</code> is absolute salinity.</p><p>Note that <span>$∂_z T$</span> (<code>∂z_T</code>), <span>$∂_z S$</span> (<code>∂z_S</code>), <span>$α$</span>, and <span>$β$</span> are all evaluated at cell interfaces in <code>z</code> and cell centers in <code>x</code> and <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/BuoyancyModels/seawater_buoyancy.jl#L152-L170">source</a></section></article><h2 id="Coriolis"><a class="docs-heading-anchor" href="#Coriolis">Coriolis</a><a id="Coriolis-1"></a><a class="docs-heading-anchor-permalink" href="#Coriolis" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.ActiveCellEnstrophyConservingScheme" href="#Oceananigans.Coriolis.ActiveCellEnstrophyConservingScheme"><code>Oceananigans.Coriolis.ActiveCellEnstrophyConservingScheme</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ActiveCellEnstrophyConservingScheme</code></pre><p>A parameter object for an enstrophy-conserving Coriolis scheme that excludes inactive (dry/land) edges (indices for which <code>peripheral_node == true</code>) from the velocity interpolation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Coriolis/hydrostatic_spherical_coriolis.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.BetaPlane" href="#Oceananigans.Coriolis.BetaPlane"><code>Oceananigans.Coriolis.BetaPlane</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BetaPlane([T=Float64;] f₀=nothing, β=nothing,
                       rotation_rate=Ω_Earth, latitude=nothing, radius=R_Earth)</code></pre><p>Return a <span>$β$</span>-plane Coriolis parameter, <span>$f = f₀ + β y$</span>. </p><p>The user may specify both <code>f₀</code> and <code>β</code>, or the three parameters <code>rotation_rate</code>, <code>latitude</code> (in degrees), and <code>radius</code> that specify the rotation rate and radius of a planet, and the central latitude (where <span>$y = 0$</span>) at which the <code>β</code>-plane approximation is to be made.</p><p>If <code>f₀</code> and <code>β</code> are not specified, they are calculated from <code>rotation_rate</code>, <code>latitude</code>, and <code>radius</code> according to the relations <code>f₀ = 2 * rotation_rate * sind(latitude)</code> and <code>β = 2 * rotation_rate * cosd(latitude) / radius</code>.</p><p>By default, the <code>rotation_rate</code> and planet <code>radius</code> are assumed to be Earth&#39;s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Coriolis/beta_plane.jl#L13-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.BetaPlane" href="#Oceananigans.Coriolis.BetaPlane"><code>Oceananigans.Coriolis.BetaPlane</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct BetaPlane{T} &lt;: AbstractRotation</code></pre><p>A parameter object for meridionally increasing Coriolis parameter (<code>f = f₀ + β y</code>) that accounts for the variation of the locally vertical component of the rotation vector with latitude.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Coriolis/beta_plane.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.ConstantCartesianCoriolis" href="#Oceananigans.Coriolis.ConstantCartesianCoriolis"><code>Oceananigans.Coriolis.ConstantCartesianCoriolis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConstantCartesianCoriolis([FT=Float64;] fx=nothing, fy=nothing, fz=nothing,
                                        f=nothing, rotation_axis=ZDirection(), 
                                        rotation_rate=Ω_Earth, latitude=nothing)</code></pre><p>Return a parameter object for a constant rotation decomposed into the <code>x</code>, <code>y</code>, and <code>z</code> directions. In oceanography the components <code>x</code>, <code>y</code>, <code>z</code> correspond to the directions east, north, and up. This constant rotation can be specified in three different ways:</p><ul><li>Specifying all components <code>fx</code>, <code>fy</code> and <code>fz</code> directly.</li><li>Specifying the Coriolis parameter <code>f</code> and (optionally) a <code>rotation_axis</code> (which defaults to the <code>z</code> direction if not specified).</li><li>Specifying <code>latitude</code> (in degrees) and (optionally) a <code>rotation_rate</code> in radians per second (which defaults to Earth&#39;s rotation rate).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Coriolis/constant_cartesian_coriolis.jl#L16-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.ConstantCartesianCoriolis" href="#Oceananigans.Coriolis.ConstantCartesianCoriolis"><code>Oceananigans.Coriolis.ConstantCartesianCoriolis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ConstantCartesianCoriolis{FT} &lt;: AbstractRotation</code></pre><p>A Coriolis implementation that accounts for the locally vertical and possibly both local horizontal components of a constant rotation vector. This is a more general implementation of <a href="#Oceananigans.Coriolis.FPlane"><code>FPlane</code></a>, which only accounts for the locally vertical component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Coriolis/constant_cartesian_coriolis.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.FPlane" href="#Oceananigans.Coriolis.FPlane"><code>Oceananigans.Coriolis.FPlane</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FPlane([FT=Float64;] f=nothing, rotation_rate=Ω_Earth, latitude=nothing)</code></pre><p>Return a parameter object for constant rotation at the angular frequency <code>f/2</code>, and therefore with background vorticity <code>f</code>, around a vertical axis. If <code>f</code> is not specified, it is calculated from <code>rotation_rate</code> and <code>latitude</code> (in degrees) according to the relation <code>f = 2 * rotation_rate * sind(latitude)</code>.</p><p>By default, <code>rotation_rate</code> is assumed to be Earth&#39;s.</p><p>Also called <code>FPlane</code>, after the &quot;f-plane&quot; approximation for the local effect of a planet&#39;s rotation in a planar coordinate system tangent to the planet&#39;s surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Coriolis/f_plane.jl#L12-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.FPlane" href="#Oceananigans.Coriolis.FPlane"><code>Oceananigans.Coriolis.FPlane</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FPlane{FT} &lt;: AbstractRotation</code></pre><p>A parameter object for constant rotation around a vertical axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Coriolis/f_plane.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.HydrostaticSphericalCoriolis" href="#Oceananigans.Coriolis.HydrostaticSphericalCoriolis"><code>Oceananigans.Coriolis.HydrostaticSphericalCoriolis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct HydrostaticSphericalCoriolis{S, FT} &lt;: AbstractRotation</code></pre><p>A parameter object for constant rotation around a vertical axis on the sphere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Coriolis/hydrostatic_spherical_coriolis.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.HydrostaticSphericalCoriolis-Union{Tuple{}, Tuple{DataType}, Tuple{S}} where S" href="#Oceananigans.Coriolis.HydrostaticSphericalCoriolis-Union{Tuple{}, Tuple{DataType}, Tuple{S}} where S"><code>Oceananigans.Coriolis.HydrostaticSphericalCoriolis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HydrostaticSphericalCoriolis([FT=Float64;]
                             rotation_rate = Ω_Earth,
                             scheme = EnergyConservingScheme())</code></pre><p>Return a parameter object for Coriolis forces on a sphere rotating at <code>rotation_rate</code>. By default, <code>rotation_rate</code> is assumed to be Earth&#39;s.</p><p><strong>Keyword arguments</strong></p><ul><li><code>scheme</code>: Either <code>EnergyConservingScheme()</code> (default), <code>EnstrophyConservingScheme()</code>, or <code>ActiveCellEnstrophyConservingScheme()</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Coriolis/hydrostatic_spherical_coriolis.jl#L27-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.NonTraditionalBetaPlane" href="#Oceananigans.Coriolis.NonTraditionalBetaPlane"><code>Oceananigans.Coriolis.NonTraditionalBetaPlane</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NonTraditionalBetaPlane(FT=Float64;
                        fz=nothing, fy=nothing, β=nothing, γ=nothing,
                        rotation_rate=Ω_Earth, latitude=nothing, radius=R_Earth)</code></pre><p>The user may directly specify <code>fz</code>, <code>fy</code>, <code>β</code>, <code>γ</code>, and <code>radius</code> or the three parameters <code>rotation_rate</code>, <code>latitude</code> (in degrees), and <code>radius</code> that specify the rotation rate and radius of a planet, and the central latitude (where <span>$y = 0$</span>) at which the non-traditional <code>β</code>-plane approximation is to be made.</p><p>If <code>fz</code>, <code>fy</code>, <code>β</code>, and <code>γ</code> are not specified, they are calculated from <code>rotation_rate</code>,  <code>latitude</code>, and <code>radius</code> according to the relations <code>fz = 2 * rotation_rate * sind(latitude)</code>, <code>fy = 2 * rotation_rate * cosd(latitude)</code>, <code>β = 2 * rotation_rate * cosd(latitude) / radius</code>, and <code>γ = - 4 * rotation_rate * sind(latitude) / radius</code>.</p><p>By default, the <code>rotation_rate</code> and planet <code>radius</code> is assumed to be Earth&#39;s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Coriolis/non_traditional_beta_plane.jl#L28-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Coriolis.NonTraditionalBetaPlane" href="#Oceananigans.Coriolis.NonTraditionalBetaPlane"><code>Oceananigans.Coriolis.NonTraditionalBetaPlane</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NonTraditionalBetaPlane{FT} &lt;: AbstractRotation</code></pre><p>A Coriolis implementation that accounts for the latitudinal variation of both the locally vertical and the locally horizontal components of the rotation vector. The &quot;traditional&quot; approximation in ocean models accounts for only the locally vertical component of the rotation vector (see <a href="#Oceananigans.Coriolis.BetaPlane"><code>BetaPlane</code></a>).</p><p>This implementation is based off of section 5 of Dellar (2011). It conserve energy, angular momentum, and potential vorticity.</p><p><strong>References</strong></p><p>Dellar, P. (2011). Variations on a beta-plane: Derivation of non-traditional     beta-plane equations from Hamilton&#39;s principle on a sphere. Journal of     Fluid Mechanics, 674, 174-195. doi:10.1017/S0022112010006464</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Coriolis/non_traditional_beta_plane.jl#L3-L19">source</a></section></article><h2 id="Diagnostics"><a class="docs-heading-anchor" href="#Diagnostics">Diagnostics</a><a id="Diagnostics-1"></a><a class="docs-heading-anchor-permalink" href="#Diagnostics" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.CFL" href="#Oceananigans.Diagnostics.CFL"><code>Oceananigans.Diagnostics.CFL</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CFL{D, S}</code></pre><p>An object for computing the Courant-Freidrichs-Lewy (CFL) number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Diagnostics/cfl.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.CFL-Tuple{Any}" href="#Oceananigans.Diagnostics.CFL-Tuple{Any}"><code>Oceananigans.Diagnostics.CFL</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CFL(Δt [, timescale = Oceananigans.Advection.cell_advection_timescale])</code></pre><p>Return an object for computing the Courant-Freidrichs-Lewy (CFL) number associated with time step <code>Δt</code> or <code>TimeStepWizard</code> and <code>timescale</code>.</p><p>See also <a href="#Oceananigans.Diagnostics.AdvectiveCFL-Tuple{Any}"><code>AdvectiveCFL</code></a> and <a href="appendix/Oceananigans.Diagnostics.DiffusiveCFL"><code>DiffusiveCFL</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Diagnostics/cfl.jl#L14-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.StateChecker-Tuple{Any}" href="#Oceananigans.Diagnostics.StateChecker-Tuple{Any}"><code>Oceananigans.Diagnostics.StateChecker</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">StateChecker(; schedule, fields)</code></pre><p>Returns a <code>StateChecker</code> that logs field information (minimum, maximum, mean) for each field in a named tuple of <code>fields</code> when <code>schedule</code> actuates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Diagnostics/state_checker.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.AdvectiveCFL-Tuple{Any}" href="#Oceananigans.Diagnostics.AdvectiveCFL-Tuple{Any}"><code>Oceananigans.Diagnostics.AdvectiveCFL</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AdvectiveCFL(Δt)</code></pre><p>Return an object for computing the Courant-Freidrichs-Lewy (CFL) number associated with time step <code>Δt</code> or <code>TimeStepWizard</code> and the time scale for advection across a cell. The advective CFL is, e.g., <span>$U Δt / Δx$</span>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; model = NonhydrostaticModel(grid = RectilinearGrid(size=(16, 16, 16), extent=(8, 8, 8)));

julia&gt; Δt = 1.0;

julia&gt; cfl = AdvectiveCFL(Δt);

julia&gt; model.velocities.u .= π;

julia&gt; cfl(model)
6.283185307179586</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Diagnostics/cfl.jl#L27-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Diagnostics.DiffusiveCFL-Tuple{Any}" href="#Oceananigans.Diagnostics.DiffusiveCFL-Tuple{Any}"><code>Oceananigans.Diagnostics.DiffusiveCFL</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DiffusiveCFL(Δt)</code></pre><p>Returns an object for computing the diffusive Courant-Freidrichs-Lewy (CFL) number associated with time step <code>Δt</code> or <code>TimeStepWizard</code> and the time scale for diffusion across a cell associated with <code>model.closure</code>.  The diffusive CFL, e.g., for viscosity is <span>$ν Δt / Δx²$</span>.</p><p>The maximum diffusive CFL number among viscosity and all tracer diffusivities is returned.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; model = NonhydrostaticModel(grid = RectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1)),
                                   closure = ScalarDiffusivity(; ν = 1e-2));

julia&gt; Δt = 0.1;

julia&gt; dcfl = DiffusiveCFL(Δt);

julia&gt; dcfl(model)
0.256</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Diagnostics/cfl.jl#L53-L79">source</a></section></article><h2 id="Distributed"><a class="docs-heading-anchor" href="#Distributed">Distributed</a><a id="Distributed-1"></a><a class="docs-heading-anchor-permalink" href="#Distributed" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Distributed.DistributedArch" href="#Oceananigans.Distributed.DistributedArch"><code>Oceananigans.Distributed.DistributedArch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DistributedArch(child_architecture = CPU(); 
                topology = (Periodic, Periodic, Periodic), 
                ranks, 
                use_buffers = false,
                devices = nothing, 
                communicator = MPI.COMM_WORLD)</code></pre><p>Constructor for a distributed architecture that uses MPI for communications</p><p><strong>Positional arguments</strong></p><ul><li><code>child_architecture</code>: Specifies whether the computation is performed on CPUs or GPUs.                        Default: <code>child_architecture = CPU()</code>.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>topology</code>: the topology we want the grid to have. It is used to establish connectivity.             Default: <code>topology = (Periodic, Periodic, Periodic)</code>.</p></li><li><p><code>ranks</code> (required): A 3-tuple <code>(Rx, Ry, Rz)</code> specifying the total processors in the <code>x</code>,                      <code>y</code> and <code>z</code> direction. NOTE: support for distributed z direction is                      limited, so <code>Rz = 1</code> is strongly suggested.</p></li><li><p><code>use_buffers</code>: if <code>true</code>, buffered halo communication is implemented. If <code>false</code>, halos will be                 exchanged through views. Buffered communication is not necessary in case of <code>CPU</code>                execution, but it is necessary for <code>GPU</code> execution without CUDA-aware MPI</p></li><li><p><code>devices</code>: <code>GPU</code> device linked to local rank. The GPU will be assigned based on the             local node rank as such <code>devices[node_rank]</code>. Make sure to run <code>--ntasks-per-node</code> &lt;= <code>--gres=gpu</code>.            If <code>nothing</code>, the devices will be assigned automatically based on the available resources</p></li><li><p><code>communicator</code>: the MPI communicator, <code>MPI.COMM_WORLD</code>. This keyword argument should not be tampered with                  if not for testing or developing. Change at your own risk!</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Distributed/multi_architectures.jl#L23-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Distributed.DistributedFFTBasedPoissonSolver-Tuple{Any, Any}" href="#Oceananigans.Distributed.DistributedFFTBasedPoissonSolver-Tuple{Any, Any}"><code>Oceananigans.Distributed.DistributedFFTBasedPoissonSolver</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DistributedFFTBasedPoissonSolver(global_grid, local_grid)</code></pre><p>Return a FFT-based solver for the Poisson equation,</p><p class="math-container">\[∇²φ = b\]</p><p>for <code>DistributedArch</code>itectures.</p><p><strong>Supported configurations</strong></p><p>We support two &quot;modes&quot;:</p><ol><li><p>Vertical pencil decompositions: two-dimensional decompositions in <span>$(x, y)$</span> for three dimensional problems that satisfy either <code>Nz &gt; Rx</code> or <code>Nz &gt; Ry</code>.</p></li><li><p>One-dimensional decompositions in either <span>$x$</span> or <span>$y$</span>.</p></li></ol><p>Above, <code>Nz = size(global_grid, 3)</code> and <code>Rx, Ry, Rz = architecture(local_grid).ranks</code>.</p><p>Other configurations that are decomposed in <span>$(x, y)$</span> but have too few <code>Nz</code>, or any configuration decomposed in <span>$z$</span>, are <em>not</em> supported.</p><p><strong>Algorithm for two-dimensional decompositions</strong></p><p>For two-dimensional decompositions (useful for three-dimensional problems), there are three forward transforms, three backward transforms, and four transpositions requiring MPI communication. In the schematic below, the first dimension is always the local dimension. In our implementation of the PencilFFTs algorithm, we require <em>either</em> <code>Nz &gt;= Rx</code>, <em>or</em> <code>Nz &gt;= Ry</code>, where <code>Nz</code> is the number of vertical cells, <code>Rx</code> is the number of ranks in <span>$x$</span>, and <code>Ry</code> is the number of ranks in <span>$y$</span>. Below, we outline the algorithm for the case <code>Nz &gt;= Rx</code>. If <code>Nz &lt; Rx</code>, but <code>Nz &gt; Ry</code>, a similar algorithm applies with <span>$x$</span> and <span>$y$</span> swapped:</p><ol><li><code>first(storage)</code> is initialized with layout <span>$(z, x, y)$</span>.</li><li>Transform along <span>$z$</span>.</li></ol><p>3  Transpose + communicate to <code>storage[2]</code> in layout <span>$(x, z, y)$</span>,    which is distributed into <code>(Rx, Ry)</code> processes in <span>$(z, y)$</span>.</p><ol><li>Transform along <span>$x$</span>.</li><li>Transpose + communicate to <code>last(storage)</code> in layout <span>$(y, x, z)$</span>, which is distributed into <code>(Rx, Ry)</code> processes in <span>$(x, z)$</span>.</li><li>Transform in <span>$y$</span>.</li></ol><p>At this point the three in-place forward transforms are complete, and we solve the Poisson equation by updating <code>last(storage)</code>. Then the process is reversed to obtain <code>first(storage)</code> in physical space and with the layout <span>$(z, x, y)$</span>.</p><p><strong>Restrictions</strong></p><p>The algorithm for two-dimensional decompositions requires that <code>Nz = size(global_grid, 3)</code> is larger than either <code>Rx = ranks[1]</code> or <code>Ry = ranks[2]</code>, where <code>ranks</code> are configured when building <code>DistributedArch</code>. If <code>Nz</code> does not satisfy this condition, we can only support a one-dimensional decomposition.</p><p><strong>Algorithm for one-dimensional decompositions</strong></p><p>This algorithm requires a one-dimensional decomposition with <em>either</em> <code>Rx = 1</code> <em>or</em> <code>Ry = 1</code>, and is important to support two-dimensional transforms.</p><p>For one-dimensional decompositions, we place the decomposed direction <em>last</em>. If the number of ranks is <code>Rh = max(Rx, Ry)</code>, this algorithm requires that  <em>both</em> <code>Nx &gt; Rh</code> <em>and</em> <code>Ny &gt; Rh</code>. The resulting flow of transposes and transforms is similar to the two-dimensional case. It remains somewhat of a mystery why this succeeds (i.e., why the last transform is correctly decomposed).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Distributed/distributed_fft_based_poisson_solver.jl#L27-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Distributed.reconstruct_global_grid-Tuple{RectilinearGrid{FT, TX, TY, TZ, FX, FY, FZ, VX, VY, VZ, &lt;:Oceananigans.Distributed.DistributedArch} where {FT, TX, TY, TZ, FX, FY, FZ, VX, VY, VZ}}" href="#Oceananigans.Distributed.reconstruct_global_grid-Tuple{RectilinearGrid{FT, TX, TY, TZ, FX, FY, FZ, VX, VY, VZ, &lt;:Oceananigans.Distributed.DistributedArch} where {FT, TX, TY, TZ, FX, FY, FZ, VX, VY, VZ}}"><code>Oceananigans.Distributed.reconstruct_global_grid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reconstruct_global_grid(grid::DistributedGrid)</code></pre><p>Return the global grid on <code>child_architecture(grid)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Distributed/distributed_grids.jl#L153-L157">source</a></section></article><h2 id="Fields"><a class="docs-heading-anchor" href="#Fields">Fields</a><a id="Fields-1"></a><a class="docs-heading-anchor-permalink" href="#Fields" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.AbstractField" href="#Oceananigans.Fields.AbstractField"><code>Oceananigans.Fields.AbstractField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractField{LX, LY, LZ, G, T, N}</code></pre><p>Abstract supertype for fields located at <code>(LX, LY, LZ)</code> and defined on a grid <code>G</code> with eltype <code>T</code> and <code>N</code> dimensions.</p><p>Note: we need the parameter <code>T</code> to subtype AbstractArray.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Fields/abstract_field.jl#L21-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.BackgroundField" href="#Oceananigans.Fields.BackgroundField"><code>Oceananigans.Fields.BackgroundField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BackgroundField{F, P}</code></pre><p>Temporary container for storing information about <code>BackgroundFields</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Fields/background_fields.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.BackgroundField-Tuple{Any}" href="#Oceananigans.Fields.BackgroundField-Tuple{Any}"><code>Oceananigans.Fields.BackgroundField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BackgroundField(func; parameters=nothing)</code></pre><p>Returns a <code>BackgroundField</code> to be passed to <code>NonhydrostaticModel</code> for use as a background velocity or tracer field.</p><p>If <code>parameters</code> is not provided, <code>func</code> must be callable with the signature</p><pre><code class="language-julia hljs">func(x, y, z, t)</code></pre><p>If <code>parameters</code> is provided, <code>func</code> must be callable with the signature</p><pre><code class="language-julia hljs">func(x, y, z, t, parameters)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Fields/background_fields.jl#L43-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.Field-Union{Tuple{Oceananigans.Grids.AbstractGrid}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Oceananigans.Grids.AbstractGrid, DataType}} where {LX, LY, LZ}" href="#Oceananigans.Fields.Field-Union{Tuple{Oceananigans.Grids.AbstractGrid}, Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Oceananigans.Grids.AbstractGrid, DataType}} where {LX, LY, LZ}"><code>Oceananigans.Fields.Field</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Field{LX, LY, LZ}(grid::AbstractGrid,
                  T::DataType=eltype(grid); kw...) where {LX, LY, LZ}</code></pre><p>Construct a <code>Field</code> on <code>grid</code> with data type <code>T</code> at the location <code>(LX, LY, LZ)</code>. Each of <code>(LX, LY, LZ)</code> is either <code>Center</code> or <code>Face</code> and determines the field&#39;s location in <code>(x, y, z)</code> respectively.</p><p><strong>Keyword arguments</strong></p><ul><li><code>data :: OffsetArray</code>: An offset array with the fields data. If nothing is provided the field is filled with zeros.<ul><li><code>boundary_conditions</code>: If nothing is provided, then field is created using the default</li></ul>boundary conditions via <a href="#Oceananigans.BoundaryConditions.FieldBoundaryConditions"><code>FieldBoundaryConditions</code></a>.</li><li><code>indices</code>: Used to prescribe where a reduced field lives on. For example, at which <code>k</code> index does a two-dimensional <span>$x$</span>-<span>$y$</span> field lives on. Default: <code>(:, :, :)</code>.</li></ul><p><strong>Example</strong></p><p>A field at location <code>(Face, Face, Center)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = RectilinearGrid(size=(2, 3, 4), extent=(1, 1, 1));

julia&gt; ω = Field{Face, Face, Center}(grid)
2×3×4 Field{Face, Face, Center} on RectilinearGrid on CPU
├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo
├── boundary conditions: FieldBoundaryConditions
│   └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux
└── data: 8×9×10 OffsetArray(::Array{Float64, 3}, -2:5, -2:6, -2:7) with eltype Float64 with indices -2:5×-2:6×-2:7
    └── max=0.0, min=0.0, mean=0.0</code></pre><p>Now, using <code>indices</code> we can create a two dimensional <span>$x$</span>-<span>$y$</span> field at location <code>(Face, Face, Center)</code> to compute, e.g., the vertical vorticity <span>$∂v/∂x - ∂u/∂y$</span> at the fluid&#39;s surface <span>$z = 0$</span>, which for <code>Center</code> corresponds to <code>k = Nz</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; u = XFaceField(grid); v = YFaceField(grid);

julia&gt; ωₛ = Field(∂x(v) - ∂y(u), indices=(:, :, grid.Nz))
2×3×1 Field{Face, Face, Center} on RectilinearGrid on CPU
├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo
├── boundary conditions: FieldBoundaryConditions
│   └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux
├── operand: BinaryOperation at (Face, Face, Center)
├── status: time=0.0
└── data: 8×9×1 OffsetArray(::Array{Float64, 3}, -2:5, -2:6, 4:4) with eltype Float64 with indices -2:5×-2:6×4:4
    └── max=0.0, min=0.0, mean=0.0

julia&gt; compute!(ωₛ)
2×3×1 Field{Face, Face, Center} on RectilinearGrid on CPU
├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo
├── boundary conditions: FieldBoundaryConditions
│   └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux
├── operand: BinaryOperation at (Face, Face, Center)
├── status: time=0.0
└── data: 8×9×1 OffsetArray(::Array{Float64, 3}, -2:5, -2:6, 4:4) with eltype Float64 with indices -2:5×-2:6×4:4
    └── max=0.0, min=0.0, mean=0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Fields/field.jl#L94-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.Reduction-Tuple{Any, Any}" href="#Oceananigans.Fields.Reduction-Tuple{Any, Any}"><code>Oceananigans.Fields.Reduction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Reduction(reduce!, operand; dims)</code></pre><p>Return a <code>Reduction</code> of <code>operand</code> with <code>reduce!</code>, along <code>dims</code>. Note that <code>Reduction</code> expects <code>reduce!</code> to operate in-place.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Oceananigans

Nx, Ny, Nz = 3, 3, 3

grid = RectilinearGrid(size=(Nx, Ny, Nz), x=(0, 1), y=(0, 1), z=(0, 1),
                       topology=(Periodic, Periodic, Periodic))

c = CenterField(grid)

set!(c, (x, y, z) -&gt; x + y + z)

max_c² = Field(Reduction(maximum!, c^2, dims=3))

compute!(max_c²)

max_c²[1:Nx, 1:Ny]

# output
3×3 Matrix{Float64}:
 1.36111  2.25     3.36111
 2.25     3.36111  4.69444
 3.36111  4.69444  6.25</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Fields/field_reductions.jl#L11-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.CenterField" href="#Oceananigans.Fields.CenterField"><code>Oceananigans.Fields.CenterField</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">CenterField(grid; kw...)</code></pre><p>Return a <code>Field{Center, Center, Center}</code> on <code>grid</code>. Additional keyword arguments are passed to the <code>Field</code> constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Fields/field.jl#L181-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.PressureFields" href="#Oceananigans.Fields.PressureFields"><code>Oceananigans.Fields.PressureFields</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">PressureFields(grid, bcs::NamedTuple)</code></pre><p>Return a <code>NamedTuple</code> with pressure fields <code>pHY′</code> and <code>pNHS</code> initialized as <code>CenterField</code>s on <code>grid</code>.  Boundary conditions <code>bcs</code> may be specified via a named tuple of <code>FieldBoundaryCondition</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Fields/field_tuples.jl#L199-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.PressureFields-Tuple{NamedTuple{(:pHY′, :pNHS)}, Any, Any}" href="#Oceananigans.Fields.PressureFields-Tuple{NamedTuple{(:pHY′, :pNHS)}, Any, Any}"><code>Oceananigans.Fields.PressureFields</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PressureFields(proposed_pressures::NamedTuple{(:pHY′, :pNHS)}, grid, bcs)</code></pre><p>Return a <code>NamedTuple</code> of pressure fields with, overwriting boundary conditions in <code>proposed_tracer_fields</code> with corresponding fields in the <code>NamedTuple</code> <code>bcs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Fields/field_tuples.jl#L295-L300">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.TendencyFields-Tuple{Any, Any}" href="#Oceananigans.Fields.TendencyFields-Tuple{Any, Any}"><code>Oceananigans.Fields.TendencyFields</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TendencyFields(grid, tracer_names;
               u = XFaceField(grid),
               v = YFaceField(grid),
               w = ZFaceField(grid),
               kwargs...)</code></pre><p>Return a <code>NamedTuple</code> with tendencies for all solution fields (velocity fields and tracer fields), initialized on <code>grid</code>. Optional <code>kwargs</code> can be specified to assign data arrays to each tendency field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Fields/field_tuples.jl#L231-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.TracerFields-Tuple{Any, Any, Any}" href="#Oceananigans.Fields.TracerFields-Tuple{Any, Any, Any}"><code>Oceananigans.Fields.TracerFields</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TracerFields(tracer_names, grid, user_bcs)</code></pre><p>Return a <code>NamedTuple</code> with tracer fields specified by <code>tracer_names</code> initialized as <code>CenterField</code>s on <code>grid</code>. Boundary conditions <code>user_bcs</code> may be specified via a named tuple of <code>FieldBoundaryCondition</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Fields/field_tuples.jl#L163-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.TracerFields-Tuple{Any, Any}" href="#Oceananigans.Fields.TracerFields-Tuple{Any, Any}"><code>Oceananigans.Fields.TracerFields</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TracerFields(tracer_names, grid; kwargs...)</code></pre><p>Return a <code>NamedTuple</code> with tracer fields specified by <code>tracer_names</code> initialized as <code>CenterField</code>s on <code>grid</code>. Fields may be passed via optional keyword arguments <code>kwargs</code> for each field.</p><p>This function is used by <code>OutputWriters.Checkpointer</code> and <code>TendencyFields</code>. ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Fields/field_tuples.jl#L176-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.TracerFields-Tuple{NamedTuple, Any, Any}" href="#Oceananigans.Fields.TracerFields-Tuple{NamedTuple, Any, Any}"><code>Oceananigans.Fields.TracerFields</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TracerFields(proposed_tracers::NamedTuple, grid, bcs)</code></pre><p>Return a <code>NamedTuple</code> of tracers, overwriting boundary conditions in <code>proposed_tracers</code> with corresponding fields in the <code>NamedTuple</code> <code>bcs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Fields/field_tuples.jl#L279-L284">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.TracerFields-Tuple{NamedTuple{(), Tuple{}}, Any, Any}" href="#Oceananigans.Fields.TracerFields-Tuple{NamedTuple{(), Tuple{}}, Any, Any}"><code>Oceananigans.Fields.TracerFields</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Shortcut constructor for empty tracer fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Fields/field_tuples.jl#L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.VelocityFields" href="#Oceananigans.Fields.VelocityFields"><code>Oceananigans.Fields.VelocityFields</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">VelocityFields(grid, user_bcs = NamedTuple())</code></pre><p>Return a <code>NamedTuple</code> with fields <code>u</code>, <code>v</code>, <code>w</code> initialized on <code>grid</code>. Boundary conditions <code>bcs</code> may be specified via a named tuple of <code>FieldBoundaryCondition</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Fields/field_tuples.jl#L133-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.VelocityFields-Tuple{NamedTuple{(:u, :v, :w)}, Any, Any}" href="#Oceananigans.Fields.VelocityFields-Tuple{NamedTuple{(:u, :v, :w)}, Any, Any}"><code>Oceananigans.Fields.VelocityFields</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">VelocityFields(proposed_velocities::NamedTuple{(:u, :v, :w)}, grid, bcs)</code></pre><p>Return a <code>NamedTuple</code> of velocity fields, overwriting boundary conditions in <code>proposed_velocities</code> with corresponding fields in the <code>NamedTuple</code> <code>bcs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Fields/field_tuples.jl#L262-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.XFaceField" href="#Oceananigans.Fields.XFaceField"><code>Oceananigans.Fields.XFaceField</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">XFaceField(grid; kw...)</code></pre><p>Return a <code>Field{Face, Center, Center}</code> on <code>grid</code>. Additional keyword arguments are passed to the <code>Field</code> constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Fields/field.jl#L189-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.YFaceField" href="#Oceananigans.Fields.YFaceField"><code>Oceananigans.Fields.YFaceField</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">YFaceField(grid; kw...)</code></pre><p>Return a <code>Field{Center, Face, Center}</code> on <code>grid</code>. Additional keyword arguments are passed to the <code>Field</code> constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Fields/field.jl#L197-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.ZFaceField" href="#Oceananigans.Fields.ZFaceField"><code>Oceananigans.Fields.ZFaceField</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ZFaceField(grid; kw...)</code></pre><p>Return a <code>Field{Center, Center, Face}</code> on <code>grid</code>. Additional keyword arguments are passed to the <code>Field</code> constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Fields/field.jl#L205-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.compute!" href="#Oceananigans.Fields.compute!"><code>Oceananigans.Fields.compute!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute!(field)</code></pre><p>Computes <code>field.data</code> from <code>field.operand</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Fields/field.jl#L417-L421">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.field-Tuple{Any, AbstractArray, Any}" href="#Oceananigans.Fields.field-Tuple{Any, AbstractArray, Any}"><code>Oceananigans.Fields.field</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">field(loc, a, grid)</code></pre><p>Build a field from <code>a</code> at <code>loc</code> and on <code>grid</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Fields/Fields.jl#L29-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.interior-Tuple{Field}" href="#Oceananigans.Fields.interior-Tuple{Field}"><code>Oceananigans.Fields.interior</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">interior(f::Field)</code></pre><p>Returns a view of <code>f</code> that excludes halo points.&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Fields/field.jl#L376-L380">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.interpolate-NTuple{4, Any}" href="#Oceananigans.Fields.interpolate-NTuple{4, Any}"><code>Oceananigans.Fields.interpolate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">interpolate(field, x, y, z)</code></pre><p>Interpolate <code>field</code> to the physical point <code>(x, y, z)</code> using trilinear interpolation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Fields/interpolate.jl#L158-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.regrid!-Tuple{Any, Any}" href="#Oceananigans.Fields.regrid!-Tuple{Any, Any}"><code>Oceananigans.Fields.regrid!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">regrid!(a, b)</code></pre><p>Regrid field <code>b</code> onto the grid of field <code>a</code>. </p><p><strong>Example</strong></p><p>Generate a tracer field on a vertically stretched grid and regrid it on a regular grid.</p><pre><code class="language-julia hljs">using Oceananigans

Nz, Lz = 2, 1.0
topology = (Flat, Flat, Bounded)

input_grid = RectilinearGrid(size=Nz, z = [0, Lz/3, Lz], topology=topology, halo=1)
input_field = CenterField(input_grid)
input_field[1, 1, 1:Nz] = [2, 3]

output_grid = RectilinearGrid(size=Nz, z=(0, Lz), topology=topology, halo=1)
output_field = CenterField(output_grid)

regrid!(output_field, input_field)

output_field[1, 1, :]

# output
4-element OffsetArray(::Vector{Float64}, 0:3) with eltype Float64 with indices 0:3:
 0.0
 2.333333333333333
 3.0
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Fields/regridding_fields.jl#L13-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.location-Tuple{Any}" href="#Oceananigans.location-Tuple{Any}"><code>Oceananigans.location</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns the location <code>(LX, LY, LZ)</code> of an <code>AbstractField{LX, LY, LZ}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Fields/abstract_field.jl#L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Fields.@compute-Tuple{Any}" href="#Oceananigans.Fields.@compute-Tuple{Any}"><code>Oceananigans.Fields.@compute</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@compute(exprs...)</code></pre><p>Call <code>compute!</code> on fields after defining them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Fields/field.jl#L424-L428">source</a></section></article><h2 id="Forcings"><a class="docs-heading-anchor" href="#Forcings">Forcings</a><a id="Forcings-1"></a><a class="docs-heading-anchor-permalink" href="#Forcings" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.AdvectiveForcing" href="#Oceananigans.Forcings.AdvectiveForcing"><code>Oceananigans.Forcings.AdvectiveForcing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AdvectiveForcing(scheme=UpwindBiasedFifthOrder(), u=ZeroField(), v=ZeroField(), w=ZeroField())</code></pre><p>Build a forcing term representing advection by the velocity field <code>u, v, w</code> with an advection <code>scheme</code>.</p><p><strong>Example</strong></p><p><strong>Using a tracer field to model sinking particles</strong></p><pre><code class="language-julia hljs">using Oceananigans

# Physical parameters
gravitational_acceleration          = 9.81     # m s⁻²
ocean_density                       = 1026     # kg m⁻³
mean_particle_density               = 2000     # kg m⁻³
mean_particle_radius                = 1e-3     # m
ocean_molecular_kinematic_viscosity = 1.05e-6  # m² s⁻¹

# Terminal velocity of a sphere in viscous flow
Δb = gravitational_acceleration * (mean_particle_density - ocean_density) / ocean_density
ν = ocean_molecular_kinematic_viscosity
R = mean_particle_radius

w_Stokes = - 2/9 * Δb / ν * R^2 # m s⁻¹

settling = AdvectiveForcing(UpwindBiasedFifthOrder(), w=w_Stokes)

# output
AdvectiveForcing with the UpwindBiased scheme:
├── u: ZeroField{Int64}
├── v: ZeroField{Int64}
└── w: ConstantField(-1.97096)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Forcings/advective_forcing.jl#L15-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.ContinuousForcing" href="#Oceananigans.Forcings.ContinuousForcing"><code>Oceananigans.Forcings.ContinuousForcing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ContinuousForcing{LX, LY, LZ, P, F, D, I, ℑ}</code></pre><p>A callable object that implements a &quot;continuous form&quot; forcing function on a field at the location <code>LX, LY, LZ</code> with optional parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Forcings/continuous_forcing.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.ContinuousForcing-Tuple{Any}" href="#Oceananigans.Forcings.ContinuousForcing-Tuple{Any}"><code>Oceananigans.Forcings.ContinuousForcing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ContinuousForcing(func; parameters=nothing, field_dependencies=())</code></pre><p>Construct a &quot;continuous form&quot; forcing with optional <code>parameters</code> and optional <code>field_dependencies</code> on other fields in a model.</p><p>If neither <code>parameters</code> nor <code>field_dependencies</code> are provided, then <code>func</code> must be callable with the signature</p><pre><code class="language-julia hljs">func(x, y, z, t)</code></pre><p>where <code>x, y, z</code> are the east-west, north-south, and vertical spatial coordinates, and <code>t</code> is time.</p><p>If <code>field_dependencies</code> are provided, the signature of <code>func</code> must include them. For example, if <code>field_dependencies=(:u, :S)</code> (and <code>parameters</code> are <em>not</em> provided), then <code>func</code> must be callable with the signature</p><pre><code class="language-julia hljs">func(x, y, z, t, u, S)</code></pre><p>where <code>u</code> is assumed to be the <code>u</code>-velocity component, and <code>S</code> is a tracer. Note that any field which does not have the name <code>u</code>, <code>v</code>, or <code>w</code> is assumed to be a tracer and must be present in <code>model.tracers</code>.</p><p>If <code>parameters</code> are provided, then the <em>last</em> argument to <code>func</code> must be <code>parameters</code>. For example, if <code>func</code> has no <code>field_dependencies</code> but does depend on <code>parameters</code>, then it must be callable with the signature</p><pre><code class="language-julia hljs">func(x, y, z, t, parameters)</code></pre><p>With <code>field_dependencies=(:u, :v, :w, :c)</code> and <code>parameters</code>, then <code>func</code> must be callable with the signature</p><pre><code class="language-julia hljs">func(x, y, z, t, u, v, w, c, parameters)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Forcings/continuous_forcing.jl#L47-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.DiscreteForcing" href="#Oceananigans.Forcings.DiscreteForcing"><code>Oceananigans.Forcings.DiscreteForcing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DiscreteForcing{P, F}</code></pre><p>Wrapper for &quot;discrete form&quot; forcing functions with optional <code>parameters</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Forcings/discrete_forcing.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.DiscreteForcing-Tuple{Any}" href="#Oceananigans.Forcings.DiscreteForcing-Tuple{Any}"><code>Oceananigans.Forcings.DiscreteForcing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DiscreteForcing(func; parameters=nothing)</code></pre><p>Construct a &quot;discrete form&quot; forcing function with optional parameters. The forcing function is applied at grid point <code>i, j, k</code>.</p><p>When <code>parameters</code> are not specified, <code>func</code> must be callable with the signature</p><pre><code class="nohighlight hljs">func(i, j, k, grid, clock, model_fields)</code></pre><p>where <code>grid</code> is <code>model.grid</code>, <code>clock.time</code> is the current simulation time and <code>clock.iteration</code> is the current model iteration, and <code>model_fields</code> is a <code>NamedTuple</code> with <code>u, v, w</code> and the fields in <code>model.tracers</code>.</p><p><em>Note</em> that the index <code>end</code> does <em>not</em> access the final physical grid point of a model field in any direction. The final grid point must be explicitly specified, as in <code>model_fields.u[i, j, grid.Nz]</code>.</p><p>When <code>parameters</code> <em>is</em> specified, <code>func</code> must be callable with the signature.</p><pre><code class="nohighlight hljs">func(i, j, k, grid, clock, model_fields, parameters)</code></pre><p>Above, <code>parameters</code> is, in principle, arbitrary. Note, however, that GPU compilation can place constraints on <code>typeof(parameters)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Forcings/discrete_forcing.jl#L15-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.GaussianMask" href="#Oceananigans.Forcings.GaussianMask"><code>Oceananigans.Forcings.GaussianMask</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GaussianMask{D}(center, width)</code></pre><p>Callable object that returns a Gaussian masking function centered on <code>center</code>, with <code>width</code>, and varying along direction <code>D</code>, i.e.,</p><pre><code class="nohighlight hljs">exp(-(D - center)^2 / (2 * width^2))</code></pre><p><strong>Examples</strong></p><ul><li>Create a Gaussian mask centered on <code>z=0</code> with width <code>1</code> meter.</li></ul><pre><code class="language-julia hljs">julia&gt; mask = GaussianMask{:z}(center=0, width=1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Forcings/relaxation.jl#L100-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.LinearTarget" href="#Oceananigans.Forcings.LinearTarget"><code>Oceananigans.Forcings.LinearTarget</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinearTarget{D}(intercept, gradient)</code></pre><p>Callable object that returns a Linear target function with <code>intercept</code> and <code>gradient</code>, and varying along direction <code>D</code>, i.e.,</p><pre><code class="nohighlight hljs">intercept + D * gradient</code></pre><p><strong>Examples</strong></p><ul><li><p>Create a linear target function varying in <code>z</code>, equal to <code>0</code> at <code>z=0</code> and with gradient 10⁻⁶:</p><pre><code class="language-julia hljs">julia&gt; target = LinearTarget{:z}(intercept=0, gradient=1e-6)</code></pre></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Forcings/relaxation.jl#L144-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.Relaxation" href="#Oceananigans.Forcings.Relaxation"><code>Oceananigans.Forcings.Relaxation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Relaxation{R, M, T}</code></pre><p>Callable object for restoring fields to a <code>target</code> at some <code>rate</code> and within a <code>mask</code>ed region in <code>x, y, z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Forcings/relaxation.jl#L11-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.Relaxation-Tuple{}" href="#Oceananigans.Forcings.Relaxation-Tuple{}"><code>Oceananigans.Forcings.Relaxation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Relaxation(; rate, mask=onefunction, target=zerofunction)</code></pre><p>Returns a <code>Forcing</code> that restores a field to <code>target(x, y, z, t)</code> at the specified <code>rate</code>, in the region <code>mask(x, y, z)</code>.</p><p>The functions <code>onefunction</code> and <code>zerofunction</code> always return 1 and 0, respectively. Thus the default <code>mask</code> leaves the whole domain uncovered, and the default <code>target</code> is zero.</p><p><strong>Example</strong></p><ul><li>Restore a field to zero on a timescale of &quot;3600&quot; (equal to one hour if the time units of the simulation are seconds).</li></ul><pre><code class="language-julia hljs">using Oceananigans

damping = Relaxation(rate = 1/3600)

# output
Relaxation{Float64, typeof(Oceananigans.Forcings.onefunction), typeof(Oceananigans.Forcings.zerofunction)}
├── rate: 0.0002777777777777778
├── mask: 1
└── target: 0</code></pre><ul><li>Restore a field to a linear z-gradient within the bottom 1/4 of a domain on a timescale of &quot;60&quot; (equal to one minute if the time units of the simulation are seconds).</li></ul><pre><code class="language-julia hljs">dTdz = 0.001 # ⁰C m⁻¹, temperature gradient

T₀ = 20 # ⁰C, surface temperature at z=0

Lz = 100 # m, depth of domain

bottom_sponge_layer = Relaxation(; rate = 1/60,
                                   target = LinearTarget{:z}(intercept=T₀, gradient=dTdz),
                                   mask = GaussianMask{:z}(center=-Lz, width=Lz/4))

# output
Relaxation{Float64, GaussianMask{:z, Float64}, LinearTarget{:z, Float64}}
├── rate: 0.016666666666666666
├── mask: exp(-(z + 100.0)^2 / (2 * 25.0^2))
└── target: 20.0 + 0.001 * z</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Forcings/relaxation.jl#L23-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Forcings.Forcing-Tuple{Any}" href="#Oceananigans.Forcings.Forcing-Tuple{Any}"><code>Oceananigans.Forcings.Forcing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Forcing(func; parameters=nothing, field_dependencies=(), discrete_form=false)</code></pre><p>Returns a forcing function added to the tendency of an Oceananigans model field.</p><p>If <code>discrete_form=false</code> (the default), and neither <code>parameters</code> nor <code>field_dependencies</code> are provided, then <code>func</code> must be callable with the signature</p><pre><code class="nohighlight hljs">func(x, y, z, t)</code></pre><p>where <code>x, y, z</code> are the east-west, north-south, and vertical spatial coordinates, and <code>t</code> is time. Note that this form is also default in the constructor for <code>NonhydrostaticModel</code>, so that <code>Forcing</code> is not needed.</p><p>If <code>discrete_form=false</code> (the default), and <code>field_dependencies</code> are provided, the signature of <code>func</code> must include them. For example, if <code>field_dependencies=(:u, :S)</code> (and <code>parameters</code> are <em>not</em> provided), then <code>func</code> must be callable with the signature</p><pre><code class="nohighlight hljs">func(x, y, z, t, u, S)`</code></pre><p>where <code>u</code> is assumed to be the <code>u</code>-velocity component, and <code>S</code> is a tracer. Note that any field which does not have the name <code>u</code>, <code>v</code>, or <code>w</code> is assumed to be a tracer and must be present in <code>model.tracers</code>.</p><p>If <code>discrete_form=false</code> (the default) and <code>parameters</code> are provided, then the <em>last</em> argument to <code>func</code> must be <code>parameters</code>. For example, if <code>func</code> has no <code>field_dependencies</code> but does depend on <code>parameters</code>, then it must be callable with the signature</p><pre><code class="nohighlight hljs">func(x, y, z, t, parameters)</code></pre><p>The object <code>parameters</code> is arbitrary in principle, however GPU compilation can place constraints on <code>typeof(parameters)</code>.</p><p>With <code>field_dependencies=(:u, :v, :w, :c)</code> and <code>parameters</code>, then <code>func</code> must be callable with the signature</p><pre><code class="nohighlight hljs">func(x, y, z, t, u, v, w, c, parameters)</code></pre><p>If <code>discrete_form=true</code> then <code>func</code> must be callable with the &quot;discrete form&quot;</p><pre><code class="nohighlight hljs">func(i, j, k, grid, clock, model_fields)</code></pre><p>where <code>i, j, k</code> is the grid point at which the forcing is applied, <code>grid</code> is <code>model.grid</code>, <code>clock.time</code> is the current simulation time and <code>clock.iteration</code> is the current model iteration, and <code>model_fields</code> is a <code>NamedTuple</code> with <code>u, v, w</code>, the fields in <code>model.tracers</code>, and the fields in <code>model.diffusivity_fields</code>, each of which is an <code>OffsetArray</code>s (or <code>NamedTuple</code>s of <code>OffsetArray</code>s depending on the turbulence closure) of field data.</p><p>When <code>discrete_form=true</code> and <code>parameters</code> <em>is</em> specified, <code>func</code> must be callable with the signature</p><pre><code class="nohighlight hljs">func(i, j, k, grid, clock, model_fields, parameters)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Oceananigans

# Parameterized forcing
parameterized_func(x, y, z, t, p) = p.μ * exp(z / p.λ) * cos(p.ω * t)

v_forcing = Forcing(parameterized_func, parameters = (μ=42, λ=0.1, ω=π))

# output
ContinuousForcing{NamedTuple{(:μ, :λ, :ω), Tuple{Int64, Float64, Irrational{:π}}}}
├── func: parameterized_func (generic function with 1 method)
├── parameters: (μ = 42, λ = 0.1, ω = π)
└── field dependencies: ()</code></pre><p>Note that because forcing locations are regularized within the <code>NonhydrostaticModel</code> constructor:</p><pre><code class="language-julia hljs">grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))
model = NonhydrostaticModel(grid=grid, forcing=(v=v_forcing,))

model.forcing.v

# output
ContinuousForcing{NamedTuple{(:μ, :λ, :ω), Tuple{Int64, Float64, Irrational{:π}}}} at (Center, Face, Center)
├── func: parameterized_func (generic function with 1 method)
├── parameters: (μ = 42, λ = 0.1, ω = π)
└── field dependencies: ()</code></pre><p>After passing through the constructor for <code>NonhydrostaticModel</code>, the <code>v</code>-forcing location information is available and set to <code>Center, Face, Center</code>.</p><pre><code class="language-julia hljs"># Field-dependent forcing
growth_in_sunlight(x, y, z, t, P) = exp(z) * P

plankton_forcing = Forcing(growth_in_sunlight, field_dependencies=:P)

# output
ContinuousForcing{Nothing}
├── func: growth_in_sunlight (generic function with 1 method)
├── parameters: nothing
└── field dependencies: (:P,)</code></pre><pre><code class="language-julia hljs"># Parameterized, field-dependent forcing
tracer_relaxation(x, y, z, t, c, p) = p.μ * exp((z + p.H) / p.λ) * (p.dCdz * z - c) 

c_forcing = Forcing(tracer_relaxation,
                    field_dependencies = :c,
                            parameters = (μ=1/60, λ=10, H=1000, dCdz=1))

# output
ContinuousForcing{NamedTuple{(:μ, :λ, :H, :dCdz), Tuple{Float64, Int64, Int64, Int64}}}
├── func: tracer_relaxation (generic function with 1 method)
├── parameters: (μ = 0.016666666666666666, λ = 10, H = 1000, dCdz = 1)
└── field dependencies: (:c,)</code></pre><pre><code class="language-julia hljs"># Unparameterized discrete-form forcing function
filtered_relaxation(i, j, k, grid, clock, model_fields) =
    @inbounds - (model_fields.c[i-1, j, k] + model_fields.c[i, j, k] + model_fields.c[i+1, j, k]) / 3

filtered_forcing = Forcing(filtered_relaxation, discrete_form=true)

# output
DiscreteForcing{Nothing}
├── func: filtered_relaxation (generic function with 1 method)
└── parameters: nothing</code></pre><pre><code class="language-julia hljs"># Discrete-form forcing function with parameters
masked_damping(i, j, k, grid, clock, model_fields, parameters) = 
    @inbounds - parameters.μ * exp(grid.zᵃᵃᶜ[k] / parameters.λ) * model_fields.u[i, j, k]

masked_damping_forcing = Forcing(masked_damping, parameters=(μ=42, λ=π), discrete_form=true)

# output
DiscreteForcing{NamedTuple{(:μ, :λ), Tuple{Int64, Irrational{:π}}}}
├── func: masked_damping (generic function with 1 method)
└── parameters: (μ = 42, λ = π)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Forcings/forcing.jl#L1-L155">source</a></section></article><h2 id="Grids"><a class="docs-heading-anchor" href="#Grids">Grids</a><a id="Grids-1"></a><a class="docs-heading-anchor-permalink" href="#Grids" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.AbstractCurvilinearGrid" href="#Oceananigans.Grids.AbstractCurvilinearGrid"><code>Oceananigans.Grids.AbstractCurvilinearGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractCurvilinearGrid{FT, TX, TY, TZ}</code></pre><p>Abstract supertype for curvilinear grids with elements of type <code>FT</code> and topology <code>{TX, TY, TZ}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Grids/Grids.jl#L126-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.AbstractGrid" href="#Oceananigans.Grids.AbstractGrid"><code>Oceananigans.Grids.AbstractGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractGrid{FT, TX, TY, TZ}</code></pre><p>Abstract supertype for grids with elements of type <code>FT</code> and topology <code>{TX, TY, TZ}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Grids/Grids.jl#L104-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.AbstractHorizontallyCurvilinearGrid" href="#Oceananigans.Grids.AbstractHorizontallyCurvilinearGrid"><code>Oceananigans.Grids.AbstractHorizontallyCurvilinearGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractHorizontallyCurvilinearGrid{FT, TX, TY, TZ}</code></pre><p>Abstract supertype for horizontally-curvilinear grids with elements of type <code>FT</code> and topology <code>{TX, TY, TZ}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Grids/Grids.jl#L133-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.AbstractRectilinearGrid" href="#Oceananigans.Grids.AbstractRectilinearGrid"><code>Oceananigans.Grids.AbstractRectilinearGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractRectilinearGrid{FT, TX, TY, TZ}</code></pre><p>Abstract supertype for rectilinear grids with elements of type <code>FT</code> and topology <code>{TX, TY, TZ}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Grids/Grids.jl#L119-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.AbstractTopology" href="#Oceananigans.Grids.AbstractTopology"><code>Oceananigans.Grids.AbstractTopology</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractTopology</code></pre><p>Abstract supertype for grid topologies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Grids/Grids.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.AbstractUnderlyingGrid" href="#Oceananigans.Grids.AbstractUnderlyingGrid"><code>Oceananigans.Grids.AbstractUnderlyingGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractUnderlyingGrid{FT, TX, TY, TZ}</code></pre><p>Abstract supertype for &quot;primary&quot; grids (as opposed to grids with immersed boundaries) with elements of type <code>FT</code> and topology <code>{TX, TY, TZ}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Grids/Grids.jl#L111-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.Bounded" href="#Oceananigans.Grids.Bounded"><code>Oceananigans.Grids.Bounded</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Bounded</code></pre><p>Grid topology for bounded dimensions, e.g., wall-bounded dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Grids/Grids.jl#L68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.Center" href="#Oceananigans.Grids.Center"><code>Oceananigans.Grids.Center</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Center</code></pre><p>A type describing the location at the center of a grid cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Grids/Grids.jl#L40-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.Face" href="#Oceananigans.Grids.Face"><code>Oceananigans.Grids.Face</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Face</code></pre><p>A type describing the location at the face of a grid cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Grids/Grids.jl#L47-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.Flat" href="#Oceananigans.Grids.Flat"><code>Oceananigans.Grids.Flat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Flat</code></pre><p>Grid topology for flat dimensions, generally with one grid point, along which the solution is uniform and does not vary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Grids/Grids.jl#L75-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.FullyConnected" href="#Oceananigans.Grids.FullyConnected"><code>Oceananigans.Grids.FullyConnected</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FullyConnected</code></pre><p>Grid topology for dimensions that are connected to other models or domains.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Grids/Grids.jl#L83-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.LatitudeLongitudeGrid" href="#Oceananigans.Grids.LatitudeLongitudeGrid"><code>Oceananigans.Grids.LatitudeLongitudeGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LatitudeLongitudeGrid([architecture = CPU(), FT = Float64];
                      size,
                      longitude,
                      latitude,
                      z = nothing,
                      radius = R_Earth,
                      topology = nothing,
                      precompute_metrics = true,
                      halo = nothing)</code></pre><p>Creates a <code>LatitudeLongitudeGrid</code> with coordinates <code>(λ, φ, z)</code> denoting longitude, latitude, and vertical coordinate respectively.</p><p><strong>Positional arguments</strong></p><ul><li><p><code>architecture</code>: Specifies whether arrays of coordinates and spacings are stored                 on the CPU or GPU. Default: <code>CPU()</code>.</p></li><li><p><code>FT</code> : Floating point data type. Default: <code>Float64</code>.</p></li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>size</code> (required): A 3-tuple prescribing the number of grid points each direction.</p></li><li><p><code>longitude</code> (required), <code>latitude</code> (required), <code>z</code> (default: <code>nothing</code>): Each is either a:</p><ol><li>2-tuple that specify the end points of the domain,</li><li>one-dimensional array specifying the cell interface locations, or</li><li>a single-argument function that takes an index and returns cell interface location.</li></ol><p><strong>Note</strong>: the latitude and longitude coordinates extents are expected in degrees.</p></li><li><p><code>radius</code>: The radius of the sphere the grid lives on. By default is equal to the radius of Earth.</p></li><li><p><code>topology</code>: Tuple of topologies (<code>Flat</code>, <code>Bounded</code>, <code>Periodic</code>) for each direction. The vertical              <code>topology[3]</code> must be <code>Bounded</code>, while the latitude-longitude topologies can be             <code>Bounded</code>, <code>Periodic</code>, or <code>Flat</code>. If no topology is provided then, by default, the             topology is (<code>Periodic</code>, <code>Bounded</code>, <code>Bounded</code>) if the latitudinal extent is 360 degrees             or (<code>Bounded</code>, <code>Bounded</code>, <code>Bounded</code>) otherwise.</p></li><li><p><code>precompute_metrics</code>: Boolean specifying whether to precompute horizontal spacings and areas.                       Default: <code>true</code>. When <code>false</code>, horizontal spacings and areas are computed                       on-the-fly during a simulation.</p></li><li><p><code>halo</code>: A 3-tuple of integers specifying the size of the halo region of cells surrounding         the physical interior. The default is 3 halo cells in every direction.</p></li></ul><p><strong>Examples</strong></p><ul><li>A default grid with <code>Float64</code> type:</li></ul><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = LatitudeLongitudeGrid(size=(36, 34, 25),
                                    longitude = (-180, 180),
                                    latitude = (-85, 85),
                                    z = (-1000, 0))
36×34×25 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics
├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=10.0
├── latitude:  Bounded  φ ∈ [-85.0, 85.0]   regularly spaced with Δφ=5.0
└── z:         Bounded  z ∈ [-1000.0, 0.0]  regularly spaced with Δz=40.0</code></pre><ul><li>A bounded spherical sector with cell interfaces stretched hyperbolically near the top:</li></ul><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; σ = 1.1; # stretching factor

julia&gt; Nz = 24; # vertical resolution

julia&gt; Lz = 1000; # depth (m)

julia&gt; hyperbolically_spaced_faces(k) = - Lz * (1 - tanh(σ * (k - 1) / Nz) / tanh(σ));

julia&gt; grid = LatitudeLongitudeGrid(size=(36, 34, Nz),
                                    longitude = (-180, 180),
                                    latitude = (-20, 20),
                                    z = hyperbolically_spaced_faces,
                                    topology = (Bounded, Bounded, Bounded))
36×34×24 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics
├── longitude: Bounded  λ ∈ [-180.0, 180.0] regularly spaced with Δλ=10.0
├── latitude:  Bounded  φ ∈ [-20.0, 20.0]   regularly spaced with Δφ=1.17647
└── z:         Bounded  z ∈ [-1000.0, -0.0] variably spaced with min(Δz)=21.3342, max(Δz)=57.2159</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Grids/latitude_longitude_grid.jl#L85-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.LeftConnected" href="#Oceananigans.Grids.LeftConnected"><code>Oceananigans.Grids.LeftConnected</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LeftConnected</code></pre><p>Grid topology for dimensions that are connected to other models or domains only on the left (the other direction is bounded)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Grids/Grids.jl#L90-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.OrthogonalSphericalShellGrid" href="#Oceananigans.Grids.OrthogonalSphericalShellGrid"><code>Oceananigans.Grids.OrthogonalSphericalShellGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OrthogonalSphericalShellGrid(architecture::AbstractArchitecture = CPU(),
                             FT::DataType = Float64;
                             size,
                             z,
                             topology = (Bounded, Bounded, Bounded),
                             ξ = (-1, 1),
                             η = (-1, 1),
                             radius = R_Earth,
                             halo = (1, 1, 1),
                             rotation = nothing)</code></pre><p>Create a <code>OrthogonalSphericalShellGrid</code> that represents a section of a sphere after it has been  mapped from the face of a cube. The cube&#39;s coordinates are <code>ξ</code> and <code>η</code> (which, by default, take values in the range <span>$[-1, 1]$</span>.</p><p>The mapping from the face of the cube to the sphere is done via the <a href="https://github.com/CliMA/CubedSphere.jl">CubedSphere.jl</a> package.</p><p><strong>Positional arguments</strong></p><ul><li><p><code>architecture</code>: Specifies whether arrays of coordinates and spacings are stored                 on the CPU or GPU. Default: <code>CPU()</code>.</p></li><li><p><code>FT</code> : Floating point data type. Default: <code>Float64</code>.</p></li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>size</code> (required): A 3-tuple prescribing the number of grid points each direction.</p></li><li><p><code>z</code> (required): Either a</p><ol><li>2-tuple that specify the end points of the <span>$z$</span>-domain,</li><li>one-dimensional array specifying the cell interface locations, or</li><li>a single-argument function that takes an index and returns cell interface location.</li></ol></li><li><p><code>radius</code>: The radius of the sphere the grid lives on. By default is equal to the radius of Earth.</p></li><li><p><code>halo</code>: A 3-tuple of integers specifying the size of the halo region of cells surrounding         the physical interior. The default is 1 halo cells in every direction.</p></li><li><p><code>rotation</code>: Rotation of the spherical shell grid about some axis that passes through the center             of the sphere. If <code>nothing</code> is provided (default), then the spherical shell includes             the North Pole of the sphere in its center.</p></li></ul><p><strong>Examples</strong></p><ul><li>A default grid with <code>Float64</code> type:</li></ul><pre><code class="language- hljs">julia&gt; using Oceananigans

julia&gt; grid = OrthogonalSphericalShellGrid(size=(36, 34, 25), z=(-1000, 0))
36×34×25 OrthogonalSphericalShellGrid{Float64, Bounded, Bounded, Bounded} on CPU with 1×1×1 halo and with precomputed metrics
├── longitude: Bounded  λ ∈ [-176.397, 180.0] variably spaced with min(Δλ)=48351.7, max(Δλ)=2.87833e5
├── latitude:  Bounded  φ ∈ [35.2644, 90.0]   variably spaced with min(Δφ)=50632.2, max(Δφ)=3.04768e5
└── z:         Bounded  z ∈ [-1000.0, 0.0]    regularly spaced with Δz=40.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Grids/orthogonal_spherical_shell_grid.jl#L67-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.Periodic" href="#Oceananigans.Grids.Periodic"><code>Oceananigans.Grids.Periodic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Periodic</code></pre><p>Grid topology for periodic dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Grids/Grids.jl#L61-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.RectilinearGrid" href="#Oceananigans.Grids.RectilinearGrid"><code>Oceananigans.Grids.RectilinearGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RectilinearGrid([architecture = CPU(), FT = Float64];
                size,
                x = nothing,
                y = nothing,
                z = nothing,
                halo = nothing,
                extent = nothing,
                topology = (Periodic, Periodic, Bounded))</code></pre><p>Create a <code>RectilinearGrid</code> with <code>size = (Nx, Ny, Nz)</code> grid points.</p><p><strong>Positional arguments</strong></p><ul><li><p><code>architecture</code>: Specifies whether arrays of coordinates and spacings are stored                 on the CPU or GPU. Default: <code>CPU()</code>.</p></li><li><p><code>FT</code> : Floating point data type. Default: <code>Float64</code>.</p></li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>size</code> (required): A tuple prescribing the number of grid points in non-<code>Flat</code> directions.                    <code>size</code> is a 3-tuple for 3D models, a 2-tuple for 2D models, and either a                    scalar or 1-tuple for 1D models.</p></li><li><p><code>topology</code>: A 3-tuple <code>(TX, TY, TZ)</code> specifying the topology of the domain.             <code>TX</code>, <code>TY</code>, and <code>TZ</code> specify whether the <code>x</code>-, <code>y</code>-, and <code>z</code> directions are             <code>Periodic</code>, <code>Bounded</code>, or <code>Flat</code>. The topology <code>Flat</code> indicates that a model does             not vary in those directions so that derivatives and interpolation are zero.             The default is <code>topology = (Periodic, Periodic, Bounded)</code>.</p></li><li><p><code>extent</code>: A tuple prescribing the physical extent of the grid in non-<code>Flat</code> directions, e.g.,           <code>(Lx, Ly, Lz)</code>. All directions are contructed with regular grid spacing and the domain           (in the case that no direction is <code>Flat</code>) is <span>$0 ≤ x ≤ L_x$</span>, <span>$0 ≤ y ≤ L_y$</span>, and           <span>$-L_z ≤ z ≤ 0$</span>, which is most appropriate for oceanic applications in which <span>$z = 0$</span>           usually is the ocean&#39;s surface.</p></li><li><p><code>x</code>, <code>y</code>, and <code>z</code>: Each of <code>x, y, z</code> are either (i) 2-tuples that specify the end points of the domain                    in their respect directions (in which case scalar values may be used in <code>Flat</code>                    directions), or (ii) arrays or functions of the corresponding indices <code>i</code>, <code>j</code>, or <code>k</code>                    that specify the locations of cell faces in the <code>x</code>-, <code>y</code>-, or <code>z</code>-direction, respectively.                    For example, to prescribe the cell faces in <code>z</code> we need to provide a function that takes                    <code>k</code> as argument and retuns the location of the faces for indices <code>k = 1</code> through <code>k = Nz + 1</code>,                    where <code>Nz</code> is the <code>size</code> of the stretched <code>z</code> dimension.</p></li></ul><p><strong>Note</strong>: <em>Either</em> <code>extent</code>, or <em>all</em> of <code>x</code>, <code>y</code>, and <code>z</code> must be specified.</p><ul><li><code>halo</code>: A tuple of integers that specifies the size of the halo region of cells surrounding         the physical interior for each non-<code>Flat</code> direction. The default is 3 halo cells in every direction.</li></ul><p>The physical extent of the domain can be specified either via <code>x</code>, <code>y</code>, and <code>z</code> keyword arguments indicating the left and right endpoints of each dimensions, e.g., <code>x = (-π, π)</code> or via the <code>extent</code> argument, e.g., <code>extent = (Lx, Ly, Lz)</code>, which specifies the extent of each dimension in which case <span>$0 ≤ x ≤ L_x$</span>, <span>$0 ≤ y ≤ L_y$</span>, and <span>$-L_z ≤ z ≤ 0$</span>.</p><p>A grid topology may be specified via a tuple assigning one of <code>Periodic</code>, <code>Bounded</code>, and, <code>Flat</code> to each dimension. By default, a horizontally periodic grid topology <code>(Periodic, Periodic, Bounded)</code> is assumed.</p><p>Constants are stored using floating point values of type <code>FT</code>. By default this is <code>Float64</code>. Make sure to specify the desired <code>FT</code> if not using <code>Float64</code>.</p><p><strong>Grid properties</strong></p><ul><li><p><code>(Nx, Ny, Nz) :: Int</code>: Number of physical points in the <span>$(x, y, z)$</span>-direction.</p></li><li><p><code>(Hx, Hy, Hz) :: Int</code>: Number of halo points in the <span>$(x, y, z)$</span>-direction.</p></li><li><p><code>(Lx, Ly, Lz) :: FT</code>: Physical extent of the grid in the <span>$(x, y, z)$</span>-direction.</p></li><li><p><code>(Δxᶜᵃᵃ, Δyᵃᶜᵃ, Δzᵃᵃᶜ)</code>: Grid spacing in the <span>$(x, y, z)$</span>-direction between cell centers.                          Defined at cell centers in <span>$x$</span>, <span>$y$</span>, and <span>$z$</span>.</p></li><li><p><code>(Δxᶠᵃᵃ, Δyᵃᶠᵃ, Δzᵃᵃᶠ)</code>: Grid spacing in the <span>$(x, y, z)$</span>-direction between cell faces.                          Defined at cell faces in <span>$x$</span>, <span>$y$</span>, and <span>$z$</span>.</p></li><li><p><code>(xᶜᵃᵃ, yᵃᶜᵃ, zᵃᵃᶜ)</code>: <span>$(x, y, z)$</span> coordinates of cell centers.</p></li><li><p><code>(xᶠᵃᵃ, yᵃᶠᵃ, zᵃᵃᶠ)</code>: <span>$(x, y, z)$</span> coordinates of cell faces.</p></li></ul><p><strong>Examples</strong></p><ul><li>A grid with the default <code>Float64</code> type:</li></ul><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = RectilinearGrid(size=(32, 32, 32), extent=(1, 2, 3))
32×32×32 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo
├── Periodic x ∈ [0.0, 1.0)  regularly spaced with Δx=0.03125
├── Periodic y ∈ [0.0, 2.0)  regularly spaced with Δy=0.0625
└── Bounded  z ∈ [-3.0, 0.0] regularly spaced with Δz=0.09375</code></pre><ul><li>A grid with <code>Float32</code> type:</li></ul><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = RectilinearGrid(Float32; size=(32, 32, 16), x=(0, 8), y=(-10, 10), z=(-π, π))
32×32×16 RectilinearGrid{Float32, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo
├── Periodic x ∈ [0.0, 8.0)          regularly spaced with Δx=0.25
├── Periodic y ∈ [-10.0, 10.0)       regularly spaced with Δy=0.625
└── Bounded  z ∈ [-3.14159, 3.14159] regularly spaced with Δz=0.392699</code></pre><ul><li>A two-dimenisional, horizontally-periodic grid:</li></ul><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = RectilinearGrid(size=(32, 32), extent=(2π, 4π), topology=(Periodic, Periodic, Flat))
32×32×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo
├── Periodic x ∈ [3.60072e-17, 6.28319) regularly spaced with Δx=0.19635
├── Periodic y ∈ [7.20145e-17, 12.5664) regularly spaced with Δy=0.392699
└── Flat z</code></pre><ul><li>A one-dimensional &quot;column&quot; grid:</li></ul><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = RectilinearGrid(size=256, z=(-128, 0), topology=(Flat, Flat, Bounded))
1×1×256 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo
├── Flat x
├── Flat y
└── Bounded  z ∈ [-128.0, 0.0]    regularly spaced with Δz=0.5</code></pre><ul><li>A horizontally-periodic regular grid with cell interfaces stretched hyperbolically near the top:</li></ul><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; σ = 1.1; # stretching factor

julia&gt; Nz = 24; # vertical resolution

julia&gt; Lz = 32; # depth (m)

julia&gt; hyperbolically_spaced_faces(k) = - Lz * (1 - tanh(σ * (k - 1) / Nz) / tanh(σ));

julia&gt; grid = RectilinearGrid(size = (32, 32, Nz),
                              x = (0, 64), y = (0, 64),
                              z = hyperbolically_spaced_faces)
32×32×24 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo
├── Periodic x ∈ [0.0, 64.0)   regularly spaced with Δx=2.0
├── Periodic y ∈ [0.0, 64.0)   regularly spaced with Δy=2.0
└── Bounded  z ∈ [-32.0, -0.0] variably spaced with min(Δz)=0.682695, max(Δz)=1.83091</code></pre><ul><li>A three-dimensional grid with regular spacing in <span>$x$</span>, cell interfaces at Chebyshev nodes in <span>$y$</span>, and cell interfaces hyperbolically stretched in <span>$z$</span> near the top:</li></ul><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; Nx, Ny, Nz = 32, 30, 24;

julia&gt; Lx, Ly, Lz = 200, 100, 32; # (m)

julia&gt; chebychev_nodes(j) = - Ly/2 * cos(π * (j - 1) / Ny);

julia&gt; σ = 1.1; # stretching factor

julia&gt; hyperbolically_spaced_faces(k) = - Lz * (1 - tanh(σ * (k - 1) / Nz) / tanh(σ));

julia&gt; grid = RectilinearGrid(size = (Nx, Ny, Nz),
                              topology = (Periodic, Bounded, Bounded),
                              x = (0, Lx),
                              y = chebychev_nodes,
                              z = hyperbolically_spaced_faces)
32×30×24 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3×3×3 halo
├── Periodic x ∈ [0.0, 200.0)  regularly spaced with Δx=6.25
├── Bounded  y ∈ [-50.0, 50.0] variably spaced with min(Δy)=0.273905, max(Δy)=5.22642
└── Bounded  z ∈ [-32.0, -0.0] variably spaced with min(Δz)=0.682695, max(Δz)=1.83091</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Grids/rectilinear_grid.jl#L71-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.RightConnected" href="#Oceananigans.Grids.RightConnected"><code>Oceananigans.Grids.RightConnected</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RightConnected</code></pre><p>Grid topology for dimensions that are connected to other models or domains only on the right (the other direction is bounded)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Grids/Grids.jl#L97-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.halo_size-Tuple{Any}" href="#Oceananigans.Grids.halo_size-Tuple{Any}"><code>Oceananigans.Grids.halo_size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">halo_size(grid)</code></pre><p>Return a 3-tuple with the number of halo cells on either side of the domain in (x, y, z).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Grids/grid_utils.jl#L69-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.minimum_xspacing-NTuple{4, Any}" href="#Oceananigans.Grids.minimum_xspacing-NTuple{4, Any}"><code>Oceananigans.Grids.minimum_xspacing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">minimum_xspacing(grid, ℓx, ℓy, ℓz)
minimum_xspacing(grid) = minimum_xspacing(grid, Center(), Center(), Center())</code></pre><p>Return the minimum spacing for <code>grid</code> in <span>$x$</span> direction at location <code>ℓx, ℓy, ℓz</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = RectilinearGrid(size=(2, 4, 8), extent=(1, 1, 1));

julia&gt; minimum_xspacing(grid, Center(), Center(), Center())
0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Grids/grid_utils.jl#L411-L427">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.minimum_yspacing-NTuple{4, Any}" href="#Oceananigans.Grids.minimum_yspacing-NTuple{4, Any}"><code>Oceananigans.Grids.minimum_yspacing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">minimum_yspacing(grid, ℓx, ℓy, ℓz)
minimum_yspacing(grid) = minimum_yspacing(grid, Center(), Center(), Center())</code></pre><p>Return the minimum spacing for <code>grid</code> in <span>$y$</span> direction at location <code>ℓx, ℓy, ℓz</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = RectilinearGrid(size=(2, 4, 8), extent=(1, 1, 1));

julia&gt; minimum_yspacing(grid, Center(), Center(), Center())
0.25</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Grids/grid_utils.jl#L430-L446">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.minimum_zspacing-NTuple{4, Any}" href="#Oceananigans.Grids.minimum_zspacing-NTuple{4, Any}"><code>Oceananigans.Grids.minimum_zspacing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">minimum_zspacing(grid, ℓx, ℓy, ℓz)
minimum_zspacing(grid) = minimum_zspacing(grid, Center(), Center(), Center())</code></pre><p>Return the minimum spacing for <code>grid</code> in <span>$z$</span> direction at location <code>ℓx, ℓy, ℓz</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = RectilinearGrid(size=(2, 4, 8), extent=(1, 1, 1));

julia&gt; minimum_zspacing(grid, Center(), Center(), Center())
0.125</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Grids/grid_utils.jl#L450-L466">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.new_data" href="#Oceananigans.Grids.new_data"><code>Oceananigans.Grids.new_data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">new_data(FT, arch, loc, topo, sz, halo_sz, indices)</code></pre><p>Returns an <code>OffsetArray</code> of zeros of float type <code>FT</code> on <code>arch</code>itecture, with indices corresponding to a field on a <code>grid</code> of <code>size(grid)</code> and located at <code>loc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Grids/new_data.jl#L54-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.nodes-Tuple{Oceananigans.Grids.AbstractGrid, Any}" href="#Oceananigans.Grids.nodes-Tuple{Oceananigans.Grids.AbstractGrid, Any}"><code>Oceananigans.Grids.nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nodes(grid, (ℓx, ℓy, ℓz); reshape=false, with_halos=false)
nodes(grid, ℓx, ℓy, ℓz; reshape=false, with_halos=false)</code></pre><p>Return a 3-tuple of views over the interior nodes of the <code>grid</code>&#39;s native coordinates at the locations in <code>loc=(ℓx, ℓy, ℓz)</code> in <code>x, y, z</code>.</p><p>If <code>reshape=true</code>, the views are reshaped to 3D arrays with non-singleton dimensions 1, 2, 3 for <code>x, y, z</code>, respectively. These reshaped arrays can then be used in broadcast operations with 3D fields or arrays.</p><p>For <code>RectilinearGrid</code>s the native coordinates are <code>x, y, z</code>; for curvilinear grids, like <code>LatitudeLongitudeGrid</code> or <code>OrthogonalSphericalShellGrid</code> the native coordinates are <code>λ, φ, z</code>.</p><p>See <a href="#Oceananigans.Grids.xnodes-NTuple{4, Any}"><code>xnodes</code></a>, <a href="#Oceananigans.Grids.ynodes-NTuple{4, Any}"><code>ynodes</code></a>, <a href="#Oceananigans.Grids.znodes-NTuple{4, Any}"><code>znodes</code></a>, <a href="#Oceananigans.Grids.λnodes-Tuple{Oceananigans.Grids.AbstractCurvilinearGrid, Any, Any, Any}"><code>λnodes</code></a>, and <a href="#Oceananigans.Grids.φnodes-Tuple{Oceananigans.Grids.AbstractCurvilinearGrid, Any, Any, Any}"><code>φnodes</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Grids/grid_utils.jl#L304-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.offset_data" href="#Oceananigans.Grids.offset_data"><code>Oceananigans.Grids.offset_data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">offset_data(underlying_data, grid::AbstractGrid, loc)</code></pre><p>Returns an <code>OffsetArray</code> that maps to <code>underlying_data</code> in memory, with offset indices appropriate for the <code>data</code> of a field on a <code>grid</code> of <code>size(grid)</code> and located at <code>loc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Grids/new_data.jl#L44-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.topology-Tuple{Any, Any}" href="#Oceananigans.Grids.topology-Tuple{Any, Any}"><code>Oceananigans.Grids.topology</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">topology(grid, dim)</code></pre><p>Return the topology of the <code>grid</code> for the <code>dim</code>-th dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Grids/grid_utils.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.topology-Union{Tuple{Oceananigans.Grids.AbstractGrid{FT, TX, TY, TZ}}, Tuple{TZ}, Tuple{TY}, Tuple{TX}, Tuple{FT}} where {FT, TX, TY, TZ}" href="#Oceananigans.Grids.topology-Union{Tuple{Oceananigans.Grids.AbstractGrid{FT, TX, TY, TZ}}, Tuple{TZ}, Tuple{TY}, Tuple{TX}, Tuple{FT}} where {FT, TX, TY, TZ}"><code>Oceananigans.Grids.topology</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">topology(grid)</code></pre><p>Return a tuple with the topology of the <code>grid</code> for each dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Grids/grid_utils.jl#L12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.total_size" href="#Oceananigans.Grids.total_size"><code>Oceananigans.Grids.total_size</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">total_size(grid, loc)</code></pre><p>Return the &quot;total&quot; size of a <code>grid</code> at <code>loc</code>. This is a 3-tuple of integers corresponding to the number of grid points along <code>x, y, z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Grids/grid_utils.jl#L112-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.xnodes-NTuple{4, Any}" href="#Oceananigans.Grids.xnodes-NTuple{4, Any}"><code>Oceananigans.Grids.xnodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">xnodes(grid, ℓx, ℓy, ℓz, with_halos=false)</code></pre><p>Return the positions over the interior nodes on <code>grid</code> in the <span>$x$</span>-direction for the location <code>ℓx</code>, <code>ℓy</code>, <code>ℓz</code>. For <code>Bounded</code> directions, <code>Face</code> nodes include the boundary points.</p><p>See <a href="#Oceananigans.Grids.znodes-NTuple{4, Any}"><code>znodes</code></a> for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Grids/grid_utils.jl#L234-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.xspacings-NTuple{4, Any}" href="#Oceananigans.Grids.xspacings-NTuple{4, Any}"><code>Oceananigans.Grids.xspacings</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">xspacings(grid, ℓx, ℓy, ℓz; with_halos=true)</code></pre><p>Return the spacings over the interior nodes on <code>grid</code> in the <span>$x$</span>-direction for the location <code>ℓx</code>, <code>ℓy</code>, <code>ℓz</code>. For <code>Bounded</code> directions, <code>Face</code> nodes include the boundary points.</p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = LatitudeLongitudeGrid(size=(8, 15, 10), longitude=(-20, 60), latitude=(-10, 50), z=(-100, 0));

julia&gt; xspacings(grid, Center(), Face(), Center())
16-element view(OffsetArray(::Vector{Float64}, -2:18), 1:16) with eltype Float64:
      1.0950562585518518e6
      1.1058578920188267e6
      1.1112718969963323e6
      1.1112718969963323e6
      1.1058578920188267e6
      1.0950562585518518e6
      1.0789196210678827e6
      1.0575265956426917e6
      1.0309814069457315e6
 999413.38046802
 962976.3124613502
 921847.720658409
 876227.979424229
 826339.3435524226
 772424.8654621692
 714747.2110712599</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Grids/grid_utils.jl#L332-L362">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.ynodes-NTuple{4, Any}" href="#Oceananigans.Grids.ynodes-NTuple{4, Any}"><code>Oceananigans.Grids.ynodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ynodes(grid, ℓx, ℓy, ℓz, with_halos=false)</code></pre><p>Return the positions over the interior nodes on <code>grid</code> in the <span>$y$</span>-direction for the location <code>ℓx</code>, <code>ℓy</code>, <code>ℓz</code>. For <code>Bounded</code> directions, <code>Face</code> nodes include the boundary points.</p><p>See <a href="#Oceananigans.Grids.znodes-NTuple{4, Any}"><code>znodes</code></a> for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Grids/grid_utils.jl#L244-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.yspacings-NTuple{4, Any}" href="#Oceananigans.Grids.yspacings-NTuple{4, Any}"><code>Oceananigans.Grids.yspacings</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">yspacings(grid, ℓx, ℓy, ℓz; with_halos=true)</code></pre><p>Return the spacings over the interior nodes on <code>grid</code> in the <span>$y$</span>-direction for the location <code>ℓx</code>, <code>ℓy</code>, <code>ℓz</code>. For <code>Bounded</code> directions, <code>Face</code> nodes include the boundary points.</p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = LatitudeLongitudeGrid(size=(20, 15, 10), longitude=(0, 20), latitude=(-15, 15), z=(-100, 0));

julia&gt; yspacings(grid, Center(), Center(), Center())
222389.85328911748</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Grids/grid_utils.jl#L366-L380">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.znodes-NTuple{4, Any}" href="#Oceananigans.Grids.znodes-NTuple{4, Any}"><code>Oceananigans.Grids.znodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">znodes(grid, ℓx, ℓy, ℓz; with_halos=false)</code></pre><p>Return the positions over the interior nodes on <code>grid</code> in the <span>$z$</span>-direction for the location <code>ℓx</code>, <code>ℓy</code>, <code>ℓz</code>. For <code>Bounded</code> directions, <code>Face</code> nodes include the boundary points.</p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; horz_periodic_grid = RectilinearGrid(size=(3, 3, 3), extent=(2π, 2π, 1), halo=(1, 1, 1),
                                            topology=(Periodic, Periodic, Bounded));

julia&gt; zC = znodes(horz_periodic_grid, Center())
3-element view(OffsetArray(::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, 0:4), 1:3) with eltype Float64:
 -0.8333333333333334
 -0.5
 -0.16666666666666666

julia&gt; zC = znodes(horz_periodic_grid, Center(), Center(), Center())
3-element view(OffsetArray(::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, 0:4), 1:3) with eltype Float64:
 -0.8333333333333334
 -0.5
 -0.16666666666666666

julia&gt; zC = znodes(horz_periodic_grid, Center(), Center(), Center(), with_halos=true)
-1.1666666666666667:0.3333333333333333:0.16666666666666666 with indices 0:4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Grids/grid_utils.jl#L254-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.zspacings-NTuple{4, Any}" href="#Oceananigans.Grids.zspacings-NTuple{4, Any}"><code>Oceananigans.Grids.zspacings</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zspacings(grid, ℓx, ℓy, ℓz; with_halos=true)</code></pre><p>Return the spacings over the interior nodes on <code>grid</code> in the <span>$z$</span>-direction for the location <code>ℓx</code>, <code>ℓy</code>, <code>ℓz</code>. For <code>Bounded</code> directions, <code>Face</code> nodes include the boundary points.</p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = LatitudeLongitudeGrid(size=(20, 15, 10), longitude=(0, 20), latitude=(-15, 15), z=(-100, 0));

julia&gt; zspacings(grid, Center(), Center(), Center())
10.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Grids/grid_utils.jl#L383-L397">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.λnodes-Tuple{Oceananigans.Grids.AbstractCurvilinearGrid, Any, Any, Any}" href="#Oceananigans.Grids.λnodes-Tuple{Oceananigans.Grids.AbstractCurvilinearGrid, Any, Any, Any}"><code>Oceananigans.Grids.λnodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">λnodes(grid::AbstractCurvilinearGrid, ℓx, ℓy, ℓz, with_halos=false)</code></pre><p>Return the positions over the interior nodes on a curvilinear <code>grid</code> in the <span>$λ$</span>-direction for the location <code>ℓλ</code>, <code>ℓφ</code>, <code>ℓz</code>. For <code>Bounded</code> directions, <code>Face</code> nodes include the boundary points.</p><p>See <a href="#Oceananigans.Grids.znodes-NTuple{4, Any}"><code>znodes</code></a> for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Grids/grid_utils.jl#L284-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Grids.φnodes-Tuple{Oceananigans.Grids.AbstractCurvilinearGrid, Any, Any, Any}" href="#Oceananigans.Grids.φnodes-Tuple{Oceananigans.Grids.AbstractCurvilinearGrid, Any, Any, Any}"><code>Oceananigans.Grids.φnodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">φnodes(grid::AbstractCurvilinearGrid, ℓx, ℓy, ℓz, with_halos=false)</code></pre><p>Return the positions over the interior nodes on a curvilinear <code>grid</code> in the <span>$φ$</span>-direction for the location <code>ℓλ</code>, <code>ℓφ</code>, <code>ℓz</code>. For <code>Bounded</code> directions, <code>Face</code> nodes include the boundary points.</p><p>See <a href="#Oceananigans.Grids.znodes-NTuple{4, Any}"><code>znodes</code></a> for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Grids/grid_utils.jl#L294-L301">source</a></section></article><h2 id="Immersed-boundaries"><a class="docs-heading-anchor" href="#Immersed-boundaries">Immersed boundaries</a><a id="Immersed-boundaries-1"></a><a class="docs-heading-anchor-permalink" href="#Immersed-boundaries" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.ImmersedBoundaries.GridFittedBottom" href="#Oceananigans.ImmersedBoundaries.GridFittedBottom"><code>Oceananigans.ImmersedBoundaries.GridFittedBottom</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GridFittedBottom(bottom_height, [immersed_condition=CenterImmersedCondition()])</code></pre><p>Return an immersed boundary with an irregular bottom fit to the underlying grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/ImmersedBoundaries/grid_fitted_immersed_boundaries.jl#L42-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.ImmersedBoundaries.ImmersedBoundaryCondition-Tuple{}" href="#Oceananigans.ImmersedBoundaries.ImmersedBoundaryCondition-Tuple{}"><code>Oceananigans.ImmersedBoundaries.ImmersedBoundaryCondition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ImmersedBoundaryCondition(; interfaces...)</code></pre><p>Return an ImmersedBoundaryCondition with conditions on individual cell <code>interfaces ∈ (west, east, south, north, bottom, top)</code> between the fluid and immersed boundary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/ImmersedBoundaries/immersed_boundary_condition.jl#L40-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.ImmersedBoundaries.ImmersedBoundaryGrid-Tuple{Any, Oceananigans.ImmersedBoundaries.AbstractGridFittedBottom}" href="#Oceananigans.ImmersedBoundaries.ImmersedBoundaryGrid-Tuple{Any, Oceananigans.ImmersedBoundaries.AbstractGridFittedBottom}"><code>Oceananigans.ImmersedBoundaries.ImmersedBoundaryGrid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ImmersedBoundaryGrid(grid, ib::GridFittedBottom)</code></pre><p>Return a grid with <code>GridFittedBottom</code> immersed boundary.</p><p>Computes ib.bottom_height and wraps in an array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/ImmersedBoundaries/grid_fitted_immersed_boundaries.jl#L64-L70">source</a></section></article><h2 id="Logger"><a class="docs-heading-anchor" href="#Logger">Logger</a><a id="Logger-1"></a><a class="docs-heading-anchor-permalink" href="#Logger" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Logger.OceananigansLogger" href="#Oceananigans.Logger.OceananigansLogger"><code>Oceananigans.Logger.OceananigansLogger</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OceananigansLogger(stream::IO=stdout, level=Logging.Info; show_info_source=false)</code></pre><p>Based on Logging.SimpleLogger, it tries to log all messages in the following format:</p><pre><code class="nohighlight hljs">[yyyy/mm/dd HH:MM:SS.sss] log_level message [-@-&gt; source_file:line_number]</code></pre><p>where the source of the message between the square brackets is included only if <code>show_info_source=true</code> or if the message is not an info level message.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Logger.jl#L26-L35">source</a></section></article><h2 id="Models"><a class="docs-heading-anchor" href="#Models">Models</a><a id="Models-1"></a><a class="docs-heading-anchor-permalink" href="#Models" title="Permalink"></a></h2><h3 id="Non-hydrostatic-models"><a class="docs-heading-anchor" href="#Non-hydrostatic-models">Non-hydrostatic models</a><a id="Non-hydrostatic-models-1"></a><a class="docs-heading-anchor-permalink" href="#Non-hydrostatic-models" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Models.NonhydrostaticModels.NonhydrostaticModel-Tuple{}" href="#Oceananigans.Models.NonhydrostaticModels.NonhydrostaticModel-Tuple{}"><code>Oceananigans.Models.NonhydrostaticModels.NonhydrostaticModel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NonhydrostaticModel(;          grid,
                              clock = Clock{eltype(grid)}(0, 0, 1),
                          advection = CenteredSecondOrder(),
                           buoyancy = nothing,
                           coriolis = nothing,
                       stokes_drift = nothing,
                forcing::NamedTuple = NamedTuple(),
                            closure = nothing,
    boundary_conditions::NamedTuple = NamedTuple(),
                            tracers = (),
                        timestepper = :QuasiAdamsBashforth2,
      background_fields::NamedTuple = NamedTuple(),
      particles::ParticlesOrNothing = nothing,</code></pre><p>biogeochemistry::AbstractBGCOrNothing = nothing,                              velocities = nothing,                               pressures = nothing,                      diffusivity<em>fields = nothing,                         pressure</em>solver = nothing,                       immersed<em>boundary = nothing,                        auxiliary</em>fields = NamedTuple())</p><p>Construct a model for a non-hydrostatic, incompressible fluid on <code>grid</code>, using the Boussinesq approximation when <code>buoyancy != nothing</code>. By default, all Bounded directions are rigid and impenetrable.</p><p><strong>Keyword arguments</strong></p><ul><li><code>grid</code>: (required) The resolution and discrete geometry on which the <code>model</code> is solved. The         architecture (CPU/GPU) that the model is solved on is inferred from the architecture         of the <code>grid</code>. Note that the grid needs to be regularly spaced in the horizontal         dimensions, <span>$x$</span> and <span>$y$</span>.</li><li><code>advection</code>: The scheme that advects velocities and tracers. See <code>Oceananigans.Advection</code>.</li><li><code>buoyancy</code>: The buoyancy model. See <code>Oceananigans.BuoyancyModels</code>.</li><li><code>coriolis</code>: Parameters for the background rotation rate of the model.</li><li><code>stokes_drift</code>: Parameters for Stokes drift fields associated with surface waves. Default: <code>nothing</code>.</li><li><code>forcing</code>: <code>NamedTuple</code> of user-defined forcing functions that contribute to solution tendencies.</li><li><code>closure</code>: The turbulence closure for <code>model</code>. See <code>Oceananigans.TurbulenceClosures</code>.</li><li><code>boundary_conditions</code>: <code>NamedTuple</code> containing field boundary conditions.</li><li><code>tracers</code>: A tuple of symbols defining the names of the modeled tracers, or a <code>NamedTuple</code> of            preallocated <code>CenterField</code>s.</li><li><code>timestepper</code>: A symbol that specifies the time-stepping method. Either <code>:QuasiAdamsBashforth2</code> or                <code>:RungeKutta3</code>.</li><li><code>background_fields</code>: <code>NamedTuple</code> with background fields (e.g., background flow). Default: <code>nothing</code>.</li><li><code>particles</code>: Lagrangian particles to be advected with the flow. Default: <code>nothing</code>.</li><li><code>biogeochemistry</code>: Biogeochemical model for <code>tracers</code>.</li><li><code>velocities</code>: The model velocities. Default: <code>nothing</code>.</li><li><code>pressures</code>: Hydrostatic and non-hydrostatic pressure fields. Default: <code>nothing</code>.</li><li><code>diffusivity_fields</code>: Diffusivity fields. Default: <code>nothing</code>.</li><li><code>pressure_solver</code>: Pressure solver to be used in the model. If <code>nothing</code> (default), the model constructor chooses the default based on the <code>grid</code> provide.</li><li><code>immersed_boundary</code>: The immersed boundary. Default: <code>nothing</code>.</li><li><code>auxiliary_fields</code>: <code>NamedTuple</code> of auxiliary fields. Default: <code>nothing</code>         </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L53-L106">source</a></section></article><h3 id="Hydrostatic-free-surface-models"><a class="docs-heading-anchor" href="#Hydrostatic-free-surface-models">Hydrostatic free-surface models</a><a id="Hydrostatic-free-surface-models-1"></a><a class="docs-heading-anchor-permalink" href="#Hydrostatic-free-surface-models" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Models.HydrostaticFreeSurfaceModels.ExplicitFreeSurface" href="#Oceananigans.Models.HydrostaticFreeSurfaceModels.ExplicitFreeSurface"><code>Oceananigans.Models.HydrostaticFreeSurfaceModels.ExplicitFreeSurface</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ExplicitFreeSurface{E, T}</code></pre><p>The explicit free surface solver.</p><ul><li><p><code>η::Any</code>: free surface elevation</p></li><li><p><code>gravitational_acceleration::Any</code>: gravitational accelerations</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Models/HydrostaticFreeSurfaceModels/explicit_free_surface.jl#L7-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Models.HydrostaticFreeSurfaceModels.HydrostaticFreeSurfaceModel-Tuple{}" href="#Oceananigans.Models.HydrostaticFreeSurfaceModels.HydrostaticFreeSurfaceModel-Tuple{}"><code>Oceananigans.Models.HydrostaticFreeSurfaceModels.HydrostaticFreeSurfaceModel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HydrostaticFreeSurfaceModel(; grid,
                                         clock = Clock{eltype(grid)}(0, 0, 1),
                            momentum_advection = CenteredSecondOrder(),
                              tracer_advection = CenteredSecondOrder(),
                                      buoyancy = SeawaterBuoyancy(eltype(grid)),
                                      coriolis = nothing,
                                  free_surface = ImplicitFreeSurface(gravitational_acceleration=g_Earth),
                           forcing::NamedTuple = NamedTuple(),
                                       closure = nothing,
               boundary_conditions::NamedTuple = NamedTuple(),
                                       tracers = (:T, :S),
                 particles::ParticlesOrNothing = nothing,
         biogeochemistry::AbstractBGCOrNothing = nothing,
                                    velocities = nothing,
                                      pressure = nothing,
                            diffusivity_fields = nothing,
                              auxiliary_fields = NamedTuple(),
        calculate_only_active_cells_tendencies = false
)</code></pre><p>Construct a hydrostatic model with a free surface on <code>grid</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>grid</code>: (required) The resolution and discrete geometry on which <code>model</code> is solved. The architecture (CPU/GPU) that the model is solve is inferred from the architecture of the grid.</li><li><code>momentum_advection</code>: The scheme that advects velocities. See <code>Oceananigans.Advection</code>.</li><li><code>tracer_advection</code>: The scheme that advects tracers. See <code>Oceananigans.Advection</code>.</li><li><code>buoyancy</code>: The buoyancy model. See <code>Oceananigans.BuoyancyModels</code>.</li><li><code>coriolis</code>: Parameters for the background rotation rate of the model.</li><li><code>forcing</code>: <code>NamedTuple</code> of user-defined forcing functions that contribute to solution tendencies.</li><li><code>free_surface</code>: The free surface model.</li><li><code>closure</code>: The turbulence closure for <code>model</code>. See <code>Oceananigans.TurbulenceClosures</code>.</li><li><code>boundary_conditions</code>: <code>NamedTuple</code> containing field boundary conditions.</li><li><code>tracers</code>: A tuple of symbols defining the names of the modeled tracers, or a <code>NamedTuple</code> of            preallocated <code>CenterField</code>s.</li><li><code>particles</code>: Lagrangian particles to be advected with the flow. Default: <code>nothing</code>.</li><li><code>biogeochemistry</code>: Biogeochemical model for <code>tracers</code>.</li><li><code>velocities</code>: The model velocities. Default: <code>nothing</code>.</li><li><code>pressure</code>: Hydrostatic pressure field. Default: <code>nothing</code>.</li><li><code>diffusivity_fields</code>: Diffusivity fields. Default: <code>nothing</code>.</li><li><code>auxiliary_fields</code>: <code>NamedTuple</code> of auxiliary fields. Default: <code>nothing</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl#L58-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Models.HydrostaticFreeSurfaceModels.ImplicitFreeSurface-Tuple{}" href="#Oceananigans.Models.HydrostaticFreeSurfaceModels.ImplicitFreeSurface-Tuple{}"><code>Oceananigans.Models.HydrostaticFreeSurfaceModels.ImplicitFreeSurface</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ImplicitFreeSurface(; solver_method=:Default, gravitational_acceleration=g_Earth, solver_settings...)</code></pre><p>Return an implicit free-surface solver. The implicit free-surface equation is</p><p class="math-container">\[\left [ 𝛁_h ⋅ (H 𝛁_h) - \frac{1}{g Δt^2} \right ] η^{n+1} = \frac{𝛁_h ⋅ 𝐐_⋆}{g Δt} - \frac{η^{n}}{g Δt^2} ,\]</p><p>where <span>$η^n$</span> is the free-surface elevation at the <span>$n$</span>-th time step, <span>$H$</span> is depth, <span>$g$</span> is the gravitational acceleration, <span>$Δt$</span> is the time step, <span>$𝛁_h$</span> is the horizontal gradient operator, and <span>$𝐐_⋆$</span> is the barotropic volume flux associated with the predictor velocity field <span>$𝐮_⋆$</span>, i.e., </p><p class="math-container">\[𝐐_⋆ = \int_{-H}^0 𝐮_⋆ \, 𝖽 z ,\]</p><p>where </p><p class="math-container">\[𝐮_⋆ = 𝐮^n + \int_{t_n}^{t_{n+1}} 𝐆ᵤ \, 𝖽t .\]</p><p>This equation can be solved, in general, using the <a href="#Oceananigans.Solvers.PreconditionedConjugateGradientSolver-Tuple{Any}"><code>PreconditionedConjugateGradientSolver</code></a> but  other solvers can be invoked in special cases.</p><p>If <span>$H$</span> is constant, we divide through out to obtain</p><p class="math-container">\[\left ( ∇^2_h - \frac{1}{g H Δt^2} \right ) η^{n+1}  = \frac{1}{g H Δt} \left ( 𝛁_h ⋅ 𝐐_⋆ - \frac{η^{n}}{Δt} \right ) .\]</p><p>Thus, for constant <span>$H$</span> and on grids with regular spacing in <span>$x$</span> and <span>$y$</span> directions, the free surface can be obtained using the <a href="#Oceananigans.Solvers.FFTBasedPoissonSolver"><code>FFTBasedPoissonSolver</code></a>.</p><p><code>solver_method</code> can be either of:</p><ul><li><code>:FastFourierTransform</code> for <a href="#Oceananigans.Solvers.FFTBasedPoissonSolver"><code>FFTBasedPoissonSolver</code></a></li><li><code>:HeptadiagonalIterativeSolver</code>  for <a href="#Oceananigans.Solvers.HeptadiagonalIterativeSolver-Tuple{Any}"><code>HeptadiagonalIterativeSolver</code></a></li><li><code>:PreconditionedConjugateGradient</code> for <a href="#Oceananigans.Solvers.PreconditionedConjugateGradientSolver-Tuple{Any}"><code>PreconditionedConjugateGradientSolver</code></a></li></ul><p>By default, if the grid has regular spacing in the horizontal directions then the <code>:FastFourierTransform</code> is chosen, otherwise the <code>:HeptadiagonalIterativeSolver</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl#L34-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Models.HydrostaticFreeSurfaceModels.PrescribedVelocityFields-Tuple{}" href="#Oceananigans.Models.HydrostaticFreeSurfaceModels.PrescribedVelocityFields-Tuple{}"><code>Oceananigans.Models.HydrostaticFreeSurfaceModels.PrescribedVelocityFields</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PrescribedVelocityFields(; u=zerofunc, v=zerofunc, w=zerofunc, parameters=nothing)</code></pre><p>Builds <code>PrescribedVelocityFields</code> with prescribed functions <code>u</code>, <code>v</code>, and <code>w</code>.</p><p>If <code>isnothing(parameters)</code>, then <code>u, v, w</code> are called with the signature</p><pre><code class="nohighlight hljs">u(x, y, z, t) = # something interesting</code></pre><p>If <code>!isnothing(parameters)</code>, then <code>u, v, w</code> are called with the signature</p><pre><code class="nohighlight hljs">u(x, y, z, t, parameters) = # something parameterized and interesting</code></pre><p>In the constructor for <code>HydrostaticFreeSurfaceModel</code>, the functions <code>u, v, w</code> are wrapped in <code>FunctionField</code> and associated with the model&#39;s <code>grid</code> and <code>clock</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Models/HydrostaticFreeSurfaceModels/prescribed_hydrostatic_velocity_fields.jl#L27-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurface" href="#Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurface"><code>Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurface</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SplitExplicitFreeSurface(; gravitational_acceleration = g_Earth, kwargs...)</code></pre><p>Return a <code>SplitExplicitFreeSurface</code> representing an explicit time discretization of oceanic free surface dynamics with <code>gravitational_acceleration</code>.</p><p><strong>Keyword Arguments</strong></p><ul><li><p><code>substeps</code>: The number of substeps that divide the range <code>(t, t + 2Δt)</code>, where <code>Δt</code> is the baroclinic             timestep. Note that some averaging functions do not require substepping until <code>2Δt</code>.             The number of substeps is reduced automatically to the last index of <code>averaging_weights</code>             for which <code>averaging_weights &gt; 0</code>.</p></li><li><p><code>cfl</code>: If set then the number of <code>substeps</code> are computed based on the advective timescale imposed from the        barotropic gravity-wave speed, computed with depth <code>grid.Lz</code>. If <code>fixed_Δt</code> is provided then the number of        <code>substeps</code> will adapt to maintain an exact cfl. If not the effective cfl will be always lower than the         specified <code>cfl</code> provided that the baroclinic time step <code>Δt_baroclinic &lt; fixed_Δt</code></p></li></ul><div class="admonition is-info"><header class="admonition-header">Needed keyword arguments</header><div class="admonition-body"><p>Either <code>substeps</code> <em>or</em> <code>cfl</code> (with <code>grid</code>) need to be prescribed.</p></div></div><ul><li><p><code>grid</code>: Used to compute the corresponding barotropic surface wave speed.</p></li><li><p><code>fixed_Δt</code>: The maximum baroclinic timestep allowed. If <code>fixed_Δt</code> is a <code>nothing</code> and a cfl is provided, then             the number of substeps will be computed on the fly from the baroclinic time step to maintain a constant cfl.</p></li><li><p><code>gravitational_acceleration</code>: the gravitational acceleration (default: <code>g_Earth</code>)</p></li><li><p><code>averaging_kernel</code>: function of <code>τ</code> used to average the barotropic transport <code>U</code> and free surface <code>η</code>                     within the barotropic advancement. <code>τ</code> is the fractional substep going from 0 to 2                     with the baroclinic time step <code>t + Δt</code> located at <code>τ = 1</code>. This function should be                     centered at <code>τ = 1</code>, that is, <span>$∑ (aₘ m /M) = 1$</span>. By default the averaging kernel                     described by Shchepetkin and McWilliams (2005): https://doi.org/10.1016/j.ocemod.2004.08.002                     is chosen.</p></li><li><p><code>timestepper</code>: Time stepping scheme used for the barotropic advancement. Choose one of:</p><ul><li><code>ForwardBackwardScheme()</code> (default): <code>η = f(U)</code>   then <code>U = f(η)</code>,</li><li><code>AdamsBashforth3Scheme()</code>: <code>η = f(U, Uᵐ⁻¹, Uᵐ⁻²)</code> then <code>U = f(η, ηᵐ, ηᵐ⁻¹, ηᵐ⁻²)</code>.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl#L34-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurface" href="#Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurface"><code>Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurface</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SplitExplicitFreeSurface</code></pre><p>The split-explicit free surface solver.</p><ul><li><p><code>η</code>: The instantaneous free surface (<code>ReducedField</code>)</p></li><li><p><code>state</code>: The entire state for the split-explicit solver (<code>SplitExplicitState</code>)</p></li><li><p><code>auxiliary</code>: Parameters for timestepping split-explicit solver (<code>NamedTuple</code>)</p></li><li><p><code>gravitational_acceleration</code>: Gravitational acceleration</p></li><li><p><code>settings</code>: Settings for the split-explicit scheme (<code>NamedTuple</code>)</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl#L14-L20">source</a></section></article><h3 id="Shallow-water-models"><a class="docs-heading-anchor" href="#Shallow-water-models">Shallow-water models</a><a id="Shallow-water-models-1"></a><a class="docs-heading-anchor-permalink" href="#Shallow-water-models" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Models.ShallowWaterModels.ShallowWaterModel-Tuple{}" href="#Oceananigans.Models.ShallowWaterModels.ShallowWaterModel-Tuple{}"><code>Oceananigans.Models.ShallowWaterModels.ShallowWaterModel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ShallowWaterModel(; grid,
                    gravitational_acceleration,
                          clock = Clock{eltype(grid)}(0, 0, 1),
             momentum_advection = UpwindBiasedFifthOrder(),
               tracer_advection = WENO(),
                 mass_advection = WENO(),
                       coriolis = nothing,
            forcing::NamedTuple = NamedTuple(),
                        closure = nothing,
                     bathymetry = nothing,
                        tracers = (),
             diffusivity_fields = nothing,
boundary_conditions::NamedTuple = NamedTuple(),
            timestepper::Symbol = :RungeKutta3,
                    formulation = ConservativeFormulation())</code></pre><p>Construct a shallow water model on <code>grid</code> with <code>gravitational_acceleration</code> constant.</p><p><strong>Keyword arguments</strong></p><ul><li><code>grid</code>: (required) The resolution and discrete geometry on which <code>model</code> is solved. The         architecture (CPU/GPU) that the model is solve is inferred from the architecture         of the grid.</li><li><code>gravitational_acceleration</code>: (required) The gravitational acceleration constant.</li><li><code>clock</code>: The <code>clock</code> for the model.</li><li><code>momentum_advection</code>: The scheme that advects velocities. See <code>Oceananigans.Advection</code>. Default: <code>UpwindBiasedFifthOrder()</code>.</li><li><code>tracer_advection</code>: The scheme that advects tracers. See <code>Oceananigans.Advection</code>. Default: <code>WENO()</code>.</li><li><code>mass_advection</code>: The scheme that advects the mass equation. See <code>Oceananigans.Advection</code>. Default: <code>WENO()</code>.</li><li><code>coriolis</code>: Parameters for the background rotation rate of the model.</li><li><code>forcing</code>: <code>NamedTuple</code> of user-defined forcing functions that contribute to solution tendencies.</li><li><code>closure</code>: The turbulence closure for <code>model</code>. See <code>Oceananigans.TurbulenceClosures</code>.</li><li><code>bathymetry</code>: The bottom bathymetry.</li><li><code>tracers</code>: A tuple of symbols defining the names of the modeled tracers, or a <code>NamedTuple</code> of            preallocated <code>CenterField</code>s.</li><li><code>diffusivity_fields</code>: Stores diffusivity fields when the closures require a diffusivity to be                       calculated at each timestep.</li><li><code>boundary_conditions</code>: <code>NamedTuple</code> containing field boundary conditions.</li><li><code>timestepper</code>: A symbol that specifies the time-stepping method. Either <code>:QuasiAdamsBashforth2</code> or                <code>:RungeKutta3</code> (default).</li><li><code>formulation</code>: Whether the dynamics are expressed in conservative form (<code>ConservativeFormulation()</code>;                default) or in non-conservative form with a vector-invariant formulation for the                non-linear terms (<code>VectorInvariantFormulation()</code>).</li></ul><div class="admonition is-warning"><header class="admonition-header">Formulation-grid compatibility requirements</header><div class="admonition-body"><p>The <code>ConservativeFormulation()</code> requires <code>RectilinearGrid</code>. Use <code>VectorInvariantFormulation()</code> with <code>LatitudeLongitudeGrid</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Models/ShallowWaterModels/shallow_water_model.jl#L62-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Models.ShallowWaterModels.ShallowWaterScalarDiffusivity" href="#Oceananigans.Models.ShallowWaterModels.ShallowWaterScalarDiffusivity"><code>Oceananigans.Models.ShallowWaterModels.ShallowWaterScalarDiffusivity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ShallowWaterScalarDiffusivity([FT::DataType=Float64;]
                              ν=0, ξ=0, discrete_form=false)</code></pre><p>Return a scalar diffusivity for the shallow water model.</p><p>The diffusivity for the shallow water model is calculated as <code>h * ν</code> so that we get a viscous term in the form <span>$h^{-1} 𝛁 ⋅ (h ν t)$</span>, where <span>$t$</span> is the 2D stress tensor plus a trace, i.e., <span>$t = 𝛁𝐮 + (𝛁𝐮)^T - ξ I ⋅ (𝛁 ⋅ 𝐮)$</span>.</p><p>With the <code>VectorInvariantFormulation()</code> (that evolves <span>$u$</span> and <span>$v$</span>) we compute <span>$h^{-1} 𝛁(ν h 𝛁 t)$</span>, while with the <code>ConservativeFormulation()</code> (that evolves <span>$u h$</span> and <span>$v h$</span>) we compute <span>$𝛁 (ν h 𝛁 t)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Models/ShallowWaterModels/shallow_water_diffusion_operators.jl#L28-L41">source</a></section></article><h3 id="Lagrangian-particle-tracking"><a class="docs-heading-anchor" href="#Lagrangian-particle-tracking">Lagrangian particle tracking</a><a id="Lagrangian-particle-tracking-1"></a><a class="docs-heading-anchor-permalink" href="#Lagrangian-particle-tracking" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Models.LagrangianParticleTracking.LagrangianParticles-Tuple{StructArrays.StructArray}" href="#Oceananigans.Models.LagrangianParticleTracking.LagrangianParticles-Tuple{StructArrays.StructArray}"><code>Oceananigans.Models.LagrangianParticleTracking.LagrangianParticles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LagrangianParticles(particles::StructArray; restitution=1.0, tracked_fields::NamedTuple=NamedTuple(), dynamics=no_dynamics)</code></pre><p>Construct some <code>LagrangianParticles</code> that can be passed to a model. The <code>particles</code> should be a <code>StructArray</code> and can contain custom fields. The coefficient of restitution for particle-wall collisions is specified by <code>restitution</code>.</p><p>A number of <code>tracked_fields</code> may be passed in as a <code>NamedTuple</code> of fields. Each particle will track the value of each field. Each tracked field must have a corresponding particle property. So if <code>T</code> is a tracked field, then <code>T</code> must also be a custom particle property.</p><p><code>dynamics</code> is a function of <code>(lagrangian_particles, model, Δt)</code> that is called prior to advecting particles. <code>parameters</code> can be accessed inside the <code>dynamics</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl#L69-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Models.LagrangianParticleTracking.LagrangianParticles-Tuple{}" href="#Oceananigans.Models.LagrangianParticleTracking.LagrangianParticles-Tuple{}"><code>Oceananigans.Models.LagrangianParticleTracking.LagrangianParticles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LagrangianParticles(; x, y, z, restitution=1.0, dynamics=no_dynamics, parameters=nothing)</code></pre><p>Construct some <code>LagrangianParticles</code> that can be passed to a model. The particles will have initial locations <code>x</code>, <code>y</code>, and <code>z</code>. The coefficient of restitution for particle-wall collisions is specified by <code>restitution</code>.</p><p><code>dynamics</code> is a function of <code>(lagrangian_particles, model, Δt)</code> that is called prior to advecting particles. <code>parameters</code> can be accessed inside the <code>dynamics</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl#L48-L56">source</a></section></article><h2 id="MultiRegion"><a class="docs-heading-anchor" href="#MultiRegion">MultiRegion</a><a id="MultiRegion-1"></a><a class="docs-heading-anchor-permalink" href="#MultiRegion" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.MultiRegion.MultiRegionGrid-Tuple{Any}" href="#Oceananigans.MultiRegion.MultiRegionGrid-Tuple{Any}"><code>Oceananigans.MultiRegion.MultiRegionGrid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MultiRegionGrid(global_grid; partition = XPartition(2), devices = nothing)</code></pre><p>Split a <code>global_grid</code> into different regions handled by <code>devices</code>.</p><p><strong>Positional Arguments</strong></p><ul><li><code>global_grid</code>: the grid to be divided into regions</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>partition</code>: the partitioning required. The implemented partitioning are <code>XPartition</code>               (division along the x direction) and <code>YPartition</code> (division along the y direction)</li><li><code>devices</code>: the devices to allocate memory on. <code>nothing</code> will allocate memory on the <code>CPU</code>. For             <code>GPU</code> computation it is possible to specify the total number of <code>GPU</code>s or the specific            <code>GPU</code>s to allocate memory on. The number of devices does not have to match the number of            regions </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/MultiRegion/multi_region_grid.jl#L31-L50">source</a></section></article><h2 id="Operators"><a class="docs-heading-anchor" href="#Operators">Operators</a><a id="Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Operators" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Operators.divᶜᶜᶜ-NTuple{7, Any}" href="#Oceananigans.Operators.divᶜᶜᶜ-NTuple{7, Any}"><code>Oceananigans.Operators.divᶜᶜᶜ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">divᶜᶜᶜ(i, j, k, grid, u, v, w)</code></pre><p>Calculate the divergence <span>$𝛁·𝐕$</span> of a vector field <span>$𝐕 = (u, v, w)$</span>,</p><pre><code class="language-julia hljs">1/V * [δxᶜᵃᵃ(Ax * u) + δxᵃᶜᵃ(Ay * v) + δzᵃᵃᶜ(Az * w)]</code></pre><p>which ends up at the cell centers <code>ccc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Operators/divergence_operators.jl#L5-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Operators.ζ₃ᶠᶠᶜ-NTuple{6, Any}" href="#Oceananigans.Operators.ζ₃ᶠᶠᶜ-NTuple{6, Any}"><code>Oceananigans.Operators.ζ₃ᶠᶠᶜ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ζ₃ᶠᶠᶜ(i, j, k, grid, u, v)</code></pre><p>The vertical vorticity associated with horizontal velocities <span>$u$</span> and <span>$v$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Operators/vorticity_operators.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Operators.∇²ᶜᶜᶜ-NTuple{5, Any}" href="#Oceananigans.Operators.∇²ᶜᶜᶜ-NTuple{5, Any}"><code>Oceananigans.Operators.∇²ᶜᶜᶜ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∇²ᶜᶜᶜ(i, j, k, grid, c)</code></pre><p>Calculate the Laplacian of <span>$c$</span> via</p><pre><code class="language-julia hljs">1/V * [δxᶜᵃᵃ(Ax * ∂xᶠᵃᵃ(c)) + δyᵃᶜᵃ(Ay * ∂yᵃᶠᵃ(c)) + δzᵃᵃᶜ(Az * ∂zᵃᵃᶠ(c))]</code></pre><p>which ends up at the location <code>ccc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Operators/laplacian_operators.jl#L25-L35">source</a></section></article><h2 id="Output-readers"><a class="docs-heading-anchor" href="#Output-readers">Output readers</a><a id="Output-readers-1"></a><a class="docs-heading-anchor-permalink" href="#Output-readers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputReaders.FieldDataset-Tuple{Any}" href="#Oceananigans.OutputReaders.FieldDataset-Tuple{Any}"><code>Oceananigans.OutputReaders.FieldDataset</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FieldDataset(filepath;
             architecture=CPU(), grid=nothing, backend=InMemory(), metadata_paths=[&quot;metadata&quot;])</code></pre><p>Returns a <code>Dict</code> containing a <code>FieldTimeSeries</code> for each field in the JLD2 file located at <code>filepath</code>. Note that model output <strong>must</strong> have been saved with halos.</p><p><strong>Keyword arguments</strong></p><ul><li><code>backend</code>: Either <code>InMemory()</code> (default) or <code>OnDisk()</code>. The <code>InMemory</code> backend will</li></ul><p>load the data fully in memory as a 4D multi-dimensional array while the <code>OnDisk()</code> backend will lazily load field time snapshots when the <code>FieldTimeSeries</code> is indexed linearly.</p><ul><li><p><code>metadata_paths</code>: A list of JLD2 paths to look for metadata. By default it looks in <code>file[&quot;metadata&quot;]</code>.</p></li><li><p><code>grid</code>: May be specified to override the grid used in the JLD2 file.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/OutputReaders/field_dataset.jl#L7-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputReaders.FieldTimeSeries-Tuple{Any, Any}" href="#Oceananigans.OutputReaders.FieldTimeSeries-Tuple{Any, Any}"><code>Oceananigans.OutputReaders.FieldTimeSeries</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FieldTimeSeries(path, name;
                backend = InMemory(),
                grid = nothing,
                iterations = nothing,
                times = nothing)</code></pre><p>Return a <code>FieldTimeSeries</code> containing a time-series of the field <code>name</code> load from JLD2 output located at <code>path</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>backend</code>: <code>InMemory()</code> to load data into a 4D array or <code>OnDisk()</code> to lazily load data from disk            when indexing into <code>FieldTimeSeries</code>.</p></li><li><p><code>grid</code>: A grid to associated with data, in the case that the native grid was not serialized         properly.</p></li><li><p><code>iterations</code>: Iterations to load. Defaults to all iterations found in the file.</p></li><li><p><code>times</code>: Save times to load, as determined through an approximate floating point          comparison to recorded save times. Defaults to times associated with <code>iterations</code>.          Takes precedence over <code>iterations</code> if <code>times</code> is specified.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/OutputReaders/field_time_series.jl#L68-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputReaders.FieldTimeSeries-Union{Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Any, Any}, Tuple{Any, Any, Any}} where {LX, LY, LZ}" href="#Oceananigans.OutputReaders.FieldTimeSeries-Union{Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Any, Any}, Tuple{Any, Any, Any}} where {LX, LY, LZ}"><code>Oceananigans.OutputReaders.FieldTimeSeries</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FieldTimeSeries{LX, LY, LZ}(grid, times, [FT=eltype(grid);]
                            indices = (:, :, :),
                            boundary_conditions = nothing)</code></pre><p>Return a <code>FieldTimeSeries</code> at location <code>(LX, LY, LZ)</code>, on <code>grid</code>, at <code>times</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/OutputReaders/field_time_series.jl#L47-L53">source</a></section></article><h2 id="Output-writers"><a class="docs-heading-anchor" href="#Output-writers">Output writers</a><a id="Output-writers-1"></a><a class="docs-heading-anchor-permalink" href="#Output-writers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.AveragedTimeInterval" href="#Oceananigans.OutputWriters.AveragedTimeInterval"><code>Oceananigans.OutputWriters.AveragedTimeInterval</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct AveragedTimeInterval &lt;: AbstractSchedule</code></pre><p>Container for parameters that configure and handle time-averaged output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/OutputWriters/windowed_time_average.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.AveragedTimeInterval-Tuple{Any}" href="#Oceananigans.OutputWriters.AveragedTimeInterval-Tuple{Any}"><code>Oceananigans.OutputWriters.AveragedTimeInterval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AveragedTimeInterval(interval; window=interval, stride=1)</code></pre><p>Returns a <code>schedule</code> that specifies periodic time-averaging of output. The time <code>window</code> specifies the extent of the time-average, which reoccurs every <code>interval</code>.</p><p><code>output</code> is computed and accumulated into the average every <code>stride</code> iterations during the averaging window. For example, <code>stride=1</code> computs output every iteration, whereas <code>stride=2</code> computes output every other iteration. Time-averages with longer <code>stride</code>s are faster to compute, but less accurate.</p><p>The time-average of <span>$a$</span> is a left Riemann sum corresponding to</p><p class="math-container">\[⟨a⟩ = T⁻¹ \int_{tᵢ-T}^{tᵢ} a \mathrm{d} t \, ,\]</p><p>where <span>$⟨a⟩$</span> is the time-average of <span>$a$</span>, <span>$T$</span> is the time-window for averaging, and the <span>$tᵢ$</span> are discrete times separated by the time <code>interval</code>. The <span>$tᵢ$</span> specify both the end of the averaging window and the time at which output is written.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Oceananigans.OutputWriters: AveragedTimeInterval
using Oceananigans.Utils: days

schedule = AveragedTimeInterval(4days, window=2days)

# output
AveragedTimeInterval(window=2 days, stride=1, interval=4 days)</code></pre><p>An <code>AveragedTimeInterval</code> schedule directs an output writer to time-average its outputs before writing them to disk:</p><pre><code class="language-julia hljs">using Oceananigans
using Oceananigans.OutputWriters: JLD2OutputWriter
using Oceananigans.Utils: minutes

model = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)))

simulation = Simulation(model, Δt=10minutes, stop_time=30days)

simulation.output_writers[:velocities] = JLD2OutputWriter(model, model.velocities,
                                                          filename= &quot;averaged_velocity_data.jld2&quot;,
                                                          schedule = AveragedTimeInterval(4days, window=2days, stride=2))

# output
JLD2OutputWriter scheduled on TimeInterval(4 days):
├── filepath: ./averaged_velocity_data.jld2
├── 3 outputs: (u, v, w) averaged on AveragedTimeInterval(window=2 days, stride=2, interval=4 days)
├── array type: Array{Float64}
├── including: [:grid, :coriolis, :buoyancy, :closure]
└── max filesize: Inf YiB</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/OutputWriters/windowed_time_average.jl#L24-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.Checkpointer-Tuple{Any}" href="#Oceananigans.OutputWriters.Checkpointer-Tuple{Any}"><code>Oceananigans.OutputWriters.Checkpointer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Checkpointer(model; schedule,
             dir = &quot;.&quot;,
             prefix = &quot;checkpoint&quot;,
             overwrite_existing = false,
             verbose = false,
             cleanup = false,
             properties = [:architecture, :grid, :clock, :coriolis,
                           :buoyancy, :closure, :timestepper, :particles])</code></pre><p>Construct a <code>Checkpointer</code> that checkpoints the model to a JLD2 file on <code>schedule.</code> The <code>model.clock.iteration</code> is included in the filename to distinguish between multiple checkpoint files.</p><p>To restart or &quot;pickup&quot; a model from a checkpoint, specify <code>pickup = true</code> when calling <code>run!</code>, ensuring that the checkpoint file is in directory <code>dir</code>. See <a href="#Oceananigans.Simulations.run!-Tuple{Any}"><code>run!</code></a> for more details.</p><p>Note that extra model <code>properties</code> can be safely specified, but removing crucial properties such as <code>:velocities</code> will make restoring from the checkpoint impossible.</p><p>The checkpointer attempts to serialize as much of the model to disk as possible, but functions or objects containing functions cannot be serialized at this time.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>schedule</code> (required): Schedule that determines when to checkpoint.</p></li><li><p><code>dir</code>: Directory to save output to. Default: <code>&quot;.&quot;</code> (current working directory).</p></li><li><p><code>prefix</code>: Descriptive filename prefixed to all output files. Default: &quot;checkpoint&quot;.</p></li><li><p><code>overwrite_existing</code>: Remove existing files if their filenames conflict. Default: <code>false</code>.</p></li><li><p><code>verbose</code>: Log what the output writer is doing with statistics on compute/write times            and file sizes. Default: <code>false</code>.</p></li><li><p><code>cleanup</code>: Previous checkpoint files will be deleted once a new checkpoint file is written.            Default: <code>false</code>.</p></li><li><p><code>properties</code>: List of model properties to checkpoint. This list must contain               <code>[:grid, :architecture, :timestepper, :particles]</code>.               Default: [:architecture, :grid, :clock, :coriolis, :buoyancy, :closure,                         :velocities, :tracers, :timestepper, :particles]</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/OutputWriters/checkpointer.jl#L20-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.JLD2OutputWriter-Tuple{Any, Any}" href="#Oceananigans.OutputWriters.JLD2OutputWriter-Tuple{Any, Any}"><code>Oceananigans.OutputWriters.JLD2OutputWriter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">JLD2OutputWriter(model, outputs; filename, schedule,
                          dir = &quot;.&quot;,
                      indices = (:, :, :),
                   with_halos = false,
                   array_type = Array{Float64},
                 max_filesize = Inf,
           overwrite_existing = false,
                         init = noinit,
                    including = [:grid, :coriolis, :buoyancy, :closure],
                      verbose = false,
                         part = 1,
                      jld2_kw = Dict{Symbol, Any}())</code></pre><p>Construct a <code>JLD2OutputWriter</code> for an Oceananigans <code>model</code> that writes <code>label, output</code> pairs in <code>outputs</code> to a JLD2 file.</p><p>The argument <code>outputs</code> may be a <code>Dict</code> or <code>NamedTuple</code>. The keys of <code>outputs</code> are symbols or strings that &quot;name&quot; output data. The values of <code>outputs</code> are either <code>AbstractField</code>s, objects that are called with the signature <code>output(model)</code>, or <code>WindowedTimeAverage</code>s of <code>AbstractFields</code>s, functions, or callable objects.</p><p><strong>Keyword arguments</strong></p><p><strong>Filenaming</strong></p><ul><li><p><code>filename</code> (required): Descriptive filename. <code>&quot;.jld2&quot;</code> is appended to <code>filename</code> in the file path                       if <code>filename</code> does not end in <code>&quot;.jld2&quot;</code>.</p></li><li><p><code>dir</code>: Directory to save output to. Default: <code>&quot;.&quot;</code> (current working directory).</p></li></ul><p><strong>Output frequency and time-averaging</strong></p><ul><li><code>schedule</code> (required): <code>AbstractSchedule</code> that determines when output is saved.</li></ul><p><strong>Slicing and type conversion prior to output</strong></p><ul><li><p><code>indices</code>: Specifies the indices to write to disk with a <code>Tuple</code> of <code>Colon</code>, <code>UnitRange</code>,            or <code>Int</code> elements. Indices must be <code>Colon</code>, <code>Int</code>, or contiguous <code>UnitRange</code>.            Defaults to <code>(:, :, :)</code> or &quot;all indices&quot;. If <code>!with_halos</code>,            halo regions are removed from <code>indices</code>. For example, <code>indices = (:, :, 1)</code>            will save xy-slices of the bottom-most index.</p></li><li><p><code>with_halos</code> (Bool): Whether or not to slice halo regions from fields before writing output.                      Note, that to postprocess saved output (e.g., compute derivatives, etc)                      information about the boundary conditions is often crucial. In that case                      you might need to set <code>with_halos = true</code>.</p></li><li><p><code>array_type</code>: The array type to which output arrays are converted to prior to saving.               Default: <code>Array{Float64}</code>.</p></li></ul><p><strong>File management</strong></p><ul><li><p><code>max_filesize</code>: The writer will stop writing to the output file once the file size exceeds <code>max_filesize</code>,                 and write to a new one with a consistent naming scheme ending in <code>part1</code>, <code>part2</code>, etc.                 Defaults to <code>Inf</code>.</p></li><li><p><code>overwrite_existing</code>: Remove existing files if their filenames conflict.                       Default: <code>false</code>.</p></li></ul><p><strong>Output file metadata management</strong></p><ul><li><p><code>init</code>: A function of the form <code>init(file, model)</code> that runs when a JLD2 output file is initialized.         Default: <code>noinit(args...) = nothing</code>.</p></li><li><p><code>including</code>: List of model properties to save with every file.              Default: <code>[:grid, :coriolis, :buoyancy, :closure]</code></p></li></ul><p><strong>Miscellaneous keywords</strong></p><ul><li><p><code>verbose</code>: Log what the output writer is doing with statistics on compute/write times and file sizes.            Default: <code>false</code>.</p></li><li><p><code>part</code>: The starting part number used if <code>max_filesize</code> is finite.         Default: 1.</p></li><li><p><code>jld2_kw</code>: Dict of kwargs to be passed to <code>jldopen</code> when data is written.</p></li></ul><p><strong>Example</strong></p><p>Write out 3D fields for <span>$u$</span>, <span>$v$</span>, <span>$w$</span>, and a tracer <span>$c$</span>, along with a horizontal average:</p><pre><code class="language-julia hljs">using Oceananigans
using Oceananigans.Utils: hour, minute

model = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)), tracers=(:c,))
simulation = Simulation(model, Δt=12, stop_time=1hour)

function init_save_some_metadata!(file, model)
    file[&quot;author&quot;] = &quot;Chim Riggles&quot;
    file[&quot;parameters/coriolis_parameter&quot;] = 1e-4
    file[&quot;parameters/density&quot;] = 1027
    return nothing
end

c_avg =  Field(Average(model.tracers.c, dims=(1, 2)))

# Note that model.velocities is NamedTuple
simulation.output_writers[:velocities] = JLD2OutputWriter(model, model.velocities,
                                                          filename = &quot;some_data.jld2&quot;,
                                                          schedule = TimeInterval(20minute),
                                                          init = init_save_some_metadata!)

# output
JLD2OutputWriter scheduled on TimeInterval(20 minutes):
├── filepath: ./some_data.jld2
├── 3 outputs: (u, v, w)
├── array type: Array{Float64}
├── including: [:grid, :coriolis, :buoyancy, :closure]
└── max filesize: Inf YiB</code></pre><p>and a time- and horizontal-average of tracer <span>$c$</span> every 20 minutes of simulation time to a file called <code>some_averaged_data.jld2</code></p><pre><code class="language-julia hljs">simulation.output_writers[:avg_c] = JLD2OutputWriter(model, (; c=c_avg),
                                                     filename = &quot;some_averaged_data.jld2&quot;,
                                                     schedule = AveragedTimeInterval(20minute, window=5minute))

# output
JLD2OutputWriter scheduled on TimeInterval(20 minutes):
├── filepath: ./some_averaged_data.jld2
├── 1 outputs: c averaged on AveragedTimeInterval(window=5 minutes, stride=1, interval=20 minutes)
├── array type: Array{Float64}
├── including: [:grid, :coriolis, :buoyancy, :closure]
└── max filesize: Inf YiB</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/OutputWriters/jld2_output_writer.jl#L29-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.NetCDFOutputWriter-Tuple{Any, Any}" href="#Oceananigans.OutputWriters.NetCDFOutputWriter-Tuple{Any, Any}"><code>Oceananigans.OutputWriters.NetCDFOutputWriter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NetCDFOutputWriter(model, outputs; filename, schedule
                                      dir = &quot;.&quot;,
                               array_type = Array{Float64},
                                  indices = nothing,
                               with_halos = false,
                        global_attributes = Dict(),
                        output_attributes = Dict(),
                               dimensions = Dict(),
                       overwrite_existing = false,
                             deflatelevel = 0,
                                  verbose = false)</code></pre><p>Construct a <code>NetCDFOutputWriter</code> that writes <code>(label, output)</code> pairs in <code>outputs</code> (which should be a <code>Dict</code>) to a NetCDF file, where <code>label</code> is a string that labels the output and <code>output</code> is either a <code>Field</code> (e.g. <code>model.velocities.u</code>) or a function <code>f(model)</code> that returns something to be written to disk. Custom output requires the spatial <code>dimensions</code> (a <code>Dict</code>) to be manually specified (see examples).</p><p><strong>Keyword arguments</strong></p><p><strong>Filenaming</strong></p><ul><li><p><code>filename</code> (required): Descriptive filename. <code>&quot;.nc&quot;</code> is appended to <code>filename</code> if <code>filename</code> does                        not end in <code>&quot;.nc&quot;</code>.</p></li><li><p><code>dir</code>: Directory to save output to.</p></li></ul><p><strong>Output frequency and time-averaging</strong></p><ul><li><code>schedule</code> (required): <code>AbstractSchedule</code> that determines when output is saved.</li></ul><p><strong>Slicing and type conversion prior to output</strong></p><ul><li><p><code>indices</code>: Tuple of indices of the output variables to include. Default is <code>(:, :, :)</code>, which            includes the full fields.</p></li><li><p><code>with_halos</code>: Boolean defining whether or not to include halos in the outputs. Default: <code>false</code>.               Note, that to postprocess saved output (e.g., compute derivatives, etc)               information about the boundary conditions is often crucial. In that case               you might need to set <code>with_halos = true</code>.</p></li><li><p><code>array_type</code>: The array type to which output arrays are converted to prior to saving.               Default: <code>Array{Float64}</code>.</p></li><li><p><code>dimensions</code>: A <code>Dict</code> of dimension tuples to apply to outputs (required for function outputs).</p></li></ul><p><strong>File management</strong></p><ul><li><p><code>overwrite_existing</code>: If <code>false</code>, <code>NetCDFOutputWriter</code> will be set to append to <code>filepath</code>. If <code>true</code>,                       <code>NetCDFOutputWriter</code> will overwrite <code>filepath</code> if it exists or create it if not.                       Default: <code>false</code>. See <a href="https://alexander-barth.github.io/NCDatasets.jl/stable/">NCDatasets.jl documentation</a>                       for more information about its <code>mode</code> option.</p></li><li><p><code>deflatelevel</code>: Determines the NetCDF compression level of data (integer 0-9; 0 (default) means no compression                 and 9 means maximum compression). See <a href="https://alexander-barth.github.io/NCDatasets.jl/stable/variables/#Creating-a-variable">NCDatasets.jl documentation</a>                 for more information.</p></li></ul><p><strong>Miscellaneous keywords</strong></p><ul><li><p><code>global_attributes</code>: Dict of model properties to save with every file. Default: <code>Dict()</code>.</p></li><li><p><code>output_attributes</code>: Dict of attributes to be saved with each field variable (reasonable                      defaults are provided for velocities, buoyancy, temperature, and salinity;                      otherwise <code>output_attributes</code> <em>must</em> be user-provided).</p></li></ul><p><strong>Examples</strong></p><p>Saving the <span>$u$</span> velocity field and temperature fields, the full 3D fields and surface 2D slices to separate NetCDF files:</p><pre><code class="language-julia hljs">using Oceananigans

grid = RectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1))

model = NonhydrostaticModel(grid=grid, tracers=:c)

simulation = Simulation(model, Δt=12, stop_time=3600)

fields = Dict(&quot;u&quot; =&gt; model.velocities.u, &quot;c&quot; =&gt; model.tracers.c)

simulation.output_writers[:field_writer] =
    NetCDFOutputWriter(model, fields, filename=&quot;fields.nc&quot;, schedule=TimeInterval(60))

# output
NetCDFOutputWriter scheduled on TimeInterval(1 minute):
├── filepath: ./fields.nc
├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0)
├── 2 outputs: (c, u)
└── array type: Array{Float64}</code></pre><pre><code class="language-julia hljs">simulation.output_writers[:surface_slice_writer] =
    NetCDFOutputWriter(model, fields, filename=&quot;surface_xy_slice.nc&quot;,
                       schedule=TimeInterval(60), indices=(:, :, grid.Nz))

# output
NetCDFOutputWriter scheduled on TimeInterval(1 minute):
├── filepath: ./surface_xy_slice.nc
├── dimensions: zC(1), zF(1), xC(16), yF(16), xF(16), yC(16), time(0)
├── 2 outputs: (c, u)
└── array type: Array{Float64}</code></pre><pre><code class="language-julia hljs">simulation.output_writers[:averaged_profile_writer] =
    NetCDFOutputWriter(model, fields,
                       filename = &quot;averaged_z_profile.nc&quot;,
                       schedule = AveragedTimeInterval(60, window=20),
                       indices = (1, 1, :))

# output
NetCDFOutputWriter scheduled on TimeInterval(1 minute):
├── filepath: ./averaged_z_profile.nc
├── dimensions: zC(16), zF(17), xC(1), yF(1), xF(1), yC(1), time(0)
├── 2 outputs: (c, u) averaged on AveragedTimeInterval(window=20 seconds, stride=1, interval=1 minute)
└── array type: Array{Float64}</code></pre><p><code>NetCDFOutputWriter</code> also accepts output functions that write scalars and arrays to disk, provided that their <code>dimensions</code> are provided:</p><pre><code class="language-julia hljs">using Oceananigans

Nx, Ny, Nz = 16, 16, 16

grid = RectilinearGrid(size=(Nx, Ny, Nz), extent=(1, 2, 3))

model = NonhydrostaticModel(grid=grid)

simulation = Simulation(model, Δt=1.25, stop_iteration=3)

f(model) = model.clock.time^2; # scalar output

g(model) = model.clock.time .* exp.(znodes(Center, grid)) # vector/profile output

xC, yF = xnodes(grid, Center()), ynodes(grid, Face())

XC = [xC[i] for i in 1:Nx, j in 1:Ny]
YF = [yF[j] for i in 1:Nx, j in 1:Ny]

h(model) = @. model.clock.time * sin(XC) * cos(YF) # xy slice output

outputs = Dict(&quot;scalar&quot; =&gt; f, &quot;profile&quot; =&gt; g, &quot;slice&quot; =&gt; h)

dims = Dict(&quot;scalar&quot; =&gt; (), &quot;profile&quot; =&gt; (&quot;zC&quot;,), &quot;slice&quot; =&gt; (&quot;xC&quot;, &quot;yC&quot;))

output_attributes = Dict(
    &quot;scalar&quot;  =&gt; Dict(&quot;longname&quot; =&gt; &quot;Some scalar&quot;, &quot;units&quot; =&gt; &quot;bananas&quot;),
    &quot;profile&quot; =&gt; Dict(&quot;longname&quot; =&gt; &quot;Some vertical profile&quot;, &quot;units&quot; =&gt; &quot;watermelons&quot;),
    &quot;slice&quot;   =&gt; Dict(&quot;longname&quot; =&gt; &quot;Some slice&quot;, &quot;units&quot; =&gt; &quot;mushrooms&quot;)
)

global_attributes = Dict(&quot;location&quot; =&gt; &quot;Bay of Fundy&quot;, &quot;onions&quot; =&gt; 7)

simulation.output_writers[:things] =
    NetCDFOutputWriter(model, outputs,
                       schedule=IterationInterval(1), filename=&quot;things.nc&quot;, dimensions=dims, verbose=true,
                       global_attributes=global_attributes, output_attributes=output_attributes)

# output
NetCDFOutputWriter scheduled on IterationInterval(1):
├── filepath: ./things.nc
├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0)
├── 3 outputs: (profile, slice, scalar)
└── array type: Array{Float64}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/OutputWriters/netcdf_output_writer.jl#L157-L329">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.OutputWriters.WindowedTimeAverage" href="#Oceananigans.OutputWriters.WindowedTimeAverage"><code>Oceananigans.OutputWriters.WindowedTimeAverage</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WindowedTimeAverage(operand, model=nothing; schedule)</code></pre><p>Returns an object for computing running averages of <code>operand</code> over <code>schedule.window</code> and recurring on <code>schedule.interval</code>, where <code>schedule</code> is an <code>AveragedTimeInterval</code>. During the collection period, averages are computed every <code>schedule.stride</code> iteration.</p><p><code>operand</code> may be a <code>Oceananigans.Field</code> or a function that returns an array or scalar.</p><p>Calling <code>wta(model)</code> for <code>wta::WindowedTimeAverage</code> object returns <code>wta.result</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/OutputWriters/windowed_time_average.jl#L164-L174">source</a></section></article><h2 id="Simulations"><a class="docs-heading-anchor" href="#Simulations">Simulations</a><a id="Simulations-1"></a><a class="docs-heading-anchor-permalink" href="#Simulations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Simulations.Callback" href="#Oceananigans.Simulations.Callback"><code>Oceananigans.Simulations.Callback</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Callback(func, schedule=IterationInterval(1); parameters=nothing)</code></pre><p>Return <code>Callback</code> that executes <code>func</code> on <code>schedule</code> with optional <code>parameters</code>. <code>schedule = IterationInterval(1)</code> by default.</p><p>If <code>isnothing(parameters)</code>, <code>func(sim::Simulation)</code> is called. Otherwise, <code>func</code> is called via <code>func(sim::Simulation, parameters)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Simulations/callback.jl#L23-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Simulations.Simulation-Tuple{Any}" href="#Oceananigans.Simulations.Simulation-Tuple{Any}"><code>Oceananigans.Simulations.Simulation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Simulation(model; Δt,
           verbose = true,
           stop_iteration = Inf,
           stop_time = Inf,
           wall_time_limit = Inf)</code></pre><p>Construct a <code>Simulation</code> for a <code>model</code> with time step <code>Δt</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>Δt</code>: Required keyword argument specifying the simulation time step. Can be a <code>Number</code>       for constant time steps or a <code>TimeStepWizard</code> for adaptive time-stepping.</p></li><li><p><code>stop_iteration</code>: Stop the simulation after this many iterations.</p></li><li><p><code>stop_time</code>: Stop the simulation once this much model clock time has passed.</p></li><li><p><code>wall_time_limit</code>: Stop the simulation if it&#39;s been running for longer than this many                    seconds of wall clock time.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Simulations/simulation.jl#L25-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Simulations.TimeStepWizard" href="#Oceananigans.Simulations.TimeStepWizard"><code>Oceananigans.Simulations.TimeStepWizard</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TimeStepWizard([FT=Float64;]
               cfl = 0.2,
               diffusive_cfl = Inf,
               max_change = 1.1,
               min_change = 0.5,
               max_Δt = Inf,
               min_Δt = 0.0,
               cell_advection_timescale = cell_advection_timescale,
               cell_diffusion_timescale = infinite_diffusion_timescale)</code></pre><p>Callback for adapting simulation to maintain the advective Courant-Freidrichs-Lewy (CFL) number to <code>cfl</code>, the <code>diffusive_cfl</code>, while also maintaining <code>max_Δt</code>, <code>min_Δt</code>, and satisfying <code>max_change</code> and <code>min_change</code> criteria so that the simulation&#39;s timestep <code>simulation.Δt</code> is not adapted &quot;too quickly&quot;.</p><p>For more information on the CFL number, see its <a href="https://en.wikipedia.org/wiki/Courant%E2%80%93Friedrichs%E2%80%93Lewy_condition">wikipedia entry</a>.</p><p><strong>Example</strong></p><p>To use <code>TimeStepWizard</code>, adapt in a <a href="#Oceananigans.Simulations.Callback"><code>Callback</code></a> and add it to a <code>Simulation</code>:</p><pre><code class="language-julia hljs">julia&gt; simulation = Simulation(model, Δt=0.9, stop_iteration=100)

julia&gt; wizard = TimeStepWizard(cfl=0.2)

julia&gt; simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(4))</code></pre><p>Then when <code>run!(simulation)</code> is invoked, the time-step <code>simulation.Δt</code> will be updated every 4 iterations.</p><p>(Note that the name <code>:wizard</code> is unimportant.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Simulations/time_step_wizard.jl#L22-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Simulations.erroring_NaNChecker!-Tuple{Any}" href="#Oceananigans.Simulations.erroring_NaNChecker!-Tuple{Any}"><code>Oceananigans.Simulations.erroring_NaNChecker!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">erroring_NaNChecker!(simulation)</code></pre><p>Toggles <code>simulation</code>&#39;s <code>NaNChecker</code> to throw an error when a <code>NaN</code> is detected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Simulations/nan_checker.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Simulations.iteration-Tuple{Simulation}" href="#Oceananigans.Simulations.iteration-Tuple{Simulation}"><code>Oceananigans.Simulations.iteration</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iteration(sim::Simulation)</code></pre><p>Return the current simulation iteration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Simulations/simulation.jl#L118-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Simulations.run!-Tuple{Any}" href="#Oceananigans.Simulations.run!-Tuple{Any}"><code>Oceananigans.Simulations.run!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">run!(simulation; pickup=false)</code></pre><p>Run a <code>simulation</code> until one of <code>simulation.stop_criteria</code> evaluates <code>true</code>. The simulation will then stop.</p><p><strong>Picking simulations up from a checkpoint</strong></p><p>Simulations are &quot;picked up&quot; from a checkpoint if <code>pickup</code> is either <code>true</code>, a <code>String</code>, or an <code>Integer</code> greater than 0.</p><p>Picking up a simulation sets field and tendency data to the specified checkpoint, leaving all other model properties unchanged.</p><p>Possible values for <code>pickup</code> are:</p><ul><li><p><code>pickup=true</code> picks a simulation up from the latest checkpoint associated with the <code>Checkpointer</code> in <code>simulation.output_writers</code>.</p></li><li><p><code>pickup=iteration::Int</code> picks a simulation up from the checkpointed file associated  with <code>iteration</code> and the <code>Checkpointer</code> in <code>simulation.output_writers</code>.</p></li><li><p><code>pickup=filepath::String</code> picks a simulation up from checkpointer data in <code>filepath</code>.</p></li></ul><p>Note that <code>pickup=true</code> and <code>pickup=iteration</code> fails if <code>simulation.output_writers</code> contains more than one checkpointer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Simulations/run.jl#L58-L84">source</a></section></article><h2 id="Solvers"><a class="docs-heading-anchor" href="#Solvers">Solvers</a><a id="Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Solvers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Solvers.BatchedTridiagonalSolver" href="#Oceananigans.Solvers.BatchedTridiagonalSolver"><code>Oceananigans.Solvers.BatchedTridiagonalSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BatchedTridiagonalSolver</code></pre><p>A batched solver for large numbers of triadiagonal systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Solvers/batched_tridiagonal_solver.jl#L6-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Solvers.BatchedTridiagonalSolver-Tuple{Any}" href="#Oceananigans.Solvers.BatchedTridiagonalSolver-Tuple{Any}"><code>Oceananigans.Solvers.BatchedTridiagonalSolver</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BatchedTridiagonalSolver(grid; lower_diagonal, diagonal, upper_diagonal, parameters=nothing, tridiagonal_direction=ZDirection())</code></pre><p>Construct a solver for batched tridiagonal systems on <code>grid</code> of the form</p><pre><code class="nohighlight hljs">                       bⁱʲ¹ ϕⁱʲ¹ + cⁱʲ¹ ϕⁱʲ²   = fⁱʲ¹,  k = 1
       aⁱʲᵏ⁻¹ ϕⁱʲᵏ⁻¹ + bⁱʲᵏ ϕⁱʲᵏ + cⁱʲᵏ ϕⁱʲᵏ⁺¹ = fⁱʲᵏ,  k = 2, ..., N-1
       aⁱʲᴺ⁻¹ ϕⁱʲᴺ⁻¹ + bⁱʲᴺ ϕⁱʲᴺ               = fⁱʲᴺ,  k = N</code></pre><p>where <code>a</code> is the <code>lower_diagonal</code>, <code>b</code> is the <code>diagonal</code>, and <code>c</code> is the <code>upper_diagonal</code>. <code>ϕ</code> is the solution and <code>f</code> is the right hand side source term passed to <code>solve!(ϕ, tridiagonal_solver, f)</code></p><p><code>a</code>, <code>b</code>, <code>c</code>, and <code>f</code> can be specified in three ways:</p><ol><li><p>A 1D array means that <code>aⁱʲᵏ = a[k]</code>.</p></li><li><p>A 3D array means that <code>aⁱʲᵏ = a[i, j, k]</code>.</p></li><li><p>Otherwise, <code>a</code> is assumed to be callable:</p><ul><li>If <code>isnothing(parameters)</code> then <code>aⁱʲᵏ = a(i, j, k, grid, args...)</code>.</li><li>If <code>!isnothing(parameters)</code> then <code>aⁱʲᵏ = a(i, j, k, grid, parameters, args...)</code>.</li></ul><p>where <code>args...</code> are <code>Varargs</code> passed to <code>solve_batched_tridiagonal_system!(ϕ, solver, args...)</code>.</p></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Solvers/batched_tridiagonal_solver.jl#L24-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Solvers.FFTBasedPoissonSolver" href="#Oceananigans.Solvers.FFTBasedPoissonSolver"><code>Oceananigans.Solvers.FFTBasedPoissonSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FFTBasedPoissonSolver(grid, planner_flag=FFTW.PATIENT)</code></pre><p>Return an <code>FFTBasedPoissonSolver</code> that solves the &quot;generalized&quot; Poisson equation,</p><p class="math-container">\[(∇² + m) ϕ = b,\]</p><p>where <span>$m$</span> is a number, using a eigenfunction expansion of the discrete Poisson operator on a staggered grid and for periodic or Neumann boundary conditions.</p><p>In-place transforms are applied to <span>$b$</span>, which means <span>$b$</span> must have complex-valued elements (typically the same type as <code>solver.storage</code>).</p><p>See <a href="#Oceananigans.Solvers.solve!"><code>solve!</code></a> for more information about the FFT-based Poisson solver algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Solvers/fft_based_poisson_solver.jl#L33-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Solvers.HeptadiagonalIterativeSolver-Tuple{Any}" href="#Oceananigans.Solvers.HeptadiagonalIterativeSolver-Tuple{Any}"><code>Oceananigans.Solvers.HeptadiagonalIterativeSolver</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HeptadiagonalIterativeSolver(coeffs;
                             grid,
                             iterative_solver = cg!,
                             maximum_iterations = prod(size(grid)),
                             tolerance = 1e-13,
                             reduced_dim = (false, false, false), 
                             placeholder_timestep = -1.0, 
                             preconditioner_method = :Default, 
                             preconditioner_settings = nothing,
                             template = arch_array(architecture(grid), zeros(prod(size(grid)))),
                             verbose = false)</code></pre><p>Return a <code>HeptadiagonalIterativeSolver</code> to solve the problem <code>A * x = b</code>, provided that <code>A</code> is a symmetric matrix.</p><p>The solver relies on a sparse version of the matrix <code>A</code> that is stored in <code>matrix_constructors</code>.</p><p>In particular, given coefficients <code>Ax</code>, <code>Ay</code>, <code>Az</code>, <code>C</code>, <code>D</code>, the solved problem is</p><pre><code class="language-julia hljs">    Axᵢ₊₁ ηᵢ₊₁ + Axᵢ ηᵢ₋₁ + Ayⱼ₊₁ ηⱼ₊₁ + Ayⱼ ηⱼ₋₁ + Azₖ₊₁ ηₖ₊₁ + Azₖ ηₖ₋₁ 
    - 2 ( Axᵢ₊₁ + Axᵢ + Ayⱼ₊₁ + Ayⱼ + Azₖ₊₁ + Azₖ ) ηᵢⱼₖ 
    +   ( Cᵢⱼₖ + Dᵢⱼₖ/Δt^2 ) ηᵢⱼₖ  = b</code></pre><p>To have the equation solved at location <code>{Center, Center, Center}</code>, the coefficients must be specified at:</p><ul><li><code>Ax</code> -&gt; <code>{Face,   Center, Center}</code></li><li><code>Ay</code> -&gt; <code>{Center, Face,   Center}</code></li><li><code>Az</code> -&gt; <code>{Center, Center, Face}</code></li><li><code>C</code>  -&gt; <code>{Center, Center, Center}</code></li><li><code>D</code>  -&gt; <code>{Center, Center, Center}</code></li></ul><p><code>solver.matrix</code> is precomputed with a placeholder timestep value of <code>placeholder_timestep = -1.0</code>.</p><p>The sparse matrix <code>A</code> can be constructed with:</p><ul><li><code>SparseMatrixCSC(constructors...)</code> for CPU</li><li><code>CuSparseMatrixCSC(constructors...)</code> for GPU</li></ul><p>The matrix constructors are calculated based on the pentadiagonal coeffients passed as an input to <code>matrix_from_coefficients</code> function.</p><p>To allow for variable time step, the diagonal term <code>- Az / (g * Δt²)</code> is only added later on and it is updated only when the previous time step changes (<code>previous_Δt != Δt</code>).</p><p>Preconditioning is done through the various methods implemented in <code>Solvers/sparse_preconditioners.jl</code>.</p><p>The <code>iterative_solver</code> used can is to be chosen from the IterativeSolvers.jl package.  The default solver is a Conjugate Gradient (<code>cg</code>):</p><pre><code class="language-julia hljs">solver = HeptadiagonalIterativeSolver((Ax, Ay, Az, C, D); grid)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Solvers/heptadiagonal_iterative_solver.jl#L29-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Solvers.PreconditionedConjugateGradientSolver-Tuple{Any}" href="#Oceananigans.Solvers.PreconditionedConjugateGradientSolver-Tuple{Any}"><code>Oceananigans.Solvers.PreconditionedConjugateGradientSolver</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PreconditionedConjugateGradientSolver(linear_operation;
                                      template_field,
                                      maxiter = size(template_field.grid),
                                      reltol = sqrt(eps(eltype(template_field.grid))),
                                      abstol = 0,
                                      preconditioner = nothing)</code></pre><p>Returns a <code>PreconditionedConjugateGradientSolver</code> that solves the linear equation <span>$A x = b$</span> using a iterative conjugate gradient method with optional preconditioning.</p><p>The solver is used by calling</p><pre><code class="nohighlight hljs">solve!(x, solver::PreconditionedConjugateGradientOperator, b, args...)</code></pre><p>for <code>solver</code>, right-hand side <code>b</code>, solution <code>x</code>, and optional arguments <code>args...</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>linear_operation</code>: Function with signature <code>linear_operation!(p, y, args...)</code> that calculates                     <code>A * y</code> and stores the result in <code>p</code> for a &quot;candidate solution&quot; <code>y</code>. <code>args...</code>                     are optional positional arguments passed from <code>solve!(x, solver, b, args...)</code>.</p></li><li><p><code>template_field</code>: Dummy field that is the same type and size as <code>x</code> and <code>b</code>, which                   is used to infer the <code>architecture</code>, <code>grid</code>, and to create work arrays                   that are used internally by the solver.</p></li><li><p><code>maxiter</code>: Maximum number of iterations the solver may perform before exiting.</p></li><li><p><code>reltol, abstol</code>: Relative and absolute tolerance for convergence of the algorithm.                   The iteration stops when <code>norm(A * x - b) &lt; tolerance</code>.</p></li><li><p><code>preconditioner</code>: Object for which <code>precondition!(z, preconditioner, r, args...)</code> computes <code>z = P * r</code>,                   where <code>r</code> is the residual. Typically <code>P</code> is approximately <code>A⁻¹</code>.</p></li></ul><p>See <a href="#Oceananigans.Solvers.solve!"><code>solve!</code></a> for more information about the preconditioned conjugate-gradient algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Solvers/preconditioned_conjugate_gradient_solver.jl#L33-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Solvers.solve!" href="#Oceananigans.Solvers.solve!"><code>Oceananigans.Solvers.solve!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">solve!(ϕ, solver::FFTBasedPoissonSolver, b, m=0)</code></pre><p>Solves the &quot;generalized&quot; Poisson equation,</p><p class="math-container">\[(∇² + m) ϕ = b,\]</p><p>where <span>$m$</span> is a number, using a eigenfunction expansion of the discrete Poisson operator on a staggered grid and for periodic or Neumann boundary conditions.</p><p>In-place transforms are applied to <span>$b$</span>, which means <span>$b$</span> must have complex-valued elements (typically the same type as <code>solver.storage</code>).</p><div class="admonition is-info"><header class="admonition-header">Alternative names for &#39;generalized&#39; Poisson equation</header><div class="admonition-body"><p>Equation <span>$(∇² + m) ϕ = b$</span> is sometimes referred to as the &quot;screened Poisson&quot; equation when <span>$m &lt; 0$</span>, or the Helmholtz equation when <span>$m &gt; 0$</span>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Solvers/fft_based_poisson_solver.jl#L74-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Solvers.solve!-Tuple{Any, Oceananigans.Solvers.BatchedTridiagonalSolver, Any, Vararg{Any}}" href="#Oceananigans.Solvers.solve!-Tuple{Any, Oceananigans.Solvers.BatchedTridiagonalSolver, Any, Vararg{Any}}"><code>Oceananigans.Solvers.solve!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve!(ϕ, solver::BatchedTridiagonalSolver, rhs, args...)</code></pre><p>Solve the batched tridiagonal system of linear equations with right hand side <code>rhs</code> and lower diagonal, diagonal, and upper diagonal coefficients described by the <code>BatchedTridiagonalSolver</code> <code>solver</code>. <code>BatchedTridiagonalSolver</code> uses a modified TriDiagonal Matrix Algorithm (TDMA).</p><p>The result is stored in <code>ϕ</code> which must have size <code>(grid.Nx, grid.Ny, grid.Nz)</code>.</p><p>Reference implementation per Numerical Recipes, Press et. al 1992 (§ 2.4).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Solvers/batched_tridiagonal_solver.jl#L60-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Solvers.solve!-Tuple{Any, Oceananigans.Solvers.PreconditionedConjugateGradientSolver, Any, Vararg{Any}}" href="#Oceananigans.Solvers.solve!-Tuple{Any, Oceananigans.Solvers.PreconditionedConjugateGradientSolver, Any, Vararg{Any}}"><code>Oceananigans.Solvers.solve!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve!(x, solver::PreconditionedConjugateGradientSolver, b, args...)</code></pre><p>Solve <code>A * x = b</code> using an iterative conjugate-gradient method, where <code>A * x</code> is determined by <code>solver.linear_operation</code></p><p>See figure 2.5 in</p><blockquote><p>The Preconditioned Conjugate Gradient Method in &quot;Templates for the Solution of Linear Systems: Building Blocks for Iterative Methods&quot; Barrett et. al, 2nd Edition.</p></blockquote><p>Given:</p><ul><li>Linear Preconditioner operator <code>M!(solution, x, other_args...)</code> that computes <code>M * x = solution</code></li><li>A matrix operator <code>A</code> as a function <code>A()</code>;</li><li>A dot product function <code>norm()</code>;</li><li>A right-hand side <code>b</code>;</li><li>An initial guess <code>x</code>; and</li><li>Local vectors: <code>z</code>, <code>r</code>, <code>p</code>, <code>q</code></li></ul><p>This function executes the psuedocode algorithm</p><pre><code class="nohighlight hljs">β  = 0
r = b - A(x)
iteration  = 0

Loop:
     if iteration &gt; maxiter
        break
     end

     ρ = r ⋅ z

     z = M(r)
     β = ρⁱ⁻¹ / ρ
     p = z + β * p
     q = A(p)

     α = ρ / (p ⋅ q)
     x = x + α * p
     r = r - α * q

     if |r| &lt; tolerance
        break
     end

     iteration += 1
     ρⁱ⁻¹ = ρ</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Solvers/preconditioned_conjugate_gradient_solver.jl#L108-L156">source</a></section></article><h2 id="Stokes-drift"><a class="docs-heading-anchor" href="#Stokes-drift">Stokes drift</a><a id="Stokes-drift-1"></a><a class="docs-heading-anchor-permalink" href="#Stokes-drift" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.StokesDrift.UniformStokesDrift" href="#Oceananigans.StokesDrift.UniformStokesDrift"><code>Oceananigans.StokesDrift.UniformStokesDrift</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UniformStokesDrift{P, UZ, VZ, UT, VT} &lt;: AbstractStokesDrift</code></pre><p>Parameter struct for Stokes drift fields associated with surface waves.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/StokesDrift.jl#L41-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.StokesDrift.UniformStokesDrift-Tuple{}" href="#Oceananigans.StokesDrift.UniformStokesDrift-Tuple{}"><code>Oceananigans.StokesDrift.UniformStokesDrift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">UniformStokesDrift(; ∂z_uˢ=addzero, ∂z_vˢ=addzero, ∂t_uˢ=addzero, ∂t_vˢ=addzero, parameters=nothing)</code></pre><p>Construct a set of functions that describes the Stokes drift field beneath a horizontally-uniform surface gravity wave field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/StokesDrift.jl#L56-L61">source</a></section></article><h2 id="Time-steppers"><a class="docs-heading-anchor" href="#Time-steppers">Time steppers</a><a id="Time-steppers-1"></a><a class="docs-heading-anchor-permalink" href="#Time-steppers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TimeSteppers.Clock" href="#Oceananigans.TimeSteppers.Clock"><code>Oceananigans.TimeSteppers.Clock</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Clock{T&lt;:Number}</code></pre><p>Keeps track of the current <code>time</code>, <code>iteration</code> number, and time-stepping <code>stage</code>. The <code>stage</code> is updated only for multi-stage time-stepping methods. The <code>time::T</code> is either a number or a <code>DateTime</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/TimeSteppers/clock.jl#L7-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TimeSteppers.Clock-Union{Tuple{}, Tuple{T}} where T" href="#Oceananigans.TimeSteppers.Clock-Union{Tuple{}, Tuple{T}} where T"><code>Oceananigans.TimeSteppers.Clock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Clock(; time, iteration=0, stage=1)</code></pre><p>Returns a <code>Clock</code> object. By default, <code>Clock</code> is initialized to the zeroth <code>iteration</code> and first time step <code>stage</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/TimeSteppers/clock.jl#L20-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper-Union{Tuple{IT}, Tuple{Any, Any}, Tuple{Any, Any, Any}} where IT" href="#Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper-Union{Tuple{IT}, Tuple{Any, Any}, Tuple{Any, Any, Any}} where IT"><code>Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">QuasiAdamsBashforth2TimeStepper(grid, tracers,
                                χ = 0.1;
                                implicit_solver = nothing,
                                Gⁿ = TendencyFields(grid, tracers),
                                G⁻ = TendencyFields(grid, tracers))</code></pre><p>Return a 2nd-order quasi Adams-Bashforth (AB2) time stepper (<code>QuasiAdamsBashforth2TimeStepper</code>) on <code>grid</code>, with <code>tracers</code>, and AB2 parameter <code>χ</code>. The tendency fields <code>Gⁿ</code> and <code>G⁻</code> can be specified via  optional <code>kwargs</code>.</p><p>The 2nd-order quasi Adams-Bashforth timestepper steps forward the state <code>Uⁿ</code> by <code>Δt</code> via</p><pre><code class="language-julia hljs">Uⁿ⁺¹ = Uⁿ + Δt * [(3/2 + χ) * Gⁿ - (1/2 + χ) * Gⁿ⁻¹]</code></pre><p>where <code>Uⁿ</code> is the state at the <span>$n$</span>-th timestep, <code>Gⁿ</code> is the tendency at the <span>$n$</span>-th timestep, and <code>Gⁿ⁻¹</code> is the tendency at the previous timestep (<code>G⁻</code>).</p><div class="admonition is-info"><header class="admonition-header">First timestep</header><div class="admonition-body"><p>For the first timestep, since there are no saved tendencies from the previous timestep, the <code>QuasiAdamsBashforth2TimeStepper</code> performs an Euler timestep:</p><pre><code class="language-julia hljs">Uⁿ⁺¹ = Uⁿ + Δt * Gⁿ</code></pre></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/TimeSteppers/quasi_adams_bashforth_2.jl#L13-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TimeSteppers.RungeKutta3TimeStepper" href="#Oceananigans.TimeSteppers.RungeKutta3TimeStepper"><code>Oceananigans.TimeSteppers.RungeKutta3TimeStepper</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RungeKutta3TimeStepper{FT, TG} &lt;: AbstractTimeStepper</code></pre><p>Holds parameters and tendency fields for a low storage, third-order Runge-Kutta-Wray time-stepping scheme described by Le and Moin (1991).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/TimeSteppers/runge_kutta_3.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TimeSteppers.RungeKutta3TimeStepper-Union{Tuple{TG}, Tuple{TI}, Tuple{Any, Any}} where {TI, TG}" href="#Oceananigans.TimeSteppers.RungeKutta3TimeStepper-Union{Tuple{TG}, Tuple{TI}, Tuple{Any, Any}} where {TI, TG}"><code>Oceananigans.TimeSteppers.RungeKutta3TimeStepper</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RungeKutta3TimeStepper(grid, tracers;
                       implicit_solver = nothing,
                       Gⁿ = TendencyFields(grid, tracers),
                       G⁻ = TendencyFields(grid, tracers))</code></pre><p>Return a 3rd-order Runge0Kutta timestepper (<code>RungeKutta3TimeStepper</code>) on <code>grid</code> and with <code>tracers</code>. The tendency fields <code>Gⁿ</code> and <code>G⁻</code> can be specified via  optional <code>kwargs</code>.</p><p>The scheme described by Le and Moin (1991) (see <a href="../../references/#LeMoin1991">H. Le, P. Moin (1991)</a>). In a nutshel, the 3rd-order Runge Kutta timestepper steps forward the state <code>Uⁿ</code> by <code>Δt</code> via 3 substeps. A pressure correction step is applied after at each substep.</p><p>The state <code>U</code> after each substep <code>m</code> is</p><pre><code class="language-julia hljs">Uᵐ⁺¹ = Uᵐ + Δt * (γᵐ * Gᵐ + ζᵐ * Gᵐ⁻¹)</code></pre><p>where <code>Uᵐ</code> is the state at the <span>$m$</span>-th substep, <code>Gᵐ</code> is the tendency at the <span>$m$</span>-th substep, <code>Gᵐ⁻¹</code> is the tendency at the previous substep, and constants <span>$γ¹ = 8/15$</span>, <span>$γ² = 5/12$</span>, <span>$γ³ = 3/4$</span>, <span>$ζ¹ = 0$</span>, <span>$ζ² = -17/60$</span>, <span>$ζ³ = -5/12$</span>.</p><p>The state at the first substep is taken to be the one that corresponds to the <span>$n$</span>-th timestep, <code>U¹ = Uⁿ</code>, and the state after the third substep is then the state at the <code>Uⁿ⁺¹ = U⁴</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/TimeSteppers/runge_kutta_3.jl#L21-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TimeSteppers.time_step!-Tuple{Oceananigans.AbstractModel{&lt;:QuasiAdamsBashforth2TimeStepper}, Any}" href="#Oceananigans.TimeSteppers.time_step!-Tuple{Oceananigans.AbstractModel{&lt;:QuasiAdamsBashforth2TimeStepper}, Any}"><code>Oceananigans.TimeSteppers.time_step!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">time_step!(model::AbstractModel{&lt;:QuasiAdamsBashforth2TimeStepper}, Δt; euler=false)</code></pre><p>Step forward <code>model</code> one time step <code>Δt</code> with a 2nd-order Adams-Bashforth method and pressure-correction substep. Setting <code>euler=true</code> will take a forward Euler time step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/TimeSteppers/quasi_adams_bashforth_2.jl#L63-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TimeSteppers.time_step!-Tuple{Oceananigans.AbstractModel{&lt;:RungeKutta3TimeStepper}, Any}" href="#Oceananigans.TimeSteppers.time_step!-Tuple{Oceananigans.AbstractModel{&lt;:RungeKutta3TimeStepper}, Any}"><code>Oceananigans.TimeSteppers.time_step!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">time_step!(model::AbstractModel{&lt;:RungeKutta3TimeStepper}, Δt)</code></pre><p>Step forward <code>model</code> one time step <code>Δt</code> with a 3rd-order Runge-Kutta method. The 3rd-order Runge-Kutta method takes three intermediate substep stages to achieve a single timestep. A pressure correction step is applied at each intermediate stage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/TimeSteppers/runge_kutta_3.jl#L73-L80">source</a></section></article><h2 id="Turbulence-closures"><a class="docs-heading-anchor" href="#Turbulence-closures">Turbulence closures</a><a id="Turbulence-closures-1"></a><a class="docs-heading-anchor-permalink" href="#Turbulence-closures" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation" href="#Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation"><code>Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AnisotropicMinimumDissipation{FT} &lt;: AbstractTurbulenceClosure</code></pre><p>Parameters for the &quot;anisotropic minimum dissipation&quot; turbulence closure for large eddy simulation proposed originally by <a href="../../references/#Rozema15">Wybe Rozema, Hyun J. Bae, Parviz Moin, Roel Verstappen (2015)</a> and <a href="../../references/#Abkar16">Mahdi Abkar, Hyun J. Bae, Parviz Moin (2016)</a>, then modified by <a href="../../references/#Verstappen18">Roel Verstappen (2018)</a>, and finally described and validated for by <a href="../../references/#Vreugdenhil18">Catherine A. Vreugdenhil, John R. Taylor (2018)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation-Union{Tuple{}, Tuple{TD}, Tuple{TD, Any}} where TD" href="#Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation-Union{Tuple{}, Tuple{TD}, Tuple{TD, Any}} where TD"><code>Oceananigans.TurbulenceClosures.AnisotropicMinimumDissipation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AnisotropicMinimumDissipation([time_discretization = ExplicitTimeDiscretization, FT = Float64;]
                              C = 1/12, Cν = nothing, Cκ = nothing, Cb = nothing)</code></pre><p>Return parameters of type <code>FT</code> for the <code>AnisotropicMinimumDissipation</code> turbulence closure.</p><p><strong>Arguments</strong></p><ul><li><p><code>time_discretization</code>: Either <code>ExplicitTimeDiscretization()</code> or <code>VerticallyImplicitTimeDiscretization()</code>,                         which integrates the terms involving only <span>$z$</span>-derivatives in the                        viscous and diffusive fluxes with an implicit time discretization.                        Default <code>ExplicitTimeDiscretization()</code>.</p></li><li><p><code>FT</code>: Float type; default <code>Float64</code>.</p></li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>C</code>: Poincaré constant for both eddy viscosity and eddy diffusivities. <code>C</code> is overridden      for eddy viscosity or eddy diffusivity if <code>Cν</code> or <code>Cκ</code> are set, respecitvely.</p></li><li><p><code>Cν</code>: Poincaré constant for momentum eddy viscosity.</p></li><li><p><code>Cκ</code>: Poincaré constant for tracer eddy diffusivities. If one number or function, the same       number or function is applied to all tracers. If a <code>NamedTuple</code>, it must possess       a field specifying the Poncaré constant for every tracer.</p></li><li><p><code>Cb</code>: Buoyancy modification multiplier (<code>Cb = nothing</code> turns it off, <code>Cb = 1</code> was used by <a href="../../references/#Abkar16">Mahdi Abkar, Hyun J. Bae, Parviz Moin (2016)</a>).       <em>Note</em>: that we <em>do not</em> subtract the horizontally-average component before computing this       buoyancy modification term. This implementation differs from <a href="../../references/#Abkar16">Mahdi Abkar, Hyun J. Bae, Parviz Moin (2016)</a>&#39;s proposal       and the impact of this approximation has not been tested or validated.</p></li></ul><p>By default: <code>C = Cν = Cκ = 1/12</code>, which is appropriate for a finite-volume method employing a second-order advection scheme, and <code>Cb = nothing</code>, which turns off the buoyancy modification term.</p><p><code>Cν</code> or <code>Cκ</code> may be numbers, or functions of <code>x, y, z</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; pretty_diffusive_closure = AnisotropicMinimumDissipation(C=1/2)
AnisotropicMinimumDissipation{ExplicitTimeDiscretization} turbulence closure with:
           Poincaré constant for momentum eddy viscosity Cν: 0.5
    Poincaré constant for tracer(s) eddy diffusivit(ies) Cκ: 0.5
                        Buoyancy modification multiplier Cb: nothing</code></pre><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; const Δz = 0.5; # grid resolution at surface

julia&gt; surface_enhanced_tracer_C(x, y, z) = 1/12 * (1 + exp((z + Δz/2) / 8Δz));

julia&gt; fancy_closure = AnisotropicMinimumDissipation(Cκ=surface_enhanced_tracer_C)
AnisotropicMinimumDissipation{ExplicitTimeDiscretization} turbulence closure with:
           Poincaré constant for momentum eddy viscosity Cν: 0.08333333333333333
    Poincaré constant for tracer(s) eddy diffusivit(ies) Cκ: surface_enhanced_tracer_C
                        Buoyancy modification multiplier Cb: nothing</code></pre><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; tracer_specific_closure = AnisotropicMinimumDissipation(Cκ=(c₁=1/12, c₂=1/6))
AnisotropicMinimumDissipation{ExplicitTimeDiscretization} turbulence closure with:
           Poincaré constant for momentum eddy viscosity Cν: 0.08333333333333333
    Poincaré constant for tracer(s) eddy diffusivit(ies) Cκ: (c₁ = 0.08333333333333333, c₂ = 0.16666666666666666)
                        Buoyancy modification multiplier Cb: nothing</code></pre><p><strong>References</strong></p><p>Vreugdenhil C., and Taylor J. (2018), &quot;Large-eddy simulations of stratified plane Couette     flow using the anisotropic minimum-dissipation model&quot;, Physics of Fluids 30, 085104.</p><p>Verstappen, R. (2018), &quot;How much eddy dissipation is needed to counterbalance the nonlinear     production of small, unresolved scales in a large-eddy simulation of turbulence?&quot;,     Computers &amp; Fluids 176, pp. 276-284.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L31-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.ConvectiveAdjustmentVerticalDiffusivity" href="#Oceananigans.TurbulenceClosures.ConvectiveAdjustmentVerticalDiffusivity"><code>Oceananigans.TurbulenceClosures.ConvectiveAdjustmentVerticalDiffusivity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConvectiveAdjustmentVerticalDiffusivity([time_discretization = VerticallyImplicitTimeDiscretization(), FT=Float64;]
                                        convective_κz = 0,
                                        convective_νz = 0,
                                        background_κz = 0,
                                        background_νz = 0)</code></pre><p>Return a convective adjustment vertical diffusivity closure that applies different values of diffusivity and/or viscosity depending whether the region is statically stable (positive or zero buoyancy gradient) or statically unstable (negative buoyancy gradient).</p><p><strong>Arguments</strong></p><ul><li><p><code>time_discretization</code>: Either <code>ExplicitTimeDiscretization()</code> or <code>VerticallyImplicitTimeDiscretization()</code>;                        default <code>VerticallyImplicitTimeDiscretization()</code>.</p></li><li><p><code>FT</code>: Float type; default <code>Float64</code>.</p></li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>convective_κz</code>: Vertical tracer diffusivity in regions with negative (unstable) buoyancy gradients. Either                  a single number, function, array, field, or tuple of diffusivities for each tracer.</p></li><li><p><code>background_κz</code>: Vertical tracer diffusivity in regions with zero or positive (stable) buoyancy gradients.</p></li><li><p><code>convective_νz</code>: Vertical viscosity in regions with negative (unstable) buoyancy gradients. Either                 a number, function, array, or field.</p></li><li><p><code>background_κz</code>: Vertical viscosity in regions with zero or positive (stable) buoyancy gradients.</p></li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; cavd = ConvectiveAdjustmentVerticalDiffusivity(convective_κz = 1)
ConvectiveAdjustmentVerticalDiffusivity{VerticallyImplicitTimeDiscretization}(background_κz=0.0 convective_κz=1 background_νz=0.0 convective_νz=0.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/TurbulenceClosures/turbulence_closure_implementations/convective_adjustment_vertical_diffusivity.jl#L21-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization" href="#Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization"><code>Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ExplicitTimeDiscretization &lt;: AbstractTimeDiscretization</code></pre><p>A fully-explicit time-discretization of a <code>TurbulenceClosure</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/TurbulenceClosures/implicit_explicit_time_discretization.jl#L6-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.HorizontalDivergenceScalarDiffusivity" href="#Oceananigans.TurbulenceClosures.HorizontalDivergenceScalarDiffusivity"><code>Oceananigans.TurbulenceClosures.HorizontalDivergenceScalarDiffusivity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HorizontalDivergenceScalarDiffusivity([time_discretization=ExplicitTimeDiscretization(),
                                      FT::DataType=Float64;]
                                      kwargs...)</code></pre><p>Shorthand for a <code>ScalarDiffusivity</code> with <code>HorizontalDivergenceFormulation()</code>. See <a href="#Oceananigans.TurbulenceClosures.ScalarDiffusivity"><code>ScalarDiffusivity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L149-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.HorizontalScalarDiffusivity" href="#Oceananigans.TurbulenceClosures.HorizontalScalarDiffusivity"><code>Oceananigans.TurbulenceClosures.HorizontalScalarDiffusivity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HorizontalScalarDiffusivity([time_discretization=ExplicitTimeDiscretization(),
                            FT::DataType=Float64;]
                            kwargs...)</code></pre><p>Shorthand for a <code>ScalarDiffusivity</code> with <code>HorizontalFormulation()</code>. See <a href="#Oceananigans.TurbulenceClosures.ScalarDiffusivity"><code>ScalarDiffusivity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L139-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.IsopycnalSkewSymmetricDiffusivity-Union{Tuple{}, Tuple{TD}, Tuple{TD, Any}} where TD" href="#Oceananigans.TurbulenceClosures.IsopycnalSkewSymmetricDiffusivity-Union{Tuple{}, Tuple{TD}, Tuple{TD, Any}} where TD"><code>Oceananigans.TurbulenceClosures.IsopycnalSkewSymmetricDiffusivity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">IsopycnalSkewSymmetricDiffusivity([time_disc=VerticallyImplicitTimeDiscretization(), FT=Float64;]
                                  κ_skew = 0,
                                  κ_symmetric = 0,
                                  isopycnal_tensor = SmallSlopeIsopycnalTensor(),
                                  slope_limiter = FluxTapering(1e-2))</code></pre><p>Return parameters for an isopycnal skew-symmetric tracer diffusivity with skew diffusivity <code>κ_skew</code> and symmetric diffusivity <code>κ_symmetric</code> that uses an <code>isopycnal_tensor</code> model for for calculating the isopycnal slopes, and (optionally) applying a <code>slope_limiter</code> to the calculated isopycnal slope values.</p><p>Both <code>κ_skew</code> and <code>κ_symmetric</code> may be constants, arrays, fields, or functions of <code>(x, y, z, t)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/TurbulenceClosures/turbulence_closure_implementations/isopycnal_skew_symmetric_diffusivity.jl#L21-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.RiBasedVerticalDiffusivity" href="#Oceananigans.TurbulenceClosures.RiBasedVerticalDiffusivity"><code>Oceananigans.TurbulenceClosures.RiBasedVerticalDiffusivity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RiBasedVerticalDiffusivity([time_discretization = VerticallyImplicitTimeDiscretization(),
                           FT = Float64;]
                           Ri_dependent_tapering = HyperbolicTangentRiDependentTapering(),
                           ν₀  = 0.7,
                           κ₀  = 0.5,
                           κᶜᵃ = 1.7,
                           Cᵉⁿ = 0.1,
                           Cᵃᵛ = 0.6,
                           Ri₀ = 0.1,
                           Riᵟ = 0.4,
                           warning = true)</code></pre><p>Return a closure that estimates the vertical viscosity and diffusivity from &quot;convective adjustment&quot; coefficients <code>ν₀</code> and <code>κ₀</code> multiplied by a decreasing function of the Richardson number, <span>$Ri$</span>. </p><p><strong>Arguments</strong></p><ul><li><p><code>time_discretization</code>: Either <code>ExplicitTimeDiscretization()</code> or <code>VerticallyImplicitTimeDiscretization()</code>,                         which integrates the terms involving only <span>$z$</span>-derivatives in the                        viscous and diffusive fluxes with an implicit time discretization.                        Default <code>VerticallyImplicitTimeDiscretization()</code>.</p></li><li><p><code>FT</code>: Float type; default <code>Float64</code>.</p></li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>Ri_dependent_tapering</code>: The <span>$Ri$</span>-dependent tapering. Options are: <code>PiecewiseLinearRiDependentTapering()</code>, <code>HyperbolicTangentRiDependentTapering()</code> (default), and <code>ExponentialRiDependentTapering()</code>.</p></li><li><p><code>ν₀</code>: Non-convective viscosity.</p></li><li><p><code>κ₀</code>: Non-convective diffusivity for tracers.</p></li><li><p><code>κᶜᵃ</code>: Convective adjustment diffusivity for tracers.</p></li><li><p><code>Cᵉⁿ</code>: Entrainment coefficient for tracers.</p></li><li><p><code>Cᵃᵛ</code>: Time-averaging coefficient for viscosity and diffusivity.</p></li><li><p><code>Ri₀</code>: <span>$Ri$</span> threshold for decreasing viscosity and diffusivity.</p></li><li><p><code>Riᵟ</code>: <span>$Ri$</span>-width over which viscosity and diffusivity decreases to 0.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/TurbulenceClosures/turbulence_closure_implementations/ri_based_vertical_diffusivity.jl#L39-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.ScalarBiharmonicDiffusivity" href="#Oceananigans.TurbulenceClosures.ScalarBiharmonicDiffusivity"><code>Oceananigans.TurbulenceClosures.ScalarBiharmonicDiffusivity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ScalarBiharmonicDiffusivity(formulation = ThreeDimensionalFormulation(), FT = Float64;
                            ν = 0,
                            κ = 0,
                            discrete_form = false,
                            loc = (nothing, nothing, nothing),
                            parameters = nothing)</code></pre><p>Return a scalar biharmonic diffusivity turbulence closure with viscosity coefficient <code>ν</code> and tracer diffusivities <code>κ</code> for each tracer field in <code>tracers</code>. If a single <code>κ</code> is provided, it is applied to all tracers. Otherwise <code>κ</code> must be a <code>NamedTuple</code> with values for every tracer individually.</p><p><strong>Arguments</strong></p><ul><li><p><code>formulation</code>:</p><ul><li><code>HorizontalFormulation()</code> for diffusivity applied in the horizontal direction(s)</li><li><code>VerticalFormulation()</code> for diffusivity applied in the vertical direction,</li><li><code>ThreeDimensionalFormulation()</code> (default) for diffusivity applied isotropically to all directions</li></ul></li><li><p><code>FT</code>: the float datatype (default: <code>Float64</code>)</p></li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>ν</code>: Viscosity. <code>Number</code>, <code>AbstractArray</code>, <code>Field</code>, or <code>Function</code>.</p></li><li><p><code>κ</code>: Diffusivity. <code>Number</code>, three-dimensional <code>AbstractArray</code>, <code>Field</code>, <code>Function</code>, or      <code>NamedTuple</code> of diffusivities with entries for each tracer.</p></li><li><p><code>discrete_form</code>: <code>Boolean</code>; default: <code>False</code>.</p></li></ul><p>When prescribing the viscosities or diffusivities as functions, depending on the value of keyword argument <code>discrete_form</code>, the constructor expects:</p><ul><li><p><code>discrete_form = false</code> (default): functions of the grid&#39;s native coordinates and time, e.g., <code>(x, y, z, t)</code> for                                    a <code>RectilinearGrid</code> or <code>(λ, φ, z, t)</code> for a <code>LatitudeLongitudeGrid</code>.</p></li><li><p><code>discrete_form = true</code>: </p><ul><li>with <code>loc = (nothing, nothing, nothing)</code> (default): functions of <code>(i, j, k, grid, ℓx, ℓy, ℓz)</code> with <code>ℓx</code>, <code>ℓy</code> and <code>ℓz</code>                                                     either <code>Face()</code> or <code>Center()</code>.</li><li>with <code>loc = (ℓx, ℓy, ℓz)</code> with <code>ℓx</code>, <code>ℓy</code> and <code>ℓz</code> either <code>Face()</code> or <code>Center()</code>: functions of <code>(i, j, k, grid)</code>.</li></ul></li><li><p><code>parameters</code>: <code>NamedTuple</code> with parameters used by the functions that compute viscosity and/or diffusivity; default: <code>nothing</code>.</p></li></ul><p>For examples see <a href="#Oceananigans.TurbulenceClosures.ScalarDiffusivity"><code>ScalarDiffusivity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/TurbulenceClosures/turbulence_closure_implementations/scalar_biharmonic_diffusivity.jl#L25-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.ScalarBiharmonicDiffusivity" href="#Oceananigans.TurbulenceClosures.ScalarBiharmonicDiffusivity"><code>Oceananigans.TurbulenceClosures.ScalarBiharmonicDiffusivity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ScalarBiharmonicDiffusivity{F, N, K} &lt;: AbstractScalarBiharmonicDiffusivity{F}</code></pre><p>Holds viscosity and diffusivities for models with prescribed isotropic diffusivities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/TurbulenceClosures/turbulence_closure_implementations/scalar_biharmonic_diffusivity.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.ScalarDiffusivity" href="#Oceananigans.TurbulenceClosures.ScalarDiffusivity"><code>Oceananigans.TurbulenceClosures.ScalarDiffusivity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ScalarDiffusivity(time_discretization = ExplicitTimeDiscretization(),
                  formulation = ThreeDimensionalFormulation(), FT = Float64;
                  ν = 0,
                  κ = 0,
                  discrete_form = false,
                  loc = (nothing, nothing, nothing),
                  parameters = nothing)</code></pre><p>Return <code>ScalarDiffusivity</code> turbulence closure with viscosity <code>ν</code> and tracer diffusivities <code>κ</code> for each tracer field in <code>tracers</code>. If a single <code>κ</code> is provided, it is applied to all tracers. Otherwise <code>κ</code> must be a <code>NamedTuple</code> with values for every tracer individually.</p><p><strong>Arguments</strong></p><ul><li><p><code>time_discretization</code>: either <code>ExplicitTimeDiscretization()</code> (default) or <code>VerticallyImplicitTimeDiscretization()</code>.</p></li><li><p><code>formulation</code>:</p><ul><li><code>HorizontalFormulation()</code> for diffusivity applied in the horizontal direction(s)</li><li><code>VerticalFormulation()</code> for diffusivity applied in the vertical direction,</li><li><code>ThreeDimensionalFormulation()</code> (default) for diffusivity applied isotropically to all directions</li></ul></li><li><p><code>FT</code>: the float datatype (default: <code>Float64</code>)</p></li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>ν</code>: Viscosity. <code>Number</code>, three-dimensional <code>AbstractArray</code>, <code>Field</code>, or <code>Function</code>.</p></li><li><p><code>κ</code>: Diffusivity. <code>Number</code>, <code>AbstractArray</code>, <code>Field</code>, <code>Function</code>, or      <code>NamedTuple</code> of diffusivities with entries for each tracer.</p></li><li><p><code>discrete_form</code>: <code>Boolean</code>; default: <code>False</code>.</p></li></ul><p>When prescribing the viscosities or diffusivities as functions, depending on the value of keyword argument <code>discrete_form</code>, the constructor expects:</p><ul><li><p><code>discrete_form = false</code> (default): functions of the grid&#39;s native coordinates and time, e.g., <code>(x, y, z, t)</code> for a <code>RectilinearGrid</code> or <code>(λ, φ, z, t)</code> for a <code>LatitudeLongitudeGrid</code>.</p></li><li><p><code>discrete_form = true</code>: </p><ul><li>with <code>loc = (nothing, nothing, nothing)</code> (default): functions of <code>(i, j, k, grid, ℓx, ℓy, ℓz)</code> with <code>ℓx</code>, <code>ℓy</code> and <code>ℓz</code> either <code>Face()</code> or <code>Center()</code>.</li><li>with <code>loc = (ℓx, ℓy, ℓz)</code> with <code>ℓx</code>, <code>ℓy</code> and <code>ℓz</code> either <code>Face()</code> or <code>Center()</code>: functions of <code>(i, j, k, grid)</code>.</li></ul></li><li><p><code>parameters</code>: <code>NamedTuple</code> with parameters used by the functions that compute viscosity and/or diffusivity; default: <code>nothing</code>.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; ScalarDiffusivity(ν = 1000, κ=2000)
ScalarDiffusivity{ExplicitTimeDiscretization}(ν=1000.0, κ=2000.0)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; const depth_scale = 100;

julia&gt; @inline ν(x, y, z) = 1000 * exp(z / depth_scale)
ν (generic function with 1 method)

julia&gt; ScalarDiffusivity(ν = ν)
ScalarDiffusivity{ExplicitTimeDiscretization}(ν=ν (generic function with 1 method), κ=0.0)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans.Grids: znode

julia&gt; @inline function κ(i, j, k, grid, ℓx, ℓy, ℓz)
           z = znode(i, j, k, grid, ℓx, ℓy, ℓz)
           return 2000 * exp(z / depth_scale)
       end
κ (generic function with 1 method)

julia&gt; ScalarDiffusivity(κ = κ, discrete_form = true)
ScalarDiffusivity{ExplicitTimeDiscretization}(ν=0.0, κ=Oceananigans.TurbulenceClosures.DiscreteDiffusionFunction{Nothing, Nothing, Nothing, Nothing, typeof(κ)})</code></pre><pre><code class="language-julia-repl hljs">julia&gt; @inline function another_κ(i, j, k, grid, p)
           z = znode(i, j, k, grid)
           return 2000 * exp(z / p.depth_scale)
       end
another_κ (generic function with 1 method)

julia&gt; ScalarDiffusivity(κ = another_κ, discrete_form = true, loc = (Center, Center, Face), parameters = (; depth_scale = 120.0))
ScalarDiffusivity{ExplicitTimeDiscretization}(ν=0.0, κ=Oceananigans.TurbulenceClosures.DiscreteDiffusionFunction{Center, Center, Face, NamedTuple{(:depth_scale,), Tuple{Float64}}, typeof(another_κ)})</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L12-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.SmagorinskyLilly-Union{Tuple{}, Tuple{TD}, Tuple{TD, Any}} where TD" href="#Oceananigans.TurbulenceClosures.SmagorinskyLilly-Union{Tuple{}, Tuple{TD}, Tuple{TD, Any}} where TD"><code>Oceananigans.TurbulenceClosures.SmagorinskyLilly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SmagorinskyLilly([time_discretization::TD = ExplicitTimeDiscretization(), FT=Float64;] C=0.16, Cb=1.0, Pr=1.0)</code></pre><p>Return a <code>SmagorinskyLilly</code> type associated with the turbulence closure proposed by Lilly (1962) and Smagorinsky (1958, 1963), which has an eddy viscosity of the form</p><pre><code class="nohighlight hljs">νₑ = (C * Δᶠ)² * √(2Σ²) * √(1 - Cb * N² / Σ²)</code></pre><p>and an eddy diffusivity of the form</p><pre><code class="nohighlight hljs">κₑ = νₑ / Pr</code></pre><p>where <code>Δᶠ</code> is the filter width, <code>Σ² = ΣᵢⱼΣᵢⱼ</code> is the double dot product of the strain tensor <code>Σᵢⱼ</code>, <code>Pr</code> is the turbulent Prandtl number, and <code>N²</code> is the total buoyancy gradient, and <code>Cb</code> is a constant the multiplies the Richardson number modification to the eddy viscosity.</p><p><strong>Arguments</strong></p><ul><li><p><code>time_discretization</code>: Either <code>ExplicitTimeDiscretization()</code> or <code>VerticallyImplicitTimeDiscretization()</code>,                         which integrates the terms involving only <span>$z$</span>-derivatives in the                        viscous and diffusive fluxes with an implicit time discretization.                        Default <code>ExplicitTimeDiscretization()</code>.</p></li><li><p><code>FT</code>: Float type; default <code>Float64</code>.</p></li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>C</code>: Smagorinsky constant. Default value is 0.16 as obtained by Lilly (1966).</p></li><li><p><code>Cb</code>: Buoyancy term multipler based on Lilly (1962) (<code>Cb = 0</code> turns it off, <code>Cb ≠ 0</code> turns it on.       Typically, and according to the original work by Lilly (1962), <code>Cb = 1 / Pr</code>.)</p></li><li><p><code>Pr</code>: Turbulent Prandtl numbers for each tracer. Either a constant applied to every       tracer, or a <code>NamedTuple</code> with fields for each tracer individually.</p></li></ul><p><strong>References</strong></p><p>Smagorinsky, J. &quot;On the numerical integration of the primitive equations of motion for     baroclinic flow in a closed region.&quot; Monthly Weather Review (1958)</p><p>Lilly, D. K. &quot;On the numerical simulation of buoyant convection.&quot; Tellus (1962)</p><p>Smagorinsky, J. &quot;General circulation experiments with the primitive equations: I.     The basic experiment.&quot; Monthly weather review (1963)</p><p>Lilly, D. K. &quot;The representation of small-scale turbulence in numerical simulation experiments.&quot;      NCAR Manuscript No. 281, 0, 1966.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl#L21-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.TwoDimensionalLeith" href="#Oceananigans.TurbulenceClosures.TwoDimensionalLeith"><code>Oceananigans.TurbulenceClosures.TwoDimensionalLeith</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TwoDimensionalLeith(FT=Float64;
                    C=0.3, C_Redi=1, C_GM=1,
                    isopycnal_model=SmallSlopeIsopycnalTensor())</code></pre><p>Return a <code>TwoDimensionalLeith</code> type associated with the turbulence closure proposed by Leith (1965) and Fox-Kemper &amp; Menemenlis (2008) which has an eddy viscosity of the form</p><pre><code class="language-julia hljs">νₑ = (C * Δᶠ)³ * √(|∇ₕ ζ|² + |∇ₕ ∂w/∂z|²)</code></pre><p>and an eddy diffusivity of the form...</p><p>where <code>Δᶠ</code> is the filter width, <code>ζ = ∂v/∂x - ∂u/∂y</code> is the vertical vorticity, and <code>C</code> is a model constant.</p><p><strong>Keyword arguments</strong></p><ul><li><code>C</code>: Model constant</li><li><code>C_Redi</code>: Coefficient for down-gradient tracer diffusivity for each tracer.           Either a constant applied to every tracer, or a <code>NamedTuple</code> with fields           for each tracer individually.</li><li><code>C_GM</code>: Coefficient for down-gradient tracer diffusivity for each tracer.         Either a constant applied to every tracer, or a <code>NamedTuple</code> with fields         for each tracer individually.</li></ul><p><strong>References</strong></p><p>Leith, C. E. (1968). &quot;Diffusion Approximation for Two‐Dimensional Turbulence&quot;, The Physics of     Fluids 11, 671. doi: 10.1063/1.1691968</p><p>Fox‐Kemper, B., &amp; D. Menemenlis (2008), &quot;Can large eddy simulation techniques improve mesoscale rich     ocean models?&quot;, in Ocean Modeling in an Eddying Regime, Geophys. Monogr. Ser., vol. 177, pp. 319–337.     doi: 10.1029/177GM19</p><p>Pearson, B. et al. (2017) , &quot;Evaluation of scale-aware subgrid mesoscale eddy models in a global eddy     rich model&quot;, Ocean Modelling 115, 42-58. doi: 10.1016/j.ocemod.2017.05.007</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl#L20-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.VerticalScalarDiffusivity" href="#Oceananigans.TurbulenceClosures.VerticalScalarDiffusivity"><code>Oceananigans.TurbulenceClosures.VerticalScalarDiffusivity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VerticalScalarDiffusivity([time_discretization=ExplicitTimeDiscretization(),
                          FT::DataType=Float64;]
                          kwargs...)</code></pre><p>Shorthand for a <code>ScalarDiffusivity</code> with <code>VerticalFormulation()</code>. See <a href="#Oceananigans.TurbulenceClosures.ScalarDiffusivity"><code>ScalarDiffusivity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L129-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.VerticallyImplicitTimeDiscretization" href="#Oceananigans.TurbulenceClosures.VerticallyImplicitTimeDiscretization"><code>Oceananigans.TurbulenceClosures.VerticallyImplicitTimeDiscretization</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct VerticallyImplicitTimeDiscretization &lt;: AbstractTimeDiscretization</code></pre><p>A vertically-implicit time-discretization of a <code>TurbulenceClosure</code>.</p><p>This implies that a flux divergence such as <span>$𝛁 ⋅ 𝐪$</span> at the <span>$n$</span>-th timestep is  time-discretized as</p><pre><code class="language-julia hljs">[∇ ⋅ q]ⁿ = [explicit_flux_divergence]ⁿ + [∂z (κ ∂z c)]ⁿ⁺¹</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/TurbulenceClosures/implicit_explicit_time_discretization.jl#L15-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.diffusivity" href="#Oceananigans.TurbulenceClosures.diffusivity"><code>Oceananigans.TurbulenceClosures.diffusivity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">diffusivity(closure, tracer_index, diffusivity_fields)</code></pre><p>Returns the scalar diffusivity associated with <code>closure</code> and <code>tracer_index</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl#L51-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.TurbulenceClosures.viscosity" href="#Oceananigans.TurbulenceClosures.viscosity"><code>Oceananigans.TurbulenceClosures.viscosity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">viscosity(closure, diffusivities)</code></pre><p>Returns the scalar viscosity associated with <code>closure</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl#L44-L48">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.AndSchedule-Tuple" href="#Oceananigans.Utils.AndSchedule-Tuple"><code>Oceananigans.Utils.AndSchedule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AndSchedule(schedules...)</code></pre><p>Return a schedule that actuates when all <code>child_schedule</code>s actuate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Utils/schedules.jl#L229-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.IterationInterval-Tuple{Any}" href="#Oceananigans.Utils.IterationInterval-Tuple{Any}"><code>Oceananigans.Utils.IterationInterval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">IterationInterval(interval; offset=0)</code></pre><p>Return a callable <code>IterationInterval</code> that &quot;actuates&quot; (schedules output or callback execution) whenever the model iteration (modified by <code>offset</code>) is a multiple of <code>interval</code>.</p><p>For example, </p><ul><li><code>IterationInterval(100)</code> actuates at iterations <code>[100, 200, 300, ...]</code>.</li><li><code>IterationInterval(100, offset=-1)</code> actuates at iterations <code>[99, 199, 299, ...]</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Utils/schedules.jl#L78-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.MultiRegionObject-Tuple{Tuple}" href="#Oceananigans.Utils.MultiRegionObject-Tuple{Tuple}"><code>Oceananigans.Utils.MultiRegionObject</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MultiRegionObject(regional_objects::Tuple; devices)</code></pre><p>Return a MultiRegionObject</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Utils/multi_region_transformation.jl#L30-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.OrSchedule-Tuple" href="#Oceananigans.Utils.OrSchedule-Tuple"><code>Oceananigans.Utils.OrSchedule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">OrSchedule(schedules...)</code></pre><p>Return a schedule that actuates when any of the <code>child_schedule</code>s actuates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Utils/schedules.jl#L245-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.SpecifiedTimes-Union{Tuple{Vararg{T}}, Tuple{T}} where T&lt;:Number" href="#Oceananigans.Utils.SpecifiedTimes-Union{Tuple{Vararg{T}}, Tuple{T}} where T&lt;:Number"><code>Oceananigans.Utils.SpecifiedTimes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SpecifiedTimes(times)</code></pre><p>Return a callable <code>TimeInterval</code> that &quot;actuates&quot; (schedules output or callback execution) whenever the model&#39;s clock equals the specified values in <code>times</code>. For example, </p><ul><li><code>SpecifiedTimes([1, 15.3])</code> actuates when <code>model.clock.time</code> is <code>1</code> and <code>15.3</code>.</li></ul><div class="admonition is-info"><header class="admonition-header">Sorting specified times</header><div class="admonition-body"><p>The specified <code>times</code> need not be ordered as the <code>SpecifiedTimes</code> constructor will check and order them in ascending order if needed.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Utils/schedules.jl#L137-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.TimeInterval" href="#Oceananigans.Utils.TimeInterval"><code>Oceananigans.Utils.TimeInterval</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct TimeInterval &lt;: AbstractSchedule</code></pre><p>Callable <code>TimeInterval</code> schedule for periodic output or diagnostic evaluation according to <code>model.clock.time</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Utils/schedules.jl#L30-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.TimeInterval-Tuple{Any}" href="#Oceananigans.Utils.TimeInterval-Tuple{Any}"><code>Oceananigans.Utils.TimeInterval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TimeInterval(interval)</code></pre><p>Return a callable <code>TimeInterval</code> that schedules periodic output or diagnostic evaluation on a <code>interval</code> of simulation time, as kept by <code>model.clock</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Utils/schedules.jl#L41-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.WallTimeInterval-Tuple{Any}" href="#Oceananigans.Utils.WallTimeInterval-Tuple{Any}"><code>Oceananigans.Utils.WallTimeInterval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">WallTimeInterval(interval; start_time = time_ns() * 1e-9)</code></pre><p>Return a callable <code>WallTimeInterval</code> that schedules periodic output or diagnostic evaluation on a <code>interval</code> of &quot;wall time&quot; while a simulation runs, in units of seconds.</p><p>The &quot;wall time&quot; is the actual real world time in seconds, as kept by an actual or hypothetical clock hanging on your wall.</p><p>The keyword argument <code>start_time</code> can be used to specify a starting wall time other than the moment <code>WallTimeInterval</code> is constructed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Utils/schedules.jl#L102-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.launch!-Tuple{Any, Any, Any, Any, Vararg{Any}}" href="#Oceananigans.Utils.launch!-Tuple{Any, Any, Any, Any, Vararg{Any}}"><code>Oceananigans.Utils.launch!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">launch!(arch, grid, layout, kernel!, args...; kwargs...)</code></pre><p>Launches <code>kernel!</code>, with arguments <code>args</code> and keyword arguments <code>kwargs</code>, over the <code>dims</code> of <code>grid</code> on the architecture <code>arch</code>. kernels run on the defaul stream</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Utils/kernel_launching.jl#L74-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.pretty_filesize" href="#Oceananigans.Utils.pretty_filesize"><code>Oceananigans.Utils.pretty_filesize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pretty_filesize(s, suffix=&quot;B&quot;)</code></pre><p>Convert a floating point value <code>s</code> representing a file size to a more human-friendly formatted string with one decimal places with a <code>suffix</code> defaulting to &quot;B&quot;. Depending on the value of <code>s</code> the string will be formatted to show <code>s</code> using an SI prefix from bytes, kiB (1024 bytes), MiB (1024² bytes), and so on up to YiB (1024⁸ bytes).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Utils/pretty_filesize.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.prettytime" href="#Oceananigans.Utils.prettytime"><code>Oceananigans.Utils.prettytime</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">prettytime(t, longform=true)</code></pre><p>Convert a floating point value <code>t</code> representing an amount of time in SI units of seconds to a human-friendly string with three decimal places. Depending on the value of <code>t</code> the string will be formatted to show <code>t</code> in nanoseconds (ns), microseconds (μs), milliseconds (ms), seconds, minutes, hours, or days.</p><p>With <code>longform=false</code>, we use s, m, hrs, and d in place of seconds, minutes, and hours.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Utils/prettytime.jl#L8-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.with_tracers-Tuple{Any, NamedTuple, Any}" href="#Oceananigans.Utils.with_tracers-Tuple{Any, NamedTuple, Any}"><code>Oceananigans.Utils.with_tracers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">with_tracers(tracer_names, initial_tuple, tracer_default)</code></pre><p>Create a tuple corresponding to the solution variables <code>u</code>, <code>v</code>, <code>w</code>, and <code>tracer_names</code>. <code>initial_tuple</code> is a <code>NamedTuple</code> that at least has fields <code>u</code>, <code>v</code>, and <code>w</code>, and may have some fields corresponding to the names in <code>tracer_names</code>. <code>tracer_default</code> is a function that produces a default tuple value for each tracer if not included in <code>initial_tuple</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Utils/with_tracers.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.work_layout-Tuple{Any, Symbol}" href="#Oceananigans.Utils.work_layout-Tuple{Any, Symbol}"><code>Oceananigans.Utils.work_layout</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">work_layout(grid, dims; include_right_boundaries=false, location=nothing)</code></pre><p>Returns the <code>workgroup</code> and <code>worksize</code> for launching a kernel over <code>dims</code> on <code>grid</code>. The <code>workgroup</code> is a tuple specifying the threads per block in each dimension. The <code>worksize</code> specifies the range of the loop in each dimension.</p><p>Specifying <code>include_right_boundaries=true</code> will ensure the work layout includes the right face end points along bounded dimensions. This requires the field <code>location</code> to be specified.</p><p>For more information, see: https://github.com/CliMA/Oceananigans.jl/pull/308</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Utils/kernel_launching.jl#L38-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Utils.@apply_regionally-Tuple{Any}" href="#Oceananigans.Utils.@apply_regionally-Tuple{Any}"><code>Oceananigans.Utils.@apply_regionally</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@apply_regionally expr</code></pre><p>Use <code>@apply_regionally</code> to distribute locally the function calls. Call <code>compute_regionally</code> in case of a returning value and <code>apply_regionally!</code>  in case of no return.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Utils/multi_region_transformation.jl#L185-L191">source</a></section></article><h2 id="Units"><a class="docs-heading-anchor" href="#Units">Units</a><a id="Units-1"></a><a class="docs-heading-anchor-permalink" href="#Units" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Units.GiB" href="#Oceananigans.Units.GiB"><code>Oceananigans.Units.GiB</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">GiB</code></pre><p>A <code>Float64</code> constant equal to 1024<code>MiB</code>. Useful for increasing the clarity of scripts, e.g. <code>max_filesize = 50GiB</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Units.jl#L109-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Units.KiB" href="#Oceananigans.Units.KiB"><code>Oceananigans.Units.KiB</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">KiB</code></pre><p>A <code>Float64</code> constant equal to 1024.0. Useful for increasing the clarity of scripts, e.g. <code>max_filesize = 250KiB</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Units.jl#L95-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Units.MiB" href="#Oceananigans.Units.MiB"><code>Oceananigans.Units.MiB</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">MiB</code></pre><p>A <code>Float64</code> constant equal to 1024<code>KiB</code>. Useful for increasing the clarity of scripts, e.g. <code>max_filesize = 100MiB</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Units.jl#L102-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Units.TiB" href="#Oceananigans.Units.TiB"><code>Oceananigans.Units.TiB</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">TiB</code></pre><p>A <code>Float64</code> constant equal to 1024<code>GiB</code>. Useful for increasing the clarity of scripts, e.g. <code>max_filesize = 2TiB</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Units.jl#L116-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Units.day" href="#Oceananigans.Units.day"><code>Oceananigans.Units.day</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">day</code></pre><p>A <code>Float64</code> constant equal to 24<code>hours</code>. Useful for increasing the clarity of scripts, e.g. <code>stop_time = 1day</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Units.jl#L53-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Units.days" href="#Oceananigans.Units.days"><code>Oceananigans.Units.days</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">days</code></pre><p>A <code>Float64</code> constant equal to 24<code>hours</code>. Useful for increasing the clarity of scripts, e.g. <code>stop_time = 7days</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Units.jl#L60-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Units.hour" href="#Oceananigans.Units.hour"><code>Oceananigans.Units.hour</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">hour</code></pre><p>A <code>Float64</code> constant equal to 60<code>minutes</code>. Useful for increasing the clarity of scripts, e.g. <code>Δt = 1hour</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Units.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Units.hours" href="#Oceananigans.Units.hours"><code>Oceananigans.Units.hours</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">hours</code></pre><p>A <code>Float64</code> constant equal to 60<code>minutes</code>. Useful for increasing the clarity of scripts, e.g. <code>Δt = 3hours</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Units.jl#L46-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Units.kilometer" href="#Oceananigans.Units.kilometer"><code>Oceananigans.Units.kilometer</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">kilometer</code></pre><p>A <code>Float64</code> constant equal to 1000<code>meters</code>. Useful for increasing the clarity of scripts, e.g. <code>Lx = 1kilometer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Units.jl#L81-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Units.kilometers" href="#Oceananigans.Units.kilometers"><code>Oceananigans.Units.kilometers</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">kilometers</code></pre><p>A <code>Float64</code> constant equal to 1000<code>meters</code>. Useful for increasing the clarity of scripts, e.g. <code>Lx = 5000kilometers</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Units.jl#L88-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Units.meter" href="#Oceananigans.Units.meter"><code>Oceananigans.Units.meter</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">meter</code></pre><p>A <code>Float64</code> constant equal to 1.0. Useful for increasing the clarity of scripts, e.g. <code>Lx = 1meter</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Units.jl#L67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Units.meters" href="#Oceananigans.Units.meters"><code>Oceananigans.Units.meters</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">meters</code></pre><p>A <code>Float64</code> constant equal to 1.0. Useful for increasing the clarity of scripts, e.g. <code>Lx = 50meters</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Units.jl#L74-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Units.minute" href="#Oceananigans.Units.minute"><code>Oceananigans.Units.minute</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">minute</code></pre><p>A <code>Float64</code> constant equal to 60<code>seconds</code>. Useful for increasing the clarity of scripts, e.g. <code>Δt = 1minute</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Units.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Units.minutes" href="#Oceananigans.Units.minutes"><code>Oceananigans.Units.minutes</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">minutes</code></pre><p>A <code>Float64</code> constant equal to 60<code>seconds</code>. Useful for increasing the clarity of scripts, e.g. <code>Δt = 15minutes</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Units.jl#L32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Units.second" href="#Oceananigans.Units.second"><code>Oceananigans.Units.second</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">second</code></pre><p>A <code>Float64</code> constant equal to 1.0. Useful for increasing the clarity of scripts, e.g. <code>Δt = 1second</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Units.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Oceananigans.Units.seconds" href="#Oceananigans.Units.seconds"><code>Oceananigans.Units.seconds</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">seconds</code></pre><p>A <code>Float64</code> constant equal to 1.0. Useful for increasing the clarity of scripts, e.g. <code>Δt = 7seconds</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/Oceananigans.jl/blob/3088f24c87a348b7d93ce08aced864c2e3a38db0/src/Units.jl#L18-L22">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../benchmarks/">« Performance benchmarks</a><a class="docs-footer-nextpage" href="../function_index/">Function index »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 6 July 2023 21:12">Thursday 6 July 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

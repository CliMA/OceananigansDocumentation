<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Boundary conditions · Oceananigans.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://clima.github.io/OceananigansDocumentation/stable/model_setup/boundary_conditions/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Oceananigans.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../quick_start/">Quick start</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/one_dimensional_diffusion/">One-dimensional diffusion</a></li><li><a class="tocitem" href="../../generated/two_dimensional_turbulence/">Two-dimensional turbulence</a></li><li><a class="tocitem" href="../../generated/internal_wave/">Internal wave</a></li><li><a class="tocitem" href="../../generated/convecting_plankton/">Convecting plankton</a></li><li><a class="tocitem" href="../../generated/ocean_wind_mixing_and_convection/">Ocean wind mixing and convection</a></li><li><a class="tocitem" href="../../generated/langmuir_turbulence/">Langmuir turbulence</a></li><li><a class="tocitem" href="../../generated/baroclinic_adjustment/">Baroclinic adjustment</a></li><li><a class="tocitem" href="../../generated/kelvin_helmholtz_instability/">Kelvin-Helmholtz instability</a></li><li><a class="tocitem" href="../../generated/shallow_water_Bickley_jet/">Shallow water Bickley jet</a></li><li><a class="tocitem" href="../../generated/horizontal_convection/">Horizontal convection</a></li><li><a class="tocitem" href="../../generated/tilted_bottom_boundary_layer/">Tilted bottom boundary layer</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Physics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../physics/notation/">Coordinate system and notation</a></li><li><a class="tocitem" href="../../physics/boussinesq/">Boussinesq approximation</a></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label"><code>NonhydrostaticModel</code></span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../physics/nonhydrostatic_model/">Nonhydrostatic model</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label"><code>HydrostaticFreeSurfaceModel</code></span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../physics/hydrostatic_free_surface_model/">Hydrostatic model with a free surface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label"><code>ShallowWaterModel</code></span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../physics/shallow_water_model/">Shallow water model</a></li></ul></li><li><a class="tocitem" href="../../physics/buoyancy_and_equations_of_state/">Buoyancy models and equations of state</a></li><li><a class="tocitem" href="../../physics/coriolis_forces/">Coriolis forces</a></li><li><a class="tocitem" href="../../physics/turbulence_closures/">Turbulence closures</a></li><li><a class="tocitem" href="../../physics/surface_gravity_waves/">Surface gravity waves and the Craik-Leibovich approximation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Numerical implementation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../numerical_implementation/finite_volume/">Finite volume method</a></li><li><a class="tocitem" href="../../numerical_implementation/spatial_operators/">Spatial operators</a></li><li><a class="tocitem" href="../../numerical_implementation/pressure_decomposition/">Pressure decomposition</a></li><li><a class="tocitem" href="../../numerical_implementation/time_stepping/">Time stepping</a></li><li><a class="tocitem" href="../../numerical_implementation/boundary_conditions/">Boundary conditions</a></li><li><a class="tocitem" href="../../numerical_implementation/poisson_solvers/">Poisson solvers</a></li><li><a class="tocitem" href="../../numerical_implementation/large_eddy_simulation/">Large eddy simulation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">Model setup</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../architecture/">Architecture</a></li><li><a class="tocitem" href="../number_type/">Number type</a></li><li><a class="tocitem" href="../grids/">Grid</a></li><li><a class="tocitem" href="../clock/">Clock</a></li><li><a class="tocitem" href="../coriolis/">Coriolis (rotation)</a></li><li><a class="tocitem" href="../tracers/">Tracers</a></li><li><a class="tocitem" href="../buoyancy_and_equation_of_state/">Buoyancy models and equation of state</a></li><li class="is-active"><a class="tocitem" href>Boundary conditions</a><ul class="internal"><li><a class="tocitem" href="#Boundary-condition-classifications"><span>Boundary condition classifications</span></a></li><li><a class="tocitem" href="#Default-boundary-conditions"><span>Default boundary conditions</span></a></li><li><a class="tocitem" href="#Boundary-condition-structures"><span>Boundary condition structures</span></a></li><li><a class="tocitem" href="#Specifying-boundary-conditions-for-a-model"><span>Specifying boundary conditions for a model</span></a></li><li><a class="tocitem" href="#Creating-individual-boundary-conditions-with-BoundaryCondition"><span>Creating individual boundary conditions with <code>BoundaryCondition</code></span></a></li><li><a class="tocitem" href="#Building-boundary-conditions-on-a-field"><span>Building boundary conditions on a field</span></a></li><li><a class="tocitem" href="#Specifying-model-boundary-conditions"><span>Specifying model boundary conditions</span></a></li><li><a class="tocitem" href="#Immersed-boundary-conditions"><span>Immersed boundary conditions</span></a></li></ul></li><li><a class="tocitem" href="../forcing_functions/">Forcing functions</a></li><li><a class="tocitem" href="../background_fields/">Background fields</a></li><li><a class="tocitem" href="../turbulent_diffusivity_closures_and_les_models/">Turbulent diffusivity closures and LES models</a></li><li><a class="tocitem" href="../lagrangian_particles/">Lagrangian particles</a></li><li><a class="tocitem" href="../diagnostics/">Diagnostics</a></li><li><a class="tocitem" href="../output_writers/">Output writers</a></li><li><a class="tocitem" href="../checkpointing/">Checkpointing</a></li><li><a class="tocitem" href="../setting_initial_conditions/">Setting initial conditions</a></li></ul></li><li><a class="tocitem" href="../../simulation_tips/">Simulation tips</a></li><li><a class="tocitem" href="../../contributing/">Contributor&#39;s guide</a></li><li><a class="tocitem" href="../../gallery/">Gallery</a></li><li><a class="tocitem" href="../../references/">References</a></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">Appendix</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../appendix/staggered_grid/">Staggered grid</a></li><li><a class="tocitem" href="../../appendix/fractional_step/">Fractional step method</a></li><li><a class="tocitem" href="../../appendix/convergence_tests/">Convergence tests</a></li><li><a class="tocitem" href="../../appendix/benchmarks/">Performance benchmarks</a></li><li><a class="tocitem" href="../../appendix/library/">Library</a></li><li><a class="tocitem" href="../../appendix/function_index/">Function index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Model setup</a></li><li class="is-active"><a href>Boundary conditions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Boundary conditions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/CliMA/Oceananigans.jl/blob/master/docs/src/model_setup/boundary_conditions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="model_step_bcs"><a class="docs-heading-anchor" href="#model_step_bcs">Boundary conditions</a><a id="model_step_bcs-1"></a><a class="docs-heading-anchor-permalink" href="#model_step_bcs" title="Permalink"></a></h1><p>Boundary conditions are intimately related to the grid topology, and only need to be considered in directions with <code>Bounded</code> topology or across immersed boundaries. In <code>Bounded</code> directions, tracer and momentum fluxes are conservative or &quot;zero flux&quot; by default. Non-default boundary conditions are therefore required to specify non-zero fluxes of tracers and momentum across <code>Bounded</code> directions, and across immersed boundaries when using <code>ImmersedBoundaryGrid</code>.</p><p>See <a href="../../numerical_implementation/boundary_conditions/#numerical_bcs">Numerical implementation of boundary conditions</a> for more details.</p><h3 id="Example:-no-slip-conditions-on-every-boundary"><a class="docs-heading-anchor" href="#Example:-no-slip-conditions-on-every-boundary">Example: no-slip conditions on every boundary</a><a id="Example:-no-slip-conditions-on-every-boundary-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-no-slip-conditions-on-every-boundary" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = RectilinearGrid(size=(16, 16, 16), x=(0, 2π), y=(0, 1), z=(0, 1), topology=(Periodic, Bounded, Bounded))
16×16×16 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3×3×3 halo
├── Periodic x ∈ [1.26883e-16, 6.28319) regularly spaced with Δx=0.392699
├── Bounded  y ∈ [0.0, 1.0]             regularly spaced with Δy=0.0625
└── Bounded  z ∈ [0.0, 1.0]             regularly spaced with Δz=0.0625

julia&gt; no_slip_bc = ValueBoundaryCondition(0)
ValueBoundaryCondition: 0</code></pre><p>A &quot;no-slip&quot; <a href="../../appendix/library/#Oceananigans.BoundaryConditions.BoundaryCondition"><code>BoundaryCondition</code></a> specifies that velocity components tangential to <code>Bounded</code> directions decay to <code>0</code> at the boundary, leading to a viscous loss of momentum.</p><pre><code class="language-julia-repl hljs">julia&gt; no_slip_field_bcs = FieldBoundaryConditions(no_slip_bc);

julia&gt; model = NonhydrostaticModel(; grid, boundary_conditions=(u=no_slip_field_bcs, v=no_slip_field_bcs, w=no_slip_field_bcs))
NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)
├── grid: 16×16×16 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3×3×3 halo
├── timestepper: QuasiAdamsBashforth2TimeStepper
├── tracers: ()
├── closure: Nothing
├── buoyancy: Nothing
└── coriolis: Nothing

julia&gt; model.velocities.u.boundary_conditions
Oceananigans.FieldBoundaryConditions, with boundary conditions
├── west: PeriodicBoundaryCondition
├── east: PeriodicBoundaryCondition
├── south: ValueBoundaryCondition: 0
├── north: ValueBoundaryCondition: 0
├── bottom: ValueBoundaryCondition: 0
├── top: ValueBoundaryCondition: 0
└── immersed: FluxBoundaryCondition: Nothing</code></pre><p>Boundary conditions are passed to <code>FieldBoundaryCondition</code> to build boundary conditions for each field individually, and then onto the model constructor (here <code>NonhydrotaticModel</code>) via the  keyword argument <code>boundary_conditions</code>. The model constructor then &quot;interprets&quot; the input and builds appropriate boundary conditions for the grid <code>topology</code>, given the user-specified <code>no_slip</code> default boundary condition for <code>Bounded</code> directions. In the above example, note that the <code>west</code> and <code>east</code> boundary conditions are <code>PeriodicBoundaryCondition</code> because the <code>x</code>-topology of the grid is <code>Periodic</code>.</p><h3 id="Example:-specifying-boundary-conditions-on-individual-boundaries"><a class="docs-heading-anchor" href="#Example:-specifying-boundary-conditions-on-individual-boundaries">Example: specifying boundary conditions on individual boundaries</a><a id="Example:-specifying-boundary-conditions-on-individual-boundaries-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-specifying-boundary-conditions-on-individual-boundaries" title="Permalink"></a></h3><p>To specify no-slip boundary conditions on every <code>Bounded</code> direction <em>except</em> the surface, we write</p><pre><code class="language-julia-repl hljs">julia&gt; free_slip_surface_bcs = FieldBoundaryConditions(no_slip_bc, top=FluxBoundaryCondition(nothing));

julia&gt; model = NonhydrostaticModel(; grid, boundary_conditions=(u=free_slip_surface_bcs, v=free_slip_surface_bcs, w=no_slip_field_bcs));

julia&gt; model.velocities.u.boundary_conditions
Oceananigans.FieldBoundaryConditions, with boundary conditions
├── west: PeriodicBoundaryCondition
├── east: PeriodicBoundaryCondition
├── south: ValueBoundaryCondition: 0
├── north: ValueBoundaryCondition: 0
├── bottom: ValueBoundaryCondition: 0
├── top: FluxBoundaryCondition: Nothing
└── immersed: FluxBoundaryCondition: Nothing

julia&gt; model.velocities.v.boundary_conditions
Oceananigans.FieldBoundaryConditions, with boundary conditions
├── west: PeriodicBoundaryCondition
├── east: PeriodicBoundaryCondition
├── south: OpenBoundaryCondition: Nothing
├── north: OpenBoundaryCondition: Nothing
├── bottom: ValueBoundaryCondition: 0
├── top: FluxBoundaryCondition: Nothing
└── immersed: FluxBoundaryCondition: Nothing</code></pre><p>Now both <code>u</code> and <code>v</code> have <code>FluxBoundaryCondition(nothing)</code> at the <code>top</code> boundary, which is <code>Oceananigans</code> lingo for &quot;no-flux boundary condition&quot;.</p><h2 id="Boundary-condition-classifications"><a class="docs-heading-anchor" href="#Boundary-condition-classifications">Boundary condition classifications</a><a id="Boundary-condition-classifications-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-condition-classifications" title="Permalink"></a></h2><p>There are three primary boundary condition classifications:</p><ol><li><p><code>FluxBoundaryCondition</code> specifies fluxes directly.</p><p>Some applications of <code>FluxBoundaryCondition</code> are:     * surface momentum fluxes due to wind, or &quot;wind stress&quot;;     * linear or quadratic bottom drag;     * surface temperature fluxes due to heating or cooling;     * surface salinity fluxes due to precipitation and evaporation;     * relaxation boundary conditions that restores a field to some boundary distribution       over a given time-scale.</p></li><li><p><code>ValueBoundaryCondition</code> (Dirchlet) specifies the value of a field on the given boundary, which when used in combination with a turbulence closure results in a flux across the boundary.</p><p><em>Note</em>: Do not use <code>ValueBoundaryCondition</code> on a wall-normal velocity component (see the note below about <code>ImpenetrableBoundaryCondition</code>).</p><p>Some applications of <code>ValueBoundaryCondition</code> are:</p><pre><code class="nohighlight hljs">* no-slip boundary condition for wall-tangential velocity components via `ValueBoundaryCondition(0)`;
* surface temperature distribution, where heat fluxes in and out of the domain
  at a rate controlled by the near-surface temperature gradient and the temperature diffusivity;
* constant velocity tangential to a boundary as in a driven-cavity flow (for example), 
  where the top boundary is moving. Momentum will flux into the domain do the difference
  between the top boundary velocity and the interior velocity, and the prescribed viscosity.</code></pre></li><li><p><code>GradientBoundaryCondition</code> (Neumann) specifies the gradient of a field on a boundary. For example, if there is a known <code>diffusivity</code>, we can express <code>FluxBoundaryCondition(flux)</code> using <code>GradientBoundaryCondition(-flux / diffusivity)</code> (aka &quot;Neumann&quot; boundary condition).</p></li></ol><p>In addition to these primary boundary conditions, <code>ImpenetrableBoundaryCondition</code> applies to velocity components in wall-normal directions.</p><p>!!! warn <code>ImpenetrableBoundaryCondition</code>     <code>ImpenetrableBoundaryCondition</code> is internally enforced for fields created inside the model constructor.     As a result, <code>ImpenetrableBoundaryCondition</code> is only used for <em>additional</em> velocity components     that are not evolved by a model, such as a velocity component used for (<code>AdvectiveForcing</code>)[@ref].</p><p>Finally, note that <code>Periodic</code> boundary conditions are internally enforced for <code>Periodic</code> directions, and <code>DefaultBoundaryCondition</code>s may exist before boundary conditions are &quot;materialized&quot; by a model.</p><h2 id="Default-boundary-conditions"><a class="docs-heading-anchor" href="#Default-boundary-conditions">Default boundary conditions</a><a id="Default-boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Default-boundary-conditions" title="Permalink"></a></h2><p>The default boundary condition in <code>Bounded</code> directions is no-flux, or <code>FluxBoundaryCondition(nothing)</code>. The default boundary condition can be changed by passing a positional argument to <code>FieldBoundaryConditions</code>, as in</p><pre><code class="language-julia-repl hljs">julia&gt; no_slip_bc = ValueBoundaryCondition(0)
ValueBoundaryCondition: 0

julia&gt; free_slip_surface_bcs = FieldBoundaryConditions(no_slip_bc, top=FluxBoundaryCondition(nothing))
Oceananigans.FieldBoundaryConditions, with boundary conditions
├── west: DefaultBoundaryCondition (ValueBoundaryCondition: 0)
├── east: DefaultBoundaryCondition (ValueBoundaryCondition: 0)
├── south: DefaultBoundaryCondition (ValueBoundaryCondition: 0)
├── north: DefaultBoundaryCondition (ValueBoundaryCondition: 0)
├── bottom: DefaultBoundaryCondition (ValueBoundaryCondition: 0)
├── top: FluxBoundaryCondition: Nothing
└── immersed: DefaultBoundaryCondition (ValueBoundaryCondition: 0)</code></pre><h2 id="Boundary-condition-structures"><a class="docs-heading-anchor" href="#Boundary-condition-structures">Boundary condition structures</a><a id="Boundary-condition-structures-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-condition-structures" title="Permalink"></a></h2><p>Oceananigans uses a hierarchical structure to express boundary conditions:</p><ol><li>Each boundary of each field has one <a href="../../appendix/library/#Oceananigans.BoundaryConditions.BoundaryCondition"><code>BoundaryCondition</code></a></li><li>Each field has seven <a href="../../appendix/library/#Oceananigans.BoundaryConditions.BoundaryCondition"><code>BoundaryCondition</code></a> (<code>west</code>, <code>east</code>, <code>south</code>, <code>north</code>, <code>bottom</code>, <code>top</code> and <code>immersed</code>)</li><li>A set of <code>FieldBoundaryConditions</code>, up to one for each field, are grouped into a <code>NamedTuple</code> and passed to the model constructor.</li></ol><h2 id="Specifying-boundary-conditions-for-a-model"><a class="docs-heading-anchor" href="#Specifying-boundary-conditions-for-a-model">Specifying boundary conditions for a model</a><a id="Specifying-boundary-conditions-for-a-model-1"></a><a class="docs-heading-anchor-permalink" href="#Specifying-boundary-conditions-for-a-model" title="Permalink"></a></h2><p>Boundary conditions are defined at model construction time by passing a <code>NamedTuple</code> of <code>FieldBoundaryConditions</code> specifying non-default boundary conditions for fields such as velocities and tracers.</p><p>Fields for which boundary conditions are not specified are assigned a default boundary conditions.</p><p>A few illustrations are provided below. See the examples for further illustrations of boundary condition specification.</p><h2 id="Creating-individual-boundary-conditions-with-BoundaryCondition"><a class="docs-heading-anchor" href="#Creating-individual-boundary-conditions-with-BoundaryCondition">Creating individual boundary conditions with <code>BoundaryCondition</code></a><a id="Creating-individual-boundary-conditions-with-BoundaryCondition-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-individual-boundary-conditions-with-BoundaryCondition" title="Permalink"></a></h2><p>Boundary conditions may be specified with constants, functions, or arrays. In this section we illustrate usage of the different <a href="../../appendix/library/#Oceananigans.BoundaryConditions.BoundaryCondition"><code>BoundaryCondition</code></a> constructors.</p><h3 id=".-Constant-Value-(Dirchlet)-boundary-condition"><a class="docs-heading-anchor" href="#.-Constant-Value-(Dirchlet)-boundary-condition">1. Constant <code>Value</code> (Dirchlet) boundary condition</a><a id=".-Constant-Value-(Dirchlet)-boundary-condition-1"></a><a class="docs-heading-anchor-permalink" href="#.-Constant-Value-(Dirchlet)-boundary-condition" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs">julia&gt; constant_T_bc = ValueBoundaryCondition(20.0)
ValueBoundaryCondition: 20.0</code></pre><p>A constant <a href="../../appendix/library/#Oceananigans.BoundaryConditions.Value"><code>Value</code></a> boundary condition can be used to specify constant tracer (such as temperature), or a constant <em>tangential</em> velocity component at a boundary. Note that boundary conditions on the <em>normal</em> velocity component must use the <a href="../../appendix/library/#Oceananigans.BoundaryConditions.Open"><code>Open</code></a> boundary condition type.</p><p>Finally, note that <code>ValueBoundaryCondition(condition)</code> is an alias for <code>BoundaryCondition(Value, condition)</code>.</p><h3 id=".-Constant-Flux-boundary-condition"><a class="docs-heading-anchor" href="#.-Constant-Flux-boundary-condition">2. Constant <code>Flux</code> boundary condition</a><a id=".-Constant-Flux-boundary-condition-1"></a><a class="docs-heading-anchor-permalink" href="#.-Constant-Flux-boundary-condition" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs">julia&gt; ρ₀ = 1027;  # Reference density [kg/m³]

julia&gt; τₓ = 0.08;  # Wind stress [N/m²]

julia&gt; wind_stress_bc = FluxBoundaryCondition(-τₓ/ρ₀)
FluxBoundaryCondition: -7.78968e-5</code></pre><p>A constant <a href="../../appendix/library/#Oceananigans.BoundaryConditions.Flux"><code>Flux</code></a> boundary condition can be imposed on tracers and tangential velocity components that can be used, for example, to specify cooling, heating, evaporation, or wind stress at the ocean surface.</p><div class="admonition is-info"><header class="admonition-header">The flux convention in Oceananigans</header><div class="admonition-body"><p><code>Oceananigans</code> uses the convention that positive fluxes produce transport in the <em>positive</em> direction (east, north, and up for <span>$x$</span>, <span>$y$</span>, <span>$z$</span>). This means, for example, that a <em>negative</em> flux of momentum or velocity at a <em>top</em> boundary, such as in the above example, produces currents in the <em>positive</em> direction, because it prescribes a downwards flux of momentum into the domain from the top. Likewise, a <em>positive</em> temperature flux at the top boundary causes <em>cooling</em>, because it transports heat <em>upwards</em>, out of the domain. Conversely, a positive flux at a <em>bottom</em> boundary acts to increase the interior values of a quantity.</p></div></div><h3 id=".-Spatially-and-temporally-varying-flux"><a class="docs-heading-anchor" href="#.-Spatially-and-temporally-varying-flux">3. Spatially- and temporally-varying flux</a><a id=".-Spatially-and-temporally-varying-flux-1"></a><a class="docs-heading-anchor-permalink" href="#.-Spatially-and-temporally-varying-flux" title="Permalink"></a></h3><p>Boundary conditions may be specified by functions,</p><pre><code class="language-julia-repl hljs">julia&gt; @inline surface_flux(x, y, t) = cos(2π * x) * cos(t);

julia&gt; top_tracer_bc = FluxBoundaryCondition(surface_flux)
FluxBoundaryCondition: ContinuousBoundaryFunction surface_flux at (Nothing, Nothing, Nothing)</code></pre><div class="admonition is-info"><header class="admonition-header">Boundary condition functions</header><div class="admonition-body"><p>By default, a function boundary condition is called with the signature</p><pre><code class="language-julia hljs">f(ξ, η, t)</code></pre><p>where <code>t</code> is time and <code>ξ, η</code> are spatial coordinates that vary along the boundary:</p><ul><li><code>f(y, z, t)</code> on <code>x</code>-boundaries;</li><li><code>f(x, z, t)</code> on <code>y</code>-boundaries;</li><li><code>f(x, y, t)</code> on <code>z</code>-boundaries.</li></ul><p>Alternative function signatures are specified by keyword arguments to <code>BoundaryCondition</code>, as illustrated in subsequent examples.</p></div></div><h3 id=".-Spatially-and-temporally-varying-flux-with-parameters"><a class="docs-heading-anchor" href="#.-Spatially-and-temporally-varying-flux-with-parameters">4. Spatially- and temporally-varying flux with parameters</a><a id=".-Spatially-and-temporally-varying-flux-with-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#.-Spatially-and-temporally-varying-flux-with-parameters" title="Permalink"></a></h3><p>Boundary condition functions may be &#39;parameterized&#39;,</p><pre><code class="language-julia-repl hljs">julia&gt; @inline wind_stress(x, y, t, p) = - p.τ * cos(p.k * x) * cos(p.ω * t); # function with parameters

julia&gt; top_u_bc = FluxBoundaryCondition(wind_stress, parameters=(k=4π, ω=3.0, τ=1e-4))
FluxBoundaryCondition: ContinuousBoundaryFunction wind_stress at (Nothing, Nothing, Nothing)</code></pre><div class="admonition is-info"><header class="admonition-header">Boundary condition functions with parameters</header><div class="admonition-body"><p>The keyword argument <code>parameters</code> above specifies that <code>wind_stress</code> is called with the signature <code>wind_stress(x, y, t, parameters)</code>. In principle, <code>parameters</code> is arbitrary. However, relatively simple objects such as floating point numbers or <code>NamedTuple</code>s must be used when running on the GPU.</p></div></div><h3 id=".-&#39;Field-dependent&#39;-boundary-conditions"><a class="docs-heading-anchor" href="#.-&#39;Field-dependent&#39;-boundary-conditions">5. &#39;Field-dependent&#39; boundary conditions</a><a id=".-&#39;Field-dependent&#39;-boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#.-&#39;Field-dependent&#39;-boundary-conditions" title="Permalink"></a></h3><p>Boundary conditions may also depend on model fields. For example, a linear drag boundary condition is implemented with</p><pre><code class="language-julia-repl hljs">julia&gt; @inline linear_drag(x, y, t, u) = - 0.2 * u
linear_drag (generic function with 1 method)

julia&gt; u_bottom_bc = FluxBoundaryCondition(linear_drag, field_dependencies=:u)
FluxBoundaryCondition: ContinuousBoundaryFunction linear_drag at (Nothing, Nothing, Nothing)</code></pre><p><code>field_dependencies</code> specifies the name of the dependent fields either with a <code>Symbol</code> or <code>Tuple</code> of <code>Symbol</code>s.</p><h3 id=".-&#39;Field-dependent&#39;-boundary-conditions-with-parameters"><a class="docs-heading-anchor" href="#.-&#39;Field-dependent&#39;-boundary-conditions-with-parameters">6. &#39;Field-dependent&#39; boundary conditions with parameters</a><a id=".-&#39;Field-dependent&#39;-boundary-conditions-with-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#.-&#39;Field-dependent&#39;-boundary-conditions-with-parameters" title="Permalink"></a></h3><p>When boundary conditions depends on fields <em>and</em> parameters, their functions take the form</p><pre><code class="language-julia-repl hljs">julia&gt; @inline quadratic_drag(x, y, t, u, v, drag_coeff) = - drag_coeff * u * sqrt(u^2 + v^2)
quadratic_drag (generic function with 1 method)

julia&gt; u_bottom_bc = FluxBoundaryCondition(quadratic_drag, field_dependencies=(:u, :v), parameters=1e-3)
FluxBoundaryCondition: ContinuousBoundaryFunction quadratic_drag at (Nothing, Nothing, Nothing)</code></pre><p>Put differently, <code>ξ, η, t</code> come first in the function signature, followed by field dependencies, followed by <code>parameters</code> is <code>!isnothing(parameters)</code>.</p><h3 id=".-Discrete-form-boundary-condition-with-parameters"><a class="docs-heading-anchor" href="#.-Discrete-form-boundary-condition-with-parameters">7. Discrete-form boundary condition with parameters</a><a id=".-Discrete-form-boundary-condition-with-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#.-Discrete-form-boundary-condition-with-parameters" title="Permalink"></a></h3><p>Discrete field data may also be accessed directly from boundary condition functions using the <code>discrete_form</code>. For example:</p><pre><code class="language-julia hljs">@inline filtered_drag(i, j, grid, clock, model_fields) =
   @inbounds - 0.05 * (model_fields.u[i-1, j, 1] + 2 * model_fields.u[i, j, 1] + model_fields.u[i-1, j, 1])

u_bottom_bc = FluxBoundaryCondition(filtered_drag, discrete_form=true)

# output
FluxBoundaryCondition: DiscreteBoundaryFunction with filtered_drag</code></pre><div class="admonition is-info"><header class="admonition-header">The &#39;discrete form&#39; for boundary condition functions</header><div class="admonition-body"><p>The argument <code>discrete_form=true</code> indicates to <a href="../../appendix/library/#Oceananigans.BoundaryConditions.BoundaryCondition"><code>BoundaryCondition</code></a> that <code>filtered_drag</code> uses the &#39;discrete form&#39;. Boundary condition functions that use the &#39;discrete form&#39; are called with the signature</p><pre><code class="language-julia hljs">f(i, j, grid, clock, model_fields)</code></pre><p>where <code>i, j</code> are grid indices that vary along the boundary, <code>grid</code> is <code>model.grid</code>, <code>clock</code> is the <code>model.clock</code>, and <code>model_fields</code> is a <code>NamedTuple</code> containing <code>u, v, w</code> and the fields in <code>model.tracers</code>. The signature is similar for <span>$x$</span> and <span>$y$</span> boundary conditions expect that <code>i, j</code> is replaced with <code>j, k</code> and <code>i, k</code> respectively.</p></div></div><h3 id=".-Discrete-form-boundary-condition-with-parameters-2"><a class="docs-heading-anchor" href="#.-Discrete-form-boundary-condition-with-parameters-2">8. Discrete-form boundary condition with parameters</a><a class="docs-heading-anchor-permalink" href="#.-Discrete-form-boundary-condition-with-parameters-2" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs">julia&gt; Cd = 0.2;  # drag coefficient

julia&gt; @inline linear_drag(i, j, grid, clock, model_fields, Cd) = @inbounds - Cd * model_fields.u[i, j, 1];

julia&gt; u_bottom_bc = FluxBoundaryCondition(linear_drag, discrete_form=true, parameters=Cd)
FluxBoundaryCondition: DiscreteBoundaryFunction linear_drag with parameters 0.2</code></pre><div class="admonition is-info"><header class="admonition-header">Inlining and avoiding bounds-checking in boundary condition functions</header><div class="admonition-body"><p>Boundary condition functions should be decorated with <code>@inline</code> when running on CPUs for performance reasons. On the GPU, all functions are force-inlined by default. In addition, the annotation <code>@inbounds</code> should be used when accessing the elements of an array in a boundary condition function (such as <code>model_fields.u[i, j, 1]</code> in the above example). Using <code>@inbounds</code> will avoid a relatively expensive check that the index <code>i, j, 1</code> is &#39;in bounds&#39;.</p></div></div><h3 id=".-A-random,-spatially-varying,-constant-in-time-temperature-flux-specified-by-an-array"><a class="docs-heading-anchor" href="#.-A-random,-spatially-varying,-constant-in-time-temperature-flux-specified-by-an-array">9. A random, spatially-varying, constant-in-time temperature flux specified by an array</a><a id=".-A-random,-spatially-varying,-constant-in-time-temperature-flux-specified-by-an-array-1"></a><a class="docs-heading-anchor-permalink" href="#.-A-random,-spatially-varying,-constant-in-time-temperature-flux-specified-by-an-array" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs">julia&gt; Nx = Ny = 16;  # Number of grid points.

julia&gt; Q = randn(Nx, Ny); # temperature flux

julia&gt; white_noise_T_bc = FluxBoundaryCondition(Q)
FluxBoundaryCondition: 16×16 Matrix{Float64}</code></pre><p>When running on the GPU, <code>Q</code> must be converted to a <code>CuArray</code>.</p><h2 id="Building-boundary-conditions-on-a-field"><a class="docs-heading-anchor" href="#Building-boundary-conditions-on-a-field">Building boundary conditions on a field</a><a id="Building-boundary-conditions-on-a-field-1"></a><a class="docs-heading-anchor-permalink" href="#Building-boundary-conditions-on-a-field" title="Permalink"></a></h2><p>To create a set of <a href="../../appendix/library/#Oceananigans.BoundaryConditions.FieldBoundaryConditions"><code>FieldBoundaryConditions</code></a> for a temperature field, we write</p><pre><code class="language-julia-repl hljs">julia&gt; T_bcs = FieldBoundaryConditions(top = ValueBoundaryCondition(20),
                                       bottom = GradientBoundaryCondition(0.01))
Oceananigans.FieldBoundaryConditions, with boundary conditions
├── west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── bottom: GradientBoundaryCondition: 0.01
├── top: ValueBoundaryCondition: 20
└── immersed: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)</code></pre><p>If the grid is, e.g., horizontally-periodic, then each horizontal <code>DefaultBoundaryCondition</code> is converted to <code>PeriodicBoundaryCondition</code> inside the model&#39;s constructor, before assigning the boundary conditions to temperature <code>T</code>.</p><p>In general, boundary condition defaults are inferred from the field location and <code>topology(grid)</code>.</p><h2 id="Specifying-model-boundary-conditions"><a class="docs-heading-anchor" href="#Specifying-model-boundary-conditions">Specifying model boundary conditions</a><a id="Specifying-model-boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Specifying-model-boundary-conditions" title="Permalink"></a></h2><p>To specify non-default boundary conditions, a named tuple of <a href="../../appendix/library/#Oceananigans.BoundaryConditions.FieldBoundaryConditions"><code>FieldBoundaryConditions</code></a> objects is passed to the keyword argument <code>boundary_conditions</code> in the <a href="../overview/#Oceananigans.Models.NonhydrostaticModels.NonhydrostaticModel"><code>NonhydrostaticModel</code></a> constructor. The keys of <code>boundary_conditions</code> indicate the field to which the boundary condition is applied. Below, non-default boundary conditions are imposed on the <span>$u$</span>-velocity and temperature.</p><pre><code class="language-julia-repl hljs">julia&gt; topology = (Periodic, Periodic, Bounded);

julia&gt; grid = RectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1), topology=topology);

julia&gt; u_bcs = FieldBoundaryConditions(top = ValueBoundaryCondition(+0.1),
                                       bottom = ValueBoundaryCondition(-0.1));

julia&gt; c_bcs = FieldBoundaryConditions(top = ValueBoundaryCondition(20),
                                       bottom = GradientBoundaryCondition(0.01));

julia&gt; model = NonhydrostaticModel(grid=grid, boundary_conditions=(u=u_bcs, c=c_bcs), tracers=:c)
NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)
├── grid: 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo
├── timestepper: QuasiAdamsBashforth2TimeStepper
├── tracers: c
├── closure: Nothing
├── buoyancy: Nothing
└── coriolis: Nothing

julia&gt; model.velocities.u
16×16×16 Field{Face, Center, Center} on RectilinearGrid on CPU
├── grid: 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo
├── boundary conditions: FieldBoundaryConditions
│   └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Value, top: Value, immersed: ZeroFlux
└── data: 22×22×22 OffsetArray(::Array{Float64, 3}, -2:19, -2:19, -2:19) with eltype Float64 with indices -2:19×-2:19×-2:19
    └── max=0.0, min=0.0, mean=0.0

julia&gt; model.tracers.c
16×16×16 Field{Center, Center, Center} on RectilinearGrid on CPU
├── grid: 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo
├── boundary conditions: FieldBoundaryConditions
│   └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Gradient, top: Value, immersed: ZeroFlux
└── data: 22×22×22 OffsetArray(::Array{Float64, 3}, -2:19, -2:19, -2:19) with eltype Float64 with indices -2:19×-2:19×-2:19
    └── max=0.0, min=0.0, mean=0.0</code></pre><p>Notice that the specified non-default boundary conditions have been applied at top and bottom of both <code>model.velocities.u</code> and <code>model.tracers.c</code>.</p><h2 id="Immersed-boundary-conditions"><a class="docs-heading-anchor" href="#Immersed-boundary-conditions">Immersed boundary conditions</a><a id="Immersed-boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Immersed-boundary-conditions" title="Permalink"></a></h2><p>Immersed boundary conditions are supported experimentally. A no-slip boundary condition is specified by writing</p><pre><code class="language-julia-repl hljs">julia&gt; underlying_grid = RectilinearGrid(size=(32, 32, 16), x=(-3, 3), y=(-3, 3), z=(0, 1), topology=(Periodic, Periodic, Bounded));

julia&gt; hill(x, y) = 0.1 + 0.1 * exp(-x^2 - y^2)
hill (generic function with 1 method)

julia&gt; grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(hill))
32×32×16 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo:
├── immersed_boundary: GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}
├── underlying_grid: 32×32×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo
├── Periodic x ∈ [-3.0, 3.0) regularly spaced with Δx=0.1875
├── Periodic y ∈ [-3.0, 3.0) regularly spaced with Δy=0.1875
└── Bounded  z ∈ [0.0, 1.0]  regularly spaced with Δz=0.0625

julia&gt; velocity_bcs = FieldBoundaryConditions(immersed=ValueBoundaryCondition(0));

julia&gt; model = NonhydrostaticModel(; grid, boundary_conditions=(u=velocity_bcs, v=velocity_bcs, w=velocity_bcs));

julia&gt; model.velocities.w.boundary_conditions.immersed
ImmersedBoundaryCondition:
├── west: ValueBoundaryCondition: 0
├── east: ValueBoundaryCondition: 0
├── south: ValueBoundaryCondition: 0
├── north: ValueBoundaryCondition: 0
├── bottom: Nothing
└── top: Nothing</code></pre><p>An <code>ImmersedBoundaryCondition</code> encapsulates boundary conditions on each potential boundary-facet of a boundary-adjcent cell. Boundary conditions on specific faces of immersed-boundary-adjacent cells may also be specified by manually building <code>ImmersedBoundaryCondition</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; bottom_drag_bc = ImmersedBoundaryCondition(bottom=ValueBoundaryCondition(0))
ImmersedBoundaryCondition:
├── west: Nothing
├── east: Nothing
├── south: Nothing
├── north: Nothing
├── bottom: ValueBoundaryCondition: 0
└── top: Nothing

julia&gt; velocity_bcs = FieldBoundaryConditions(immersed=bottom_drag_bc)
Oceananigans.FieldBoundaryConditions, with boundary conditions
├── west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── bottom: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── top: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
└── immersed: ImmersedBoundaryCondition with west=Nothing, east=Nothing, south=Nothing, north=Nothing, bottom=Value, top=Nothing</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../buoyancy_and_equation_of_state/">« Buoyancy models and equation of state</a><a class="docs-footer-nextpage" href="../forcing_functions/">Forcing functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Thursday 28 April 2022 23:48">Thursday 28 April 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
